        SingleRemoveArg.pObject = pNames[i];
                    DirRemoveEntry(&SingleRemoveArg, &pSingleRemoveRes );

                    THFreeEx(pTHS, pNames[i]);
                    THFreeEx(pTHS, pSingleRemoveRes);
                    THFreeEx(pTHS, SingleRemoveArg.pResObj);
                    pSingleRemoveRes = NULL;

                    if (fWrapped) {
                        if (i == iLastName) {
                            // ok, last entry was deleted, done.
                            break;
                        }
                        else if (i == 0) {
                            // need to wrap around
                            i = cNamesMax;
                        }
                    }
                    else {
                        // not wrapped
                        if (i == 0) {
                            // last entry (first in the array) was deleted, done.
                            break;
                        }
                    }
                }
            }
            __finally {
                pTHS->fDeletingTree = FALSE;
            }
        }
    }
    __finally {
        if(fLockedDN) {
            DBUnlockStickyDN (pRemoveArg->pResObj->pObj);
        }
    }

    if(!pTHS->errCode && !bWholeTree) {
        // We finished off the deletions we knew about, but we didn't delete the
        // root of the tree.
        SetSvcErrorEx(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,
                      DIRERR_TREE_DELETE_NOT_FINISHED,
                      pTHS->errCode);
    }

    return pTHS->errCode;
}

/*++ DirProtectEntry
 *
 * This routine, callable only by in-process clients, registers an object as
 * being undeletable on this DSA.  The registration lasts only for the current
 * boot cycle (i.e., it must be renewed each time the DSA starts), and is
 * effective only on this DSA.  That is, these objects can still be deleted
 * on other DSAs in the enterprise, but when that deletion replicates to this
 * server it will be rejected and the object re-animated.
 *
 * Note that the ancestors of the protected object are also protected. The ancestors
 * are automatically recalculated if the protected object is moved.
 *
 * INPUT:
 *   pObj - name of object to be protected from deletion
 * RETURN VALUE:
 *   0 on success, error in pTHS->errCode if the object could not be found
 */
ULONG
DirProtectEntry(DSNAME *pObj)
{
    THSTATE *pTHS;
    COMMARG CommArg;
    COMMRES CommRes;
    RESOBJ  *pResObj;
    ULONG   *pDNTs, *pOld;
    unsigned i;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ULONG UnDelAncNum, *pUnDelAncDNTs, *pOldUnDelAncDNTs = NULL;

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {
        __try {
            if (eServiceShutdown) {
                ErrorOnShutdown();
                __leave;
            }

            SYNC_TRANS_READ();

            InitCommarg(&CommArg);
            // We can't protect what we can't write, so no copies allowed
            CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               0,
                               pObj,
                               &CommArg,
                               &CommRes,
                               &pResObj)) {
                // Got the object, so add it
                pOld = NULL;
                EnterCriticalSection(&gAnchor.CSUpdate);
                __try {
                    pDNTs = malloc((gAnchor.UnDeletableNum + 1) * sizeof(ULONG));
                    if (!pDNTs) {
                        SetSysError(ENOMEM, ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    for (i=0; i< gAnchor.UnDeletableNum; i++) {
                        if (gAnchor.pUnDeletableDNTs[i] == pResObj->DNT) {
                            // Already present
                            pOld = pDNTs;
                            __leave;
                        }
                        else {
                            pDNTs[i] = gAnchor.pUnDeletableDNTs[i];
                        }
                    }
                    pDNTs[gAnchor.UnDeletableNum] = pResObj->DNT;

                    // Update anchor atomically
                    pOld = gAnchor.pUnDeletableDNTs;
                    gAnchor.pUnDeletableDNTs = pDNTs;
                    gAnchor.UnDeletableNum++;

                    // Update undeletable ancestors
                    if (ERROR_SUCCESS ==
                        MakeProtectedAncList( gAnchor.pUnDeletableDNTs,
                                              gAnchor.UnDeletableNum,
                                              &pUnDelAncDNTs,
                                              &UnDelAncNum )) {

                        pOldUnDelAncDNTs = gAnchor.pUnDelAncDNTs;

                        // Order updates against other readers
                        if (gAnchor.UnDelAncNum <= UnDelAncNum) {
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                            gAnchor.UnDelAncNum = UnDelAncNum;
                        }
                        else {
                            gAnchor.UnDelAncNum = UnDelAncNum;
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                        }
                        pUnDelAncDNTs = NULL;
                    }
                }
                __finally {
                    LeaveCriticalSection(&gAnchor.CSUpdate);
                }
                if (pOld) {
                    DELAYED_FREE(pOld);
                }
                if (pOldUnDelAncDNTs) {
                    DELAYED_FREE(pOldUnDelAncDNTs);
                }
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return pTHS->errCode;
}

DWORD
PossiblyMoveDeletedObject (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
/*++
  Description:
      Check to see if any of the exceptions to moving are found.  If not,
      move a deleted object to the deleted object container for the NC it's in.
      Note that if no deleted container is found, this is a no-op.  Further, the
      dblayer routine we call here DOES NOT QUEUE an SD propagation.  This is OK
      since we've already verified that this object has no children, and we've
      already written the default SD.  The dblayer routine fixes the ancestry,
      though.

    NOTE: in the case where we decide not to move the object, or no deleted
    objects container is found, we simply return 0 and do nothing.  We are just
    not moving the object and not returning an error.  We only return an error
    in the case where we decide to move the object, but the move fails.

--*/
{
    NAMING_CONTEXT_LIST *pNCL;
    DWORD dwDeletedContainerDNT;
    ULONG ulSysFlags;
    DWORD err;

    // First, check for the reasons we don't move based on the thread state.
    if(
       // Don't move objects if we're just replicating this deletion.  Only
       // originating deletions move objects
       pTHS->fDRA
       ) {
        return 0;
    }

    // Now, the reasons that we can check in the remove arg.
    if(
        // Don't move objects we're not renaming
          pRemoveArg->fPreserveRDN
        // Don't move NC heads.
       || (IT_NC_HEAD & pRemoveArg->pResObj->InstanceType)) {
        return 0;
    }


    // Finally, check the system flags.
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_SYSTEM_FLAGS,
                           &ulSysFlags,
                           sizeof(ulSysFlags),
                           NULL);
    switch(err) {
    case 0:
        if (ulSysFlags & FLAG_DISALLOW_MOVE_ON_DELETE) {
            // Don't move this one.
            return 0;
        }
        break;

    case DB_ERR_NO_VALUE:
        // No system flags.  Allow the move.
        break;

    default:
        // Something wrong in getting the system flags.  Don't allow the move.
        return 0;
    }

    // OK, we think we can move this object.  See if we can find a destination
    // for the move. Find the deleted objects container for the NC this object
    // is in

    // We shouldn't be deleting things that move during cross domain move.
    // Assert this.
    Assert(!pTHS->fCrossDomainMove );

    pNCL = FindNCLFromNCDNT(pTHS->pDB->NCDNT, TRUE);
    if(pNCL) {
        dwDeletedContainerDNT = pNCL->DelContDNT;
    }
    else {
        dwDeletedContainerDNT = INVALIDDNT;
    }

    if(dwDeletedContainerDNT == INVALIDDNT) {
        // Couldn't find a deleted objects container.  Oh, well, we just don't
        // move this object.  No big deal.
        return 0;
    }

    if(err = DBResetParentByDNT(pTHS->pDB, dwDeletedContainerDNT, FALSE)) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             DIRERR_ILLEGAL_MOD_OPERATION,
                             err);
    }
    return 0;
}


/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_LinkVals(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DBPOS           *pDB;
    ULONG           ulCurrentTag  = 0; // initial key values or state information
    ULONG           ulCurrentValueTag  = 0; // initial key values or state information
    DSTIME          tCurrentTime = 0; // for  DBGetNextDelRecord
    ULONG           err;
    ULONG           dwException, ulErrorCode, dsid;
    PVOID           dwEA;

    DBOpen(&pDB);
    __try {

        //
        // Garbage collect absent values that have expired
        //

        tCurrentTime = 0;
        ulCurrentTag = 0;
        ulCurrentValueTag = 0;

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelLinkVal(pDB,
                                     AgeOutDate,
                                     &tCurrentTime,
                                     &ulCurrentTag,
                                     &ulCurrentValueTag )) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE))
        {
            err = 1;               // in case of exception

            if (err = DBPhysDelLinkVal(pDB, ulCurrentTag, ulCurrentValueTag)) {
                DPRINT( 1, "Failed physically removing value.\n" );

                dsid = 0;
            }

            // TODO: Flush the transaction every 100 values instead of each time
            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }

            if (0 == err) {
                DPRINT(4,"Physically removed value successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                (*pulSuccessCount)++;

                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_GC_REMOVED_OBJECT_VALUE,
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                         NULL);
            }
            else {
                (*pulFailureCount)++;

                LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_GC_FAILED_TO_REMOVE_OBJECT_VALUE,
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                          szInsertInt(err),
                          szInsertUL(dsid),
                          NULL, NULL, NULL, NULL);
            }
            DBTransIn(pDB);
        }
    }
    __finally
    {
        DBClose( pDB, TRUE);
    }
}

/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_EntryTTL(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount,
    IN OUT ULONG    *pulNextSecs
    )
{
    DSNAME          *pDelObj = NULL;
    DBPOS           *pDB = NULL;
    ULONG           err;
    BOOL            fObject;
    ULONG           dwException, ulErrorCode, dsid = 0;
    PVOID           dwEA;
    ATTCACHE        *pAC;
    ULONG           ulNoDelDnt = INVALIDDNT;
    DSTIME          tNoDelTime;
    ULONG           Dnt;
    DSTIME          tCurrentTime = 0;

    DBOpen(&pDB);
    __try {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        pAC = SCGetAttById(pDB->pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE);
        if (!pAC) {
            DPRINT1(0, "SCGetAttById(msDS-Entry-Time-To-Die(= %08x); not found\n",
                    ATT_MS_DS_ENTRY_TIME_TO_DIE);
            __leave;
        }

        // Loop over all DNs of records to be removed; allow for service
        // shutdown and for undeletable records (ulNoDelDnt). Undeletable
        // records are skipped.

        while ((!DBGetNextEntryTTLRecord(pDB,
                                         AgeOutDate,
                                         pAC,
                                         ulNoDelDnt,
                                         &pDelObj,
                                         &tCurrentTime,
                                         &fObject,
                                         pulNextSecs)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            // Dnt of record (in case pDB->DNT is altered by subsequent calls)
            Dnt = pDB->DNT;

            // Assume no problems
            err = 0;

            // Critical object, skip it
            if (fObject && NoDelCriticalObjects(pDelObj, pDB->DNT)) {
                DPRINT( 1, "Failed removing critical object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't lock, skip it. Unlocked by DBTransOut
            else if (fObject && DBLockDN(pDB, DB_LOCK_DN_WHOLE_TREE, pDelObj)) {
                DPRINT( 1, "Failed locking object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't delete; skip it
            // Keep in mind that a successful return doesn't mean it was
            // actually deleted. If it has children, its time is simply
            // adjusted to its child's time + 1 so that it can be
            // successfully deleted later. However, DBPhysDel returns TRUE
            // in this case so that the transaction will be committed.
            else if (DBPhysDel(pDB, FALSE, pAC)) {
                DPRINT( 1, "Failed physically removing object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Are we skipping a previously undeletable record?
            else if (ulNoDelDnt != INVALIDDNT) {
                // If so, stop if we have moved past its expiration time
                if (tNoDelTime != tCurrentTime) {
                    ulNoDelDnt = INVALIDDNT;
                }
            }

            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = (ulErrorCode) ? ulErrorCode : 1;
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");
                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_BASIC,
                             DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                             szInsertDN( pDelObj ),
                             szInsertInt(err),
                             szInsertUL(dsid));
                }
            }
            THFreeEx(pDB->pTHS, pDelObj);
            DBTransIn(pDB);
        }
    } __finally {
        DBClose( pDB, TRUE);
    }
}

/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_DelTime(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DSNAME              *pDelObj = NULL;
    THSTATE             *pTHS = pTHStls;
    ULONG               ulCurrentTag  = 0; // initial key values or state information
    DSTIME              tCurrentTime = 0; // for  DBGetNextDelRecord
    ULONG               err;
    BOOL                fObject;
    ULONG               dwException, ulErrorCode, dsid;
    PVOID               dwEA;

    // The reason we use pTHS->pDB here is that some of our called routines expect it
    Assert( !pTHS->pDB );
    DBOpen(&pTHS->pDB);
    __try {

        // Loop over all DNs of records to be removed; allow for service
        // shutdown

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelRecord(pTHS->pDB,
                                    AgeOutDate,
                                    &pDelObj,
                                    &tCurrentTime,
                                    &ulCurrentTag,
                                    &fObject)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            err = 1;               // in case of exception
            dsid = 0;

            err = DBPhysDel(pTHS->pDB, FALSE, NULL);
            if (err == ERROR_DS_CHILDREN_EXIST) {

                // Move children to lost and found prior to object removal
                // DBMakeCurrent is needed because pDB->NCDNT not set
                if ( (err = DBMakeCurrent(pTHS->pDB)) ||
                     (err = PrePhantomizeChildCleanup(pTHS, TRUE /*fChildrenAllowed*/)) )
                {
                    DPRINT(0,"Garbage Collection child cleanup failed\n" );
                    DbgPrintErrorInfo();
                    THClearErrors();
                }
            } else if (err) {
                DPRINT( 1, "Failed physically removing object.\n" );
            }

            __try {
                DBTransOut(pTHS->pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_BASIC,
                             DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                             szInsertDN( pDelObj ),
                             szInsertInt(err),
                             szInsertUL(dsid));
                }
            }
            THFreeEx(pTHS, pDelObj);
            DBTransIn(pTHS->pDB);
        }
    }
    __finally
    {
        DBClose( pTHS->pDB, TRUE );
    }
}

/*-------------------------------------------------------------------------*/
USHORT
Garb_Collect(
             DSTIME    AgeOutDate )
{
    ULONG   ulSuccessCount = 0;
    ULONG   ulFailureCount = 0;
    ULONG   ulNextSecs = 0;
    DBPOS   *pDB;
    ULONG   dwException, ulErrorCode, dsid;
    PVOID   dwEA;

    DPRINT( 1, "Garbage Collector entered\n" );

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_STARTED,
             NULL,
             NULL,
             NULL);

    __try {
        // collect deleted objects
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_DelTime(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect link vals
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_LinkVals(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect expired dynamic objects (EntryTTL)
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_EntryTTL(DBTime(),
                                  &ulSuccessCount,
                                  &ulFailureCount,
                                  &ulNextSecs);
        }

        // Defrag
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            DBOpen(&pDB);
            __try {
                if (!eServiceShutdown) {
                    DBDefrag(pDB);
                }
            } __finally {
                DBClose( pDB, TRUE);
            }
        }
    } __except(GetExceptionData(GetExceptionInformation(),
                                &dwException,
                                &dwEA,
                                &ulErrorCode,
                                &dsid)) {
        DPRINT3(0, "Garb_Collect() EXCEPTION: %08x (%d) ulErrorCode; %08x dsid\n",
               ulErrorCode, ulErrorCode, dsid);
    }

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_COMPLETED,
             szInsertUL(ulSuccessCount),
             szInsertUL(ulFailureCount),
             NULL);

    DPRINT( 1, "Garbage Collector returning.\n");
    return (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdfind.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdfind.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirGetDomainHandle and DirFindEntry APIs.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <prefix.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <mdlocal.h>                  // MD local definition header
#include <dsatools.h>                 // needed for output allocation
#include <samsrvp.h>                  // to support CLEAN_FOR_RETURN()
#include <sdprop.h>                   // Critical section for adds.
#include <gcverify.h>                 // GC DSNAME verification

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes

// Assorted DSA headers.
#include "objids.h"                   // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                    // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include "filtypes.h"
#define DEBSUB "MDFIND:"              // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include <fileno.h>
#define  FILENO FILENO_MDFIND

BOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL fUseSearchTbl,
        UCHAR Operation,
        ATTRTYP type,
        ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL *pbSkip
        );
DWORD
LocalFind(FINDARG *pFindArg,
          FINDRES *pFindRes);
DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    );



/*++
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
ULONG
DirFindEntry(FINDARG  * pFindArg,
             FINDRES ** ppFindRes)
{
    THSTATE*        pTHS;
    FINDRES *       pFindRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(2,"DirFindEntry entered\n");

    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppFindRes = pFindRes = NULL;

    Assert(pTHS->fDSA || pTHS->fSAM || pTHS->fDRA);
    
    if (eServiceShutdown) {
        ErrorOnShutdown();
        return pTHS->errCode;
    }

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppFindRes = pFindRes = THAllocEx(pTHS, sizeof(FINDRES));
        if (pTHS->errCode) {
            __leave;
        }
        SYNC_TRANS_READ();       /* Set Sync point*/
	__try {
            LocalFind(pFindArg, pFindRes);
	}
	__finally {
	
	    CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pFindRes) {
	pFindRes->CommRes.errCode = pTHS->errCode;
	pFindRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

} /*DirFindEntry*/

/*++ 
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
DWORD
LocalFind(FINDARG *pFindArg,
          FINDRES *pFindRes)
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC;
    DWORD err=0;
    INDEX_VALUE IV;
    ULONG len;
    DWORD FoundDNT = INVALIDDNT;
    ATTRVAL IntVal;
    BOOL     fCheckValue;
    DWORD    cbKey=0;

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_FIND,
                     EVENT_TRACE_TYPE_START,
                     DsGuidFind,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertHex(pFindArg->AttId),
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pAC = SCGetAttById(pTHS, pFindArg->AttId);
    if (!pAC || !(pAC->fSearchFlags & fATTINDEX)) {
        SetAttError(gpRootDN,
                    pFindArg->AttId,
                    (USHORT)(pAC
                             ? PR_PROBLEM_WRONG_MATCH_OPER
                             : PR_PROBLEM_UNDEFINED_ATT_TYPE),
                    NULL,
                    DIRERR_GENERIC_ERROR);
        goto exit;
    }

    // Convert the given arg to internal value

    err = MakeInternalValue(pTHS->pDB,
                      pAC->syntax,
                      &pFindArg->AttrVal,
                      &IntVal);

    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    err = DBSetCurrentIndex(pTHS->pDB,
                            0,
                            pAC,
                            FALSE);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    IV.pvData = IntVal.pVal;
    IV.cbData = IntVal.valLen;
    err = DBSeek(pTHS->pDB,
                 &IV,
                 1,
                 DB_SeekEQ);
    if (err) {
        // No matches
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err); 
        goto exit;
    }
    
    //
    // See if the key was too long.  If it was, then check and return objects
    // must also verify the value of the attribute we're searching on, in
    // addition to the rest of the checks it does.
    //
    
    DBGetKeyFromObjTable(pTHS->pDB, NULL, &cbKey);
    fCheckValue = (cbKey >= DB_CB_MAX_KEY);


    // Set an index range over the given value as we might need to
    // either iterate over the object or move one step further to
    // check for duplicates.

    err = DBSetIndexRange(pTHS->pDB,
                          &IV,
                          1);
    if (err) {
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }



    while (0==err) {


        err = CheckAndReturnObject(pFindArg,
                                   pFindRes,
                                   fCheckValue,
                                   &IntVal,
                                   &FoundDNT);

        if (err)
        {
            // Some other error occured. 
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            goto exit;
        }

        err = DBMove(pTHS->pDB, 
                     FALSE,
                     1);
    }

    if (FoundDNT == INVALIDDNT) {
       // Uh, oh.  We're out of candidates.
       SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                     NULL,
                     DIRERR_UNKNOWN_ERROR,
                     err);
       goto exit;
    }

    Assert(pTHS->errCode == 0);

exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_FIND,
                     EVENT_TRACE_TYPE_END,
                     DsGuidFind,
                     szInsertUL(pTHS->errCode), 
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;
}

/*++
 *  This routine will perform the following operations
 *  1. Check if the currently positioned object is in the right NC
 *  2. Check if the currently positioned object is not deleted
 *     If any of the above fail, return success without setting pFoundDNT
 *  3. Check if no other object has been found before, if so fail
 *  4. If told to, check that the value looked up is equal to the value found.
 *     This solves problems with truncated jet keys.
 *  5. If all is well, retrieve the DSName of the object, set pFoundDNT to the
 *     DNT we found. return a success 
 *  This routine is called by LocalFind, after LocalFind thinks that
 *  it has positioned on an object. 
--*/
DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    )
{
    THSTATE *pTHS=pTHStls;
    ULONG   isdel;
    ULONG   len;
    ULONG   err=0;
    DWORD   DNT;

    // We are positioned on an object at this time

    // Is it in the right NC ?
    if (pTHS->pDB->NCDNT != pFindArg->hDomain) {

        //Nope, do not touch the state of pFoundDNT
        return 0;
    }

    // Check wether it is deleted
    err = DBGetSingleValue(pTHS->pDB,
                   ATT_IS_DELETED,
                   &isdel,
                   sizeof(isdel),
                   NULL);
    if (err) {
        if (DB_ERR_NO_VALUE == err) {
            // Treat having no value the same as being false.
            isdel = 0;
            err = 0;
        }
        else {
            // I don't know what happened, but it isn't good.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            return pTHS->errCode;
        }
    }

    if (0!=isdel) {
       // object is deleted. Return without touch pFoundDNT
       return 0;
    }

    // Good! object is not deleted.  Get it's DNT
    DBGetSingleValue(pTHS->pDB,
                     FIXED_ATT_DNT,
                     &DNT,
                     sizeof(DNT),
                     NULL);

    
    if(fCheckValue && (DNT != *pFoundDNT)) {
        // Need to check that the value is actually a match.
        if(!dbEvalInt(pTHS->pDB,
                      FALSE,
                      FI_CHOICE_EQUALITY,
                      pFindArg->AttId,
                      pIntVal->valLen,
                      pIntVal->pVal,
                      NULL)) {
            // Not really a match
            return 0;
        }
    }


    // Have we found an object before ?
    if ((*pFoundDNT != INVALIDDNT) && (*pFoundDNT != DNT)) {
        // this is a duplicate !
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }
    
    // O.K get the DSNAME and set pFoundDNT to the DNT we've found.
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_OBJ_DIST_NAME,
                      pFindArg->fShortNames?DBGETATTVAL_fSHORTNAME:0,
                      0,
                      &len,
                      (UCHAR**)&pFindRes->pObject);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }

    *pFoundDNT=DNT;

    return(0);
}



/*++
 *  This routine returns a "domain handle" for the specified domain, as needed
 *  by clients of DirFindEntry.  The domain handle is actually just the DNT 
 *  of the NC head, which is therefore the NCDNT of objects in that domain/NC.
 *  We verify that the name passed in is indeed the name of an NC head, but
 *  not that it is the name of a domain (as opposed to being the name of a
 *  non-domain NC, such as the schema NC).
 *
 *  INPUT:
 *     pDomainDN  - pointer to DSNAME of domain for which handle is desired
 *  RETURN VALUE
 *     non-0      - domain handle
 *     0          - name was not that of a domain
 */
DWORD DirGetDomainHandle(DSNAME *pDomainDN)
{
    THSTATE*        pTHS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err, it;
    DWORD handle = 0;


    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {
        SYNC_TRANS_READ();       /* Set Sync point*/
	__try {
            err = DBFindDSName(pTHS->pDB,
                               pDomainDN);
            if (err) {
                __leave;
            }
            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);
            if (!err &&
                (it & IT_NC_HEAD)) {
                handle = pTHS->pDB->DNT;
            }
	}
	__finally {
	
	    CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mddebug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mddebug.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/20/97    Jeff Parham (jeffparh)
                Moved functions over from dscommon to avoid linking
                problems.  (These functions use the core and thus
                are only useful inside executable that also link
                with the core.)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include "debug.h"
#define DEBSUB "MDDEBUG:"

#include <dsconfig.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsevent.h>
#include <ntrtl.h>
#include <fileno.h>
#define  FILENO FILENO_MDDEBUG

DWORD gulHideDSID = DSID_REVEAL_ALL;

//
// We want the following Table both in Free and Checked Build
//
typedef struct
{
    char* ErrStr;
    ULONG ErrNo;
}ERRINFOSTRUCT;


static ERRINFOSTRUCT ProblemTable[]=
{
{"NO_ATTRIBUTE_OR_VAL", PR_PROBLEM_NO_ATTRIBUTE_OR_VAL},
{"INVALID_ATT_SYNTAX", PR_PROBLEM_INVALID_ATT_SYNTAX },
{"UNDEFINED_ATT_TYPE", PR_PROBLEM_UNDEFINED_ATT_TYPE },
{"WRONG_MATCH_OPER", PR_PROBLEM_WRONG_MATCH_OPER},
{"CONSTRAINT_ATT_TYPE", PR_PROBLEM_CONSTRAINT_ATT_TYPE},
{"ATT_OR_VALUE_EXISTS", PR_PROBLEM_ATT_OR_VALUE_EXISTS},
{"NO_OBJECT", NA_PROBLEM_NO_OBJECT},
{"NO_OBJ_FOR_ALIAS", NA_PROBLEM_NO_OBJ_FOR_ALIAS },
{"BAD_ATT_SYNTAX", NA_PROBLEM_BAD_ATT_SYNTAX},
{"ALIAS_NOT_ALLOWED", NA_PROBLEM_ALIAS_NOT_ALLOWED},
{"NAMING_VIOLATION", NA_PROBLEM_NAMING_VIOLATION},
{"BAD_NAME", NA_PROBLEM_BAD_NAME},
{"INAPPROPRIATE_AUTH", SE_PROBLEM_INAPPROPRIATE_AUTH},
{"INVALID_CREDENTS", SE_PROBLEM_INVALID_CREDENTS},
{"INSUFF_ACCESS_RIGHTS", SE_PROBLEM_INSUFF_ACCESS_RIGHTS},
{"INVALID_SIGNATURE", SE_PROBLEM_INVALID_SIGNATURE},
{"PROTECTION_REQUIRED", SE_PROBLEM_PROTECTION_REQUIRED},
{"NO_INFORMATION", SE_PROBLEM_NO_INFORMATION},
{"BUSY", SV_PROBLEM_BUSY},
{"UNAVAILABLE", SV_PROBLEM_UNAVAILABLE},
{"WILL_NOT_PERFORM", SV_PROBLEM_WILL_NOT_PERFORM},
{"CHAINING_REQUIRED", SV_PROBLEM_CHAINING_REQUIRED},
{"UNABLE_TO_PROCEED", SV_PROBLEM_UNABLE_TO_PROCEED},
{"INVALID_REFERENCE", SV_PROBLEM_INVALID_REFERENCE},
{"TIME_EXCEEDED", SV_PROBLEM_TIME_EXCEEDED},
{"ADMIN_LIMIT_EXCEEDED", SV_PROBLEM_ADMIN_LIMIT_EXCEEDED},
{"LOOP_DETECTED", SV_PROBLEM_LOOP_DETECTED},
{"UNAVAIL_EXTENSION", SV_PROBLEM_UNAVAIL_EXTENSION},
{"OUT_OF_SCOPE", SV_PROBLEM_OUT_OF_SCOPE},
{"DIR_ERROR", SV_PROBLEM_DIR_ERROR},
{"NAME_VIOLATION", UP_PROBLEM_NAME_VIOLATION},
{"OBJ_CLASS_VIOLATION", UP_PROBLEM_OBJ_CLASS_VIOLATION},
{"CANT_ON_NON_LEAF", UP_PROBLEM_CANT_ON_NON_LEAF},
{"CANT_ON_RDN", UP_PROBLEM_CANT_ON_RDN},
{"ENTRY_EXISTS", UP_PROBLEM_ENTRY_EXISTS},
{"AFFECTS_MULT_DSAS", UP_PROBLEM_AFFECTS_MULT_DSAS},
{"CANT_MOD_OBJ_CLASS", UP_PROBLEM_CANT_MOD_OBJ_CLASS},
{"unknown problem", 0}};

char * GetProblemString(USHORT problem)
{
    ERRINFOSTRUCT * pEI = ProblemTable;

    while (pEI->ErrNo != problem && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}

static char * pUnknown = "Not in cache!";

#if DBG

void DumpErrorInfo(UCHAR * pDebSub, unsigned line)
{
    UCHAR *pString=NULL;
    DWORD cbString=0;
    if(!CreateErrorString(&pString, &cbString)) {
        // couldn't create an error string
	DebPrint(0,"Unable to create an error info string.\n",
                 pDebSub, line);
    }
    else {
	DebPrint(0,pString,
                 pDebSub, line);
        THFree(pString);
    }
}

#endif /*DBG*/


//
// This is the same function as above except its output goes to a Debugger.
// and is available on Free Builds.
//
void DbgPrintErrorInfo()
{
    UCHAR *pString=NULL;
    DWORD cbString=0;
    if(!CreateErrorString(&pString, &cbString)) {
        // couldn't create an error string
        DbgPrint("Unable to create an error info string.\n");
    }
    else {
        DbgPrint(pString);
        THFree(pString);
    }
}

//
// Create a THAlloc'ed string describing the error in the pTHStls.
// Returns NULL if no string could be created. 
//
BOOL
CreateErrorString(UCHAR **ppBuf, DWORD *pcbBuf)
{
    THSTATE *pTHS = pTHStls;
    PROBLEMLIST *ppl;
    DSA_ADDRESS_LIST *pdal;
    unsigned long u;
    ATTCACHE * pAC;
    char * pName;
    char * pNoError = "No Error.\n";
    char * pString;
    DWORD  cbString = 256;
    DWORD  cbUsedString = 1;
    char   pTempBuff[1024];
    DWORD  cbTempBuff;
    BOOL   fDsidHideOnName = (gulHideDSID >= DSID_HIDE_ON_NAME_ERR) ? TRUE : FALSE;
    BOOL   fDsidHideAll    = (gulHideDSID >= DSID_HIDE_ALL) ? TRUE : FALSE;


    *ppBuf = NULL;
    *pcbBuf = 0;

    if(!pTHS) {
        // No thread state
        return FALSE;
    }
        
    pString = THAlloc(cbString);
    
    if(!pString)
        return FALSE;

    switch(pTHS->errCode) {
    case attributeError:
        if(pTHS->pErrInfo->AtrErr.count) {
            // OK, at least one problem is here.  Use the error from the first
            // problem as the main error to return.
            ppl =  &pTHS->pErrInfo->AtrErr.FirstProblem;
            _snprintf(pTempBuff, 1024,
                      "%08X: AtrErr: DSID-%08X, #%u:\n",
                      ppl->intprob.extendedErr,
                      fDsidHideAll ? 0 : ppl->intprob.dsid,
                      pTHS->pErrInfo->AtrErr.count);
            cbTempBuff = strlen(pTempBuff);
            if(cbTempBuff+cbUsedString > cbString) {
                cbString = 2 * (cbTempBuff + cbUsedString);
                pString = THReAlloc(pString, cbString);
                if(!pString)
                    return FALSE;
                
            }
            
            strcat(pString, pTempBuff);
            cbUsedString += cbTempBuff;
            
            for (u=0; u<pTHS->pErrInfo->AtrErr.count; u++) {
                if (pAC = SCGetAttById(pTHS, ppl->intprob.type)) {
                    pName = pAC->name;
                } else {
                    pName = pUnknown;
                }
                
                if (ppl->intprob.valReturned) {
                    _snprintf(pTempBuff, 1024,
                              "\t%u: %08X: DSID-%08X, problem %u (%s), data %d,"
                              " Att %x (%s):len %u\n",
                              u,
                              ppl->intprob.extendedErr,
			      fDsidHideAll ? 0 : ppl->intprob.dsid,
                              ppl->intprob.problem,
                              GetProblemString(ppl->intprob.problem),
                              ppl->intprob.extendedData,
                              ppl->intprob.type,
                              pName,
                              ppl->intprob.Val.valLen);
                }
                else {
                    _snprintf(pTempBuff, 1024,
                              "\t%u: %08X: DSID-%08X, problem %u (%s), data %d,"
                              " Att %x (%s)\n",
                              u,
                              ppl->intprob.extendedErr,
			      fDsidHideAll ? 0 : ppl->intprob.dsid,
                              ppl->intprob.problem,
                              GetProblemString(ppl->intprob.problem),
                              ppl->intprob.extendedData,
                              ppl->intprob.type,
                              pName);
                }
                
                cbTempBuff = strlen(pTempBuff);
                if(cbTempBuff+cbUsedString > cbString) {
                    cbString = 2 * (cbTempBuff + cbUsedString);
                    pString = THReAlloc(pString, cbString);
                    if(!pString)
                        return FALSE;
                }
                strcat(pString, pTempBuff);
                cbUsedString += cbTempBuff;
                ppl = ppl->pNextProblem;
            }
        } 
        else {
            // No specific problems where set
            _snprintf(pTempBuff, 1024,"00000001: AtrErr: DSID-00000000, #0:\n");
        }
        break;
         
    case nameError:
        _snprintf(pTempBuff, 1024,
                  "%08X: NameErr: DSID-%08X, problem %u (%s), data %d, best"
                  " match of:\n\t'%S'\n",
                  pTHS->pErrInfo->NamErr.extendedErr,
                  fDsidHideOnName ? 0 :pTHS->pErrInfo->NamErr.dsid,
                  pTHS->pErrInfo->NamErr.problem,
                  GetProblemString(pTHS->pErrInfo->NamErr.problem),
                  pTHS->pErrInfo->NamErr.extendedData,
                  pTHS->pErrInfo->NamErr.pMatched->StringName);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case updError:
        _snprintf(pTempBuff, 1024,
                  "%08X: UpdErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->UpdErr.extendedErr,
		  fDsidHideAll ? 0 : pTHS->pErrInfo->UpdErr.dsid,
                  pTHS->pErrInfo->UpdErr.problem,
                  GetProblemString(pTHS->pErrInfo->UpdErr.problem),
                  pTHS->pErrInfo->UpdErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case systemError:
        // Note that problems are from a different space
        _snprintf(pTempBuff, 1024,
                  "%08X: SysErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->UpdErr.extendedErr,
		  fDsidHideAll ? 0 : pTHS->pErrInfo->UpdErr.dsid,
                  pTHS->pErrInfo->UpdErr.problem,
                  strerror(pTHS->pErrInfo->UpdErr.problem),
                  pTHS->pErrInfo->UpdErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case referralError:
        _snprintf(pTempBuff, 1024,
                  "%08X: RefErr: DSID-%08X, data %d, %u access points\n",
                  pTHS->pErrInfo->RefErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->RefErr.dsid,
                  pTHS->pErrInfo->RefErr.extendedData,
                  pTHS->pErrInfo->RefErr.Refer.count);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;

        pdal = pTHS->pErrInfo->RefErr.Refer.pDAL;
        for (u=0; u<pTHS->pErrInfo->RefErr.Refer.count; u++) {
            _snprintf(pTempBuff, 1024,
                      "\tref %u: '%.*S'\n",
                      u+1,
                      pdal->Address.Length/sizeof(WCHAR),
                      pdal->Address.Buffer);

            cbTempBuff = strlen(pTempBuff);
            if(cbTempBuff+cbUsedString > cbString) {
                cbString = 2 * (cbTempBuff + cbUsedString);
                pString = THReAlloc(pString, cbString);
                if(!pString)
                  return FALSE;
            }
            strcat(pString, pTempBuff);
            cbUsedString += cbTempBuff;

            pdal = pdal->pNextAddress;
        }
        break;
        
    case securityError:
        _snprintf(pTempBuff, 1024,
                  "%08X: SecErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->SecErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->SecErr.dsid,
                  pTHS->pErrInfo->SecErr.problem,
                  GetProblemString(pTHS->pErrInfo->SecErr.problem),
                  pTHS->pErrInfo->SecErr.extendedData);
        
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case serviceError:
        _snprintf(pTempBuff, 1024,
                  "%08X: SvcErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->SvcErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->SvcErr.dsid,
                  pTHS->pErrInfo->SvcErr.problem,
                  GetProblemString(pTHS->pErrInfo->SvcErr.problem),
                  pTHS->pErrInfo->SvcErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;

    case 0:
        /* no error */
        cbTempBuff = strlen(pNoError);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pNoError);
        cbUsedString += cbTempBuff;
        break;       
        
    default:
        _snprintf(pTempBuff, 1024,
                "Invalid error code of %u\n",
                pTHS->errCode);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString *= 2;
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
    }

    if(cbUsedString) {
        pString = THReAlloc(pString, cbUsedString);
        if(!pString)
            return FALSE;
        *ppBuf = pString;
        *pcbBuf = cbUsedString;
    }
    else {
        THFree(pString);
    }

    return TRUE;
}

LPSTR
THGetErrorString()
/*++

Routine Description:

    Return error string associated with THSTATE error; free with THFree().
    
    EXPORTED TO EX-MODULE, IN-PROCESS CALLERS.

Arguments:

    None.
    
Return Values:

    Non-NULL error string on success, NULL on failure.

--*/
{
    LPSTR pszError;
    DWORD cbError;

    if (!CreateErrorString(&pszError, &cbError)) {
        pszError = NULL;
    }

    return pszError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdmod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdmod.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirModifyEntry API.

    DirModifyEntry() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h> 
#include <scache.h>                     // schema cache 
#include <prefix.h>                     // prefix table
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header 
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation 
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <gcverify.h>                   // GC DSNAME verification
#include <ntdsctr.h>                    // Perf Hook
#include <dsconfig.h>

// SAM interoperability headers
#include <mappings.h>
                         
// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging 
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes 

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include <permit.h>                     // permission constants 
#include "debug.h"                      // standard debugging header 
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include <filtypes.h>

#define DEBSUB "MDMOD:"                 // define the subsystem for debugging 

#include <fileno.h>
#define  FILENO FILENO_MDMOD

#include <NTDScriptExec.h>

/* MACROS */

/* Internal functions */

int InvalidIsDefunct(IN MODIFYARG *pModifyArg, 
                     OUT BOOL *fIsDefunctPresent,
                     OUT BOOL *fIsDefunct);
int CheckForSafeSchemaChange(THSTATE *pTHS, 
                             MODIFYARG *pModifyArg, 
                             CLASSCACHE *pCC);
int ModSetAtts(THSTATE *pTHS, 
               MODIFYARG *pModifyArg,
               CLASSCACHE **ppClassSch,
               CLASSSTATEINFO  **ppClassInfo,
               ATTRTYP rdnType);

BOOL SysModReservedAtt(THSTATE *pTHS,
                       ATTCACHE *pAC,
                       CLASSCACHE *pClassSch);
int ApplyAtt(THSTATE *pTHS,
             DSNAME *pObj,
             HVERIFY_ATTS hVerifyAtts,
             ATTCACHE *pAC,
             ATTRMODLIST *pAttList,
             COMMARG *pCommArg);
int ModCheckSingleValue (THSTATE *pTHS,
                         MODIFYARG *pModifyArg);
int ModCheckCatalog(THSTATE *pTHS,
                    RESOBJ *pResObj);

BOOL IsValidBehaviorVersionChange(THSTATE * pTHS, 
                                  ATTRMODLIST *pAttrToModify,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  LONG *pNewForestVersion );

DWORD VerifyNoMixedDomain(THSTATE *pTHS, BOOL fDomainOnly);

DWORD forestVersionRunScript(THSTATE *pTHS,DWORD oldVersion, DWORD newVersion);

extern BOOL gfRestoring;


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirModifyEntry(
    MODIFYARG*  pModifyArg,     /* ModifyEntry  argument */
    MODIFYRES** ppModifyRes
    )
{

    THSTATE*     pTHS;
    MODIFYRES *  pModifyRes;
    BOOL           fContinue;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    BOOL  RecalcSchemaNow=FALSE;


    DPRINT1(1,"DirModifyEntry(%ws) entered\n",pModifyArg->pObject->StringName);


    // This operation should not be performed on read-only objects.
    pModifyArg->CommArg.Svccntl.dontUseCopy = TRUE;

    /* Initialize the THSTATE anchor and set a write sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    pTHS->fLazyCommit |= pModifyArg->CommArg.fLazyCommit;
    *ppModifyRes = pModifyRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyRes = pModifyRes = THAllocEx(pTHS, sizeof(MODIFYRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        // GC verification intentially performed outside transaction scope.
        if ( GCVerifyDirModifyEntry(pModifyArg) )
            leave;
        SYNC_TRANS_WRITE();       /* Set Sync point*/
        __try {

            // Inhibit update operations if the schema hasen't been loaded yet
            // or if we had a problem loading.

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_SCHEMA_NOT_LOADED);
                goto ExitTry;
            }

            // Perform name resolution to locate object.  If it fails, just 
            // return an error, which may be a referral. Note that we must
            // demand a writable copy of the object.
            pModifyArg->CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               0,
                               pModifyArg->pObject,
                               &pModifyArg->CommArg,
                               &pModifyRes->CommRes,
                               &pModifyArg->pResObj)){

                /* Local Modify operation */
           
                if ( (0 == SampModifyLoopbackCheck(pModifyArg, &fContinue)) &&
                    fContinue ) {
                    LocalModify(pTHS, pModifyArg);
                }
            }

          ExitTry:;
        }
        __finally {
            if (pTHS->errCode != securityError) {
                /* Security errors are logged separately */
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ? 
                            DS_EVENT_SEV_EXTENSIVE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ? 
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pModifyArg->pObject),
                         NULL,
                         FILENO);
            }

            // Check if we need to enque an immediate schema update or not.
            if (pTHS->errCode==0 && pTHS->RecalcSchemaNow)
            {
                RecalcSchemaNow = TRUE;
            }

            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pModifyRes) {
        pModifyRes->CommRes.errCode = pTHS->errCode;
        pModifyRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    if (RecalcSchemaNow)
    {
        SCSignalSchemaUpdateImmediate();
        //
        // [rajnath][4/22/1997]: This will be the place to 
        // syncronize this call with the completion of the schema
        // cache update using an event which is set by the above 
        // call.
        //
    }

    return pTHS->errCode;

} /*DirModifyEntry*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Find the base object.  If the object already exists or if the object
   name has a syntax problem, return an error.
*/

int LocalModify(THSTATE *pTHS, MODIFYARG *pModifyArg){

    CLASSCACHE     *pClassSch;
    PROPERTY_META_DATA_VECTOR *pMetaData = NULL;
    USN usnChange;
    int aliveStatus;
    ULONG ulRet;
    ULONG iClass, LsaClass=0;
    DWORD ActiveContainerID=0;
    BOOL  RoleTransferInvolved;
    BOOL  SamClassReferenced;
    DOMAIN_SERVER_ROLE NewRole;
    DWORD dwMetaDataFlags = META_STANDARD_PROCESSING;
    ULONG cModAtts;
    ATTRTYP *pModAtts = NULL;
    ULONG err;
    BOOL fCheckSPNValues = FALSE;
    BOOL fCheckDNSHostNameValues = FALSE;
    BOOL fCheckAdditionalDNSHostNameValues = FALSE;
    CLASSSTATEINFO  *pClassInfo = NULL;
    ATTRTYP rdnType;

    DPRINT(2,"LocalModify entered \n");

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    Assert(pModifyArg->pResObj);

    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_MODIFY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidModify,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pModifyArg->pObject),
                     NULL, NULL, NULL, NULL, NULL, NULL);

    // Verify write rights for all attributes being modified.
    if (CheckModifySecurity(pTHS,
                         pModifyArg,
                         &fCheckDNSHostNameValues,
                         &fCheckAdditionalDNSHostNameValues,
                         &fCheckSPNValues)) {
        goto exit;
    }

    // Determine object's class by checking attributes offered
    // (replication only) or reading from object in database.
    if (!(pClassSch = SCGetClassById(pTHS, 
                                     pModifyArg->pResObj->MostSpecificObjClass))){
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           ERROR_DS_OBJECT_CLASS_REQUIRED);
        goto exit;

    }

    // Check if the class is defunct. We don't allow
    // modification of instances of defunct classes, except for DRA 
    // or DSA thread
    if ((pClassSch->bDefunct)  && !pTHS->fDRA && !pTHS->fDSA) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           ERROR_DS_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    // Don't allow modifications to Lost And Found containers
    if ((CLASS_LOST_AND_FOUND == pClassSch->ClassId) && !pTHS->fDRA && !pTHS->fSDP)
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // Don't allow modification to the subschema object
    if ((CLASS_SUBSCHEMA == pClassSch->ClassId) 
        && !pTHS->fDRA 
        && !pTHS->fDSA 
        && !pTHS->fSDP 
        && !gAnchor.fSchemaUpgradeInProgress)
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // Don't allow modifications to tombstones, except if target is a
    // DeletedObjects container (e.g. to allow SD to be set) or if caller is
    // the replicator.
    if (pModifyArg->pResObj->IsDeleted && !pTHS->fDRA) {
        NAMING_CONTEXT_LIST *pNCL;
         
        pNCL = FindNCLFromNCDNT(pModifyArg->pResObj->NCDNT, TRUE);
        if ((NULL == pNCL)
            || (pModifyArg->pResObj->DNT != pNCL->DelContDNT)) {
            // Not a modification of the DeletedObjects container.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_ILLEGAL_MOD_OPERATION);
        }
    }

#ifndef DBG // leave a back door for checked build

    // Only LSA can modify TrustedDomainObject and SecretObject
    if (!SampIsClassIdAllowedByLsa(pTHS, pClassSch->ClassId))
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

#endif // ifndef

    // Check to see if this is an update in an active container

    // Since the schema container object itself doesn't belong
    // to any active container, we should make sure to set the
    // thread state's SchemaUpdate field appropriately for this
    // in case this is the DRA thread, since it may hold a wrong value
    // from a previous schema object add/modify (since for DRA, the
    // entire schema NC is replicated in one thread state), which can cause
    // it to go in for schema validation etc. which should not be done
    // for schema container object itself

    if (pTHS->fDRA && (pModifyArg->pResObj->DNT==gAnchor.ulDNTDMD) ) {
        pTHS->SchemaUpdate = eNotSchemaOp;
    }

    CheckActiveContainer(pModifyArg->pResObj->PDNT, &ActiveContainerID);
    
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(
                pTHS,
                ACTIVE_CONTAINER_FROM_MOD,
                pModifyArg->pObject,
                pClassSch,
                ActiveContainerID)) {
            goto exit;
        }
    }

    // if this is a schema update, we need to check various
    // things to ensure that schema updates are upward compatible

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
       err = CheckForSafeSchemaChange(pTHS, pModifyArg, pClassSch);
       if (err) {
          // not an allowed change. Error code is set in
          // thread state already, just leave
          goto exit;
       }

        // Signal a urgent replication. We want schema changes to
        // replicate out immediately to reduce the chance of a schema
        // change not replicating out before the Dc where the change is
        // made crashes

        pModifyArg->CommArg.Svccntl.fUrgentReplication = TRUE;
    }

    // If it is a schema object modification, we need to check if
    // Is-Defunct is the attribute being modified. If yes, we need
    // an additional check (Is-Defunct can be the only attribute
    // in the modifyarg) and reset type of schema operation
    // appropriately for subsequent schema validations
    // (since setting Is-Defunct to TRUE on a non-defunt schema 
    // object is really a delete and setting it to FALSE or removing 
    // it on a defunct object is really an add as far as their 
    // effects on further schema updates go)
    // [ArobindG: 10/28/98]: Merge this code into 
    //                              CheckForSafeSchemaChange in future
    
    // DSA and DRA threads are exempt from this check

    if ((pTHS->SchemaUpdate!=eNotSchemaOp) && 
              !pTHS->fDRA && !pTHS->fDSA) {

        ULONG err = 0;
        BOOL fObjDefunct = FALSE, fIsDefunctPresent = FALSE, fIsDefunct = FALSE;

        // Check if the object is currently defunct or not
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DEFUNCT, &fObjDefunct,
                             sizeof(fObjDefunct), NULL); 

        switch (err) {

          case DB_ERR_NO_VALUE:
             // Value does not exist. Object is not defunct.
              fObjDefunct = FALSE;
              break;
          case 0:
             // Value exists. fObjDefunct is set to the value already
              break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
              goto exit;
        } /* switch */

        // If Is-Defunct is there on the modifyarg, it should be the
        // only one in there. Otherwise, raise appropriate error 
        // depending on if the object is currently defunct or not

        if (InvalidIsDefunct(pModifyArg, &fIsDefunctPresent, &fIsDefunct)) {
            // Is-Defunct is there in the modifyarg, and 
            // it is not the only one
            if (fObjDefunct) {
                // Defunct object. Set object_not_found error
                SetNamError(NA_PROBLEM_NO_OBJECT, NULL,
                            ERROR_DS_OBJ_NOT_FOUND);
                goto exit;
            }
            else {
                // Object is not defunct. Set illegal_modify error
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_MOD_OPERATION);
                goto exit;
            }
        }

        // Either Is-Defunct is not there on the modifyarg, or it
        // is the only one there. If it is not there, we are done
        // and let things go on for usual modification, provided
        // the object is not defunct
        //
        // Modifying defunct schema objects is allowed after
        // schema-reuse is enabled

        if (!fIsDefunctPresent 
            && fObjDefunct && !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
               SetNamError(NA_PROBLEM_NO_OBJECT, NULL,
                           ERROR_DS_OBJ_NOT_FOUND);
               goto exit;
        }               

        // If Is-Defunct is there, reset type of schema update 
        // appropriately to ensure that proper schema validation 
        // checks occur at the end. Note that the call to
        // InvalidIsDefunct sets fIsDefunctPresent correctly on success

        if (fIsDefunctPresent) {
            if (fObjDefunct && !fIsDefunct) {
                // changing state to not-defunct. Do validations for add.
                if (pTHS->SchemaUpdate == eSchemaClsMod) {
                    pTHS->SchemaUpdate = eSchemaClsAdd;
                }
                else if (pTHS->SchemaUpdate == eSchemaAttMod) {
                    pTHS->SchemaUpdate = eSchemaAttAdd;
                }
            }
            else if (!fObjDefunct && fIsDefunct) {
                // changing state to defunct. Do validations for delete.
                if (pTHS->SchemaUpdate == eSchemaClsMod) {
                    pTHS->SchemaUpdate = eSchemaClsDel;
                }
                else if (pTHS->SchemaUpdate == eSchemaAttMod) {
                    pTHS->SchemaUpdate = eSchemaAttDel;
                }
            } // else not changing state; validate as regular schema mod
        }

        // All set. Go on with rest of modification as usual
    }

    /* Set the dwMetaDataFlags appropriately */
    if (pModifyArg->CommArg.Svccntl.fAuthoritativeModify)
    {
        Assert(gfRestoring); // currently fAuthoritativeModify
                             // should be specified only by HandleRestore()                             

        dwMetaDataFlags |= META_AUTHORITATIVE_MODIFY;
    }
    
    /* The order of these validations are important */

    if ( // get the object's rdnType
         GetObjRdnType(pTHS->pDB, pClassSch, &rdnType)
            ||
         // Verify schema restrictions and modify each attribute in database.
         ModSetAtts(pTHS, pModifyArg, &pClassSch, &pClassInfo, rdnType)
            ||
         // Verify Single-Value constraints are being met.
         ModCheckSingleValue(pTHS, pModifyArg)
            ||
         // Grab the meta data for use below
         ((err = DBMetaDataModifiedList(pTHS->pDB, &cModAtts, &pModAtts))
          && SetSvcError(SV_PROBLEM_DIR_ERROR, err))
            ||
         // 
         ValidateSPNsAndDNSHostName(pTHS,
                                    pModifyArg->pObject,
                                    pClassSch,
                                    fCheckDNSHostNameValues,
                                    fCheckAdditionalDNSHostNameValues,
                                    fCheckSPNValues,
                                    FALSE)
            ||
         // Insure all mandatory attributes are present and all others
         // are allowed.
         ValidateObjClass(pTHS, 
                          pClassSch,
                          pModifyArg->pObject,
                          cModAtts,
                          pModAtts,
                          &pClassInfo)
            ||
         (pClassInfo && ModifyAuxclassSecurityDescriptor (pTHS, 
                                                          pModifyArg->pObject, 
                                                          &pModifyArg->CommArg,
                                                          pClassSch, 
                                                          pClassInfo,
                                                          NULL))
            ||
         // Insert the object into the database for real.
         InsertObj(pTHS,
                   pModifyArg->pObject, 
                   pModifyArg->pMetaDataVecRemote,
                   TRUE,
                   dwMetaDataFlags))
    {
        goto exit;
    }

    // Note, the two special LOST AND FOUND containers in the Config and Schema
    // NCs are now protected from rename and detete via special system flags.
    // There are no longer any special checks at this point, other than above.

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
        //
        // On Schema updates we want to resolve conflicts, and we want to
        // do so without losing database currency, which would cause operations
        // a few lines below to fail.
        
        ULONG dntSave = pTHS->pDB->DNT;

        // write any new prefixes that were added by this thread
        // to the schema object

        if (WritePrefixToSchema(pTHS))
        {
            goto exit;
        }
        if (!pTHS->fDRA) {        
            if (ValidSchemaUpdate()) {
                goto exit;
            }
            if (WriteSchemaObject()) {
                goto exit;
            }
            
            //log the schema change
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DSA_SCHEMA_OBJECT_MODIFIED, 
                     szInsertDN(pModifyArg->pObject),
                     0, 0);
        }

        // Now restore currency
        DBFindDNT(pTHS->pDB, dntSave);
    }

    // If this is not a schema update, but a new prefix is created,
    // flag an error and bail out

    if (!pTHS->fDRA &&
        pTHS->SchemaUpdate == eNotSchemaOp &&
        pTHS->NewPrefix != NULL) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_SECURITY_ILLEGAL_MODIFY);
        goto exit;
    }


    if (   ModCheckCatalog(pTHS, pModifyArg->pResObj)
        ||
        ModObjCaching(pTHS, 
                      pClassSch,
                      cModAtts,
                      pModAtts,
                      pModifyArg->pResObj))
    {
        goto exit;
    }

  
    //
    // If We are the DRA we need to inform SAM and NetLogon of replicated in
    // changes to SAM objects to support downlevel replication
    // Also, if this isn't a Sam or Lsa started transaction, we'll potentially
    // need to notify Lsa. Also if a role transfer ( PDC or BDC) is involved by
    // any means we must inform the new role to SAM , LSA and netlogon
    //


    if( DsaIsRunning() ) {
        RoleTransferInvolved = SampIsRoleTransfer(pModifyArg,&NewRole);
        SamClassReferenced   = SampSamClassReferenced(pClassSch,&iClass);
        
        if ((SamClassReferenced && RoleTransferInvolved)
            //Sam class + Role Transfer
            // Or Sam Class and Sam attribute modified by LSA or DRA
            ||( SamClassReferenced
               &&(SampSamReplicatedAttributeModified(iClass,pModifyArg)))) 
            {
                
                if (SampAddToDownLevelNotificationList(
                        pModifyArg->pObject,
                        iClass,
                        LsaClass,
                        SecurityDbChange,
                        SampIsMixedModeChange(pModifyArg),
                        RoleTransferInvolved,
                        NewRole) )
                {
                    // 
                    // the above routine failed
                    //
                    goto exit;
                }
            }

        if (SampIsClassIdLsaClassId(pTHS,
                                    pClassSch->ClassId,
                                    cModAtts,
                                    pModAtts,
                                    &LsaClass)) {
            if ( SampAddToDownLevelNotificationList(
                    pModifyArg->pObject,
                    iClass,
                    LsaClass,
                    SecurityDbChange,
                    FALSE,
                    FALSE,
                    NewRole) )
            {
                //
                // the above routine failed
                //
                goto exit;
            }
        }
    }

    if (!pTHS->fDRA) {
        // Only notify replicas if this is not the DRA thread. If it is, then
        // we will notify replicas near the end of DRA_replicasync. We can't
        // do it now as NC prefix is in inconsistent state
           
        // Currency of DBPOS must be at the target object
        DBNotifyReplicasCurrDbObj(pTHS->pDB,
                            pModifyArg->CommArg.Svccntl.fUrgentReplication);
    }

exit:
    if (pModAtts) {
        THFreeEx(pTHS, pModAtts);
    }
    
    if (pClassInfo) {
        ClassStateInfoFree (pTHS, pClassInfo);
        pClassInfo = NULL;
    }

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_MODIFY,
                     EVENT_TRACE_TYPE_END,
                     DsGuidModify,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;  /*incase we have an attribute error*/

}/*LocalModify*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check the modifyarg to see what schema changes are attempted. We will allow
   only certain changes in order to ensure that the schema is upward compatible

   Returns 0 if all goes well, or an error code (also set in
   thread state) if any of the tests fail
*/

int CheckForSafeSchemaChange(THSTATE *pTHS, 
                             MODIFYARG *pModifyArg, 
                             CLASSCACHE *pCC)
{

    ULONG err=0, sysFlags, governsId;
    BOOL  fBaseSchemaObj = FALSE, fSaveCopy = FALSE, fDefunct;
    ULONG count;
    ATTRMODLIST  *pAttList=NULL;
    ATTR      attrInf;

    // exempt fDSA, fDRA, install, and if the special registry flag to allow all changes
    // is set
   
    if (pTHS->fDSA 
        || pTHS->fDRA 
        || DsaIsInstalling() 
        || gAnchor.fSchemaUpgradeInProgress) {
       return 0;
    }    

    // otherwise, do the tests

    // Check if we are modifying the class-schema, attribute-schema, or
    // the subschema class objects. No modifications are allowed on them
    // to ensure that replication of the schema container itself never fails
    // with a schema mismatch

    if (pCC->ClassId == CLASS_CLASS_SCHEMA) {
        // Get the governs-id on the object.
        err = DBGetSingleValue(pTHS->pDB, ATT_GOVERNS_ID, &governsId,
                               sizeof(governsId), NULL);

        // value must exist
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
            goto exit;
        }

        switch (governsId) {
           case CLASS_ATTRIBUTE_SCHEMA:
           case CLASS_CLASS_SCHEMA:
           case CLASS_SUBSCHEMA:
           case CLASS_DMD:
               // no mods are allowed on these class-schema objects
               SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
               goto exit;
           default:
               ;
        }
    }

    // if class is Top, don't allow any mod at all except to
    // add backlinks as mayContains.
   
    fSaveCopy = FALSE;
    if ( (pCC->ClassId == CLASS_CLASS_SCHEMA) && (governsId == CLASS_TOP) ) {
        pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
        for (count = 0; !(pTHS->errCode) && (count < pModifyArg->count); count++){
            attrInf = pAttList->AttrInf;
            switch (attrInf.attrTyp) {
                case ATT_MAY_CONTAIN:
                case ATT_AUXILIARY_CLASS:
                    // this may add backlinks, save for checks later
                    fSaveCopy = TRUE;
                    break;
                default:
                    // no other change is permitted
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
                    break;
             } 
        }
        if (pTHS->errCode) {
            goto exit;
        }
        else {
            goto saveCopy;
        }
    }

    // For other schema objects, do selective tests below 

    // Find the systemFlag value on the object, if any
    // to determine is this is a base schema object

    err = DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &sysFlags,
                           sizeof(sysFlags), NULL);

    switch (err) {

          case DB_ERR_NO_VALUE:
             // Value does not exist. Not a base schema object
             fBaseSchemaObj = FALSE;
             break;
          case 0:
             // Value exists. Check the bit 
             if (sysFlags & FLAG_SCHEMA_BASE_OBJECT) {
                fBaseSchemaObj = TRUE;
             }
             else {
                fBaseSchemaObj = FALSE;
             } 
             break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
              goto exit;
    } /* switch */

    // Now go through the modifyarg to see what is being changed

    fSaveCopy = FALSE;
    pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
    for (count = 0; !(pTHS->errCode) && (count < pModifyArg->count); count++){
        attrInf = pAttList->AttrInf;
        switch (attrInf.attrTyp) {
            case ATT_MUST_CONTAIN:
                // remember to save a current copy of the class from the db
                // in the threadstate so that it can be compared later
                // with the updated copy (We can simply fail this here, but we have 
                // take care of the weird cases when someone added/deleted or replaced
                // with the same value in a single modifyarg
                fSaveCopy = TRUE;
                break;
            case ATT_IS_DEFUNCT:
            case ATT_RANGE_LOWER:
            case ATT_RANGE_UPPER:
            case ATT_ATTRIBUTE_SECURITY_GUID:
            case ATT_LDAP_DISPLAY_NAME:
            case ATT_DEFAULT_OBJECT_CATEGORY:
                // no change allowed on these on base schema objects
                if (fBaseSchemaObj) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
                }
                break;
            case ATT_AUXILIARY_CLASS:
                // need to compare old with new later to see if this adds 
                // new must-contains 

                fSaveCopy = TRUE;  
                break; 
            default:
                // allow arbitrary change
                break;
                   
        }  /* switch */

        // check if error raised
        if (pTHS->errCode) {
            goto exit;
        }

        pAttList = pAttList->pNextMod;   /*Next mod*/

    } /* for */


    // No error raised. Check if something in the modifyarg asked for a saved copy

saveCopy:
    if (fSaveCopy) {
        // check class, as SCBuildCCEntry will fail otherwise 
        if (pCC->ClassId != CLASS_CLASS_SCHEMA) {
             // not a class schema
             SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
             goto exit;

        }
        err = 0;
        err = SCBuildCCEntry(NULL, &((CLASSCACHE *)(pTHS->pClassPtr)));
        if (err) {
            // thread state error should already be set
            Assert(pTHS->errCode);
        }
    }

exit:
    return (pTHS->errCode);

}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check the modifyarg to see if the Is-defunct attribute is present.
   If it is, it should be the only one present in the modifyarg. This
   routine is called only on a schema modification

   Returns 0 if the modifyarg is valid (that is, either the Is-Defunct 
   attribute is not in it, or Is-defunct is the only attribute in 
   it), non-0 otherwise. If the modifyarg is valid, sets fIsDefunctPresent
   to TRUE or FALSE depending on whether the Is-Defunct attribute is 
   there or not respectively
*/

int InvalidIsDefunct(
    IN  MODIFYARG *pModifyArg, 
    OUT BOOL *fIsDefunctPresent,
    OUT BOOL *fIsDefunct)
{
    ULONG count;
    ATTRMODLIST  *pAttList=NULL;
    ATTRTYP      attType;
    BOOL found = FALSE;

    // assume Is-Defunct is not present in the modifyarg.
    *fIsDefunctPresent = FALSE;
    *fIsDefunct = FALSE;

    pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
    for (count = 0; !found && count < pModifyArg->count; count++){
        attType = pAttList->AttrInf.attrTyp;
        if (attType == ATT_IS_DEFUNCT) {
            // If properly formatted, return new value for isDefunct.
            // Other code will error out if value is badly formatted.
            if (pAttList->AttrInf.AttrVal.valCount == 1
                && pAttList->AttrInf.AttrVal.pAVal->valLen == sizeof (BOOL)) {
                memcpy(fIsDefunct, 
                       pAttList->AttrInf.AttrVal.pAVal->pVal, sizeof (BOOL)); 
            }
            *fIsDefunctPresent = TRUE;
            // must be the only modification (why?)
            return (pModifyArg->count != 1);
        }
        pAttList = pAttList->pNextMod;   /*Next mod*/
    }
    // isDefunct is not present; okay to go
    return 0;
} /*InvalidIsDefunct*/

// Checks to see if changing partial set membership of an
// attribute is illegal; Returns TRUE if illegal.
BOOL SysIllegalPartialSetMembershipChange(THSTATE *pTHS)
{
    // assume the currency is already on the attribute schema of interest
    ULONG ulSystemFlags;

    // We shouldn't allow users to touch the partial set membership of an
    // attribute if:
    //  1) the attribute is not replicated
    //  2) the attribute is a member of the system default partial set
    if ((DB_success == DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, 
                            &ulSystemFlags, sizeof(ulSystemFlags), NULL))
        &&  ((ulSystemFlags & FLAG_ATTR_NOT_REPLICATED)
             || (ulSystemFlags & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER)))
    {      
        return TRUE;
    }
    
    return FALSE;

} /* SysIllegalPartialSetMembershipChange */


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if the modification to the behavior version attribute is legal or
   not.  The behavior version attribute is not allowed to decrease.  The 
   behavior version of a domain must be less than or equal to the behavior
   version of all the dsa's in the domain; The behavior version of the forest
   must be less than or equal to the behavoir version of all dsa's in the
   forest.
   
   Return false if the contraints are violated or any other error occurs;
   return true if the modification is legal.
   
   Upon success, pNewForestVersion will be assigned to the new forest version
   if the forest version is changed, and unchanged otherwise.
*/
BOOL IsValidBehaviorVersionChange(THSTATE * pTHS, 
                                  ATTRMODLIST *pAttrToModify,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  LONG *pNewForestVersion )
{
    DWORD err;
    FILTER ObjCategoryFilter, DomainFilter, AndFilter, VersionFilter, NotFilter;
    LONG lNewVersion;
    BOOL fDSASave;
    DBPOS *pDBSave;

    BOOL fDomain;

    CLASSCACHE *pCC;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(2, "IsValidBehaviorVersionChange entered\n");

    Assert(pAttrToModify);
    Assert(pAttrToModify->AttrInf.attrTyp==ATT_MS_DS_BEHAVIOR_VERSION);

    //only add and replace operations are allowed
    if (    pAttrToModify->choice != AT_CHOICE_ADD_ATT
         && pAttrToModify->choice != AT_CHOICE_ADD_VALUES
         && pAttrToModify->choice != AT_CHOICE_REPLACE_ATT ) {
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, invalid operation.\n");
        SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                     ERROR_DS_ILLEGAL_MOD_OPERATION );
        return FALSE;
    }

    Assert(pAttrToModify->AttrInf.AttrVal.valCount);

    //The new value for ms-ds-behavior-version
    lNewVersion = (LONG)*(pAttrToModify->AttrInf.AttrVal.pAVal->pVal);

    //preliminary check
    if (NameMatched(gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
        //the object is current domainDNS
        if (lNewVersion <= gAnchor.DomainBehaviorVersion) {
            //decrement is not allowed
            DPRINT2(2, "IsValidBehaviorVersionChange returns FALSE, the new value(%d) <= old value (%d)\n", 
                    lNewVersion, gAnchor.DomainBehaviorVersion);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_MOD_OPERATION );
            return FALSE;
        }
        fDomain = TRUE;

    }
    else if (NameMatched(gAnchor.pPartitionsDN,pModifyArg->pResObj->pObj)) {
        // the object is crossrefContainer
        if (lNewVersion <= gAnchor.ForestBehaviorVersion) {
            //decrement is not allowed
            DPRINT2(2, "IsValidBehaviorVersionChange returns FALSE, the new value(%d) <= old value (%d)\n", 
                    lNewVersion, gAnchor.ForestBehaviorVersion);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_MOD_OPERATION );
            return FALSE;
        }
        fDomain = FALSE;
    }
    else {
        //only the msDs-Behavior-Version of current domainDNS and crossRefContainer
        //objects is allowed to change
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, invalid object type\n");
        SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                     ERROR_DS_ILLEGAL_MOD_OPERATION );
        return FALSE;
        
    }

    //check if it is the FSMO role holder
    err = CheckRoleOwnership( pTHS,
                              fDomain?(gAnchor.pDomainDN):(gAnchor.pDMD),
                              pModifyArg->pResObj->pObj );

    if (err) {
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, not FSMO role holder\n");
        return FALSE;
               
    }

    //save current DBPOS etc
    fDSASave = pTHS->fDSA;
    pDBSave  = pTHS->pDB;

    pTHS->fDSA = TRUE;  //suppress checks

    __try {

        //open another DBPOS
        pTHS->pDB = NULL;
        DBOpen(&(pTHS->pDB));

        __try {

            // When the forest/domain version is raised from a value less than 2
            // (DS_BEHAVIOR_WHISTLER) to 2 or greater, we will check if all the domains
            // or current domain are in native mode

            if ( lNewVersion >= DS_BEHAVIOR_WHISTLER
                 && ((fDomain?gAnchor.DomainBehaviorVersion:gAnchor.ForestBehaviorVersion)<DS_BEHAVIOR_WHISTLER))
            {

                err = VerifyNoMixedDomain(pTHS,fDomain);

                if (err) {
                    __leave;
                }
            } 

            //initialize SearchArg
            memset(&SearchArg,0,sizeof(SearchArg));
            SearchArg.pObject = gAnchor.pConfigDN;
            SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
            SearchArg.bOneNC  = TRUE;

            if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
                SetSvcErrorEx( SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_DATABASE_ERROR,
                               err );
                DPRINT(2,"IsValidBehaviorVersionChange returns FALSE, DB error\n");
                __leave;
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

            InitCommarg(&SearchArg.CommArg);

            pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA);
            Assert(pCC);

            //set filters "( (objCategory==NTDSA) && !(msDs-Behavior-Version>=lNewVersion))"
            memset(&AndFilter,0,sizeof(AndFilter));
            AndFilter.choice = FILTER_CHOICE_AND;
            AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;

            memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
            ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
            ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                             pCC->pDefaultObjCategory->structLen;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                             (BYTE*)(pCC->pDefaultObjCategory);
            ObjCategoryFilter.pNextFilter = &NotFilter;

            memset(&NotFilter,0,sizeof(NotFilter));
            NotFilter.choice = FILTER_CHOICE_NOT;
            NotFilter.FilterTypes.pNot = &VersionFilter;

            memset(&VersionFilter,0,sizeof(VersionFilter));
            VersionFilter.choice = FILTER_CHOICE_ITEM;
            VersionFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
            VersionFilter.FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_BEHAVIOR_VERSION;
            VersionFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(lNewVersion);
            VersionFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)&lNewVersion;

            SearchArg.pFilter = &AndFilter;

            //return one object only
            SearchArg.CommArg.ulSizeLimit = 1;

            if (fDomain) {
                //change the msDs-Behavior-Version of the DomainDNS object
                //we only need to check the nTDSDSA objects in the domain
                //so here we append (hasMasterNCs==current domain) to the AND-filter above
                memset(&DomainFilter,0,sizeof(DomainFilter));
                DomainFilter.choice = FILTER_CHOICE_ITEM;
                DomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
                DomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS;
                DomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = 
                            gAnchor.pDomainDN->structLen;
                DomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                            (BYTE*)gAnchor.pDomainDN;

                NotFilter.pNextFilter = &DomainFilter;

                AndFilter.FilterTypes.And.count = 3;  //3 items instead of 2

            }
            else {
                AndFilter.FilterTypes.And.count = 2; //only 2 items
            }

            memset(&SearchRes,0,sizeof(SearchRes));

            if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                DPRINT1(2, "IsValidBehaviorVersionChange returns FALSE, LocalSearch failed with err(%x)\n", err);
                __leave;
            }

            if (0 != SearchRes.count) {
                err = ERROR_DS_LOW_DSA_VERSION;
                SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                             ERROR_DS_LOW_DSA_VERSION );
                LogEvent( DS_EVENT_CAT_DIRECTORY_ACCESS,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_LOWER_DSA_VERSION,
                          szInsertDN(pModifyArg->pObject),
                          szInsertDN(SearchRes.FirstEntInf.Entinf.pName),
                          NULL );
                DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, a dsa with lower version exists.\n");
                __leave;
            }

        } // inner __try
        __finally {
            DBClose(pTHS->pDB, !err);
            //restore the saved value
            pTHS->pDB = pDBSave;
            pTHS->fDSA = fDSASave;
        }

    } // outer __try
    __except(GetExceptionData( GetExceptionInformation(),
                               &dwException,
                               &dwEA,
                               &ulErrorCode,
                               &dsid ) ){
        HandleDirExceptions(dwException, ulErrorCode, dsid );
        err = ERROR_DS_DATABASE_ERROR;
    }
    
    DPRINT1(2, "IsValidBehaviorVersionChange returns %s\n", (err)?"FALSE":"TRUE");

    // if the forest version is raised, return the new forest version.
    if ( !err && !fDomain ) {
         *pNewForestVersion = lNewVersion;
    }

    return !err;
}   /*IsValidBehaviorVersionChange*/

      
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if the object to modify is the crossref object for current domain
   or root domain.
*/
BOOL IsCurrentOrRootDomainCrossRef(THSTATE  *pTHS,
                                  MODIFYARG *pModifyArg)
{

    CROSS_REF *pDomainCF, *pRootDomainCF;
    COMMARG CommArg;
    ATTCACHE *pAC = SCGetAttById(pTHS,ATT_MS_DS_DNSROOTALIAS);
    Assert(pAC);

    InitCommarg(&CommArg);
        
    //see if the the crossref object of current domain
    pDomainCF = FindExactCrossRef(gAnchor.pDomainDN, &CommArg);
    Assert(pDomainCF);

    if (pDomainCF && NameMatched(pDomainCF->pObj,pModifyArg->pObject) ) {
        return TRUE;

    }
    //see if the crossref object of the root domain
    pRootDomainCF = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
    Assert(pRootDomainCF);

    if (pRootDomainCF && NameMatched(pRootDomainCF->pObj, pModifyArg->pObject)) {
        return TRUE;
    }

    return FALSE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Instead of setting Entry-TTL, a constructed attribute with syntax INTEGER,
   set ms-DS-Entry-Time-To-Die, an attribute with syntax DSTIME. The garbage
   collection thread, garb_collect, deletes these entries after they
   expire.
*/
VOID ModSetEntryTTL(THSTATE     *pTHS,
                    MODIFYARG   *pModifyArg,
                    ATTRMODLIST *pAttList,
                    ATTCACHE    *pACTtl
                    )
{
    ATTRVAL         AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    LONG            Secs;
    DSTIME          TimeToDie;
    ATTCACHE        *pACTtd;
    DWORD           dwErr;

    switch (pAttList->choice){

    case AT_CHOICE_REPLACE_ATT:

        if (!CheckConstraintEntryTTL(pTHS,
                                     pModifyArg->pObject,
                                     pACTtl,
                                     &pAttList->AttrInf,
                                     &pACTtd,
                                     &Secs)) {
            return;
        }
        memset(&AttrValBlock, 0, sizeof(AttrValBlock));
        memset(&AttrVal, 0, sizeof(AttrVal));

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;
        AttrVal.valLen = sizeof (TimeToDie);
        AttrVal.pVal = (BYTE *)&TimeToDie;
        TimeToDie = Secs + DBTime();

        if (dwErr = DBReplaceAtt_AC(pTHS->pDB, 
                                    pACTtd,
                                    &AttrValBlock,
                                    NULL)) {
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
        }

        break;

    case AT_CHOICE_ADD_ATT:
    case AT_CHOICE_REMOVE_ATT:
    case AT_CHOICE_ADD_VALUES:
    case AT_CHOICE_REMOVE_VALUES:
    default:
       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                     DIRERR_ILLEGAL_MOD_OPERATION,
                     pAttList->choice);
        break;
    }
}/*ModSetEntryTTL*/

int
FixSystemFlagsForMod(
    IN THSTATE     *pTHS,
    IN ATTRMODLIST *pAttList
    )
/*++
Routine Description

    Fix the systemFlags in caller's ModifyArgs. Previously, this
    logic was performed by SetClassInheritence while it added in
    class-specific systemFlags. The logic was moved here to allow
    a user to set, but not reset, FLAG_ATTR_IS_RDN in attributeSchema
    objects in the SchemaNC. The user sets FLAG_ATTR_IS_RDN to identify
    which of several attributes with the same attributeId should be
    used as the rdnattid of a new class. Once set, the attribute is
    treated as if it were used as the rdnattid of some class; meaning it
    cannot be reused.

    Caller has verified that pAttList is ATT_SYSTEM_FLAGS and that
    this is an attributeSchema object.

Paramters
    pTHS - thread struct, obviously
    pAttList - Current attr in ModifyArg's list of attrs

Return
    0 okay to proceed (may fail later)
    1 ModSetAttsHelper fails with no-mod-systemOnly error
--*/
{
    ULONG   OldSystemFlags, NewSystemFlags;

    // caller may do whatever it wishes
    if (CallerIsTrusted(pTHS)) {
        return 0;
    }

    // Add or replace is allowed, but not remove
    switch (pAttList->choice) {
    case AT_CHOICE_REPLACE_ATT:
    case AT_CHOICE_ADD_ATT:
    case AT_CHOICE_ADD_VALUES:

        // valCount of 0 is the same as AT_CHOICE_REMOVE_ATT
        if (pAttList->AttrInf.AttrVal.valCount == 0) {
            return 1;
        }

        // must be single-valued and an integer. If not, ModSetAttsHelper
        // later fails with not-multi-valued or bad-syntax error.
        if (pAttList->AttrInf.AttrVal.valCount != 1
            || pAttList->AttrInf.AttrVal.pAVal->valLen != sizeof(LONG)) {
            return 0;
        }

        // New value from user
        memcpy(&NewSystemFlags, pAttList->AttrInf.AttrVal.pAVal->pVal, sizeof(LONG));

        // Get the current value of systemFlags (default to 0)
        if (DBGetSingleValue(pTHS->pDB,
                             ATT_SYSTEM_FLAGS,
                             &OldSystemFlags,
                             sizeof(OldSystemFlags),
                             NULL)) {
            OldSystemFlags = 0;
        }
        // Only one modification to systemFlags is allowed. The user
        // may set, but not reset, FLAG_ATTR_IS_RDN on an attributeSchema
        // object. scchk.c will later verify that this attribute has
        // the correct syntax to be an rdn. The caller verified that this
        // is an attributeSchema object.
        NewSystemFlags = OldSystemFlags | (NewSystemFlags & FLAG_ATTR_IS_RDN);

        // Update ModifyArgs. ApplyAtt will hammer systemFlags.
        memcpy(pAttList->AttrInf.AttrVal.pAVal->pVal, &NewSystemFlags, sizeof(LONG));

        break;

    case AT_CHOICE_REMOVE_ATT:
    case AT_CHOICE_REMOVE_VALUES:
    default:
        return 1;
    }
    return 0;
}/*FixSystemFlagsForMod*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
//
//
// Functions:
//       ModSetAttsHelperPreProcess
//       ModSetAttsHelperProcess
//       ModSetAttsHelperPostProcess
//
// Description:
//      Add each input attribute to the current object.  
//
//      There is the pre-processing phase, where all the checks for validity 
//      are done. At this point the checks can navigate to other objects
//      and check various conditions as needed. It is assumed that in the end 
//      of the preprocessing phase, we are located on the initial object
//      If there is a need to communicate some data to the later steps, 
//      this is done through the hVerifyAtts data structure
//
//      The processing phase does the real update
//      If there is a need to communicate some data to the later steps, 
//      this is done through the hVerifyAtts data structure
//
//      The post-processing phase, checks the data passed in the 
//      hVerifyAtts data structure and takes appropriate action
//      if directed todo so
//
// Return:
//      0, on success
//      errCode otherwise

DWORD ModSetAttsHelperPreProcess(THSTATE *pTHS,
                                 MODIFYARG *pModifyArg,
                                 HVERIFY_ATTS hVerifyAtts,
                                 CLASSCACHE **ppClassSch,
                                 CLASSSTATEINFO  **ppClassInfo,
                                 ATTRTYP rdnType) 
{
    USHORT       count;
    DWORD        err;
    ATTRTYP      attType;
    ATTCACHE    *pAC;
    ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
    CLASSCACHE  *pClassSch = *ppClassSch;
    CLASSSTATEINFO  *pClassInfo;
    BOOL         fGroupObject = (CLASS_GROUP == pClassSch->ClassId);  
    BOOL         fAttrSchemaObject = (CLASS_ATTRIBUTE_SCHEMA == pClassSch->ClassId);
    BOOL         fEnabledCR;
    BOOL         fSeEnableDelegation; // SE_ENABLE_DELEGATION_PRIVILEGE enabled
    
    // Visit and apply each att.
    for (count = 0; 
         count < pModifyArg->count
                && (pTHS->errCode == 0 || pTHS->errCode == attributeError);
         count++, pAttList = pAttList->pNextMod) {

        // Get the target attribute type.  Remove att uses only ATTRTYP.
        // All other choices use an ATTR data structure.

        attType = pAttList->AttrInf.attrTyp;

        if(!(pAC = SCGetAttById(pTHS, attType))) {
            DPRINT1(2, "Att not in schema <%lx>\n",attType);
            return SetAttError(pModifyArg->pObject, attType,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                               ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
        }

        if (pAC->bIsConstructed) {
            // if this is not the EntryTTL, then it is an error
            //
            if (attType != ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

                // Constructed Attributes cannot be modified
                // Return error as if no such attribute

                DPRINT1(2, "Att constructed schema <%lx>\n", attType);
                return SetAttError(pModifyArg->pObject, attType,
                                   PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                                   DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }
        }

        // the following checks are valid only when the user is not the DRA
        //
        if (!pTHS->fDRA) {

            // start with a set of tests that have be ORed together

            if ((pAC->bDefunct) && !pTHS->fDSA) {
                // Attribute is defunct, so as far as the user is concerned,
                // it is not in schema. DSA or DRA is allowed to modify

                // Allow modification only if it is a delete operation
                // on the attribute, since the user needs to clean up

                if (pAttList->choice != AT_CHOICE_REMOVE_ATT) {
                    // trying to add/modify the attribute, not delete

                    DPRINT1(2, "Att not in schema <%lx>\n",attType);
                    return SetAttError(pModifyArg->pObject, attType,
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                }
            }

            // Skip RDN attributes. Only DRA can do this
            if (attType == rdnType || attType == ATT_RDN) {
                    return SetUpdError(UP_PROBLEM_CANT_ON_RDN,
                                       ERROR_DS_CANT_MOD_SYSTEM_ONLY); 
            }
            
            

            // now continue with a set of tests
            // that are specific for each attribute modified
            // and are of interest only when done on the originating modify
            //
            // most of the attribute cases can fit in the below switch 
            //

            switch ( attType ) {
            case ATT_MS_DS_ALLOWED_TO_DELEGATE_TO:
                // 371706 Allowed-To-Delegate-To needs proper ACL and Privilege protection
                //
                // From the DCR:
                //
                // A2D2 is used to configure a service to be able to obtain
                // delegated service tickets via S4U2proxy. KDCs will only
                // issue service tickets in response to S4U2proxy TGS-REQs
                // if the target service name is listed on the requesting
                // services A2D2 attribute. The A2D2 attribute has the
                // same security sensitivity as the Trusted-for-Delegation
                // (T4D) and Trusted-to-Authenticate-for-Delegation (T2A4D)
                // userAccontControl.  Thus, the ability to set A2D2 is also
                // protected by both an ACL on the attribute, and a privilege.
                //
                // write/modify access control: User must have both WRITE
                // permission to A2D2 attribute --and-- the SE_ENABLE_DELEGATION_NAME
                // (SeEnableDelegationPrivilege) privilege 
                if (!pTHS->fDSA) {
                    err = CheckPrivilegeAnyClient(SE_ENABLE_DELEGATION_PRIVILEGE,
                                                  &fSeEnableDelegation); 
                    if (err || !fSeEnableDelegation) {
                        return SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, 
                                             ERROR_PRIVILEGE_NOT_HELD, err);
                    }
                }
                break;


            case ATT_OBJECT_CATEGORY:
                // Trying to modify the objectCategory of an instance of a
                // base schema class. Not allowed unless DRA or DSA
                //
                if ((pClassSch->bIsBaseSchObj) && !pTHS->fDSA) {
                    DPRINT1(2,"Can't change object-category for instances of %s\n",

                            pClassSch->name);
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_MOD_OPERATION);
                    return (pTHS->errCode);
                }
                break;

            
            case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
                // We are trying to do an originating change on the
                // partial set membership of an attribute object.
                // - check validity of the operation
                //
                if (fAttrSchemaObject) {
                    if (SysIllegalPartialSetMembershipChange(pTHS)) {
                        DPRINT(1, "Illegal attempt to change partial set membership");
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_MOD_OPERATION);
                        return (pTHS->errCode);
                    }
                }
                break;



            case ATT_OBJECT_CLASS:
                // check whether we are changing the objectClass attribute
                // if we are the DRA thread, we just let it through
                //
                // If not a whistler enterprise, auxclasses must be in an NDNC
                //
                if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WHISTLER) {
                    CROSS_REF   *pCR;
                    pCR = FindBestCrossRef(pModifyArg->pObject, NULL);
                    if (   !pCR
                        || !(pCR->flags & FLAG_CR_NTDS_NC)
                        || (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
                        DPRINT (0, "You can modify auxclass/objectass only on an NDNC\n");
                        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                           ERROR_DS_NOT_SUPPORTED);
                    }
                }

                // if this is the first time through, we have to read the 
                // original values for objectClass from the database
                //
                if (ppClassInfo && *ppClassInfo==NULL) {

                    pClassInfo = ClassStateInfoCreate (pTHS);
                    if (!pClassInfo) {
                        return pTHS->errCode;
                    }
                    // read the objectClass
                    if (err = ReadClassInfoAttribute (pTHS->pDB, 
                                                      pAC,
                                                      &pClassInfo->pOldObjClasses,
                                                      &pClassInfo->cOldObjClasses_alloced,
                                                      &pClassInfo->cOldObjClasses,
                                                      NULL)) {
                        return err;
                    }
                    *ppClassInfo = pClassInfo;
                }
                else {
                    Assert (ppClassInfo);
                    Assert (*ppClassInfo);
                    pClassInfo = *ppClassInfo;
                }
                break;

   
            case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                // check if additional-dns-host-name is changed but forest version is < whistler
                if ( !pTHS->fDSA ) {

                    if (gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WHISTLER ) 
                      {
                         return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                            ERROR_DS_NOT_SUPPORTED);
                      }
                }
                break;



            case ATT_MS_DS_NC_REPLICA_LOCATIONS:
                // If were modifying a replica set on a crossRef, check that the this
                // crossRef is enabled. (or that we are fDSA in the case of a creation
                // of a new NDNC)
                if ( !pTHS->fDSA ){
                    // Get the Enabled attribute off this object/CR.
                    err = DBGetSingleValue(pTHS->pDB,
                                           ATT_ENABLED,
                                           &fEnabledCR,
                                           sizeof(fEnabledCR),
                                           NULL);
                    if(err == DB_ERR_NO_VALUE){
                        // Deal w/ no value, because, no value means TRUE in
                        // the context of the Enabled attribute.
                        fEnabledCR = TRUE;
                    } else if (err){
                        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                      DIRERR_UNKNOWN_ERROR,
                                      err);
                        return(pTHS->errCode);
                    }

                    if(!fEnabledCR){
                        // This cross ref is disabled, and we're trying to add/delete
                        // something from the replica set, that's No Good!
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR);
                        return(pTHS->errCode);
                    }
                }
                break;


            case ATT_GROUP_TYPE:

                // check whether we are changing the group type 

                if (hVerifyAtts->fGroupTypeChange = fGroupObject) {

                    // originating change on group type - keep copy of
                    // the old group type
                    err = DBGetSingleValue(pTHS->pDB,
                                           ATT_GROUP_TYPE,
                                           &hVerifyAtts->ulGroupTypeOld,
                                           sizeof(hVerifyAtts->ulGroupTypeOld),
                                           NULL);
                    if (err) {
                        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                                      ERROR_DS_MISSING_EXPECTED_ATT,
                                      err); 
                        return pTHS->errCode;
                    }
                }
                break;

            case ATT_MS_DS_UPDATESCRIPT:

                // check that the DC holds the Domain FSMO role
                err = CheckRoleOwnership( pTHS,
                                          gAnchor.pDomainDN,
                                          pModifyArg->pResObj->pObj );

                if (err) {
                    DPRINT(0, "DC should hold the domain FSMO role to update script \n");
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
                    return pTHS->errCode;
                }
                break;


           case ATT_NT_MIXED_DOMAIN:
                // if ntMixedDomain attribute of current domain is changed,
                // invoke behaviorVersionUpdate thread to update the ntMixedDomain
                // attribute on the crossref object of current domain.
                if ( NameMatched(gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
                    pTHS->fBehaviorVersionUpdate = TRUE;
                }
                break;



            default:
                // this is ok. go on
                break;
            }  // end switch 
        
        } // end if not DRA



        // next continue with tests for attributes that are of interest
        // at any time (originating or not)
        //
        // most of the attribute cases can fit in the below switch 
        // all the rest that can take place without DRA, are handled above
        //
        switch ( attType) {
        
        case ATT_SCHEMA_INFO:
            // Skip writing SchemaInfo if fDRA during normal running. It will
            // be written directly by the dra thread at the end of schema NC
            // sync.

            if (DsaIsRunning() && pTHS->fDRA) {
                continue;
            }
            break;


        case ATT_MAX_PWD_AGE:
        case ATT_LOCKOUT_DURATION:
        case ATT_MS_DS_ALLOWED_DNS_SUFFIXES:
            //
            // MaxPasswordAge and Lockout Duration are cached in the anchor.
            // if we are modifiying one of these attributes, remember to
            // invalidate anchor after the apply Att succeeds
            //
            if (pTHS->pDB->DNT == gAnchor.ulDNTDomain) {
                pTHS->fAnchorInvalidated = TRUE;
            }

            break;


        case ATT_MS_DS_BEHAVIOR_VERSION:
            // check the msDs-Behavior-Version attribute

            if (!pTHS->fDRA && !pTHS->fDSA ) {
                if (!IsValidBehaviorVersionChange(pTHS, pAttList, pModifyArg,
                                                  pClassSch, &hVerifyAtts->NewForestVersion)) {
                    return pTHS->errCode;
                }
            }
            
            // activate RebuildAnchor
            pTHS->fAnchorInvalidated = TRUE;

            // if forest version is changed, enable the BehaviorVersionUpdate
            // thread to update domain version if necessary
            // if domain version is changed, enable the BehaviorVersionUpdate
            // to update the msDs-Behavior-version on crossref container
            if (  ( gAnchor.pPartitionsDN
                    && NameMatched(gAnchor.pPartitionsDN,pModifyArg->pResObj->pObj))
                ||  NameMatched(gAnchor.pDomainDN,pModifyArg->pResObj->pObj)  )
            {
                pTHS->fBehaviorVersionUpdate = TRUE;
            }

            break;

        case ATT_MS_DS_DNSROOTALIAS:
            // check if ms-DS-DnsRootAlias is changed
            if ( IsCurrentOrRootDomainCrossRef(pTHS,pModifyArg) ) {
                pTHS->fNlDnsRootAliasNotify = TRUE;
            } 
            break;

        default:
            // this is ok. go on
            break;

        } // end switch


        // finally, test for special flags on attributes
        //
        // objectClass, msDs-behavior-version, and systemFlags
        // are special Attributes and although they are system only,
        // we want to be able to change them in some cases.
        //
        if (   (attType != ATT_OBJECT_CLASS)
            && (attType != ATT_MS_DS_BEHAVIOR_VERSION)
            && (attType != ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME)
            // Allow user to set, but not reset, FLAG_ATTR_IS_RDN
            && (attType != ATT_SYSTEM_FLAGS
                || !fAttrSchemaObject
                || FixSystemFlagsForMod(pTHS, pAttList))
            && SysModReservedAtt(pTHS, pAC, pClassSch)
            && !gAnchor.fSchemaUpgradeInProgress) {

            if (!pTHS->fDRA) {
                // This is a reserved attribute which we won't let you
                // change unless a schema upgrade is in progress
                return SetAttError(pModifyArg->pObject, attType,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                   ERROR_DS_CANT_MOD_SYSTEM_ONLY);
            }
        } 

        // pheeeeeeeww, this is ok to go on and modify this attr
        // this is done in the ModSetAttsHelperProcess function
        
        // continue with the next one

    }  // for loop

   return pTHS->errCode;
}

DWORD ModSetAttsHelperProcess(THSTATE *pTHS,
                              MODIFYARG *pModifyArg,
                              CLASSCACHE **ppClassSch,
                              CLASSSTATEINFO  **ppClassInfo,
                              HVERIFY_ATTS hVerifyAtts) 
{
    USHORT           count;
    DWORD            err;
    CLASSSTATEINFO  *pClassInfo;
    CLASSCACHE      *pClassSch = *ppClassSch;
    ATTRTYP          attType;
    ATTCACHE        *pAC;
    ATTRMODLIST     *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/

    // Visit and apply each att.
    for (count = 0; 
         count < pModifyArg->count
                && (pTHS->errCode == 0 || pTHS->errCode == attributeError);
         count++, pAttList = pAttList->pNextMod) {

        // Get the target attribute type.  Remove att uses only ATTRTYP.
        // All other choices use an ATTR data structure.

        attType = pAttList->AttrInf.attrTyp;

        if(!(pAC = SCGetAttById(pTHS, attType))) {
            DPRINT1(2, "Att not in schema <%lx>\n",attType);
            return SetAttError(pModifyArg->pObject, attType,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                               ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
        }


        ApplyAtt(pTHS, pModifyArg->pObject, hVerifyAtts, pAC, pAttList,
                 &pModifyArg->CommArg);

        switch (attType) {
        case ATT_OBJECT_CLASS:
            // if we changed (originating) the objectClass, 
            // we want to fix the values stored 
            //
            if (!pTHS->fDRA) {
                pClassInfo = *ppClassInfo;

                Assert (pClassInfo);

                // read the new objectClass
                if (err = ReadClassInfoAttribute (pTHS->pDB, 
                                                  pAC,
                                                  &pClassInfo->pNewObjClasses,
                                                  &pClassInfo->cNewObjClasses_alloced,
                                                  &pClassInfo->cNewObjClasses,
                                                  NULL)) {
                    return err;
                }

                pClassInfo->fObjectClassChanged = TRUE;

                // compute and write new objectClass
                if (err = SetClassInheritance (pTHS, ppClassSch, pClassInfo, FALSE, pModifyArg->pObject)) {
                    return err;
                }
                pClassSch = *ppClassSch;
            }
            break;


        case ATT_LOCKOUT_TIME:
            //
            // if the client is trying to set the AccountLockoutTime attribute, 
            // get the new value, we will check the new value later.
            // 
            if (err = DBGetSingleValue(pTHS->pDB, 
                                       ATT_LOCKOUT_TIME, 
                                       &hVerifyAtts->LockoutTimeNew, 
                                       sizeof(hVerifyAtts->LockoutTimeNew), 
                                       NULL) ) 
            {
                // can't retrieve LockoutTime attribute, will leave BadPwdCount as it is.
                hVerifyAtts->fLockoutTimeUpdated = FALSE;
            }
            else
            {
                hVerifyAtts->fLockoutTimeUpdated = TRUE;
            }
            break;


        case ATT_MS_DS_UPDATESCRIPT:
            // if the client is updating the updateScript, we need to know
            //
            hVerifyAtts->fUpdateScriptChanged = TRUE;
            break;

        } // end switch


    }  // for loop

    return pTHS->errCode;
}

DWORD ModSetAttsHelperPostProcess(THSTATE *pTHS,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  HVERIFY_ATTS hVerifyAtts) 
{
    DWORD            err;

    if (hVerifyAtts->fGroupTypeChange) {
        // Originating change on group type - need to touch the
        // member property for the GC filtering logic if this is
        // a change from non-universal group to universal group.
        ULONG ulGroupTypeNew;
        ATTCACHE *pACMember;

        err = DBGetSingleValue(pTHS->pDB,
                               ATT_GROUP_TYPE,
                               &ulGroupTypeNew,
                               sizeof(ulGroupTypeNew),
                               NULL);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                          ERROR_DS_MISSING_EXPECTED_ATT,
                          err); 
            return pTHS->errCode;
        }

        if (!(hVerifyAtts->ulGroupTypeOld & GROUP_TYPE_UNIVERSAL_GROUP)
            && (ulGroupTypeNew & GROUP_TYPE_UNIVERSAL_GROUP)) {
            // We have just changed a non-universal group to
            // universal group.  Touch the member property so that
            // the membership will replicate out to GCs.
            pACMember = SCGetAttById(pTHS, ATT_MEMBER);
            Assert(NULL != pACMember);

            if (pTHS->fLinkedValueReplication) {
                // See the comments to this routine for semantics
                DBTouchLinks_AC(pTHS->pDB, pACMember, FALSE /* forward links */);
            } else {
                DBTouchMetaData(pTHS->pDB, pACMember);
            }
        }
    }

    if ( hVerifyAtts->fLockoutTimeUpdated && 
         (hVerifyAtts->LockoutTimeNew.QuadPart == 0) )
    {
        DWORD    dwErr;
        ATTCACHE *pAttSchema = NULL;
        ULONG    BadPwdCount = 0;
        ATTRVAL  AttrVal;
        ATTRVALBLOCK AttrValBlock;


        AttrVal.pVal = (PCHAR) &BadPwdCount;
        AttrVal.valLen = sizeof(ULONG);

        AttrValBlock.pAVal = &AttrVal;
        AttrValBlock.valCount = 1;


        if (!(pAttSchema = SCGetAttById(pTHS, ATT_BAD_PWD_COUNT)))
        {
            DPRINT1(2, "Att not in schema (%lx)\n", ATT_BAD_PWD_COUNT);
            return SetAttError(pModifyArg->pObject, ATT_BAD_PWD_COUNT,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        }
        if (dwErr = DBReplaceAtt_AC(pTHS->pDB, pAttSchema, &AttrValBlock, NULL) )
        {
            SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
        }
    }

    if (hVerifyAtts->fUpdateScriptChanged) {

        // if this attribute changed on a cross ref container
        // we want to reset the hidden key
        if (pClassSch->ClassId == CLASS_CROSS_REF_CONTAINER) {

            // was it a change on the partitions container ?
            //
            Assert (pModifyArg->pResObj->pObj);

            if (NameMatched (pModifyArg->pResObj->pObj, gAnchor.pPartitionsDN)) {

                DWORD    dwErr;
                ATTCACHE *pAttSchema = NULL;

                if (!(pAttSchema = SCGetAttById(pTHS, ATT_MS_DS_EXECUTESCRIPTPASSWORD)))
                {
                    DPRINT1(2, "Att not in schema (%lx)\n", ATT_MS_DS_EXECUTESCRIPTPASSWORD);
                    return SetAttError(pModifyArg->pObject, ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                }

                dwErr = DBRemAtt_AC(pTHS->pDB, pAttSchema);

                if (dwErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST && dwErr != DB_success) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                }
            }
        }
    }

    if (hVerifyAtts->NewForestVersion>0 
        && hVerifyAtts->NewForestVersion>gAnchor.ForestBehaviorVersion) {
        // if the forest version is raised, 
        // execute the coresponding script(s)
        err = forestVersionRunScript(pTHS, gAnchor.ForestBehaviorVersion, hVerifyAtts->NewForestVersion);
                    
        if (err) {
            return SetSvcErrorEx( SV_PROBLEM_DIR_ERROR,
                                  DIRERR_UNKNOWN_ERROR,
                                  err );
        }
    }

   return pTHS->errCode;
}



int ModSetAtts(THSTATE *pTHS,
               MODIFYARG *pModifyArg,
               CLASSCACHE **ppClassSch,
               CLASSSTATEINFO **ppClassInfo,
               ATTRTYP rdnType)
{
    HVERIFY_ATTS hVerifyAtts;
    
    hVerifyAtts = VerifyAttsBegin(pTHS, pModifyArg->pObject,
                                  pModifyArg->pResObj->NCDNT,
                                  NULL);

    __try {

        if (ModSetAttsHelperPreProcess(pTHS,
                                       pModifyArg,
                                       hVerifyAtts,
                                       ppClassSch,
                                       ppClassInfo,
                                       rdnType)) {
            __leave;
        }


        if (ModSetAttsHelperProcess(pTHS,
                                    pModifyArg,
                                    ppClassSch,
                                    ppClassInfo,
                                    hVerifyAtts)) {
            __leave;
        }

        if (ModSetAttsHelperPostProcess(pTHS,
                                        pModifyArg,
                                        *ppClassSch,
                                        hVerifyAtts)) {
            __leave;
        }


    } __finally {
        VerifyAttsEnd(pTHS, &hVerifyAtts);
    }

    return pTHS->errCode;
}/*ModSetAtts*/

int
BreakObjectClassesToAuxClasses (
        THSTATE *pTHS,
        CLASSCACHE **ppClassSch,
        CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    Given the full new objectClass (set by the user), 
    it figures out which classes belong to the hierarchy of 
    the stuctural object class and which classes are auxClasses.
    
    Note, this function does not assume any special order on the values 
    passed in

    On success, pClassInfo->pNewAuxClasses contains the auxClasses that 
    should be present on the object

Parameters

Return
    0 on Success
    Err on Failure

--*/

{
    DWORD           err;
    DWORD           fFound, usedPos, j, k;
    ATTRVALBLOCK    *pAttrVal;
    CLASSCACHE      *pClassSch, *pCCNew, *pCCtemp;

    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo) {
        return 0;
    }

    Assert (pClassInfo->cNewObjClasses);

    // since we are here, it means that we modified the objectClass
    // we have todo several checks and later on re-adjust the 
    // values stored in the various columns (objectClass, auxClass)

    ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses,              // p
                                   pClassInfo->pNewAuxClassesCC,            // pCC
                                   pClassInfo->cNewObjClasses_alloced,      // startsize
                                   pClassInfo->cNewAuxClasses_alloced,      // allocedSize
                                   pClassInfo->cNewObjClasses_alloced);     // newsize

    pClassInfo->cNewAuxClasses = 0;

    // find the position of the class that is the same as our objectClass
    fFound = FALSE;
    pClassSch = *ppClassSch;
    for (j=0; j<pClassInfo->cNewObjClasses;j++) {
        if (pClassInfo->pNewObjClasses[j] == pClassSch->ClassId) {
            usedPos = j;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound) {

        ATTRTYP InetOrgPersonId = ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId;

        // possibly, we are converting an inetOrgPerson to a User
        // (removing the inetOrgPerson class).
        // we want to allow this conversion
        //
        if (pClassSch->ClassId == InetOrgPersonId) {
            
            DPRINT (0, "Changing InetOrgPerson to a User\n");

            for (j=0; j<pClassInfo->cNewObjClasses;j++) {
                if (pClassInfo->pNewObjClasses[j] == CLASS_USER) {
                    usedPos = j;
                    fFound = TRUE;
                    pClassSch = SCGetClassById(pTHS, CLASS_USER);
                    if (!pClassSch) {
                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           DIRERR_OBJ_CLASS_NOT_DEFINED);
                    }

                    *ppClassSch = pClassSch;
                    break;
                }
            }
        }
        else if (pClassSch->ClassId == CLASS_USER) {

            DPRINT (0, "Changing User to InetOrgPerson\n");

            for (j=0; j<pClassInfo->cNewObjClasses;j++) {
                if (pClassInfo->pNewObjClasses[j] == InetOrgPersonId) {
                    usedPos = j;
                    fFound = TRUE;
                    pClassSch = SCGetClassById(pTHS, InetOrgPersonId);
                    if (!pClassSch) {
                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           DIRERR_OBJ_CLASS_NOT_DEFINED);
                    }

                    *ppClassSch = pClassSch;
                    break;
                }
            }
        }
        
        if (!fFound) {
            DPRINT1 (1, "Original Structural Object Class 0x%x not found on new value\n", pClassSch->ClassId);
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               ERROR_DS_ILLEGAL_MOD_OPERATION);
        }
    }

    // Now, look at all the object classes.  Make sure they describe a
    // (possibly incomplete) inheritence chain, not a web.
    for(j=0 ; j<pClassInfo->cNewObjClasses; j++) {
        if (j == usedPos) {
            // we have seen this position
            continue;
        }
        if(!(pCCNew = SCGetClassById(pTHS, pClassInfo->pNewObjClasses[j]))) {
            DPRINT1(0, "Object class 0x%x undefined.\n", pClassInfo->pNewObjClasses[j]);
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               DIRERR_OBJ_CLASS_NOT_DEFINED);
        }

        // make sure pCCNew inherits from pClassSch or vice versa
        pCCtemp = FindMoreSpecificClass(pClassSch, pCCNew);
        if(!pCCtemp) {
            // Ooops, pCCNew is not in the chain for objectClass.
            // It might be an auxClass, or a chain for an auxClass
            //

            // better check explicitly for the classes rather than checking for 
            // not beeing DS_STRUCTURAL_CLASS
            //
            if (pCCNew->ClassCategory == DS_AUXILIARY_CLASS || 
                pCCNew->ClassCategory == DS_88_CLASS || 
                pCCNew->ClassCategory == DS_ABSTRACT_CLASS) {

                DPRINT1 (1, "Found auxClass (%s) while creating object\n", pCCNew->name);

                pClassInfo->cNewAuxClasses++;

                ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses, 
                                               pClassInfo->pNewAuxClassesCC, 
                                               MIN_NUM_OBJECT_CLASSES, 
                                               pClassInfo->cNewAuxClasses_alloced, 
                                               pClassInfo->cNewAuxClasses);

                pClassInfo->pNewAuxClasses[pClassInfo->cNewAuxClasses-1] = pCCNew->ClassId;
                pClassInfo->pNewAuxClassesCC[pClassInfo->cNewAuxClasses-1] = pCCNew;

            }
            else {
                DPRINT1 (1, "Found a class(%s) that does not belong to the object\n", pCCNew->name);
                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   DIRERR_OBJ_CLASS_NOT_SUBCLASS);
            }
        }
        else {
            // we have to see whether pCCNew is a subClass of pClassSch

            if (pCCtemp == pCCNew) {
                // somehow we are changing the structural object Class
                // is this an allowed change ?
                if ((pClassSch->ClassId == CLASS_USER) && 
                    (pCCtemp->ClassId == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId)) {

                    pClassSch = pCCtemp;
                    *ppClassSch = pClassSch;
                    DPRINT1 (1, "Changing User to InetOrgPerson: 0x%x\n", pClassSch);

                }
                else {
                    DPRINT1 (1, "Found a class(%s) that does not belong to the object\n", pCCNew->name);
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       ERROR_DS_ILLEGAL_MOD_OPERATION);
                }
            }
        }
    }

#ifdef DBG
    for (j = 0; j < pClassInfo->cNewAuxClasses ; j++) {    
        DPRINT2 (1, "NewAuxClasses[%d]=0x%x \n", j, pClassInfo->pNewAuxClasses[j]);
    }
#endif

    return pTHS->errCode;
} // BreakObjectClassesToAuxClasses


int
BreakObjectClassesToAuxClassesFast (
        THSTATE *pTHS,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    Given the full new objectClass (read from the database), 
    it figures out which classes belong to the hierarchy of 
    the stuctural object class and which classes are auxClasses.
    
    Note, this function ASSUMES a special order on the values passed in.

    On success, pClassInfo->pNewAuxClasses contains the auxClasses of the object.
    
Parameters

Return
    0 on Success
    Err on Failure

--*/
{
    DWORD i;

    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo) {
        return 0;
    }

    Assert (pClassInfo->cNewObjClasses);
    
    if (pClassInfo->cNewObjClasses == (pClassSch->SubClassCount+1 )) {
        pClassInfo->cNewAuxClasses = 0;
        return 0;
    }

    ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses,              // p
                                   pClassInfo->pNewAuxClassesCC,            // pCC
                                   pClassInfo->cNewObjClasses,              // startsize
                                   pClassInfo->cNewAuxClasses_alloced,      // allocedSize
                                   pClassInfo->cNewObjClasses);            // newsize

    pClassInfo->cNewAuxClasses = 0;
    for (i=pClassSch->SubClassCount; i<pClassInfo->cNewObjClasses-1; i++) {
        pClassInfo->pNewAuxClasses [ pClassInfo->cNewAuxClasses ] = 
                    pClassInfo->pNewObjClasses[i];

        pClassInfo->pNewAuxClassesCC[ pClassInfo->cNewAuxClasses++ ] = 
                    SCGetClassById(pTHS, pClassInfo->pNewObjClasses[i]);
    }

    return 0;
}


int 
CloseAuxClassList (
    THSTATE *pTHS, 
    CLASSCACHE *pClassSch,
    CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    The auxClass list contains all the classes that are not on 
    the structural object class hierarchy.
    
    For all these classes, this function finds the closed set, 
    by adding all the superclasses needed. 
    
    The pClassInfo->?NewAuxClasses* variables are expanded to hold the 
    addition auxClasses.

Return
    0 on Success
    Err on Failure

--*/
{
    BOOL            fFound;
    DWORD           i, j, k, cUpperBound;
    DWORD           cCombinedObjClass, cCombinedObjClass_alloced;
    ATTRTYP         *pCombinedObjClass;
    CLASSCACHE      *pCC, *pCCNew;
    
    if (!pClassInfo || !pClassInfo->cNewAuxClasses) {
        return 0;
    }

    // combinedObjClass contains all the structural object classes plus the auxClasses
    cCombinedObjClass_alloced = (pClassInfo->cNewAuxClasses + 1 + pClassSch->SubClassCount) * 2;
    pCombinedObjClass = THAllocEx (pTHS, sizeof (ATTRTYP) * cCombinedObjClass_alloced);
    
    pCombinedObjClass[0] = pClassSch->ClassId;
    cCombinedObjClass = 1;

    for (i=0; i<pClassSch->SubClassCount; i++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassSch->pSubClassOf[i];
    }

    for (i=0; i < pClassInfo->cNewAuxClasses; i++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassInfo->pNewAuxClasses[i];
    }
    
    qsort(pCombinedObjClass,
          cCombinedObjClass,
          sizeof(ATTRTYP),
          CompareAttrtyp);


    // the point where we start adding new auxClasses
    cUpperBound = pClassInfo->cNewAuxClasses;

    // check for all the existing auxClasses
    for (i=0; i < pClassInfo->cNewAuxClasses; i++) {

        // check whether all the superiors of this class are present
        pCC = pClassInfo->pNewAuxClassesCC[i];

        for (j=0; j<pCC->SubClassCount; j++) {
            fFound = FALSE;

            // first check the sorted array
            if (bsearch(&pCC->pSubClassOf[j],
                         pCombinedObjClass,
                         cCombinedObjClass,
                         sizeof(ATTRTYP),
                         CompareAttrtyp)) {

                fFound = TRUE;
            }
            else {
                DPRINT1 (0, "Class (0x%x) not found in sorted hierarchy\n", pCC->pSubClassOf[j]);

                // search only in the new additions
                for (k=cUpperBound; k<pClassInfo->cNewAuxClasses; k++) {

                    if (pClassInfo->pNewAuxClasses[k] == pCC->pSubClassOf[j]) {
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound) {
                DPRINT1 (0, "Class (0x%x) not found at all.\n", pCC->pSubClassOf[j]);

                pClassInfo->cNewAuxClasses++;
                if (pClassInfo->cNewAuxClasses > pClassInfo->cNewAuxClasses_alloced) {
                    pClassInfo->cNewAuxClasses_alloced = pClassInfo->cNewAuxClasses_alloced*2;
                    pClassInfo->pNewAuxClasses = THReAllocEx(pTHS, pClassInfo->pNewAuxClasses, 
                                                             sizeof (ATTRTYP) * pClassInfo->cNewAuxClasses_alloced);
                    pClassInfo->pNewAuxClassesCC = THReAllocEx (pTHS, pClassInfo->pNewAuxClassesCC,
                                                                sizeof (CLASSCACHE *) * pClassInfo->cNewAuxClasses_alloced);
                }

                if(!(pCCNew = SCGetClassById(pTHS, pCC->pSubClassOf[j]))) {
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       DIRERR_OBJ_CLASS_NOT_DEFINED);
                }
                pClassInfo->pNewAuxClasses[pClassInfo->cNewAuxClasses-1] = pCC->pSubClassOf[j];
                pClassInfo->pNewAuxClassesCC[pClassInfo->cNewAuxClasses-1] = pCCNew;
                DPRINT2 (0, "Added new AuxObjectClass[%d]=%s  \n", 
                         pClassInfo->cNewAuxClasses-1, pCCNew->name);
            }
        }
    }

    THFreeEx (pTHS, pCombinedObjClass);

    return 0;
}


int
VerifyAndAdjustAuxClasses (
        THSTATE *pTHS,
        DSNAME *pObject,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo)
//
//
//  Assumes that the auxClass set is closed.
//
//
{
    DWORD           err;
    DWORD           seekIdx, i, j;
    BOOL            fFound;
    CLASSCACHE      *pCC, *pCCparent, *pCCold;
    BOOL            fOldDynamicObjectId;
    BOOL            fNewDynamicObjectId;
    ATTRTYP         DynamicObjectId;
    DWORD           cOriginalAuxClasses;
    ATTRTYP         *pOriginalAuxClasses = NULL;
    DWORD           cOldAuxClasses;
    ATTRTYP         *pOldAuxClasses = NULL;
    BOOL            fChangedAuxClass=FALSE;


    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo || (pClassInfo && !pClassInfo->fObjectClassChanged)) {
        return 0;
    }

    // check whether we have a real change in the objectClass stored on the object
    //
    if ((pClassInfo->cNewObjClasses != pClassInfo->cOldObjClasses) ||
        (pClassInfo->cNewObjClasses &&
         pClassInfo->cOldObjClasses &&
         memcmp (pClassInfo->pNewObjClasses, 
                 pClassInfo->pOldObjClasses,
                 pClassInfo->cNewObjClasses * sizeof (ATTRVAL)) != 0)) {

        pClassInfo->fObjectClassChanged = TRUE;
    }
    else {
        pClassInfo->fObjectClassChanged = FALSE;
        return 0;
    }


    // so somebody changed the objectClass and as a result 
    // we have additional/less auxClasses 

    // we don't have to check for dynamic auxclass removal if this was an add
    //
    if (!pClassInfo->fOperationAdd) {
        // the dynamic-object auxclass cannot be added or removed
        DynamicObjectId = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId;
        fOldDynamicObjectId = FALSE;
        for (seekIdx=0; seekIdx < pClassInfo->cOldObjClasses; seekIdx++) {
            if (pClassInfo->pOldObjClasses[seekIdx] == DynamicObjectId) {
                fOldDynamicObjectId = TRUE;
                break;
            }
        }

        fNewDynamicObjectId = FALSE;
        for (seekIdx=0; seekIdx < pClassInfo->cNewObjClasses; seekIdx++) {
            if (pClassInfo->pNewObjClasses[seekIdx] == DynamicObjectId) {
                fNewDynamicObjectId = TRUE;
                break;
            }
        }
        if (fNewDynamicObjectId != fOldDynamicObjectId) {
            return SetAttError(pObject, 
                               ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL, 
                               ERROR_DS_OBJ_CLASS_VIOLATION);
        }
    }


    // check to see that for every auxClass that we removed
    // we also removed all the parent abstract classes
    // if not we have to remove them

    // calculate the old set of auxClasses
    // we assume that the objectClass set is in a normalized form
    // i.e. mostSpecificClass; parentClasses; auxClasses; Top


    // what an Assert !!
    Assert (!pClassInfo->pOldObjClasses || 
              (pClassInfo->pOldObjClasses && 
                ( pClassInfo->pOldObjClasses[0] == pClassSch->ClassId || 
                 (pClassInfo->pOldObjClasses[0] == CLASS_USER &&
                  pClassSch->ClassId == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId) ||
                 (pClassSch->ClassId == CLASS_USER &&
                  pClassInfo->pOldObjClasses[0] == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId)
                )
               )
            );

    cOldAuxClasses = 0;
    if (pClassInfo->cOldObjClasses) {
        if(!(pCCold = SCGetClassById(pTHS, pClassInfo->pOldObjClasses[0]))) {
             return SetAttError(pObject, pClassInfo->pOldObjClasses[0],
                                PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        }
    
        pOldAuxClasses = THAllocEx (pTHS, sizeof (ATTRTYP) * pClassInfo->cOldObjClasses);
        for (seekIdx=pCCold->SubClassCount; seekIdx < pClassInfo->cOldObjClasses; seekIdx++) {
            pOldAuxClasses[cOldAuxClasses++]=pClassInfo->pOldObjClasses[seekIdx];
        }
        if (cOldAuxClasses) {
            // got the last one too
            cOldAuxClasses--;
        }
    }

    DPRINT2 (1, "Found OldAuxClasses: %d %x\n", cOldAuxClasses, pOldAuxClasses);

    // make a copy of the newAuxClasses, since we will be changing the array

    cOriginalAuxClasses = pClassInfo->cNewAuxClasses;
    if (cOriginalAuxClasses) {
        pOriginalAuxClasses = THAllocEx (pTHS, sizeof (ATTRTYP) * cOriginalAuxClasses);
        memcpy (pOriginalAuxClasses, pClassInfo->pNewAuxClasses, sizeof (ATTRTYP) * cOriginalAuxClasses);
    }

    for (seekIdx=0; seekIdx < cOldAuxClasses; seekIdx++) {

        fFound = FALSE;

        for (i=0; i<cOriginalAuxClasses; i++) {
            if (pOriginalAuxClasses[i] == pOldAuxClasses[seekIdx]) {
                fFound=TRUE;
                break;
            }
        }

        if (!fFound) {
            // we removed this objectClass so we have to remove  
            // its abstract superClass(es), unless it is used in 
            // another auxClass in the new list
            //
            // if this class parent is not an abstract class, we don't do anything
            if(!(pCC = SCGetClassById(pTHS, pOldAuxClasses[seekIdx]))) {
                 return SetAttError(pObject, pOldAuxClasses[seekIdx],
                                    PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
            }

            for (i=0; i<pCC->SubClassCount; i++) {
                if (!(pCCparent = SCGetClassById(pTHS, pCC->pSubClassOf[i]))) {
                    return SetAttError(pObject, pCC->pSubClassOf[i],
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                       ERROR_DS_OBJ_CLASS_NOT_DEFINED);
                }

                // we found an abstract class as a parent of the class that we
                // removed. we have to remove it from the auxClass list
                // unless it is used by another auxClass
                if ((pCCparent->ClassCategory == DS_ABSTRACT_CLASS) && 
                    (pCCparent->ClassId != CLASS_TOP)) {

                    for (j=0; j<pClassInfo->cNewAuxClasses; j++) {
                        if (pClassInfo->pNewAuxClasses[j] == pCCparent->ClassId) {

                            // it is easier to remove this class now
                            // and add it later if it is needed
                            // our comparison of what auxClasses originally
                            // got removed still works, since we have a copy
                            // of the original array

                            DPRINT1 (0, "Removing abstract parent class (%s) from auxClass\n", 
                                     pCCparent->name);

                            if (j==(pClassInfo->cNewAuxClasses-1)) {
                                pClassInfo->cNewAuxClasses--;
                            }
                            else {
                                memmove(&pClassInfo->pNewAuxClasses[j],
                                        &pClassInfo->pNewAuxClasses[j+1],
                                        (pClassInfo->cNewAuxClasses - j - 1)*sizeof(ATTRTYP));
                                memmove(&pClassInfo->pNewAuxClassesCC[j],
                                        &pClassInfo->pNewAuxClassesCC[j+1],
                                        (pClassInfo->cNewAuxClasses - j - 1)*sizeof(ATTRTYP));

                                pClassInfo->cNewAuxClasses--;
                            }

                            fChangedAuxClass = TRUE;
                            break;
                        }
                    }
                }
                else {
                    // we either found an auxiliaryClass or TOP
                    // we leave them there, and we are finished
                    break;
                }
            }
        }
    }

    // the auxClass list should contain only auxClass or abstract classes
    // for all the abstract classes, check that they belong on the
    // hierarchy of one of the auxClasses

    for (j=0; j<pClassInfo->cNewAuxClasses; j++) {

        if (pClassInfo->pNewAuxClassesCC[j]->ClassCategory == DS_ABSTRACT_CLASS) {

            fFound = FALSE;
            for (i=0; i<pClassInfo->cNewAuxClasses; i++) {
                if (pClassInfo->pNewAuxClassesCC[i]->ClassCategory == DS_AUXILIARY_CLASS) {
                    
                    // see whether one class is subclass of the other
                    if (FindMoreSpecificClass(pClassInfo->pNewAuxClassesCC[i], 
                                              pClassInfo->pNewAuxClassesCC[j])) {
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound) {
                DPRINT1(0, "Object class(%s) should not be in list.\n", 
                        pClassInfo->pNewAuxClassesCC[j]->name);
                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_OBJ_CLASS_NOT_DEFINED);
            }
        }
    }

    // in case we implement targetPermittedclasses, this is the place for the check


    // possibly we removed a bunch of classes, some of them might be needed
    // the ones that are needed, we are going to add them back
    // in addition, we are going to add superclasses that are not 
    // already on the list

    if (fChangedAuxClass) {
        if (err = CloseAuxClassList (pTHS, pClassSch, pClassInfo)) {
            return err;
        }
    }

    if (pOriginalAuxClasses) {
        THFreeEx (pTHS, pOriginalAuxClasses);
    }

    if (pOldAuxClasses) {
        THFreeEx (pTHS, pOldAuxClasses);
    }

    return pTHS->errCode;
} // VerifyAndAdjustAuxClasses


//
// Reads the specified attribute from the object into the specified location
// This is to help filling in CLASSSTATEINFO datatypes
//
int ReadClassInfoAttribute (DBPOS *pDB,
                            ATTCACHE *pAC,
                            ATTRTYP **ppClassID,
                            DWORD    *pcClasses_alloced,
                            DWORD    *pcClasses,
                            CLASSCACHE ***ppClassCC)
{
    THSTATE *pTHS = pDB->pTHS;
    CLASSCACHE      *pCC;
    DWORD           err;
    ULONG           cLen;
    ATTRTYP         Temp, *pTemp;

    if (!*ppClassID) {
        *ppClassID = THAllocEx (pTHS, sizeof (ATTRTYP) * MIN_NUM_OBJECT_CLASSES);
        *pcClasses_alloced = MIN_NUM_OBJECT_CLASSES;
    }

    if (ppClassCC) {
        if (!*ppClassCC) {
            *ppClassCC = THAllocEx (pTHS, sizeof (CLASSCACHE *) * (*pcClasses_alloced));
        }
        else {
            *ppClassCC = THReAllocEx (pTHS, *ppClassCC, sizeof (CLASSCACHE *) * (*pcClasses_alloced));
        }
    }
    *pcClasses = 0;

    pTemp = &Temp;
    
    do {
        err = DBGetAttVal_AC(pDB, 
                             *pcClasses+1, 
                             pAC, 
                             DBGETATTVAL_fCONSTANT,
                             sizeof(ATTRTYP), 
                             &cLen, 
                             (UCHAR **)&pTemp);

        switch (err) {
           case DB_ERR_NO_VALUE:
                break;

           case 0:
                (*pcClasses)++;

                if (*pcClasses > *pcClasses_alloced) {
                    *pcClasses_alloced = *pcClasses_alloced * 2;
                    *ppClassID = THReAllocEx(pTHS, *ppClassID, 
                                             sizeof (ATTRTYP) * (*pcClasses_alloced));

                    if (ppClassCC) {
                        *ppClassCC = THReAllocEx (pTHS, *ppClassCC, 
                                             sizeof (CLASSCACHE *) * (*pcClasses_alloced));
                    }
                }
                (*ppClassID)[*pcClasses-1] = *pTemp;
                
                if (ppClassCC) {
                    if(!(pCC = SCGetClassById(pTHS, *pTemp))) {
                        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                                           ERROR_DS_MISSING_EXPECTED_ATT);
                    }

                    (*ppClassCC)[*pcClasses-1] = pCC;
                }
                break;

            default:
                // other error
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                              ERROR_DS_DATABASE_ERROR,
                              err); 
                return pTHS->errCode;

        }  /* switch */

    } while ( err == 0 );


    return pTHS->errCode;
} // ReadClassInfoAttribute


CLASSSTATEINFO  *ClassStateInfoCreate (THSTATE *pTHS) 
{
    CLASSSTATEINFO  *pClassInfo = THAllocEx (pTHS, sizeof (CLASSSTATEINFO));

    // set the objectClass
    if(!(pClassInfo->pObjClassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS))) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        
        THFreeEx (pTHS, pClassInfo);
        return NULL;
    }

    return pClassInfo;
}

void ClassStateInfoFree (THSTATE *pTHS, CLASSSTATEINFO  *pClassInfo)
{
    if (pClassInfo->pOldObjClasses) {
        THFreeEx(pTHS, pClassInfo->pOldObjClasses);
    }
    if (pClassInfo->pNewObjClasses) {
        THFreeEx(pTHS, pClassInfo->pNewObjClasses);
    }
    if (pClassInfo->pNewAuxClasses) {
        THFreeEx(pTHS, pClassInfo->pNewAuxClasses);
    }
    if (pClassInfo->pNewAuxClassesCC) {
        THFreeEx(pTHS, pClassInfo->pNewAuxClassesCC);
    }
    THFreeEx(pTHS, pClassInfo);
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check each attribute for which we actually added values to make sure that
   they do not violate any single valued constraints.  Do this now because we
   supressed this check while adding values since it is legal for mod to
   transiently violate single valuedness.
*/

int
ModCheckSingleValue (
        THSTATE *pTHS,
        MODIFYARG *pModifyArg
        )
{
   ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
   ATTCACHE    *pAC;
   DWORD        dwErr;


    if (pTHS->fDRA ||
        (pTHS->fSAM && pTHS->fDSA)){
        // Replication is allowed to perform modifications that violate the
        // schema, OR if it's SAM calling us and he's swearing that he's
        // only modifying SAM owned attributes, we'll trust him.
        return 0;
   }

   // visit and appy each att

   while (pAttList) {
       switch(pAttList->choice) {
       case AT_CHOICE_REPLACE_ATT:
       case AT_CHOICE_ADD_ATT:
       case AT_CHOICE_ADD_VALUES:
           // These operations all add values to the database, so they might
           // have violated single-value constraints.

           // Objects are in schema or we'd have failed already.
           pAC = SCGetAttById(pTHS, pAttList->AttrInf.attrTyp);
           Assert(pAC != NULL);
           // ignore the funky constructed attribute, EntryTTL
           if(    pAC 
               && pAC->isSingleValued
               && pAC->id != ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

               ULONG Len;
               ULONG Temp, *pTemp;
               pTemp = &Temp;

               // Ok, look for too many values.
               dwErr = DBGetAttVal_AC(pTHS->pDB, 2, pAC,
                                      DBGETATTVAL_fINTERNAL | DBGETATTVAL_fCONSTANT,
                                      sizeof(Temp),
                                      &Len,
                                      (UCHAR **) &pTemp);
               if(dwErr != DB_ERR_NO_VALUE) {
                   // Too many values. Gronk.
                   return SetAttError(pModifyArg->pObject,
                                      pAttList->AttrInf.attrTyp,
                                      PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                      ERROR_DS_SINGLE_VALUE_CONSTRAINT);
               }
           }
           break;
       default:
           // These operations do not add values to the database, so they can't
           // have violated single-value constraints.
           break;
       }
       pAttList = pAttList->pNextMod;
   }

   return pTHS->errCode;
} /* ModCheckSIngleValue */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

BOOL
SysModReservedAtt (
        THSTATE *pTHS,
        ATTCACHE *pAC,
        CLASSCACHE *pClassSch
        )
{
    // TRUE means the attribute is reserved and should not be added
    // We discriminate based on attribute id. Also, we don't allow
    // adding backlink attributes or attributes marked as system only.

    if(pAC->bSystemOnly && !(pTHS->fDRA || pTHS->fDSA) ) {
        // only the DRA or the DSA can modify system only attributes.
        return TRUE;
    }

    switch (pAC->id) {
    case ATT_OBJ_DIST_NAME:
    case ATT_USN_CREATED:
    case ATT_SUB_REFS:
    case ATT_USN_LAST_OBJ_REM:
    case ATT_USN_DSA_LAST_OBJ_REMOVED:
    case ATT_RDN:
        return TRUE;
        break;

    case ATT_IS_DELETED:
    case ATT_HAS_MASTER_NCS:
    case ATT_HAS_PARTIAL_REPLICA_NCS:
        // fall through
    case ATT_OBJECT_CLASS:
    case ATT_WHEN_CREATED:
        // NOTE: The DRA must be allowed to do these to instantiate a naked
        // SUBREF into the real NC head.
        return !(pTHS->fDRA);
        break;

    default:
        return FIsBacklink(pAC->ulLinkID);
    }

}/*SysModReservedAtt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add or remove whole attributes of specific attribute values.  Attributes
   and attribute values to be added require that that the attribute type
   exist in the schema.
*/

int
ApplyAtt(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pObj,
    IN  HVERIFY_ATTS    hVerifyAtts,
    IN  ATTCACHE *      pAttSchema,
    IN  ATTRMODLIST *   pAttList,
    IN  COMMARG *       pCommArg
    )
{
    ATTRTYP attType = pAttList->AttrInf.attrTyp;
    DWORD dwFlags;
    DWORD err;

    DPRINT(1, "ApplyAtt entered\n");

    switch (pAttList->choice){
    case AT_CHOICE_REPLACE_ATT:
        DPRINT1(2, "Replace att <%lu>\n", attType);
        return ReplaceAtt(pTHS,
                          hVerifyAtts,
                          pAttSchema,
                          &(pAttList->AttrInf.AttrVal),
                          TRUE);

    case AT_CHOICE_ADD_ATT:
        DPRINT1(2, "Add att <%lu>\n", attType);
        return AddAtt(pTHS, hVerifyAtts, pAttSchema,
                      &pAttList->AttrInf.AttrVal);

    case AT_CHOICE_REMOVE_ATT:
        DPRINT1(2, "Remove att <%lu>\n", attType);
        err = DBRemAtt_AC(pTHS->pDB, pAttSchema);
        switch (err) {
        case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
            if (pCommArg->Svccntl.fPermissiveModify) {
                /* caller doesn't care if it wasn't there to begin with */
                return 0;
            }
            DPRINT1(2, "Att does not exist %lu\n", attType);
            return SetAttError(pObj, attType,
                               PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                               ERROR_DS_ATT_IS_NOT_ON_OBJ);
        case 0:
            return 0;

        default:
            Assert(!"New return code added for DBRemAtt_AC?");
            return SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR);
        }

        break;

    case AT_CHOICE_ADD_VALUES:
        DPRINT1(2, "Add vals <%lu>\n", attType);
        dwFlags = AAV_fCHECKCONSTRAINTS;
        if (pCommArg->Svccntl.fPermissiveModify) {
            dwFlags |= AAV_fPERMISSIVE;
        }
        return AddAttVals(pTHS,
                          hVerifyAtts,
                          pAttSchema, 
                          &(pAttList->AttrInf.AttrVal),
                          dwFlags); 

    case AT_CHOICE_REMOVE_VALUES:
        DPRINT1(2, "Rem vals from att <%lu>\n", attType);
        return RemAttVals(pTHS,
                          hVerifyAtts,
                          pAttSchema,
                          &(pAttList->AttrInf.AttrVal),
                          pCommArg->Svccntl.fPermissiveModify);

    default:
        DPRINT(2, "Bad modify choice given by the user.. will not perform\n");
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             ERROR_DS_ILLEGAL_MOD_OPERATION,
                             pAttList->choice);
    }/*switch*/

    //
    // Added to remove sundown warning. Should never come here.
    //

    Assert(FALSE);
    return 0;

}/*ApplyAtt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function compares the pre and post modification instance types
    and updates the system catalog if they are changed.  For now we take
   the simple approach deleting and re-adding the catalog info if the type
   has changed.  Since this is an update event, expense is no problem.
*/

int
ModCheckCatalog(THSTATE *pTHS,
                RESOBJ *pResObj)
{
    SYNTAX_INTEGER beforeInstance = pResObj->InstanceType;
    SYNTAX_INTEGER afterInstance;
    DWORD err;

    DPRINT(1,"ModCheckCatalog entered\n");

    /* Position on the attribute instance.  */
    if (err = DBGetSingleValue(pTHS->pDB,
                               ATT_INSTANCE_TYPE,
                               &afterInstance,
                               sizeof(afterInstance),
                               NULL)) {

        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                      ERROR_DS_MISSING_EXPECTED_ATT,
                      err); 
        DPRINT(0,"Couldn't retrieve INSTANCE type error already set\n");
        return pTHS->errCode;
    }

    DPRINT2(2,"Before Instance <%lu>.  After Instance <%lu>\n",
            beforeInstance, afterInstance);

    /* Update global info inf the object instance has changed*/

    if (beforeInstance == afterInstance){
        DPRINT(2, "Object instance unchanged...return\n");
        return 0;
    }
    DPRINT(2,"instance type different..process\n");

    /* In most cases a change in instance type is handled by simply deleting
       old catalog info and adding new stuff. The following IF handles
       two special cases.. One is moving from a NC to an INT reference and
       the other is from an INT to an NC.  These are special because the
       SUBREF info kept on these objects must be moved.  Handle this special
       case and then perform the standard delete then add.
       */
    if(!(beforeInstance & IT_UNINSTANT) && !(afterInstance & IT_UNINSTANT)) {
        // Ok, we aren't dealing with a pure subref here.

        if( (beforeInstance & IT_NC_HEAD) &&
           !(afterInstance  & IT_NC_HEAD)    ) {

            DPRINT(2,"Special case NC->INT .move SUB info to it's parentNC\n");
            if (MoveSUBInfoToParentNC(pTHS, pResObj->pObj))
                return pTHS->errCode;
        }
        else if(!(beforeInstance & IT_NC_HEAD) &&
                (afterInstance  & IT_NC_HEAD)    ) {

            DPRINT(2,"Special case INT->NC ref,take SUB info from parentNC\n");
            if (MoveParentSUBInfoToNC(pTHS, pResObj->pObj))
                return pTHS->errCode;
        }
    }

    /* Remove all catalog references for the object under its old type and
       add catalog info under its new type...
       */

    DPRINT(2, "Object instance changed so delete then add global info\n");

    if (DelCatalogInfo(pTHS, pResObj->pObj, beforeInstance)){
        DPRINT(2,"Error while deleting global object info\n");
        return pTHS->errCode;
    }

    DPRINT(2, "Global obj info deleted...no add \n");

    return AddCatalogInfo(pTHS, pResObj->pObj);

}/*ModCheckCatalog*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function check if there is a mixed mode domain,  in the forest if
   fDomainOnly if false; or in the current domain if the fDomainONly is true.
   If fDomainOnly is false, this function does a search in the Partitions
   container for a domain cross-ref with non-zero ntmixeddomain attribute or 
   without this attribute; If fDomainOnly is true, we simply check the 
   ntMixedDomain attribute on the domain-DNS object.
*/

DWORD VerifyNoMixedDomain(THSTATE *pTHS, BOOL fDomainOnly)
{

    LONG lMixedDomain = 0;
    DWORD err;
    DWORD FlagValue = FLAG_CR_NTDS_DOMAIN;
    CLASSCACHE * pCC;
    FILTER AndFilter, SystemFlagsFilter, NotFilter, ObjCategoryFilter, MixedDomainFilter;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    if (fDomainOnly) {
        //check if a domain is in mixed mode
        //if so, return false;

        err = DBFindDSName(pTHS->pDB,gAnchor.pDomainDN);
        if (err) {
            SetSvcErrorEx( SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_DATABASE_ERROR,
                           err );
            return err;

        }

        err = DBGetSingleValue( pTHS->pDB,
                                ATT_NT_MIXED_DOMAIN,
                                (void*)&lMixedDomain,
                                sizeof(lMixedDomain),
                                NULL );
        if (err) {
            if (DB_ERR_NO_VALUE == err) {
                //non-existence of this attribute 
                //means it is not a mixed domain;
                lMixedDomain = 0;   
                err = 0;

            }
            else {
                SetSvcErrorEx( SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_DATABASE_ERROR,
                               err );
                DPRINT(2,"IsValidBehaviorVersionChange returns FALSE, DB error\n");
                return err;

            }
        }

        if (lMixedDomain) {
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN );
            err = ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN;
            LogEvent( DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_NO_VERSION_UPGRADE_IN_MIXED_DOMAIN,
                      szInsertDN(gAnchor.pDomainDN),
                      NULL,
                      NULL );
            DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, the domain is a mixed domain\n");
            return err;
        }

    } //if (fDomain)
    else {
        //looks for mixed domain forest-wide
        
        //initialize SearchArg
        memset(&SearchArg,0,sizeof(SearchArg));
        SearchArg.pObject = gAnchor.pPartitionsDN;
        SearchArg.choice  = SE_CHOICE_IMMED_CHLDRN;
        SearchArg.bOneNC  = TRUE;

        if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
            SetSvcErrorEx( SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_DATABASE_ERROR,
                           err );
            return err;
        }

        SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);
    
        InitCommarg(&SearchArg.CommArg);
    
        pCC = SCGetClassById(pTHS, CLASS_CROSS_REF);
        Assert(pCC);
    
        // construct filter "(objCategory==CROSS_REF)&&(systemFlags&2)&&!(ntMixedDomain==0)"
        memset(&AndFilter,0,sizeof(AndFilter));
        AndFilter.choice = FILTER_CHOICE_AND;
        AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;
        
        memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
        ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
        ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
        ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                         pCC->pDefaultObjCategory->structLen;
        ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                         (BYTE*)(pCC->pDefaultObjCategory);
        ObjCategoryFilter.pNextFilter = &SystemFlagsFilter;
        
        memset(&SystemFlagsFilter,0,sizeof(SystemFlagsFilter));
        SystemFlagsFilter.choice = FILTER_CHOICE_ITEM;
        SystemFlagsFilter.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
        SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SYSTEM_FLAGS;
        SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                         sizeof(DWORD);
        SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                         (BYTE*)&FlagValue;
        SystemFlagsFilter.pNextFilter = &NotFilter;
        
        memset(&NotFilter,0,sizeof(NotFilter));
        NotFilter.choice = FILTER_CHOICE_NOT;
        NotFilter.FilterTypes.pNot = &MixedDomainFilter;
        
        memset(&MixedDomainFilter,0,sizeof(MixedDomainFilter));
        MixedDomainFilter.choice = FILTER_CHOICE_ITEM;
        MixedDomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        MixedDomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NT_MIXED_DOMAIN;
        MixedDomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(lMixedDomain);
        MixedDomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)&lMixedDomain;
        
        SearchArg.pFilter = &AndFilter;
    
        //return one object only
        SearchArg.CommArg.ulSizeLimit = 1;
    
        memset(&SearchRes,0,sizeof(SearchRes));
    
        if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
            DPRINT1(2, "IsValidBehaviorVersionChange returns FALSE, LocalSearch failed with err(%x)\n", err);
            return err;;
        }
        
        if (0 != SearchRes.count) {
            err = ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN;
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         err );
            DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, a dsa with lower version exists.\n");
            return err;
        }
    }
    return 0;

}

/* Following array stores the XML scripts that are invoked
when the forest version is raised. Element i stores the 
script for forest version raised from i to i+1 or greater.
*/

WCHAR * pForestVersionUpdateScripts[] =
{ 
 /* Script that will be executed when rasing forest version from 0 to 1*/
 L"<?xml version='1.0'?>\r\n"
 L"<NTDSAscript>\r\n" 
 L"   <!-- Executed when forest version is raised from 0 to 1*-->\r\n"
 L"   <action>\r\n"
 L"      <condition>\r\n"
 L"        <if>\r\n"
 L"    	    <predicate test=\"compare\" path=\"$CN=ms-DS-Trust-Forest-Trust-Info,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"        <then>\r\n"
 L"	        <action>\r\n"
 L"	           <update path=\"$CN=ms-DS-Trust-Forest-Trust-Info,$SchemaNCDN$\">\r\n"
 L"   	         <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L" 	        </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Trust-Direction,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"        <then>\r\n"
 L"	        <action>\r\n"
 L"	           <update path=\"$CN=Trust-Direction,$SchemaNCDN$\">\r\n"
 L"	             <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L"	        </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"            <predicate test=\"compare\" path=\"$CN=Trust-Attributes,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"	      <then>\r\n"
 L"	        <action>\r\n"
 L" 	          <update path=\"$CN=Trust-Attributes,$SchemaNCDN$\">\r\n"
 L"	             <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"         </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"       <if>\r\n"
 L"         <predicate test=\"compare\" path=\"$CN=Trust-Type,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"	     <then>\r\n"
 L"         <action>\r\n"
 L"           <update path=\"$CN=Trust-Type,$SchemaNCDN$\">\r\n"
 L"	            <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"           </update>\r\n"
 L"         </action>\r\n"
 L"       </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Trust-Partner,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"  	  <then>\r\n"
 L"	        <action>\r\n"
 L"	          <update path=\"$CN=Trust-Partner,$SchemaNCDN$\">\r\n"
 L" 	            <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Security-Identifier,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"  	  <then>\r\n"
 L"	        <action>\r\n"
 L"	          <update path=\"$CN=Security-Identifier,$SchemaNCDN$\">\r\n"
 L"	       	    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"	        </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=ms-DS-Entry-Time-To-Die,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"	      <then>\r\n"
 L"	         <action>\r\n"
 L"	            <update path=\"$CN=ms-DS-Entry-Time-To-Die,$SchemaNCDN$\" >\r\n"
 L"	              <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"              </update>\r\n"
 L"           </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=MSMQ-Secured-Source,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"	      <then>\r\n"
 L"	        <action>\r\n"
 L"	           <update path=\"$CN=MSMQ-Secured-Source,$SchemaNCDN$\" >\r\n"
 L"	              <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L"	        </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"	        <predicate test=\"compare\" path=\"$CN=MSMQ-Multicast-Address,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L" 	     <then>\r\n"
 L"	       <action>\r\n"
 L"	          <update path=\"$CN=MSMQ-Multicast-Address,$SchemaNCDN$\" >\r\n"
 L"	            <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"	       </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"      <if>\r\n"
 L"        <predicate test=\"compare\" path=\"$CN=ms-MMS-Version,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"	    </if>\r\n"
 L"	    <then>\r\n"
 L"        <action>\r\n"
 L"           <update path=\"$CN=ms-MMS-Version,$SchemaNCDN$\" >\r\n"
 L"	            <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"           </update>\r\n"
 L"	      </action>\r\n"
 L"      </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"      <if>\r\n"
 L"        <predicate test=\"compare\" path=\"$CN=ms-MMS-MA-Category,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"      </if>\r\n"
 L" 	    <then>\r\n"
 L"        <action>\r\n"
 L"	        <update path=\"$CN=ms-MMS-MA-Category,$SchemaNCDN$\" >\r\n"
 L"	          <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"          </update>\r\n"
 L"        </action>\r\n"
 L"      </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=ms-MMS-Service-Name,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"         <action>\r\n"
 L"	          <update path=\"$CN=ms-MMS-Service-Name,$SchemaNCDN$\" >\r\n"
 L"   		    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"	       </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=ms-MMS-Domain-Controller,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"	          <update path=\"$CN=ms-MMS-Domain-Controller,$SchemaNCDN$\" >\r\n"
 L"     		    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Memory,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"	          <update path=\"$CN=Print-Memory,$SchemaNCDN$\" >\r\n"
 L"     		    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Rate,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"	          <update path=\"$CN=Print-Rate,$SchemaNCDN$\" >\r\n"
 L"     		    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Rate-Unit,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"	          <update path=\"$CN=Print-Rate-Unit,$SchemaNCDN$\" >\r\n"
 L"     		    <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L" </NTDSAscript>\r\n"
 ,
 /* Script that will be executed when raising forest version from 1 to 2*/
 NULL

};

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function is called when the forest version is raised, and it will 
   execute the XML scripts to do some necessary updates.  So far, when the
   forest version is changed from 0 to 1, we put some attributes into 
   partial attribute set.
   
   Return value: 0 on success; win32 error code otherwise.
*/

DWORD forestVersionRunScript(THSTATE * pTHS, DWORD oldVersion, DWORD newVersion)
{
    DWORD i;
    DWORD err = 0;
    DBPOS *pDBSave;
    SCENUM SchemaUpdate;

    Assert(oldVersion <= newVersion && newVersion <= DS_BEHAVIOR_VERSION_CURRENT);
    Assert(DS_BEHAVIOR_VERSION_CURRENT<=sizeof(pForestVersionUpdateScripts)/sizeof(WCHAR*));

    pDBSave = pTHS->pDB;
    pTHS->pDB = NULL;
    SchemaUpdate = pTHS->SchemaUpdate;
    DBOpen2(TRUE, &pTHS->pDB);
    __try{
        for (i=oldVersion; i<newVersion; i++) {
            if (pForestVersionUpdateScripts[i]) {
                err = GeneralScriptExecute(pTHS,pForestVersionUpdateScripts[i]);
                DPRINT2(0,"Behavior version update script %d is executed, err=%d\n", i, err);
                if (err) {
                    __leave;
                }
            
            }
    
        } 
    }
    __finally{
        DBClose(pTHS->pDB,!err);
        pTHS->pDB = pDBSave;
        pTHS->SchemaUpdate = SchemaUpdate;

    }
    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdname.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdname.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <sddl.h>                       // For SID conversion routines.

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "MDNAME:"            // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDNAME


NAMING_CONTEXT * CheckForNCExit(THSTATE *pTHS,
                                NAMING_CONTEXT * pNC,
                                DSNAME * pObj);

ATTRBLOCK RootDNB = {0, NULL};
ATTRBLOCK * gpRootDNB= &RootDNB;


unsigned
GenAutoReferral(THSTATE *pTHS,
                ATTRBLOCK *pTarget,
                WCHAR **ppDNS);

DWORD
DoExtendedNameRes (
        THSTATE  *pTHS,
        ATTCACHE *pAC,
        DSNAME   *pTempDN,
        GUID     *pGuid
        )
/*++
  Description:
      Look through the values of the pAC attribute (which is a distname binary)
      for a value that has the binary portion equal to the guid passed in.  When
      found, get the guid from the name portion and put it in pTemp.

  Parameters:
      pTHS - thread state
      pAC  - attribute to read.  Expect values are ATT_WELL_KNOWN_OBJECTS and
             ATT_OTHER_WELL_KNOWN_OBJECTS.
      pTempDN - DN buffer.  Size is at least DSNameSizeFromLen(0).  On success,
             the found objects GUID is put into this as a GUID only name.
      pGuid - The guid we're looking for.
--*/
{
    SYNTAX_DISTNAME_BINARY *pVal;
    DWORD   iVal;
    DWORD   err2 = 0, len;
    DWORD   fFound = FALSE;
    
    iVal = 0;
    while ( !(err2 || fFound))  {
        iVal++;
        pVal = NULL;
        
        err2 = DBGetAttVal_AC(pTHS->pDB,
                              iVal,
                              pAC,
                              0,
                              0,
                              &len,
                              (UCHAR **) &pVal);
        
        if(!err2 &&
           !memcmp(pGuid,
                   DATAPTR(pVal)->byteVal,
                   sizeof(GUID)) ) {
            fFound = TRUE;
            memset(pTempDN, 0, DSNameSizeFromLen(0));
            pTempDN->Guid = NAMEPTR(pVal)->Guid;
            pTempDN->structLen = DSNameSizeFromLen(0);
        }
        THFreeEx(pTHS, pVal);
    }

    // Either we found the object with no error, or we didn't find the object
    // and errored out.
    Assert((fFound && !err2) || (!fFound && err2));
    
    if(fFound) {
        __try {
            err2 = DBFindDSName(pTHS->pDB, pTempDN);
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            err2 = DIRERR_OBJ_NOT_FOUND;
        }
    }
    
    return err2;
}

/*++ DoNameRes - locates an object by name
 *
 * Given the name of a purported DS object, this routine either positions
 * to the object in the local database, returns a referral to another DSA
 * that should have a better chance of locating the object.
 *
 * INPUT:
 *    dwFlags    - values and meanings:
 *        NAME_RES_PHANTOMS_ALLOWED: successful return even if the object
 *                 being resolved exists locally only as a phantom.  Used
 *                 by some flat-search code.
 *        NAME_RES_VACANCY_ALLOWED: This should always succeed, either finding
 *                 a current record or just returning a faked up resobj
 *                 if no such record exists.
 *    queryOnly  - TRUE if a read/only copy of the object is acceptable
 *    childrenNeeded - TRUE if we must resolve to a copy of the object
 *                     where the children of that object are locally available.
 *    pObj       - pointer to DSNAME of purported object
 *    pComArg    - pointer to common arguments
 *    pComRes    - pointer to common results set
 *    ppResObj   - pointer to pointer to be filled in
 * OUTPUT:
 *    *ppResObj filled in with a pointer to a RESOBJ structure that includes
 *    pre-fetched information about the object.  Note that the pObj field of
 *    the ResObj will be filled in with the pObj argument itself, and that
 *    that DSNAME will have its GUID and SID fields filled out completely.
 * RETURN VALUE:
 *    error code, as set in THSTATE
 */
int DoNameRes(THSTATE *pTHS,
              DWORD dwFlags,
              DSNAME *pObj,
              COMMARG *pComArg,
              COMMRES *pComRes,
              RESOBJ **ppResObj)
{
    DWORD err;
    ULONG it, isdel, vallen;
    UCHAR *pVal;
    NAMING_CONTEXT * pNC, *pSubNC;
    CROSS_REF * pCR;
    ATTRBLOCK *pObjB=NULL;
    ATTRTYP msoc;
    BOOL fPresentButInadequate = FALSE;
    BOOL fNDNCObject = FALSE;

    /* catch ill-formed DSNAMEs */
    Assert(pObj->NameLen == 0 || pObj->StringName[pObj->NameLen] == L'\0');
    Assert(pObj->NameLen == 0 || pObj->StringName[pObj->NameLen-1] != L'\0');
    Assert(pObj->structLen >= DSNameSizeFromLen(pObj->NameLen));

    __try {
        *ppResObj = NULL;
        err = DBFindDSName(pTHS->pDB, pObj);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    if((err == ERROR_DS_OBJ_NOT_FOUND) && 
       (pObj->NameLen) &&
       (!pObj->SidLen) &&
       (!fNullUuid(&(pObj->Guid)))) {
        // We were given a name with a guid AND a string, but failed to find the
        // object.  In this case, the guid may be a well-known-guid and the
        // string the dn of an object with a wellKnownObjects attribute.
        DSNAME *pTempDN;
        DWORD   err2;
        ATTCACHE *pAC = SCGetAttById(pTHS, ATT_WELL_KNOWN_OBJECTS);
        
        if(pAC) {
            pTempDN = THAllocEx(pTHS, pObj->structLen);
            memcpy(pTempDN, pObj, pObj->structLen);
            memset(&pTempDN->Guid, 0, sizeof(GUID));
            __try{
                err2 = DBFindDSName(pTHS->pDB, pTempDN);
            }
            __except (HandleMostExceptions(GetExceptionCode())) {
                err2 = DIRERR_OBJ_NOT_FOUND;
            }
            
            if(!err2) {
                // Found something by string name.  Now, read the 
                // wellKnownObjects  property, looking for something with the
                // correct GUID.
                if(!DoExtendedNameRes(pTHS, pAC, pTempDN, &pObj->Guid)) {
                    // found an object through indirection.  Use it.
                    Assert(pTempDN->structLen <= pObj->structLen);
                    memcpy(pObj, pTempDN, pTempDN->structLen);
                    err = 0;
                }
                else {
                    pAC = SCGetAttById(pTHS, ATT_OTHER_WELL_KNOWN_OBJECTS);
                    if(pAC && !DoExtendedNameRes(pTHS,
                                                 pAC,
                                                 pTempDN,
                                                 &pObj->Guid)) { 
                        // found an object through indirection. Use it.
                        Assert(pTempDN->structLen <= pObj->structLen);
                        memcpy(pObj, pTempDN, pTempDN->structLen);
                        err = 0;
                    }
                }
            }
            THFreeEx(pTHS, pTempDN);
        }
    }

    if (!err) {
        // found an object, let's see if it's good enough
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_IS_DELETED,
                               &isdel,
                               sizeof(isdel),
                               NULL);
        if (err) {
            if (DB_ERR_NO_VALUE == err) {
                // Treat having no value the same as being false.
                  isdel = 0;
                err = 0;
            }
            else {
                // I don't know what happened, but it isn't good.
                goto NotFound;
            }
        }
        if(isdel && !pComArg->Svccntl.makeDeletionsAvail) {
            // If we're only looking for live objects and this isn't one,
            // bail out now.
            goto NotFound;
        }

        err = DBGetSingleValue(pTHS->pDB,
                               ATT_INSTANCE_TYPE,
                               &it,
                               sizeof(it),
                               NULL);
        if (err) {
            if (DB_ERR_NO_VALUE == err) {
                // Treat having no value the same as not being there.
                it = IT_UNINSTANT;
                err = 0;
            }
            else {
                // I don't know what happened, but it isn't good.
                goto NotFound;
            }
        }
        if (it & IT_UNINSTANT) {
            // The object is not instantiated.  Do the phantom check.
            if (dwFlags &
                (NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED)) {
                goto DoPhantomCheck;
            }
            else {
                goto NotFound;
            }
        }

        if(pComArg->Svccntl.dontUseCopy &&
           !(it & IT_WRITE))                {
            // it was not writable and they wanted only writable objects.
            fPresentButInadequate = TRUE;
            goto NotFound;
        }

        if(dwFlags & NAME_RES_GC_SEMANTICS){
            // This is a GC port operation, and we want GC port operations
            // to be completely unaware of NDNCs.
            if(gAnchor.pNoGCSearchList &&
               bsearch(((it & IT_NC_HEAD) ?  
                          &pTHS->pDB->DNT :
                          &pTHS->pDB->NCDNT), // The Key to search for.
                       gAnchor.pNoGCSearchList->pList, // sorted array to search.
                       gAnchor.pNoGCSearchList->cNCs, // number of elements in array.
                       sizeof(ULONG), // sizeof each element in array.
                       CompareDNT) ){
                // This was one of the NCs weren't not supposed to
                // operate on objects from.
                fPresentButInadequate = TRUE;
                fNDNCObject = TRUE;
                goto NotFound;
            }
        }

        fPresentButInadequate = FALSE;

        // We found the object and it's good enough.  Make sure the GUID and
        // SID are filled in.
        DBFillGuidAndSid(pTHS->pDB, pObj);

        // Get the rest of the attributes needed to fill out the resobj
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_OBJECT_CLASS,
                               &msoc,
                               sizeof(msoc),
                               NULL);
        if (err) {
            // Treat any error in class as being the most generic class
            msoc = CLASS_TOP;
        }
        *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        if (dwFlags & NAME_RES_IMPROVE_STRING_NAME) {
       
        err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_OBJ_DIST_NAME,
                              0,
                              0,
                              &vallen,
                              (CHAR **)&((*ppResObj)->pObj));
            if (err) {
                // I don't know what happened, but it isn't good.
                goto NotFound;
            }
        }
        else {
            // input string name (if any) is good enough
            (*ppResObj)->pObj = pObj;
        }
        (*ppResObj)->DNT = pTHS->pDB->DNT;
        (*ppResObj)->PDNT = pTHS->pDB->PDNT;
        (*ppResObj)->NCDNT = (it & IT_NC_HEAD)
                             ? pTHS->pDB->DNT : pTHS->pDB->NCDNT;
        (*ppResObj)->InstanceType = it;
        (*ppResObj)->IsDeleted = isdel;
        (*ppResObj)->MostSpecificObjClass = msoc;

        // Set flags and return
        pComRes->aliasDeref = FALSE;
        return 0;
    }

    if (err == DIRERR_NOT_AN_OBJECT &&
        (dwFlags & NAME_RES_PHANTOMS_ALLOWED)) {
        // OK, we found a phantom and they said that phantoms were ok as search
        // roots. Before we go on with this, make sure there is some naming
        // context under this phantom.
    DoPhantomCheck:

        err = DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE);
        if (err) {
            SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                          pObj,
                          DIRERR_BAD_NAME_SYNTAX,
                          err);
            return (pTHS->errCode);
        }
        if (  (dwFlags & NAME_RES_VACANCY_ALLOWED)
            || fHasDescendantNC(pTHS, pObjB, pComArg)) {

            // OK, there is either something under this phantom, or we
            // don't care.  Go for it.
            pComRes->aliasDeref = FALSE;
            // we don't need this anymore...
            FreeBlockName(pObjB);

            *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
            (*ppResObj)->pObj = pObj;
            (*ppResObj)->DNT = pTHS->pDB->DNT;
            (*ppResObj)->PDNT = pTHS->pDB->PDNT;
            (*ppResObj)->NCDNT = pTHS->pDB->NCDNT;
            (*ppResObj)->InstanceType = IT_UNINSTANT;
            (*ppResObj)->IsDeleted = TRUE;
            (*ppResObj)->MostSpecificObjClass = CLASS_TOP;

            return 0;
        }
    }


 NotFound:

    if (dwFlags & NAME_RES_VACANCY_ALLOWED) {
        // There's no object there, but that's ok.
        // Create a null resobj and send it back.
        *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        (*ppResObj)->pObj = pObj;
        (*ppResObj)->DNT = INVALIDDNT;
        (*ppResObj)->PDNT = INVALIDDNT;
        (*ppResObj)->NCDNT = INVALIDDNT;
        (*ppResObj)->InstanceType = IT_UNINSTANT;
        (*ppResObj)->IsDeleted = TRUE;
        (*ppResObj)->MostSpecificObjClass = CLASS_TOP;
        return 0;
    }

    if (pObj->NameLen == 0) {

        // Failed a search for <SID=...>; try to generate a referral
        if(pObj->SidLen && fNullUuid(&pObj->Guid)) {
            DWORD cbDomainSid;
            PSID pDomainSid = NULL;
            CROSS_REF *FindCrossRefBySid(PSID pSID);

            // Extract the domain portion of the SID and locate a crossRef
            cbDomainSid = pObj->SidLen;
            pDomainSid = THAllocEx(pTHS, cbDomainSid);
            if (GetWindowsAccountDomainSid(&pObj->Sid, pDomainSid, &cbDomainSid)
                && (NULL != (pCR = FindCrossRefBySid(pDomainSid)))) {
                THFreeEx(pTHS, pDomainSid);
                return GenCrossRef(pCR, pObj);
            }
            THFreeEx(pTHS, pDomainSid);
        }

        // If we don't have a string name, we're searching only on GUID.
        // We haven't found an object with the requested GUID, but that
        // may or may not tell us much.  If this server is a Global
        // Catalog server then we have an exhaustive list of all objects
        // in the enterprise, so we can state that the object does not
        // exist.  If we're not a GC, though, we need to refer to a GC
        // in order to answer the question, because the GUID could belong
        // to an object in another NC.
        // We also return an error if there was no GUID in the object, because
        // then the DSNAME was that of the root (no name, no guid), and
        // you can't resolve the root as a base object unless you set
        // the PHANTOMS_ALLOWED flag, in which case you would have already
        // succeeded.
        if ((gAnchor.fAmGC && !fPresentButInadequate)
            || fNullUuid(&pObj->Guid)) {
            SetNamError(NA_PROBLEM_NO_OBJECT,
                        NULL,
                        DIRERR_OBJ_NOT_FOUND);
        }
        else {
            // The name has a GUID, and either I'm not a GC and couldn't
            // find it, or I am a GC but not called through the GC port
            // and the copy I found was only partial.
            GenSupRef(pTHS, pObj, gpRootDNB, pComArg, NULL);
        }
        return pTHS->errCode;
    }

    // We might have already blockified the name
    if(!pObjB) {
        err = DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE);
        if (err) {
            SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                          pObj,
                          DIRERR_BAD_NAME_SYNTAX,
                          err);
            return (pTHS->errCode);
        }
    }
    pNC = FindNamingContext(pObjB, pComArg);

    if(pNC && !fNDNCObject && (pSubNC = CheckForNCExit(pTHS, pNC, pObj)) == NULL) {
        // We found the best candidate NC that is held on this server,
        // and found that there was no NC exit point between that candidate
        // NC and the purported object, which means that if the object
        // exists it must be in this NC.  However, we already know that the
        // object does not exist on this server, which means that the object
        // does not exist at all.
        DSNAME *pBestMatch=NULL;

        DBFindBestMatch(pTHS->pDB, pObj, &pBestMatch);

        SetNamError(NA_PROBLEM_NO_OBJECT,
                    pBestMatch,
                    DIRERR_OBJ_NOT_FOUND);

        THFreeEx(pTHS, pBestMatch);
        return (pTHS->errCode);
    }

    if(fNDNCObject){
        // BUGBUG Basically we bail out here pretending we don't have the
        // the object. However the correct thing to do is generate a referral
        // to the NDNC for port 389.
        SetNamError(NA_PROBLEM_NO_OBJECT,
                    NULL,
                    DIRERR_OBJ_NOT_FOUND);
        
    }

    // If we're here it's either because we hold no NC related in any way
    // to the purported object, or we hold an NC above the one in which
    // the purported object would reside.  While we could generate a
    // subref in the latter case, we have decided to only maintain information
    // for cross refs, and to generate those instead of subrefs.

    // can we find a decent cross ref?
    if (pCR = FindCrossRef(pObjB, pComArg)) {
        // yes, so build the thing

        GenCrossRef(pCR, pObj);
    }
    else {
        // no, so wimp out entirely
        GenSupRef(pTHS, pObj, pObjB, pComArg, NULL);
    }

    // we don't need this anymore...
    FreeBlockName(pObjB);

    return (pTHS->errCode);

}

/*++ CreateResObj
 *
 *  This routine creates and fills in a RESOBJ structure for the currently
 *  positioned object.  Used by callers who for some reason need to bypass
 *  DoNameRes but still want to be able to call the LocalFoo routines which
 *  all require a completed ResObj.
 *
 *  INPUT:
 *    pDN    - pointer to DSNAME to be placed in the RESOBJ.  If NULL, a
 *             faked up empty RESOBJ is created (this is expected only
 *             during NC creation).
 *  RETURN VALUE:
 *    pointer to freshly allocated RESOBJ
 */
RESOBJ * CreateResObj(DBPOS *pDB,
                      DSNAME *pDN)
{
    THSTATE *pTHS = pDB->pTHS;
    RESOBJ * pResObj;
    DWORD realDNT;

    if (pDN) {
        pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        pResObj->DNT = pDB->DNT;
        pResObj->PDNT = pDB->PDNT;
        pResObj->pObj = pDN;

        // We could use DBGetMultipleVals here, but it seems to impose more in
        // memory management overhead than Jet does in individual calls, so
        // we'll instead just invoke the simplest wrapper we can multiple times
        if (DBGetSingleValue(pDB,
                             ATT_INSTANCE_TYPE,
                             &pResObj->InstanceType,
                             sizeof(pResObj->InstanceType),
                             NULL)) {
            pResObj->InstanceType = 0;
        }
        pResObj->NCDNT = (pResObj->InstanceType & IT_NC_HEAD)
                         ? pDB->DNT : pDB->NCDNT;

        if (DBGetSingleValue(pDB,
                             ATT_IS_DELETED,
                             &pResObj->IsDeleted,
                             sizeof(pResObj->IsDeleted),
                             NULL)) {
            pResObj->IsDeleted = 0;
        }
        if (DBGetSingleValue(pDB,
                             ATT_OBJECT_CLASS,
                             &pResObj->MostSpecificObjClass,
                             sizeof(pResObj->MostSpecificObjClass),
                             NULL)) {
            pResObj->MostSpecificObjClass = 0;
        }

        if (fNullUuid(&pDN->Guid)) {
            UCHAR *pb = (UCHAR*)&pDN->Guid;
            ULONG len;
            if (DBGetAttVal(pDB,
                            1,
                            ATT_OBJECT_GUID,
                            DBGETATTVAL_fCONSTANT,
                            sizeof(GUID),
                            &len,
                            &pb)) {
                memset(pb, 0, sizeof(GUID));
            }
        }


#if DBG
        DBGetSingleValue(pDB,
                         FIXED_ATT_DNT,
                         &realDNT,
                         sizeof(realDNT),
                         NULL);
        Assert(realDNT == pResObj->DNT);
#endif
    }
    else {
        // Object doesn't exist, so create a placeholder resobj
        pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        pResObj->pObj = gpRootDN;
        pResObj->DNT = INVALIDDNT;
        pResObj->PDNT = INVALIDDNT;
        pResObj->NCDNT = INVALIDDNT;
        pResObj->InstanceType = IT_UNINSTANT;
        pResObj->IsDeleted = TRUE;
        pResObj->MostSpecificObjClass = CLASS_TOP;
    }

    return pResObj;
}


/*++ NamePrefix
 *
 * This routine determines if one name is a prefix of another.  If so it
 * returns an indication of how much prefix was matched.  Although this value
 * is intended to indicate how many RDNs were matched, that can't be
 * guaranteed.  The one thing that can be depended on is that, when comparing
 * two prefixes against the same DN, a higher number indicates a larger match.
 * Returns 0 if the purported prefix isn't a prefix.
 *
 * INPUT:
 *   pPrefix - pointer to the (potential) prefix DSNAME
 *   pDN     - pointer to the DN to be evaluated.
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   0       - not a prefix
 *   non-0   - is a prefix (see above)
 *
 * NOTE:
 *   This routine is NOT GUID based, and only works on string names.
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned
NamePrefix(const DSNAME *pPrefix,
           const DSNAME *pDN)
{
    unsigned ip, in;
    WCHAR rdnPrefix[MAX_RDN_SIZE];
    WCHAR rdnMain[MAX_RDN_SIZE];
    ATTRTYP typePrefix, typeMain;
    DWORD ccPrefixVal, ccMainVal;
    DWORD err;
    WCHAR *pKey, *pQVal;
    DWORD ccKey, ccQVal;
    unsigned retval;
    THSTATE *pTHS;

    if (pPrefix->NameLen > pDN->NameLen) {
        return 0;
    }

    if (IsRoot(pPrefix)) {
        return 1;
    }

    pTHS=pTHStls;

    ip = pPrefix->NameLen-1;
    in = pDN->NameLen-1;
    retval = 1;

    while (ip) {
        if ((pPrefix->StringName[ip] != pDN->StringName[in]) &&
            (towlower(pPrefix->StringName[ip]) !=
             towlower(pDN->StringName[in]))) {
            // Can we put in a smarter test?  Perhaps if we have
            // not seen any spaces or escapes up until now (including this
            // char) then we can reject without the more expensive test.
            // Unfortunately that would miss cases where we're looking at
            // the last character of an escaped character.
            // Perhaps we can reject unless either one of the characters is
            // a space or a hex digit or a quote?
            goto NotExactly;
        }
        if (',' == pPrefix->StringName[ip]) {
            ++retval;
        }
        --ip;
        --in;
    }

    // Ok, we've exhausted the prefix, make sure that we're at
    // a good stopping point in the name
    // We could be inside a quote, which would make this
    // check for a separator character meaningless.  That would imply
    // that the prefix name was invalid, though, because it ends with
    // an open quoted string.  In that case I believe that the bogus
    // name will be caught elsewhere shortly.
    if ((in == 0) ||
        (IsDNSepChar(pDN->StringName[in-1]))) {
        return retval;
    }
    else {
        return 0;
    }

  NotExactly:
    // While matches of identically escaped or normalized DNs should have
    // been caught above, we need to test here for possible matches of
    // differently escaped names.  We do this by repeatedly extracting
    // and unquoting the components of the two names, top to bottom,
    // and comparing the unquoted values.
    ip = pPrefix->NameLen;
    in = pDN->NameLen;
    retval = 0;
    while (TRUE) {
        ++retval;

        // Parse out one element of the prefix

        err = GetTopNameComponent(pPrefix->StringName,
                                  ip,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            // The name is unparseable for some reason.  Claim that it's
            // not a prefix;
            return 0;
        }
        if (!pKey) {
            // We've run out of components in the prefix.  Whether or not
            // there are any components left in the DN, we know that the
            // purported prefix truly is one.
            Assert(!pQVal);
            return retval;
        }
        Assert(pQVal);
        typePrefix = KeyToAttrType(pTHS, pKey, ccKey);
        ccPrefixVal = UnquoteRDNValue(pQVal, ccQVal, rdnPrefix);
        if ((0 == ccPrefixVal) || (0 == typePrefix)) {
            // Prefix was not properly parseable.  Return an error
            return 0;
        }
        ip = (unsigned)(pKey - pPrefix->StringName);
        

        // Parse out one element of the DN

        err = GetTopNameComponent(pDN->StringName,
                                  in,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            // The name is unparseable for some reason.  Claim that it's
            // not a prefix;
            return 0;
        }
        if (!pKey) {
            // We've run out of components in the name.  Since we still
            // have a component in the prefix, we know that it is in fact
            // not a prefix
            Assert(!pQVal);
            return 0;
        }
        Assert(pQVal);
        typeMain = KeyToAttrType(pTHS, pKey, ccKey);
        ccMainVal = UnquoteRDNValue(pQVal, ccQVal, rdnMain);
        if ((0 == ccMainVal) || (0 == typeMain)) {
            // Name was not properly parseable.  Return an error
            return 0;
        }
        in = (unsigned)(pKey - pDN->StringName);
        

        // Compare the parsed components

        if ((typePrefix != typeMain) ||
            (ccPrefixVal != ccMainVal) ||
            (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 rdnPrefix,
                                 ccPrefixVal,
                                 rdnMain,
                                 ccMainVal))) {
            // The components didn't compare.  Either the types differed or
            // the lengths differed or the strings didn't match.  Not a prefix.
            return 0;
        }
    }
}

/*++ DSNameToBlockName
 *
 * Pull apart a full dsname into an attrblock holding the individual RDNs and a
 * tagarray to go with it. (the AttrBlock holds the name fragments, the
 * tagarray is space for DNTs, and some duplicated information).
 * Assumes the memory for a maximal attrblock has already been allocated and is
 * passed in here.  The value pointers in the attrblock point into the dsname,
 * so don't call this then mess with the dsname.
 *
 * INPUT:
 *   pDSName     - pointer to name, in DSNAME format
 *   ppBlockName - pointer to pointer to fill in with the address of the
 *                 name in block format.
 *   fLowerCase  - change block name to lower case
 * OUTPUT:
 *   ppBlockName - filled in with pointer to name in blockname format
 * RETURN VALUE:
 *   0 - if all went well
 *   a DIRERR error code otherwise
 */
unsigned
DSNameToBlockName (
        THSTATE *pTHS,
        const DSNAME *pDSName,
        ATTRBLOCK ** ppBlockName,
        BOOL fLowerCase
        )
{
    ULONG cAVA=0,len,i;
    unsigned curlen = pDSName->NameLen;
    ATTRBLOCK * pBlockName;
    ATTR * pAVA;
    WCHAR * pKey, *pQVal;
    unsigned ccKey, ccQVal;
    WCHAR rdnbuf[MAX_RDN_SIZE];
    unsigned err;

    err = CountNameParts(pDSName, &cAVA);
    if (err) {
        return err;
    }

    *ppBlockName = pBlockName = THAllocEx(pTHS, sizeof(ATTRBLOCK));
    pBlockName->attrCount = cAVA;

    if (cAVA == 0) {
        Assert(IsRoot(pDSName));
        return 0;
    }

    pBlockName->pAttr = THAllocEx(pTHS, cAVA * sizeof(ATTR));
    pAVA = pBlockName->pAttr;

    for (i=0; i<cAVA; i++) {
        Assert(curlen);

        // extract the most significant remaining name component
        err = GetTopNameComponent(pDSName->StringName,
                                  curlen,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            return err;
        }
        if (NULL == pKey) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // shorten our view of the string name, which removes the
        // name component we got above
        curlen = (unsigned)(pKey - pDSName->StringName);

        // convert the name from string to binary
        pAVA->attrTyp = KeyToAttrType(pTHS, pKey, ccKey);

        len = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (len == 0 || len > MAX_RDN_SIZE) {
            return DIRERR_NAME_VALUE_TOO_LONG;
        }

        if ( fLowerCase ) {
            // fold the case of the value, to ease future comparisons
            CharLowerBuffW(rdnbuf, len);
        }

        // wrangle the data into proper Attr format
        pAVA->AttrVal.pAVal = THAllocEx(pTHS, sizeof(ATTRVAL) +
                                        len * sizeof(WCHAR));
        pAVA->AttrVal.valCount = 1;
        pAVA->AttrVal.pAVal->valLen = len * sizeof(WCHAR);
        pAVA->AttrVal.pAVal->pVal = (UCHAR*)(pAVA->AttrVal.pAVal + 1);
        memcpy(pAVA->AttrVal.pAVal->pVal, rdnbuf, len * sizeof(WCHAR));

        pAVA++;
    }

    return 0;
} // DSNameToBlockName


//
// Convert a BLOCKNAME to DSName
//
// INPUT:
//      pBlockName - the blockname to convert to a DSNAME
//
// OUTPUT: 
//      ppName - a DSNAME is all went well
//
// Returns:
//      0 on success
//      1 on failure
//      Throws exception on memory alloc error
//

DWORD BlockNameToDSName (THSTATE *pTHS, ATTRBLOCK * pBlockName, DSNAME **ppName)
{
    DSNAME *pName;
    unsigned len, quotelen;
    ULONG allocLen;       // Count of Unicode Chars allocated for the stringname.
    unsigned i = 0;
    ATTR * pAVA;

    if (pBlockName->attrCount == 0) {
        *ppName = THAllocEx(pTHS, DSNameSizeFromLen(0));
        return 0;
    }
    
    // Allocate enough memory for most names.
    allocLen = sizeof(wchar_t)*(MAX_RDN_SIZE + MAX_RDN_KEY_SIZE+2);
    pName = THAllocEx(pTHS, DSNameSizeFromLen(allocLen));

    // Pull naming info off of each component, until we're done.

    i = pBlockName->attrCount;
    len = 0;

    do {
        if ((allocLen - len) < (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2)) {
            // We might not have enough buffer to add another component,
            // so we need to reallocate the buffer up.  We allocate
            // enough for the maximal key, the maximal value, plus two
            // characters more for the comma and equal sign
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            pName = THReAllocEx(pTHS, pName, DSNameSizeFromLen(allocLen));
        }

        // skip the first one
        if (i != pBlockName->attrCount ) {
            pName->StringName[len++] = L',';
        }
        
        pAVA = &pBlockName->pAttr[--i];

        len += AttrTypeToKey(pAVA->attrTyp, &pName->StringName[len]);
        pName->StringName[len++] = L'=';
        quotelen = QuoteRDNValue((WCHAR *)pAVA->AttrVal.pAVal->pVal,
                                 pAVA->AttrVal.pAVal->valLen/sizeof(WCHAR),
                                 &pName->StringName[len],
                                 allocLen - len);

        if (quotelen == 0) {
            THFreeEx (pTHS, pName);
            return 1;
        }

        // not enough size
        while (quotelen > (allocLen - len)) {
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            pName = THReAllocEx(pTHS, pName, DSNameSizeFromLen(allocLen));
            quotelen = QuoteRDNValue((WCHAR *)pAVA->AttrVal.pAVal->pVal,
                                     pAVA->AttrVal.pAVal->valLen/sizeof(WCHAR),
                                     &pName->StringName[len],
                                     allocLen - len);
        }
        len += quotelen;

        // We should not have run out of buffer
        Assert(len < allocLen);
    }
    while (i >= 1);

    pName->StringName[len] =  L'\0';

    pName->NameLen = len;
    pName->structLen = DSNameSizeFromLen(len);

    *ppName = pName;

    return 0;
} // BlockNameToDSName

/*++ FreeBlockName
 *
 * This routine frees a BlockName as created by DSNameToBlockName.  It's
 * here so that callers do not need to to be aware of which parts were
 * put into which heap blocks.  Note that this should not be called on
 * block names that have been made permanent (below), as those are allocated
 * as a single block, and can be freed from the permanent heap directly.
 * For assertion purposes we rely on the code in THFree to assert if given
 * memory off of the wrong heap.
 *
 * INPUT:
 *   pBlockName - pointer to block name
 * RETURN VALUE:
 *   none
 */
void
FreeBlockName (
        ATTRBLOCK * pBlockName
        )
{
    unsigned i;
    ATTR * pAVA;
    THSTATE *pTHS=pTHStls;

    pAVA = pBlockName->pAttr;
    for (i=0; i<pBlockName->attrCount; i++) {
            THFreeEx(pTHS, pAVA->AttrVal.pAVal);
            ++pAVA;
    }
    THFreeEx(pTHS, pBlockName);
}

#define RoundToBlock(x)  (((x) + 7) & ~7)
/*++ MakeBlockNamePermanent
 *
 * This routine takes a BlockName (a DN stored as a AttrBlock) and copies
 * it to a single permanently allocated memory block, so that it can outlive
 * the current transaction.
 *
 * INPUT:
 *   pName - pointer to input name
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   pointer to freshly allocated block, or NULL for memory failure
 */
ATTRBLOCK * MakeBlockNamePermanent(ATTRBLOCK * pName)
{
    unsigned size;
    unsigned i;
    char * pBuf;
    ATTRBLOCK * pRet;

    size = RoundToBlock(sizeof(ATTRBLOCK));
    size += RoundToBlock(pName->attrCount * sizeof(ATTR));
    if (pName->attrCount) {
        Assert(pName->pAttr);
        for (i=0; i<pName->attrCount; i++) {
            size += RoundToBlock(sizeof(ATTRVAL)) +
                RoundToBlock(pName->pAttr[i].AttrVal.pAVal->valLen);
        }
    }

    pBuf = malloc(size);
    if (!pBuf) {
        LogUnhandledError(size);
        return NULL;
    }

    pRet = (ATTRBLOCK *)pBuf;
    pBuf += RoundToBlock(sizeof(ATTRBLOCK));

    pRet->attrCount = pName->attrCount;
    pRet->pAttr = (ATTR*)pBuf;
    pBuf += RoundToBlock(pRet->attrCount * sizeof(ATTR));

    for (i=0; i<pRet->attrCount; i++) {
        pRet->pAttr[i] = pName->pAttr[i];
        pRet->pAttr[i].AttrVal.pAVal = (ATTRVAL*)pBuf;
        pBuf += RoundToBlock(sizeof(ATTRVAL));
        pRet->pAttr[i].AttrVal.pAVal->valLen =
          pName->pAttr[i].AttrVal.pAVal->valLen;
        pRet->pAttr[i].AttrVal.pAVal->pVal = pBuf;
        pBuf += RoundToBlock(pRet->pAttr[i].AttrVal.pAVal->valLen);
        memcpy(pRet->pAttr[i].AttrVal.pAVal->pVal,
               pName->pAttr[i].AttrVal.pAVal->pVal,
               pRet->pAttr[i].AttrVal.pAVal->valLen);
    }

    Assert((pBuf - (char *)pRet) == (int)size);

    return pRet;
}

/*++ BlockNamePrefix
 *
 * This routine determines if one name is a prefix of another.  If so it
 * returns the number of RDNs matched. Returns 0 if the prefix isn't a prefix.
 *
 * INPUT:
 *   pPrefix - pointer to the (potential) prefix name, in ATTR format
 *   pDN     - pointer to the DN to be evaluated.
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   0       - not a prefix
 *   non-0   - is a prefix (see above)
 *
 * NOTE:
 *   This routine is NOT GUID based, and only works on string names.
 *
 */
unsigned
BlockNamePrefix(THSTATE *pTHS,
                const ATTRBLOCK *pPrefix,
                const ATTRBLOCK *pDN)
{
    int i;
    ATTR * pAvaPrefix, *pAvaDN;

    if ( 0 == pPrefix->attrCount )
    {
        // Prefix identifies the root, ergo anything else is a child.
        return(1);
    }

    if (pPrefix->attrCount > pDN->attrCount) {
        return 0;
    }

    pAvaPrefix = pPrefix->pAttr;
    pAvaDN = pDN->pAttr;

    for (i=0; i<(int)(pPrefix->attrCount); i++) {
        if ((pAvaPrefix->attrTyp != pAvaDN->attrTyp) ||
            (pAvaPrefix->AttrVal.pAVal->valLen !=
             pAvaDN->AttrVal.pAVal->valLen)) {
            return 0;
        }

        Assert(pAvaPrefix->AttrVal.valCount == 1);
        Assert(pAvaDN->AttrVal.valCount == 1);

        if (memcmp(pAvaPrefix->AttrVal.pAVal->pVal,
                   pAvaDN->AttrVal.pAVal->pVal,
                   pAvaPrefix->AttrVal.pAVal->valLen)) {
            return 0;
        }

        pAvaPrefix++;
        pAvaDN++;
    }

    return i;

}

/*++ FindNamingContext
 *
 * Given the name of a purported DS object, finds the naming context with
 * an adequate replica existing on this machine that could contain the object.
 * The "adequacy" of the replica is determined by whether or not the caller
 * allows us to use a "copy" of the NC, as opposed to a master copy.  The
 * only case where we would have "copies" in NTDS is for a thin read-only
 * replica on a global catalog server.  Note again that the result is the
 * best NC ON THIS MACHINE.  This means that the caller is responsible for
 * determining whether or not the object would actually lie in the NC.  This
 * can be done either by CheckForNCExit or by using FindBestCrossRef (which
 * will definitively return the best NC known in the enterprise) and comparing
 * the results between that an FindNamingContext.
 *
 * INPUT:
 *    pObj    - name of purported DS object, in blockname format
 *    pComArg - common arguments
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    null    - no NC held on this machine could contain the purported object
 *    non-0   - pointer to name of the NC that is most likely to hold
 *              the purported object (i.e., the NC whose name is the maximal
 *              prefix of the object's name).
 *
*/
NAMING_CONTEXT * FindNamingContext(ATTRBLOCK *pObj,
                                   COMMARG *pComArg)
{
    int iBest = 0, iCur;
    NAMING_CONTEXT *pNCBest = NULL;
    NAMING_CONTEXT_LIST *pNCL;
    THSTATE *pTHS=pTHStls;
    NCL_ENUMERATOR nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1, (PVOID)pObj);
    while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        iCur = nclEnum.matchResult;
        if (iCur > iBest) {
            iBest = iCur;
            pNCBest = pNCL->pNC;
        }
    }

    if (!pComArg->Svccntl.dontUseCopy) {
        // copies are acceptable
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1, (PVOID)pObj);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            iCur = nclEnum.matchResult;
            if (iCur > iBest) {
                iBest = iCur;
                pNCBest = pNCL->pNC;
            }
        }
    }

    return pNCBest;
}

/*++ CheckForNCExit
 *
 * Given the name of a purported DS object and the name of a naming context
 * that may contain it, this routine checks to see whether the object would
 * truly fall inside the NC, or whether the object would actually be in a
 * naming context that is beneath the naming context in question.  If it
 * is discovered that the purported object would be in some other NC, the
 * name of that NC is returned.  If the object would be in the specified
 * NC, then a null pointer is returned.
 *
 * INPUT:
 *    pNC   - name of NC to check for inclusion
 *    pObj  - name of purported object
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    null  - purported object would fall in given NC
 *    non-0 - pointer to name of NC that the object would be in.
 */
NAMING_CONTEXT * CheckForNCExit(THSTATE *pTHS,
                                NAMING_CONTEXT * pNC,
                                DSNAME * pObj)
{
    ULONG err;
    ULONG iVal;
    DSNAME *pSR;
    ATTCACHE *pAC;
    ULONG cb;

    __try {
        err = DBFindDSName(pTHS->pDB, pNC);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    if (!(pAC = SCGetAttById(pTHS, ATT_SUB_REFS))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ATT_SUB_REFS);
    }
    iVal = 1;
    pSR = 0;
    cb = 0;
    do {
        err = DBGetAttVal_AC(pTHS->pDB,
                             iVal,
                             pAC,
                             DBGETATTVAL_fREALLOC,
                             cb,
                             &cb,
                             (UCHAR**)&pSR);
        if (!err) {
            Assert(cb == pSR->structLen);
            // ok, we found a subref.  See if it is a prefix of the
            // purported DN
            if (NamePrefix(pSR, pObj)) {
                // it is, which means that the object is not in this NC
                return pSR;
            }
        }
        iVal++;
    } while (!err);

    if (pSR) {
        THFreeEx(pTHS, pSR);
    }

    return 0;
}

/*++ FindCrossRef
 *
 * Given the name of a purported DS object (in blockname format), this
 * routine scans the list of cross refernces held by this DSA and
 * returns the best candidate cross reference (i.e., the cross ref that
 * matches the most components of the name of the purported object.
 *
 * The convoulted test for "better-ness" is really two parts.  We take
 * a CR to be "better" if it matches more of the name than our current
 * champ (the normal part), or if it matches exactly the same amount of
 * the name as our current champ and wins an arbitrary GUID comparison.
 * This latter part is only necessary to give consistent (if arbitrary)
 * results when someone has messed up and added two CRs for the same NC.
 *
 * INPUT:
 *    pObj    - name of the purported object, in blockname format
 *    pComArg - common arguments
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    NULL    - no known cross refs could contain the purported object
 *    non-0   - pointer to in-memory structure holding the cached cross
 *              ref that best matches the purported object.
 */
CROSS_REF * FindCrossRef(const ATTRBLOCK *pObj,
                         const COMMARG *pComArg)
{
    CROSS_REF_LIST * pCRL = gAnchor.pCRL;
    ULONG iCur;
    ULONG iBest = 0;
    CROSS_REF * pCRBest = NULL;
    THSTATE *pTHS=pTHStls;

    while (pCRL) {
        iCur = BlockNamePrefix(pTHS, pCRL->CR.pNCBlock, pObj);
        if ((iCur > iBest) ||
            ((iCur == iBest) &&
             (iCur > 0) &&
             (0 > memcmp(&pCRBest->pObj->Guid,
                         &pCRL->CR.pObj->Guid,
                         sizeof(GUID))))) {
            iBest = iCur;
            pCRBest = &pCRL->CR;
        }
        pCRL = pCRL->pNextCR;
    }

    return pCRBest;
}

/*++ FindBestCrossRef
 *
 * A publicy callable routine that will return the in memory CrossRef
 * that is the best match for the target object.  Currently just a wrapper
 * around FindCrossRef (above) that doesn't require blocknames, but that
 * may change in the future.
 *
 * INPUT
 *   pObj    - DSNAME of object for which cross ref is desired
 *   pComArg - COMMARG
 * RETURN VALUE
 *   null    - no CR could be found
 *   non-null - pointer to CROSS_REF object
 */
CROSS_REF *
FindBestCrossRef(const DSNAME *pObj,
                 const COMMARG *pComArg)
{
    THSTATE *pTHS=pTHStls;
    ATTRBLOCK * pObjB;
    CROSS_REF * pCR;

    if (DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE)) {
        return NULL;
    }
    pCR = FindCrossRef(pObjB, pComArg);
    FreeBlockName(pObjB);

    return pCR;
}

/*++ FindExactCrossRef
 *
 * A publicy callable routine that will return the in memory CrossRef
 * that is a perfect match for the target object (i.e., the target must
 * be the name of an NC, not of an object inside the NC).  Currently just
 * calls FindBestCrossRef, but hopefully this will change, as a search for
 * an exact match could be made more efficient than a search for a prefix.
 *
 * INPUT
 *   pObj    - DSNAME of object for which cross ref is desired
 *   pComArg - COMMARG
 * RETURN VALUE
 *   null    - no CR could be found
 *   non-null - pointer to CROSS_REF object
 */
CROSS_REF *
FindExactCrossRef(const DSNAME *pObj,
                  const COMMARG *pComArg)
{
    THSTATE *pTHS=pTHStls;
    ATTRBLOCK * pObjB;
    CROSS_REF * pCR;

    if (DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE)) {
        return NULL;
    }
    pCR = FindCrossRef(pObjB, pComArg);
    FreeBlockName(pObjB);

    if ( (NULL != pCR) && !NameMatched(pObj, pCR->pNC) ) {
        pCR = NULL;
    }

    return pCR;
}

/*++ FindExactCrossRef
 *
 * A publicy callable routine that will return the in memory CrossRef
 * that is a perfect match for the target object (i.e., the target must
 * be the name of an NC, not of an object inside the NC).  Currently just
 * calls FindBestCrossRef, but hopefully this will change, as a search for
 * an exact match could be made more efficient than a search for a prefix.
 *
 * INPUT
 *   pObj    - DSNAME of object for which cross ref is desired
 *   pComArg - COMMARG
 * RETURN VALUE
 *   null    - no CR could be found
 *   non-null - pointer to CROSS_REF object
 */
CROSS_REF *
FindExactCrossRef2(const DSNAME *pObj,
                  const COMMARG *pComArg)
{
    THSTATE *pTHS=pTHStls;
    ATTRBLOCK * pObjB;
    CROSS_REF * pCR;

    if (DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE)) {
        return NULL;
    }
    pCR = FindCrossRef(pObjB, pComArg);
    FreeBlockName(pObjB);

    if ( (NULL != pCR) && !NameMatched(pObj, pCR->pNC) ) {
        pCR = NULL;
    }

    return pCR;
}




/*++ FindExactCrossRefForAltNcName
 *
 * Finds the cross ref with the desired naming context
 *
 */
CROSS_REF *
FindExactCrossRefForAltNcName(
    ATTRTYP        attrTyp,
    ULONG          crFlags,
    const WCHAR *  pwszVal // This is implied to be the DNS of the NC.
    )
{
    CROSS_REF_LIST  *pCRL = gAnchor.pCRL;
    CROSS_REF       *pBestCR = NULL;

#if DBG
    DWORD           cFound = 0;
#endif

    Assert(pwszVal);
    Assert((ATT_NETBIOS_NAME == attrTyp) || (ATT_DNS_ROOT == attrTyp));
    Assert((ATT_DNS_ROOT == attrTyp) || (crFlags & FLAG_CR_NTDS_DOMAIN));

    if ((ATT_NETBIOS_NAME != attrTyp) && (ATT_DNS_ROOT != attrTyp))
    {
        return(NULL);
    }

    if ( !(crFlags & FLAG_CR_NTDS_DOMAIN) ) {
        if(DsaIsInstalling()){
            Assert(!"Can't call this function for non-domains during install");
            return(NULL);
        }
    }

    while ( pCRL )
    {
        if (    (crFlags == (pCRL->CR.flags & crFlags))     // correct flags
             && ( (ATT_NETBIOS_NAME == attrTyp)              // value present
                            ? pCRL->CR.NetbiosName
                            : pCRL->CR.DnsName  )
             && (2 == CompareStringW(                      // value matches
                            DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            (ATT_NETBIOS_NAME == attrTyp)
                                    ? pCRL->CR.NetbiosName
                                    : pCRL->CR.DnsName,
                            -1,
                            pwszVal,
                            -1)) 
             && ((crFlags & FLAG_CR_NTDS_DOMAIN) ||
                  (!NameMatched(pCRL->CR.pNC, gAnchor.pConfigDN) &&
                   !NameMatched(pCRL->CR.pNC, gAnchor.pDMD))) ) 
        {
#if DBG
            cFound++;
            pBestCR = &pCRL->CR;
#else
            return(&pCRL->CR);
#endif
        }

        pCRL = pCRL->pNextCR;
    }

#if DBG
    Assert(cFound < 2);
#endif

    return(pBestCR);
}




BOOL
IsCrossRefProtectedFromDeletion(
    IN DSNAME * pDN
    )
/*++

Routine Description:

    Determine whether the given DN is a cross-ref for a locally writable
    config/schema/domain NC.

Arguments:

    pDN (IN) - DN to check.

Return Values:

    TRUE - pDN is a cross-ref for a locally writable NC.
    FALSE - otherwise.

--*/
{
    CROSS_REF_LIST *      pCRL;
    NAMING_CONTEXT_LIST * pNCL;
    NCL_ENUMERATOR nclEnum;

    for (pCRL = gAnchor.pCRL; NULL != pCRL; pCRL = pCRL->pNextCR) {
        if (NameMatched(pCRL->CR.pObj, pDN)) {
            // pDN is a indeed a cross-ref; do we hold a writable copy of the
            // corresponding NC?
            if (!fIsNDNCCR(&pCRL->CR)) {
                NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
                NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pCRL->CR.pNC);
                if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                    // pDN is a cross-ref for a locally writable
                    // config/schema/domain NC.
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

/*++ AdjustDNSPort
 *
 *  Given a string of the format a.b.c:p1:p2 (i.e. a dns string with up to
 *  two port numbers hanging off the end) adjust the string inplace
 *  to a.b.c:p1 or a.b.c:p2 based in the input flag.
 *
 * INPUT:
 *   pString    - pointer to the DNS string (WHCAR)
 *   cbString   - bytes in pString (NOT CHARS!)
 *   fFirst     - TRUE if the first port is desired, FALSE if the second
 *                port is desired.
 *
 * OUTPUT:
 *   pString    - the string is adjusted in place
 *
 * RETURN VALUE:
 *   count of bytes (NOT WCHARS!) in the newly formated pString
 *
 */
DWORD
AdjustDNSPort(
        WCHAR *pString,
        DWORD cbString,
        BOOL  fFirst
        )
{
    DWORD i;
    DWORD ccString;
    DWORD iFirstColon;
    DWORD iSecondColon;

    // First, find the first ':'
    i=0;
    ccString = cbString/sizeof(WCHAR);
    while(i<ccString && pString[i] != L':') {
        i++;
    }

    if(i != ccString ) {
        // We found at least one ':'
        iFirstColon = i;
        i++;
        while(i<ccString && pString[i] != L':') {
            i++;
        }
        if(i != ccString) {
            // Two colons
            iSecondColon = i;
        }
        else {
            iSecondColon = 0;
        }

        if(fFirst) {
            if(iSecondColon) {
                // Ok, we found a second colon, but we don't want the
                // second port.  Reset the ccStringgth to just ignore
                // everything after and including the second colon.
                ccString = iSecondColon;
                // We don't really need to do this, since this is a counted char
                // string, not null terminated, but it makes it easier to read.
                pString[iSecondColon]=0;
            }
        }
        else {
            if(!iSecondColon) {
                // No second port.  However, we don't want the first
                // port, so chop it.
                ccString = iFirstColon;
            }
            else {
                // OK, two colons, and we want the second.
                iFirstColon++;
                iSecondColon++;
                while(iSecondColon < ccString) {
                    pString[iFirstColon] = pString[iSecondColon];
                    iFirstColon++;
                    iSecondColon++;
                }
                // We don't really need to do this, since this is a counted char
                // string, not null terminated, but it makes it easier to read.
                pString[iFirstColon]=0;

                ccString = iFirstColon;
            }
        }
    }

    return ccString*sizeof(WCHAR);
}



/*++ GenCrossRef
 *
 * This routine takes the name of a cross reference (in its general sense,
 * the name of an object that holds information about the location of
 * one or more replicas of a specific naming context) and produces a
 * referral based on that cross ref.
 *
 * INPUT:
 *     pCR      - pointer to the in-memory cross-ref object
 *     pObj     - name of purported object being sought
 * OUTPUT:
 *     none     - (the referral is placed in the THSTATE)
 * RETURN VALUE:
 *     referralError if all went well, some other error code if we
 *     were unable to generate the referral.
 */
int
GenCrossRef(CROSS_REF *pCR,
            DSNAME *pObj)
{
    THSTATE     *pTHS = pTHStls;
    ULONG       len, nVal;
    WCHAR       *pDNS;
    NAMERESOP   Op;
    DSA_ADDRESS da;

    Op.nameRes = OP_NAMERES_NOT_STARTED; // next server must restart algorithm

    if(!pCR->bEnabled){
        // We don't generate referrals of any kind for disabled 
        // crossRefs.  As far as the directory is concerned we this
        // part of the directory does not exist yet.
        return SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND);
    }

    if(0 == pCR->DnsReferral.valCount) {
        DPRINT(0,"Missing required DNS root for Cross Ref\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_MASTERDSA_MISSING_SUBREF,
                 szInsertDN(pCR->pObj),
                 NULL,
                 NULL);

        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_MASTERDSA_REQUIRED);
    }

    for (nVal = 0; nVal < pCR->DnsReferral.valCount; ++nVal) {
        len = pCR->DnsReferral.pAVal[nVal].valLen;
        pDNS = THAllocEx(pTHS, len);
        memcpy(pDNS, pCR->DnsReferral.pAVal[nVal].pVal, len);

        len = AdjustDNSPort(pDNS, len, (pTHS->CipherStrength == 0));

        da.Length = (unsigned short) len;
        da.MaximumLength = (unsigned short) len;
        da.Buffer = pDNS;

        SetRefError(pObj,
                    0,
                    &Op,
                    0,
                    CH_REFTYPE_CROSS,
                    &da,
                    DIRERR_REFERRAL);
    }

    return pTHS->errCode;
}

/*++ GenSupRef - Generate a referral based on our Superior Reference
 *
 * This routine is the referral generator of last resort.  If all other
 * attempts to refer the caller to a sensible location have failed, we
 * will refer him to the server known to hold the portion of the tree
 * above us, in hopes that it can do better.
 *
 * INPUT:
 *     pObj     - name of purported object being sought
 *     pObjB    - name of purported object being sought, in blockname format
 *     pComArg  - common argument flags
 *     pDA      - (optional) If present, the referred DSA-Address is returned,
 *                and no error is placed in the THSTATE
 * OUTPUT:
 *     none     - (the referral is placed in the THSTATE)
 * RETURN VALUE:
 *     referralError if all went well, some other error code if we
 *     were unable to generate the referral.
 */
int
GenSupRef(THSTATE *pTHS,
          DSNAME *pObj,
          ATTRBLOCK *pObjB,
          const COMMARG *pComArg,
          DSA_ADDRESS *pDA)
{
#define GC_PREAMBLE     L"gc._msdcs."
#define CB_GC_PREAMBLE (sizeof(GC_PREAMBLE) - sizeof(WCHAR))
#define CC_GC_PREAMBLE ((CB_GC_PREAMBLE)/sizeof(WCHAR))
#define GC_PORT        L":3268"
#define GC_SSL_PORT    L":3269"
#define CB_GC_PORTS    (sizeof(GC_PORT) - sizeof(WCHAR))
#define CC_GC_PORTS    ((CB_GC_PORTS)/sizeof(WCHAR))
    ULONG err;
    ULONG cbVal;
    ULONG att;
    WCHAR *pDNS, *pTempDNS;
    DSA_ADDRESS da;
    NAMERESOP Op;
    BOOL fGCReferral;
    CROSS_REF *pCR=NULL;
    DWORD     i, iFirstColon, iSecondColon;

    if(IsRoot(pObj) ||
        // suprefs to the root should generate a referral to the GC.
       (!pObj->NameLen && !fNullUuid(&pObj->Guid))) {
        // suprefs with no string name and a guid get sent to the GC also
        fGCReferral = TRUE;
    }
    else {
        fGCReferral = FALSE;
    }

    Assert(sizeof(GC_PORT) == sizeof(GC_SSL_PORT));

    Op.nameRes = OP_NAMERES_NOT_STARTED; // next server must restart algorithm

    if(!gAnchor.pRootDomainDN ||
       (!(pCR = FindExactCrossRef(gAnchor.pRootDomainDN, pComArg))) ) {
        DPRINT1(0,
                "Missing config info, can't gen referral for '%S'\n",
                pObj->StringName
                );
        return SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                           DIRERR_MISSING_SUPREF);
    }
    else {
        // Now, go to the cross ref
        err = DBFindDSName(pTHS->pDB, pCR->pObj);

        Assert(!err);           // we've gotta have this

        if (err) {
            DPRINT2(0,"Error %d finding object %S for SupRef gen\n",
                    err, gAnchor.pRootDomainDN->StringName);
            return SetSvcError(SV_PROBLEM_INVALID_REFERENCE,
                               DIRERR_MISSING_SUPREF);
        }

        if(fGCReferral) {
            // This is a GC referral, read the ATT_DNS_ROOT
            att = ATT_DNS_ROOT;
        }
        else {
            // A normal sup ref.  Read the ATT_SUP_REF_DNS
            att = ATT_SUPERIOR_DNS_ROOT;
        }

        if( DBGetAttVal(pTHS->pDB,
                        1,
                        att,
                        0,
                        0,
                        &cbVal,
                        (UCHAR **)&pDNS)){

            // Jeez!  We don't have a single known place to send referrals
            // for unknown objects.  Instead we'll try to automatically guess
            // one based on the target DN.
            cbVal = GenAutoReferral(pTHS,
                                    pObjB,
                                    &pDNS);
        }
        else if(fGCReferral) {
            //
            // We are generating a supref for the root.  We will generate a
            // referral the GC.
            //
            // First, adjust the dns string we got back to trim out :'s
            pTempDNS = pDNS;
            i=0;
            while(i<cbVal && *pTempDNS != ':') {
                i += sizeof(WCHAR);
                pTempDNS++;
            }
            // i either == cbVal or i == length through first ':'
            cbVal=i;
            pTempDNS = THAllocEx(pTHS, cbVal + CB_GC_PREAMBLE + CB_GC_PORTS);
            memcpy(pTempDNS, GC_PREAMBLE, CB_GC_PREAMBLE);
            memcpy(&pTempDNS[CC_GC_PREAMBLE],pDNS, cbVal);
            cbVal += CB_GC_PREAMBLE;
            if(pTHS->CipherStrength != 0) {
                memcpy(&pTempDNS[cbVal/2],GC_SSL_PORT,CB_GC_PORTS);
            }
            else {
                memcpy(&pTempDNS[cbVal/2],GC_PORT,CB_GC_PORTS);
            }
            cbVal += CB_GC_PORTS;
            THFreeEx(pTHS, pDNS);
            pDNS = pTempDNS;

        }
        else {
            cbVal = AdjustDNSPort(pDNS, cbVal, (pTHS->CipherStrength ==0));
        }
    }

    if (0 == cbVal) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_MISSING_SUPREF,
                 NULL,
                 NULL,
                 NULL);
        
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_SUPREF);
    }

    da.Length = (unsigned short) cbVal;
    da.MaximumLength = (unsigned short) cbVal;
    da.Buffer = pDNS;

    if (pDA) {
        // The caller didn't want an error set, just the address back
        *pDA = da;
    }
    else {

        // Set the error
        SetRefError(pObj,
                    0,
                    &Op,
                    0,
                    CH_REFTYPE_SUPERIOR,
                    &da,
                    DIRERR_REFERRAL);

    }

    return pTHS->errCode;
}

//-----------------------------------------------------------------------
//
// Function Name:            ConvertX500ToLdapDisplayName
//
// Routine Description:
//
//    Converts an X500 Name to Ldap Convention
//
// Author: RajNath
//
// Arguments:
//
//    WCHAR* x500Name
//    DWORD Len                    Length of the supplied name, note that for
//                                 internal strings, there is no terminating
//                                 NULL; the strings are sized only.
//    WCHAR* LdapName              Preallocated Buffer to return the Ldap Name
//    DWORD* RetLen                Size of Returned Length
//
// Return Value:
//
//    None
//
//-----------------------------------------------------------------------
VOID
ConvertX500ToLdapDisplayName(
    WCHAR*  x500Name,
    DWORD   Len,
    WCHAR*  LdapName,
    DWORD*  RetLen
)
{
    BOOL    fLastCharWasSpecial = FALSE;
    DWORD   i;

    Assert(Len > 0);

    *RetLen = 0;

    for ( i = 0; i < Len; i++ )
    {
        // Skip special characters and flag them.

        if (    (L' ' == x500Name[i])
             || (L'-' == x500Name[i])
             || (L'_' == x500Name[i]) )
        {
            fLastCharWasSpecial = TRUE;
            continue;
        }

        // If we get to here, we're not sitting on a special
        // character.  Change case based on previous character
        // and whether this is the first character at all.

        if ( 0 == *RetLen )
        {
            LdapName[(*RetLen)++] = towlower(x500Name[i]);
        }
        else if ( fLastCharWasSpecial )
        {
            LdapName[(*RetLen)++] = towupper(x500Name[i]);
        }
        else
        {
            LdapName[(*RetLen)++] = x500Name[i];
        }

        fLastCharWasSpecial = FALSE;
    }

    Assert(*RetLen > 0);
    Assert(*RetLen <= Len);

} // End ConvertX500ToLdapDisplayName

DWORD
FillGuidAndSid (
        IN OUT DSNAME *pDN
        )
/*++

Routine Description:
    Given a DN, fill in the GUID and SID fields.  Note that if the GUID is
    already filled in, the after this routine the GUID and SID will definitely
    be from the same object, but since DBFindDSName preferentially uses the
    GUID, it is possible that the GUID/SID and the StringName don't refer to the
    same object.

    This routine opens it's own DBPOS in order to avoid messing up a prepare rec
    that the caller (like CheckAddSecurity) might be in.

Argumnts:
    pDN - DSName to find and then fill in GUIDs and SIDs.

Return Values:
    0 if all went well, a dblayer error otherwise.

--*/
{
    DBPOS *pDBTmp;
    GUID Guid;
    GUID *pGuid = &Guid;
    NT4SID Sid;
    NT4SID *pSid = &Sid;
    BOOL  fCommit = FALSE;
    DWORD err, SidLen, len;
    DSNAME TempDN;

    DBOpen(&pDBTmp);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp' 
        //         DBOpen returns non-NULL pDBTmp or throws an exception

        // Find the object.
        err = DBFindDSName(pDBTmp, pDN);
        if (!err) {
            // Ok, we're on the object
            err = DBFillGuidAndSid(pDBTmp, &TempDN);
        }

        if(!err) {
            // Only set the values in the DN if everything is OK
            pDN->Guid = TempDN.Guid;
            pDN->Sid = TempDN.Sid;
            pDN->SidLen = TempDN.SidLen;
        }

        fCommit = TRUE;
    }
    __finally {
        DBClose(pDBTmp, fCommit);
    }

    return err;
}

DWORD
UserFriendlyNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        )
/*++

    Take a string name and generate a DSName from it.

    If the string starts with some (or none) whitespace, then "<", we parse out
    an extended string which is either <SID=........>, <GUID=..........>,
    or <WKGUID=.........,~DN~>

--*/
{
    THSTATE *pTHS=pTHStls;
    BYTE  ObjGuid[sizeof(GUID)];
    BYTE  ObjSid[sizeof(NT4SID)];
    DWORD SidLen = 0,j;
    WCHAR acTmp[3];
    BOOL  bDone;
    DWORD dnstructlen;
#define foundGUID   1
#define foundSID    2
#define foundString 3
#define foundWKGUID 4
    DWORD dwContents= foundString;


    memset(ObjGuid, 0, sizeof(GUID));
    memset(ObjSid,0,sizeof(NT4SID));

    if (!ppDN || !pUfn) {
        // Urk. No place to put the answer, or no source to build the answer
        // from
        return 1;
    }

    // Skip leading spaces.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (*pUfn) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            pUfn++;
            ccUfn--;
            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Now, skip trailing whitespace also.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (pUfn[ccUfn-1]) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            if( (ccUfn > 1) && (pUfn[ccUfn-2] == L'\\') ) {
                //There is a '\\' in front of the space. Need to count the
                // number of consequtive '\\' to determine if ' ' is escaped
                DWORD cc = 1;

                while( (ccUfn > (cc+1)) && (pUfn[ccUfn-cc-2] == L'\\') )
                    cc++;

                if( ! (cc & 0x1) ) //Even number of '\\'. Space is not escaped
                    ccUfn--;

                bDone = TRUE; //Either way, exit the loop.
            }
            else
                ccUfn--;

            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Let's see if we were given an "extended" DN.  The test we use is for the
    // first non-white space to be a '<' and the last non-whitespace to be a '>'
    if(ccUfn &&
       pUfn[0] == L'<' &&
       pUfn[ccUfn-1] == L'>') {
        // OK, this must be an extended DN.  Skip this leading '<' No whitespace
        // is allowed inside an extended DN.
        pUfn++;
        acTmp[2]=0;

        switch(*pUfn) {
        case L'W':
        case L'w':
            // We might have a well known GUID. Format is
            // <WKGUID=.......,a=b,c=d..>
            // minimal length is 45:
            //   1 for '<'
            //   7 for WKGUID=
            //   32 for the GUID,
            //   1 for ','
            //   3 for at least "a=b"
            //   1 for '>'
            if((ccUfn<45)                            || 
               (_wcsnicmp(pUfn, L"WKGUID=", 7) != 0) ||
               (pUfn[39] != L',')) {
                // Invalidly formatted
                return 1;
            }
            pUfn += 7;
            for(j=0;j<16;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }
            pUfn++;
            // Adjust ccUfn to leave only the a=b portion.
            ccUfn -= 42;
            dwContents = foundWKGUID;
            break;
        case L'G':
        case L'g':
            // We have some characters which have to be a guid
            if(((ccUfn!=39) // 1 for < ,5 for GUID= ,32 for the GUID, 1 for >
                && (ccUfn != 43)) // same plus 4 '-'s for formatted guid
               || (_wcsnicmp(pUfn, L"GUID=", 5) != 0)) {
                // Invalidly formatted
                return 1;
            }
            pUfn += 5;
            dwContents = foundGUID;

            if (39 == ccUfn) {
                // Hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
                for(j=0;j<16;j++) {
                    acTmp[0] = towlower(pUfn[0]);
                    acTmp[1] = towlower(pUfn[1]);
                    if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                        ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                        pUfn+=2;
                    }
                    else {
                        // Invalidly formatted name.
                        return 1;
                    }
                }
            }
            else {
                // Formatted guid (e.g., 38145c62-5a26-11d2-b388-0000f87a46c8).
                WCHAR szGuid[36+1];

                wcsncpy(szGuid, pUfn, 36);
                szGuid[36] = L'\0';

                if (UuidFromStringW(szGuid, (GUID *) ObjGuid)) {
                    // Incorrect format.
                    return 1;
                }
            }
            // We must have correctly parsed out a guid.  No string name left.
            break;

        case L'S':
        case L's':
            if (ccUfn<8) {
                //Must have at least 1 for >, at least 2 for val, 4 for "SID=",1 for >
                return 1;
            }
            //
            // First check for the standard user friendly string form of 
            // the sid.
            //
            if ((ccUfn>8) && // Must have more than just "<SID=S-"
                _wcsnicmp(pUfn, L"SID=S-", 6) == 0) {
                PSID     pSid = NULL;
                PWCHAR   pTmpUfn;
                unsigned ccTmpUfn;

                // Make a copy of the user friendly name so that it can be
                // null terminated appropriately for ConvertStringSidToSid

                ccTmpUfn = ccUfn - 5;  // 2 for <> and 4 for SID= add one for the 
                                       // terminating null

                pTmpUfn = THAllocEx(pTHS, ccTmpUfn * sizeof(*pTmpUfn));
                CopyMemory(pTmpUfn, pUfn + 4, ccTmpUfn * sizeof(*pTmpUfn));
                pTmpUfn[ccTmpUfn - 1] = L'\0';

                if (ConvertStringSidToSidW(pTmpUfn, &pSid)) {
                    SidLen = RtlLengthSid(pSid);
                    Assert(SidLen <= sizeof(ObjSid));
                    CopyMemory(ObjSid, pSid, SidLen);

                    LocalFree(pSid); pSid = NULL;
                    THFreeEx(pTHS, pTmpUfn);
                    //
                    // Success!
                    //
                    dwContents = foundSID;

                    // We have correctly parsed out a sid.  No string name left.
                    ccUfn=0;

                    break;
                }

                THFreeEx(pTHS, pTmpUfn);
            }

            //
            // It wasn't the the standard user friendly form.  Maybe it's the byte
            // encoded string form.
            //
            SidLen= (ccUfn - 6)/2; // Number of bytes that must be in the SID,
                                   // if this is indeed a Sid. Subtract 6 for
                                   // "<SID=>", leaving only the characters
                                   // which encode the string.  Divide by two
                                   // because each byte is encoded by two
                                   // characters.


            if((ccUfn<8) || //1 for >, at least 2 for val, 4 for "SID=",1 for >
               (ccUfn & 1) || // Must be an even number of characters
               (SidLen > sizeof(NT4SID)) || // Max size for a SID
               (_wcsnicmp(pUfn, L"SID=", 4) != 0)) {
                // Invalidly formatted
                return 1;
            }
            pUfn+=4;
            dwContents = foundSID;
            for(j=0;j<SidLen;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjSid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }

            // We must have correctly parsed out a sid.  No string name left.
            ccUfn=0;
            break;

        default:
            // Invalid character
            return 1;
        }
    }


    // We may have parsed out either a GUID or a SID.  Build the DSNAME
    dnstructlen = DSNameSizeFromLen(ccUfn);
    *ppDN = (DSNAME *)THAllocEx(pTHS, dnstructlen);

    // Null out the DSName
    memset(*ppDN, 0, dnstructlen);

    (*ppDN)->structLen = dnstructlen;

    switch(dwContents) {
    case foundWKGUID:
        // A string name and a GUID.
        Assert(ccUfn);
        memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
        (*ppDN)->NameLen = ccUfn;
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;

    case foundString:
        // Just a string name

        if(ccUfn) {
            WCHAR *pString = (*ppDN)->StringName;   // destination string
            WCHAR *p = pUfn;         // original string
            DWORD cc = ccUfn;        // num chars to process
            BOOL  fDoItFast = TRUE;

            // this loop is a substitute for
            // memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
            // we try to find out whether the DN passed in has an escaped constant
            while (cc > 0) {

                if (*p == L'"' || *p== L'\\') {
                    fDoItFast = FALSE;
                    break;
                }

                *pString++ = *p++;
                cc--;
            }
            
            (*ppDN)->NameLen = ccUfn;
            
            // if we have an escaped constant in the DN
            // we convert it to blockname and back to DN so as to
            // put escaping into a standardized form which will help
            // future comparisons
            //
            if (!fDoItFast) {
                ATTRBLOCK *pAttrBlock = NULL;
                DWORD err;

                memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
                (*ppDN)->StringName[ccUfn] = L'\0';

                err = DSNameToBlockName (pTHS, *ppDN, &pAttrBlock, DN2BN_PRESERVE_CASE);
                THFreeEx (pTHS, *ppDN); *ppDN = NULL;
                if (err) {
                    return err;
                }

                err = BlockNameToDSName (pTHS, pAttrBlock, ppDN);
                FreeBlockName (pAttrBlock);

                return err;
            }
            
        }
        break;

    case foundGUID:
        // we found a guid
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;
        
    case foundSID:
        // we found a sid.
        if(SidLen) {
            // We must have found a SID

            // First validate the SID

            if ((RtlLengthSid(ObjSid) != SidLen) || (!RtlValidSid(ObjSid)))
            {
                return(1);
            }
            memcpy(&(*ppDN)->Sid, ObjSid, SidLen);
            (*ppDN)->SidLen = SidLen;
        }
        break;
    }

    // Null terminate the string if we had one (or just set the string to '\0'
    // if we didn't).
    (*ppDN)->StringName[ccUfn] = L'\0';

    return 0;
}


typedef struct _ScriptMacroDsName {
    LPWSTR macroName;
    DSNAME **ppDSName;
} ScriptMacroDsName;

ScriptMacroDsName scriptmacrodsname[] = 
{
    L"$LocalNTDSSettingsObjectDN$", &gAnchor.pDSADN,
    L"$RootDomainDN$",              &gAnchor.pRootDomainDN,
    L"$DomainDN$",                  &gAnchor.pDomainDN,
    L"$PartitionsObjectDN$",        &gAnchor.pPartitionsDN,
    L"$ConfigNCDN$",                &gAnchor.pConfigDN,
    L"$SchemaNCDN$",                &gAnchor.pDMD,
    L"$SiteDN$",                    &gAnchor.pSiteDN,
    L"$DirectoryServiceConfigDN$",  &gAnchor.pDsSvcConfigDN,
    NULL,                           NULL
};



//
//  DSNameExpandMacro
//
//  Description:
//
//     Take a string name coming from an XML script representing a DSNAME macro 
//     and generate a DSName from it.
//
//     the string can be of the form:
//        $SupportedMacroDSName$
//     or "$CN=abc,$SupportedMacroDSName$", in which case, the first '$' will be 
//     stripped off and $SupportedMacroDSName$ will be replaced with the coresponding
//     DN.
//
//  Arguments:
//
//     pUfn - the string representing the DSNAME
//     ccUfn - the number of characters of the string
//     ppDN (OUT) - where to store the result DSNAME
//
//  Return Value:
//
//     0 on success
//     1 not found
//     2 found but empty
//
DWORD DSNameExpandMacro (
    THSTATE *pTHS,
    WCHAR   *pUfn,
    DWORD    ccUfn,
    DSNAME **ppDN
    )
{
    DWORD i = 0;
    LPWSTR pMacro;
    DSNAME *pDN = NULL;
    WCHAR *pTemp, *pD1, *pD2;
    DWORD ccLen, cBytes;

    Assert(pUfn[0]==L'$' && ccUfn>2);

    pD1 = pUfn;
    pD2 = wcschr(pD1+1,L'$');
    if (!pD2) {
        return 2;
    }

    //find the last pair of '$'
    while ((pTemp=wcschr(pD2+1,L'$')) && pTemp<=pUfn+ccUfn)  {
        pD1 = pD2;
        pD2 = pTemp;
    }

    while (pMacro = scriptmacrodsname[i].macroName) {
        if (_wcsnicmp(pMacro, pD1, (DWORD)(pD2-pD1+1)) == 0) {
            pDN = *(scriptmacrodsname[i].ppDSName);
            if (!pDN) {
                return 2;
            }
            break;
        }
        i++;
    }

    if (pDN) {
        DPRINT1 (0, "Found DSNAME Macro: %ws\n", pDN->StringName);
        ccLen = (DWORD)(pD1-pUfn); 
        
        if (ccLen) {  
            // The string does not start with the macro
            cBytes = DSNameSizeFromLen(ccLen-1+pDN->NameLen);
            *ppDN = (DSNAME *)THAllocEx(pTHS, cBytes);
            (*ppDN)->structLen = cBytes;
            (*ppDN)->NameLen = (ccLen-1)+pDN->NameLen;
            wcsncpy((*ppDN)->StringName, &pUfn[1], ccLen-1);
            wcsncat((*ppDN)->StringName, pDN->StringName, pDN->NameLen);
        }
        else {
            //The whole string is a macro
            *ppDN = (DSNAME *)THAllocEx(pTHS,pDN->structLen);
            memcpy(*ppDN, pDN, pDN->structLen);
        }
        
        return 0;
    }

    DPRINT1 (0, "DSNAME Macro not found: %ws\n", pUfn);

    return 1;
}


//
//  ScriptNameToDSName
//
//  Description:
//
//     Take a string name coming from an XML script and generate a DSName from it.
//
//     the string can be of the form:
//        dn:CN=foo,...DC=com
//        guid:625c1438265ad211b3880000f87a46c8  (Hex digit stream)
//        guid:38145c62-5a26-11d2-b388-0000f87a46c8 (Formatted guid)
//        sid:1517B85159255D7266
//        $SupportedMacroDSName$
//
//  Arguments:
//
//     pUfn - the string representing the DSNAME
//     ccUfn - the number of characters of the string
//     ppDN (OUT) - where to store the result DSNAME
//
//  Return Value:
//
//     0 on success
//
DWORD
ScriptNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        )
{
    THSTATE *pTHS=pTHStls;
    BYTE  ObjGuid[sizeof(GUID)];
    BYTE  ObjSid[sizeof(NT4SID)];
    DWORD SidLen = 0,j;
    WCHAR acTmp[3];
    BOOL  bDone;
    DWORD dnstructlen;
    DWORD dwContents= foundString;

    memset(ObjGuid, 0, sizeof(GUID));
    memset(ObjSid,0,sizeof(NT4SID));

    if (!ppDN || !pUfn) {
        // Urk. No place to put the answer, or no source to build the answer
        // from
        return 1;
    }

    // Skip leading spaces.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (*pUfn) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            pUfn++;
            ccUfn--;
            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Now, skip trailing whitespace also.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (pUfn[ccUfn-1]) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            if( (ccUfn > 1) && (pUfn[ccUfn-2] == L'\\') ) {
                //There is a '\\' in front of the space. Need to count the
                // number of consequtive '\\' to determine if ' ' is escaped
                DWORD cc = 1;

                while( (ccUfn > (cc+1)) && (pUfn[ccUfn-cc-2] == L'\\') )
                    cc++;

                if( ! (cc & 0x1) ) //Even number of '\\'. Space is not escaped
                    ccUfn--;

                bDone = TRUE; //Either way, exit the loop.
            }
            else
                ccUfn--;

            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }


    if (ccUfn > 3 && _wcsnicmp(pUfn, L"dn:", 3) == 0) {

        ccUfn -=3;
        pUfn += 3;

    }
    else if (ccUfn > 5 && _wcsnicmp(pUfn, L"guid:", 5) == 0) {

        // We have some characters which have to be a guid
        if( (ccUfn!=37)  &&     // 5 for guid: , 32 for the GUID
            (ccUfn != 41)) {    // same plus 4 '-'s for formatted guid
                // Invalidly formatted
                return 1;
        }
        pUfn += 5;
        dwContents = foundGUID;

        if (37 == ccUfn) {
            // Hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
            for(j=0;j<16;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }
        }
        else {
            // Formatted guid (e.g., 38145c62-5a26-11d2-b388-0000f87a46c8).
            WCHAR szGuid[36+1];

            wcsncpy(szGuid, pUfn, 36);
            szGuid[36] = L'\0';

            if (UuidFromStringW(szGuid, (GUID *) ObjGuid)) {
                // Incorrect format.
                return 1;
            }
        }
        ccUfn = 0;
        // We must have correctly parsed out a guid.  No string name left.

    }
    else if (ccUfn > 4 && _wcsnicmp(pUfn, L"sid:", 4) == 0) {
        //
        // First check for the standard user friendly string form of
        // the sid.
        //
        if ((ccUfn>6) && // Must have more than just "sid:S-"
            _wcsnicmp(pUfn, L"sid:S-", 6) == 0) {
            PSID     pSid = NULL;
            PWCHAR   pTmpUfn;
            unsigned ccTmpUfn;

            // Make a copy of the user friendly name so that it can be
            // null terminated appropriately for ConvertStringSidToSid

            ccTmpUfn = ccUfn - 3;  // 4 for sid: add one for the 
                                   // terminating null

            pTmpUfn = THAllocEx(pTHS, ccTmpUfn * sizeof(*pTmpUfn));
            CopyMemory(pTmpUfn, pUfn + 4, ccTmpUfn * sizeof(*pTmpUfn));
            pTmpUfn[ccTmpUfn - 1] = L'\0';

            if (ConvertStringSidToSidW(pTmpUfn, &pSid)) {
                SidLen = RtlLengthSid(pSid);
                Assert(SidLen <= sizeof(ObjSid));
                CopyMemory(ObjSid, pSid, SidLen);

                LocalFree(pSid); pSid = NULL;
                //
                // Success!
                //
                dwContents = foundSID;
                
                // We have correctly parsed out a sid.  No string name left.
                ccUfn=0;
            }

            THFreeEx(pTHS, pTmpUfn);
        }

        if (dwContents != foundSID) {
            //
            // It wasn't the the standard user friendly form.  Maybe it's the byte
            // encoded string form.
            //
            SidLen= (ccUfn - 4)/2; // Number of bytes that must be in the SID,
                                   // if this is indeed a Sid. Subtract 4 for
                                   // "SID:", leaving only the characters
                                   // which encode the string.  Divide by two
                                   // because each byte is encoded by two
                                   // characters.

            if((ccUfn<6) ||   // at least 2 for val, 4 for "SID:"
                (ccUfn & 1) || // Must be an even number of characters
                (SidLen > sizeof(NT4SID)) ){  // Max size for a SID
                    // Invalidly formatted
                    return 1;
            }
            pUfn+=4;
            dwContents = foundSID;
            for(j=0;j<SidLen;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjSid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }

            // We have correctly parsed out a sid.  No string name left.
            ccUfn=0;
        }
    }
    else if ((ccUfn > 2) && 
             (*pUfn == L'$') && 
             (DSNameExpandMacro (pTHS, pUfn, ccUfn, ppDN) == 0) ) {

        return 0;
    }

    // We may have parsed out either a GUID or a SID.  Build the DSNAME
    dnstructlen = DSNameSizeFromLen(ccUfn);
    *ppDN = (DSNAME *)THAllocEx(pTHS, dnstructlen);

    // Null out the DSName
    memset(*ppDN, 0, dnstructlen);

    (*ppDN)->structLen = dnstructlen;

    switch(dwContents) {

    case foundString:
        // Just a string name

        if(ccUfn) {
            WCHAR *pString = (*ppDN)->StringName;   // destination string
            WCHAR *p = pUfn;         // original string
            DWORD cc = ccUfn;        // num chars to process
            BOOL  fDoItFast = TRUE;

            // this loop is a substitute for
            // memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
            // we try to find out whether the DN passed in has an escaped constant
            while (cc > 0) {

                if (*p == L'"' || *p== L'\\') {
                    fDoItFast = FALSE;
                    break;
                }

                *pString++ = *p++;
                cc--;
            }
            
            (*ppDN)->NameLen = ccUfn;
            
            // if we have an escaped constant in the DN
            // we convert it to blockname and back to DN so as to
            // put escaping into a standardized form which will help
            // future comparisons
            //
            if (!fDoItFast) {
                ATTRBLOCK *pAttrBlock = NULL;
                DWORD err;

                memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
                (*ppDN)->StringName[ccUfn] = L'\0';

                err = DSNameToBlockName (pTHS, *ppDN, &pAttrBlock, DN2BN_PRESERVE_CASE);
                THFreeEx (pTHS, *ppDN); *ppDN = NULL;
                if (err) {
                    return err;
                }

                err = BlockNameToDSName (pTHS, pAttrBlock, ppDN);
                FreeBlockName (pAttrBlock);

                return err;
            }
            
        }
        break;

    case foundGUID:
        // we found a guid
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;
        
    case foundSID:
        // we found a sid.
        if(SidLen) {
            // We must have found a SID

            // First validate the SID

            if ((RtlLengthSid(ObjSid) != SidLen) || (!RtlValidSid(ObjSid)))
            {
                return(1);
            }
            memcpy(&(*ppDN)->Sid, ObjSid, SidLen);
            (*ppDN)->SidLen = SidLen;
        }
        break;
    }

    // Null terminate the string if we had one (or just set the string to '\0'
    // if we didn't).
    (*ppDN)->StringName[ccUfn] = L'\0';

    return 0;
}


/*++ fhasDescendantNC
 *
 * Given the name of a purported DS object (in blockname format), this
 * routine scans the list of cross refernces held by this DSA and
 * returns TRUE if some object is the descendant of the purported DS object.
 *
 * INPUT:
 *    pObj    - name of the purported object, in blockname format
 *    pComArg - common argument flags
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    TRUE  - there is at least one cross ref that could be a descendant.
 *    FALSE - unable to verify that at least one cross reff could be a
 *            descendant
 *
 */
BOOL
fHasDescendantNC(
        THSTATE *pTHS,
        ATTRBLOCK *pObj,
        COMMARG *pComArg
        )
{
    NCL_ENUMERATOR nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2, pObj);
    if (NCLEnumeratorGetNext(&nclEnum)) {
        return TRUE;
    }

    if (!pComArg->Svccntl.dontUseCopy) {
        // copies are acceptable
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2, pObj);
        if (NCLEnumeratorGetNext(&nclEnum)) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
MangleRDN(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    )
/*
 * This is the excepting version of MangleRDN.
 * The base version, MangleRDNWithStatus, lives in parsedn.c
 */

{
    if (MangleRDNWithStatus( eMangleFor, pGuid, pszRDN, pcchRDN )) {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);        
    }
}

BOOL
IsExemptedFromRenameRestriction(THSTATE *pTHS, MODIFYDNARG *pModifyDNArg)
{
    // If the originating rename operation attempts to rename an RDN 
    // mangled due to repl conflict to its original name, then we 
    // would exempt the operation from rename restrictions. Rename restrictions
    // are dictated by the System-Flag setting on the object.
    // This function is used to exempt the rename restrictions on objects with 
    // mangled names due to naming conflicts so that the admin could rename it 
    // to its original name if he chooses after resolving the name conflict.
    // Of course, the assumption here is that the admin has made sure there is
    // no other object with that name when he attempts to rename the mangled-name
    // to the original name.

    WCHAR       RDNVal[MAX_RDN_SIZE];
    ATTRTYP     RDNType;
    ULONG       RDNLen;
    ULONG       PreservedRDNLen;
    ULONG       NewRDNLen;

    // Check if the name is mangled. Note that we don't check for mangle-type here.
    // The caller will have already excluded deleted objects.
    if (pModifyDNArg && pModifyDNArg->pObject && pModifyDNArg->pNewRDN
        && (0 == GetRDNInfo(pTHS, pModifyDNArg->pObject, RDNVal, &RDNLen, &RDNType))
        && (IsMangledRDNExternal( RDNVal, RDNLen, &PreservedRDNLen )))
    {
        // Input params are valid and this is an attempt to rename a Mangled RDN which
        // was mangled due to name conflict. Now we will Exempt this operation from 
        // rename restrictions if and only if the new RDN is same as the RDN of the object 
        // before the name was mangled(if the original name is preserved in the mangled name) or 
        // if the new RDN contains at least the preserved portion of the original name as a 
        // prefix (if the original name was not completely preserved in the mangled name)

        NewRDNLen = pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR);

        if (((NewRDNLen == PreservedRDNLen)
              || ((NewRDNLen > PreservedRDNLen)
                    && (MAX_RDN_SIZE == RDNLen)))
            && (0 == _wcsnicmp(RDNVal, 
                               (WCHAR *) pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal, 
                               PreservedRDNLen)))
        {
            return TRUE;
        }
    }

    // we can't exempt this operation from rename restrictions
    return FALSE;    
}


unsigned
GenAutoReferral(THSTATE *pTHS,
                ATTRBLOCK *pTarget,
                WCHAR **ppDNS)
{
    int i,j;
    unsigned cc, cbVal;
    WCHAR *pDNS, *pDNScur;

    for (i=0; i<(int)(pTarget->attrCount); i++) {
        if (pTarget->pAttr[i].attrTyp != ATT_DOMAIN_COMPONENT) {
            break;
        }
    }

    if (i>0) {
        // Ok, we have (i) components at the top of the DN that are "DC=",
        // which means that we can construct a guess at a DNS name that might
        // map to whatever the guy is trying to read.
        cc = 0;
        for (j=0; j<i; j++) {
            cc += (pTarget->pAttr[j].AttrVal.pAVal[0].valLen / sizeof(WCHAR));
            ++cc;
        }

        // cc is now the count of chars in the new DNS addr we're going to
        // generate, so allocate enough space to hold it.  pDNS is a pointer
        // to the start of this buffer, and pDNScur is a pointer to the next
        // available character as we append.

        pDNS = THAllocEx(pTHS, sizeof(WCHAR)*cc);
        pDNScur = pDNS;

        for (j=i-1; j>=0; j--) {
            memcpy(pDNScur,
                   pTarget->pAttr[j].AttrVal.pAVal[0].pVal,
                   pTarget->pAttr[j].AttrVal.pAVal[0].valLen);
            pDNScur += pTarget->pAttr[j].AttrVal.pAVal[0].valLen / sizeof(WCHAR);
            if (j) {
                // Tack on a dot after everything but the last component
                *pDNScur = L'.';
                ++pDNScur;
            }
        }

        cbVal = ((DWORD)(pDNScur - pDNS))*sizeof(WCHAR);
        *ppDNS = pDNS;
    }
    else {
        cbVal = 0;
    }

    return cbVal;
} // GetAutoReferral

ULONG
ValidateCRDeletion(THSTATE *pTHS,
                   DSNAME  *pDN)
/*
 * This routine checks to see if it's ok if the CR object pDN is deleted.
 * It sets an error in pTHS if not.
 */
{
    DBPOS *pDBTmp;
    ULONG err;
    DWORD sysflags;
    CROSS_REF *pThisCR = NULL;

    DBOpen(&pDBTmp);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp' 
        //         DBOpen returns non-NULL pDBTmp or throws an exception
        err = DBFindDSName(pDBTmp, pDN);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_FIND_EXPECTED_NC,
                          err);
            __leave;
        }

        err = DBGetSingleValue(pDBTmp,
                               ATT_SYSTEM_FLAGS,
                               &sysflags,
                               sizeof(sysflags),
                               NULL);
        if (err) {
            sysflags = 0;
        }

        if ( sysflags & FLAG_CR_NTDS_NC ) {
            // If the CR is for an NC in our forest, we disallow deletion
            // if there exists a child NC.
            ULONG unused;
            DSNAME *pNC;
            CROSS_REF_LIST * pCRL;
            ATTCACHE *pAC;
            DSNAME *pDSA;
            
            err = DBGetAttVal(pDBTmp,
                              1,
                              ATT_NC_NAME,
                              0,
                              0,
                              &unused,
                              (UCHAR**)&pNC);

            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_CANT_FIND_EXPECTED_NC,
                              err);
                __leave;
            }

            pCRL = gAnchor.pCRL;

            while (pCRL) {
                if (NamePrefix(pNC, pCRL->CR.pNC)) {
                    if (NameMatched(pNC, pCRL->CR.pNC)) {
                        Assert(NULL == pThisCR);
                        pThisCR = &pCRL->CR;
                    } else {
                        SetUpdError(UP_PROBLEM_CANT_ON_NON_LEAF,
                                    ERROR_DS_CANT_ON_NON_LEAF);
                        __leave;
                    }
                }
                pCRL = pCRL->pNextCR;
            }

            // If CR was found in the database as a deletion candidate, it
            // should have been found in the crossRef cache.
            LooseAssert(pThisCR != NULL && "CR is in the DB, but not in the CR cache", GlobalKnowledgeCommitDelay);

            if ((NULL != pThisCR)
                && !fIsNDNCCR(pThisCR)) {
                // If the CR is for a domain/config/schema NC which is still
                // mastered by someone, we disallow deletion.  Does this cause
                // complications for legitimate uninstall?  DC demotion only
                // deletes a CR when demoting the last DC in a non-root domain.
                // And in those cases, the NTDS-DSA object is deleted first on
                // the same DC.  Thus the DC hosting the CR deletion truly
                // should have no NTDS-DSA whose hasMasterNCs point to the NC
                // in question when the CR deletion is requested during DC
                // demotion.
    
                pAC = SCGetAttById(pTHS, ATT_MASTERED_BY);
                Assert(NULL != pAC);
                Assert(FIsBacklink(pAC->ulLinkID));
    
                // Seek to NC head.  GC-ness has been verified before
                // we got here, thus we can expect to have a copy of
                // all NCs which are active (modulo replication latency).
                switch ( err = DBFindDSName(pDBTmp, pNC) ) {
                case 0:
                case DIRERR_NOT_AN_OBJECT:
                    // Found an instantiated object or a phantom.
                    // See if masteredBy has any values.
                    switch ( err = DBGetAttVal_AC(pDBTmp, 1, pAC, 
                                                  0, 0, &unused, 
                                                  (UCHAR **) &pDSA) ) {
                    case DB_success:
                        // Someone masters this NC - reject the delete.
                        THFreeEx(pTHS, pDSA);
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_NC_STILL_HAS_DSAS);
                        __leave;
                    case DB_ERR_NO_VALUE:
                        // No one masters this NC - nothing to object to.
                        break;
                    default:
                        SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                      DIRERR_DATABASE_ERROR, err);
                        __leave;
                    }
                    break;
                case DIRERR_OBJ_NOT_FOUND:
                    // If we have the crossRef we must at least have a phantom
                    // for the ncName.  Is the CR cache incoherent?  Fall
                    // through to return an error.
                default:
                    SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                  DIRERR_DATABASE_ERROR, err);
                    __leave;
                }
            }
        }
    } __finally {
        DBClose(pDBTmp, TRUE);
    }

    return pTHS->errCode;
}

// This routine was not located in parsedn.c because parsedn.c is included in client
// libraries and is a more restricted environment.
void
SpliceDN(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pOriginalDN,
    IN  DSNAME *    pNewParentDN,   OPTIONAL
    IN  WCHAR *     pwchNewRDN,     OPTIONAL
    IN  DWORD       cchNewRDN,      OPTIONAL
    IN  ATTRTYP     NewRDNType,     OPTIONAL
    OUT DSNAME **   ppNewDN
    )
/*++

Routine Description:

    Construct a new DN from the original DN, an optional new parent DN, and an
    optional new RDN.  The resultant DN has the same GUID/SID as the original.

Arguments:

    pTHS (IN) - THSTATE.

    pOriginalDN (IN) - Original DN.

    pNewParentDN (IN, OPTIONAL) - Parent DN to substitute for the original
        parent.  May be NULL, in which case the new parent is the same as the
        original parent.

    pwchNewRDN (IN, OPTIONAL) - RDN to substitute for the original RDN.  May be
        NULL, in which case the new RDN is that same as the original RDN.

    cchNewRDN (IN, OPTIONAL) - Length in characters of pwchNewRDN.  Ignored if
        pwchNewRDN is NULL.

    NewRDNType (IN, OPTIONAL) - Class-specific RDN type (e.g., ATT_COMMON_NAME)
        for the new RDN.  Ignored if pwchNewRDN is NULL.

    ppNewDN (OUT) - On return, holds a pointer to the spliced DN.

Return Values:

    None.  Throws exception on error.

--*/
{
    DWORD cchNewDN;
    BOOL bNewParentDNAllocd = FALSE;
    BOOL bNewRDNAllocd = FALSE;

    Assert(pNewParentDN || pwchNewRDN);
    Assert(!pwchNewRDN || (NewRDNType && (ATT_RDN != NewRDNType)));

    if (NULL == pNewParentDN) {
        // New parent is the same as the old parent.
        pNewParentDN = THAllocEx(pTHS, pOriginalDN->structLen);
        bNewParentDNAllocd = TRUE; // signal that this was alloc'd and should be cleaned up
        if (TrimDSNameBy(pOriginalDN, 1, pNewParentDN)) {
            DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
        }
    }

    if (NULL == pwchNewRDN) {
        // New parent is the same as the old parent.
        // New RDN is the same as the old RDN.
        pwchNewRDN = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);
        bNewRDNAllocd = TRUE; // signal that this was alloc'd and should be cleaned up
        if (GetRDNInfo(pTHS, pOriginalDN, pwchNewRDN, &cchNewRDN, &NewRDNType)) {
            DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
        }
    }

    // Construct new DN from new parent and new RDN.
    cchNewDN = pNewParentDN->NameLen + cchNewRDN + MAX_RDN_KEY_SIZE + 4;
    *ppNewDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cchNewDN));

    if (AppendRDN(pNewParentDN,
                  *ppNewDN,
                  DSNameSizeFromLen(cchNewDN),
                  pwchNewRDN,
                  cchNewRDN,
                  NewRDNType)) {
        DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    Assert((*ppNewDN)->NameLen <= cchNewDN);

    // Copy the GUID & SID from the original DN to the new DN.
    (*ppNewDN)->Guid   = pOriginalDN->Guid;
    (*ppNewDN)->Sid    = pOriginalDN->Sid;
    (*ppNewDN)->SidLen = pOriginalDN->SidLen;

    if(bNewParentDNAllocd && pNewParentDN != NULL) THFreeEx(pTHS, pNewParentDN);
    if(bNewRDNAllocd && pwchNewRDN != NULL) THFreeEx(pTHS, pwchNewRDN);

}


VOID
CheckNCRootNameOwnership(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    )

/*++

Routine Description:

This routine is called in at least three circumstances where we know that a cross-ref
has just been removed.  In all cases we know that ownership the name pointed to by its
ncName attribute is being released.  We want to check if there is another cross-ref which
wants this name. If so, we fix up the other cross-ref to have the name.  The three cases
are:
1. NC teardown in the KCC (removal of replica)
2. Remove auto subref where the referent was a phantom
3. Remove auto subref where the referent was a subref

We check the cross reference list for a cross-ref with a conflicted name. If we find one,
we unmangle it and see if it matches the NC we are tearing down. If so, then we unmangle
the name of the new NC head so that it can have the good name. The cross-ref ncName attribute
gets fixed up by virtue of being a reference. We must adjust the cross-ref cache so that it
also uses the correct name. 

We only fix the first cross-ref that we find in this conflicted state.

The caller must commit the transaction.

This routine has no name conflict retry logic. It is assumed that the caller has already
taken care of mangling the old holder of the name.

Arguments:

    pTHS - Thread state
    pNC - Unmangled name of NC to check for

Return Value:

   Exceptions raised

--*/

{
    ULONG ret = 0;
    CROSS_REF_LIST * pCRL = gAnchor.pCRL;
    WCHAR wchRDN[MAX_RDN_SIZE];
    DWORD cchRDN, cchUnMangled;
    ATTRTYP attrtypRDN;
    DSNAME *pUnMangledDN = NULL;
    BOOL fFound = FALSE;
    ATTRVAL attrvalRDN;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    DPRINT1( 1, "Enter CheckNCRootNameOwnership nc %ws\n", pNC->StringName );

    // See if there exists another cross-ref with a mangled version of this name
    while (pCRL) {
        if (GetRDNInfo(pTHS, pCRL->CR.pNC, wchRDN, &cchRDN, &attrtypRDN)) {
            DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
        }
        if (IsMangledRDNExternal( wchRDN, cchRDN, &cchUnMangled )) {
            BOOL fMatch;

            DPRINT3( 1, "cross_ref %p name %ws nc %ws is mangled\n",
                     &(pCRL->CR), pCRL->CR.pObj->StringName, pCRL->CR.pNC->StringName );

            // Construct the unmangled string name
            SpliceDN(
                pTHS,
                pCRL->CR.pNC,   // Original DN
                NULL,           // New parent same as the original
                wchRDN,        // New RDN
                cchUnMangled,  // Length in chars of new RDN
                attrtypRDN,    // RDN type
                &pUnMangledDN  // New DN
                );

            fMatch = NameMatchedStringNameOnly(pNC, pUnMangledDN);

            THFreeEx(pTHS, pUnMangledDN);

            if ( fMatch ) {
                break;
            }
        }

        pCRL = pCRL->pNextCR;
    }
    if (!pCRL) {
        return;
    }

    DPRINT( 1, "NC needs to have its name unmangled\n" );

    attrvalRDN.valLen = cchUnMangled * sizeof(WCHAR);
    attrvalRDN.pVal = (UCHAR *) wchRDN;

    // We need to correct the name on the object referenced by the ncName
    // on the cross-ref. The object is most likely a phantom or a subref.
    // It should not be an instantiated NC head. Position on it.
    ret = DBFindDSName(pTHS->pDB, pCRL->CR.pNC);
    if ( ret && (ret != DIRERR_NOT_AN_OBJECT) ) {
        DPRINT2( 0, "Failed to find mangled object or phantom for %ws, ret = %d\n",
                 pCRL->CR.pNC->StringName, ret );
        LogUnhandledError( ret );
        DRA_EXCEPT(ERROR_DS_DATABASE_ERROR, ret);
    }

    // Give the mangled phantom the original name
    ret = DBResetRDN( pTHS->pDB, &attrvalRDN );
    if(!ret) {
        ret = DBUpdateRec(pTHS->pDB);
    }
    if (!ret) {
        // Modify cross-ref object caching
        ModCrossRefCaching( pTHS, &(pCRL->CR) );
    }
    if (ret) {
        DPRINT4( 0, "Failed to reset rdn ='%*.*ws', ret = %d\n",
                 cchUnMangled, cchUnMangled, wchRDN, ret );
        LogEvent8WithData( DS_EVENT_CAT_REPLICATION,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_DRA_NCNAME_CONFLICT_RENAME_FAILURE,
                           szInsertDN(pCRL->CR.pObj),
                           szInsertDN(pCRL->CR.pNC),
                           szInsertDN(pNC),
                           szInsertWin32Msg(ret),
                           NULL, NULL, NULL, NULL,
                           sizeof(ret),
                           &ret );
        // Rename failed; bail.
        DRA_EXCEPT( ret, 0 );
    }

    // Assume the caller will commit

    DPRINT2( 0, "Renamed conflicted NC HEAD RDN from %ws to %ws.\n",
             pCRL->CR.pNC->StringName, pNC->StringName );

    LogEvent( DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_NCNAME_CONFLICT_RENAME_SUCCESS,
              szInsertDN(pCRL->CR.pObj),
              szInsertDN(pCRL->CR.pNC),
              szInsertDN(pNC) );

    DPRINT( 1, "Exit CheckNCRootNameOwnership\n" );

} /* CheckNCRootNameOwnership */


BOOL
IsMangledDSNAME(
    DSNAME *pDSName
    )

/*++

Routine Description:

    Detect whether a DSNAME has a mangled component ANYWHERE in the name

Arguments:

    pDSName - 

Return Value:

    BOOL - 

--*/

{
    ULONG cAVA=0,len,i;
    unsigned curlen = pDSName->NameLen;
    WCHAR * pKey, *pQVal;
    unsigned ccKey, ccQVal;
    WCHAR rdnbuf[MAX_RDN_SIZE];
    unsigned err;
    GUID EmbeddedGuid;
    MANGLE_FOR peMangleFor;

    err = CountNameParts(pDSName, &cAVA);
    if (err) {
        return FALSE;
    }
    if (cAVA == 0) {
        Assert(IsRoot(pDSName));
        return FALSE;
    }
    for (i=0; i<cAVA; i++) {
        Assert(curlen);

        // extract the most significant remaining name component
        err = GetTopNameComponent(pDSName->StringName,
                                  curlen,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            return FALSE;
        }
        if (NULL == pKey) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // shorten our view of the string name, which removes the
        // name component we got above
        curlen = (unsigned)(pKey - pDSName->StringName);

        len = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (len == 0 || len > MAX_RDN_SIZE) {
            return FALSE;
        }

        if (IsMangledRDN(rdnbuf, len, &EmbeddedGuid, &peMangleFor)) {
            // In the future, if the caller needs to know which component,
            // the embedded guid or the mangle type, we can return those
            return TRUE;
        }   
    }

    return FALSE;
} /* IsMangledDSNAME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdndnc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 2000
//
//  File:       mdndnc.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the functions necessary for the maintance of Non-Domain 
    Naming Contexts.

*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <attids.h>
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <prefix.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <sddl.h>
#include <ntdsapi.h>
#include <windns.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                      // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include "drancrep.h"                   // for ReplicateCrossRefBack().
#include "ntdsadef.h"
#include "sdprop.h"
#include "dsaapi.h"                     // For DirReplicaAdd & DirReplicaSynchronize

#define DEBSUB "MDNDNC:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDNDNC

#include <ntdsadef.h>
  
DSNAME *
DeepCopyDSNAME(
    THSTATE *                      pTHS,
    DSNAME *                       pDsNameOrig,
    DSNAME *                       pPreAllocCopy
    )
{
    DSNAME *                       pDsNameCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pDsNameOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pDsNameCopy = pPreAllocCopy;
        Assert(!"If someone runs into this, then they can take it out, but it "
               "is suspicious you are pre-allocating this structure.\n");
        Assert(pDsNameCopy->structLen == pDsNameOrig->structLen && "It would "
               "be a good idea if these equaled each other to prove the called "
               "knows what he is doing");
        Assert(!IsBadWritePtr(pDsNameCopy, pDsNameOrig->structLen) && "This is "
               "bad, this means this call of DeepCopyDSNAME needs to not have "
               "the parameter preallocated, because the caller doesn't know "
               "how to allocate the right size struct\n");
    } else {
        // Means we need to THAlloc the structure and then fill it in.
        pDsNameCopy = THAllocEx(pTHS, pDsNameOrig->structLen);
    }

    Assert(!IsBadReadPtr(pDsNameOrig, sizeof(pDsNameOrig->structLen)));
    Assert(!IsBadWritePtr(pDsNameCopy, 1));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    memcpy(pDsNameCopy, pDsNameOrig, pDsNameOrig->structLen);

    return(pDsNameCopy);
}

ATTRVAL *
DeepCopyATTRVAL(
    THSTATE *                       pTHS,
    ATTRVAL *                       pAttrValOrig,
    ATTRVAL *                       pPreAllocCopy
    )
{
    ATTRVAL *                       pAttrValCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...


    // This ensures this static definition doesn't change/expand on us.
    Assert(sizeof(ATTRVAL) == sizeof( struct { ULONG u; UCHAR * p; } ) &&
           "There've been changes to ATTRVAL's definition, please update "
           "function: DeepCopyATTRVAL()\n");
 
    Assert(pPreAllocCopy);
    pAttrValCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrValOrig, sizeof(ATTRVAL)));
    Assert(!IsBadWritePtr(pAttrValCopy, sizeof(ATTRVAL)));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrValCopy->valLen = pAttrValOrig->valLen;
    pAttrValCopy->pVal = THAllocEx(pTHS, sizeof(UCHAR) * pAttrValOrig->valLen);
    memcpy(pAttrValCopy->pVal, pAttrValOrig->pVal, pAttrValOrig->valLen);

    return(pAttrValCopy);
}

ATTRVALBLOCK *
DeepCopyATTRVALBLOCK(
    THSTATE *                      pTHS,
    ATTRVALBLOCK *                 pAttrValBlockOrig,
    ATTRVALBLOCK *                 pPreAllocCopy
    )
{
    ATTRVALBLOCK *                 pAttrValBlockCopy = NULL;
    ULONG                          i;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    
    // This ensures this static definition doesn't change/expand on us.
    Assert( sizeof(ATTRVALBLOCK) == sizeof( struct { ULONG u; ATTRVAL * p; } ) &&
            "There've been changes to ATTRVALBLOCK's definition, please update "
            "function: DeepCopyATTRVALBLOCK()\n");

    Assert(pPreAllocCopy);    
    pAttrValBlockCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrValBlockOrig, sizeof(ATTRVALBLOCK)));
    Assert(!IsBadWritePtr(pAttrValBlockCopy, sizeof(ATTRVALBLOCK)));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrValBlockCopy->valCount = pAttrValBlockOrig->valCount;
    pAttrValBlockCopy->pAVal = THAllocEx(pTHS, sizeof(ATTRVAL) * pAttrValBlockOrig->valCount);
    for(i = 0; i < pAttrValBlockCopy->valCount; i++){
        DeepCopyATTRVAL(pTHS, &(pAttrValBlockOrig->pAVal[i]), &(pAttrValBlockCopy->pAVal[i]));
    }

    return(pAttrValBlockCopy);
}


ATTR *
DeepCopyATTR(
    THSTATE *                      pTHS,
    ATTR *                         pAttrOrig,
    ATTR *                         pPreAllocCopy
    )
{
    ATTR *                         pAttrCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...

    // This ensures this static definition doesn't change/expand on us.
    Assert(sizeof(ATTR) == sizeof(struct { ATTRTYP a; ATTRVALBLOCK ab; } ) && 
           "There've been changes to the definition of ATTR, please update "
           "function: DeepCopyATTR()\n");

    Assert(pPreAllocCopy);    
    pAttrCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrOrig, sizeof(ATTR)));
    Assert(!IsBadWritePtr(pAttrCopy, sizeof(ATTR)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrCopy->attrTyp = pAttrOrig->attrTyp;
    DeepCopyATTRVALBLOCK(pTHS, &(pAttrOrig->AttrVal), &(pAttrCopy->AttrVal));

    return(pAttrCopy);
}

ATTRBLOCK *
DeepCopyATTRBLOCK(
    THSTATE *                      pTHS,
    ATTRBLOCK *                    pAttrBlockOrig,
    ATTRBLOCK *                    pPreAllocCopy
    )
{
    ATTRBLOCK *                    pAttrBlockCopy = NULL;
    ULONG                          i;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);
    Assert(sizeof(ATTRBLOCK) == sizeof( struct { ULONG u; ATTR * p; } ) &&
           "There've been changes to ATTRBLOCK's definition, please update "
           "funtion: DeepCopyATTRBLOCK()\n");
    
    if(pAttrBlockOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pAttrBlockCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own ATTRBLOCK.
        pAttrBlockCopy = THAllocEx(pTHS, sizeof(ATTRBLOCK));
    }

    Assert(!IsBadReadPtr(pAttrBlockOrig, sizeof(ATTRBLOCK)));
    Assert(!IsBadWritePtr(pAttrBlockCopy, sizeof(ATTRBLOCK)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrBlockCopy->attrCount = pAttrBlockOrig->attrCount;
    pAttrBlockCopy->pAttr = THAllocEx(pTHS, sizeof(ATTR) * pAttrBlockOrig->attrCount);
    for(i = 0; i < pAttrBlockCopy->attrCount; i++){
        DeepCopyATTR(pTHS, &(pAttrBlockOrig->pAttr[i]), &(pAttrBlockCopy->pAttr[i]));
    }

    return(pAttrBlockCopy);    
}
 
PROPERTY_META_DATA_VECTOR *
DeepCopyPROPERTY_META_DATA_VECTOR(
    THSTATE *                      pTHS,
    PROPERTY_META_DATA_VECTOR *    pMetaDataVecOrig,
    PROPERTY_META_DATA_VECTOR *    pPreAllocCopy
    )
{

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    if(pMetaDataVecOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    
    // If this needs to be filled in, use DeepCopyADDARG as an example.
    Assert(pMetaDataVecOrig == NULL && "Assumed this function then "
           "is not called in a replication thread (!fDRA), but if it does, "
           "someone should create the appropriate "
           "DeepCopyPROPERTY_META_DATA_VECTOR(...) function.");
    // Suggest you use DeepCopyADDARG() as an example function.
    return(NULL);
}

COMMARG *
DeepCopyCOMMARG(
    THSTATE *                      pTHS,
    COMMARG *                      pCommArgOrig,
    COMMARG *                      pPreAllocCopy
    )
{
    COMMARG *                      pCommArgCopy = NULL;
    
    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pCommArgOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pCommArgCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pCommArgCopy = THAllocEx(pTHS, sizeof(COMMARG));
    }

    Assert(!IsBadReadPtr(pCommArgOrig, sizeof(COMMARG)));
    Assert(!IsBadWritePtr(pCommArgCopy, sizeof(COMMARG)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    // Note: Comm args are shallow structures so easy to fill in.
    *pCommArgCopy = *pCommArgOrig;

    return(pCommArgCopy);
}

RESOBJ *
DeepCopyRESOBJ(
    THSTATE *                      pTHS,
    RESOBJ *                       pResObjOrig,
    RESOBJ *                       pPreAllocCopy
    )
{
    RESOBJ *                       pResObjCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pResObjOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pResObjCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pResObjCopy = THAllocEx(pTHS, sizeof(RESOBJ));
    }

    Assert(!IsBadReadPtr(pResObjOrig, sizeof(RESOBJ)));
    Assert(!IsBadWritePtr(pResObjCopy, sizeof(RESOBJ)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    *pResObjCopy = *pResObjOrig;
    pResObjOrig->pObj = DeepCopyDSNAME(pTHS, pResObjOrig->pObj, NULL);
        
    return(pResObjCopy);
}

CREATENCINFO *
DeepCopyCREATENCINFO(
    THSTATE *                      pTHS,
    CREATENCINFO *                 pCreateNCOrig,
    CREATENCINFO *                 pPreAllocCopy
    )
{
    CREATENCINFO *                 pCreateNCCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pCreateNCOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pCreateNCCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pCreateNCCopy = THAllocEx(pTHS, sizeof(CREATENCINFO));
    }

    Assert(!IsBadReadPtr(pCreateNCOrig, sizeof(CREATENCINFO)));
    Assert(!IsBadWritePtr(pCreateNCCopy, sizeof(CREATENCINFO)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    *pCreateNCCopy = *pCreateNCOrig;
    Assert(pCreateNCCopy->pSDRefDomCR == NULL);
        
    return(pCreateNCCopy);
}

ADDARG *
DeepCopyADDARG(
    THSTATE * pTHS,
    ADDARG * pAddArgOrig,
    ADDARG * pPreAllocCopy
    )
{
    ADDARG *   pAddArgCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);
    
    if(pAddArgOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller, and
        pAddArgCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc the structure and then fill it in.
        pAddArgCopy = THAllocEx(pTHS, sizeof(ADDARG));
    }

    Assert(!IsBadReadPtr(pAddArgOrig, sizeof(ADDARG)));
    Assert(!IsBadWritePtr(pAddArgCopy, sizeof(ADDARG)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAddArgCopy->pObject = DeepCopyDSNAME(pTHS, pAddArgOrig->pObject, NULL);
    DeepCopyATTRBLOCK(pTHS, &(pAddArgOrig->AttrBlock), &(pAddArgCopy->AttrBlock));
    pAddArgCopy->pMetaDataVecRemote = DeepCopyPROPERTY_META_DATA_VECTOR(pTHS, pAddArgOrig->pMetaDataVecRemote, NULL);
    DeepCopyCOMMARG(pTHS, &(pAddArgOrig->CommArg), &(pAddArgCopy->CommArg));
    pAddArgCopy->pResParent = DeepCopyRESOBJ(pTHS, pAddArgOrig->pResParent, NULL);
    pAddArgCopy->pCreateNC = DeepCopyCREATENCINFO(pTHS, pAddArgOrig->pCreateNC, NULL);

    return (pAddArgCopy);
}

DWORD
AddNDNCHeadCheck(
    THSTATE *       pTHS,
    CROSS_REF *     pCR,
    ADDARG *        pAddArg
    )
{
    DBPOS *         pDB = NULL;
    WCHAR *         wszDnsTemp = NULL;
    ULONG           ulTemp = 0;
    BOOL            fCreatorGood = FALSE;
    BOOL            fEnabled = TRUE;
    ULONG           i, dwErr;
    ATTCACHE *      pAC;


    // This routine checks that this is a valid NC Head creation,
    //  checks that the Cross-Ref is in a disabled state, checks
    //  that the current DC is the DC in the dnsRoot attribute.
    //  Note that we're overloading this attribute just before
    //  NC head creation.  After the NC Head is created the 
    //  attribute will be the appropriate DNS name of the 
    //  domain, not just this DC.

    // Make sure we've a clear error state.
    Assert(!pTHS->errCode);

    DBOpen(&pDB);
    __try {

        dwErr = DBFindDSName(pDB, pCR->pObj);
        if(dwErr){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        }
               
        // ----------------------------------------------------
        //
        // Check that the cross-ref is enabled.
        //

        dwErr = DBGetSingleValue(pDB,
                                 ATT_ENABLED,
                                 &fEnabled,
                                 sizeof(fEnabled),
                                 NULL);

        if(dwErr == DB_ERR_NO_VALUE){
            // Deal w/ no value seperately, because, no value means TRUE in
            // this context.
            fEnabled = TRUE;
        } else if (dwErr){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        } 
        
        if(fEnabled){
            SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                        DIRERR_CROSS_REF_EXISTS);
            __leave;
        }

        // ----------------------------------------------------
        //
        // Check the dNSRoot attribute matches the
        // current DSA pwszHostDnsName.
        //
        pAC = SCGetAttById(pTHS, ATT_DNS_ROOT);
        dwErr = DBGetAttVal_AC(pDB, 1, pAC, 0, 0, 
                               &ulTemp, (UCHAR **) &wszDnsTemp);
        Assert(ulTemp > 0);
        if(dwErr == DB_ERR_NO_VALUE){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_MISSING_REQUIRED_ATT,
                          dwErr);
            __leave;
        } else if (dwErr) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        }

        wszDnsTemp = THReAllocEx(pTHS, wszDnsTemp, ulTemp + sizeof(WCHAR));
        wszDnsTemp[ulTemp/sizeof(WCHAR)] = L'\0';

        if( DnsNameCompare_W(wszDnsTemp, gAnchor.pwszHostDnsName) ){
            // keep going and check other stuff.
        } else {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        DIRERR_MASTERDSA_REQUIRED);
            __leave;
        }

        // We're golden ... 
        Assert(!pTHS->errCode);

    } __finally {

        if (wszDnsTemp) { THFreeEx(pTHS, wszDnsTemp); }
        DBClose(pDB, FALSE);
    
    }

    return(pTHS->errCode);
}


VOID
SometimesLogEvent(
    DWORD        dwEvent,
    BOOL         fAlways,
    DSNAME *     pdnNC
    )
{
    static DWORD  s_ulLastTickNoRefDomSet     = 0;
    const  DWORD  ulNoLogPeriod               = 300*1000; // 5 minutes
           DWORD  ulCurrentTick               = GetTickCount();
    
    if(((ulCurrentTick - s_ulLastTickNoRefDomSet) > ulNoLogPeriod) || fAlways){
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, 
                 szInsertDN(pdnNC),
                 NULL, NULL);
        s_ulLastTickNoRefDomSet = ulCurrentTick;
    }

}

CROSS_REF *
GetDefaultSDRefDomCR(
    DSNAME *       pdnNC
    )
{
    CROSS_REF *    pCR = NULL;
    CROSS_REF *    pSDRefDomCR = NULL;
    COMMARG        CommArg;
    DSNAME *       pdnParentNC = NULL;

    Assert(DsaIsRunning());
    Assert(!DsaIsInstalling());
    Assert(pTHStls);

    // Trim one DN off the NC to get the parent NC
    pdnParentNC = (DSNAME*)THAllocEx(pTHStls, pdnNC->structLen);
    TrimDSNameBy(pdnNC, 1, pdnParentNC);

    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pdnParentNC, &CommArg);

    if(pCR){
        
        // Use the domain or SDRefDom of the parent.

        // We can't have the parent be a config/schema NC.
        Assert(!NameMatched(pCR->pNC, gAnchor.pConfigDN) &&
               !NameMatched(pCR->pNC, gAnchor.pDMD));

        if(pCR->flags & FLAG_CR_NTDS_DOMAIN){

            // This is the 1st (of 2) successful exit paths.
            return(pCR);

        } else {

            if(pCR->pdnSDRefDom){

                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
                pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg);
                
                if(pSDRefDomCR){

                    // This is the 2nd successful potential exit path.
                    return(pSDRefDomCR);

                }

            }

            // else just log an event and return NULL.
            SometimesLogEvent(DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, TRUE,
                              pCR->pNC);
            return(NULL);

        }

    }

    // Presume NDNC is it's own rooted tree, use the root domain.
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
    Assert(pCR); // Huh!  We can't even find the root domain crossref.
    return(pCR);

}

PSID
GetSDRefDomSid(
    CROSS_REF *    pCR
    )
{
    PSID           pSid = NULL;
    CROSS_REF *    pSDRefDomCR = NULL;
    COMMARG        CommArg;

    Assert(pCR);    
    Assert(pCR->flags & FLAG_CR_NTDS_NC); // Don't add object not in our NCs.
 
    // This code does not yet handle non-NDNC queries.  In Blackcomb, this
    // function could be made to hand back the SID of the domain to 
    // implement multiple domains.
    if(!fIsNDNCCR(pCR)){
        Assert(!"This func wasn't intended to be used for domains/config/schema NCs.");
        return(NULL);
    }

    // This line is very important due to the semantics of how this variable
    // can be erased at any moment, though the data will remain valid for an
    // hour.
    pSid = pCR->pSDRefDomSid;

    if(pSid){
        // Yeah!!! The SID is cached, nothing to do but return it.
        Assert(IsValidSid(pSid));
        return(pSid);
    }

    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        pSid = pCR->pSDRefDomSid;
        if(pSid){
            Assert(IsValidSid(pSid));
            // WOW, this varibale got updated in a very narrow window.
            __leave; // Our work here is done.
        }

        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        
        if(pCR->pdnSDRefDom &&
           (NULL != (pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg))) &&
           pSDRefDomCR->pNC->SidLen > 0){
            
            // Update the cache.
            pCR->pSDRefDomSid = &pSDRefDomCR->pNC->Sid;
            pSid = pCR->pSDRefDomSid;
            Assert(pSid && IsValidSid(pSid));

        } else {

            // No valid reference domain, log event and fall through and
            // use the root domain.
            SometimesLogEvent(DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, FALSE,
                              pCR->pNC);

        }
    
    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }
    
    if(!pSid){

        // If we got here, then there was an error above, and we need to use
        // the root domain SID instead.
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        pSDRefDomCR = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
        if(pSDRefDomCR == NULL || 
           pSDRefDomCR->pNC == NULL ||
           pSDRefDomCR->pNC->SidLen == 0){
            Assert(!"What we can't find out own root domain.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
        } else {
            pSid = &pSDRefDomCR->pNC->Sid;
        }

    }

    Assert(pSid && IsValidSid(pSid));
    return(pSid);
}





#define DEFAULT_DELETED_OBJECTS_RDN    L"Deleted Objects"
#define DEFAULT_LOSTANDFOUND_RDN    L"LostAndFound"
#define DEFAULT_INFRASTRUCTURE_RDN    L"Infrastructure"


VOID    
SetAttSecurityDescriptor(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    WCHAR *               wcszStrSD
    )
{
    BOOL                  bRet;
    SECURITY_DESCRIPTOR * pSD = 0;
    ULONG                 cSD = 0;

    bRet = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                wcszStrSD,
                SDDL_REVISION_1,
                &pSD,
                &cSD);

    if(!bRet){
        // Two options, the programmer supplied arguments were bad, or 
        // there was an allocation error, we'll presume the later and 
        // raise an exception
        DPRINT1(0, "ConvertStringSecurityDescriptorToSecurityDescriptorW() failed with %d\n", GetLastError());
        Assert(!"Note this assert should ONLY fire if there is no more memory.  This function is not meant for user specified SD strings, only programmer (and thus flawless ;) SD strings.");
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0, 
                       ((FILENO << 16) | __LINE__), 
                       DS_EVENT_SEV_MINIMAL);
    }

    Assert(pSD);
    Assert(cSD);

    pAttr->attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = cSD;
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, cSD);
    memcpy (pAttr->AttrVal.pAVal[0].pVal, pSD, cSD);
    (*piAttr)++;

    LocalFree(pSD);
}

VOID
SetAttSingleValueUlong(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    ULONG                 ulAttData
    )
{
    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, sizeof(ULONG));
    *((ULONG *)pAttr->AttrVal.pAVal[0].pVal) = ulAttData;
    (*piAttr)++;
}

VOID
SetAttSingleValueDsname(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    DSNAME *               pDsname
    )
{
    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = pDsname->structLen;
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, pAttr->AttrVal.pAVal[0].valLen);
    memcpy((WCHAR *) pAttr->AttrVal.pAVal[0].pVal, pDsname, pDsname->structLen);
    (*piAttr)++;

}

VOID
SetAttSingleValueString(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    WCHAR *               wcszAttData
    )
{
    // Note that strings are stored w/o NULLs in the directory.

    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = wcslen(wcszAttData) * sizeof(WCHAR);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, pAttr->AttrVal.pAVal[0].valLen);
    memcpy((WCHAR *) pAttr->AttrVal.pAVal[0].pVal, 
           wcszAttData, 
           pAttr->AttrVal.pAVal[0].valLen);
    (*piAttr)++;

}

VOID
SetCommonThreeAttrs(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulClassId
    )
{

    // Set the objectClass attribute.
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_OBJECT_CLASS,
                           ulClassId);

    // Set the isCriticalSystemObject attribute
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_IS_CRITICAL_SYSTEM_OBJECT,
                           TRUE);
    
    // Set the systemFlags attribute
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_SYSTEM_FLAGS,
                           (FLAG_DOMAIN_DISALLOW_RENAME |
                            FLAG_DOMAIN_DISALLOW_MOVE |
                            FLAG_DISALLOW_DELETE));
}

VOID
FillDeletedObjectsAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock
    )
{
    ULONG                 iAttr = 0;

    // [Deleted Objects]
    // ; NOTE: This section is used for three objects, the Deleted Objects container
    // ; in Root Domain NC and the deleted objects container in the Config NC.
    // nTSecurityDescriptor=O:SYG:SYD:P(A;;RPWPCCDCLCSWRCWDWOSD;;;SY)(A;;RPLC;;;BA)S:P(AU;SAFA;RPWPCCDCLCSWRCWDWOSD;;;WD) 
    // objectClass =container
    // ObjectCategory =container
    // description=Default container for deleted objects
    // showInAdvancedViewOnly=True
    // isDeleted=True
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000
    
    pAttrBlock->attrCount = 6;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));
    
        // --------------------------
        ;
        SetCommonThreeAttrs(pTHS,
                    &(pAttrBlock->pAttr[iAttr]),
                    &iAttr,
                    CLASS_CONTAINER);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_DELETED_OBJECTS_RDN);
        SetAttSecurityDescriptor(pTHS,
                                 &(pAttrBlock->pAttr[iAttr]),
                                 &iAttr,
                                 L"O:SYG:SYD:P(A;;RPWPCCDCLCSWRCWDWOSD;;;SY)(A;;RPLC;;;BA)S:P(AU;SAFA;RPWPCCDCLCSWRCWDWOSD;;;WD)");
        SetAttSingleValueUlong(pTHS,
                               &(pAttrBlock->pAttr[iAttr]),
                               &iAttr,
                               ATT_IS_DELETED,
                               TRUE);

    Assert(iAttr == pAttrBlock->attrCount);
}

VOID
FillLostAndFoundAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock
    )
{
    ULONG                   iAttr = 0;

    // [LostAndFound]
    // nTSecurityDescriptor=O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)
    // objectClass =lostAndFound
    // ObjectCategory =Lost-And-Found
    // description=Default container for orphaned objects
    // showInAdvancedViewOnly=True
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000

    pAttrBlock->attrCount = 5;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));
    
        // --------------------------
        SetCommonThreeAttrs(pTHS,
                            &(pAttrBlock->pAttr[iAttr]),
                            &iAttr,
                            CLASS_LOST_AND_FOUND);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_LOSTANDFOUND_RDN);
        SetAttSecurityDescriptor(pTHS,
                         &(pAttrBlock->pAttr[iAttr]),
                         &iAttr,
                         L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)");



    Assert(iAttr == pAttrBlock->attrCount);

}

VOID
FillInfrastructureAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock,
    DSNAME *              pdsFsmo
    )
{
    ULONG                 iAttr = 0;
    
    // This is the Attr Block we are trying to achieve.
    // [Infrastructure]
    // nTSecurityDescriptor=O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)
    // objectClass =infrastructureUpdate
    // ObjectCategory =Infrastructure-Update
    // ShowInAdvancedViewOnly=True
    // fSMORoleOwner=$REGISTRY=Machine DN Name
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000

    // ---------------------------------
    pAttrBlock->attrCount = 6;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));
    
        // --------------------------
        SetCommonThreeAttrs(pTHS,
                            &(pAttrBlock->pAttr[iAttr]),
                            &iAttr,
                            CLASS_INFRASTRUCTURE_UPDATE);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_INFRASTRUCTURE_RDN);
        SetAttSingleValueDsname(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_FSMO_ROLE_OWNER,
                                pdsFsmo);
        SetAttSecurityDescriptor(pTHS,
                         &(pAttrBlock->pAttr[iAttr]),
                         &iAttr,
                         L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)");

    Assert(iAttr == pAttrBlock->attrCount);
}


ULONG
AddSpecialNCContainers(
    THSTATE *       pTHS,
    DSNAME *        pDN
    )
{
    ADDARG          AddArg;
    ADDRES          AddRes;
    DSNAME *        pContainerDN = NULL;
    DWORD           dwFlags = (  NAME_RES_PHANTOMS_ALLOWED 
                                | NAME_RES_VACANCY_ALLOWED);
    INT             iRetLen;
    BOOL            fDSASaved;
    DWORD           dwRet;
    

    // Given the pDN we will call LocalAdd() to add each of the 3 special 
    // containers: Deleted Objects, LostAndFound, & Infrastructure.
          
    // [DEFAULTROOTDOMAIN]
    // objectClass = DomainDNS
    // objectCategory = Domain-DNS
    // NTSecurityDescriptor=O:DAG:DAD:(A;;RP;;;WD)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;CI;RPWPCRLCLOCCRCWDWOSDSW;;;BA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;CI;LC;;;RU)(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RPLCLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(A;;RC;;;RU)(OA;CIIO;RPLCLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)S:(AU;CISAFA;WDWOSDDTWPCRCCDCSW;;;WD)
    // auditingPolicy=\x0001
    // nTMixedDomain=1
    // ;Its a NC ROOT
    // instanceType=5
    // ;Its the PDC, set FSMO role owner
    // fSMORoleOwner=$REGISTRY=Machine DN Name
    // wellKnownObjects=$EMBEDDED:32:ab8153b7768811d1aded00c04fd8d5cd:cn=LostAndFound,<Root Domain
    // wellKnownObjects=$EMBEDDED:32:2fbac1870ade11d297c400c04fd8d5cd:cn=Infrastructure,<Root Domain
    // wellKnownObjects=$EMBEDDED:32:18e2ea80684f11d2b9aa00c04f79f805:cn=Deleted Objects,<Root Domain
    // gPLink=$REGISTRY=GPODomainLink
    // mS-DS-MachineAccountQuota=10
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000
    
    Assert(pTHS->errCode == ERROR_SUCCESS);

    fDSASaved = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    __try {
        // ----------------------------------------------
        // Create AddArg for "Deleted Objects" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_DELETED_OBJECTS_RDN) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_DELETED_OBJECTS_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillDeletedObjectsAttrArray(pTHS, &(AddArg.AttrBlock));
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent) ){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }
        // One more thing to do, set the delete time _way_ in the future.
        dwRet = DBMoveObjectDeletionTimeToInfinite(AddArg.pObject);
        if(dwRet){
            SetSvcError(SV_PROBLEM_UNAVAILABLE, dwRet);
        }
         
        // ----------------------------------------------
        // Create AddArg for "LostAndFound" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_LOSTANDFOUND_RDN) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_LOSTANDFOUND_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillLostAndFoundAttrArray(pTHS, &(AddArg.AttrBlock));
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }

        // ----------------------------------------------
        // Create AddArg for "Infrastructure" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_INFRASTRUCTURE_RDN) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_INFRASTRUCTURE_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillInfrastructureAttrArray(pTHS, &(AddArg.AttrBlock), gAnchor.pDSADN);
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }

    } __finally {

        pTHS->fDSA = fDSASaved;

    }
    
    return(pTHS->errCode);
}

BOOL
AddNCWellKnownObjectsAtt(
    THSTATE *       pTHS,
    ADDARG *        pAddArg
    )
{
    ULONG           i;
    ULONG           cAttr, cAttrVal;
    ATTRVAL *       pNewAttrVal;
    INT             cRetLen;
    ULONG           cLen;
    SYNTAX_DISTNAME_BINARY *  pSynDistName;
    DSNAME *                  pDN = NULL;
    GUID                      guid = {0, 0, 0, 0};
    SYNTAX_ADDRESS *          pSynAddr;
    
    MODIFYARG                 ModArg;
    ATTRVAL                   AttrVals[3];
    COMMRES                   CommRes;
    ULONG                     ulRet;
    BOOL                      fDSASaved;

    // Need to massage add args to have additional containers for NC heads.
    
    Assert(pAddArg->pCreateNC);
    Assert(fISADDNDNC(pAddArg->pCreateNC)); // This may need
    // to be taken out if we do the special containers for other NCs here.

    memset(&ModArg, 0, sizeof(ModArg));
    ModArg.pObject = pAddArg->pObject;
    ModArg.count = 1;
    InitCommarg(&ModArg.CommArg);
    ModArg.FirstMod.choice = AT_CHOICE_ADD_ATT;
    ModArg.FirstMod.AttrInf.attrTyp = ATT_WELL_KNOWN_OBJECTS;
    ModArg.FirstMod.AttrInf.AttrVal.valCount = 3;
    ModArg.FirstMod.AttrInf.AttrVal.pAVal = AttrVals;
    ModArg.FirstMod.pNextMod = NULL;
    
    cAttrVal = 0;

    // ----------------------------------------------
    // Constructe WellKnownLink for deleted Objects
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_DELETED_OBJECTS_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_DELETED_OBJECTS_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_DELETED_OBJECTS_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    // Put the syntax distname in the attribute value block.
    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;
    
    cAttrVal++;

    // ----------------------------------------------
    // Constructe WellKnownLink for LostAndFound
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_LOSTANDFOUND_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_LOSTANDFOUND_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_LOSTANDFOUND_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;

    cAttrVal++;

    // ----------------------------------------------
    // Constructe WellKnownLink for Infrastructure Objects
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_INFRASTRUCTURE_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_INFRASTRUCTURE_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_INFRASTRUCTURE_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    // Put the syntax distname in the attribute value block.
    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;

    cAttrVal++;

                
    ulRet = DoNameRes(pTHS, 0, ModArg.pObject, &ModArg.CommArg, &CommRes, &ModArg.pResObj);
    if(ulRet){
        return(ulRet);
    }
 
    __try{
        fDSASaved = pTHS->fDSA;
        pTHS->fDSA = TRUE;
        LocalModify(pTHS, &ModArg);
    } __finally {
        pTHS->fDSA = fDSASaved;
    }
    
    return(pTHS->errCode);
}

VOID
TestNDNCLocalAdd(
    THSTATE *       pTHS,
    ADDARG *        pAddArg,
    ADDRES *        pAddRes
    )
{
    return;
}

DSNAME *
GetPartitionsDn(
    THSTATE *         pTHS
    )
{
    ULONG             cbPDN = 0;
    DSNAME *          pdnPartitions = NULL;

    // Caller must have a valid THSTATE.
    Assert(pTHS); 
    Assert(gAnchor.pConfigDN);

    // First do a fake AppendRDN() to get the size.
    cbPDN = AppendRDN(gAnchor.pConfigDN, NULL, 0, 
                      L"Partitions", wcslen(L"Partitions"), ATT_COMMON_NAME);
    Assert(cbPDN != -1);

    // Now actually do the AppendRDN().
    pdnPartitions = THAllocEx(pTHS, cbPDN);
    cbPDN = AppendRDN(gAnchor.pConfigDN, pdnPartitions, cbPDN, 
                      L"Partitions", wcslen(L"Partitions"), ATT_COMMON_NAME);

    Assert(cbPDN == 0);

    Assert(pdnPartitions);
    return(pdnPartitions);
}

DWORD
GetCrossRefDn(
    THSTATE *         pTHS,
    PDSNAME           pdnNC,
    PDSNAME *         ppdnCR
    )
{
    DSNAME *          pdnPartitions = NULL;
    GUID              CrossRefGuid = { 0, 0, 0, 0 };
    WCHAR *           wszCrossRefGuid = NULL;
    DWORD             dwRet;
    ULONG             cbCR;



    __try{
        // Step 1: Get Partition's container DN.
        pdnPartitions = GetPartitionsDn(pTHS);

        // ----------------------------------------
        // Step 1: Need Guid.
        dwRet = UuidCreate(&CrossRefGuid);
        if(dwRet != RPC_S_OK){
            __leave;
        }

        // Step 2: Convert GUID to String.
        dwRet = UuidToStringW(&CrossRefGuid, &wszCrossRefGuid);
        if(dwRet != RPC_S_OK){
            __leave;
        }
        Assert(wszCrossRefGuid);

        // Step 3: Allocate space for the cross ref DN.
        cbCR = AppendRDN(pdnPartitions,          // Base
                         NULL, 0,                // New
                         wszCrossRefGuid, 0, ATT_COMMON_NAME);  // RDN
        Assert(cbCR != -1);
        *ppdnCR = THAllocEx(pTHS, cbCR);

        // Step 4: Append the Guid RDN to the Partitions DN.
        dwRet = AppendRDN(pdnPartitions,   // base
                          *ppdnCR, cbCR,      // new
                          wszCrossRefGuid, 0, ATT_COMMON_NAME);  // RDN

        Assert(dwRet == 0);

    } __finally {

        if(wszCrossRefGuid){ RpcStringFreeW(&wszCrossRefGuid); }
        if(pdnPartitions){ THFreeEx(pTHS, pdnPartitions); }

    }

    return(dwRet);
}

DWORD
CreateCrossRefForNDNC(
    THSTATE *         pTHS,
    DSNAME *          pdnNC,
    ENTINF *          peiCR
    )
{
    DWORD             ulRet = ERROR_SUCCESS;
    ULONG             iAttr = 0;
    WCHAR *           pwszArrStr[1];
    DS_NAME_RESULTW * pdsrDnsName = NULL;
    WCHAR *           wszDnsName = NULL;
    DSNAME *          pdnCrossRef;
                                
    Assert(peiCR); // Caller must supply memory for ENTINF, because
    // the first ENTINF is usually embedded in the ENTINFLIST ... but
    // we'll allocate everything else :)

    memset(peiCR, 0, sizeof(ENTINF));

    ulRet = GetCrossRefDn(pTHS, pdnNC, &pdnCrossRef);
    if(ulRet){
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    peiCR->pName = pdnCrossRef;
    peiCR->AttrBlock.attrCount = 5;
    peiCR->AttrBlock.pAttr = THAllocEx(pTHS, 
              peiCR->AttrBlock.attrCount * sizeof(ATTR));
    
    // Set the objectClass to crossRef.
    SetAttSingleValueUlong(pTHS,
                           &(peiCR->AttrBlock.pAttr[iAttr]), 
                           &iAttr, 
                           ATT_OBJECT_CLASS,
                           CLASS_CROSS_REF);
    // Disable the Cross-Ref, the creation of the NC Head will enable it.
    SetAttSingleValueUlong(pTHS, 
                           &(peiCR->AttrBlock.pAttr[iAttr]), 
                           &iAttr, 
                           ATT_ENABLED, 
                           FALSE);
    // Set the DNS Root attribute to this DSA's DNS name
    SetAttSingleValueString(pTHS, 
                            &(peiCR->AttrBlock.pAttr[iAttr]),
                            &iAttr, 
                            ATT_DNS_ROOT, 
                            gAnchor.pwszHostDnsName);
    // Set nCName to the NC Head DN.
    SetAttSingleValueDsname(pTHS,
                            &(peiCR->AttrBlock.pAttr[iAttr]),
                            &iAttr,
                            ATT_NC_NAME,
                            pdnNC);
    // Set the systemFlags.
    SetAttSingleValueUlong(pTHS,
                           &(peiCR->AttrBlock.pAttr[iAttr]),
                           &iAttr,
                           ATT_SYSTEM_FLAGS,
                           FLAG_CR_NTDS_NC | FLAG_CR_NTDS_NOT_GC_REPLICATED);

    // This is no longer needed, but we're going to do it anyway because
    // it does advanced error checking, because it's better to fail now
    // then after creating the crossRef.
    pwszArrStr[0] = pdnNC->StringName;
    ulRet = DsCrackNamesW(NULL,
                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                          DS_FQDN_1779_NAME,
                          DS_CANONICAL_NAME,
                          1,
                          pwszArrStr,
                          &pdsrDnsName);
    Assert(ulRet != ERROR_INVALID_PARAMETER);
    if(ulRet){
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    __try {
        Assert(pdsrDnsName);
        Assert(pdsrDnsName->cItems == 1);
        Assert(pdsrDnsName->rItems != NULL);
        if(pdsrDnsName->rItems[0].status != DS_NAME_NO_ERROR){
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pdnNC,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        Assert(pdsrDnsName->rItems[0].pDomain);
    } __finally {
          DsFreeNameResultW(pdsrDnsName);
    }

    Assert(pTHS->errCode != 0 || iAttr == peiCR->AttrBlock.attrCount);

    return(pTHS->errCode);
}

DWORD
GetFsmoDnsAddress(
    IN     THSTATE *           pTHS,
    IN     DSNAME *            pdnFsmoContainer,
    OUT    WCHAR **            pwszFsmoDnsAddr,
    OUT    BOOL *              pfRemoteFsmo
    )

// This needs to work for install too.  In theory though not tested, this
// should work for any FSMO holder if you just pass the right pdnFsmoContainer.

{
    READARG           ReadArg;
    READRES *         pReadRes;
    ENTINFSEL         EIS;
    ATTR              Attr;
    ULONG             i;
    DSNAME *          pMasterDN = NULL;
    DSNAME *          pdnServer;
    ULONG             cbDnsAddr = 0;
    DWORD             dwRet;

    Assert(pwszFsmoDnsAddr || pfRemoteFsmo);

    memset(&ReadArg, 0, sizeof(READARG));
    ReadArg.pObject = pdnFsmoContainer;
    ReadArg.pSel = &EIS;
    InitCommarg(&ReadArg.CommArg);
    ReadArg.CommArg.Svccntl.dontUseCopy = FALSE;
    EIS.attSel = EN_ATTSET_LIST;
    EIS.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EIS.AttrTypBlock.attrCount = 1;
    EIS.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_FSMO_ROLE_OWNER;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal = NULL;

    dwRet = DirRead(&ReadArg, &pReadRes);
    
    if(dwRet){
        DPRINT1(3, "DirRead returned unexpected error %d.\n", dwRet);
        return(dwRet);
    }

    for (i=0; i < pReadRes->entry.AttrBlock.attrCount; i++) {
        if (ATT_FSMO_ROLE_OWNER ==
            pReadRes->entry.AttrBlock.pAttr[i].attrTyp) {
            pMasterDN =
              (DSNAME*) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            break;
        }
    }

    // BUGBUG now we've got the DSNAME of the nTDSA object, now we should
    // call the GuidBasedDNSNameFromDSName() to resolve the right DNS name,
    // BUT their is one catch, we need to make sure this function works
    // during dcpromo.  It uses the gAnchor to pull the rootdomain ... is 
    // that bad?????  Depends on if you can do this during dcpromo.  perhaps
    // we can pass the root domain into this function, or make this function
    // handle install by figuring out the root domain, and passing it down
    // to GuidBasedDNSNameFromDSName() ... or ??? keep thinking ???

    Assert(pMasterDN);
    Assert(gAnchor.pDSADN);

    if(pfRemoteFsmo){
        *pfRemoteFsmo = !NameMatched(pMasterDN, gAnchor.pDSADN);
    }
    if(!pwszFsmoDnsAddr){
        // The caller only wanted to know whether the FSMO was local or remote.
        return(ERROR_SUCCESS);
    }


    pdnServer = (DSNAME*)THAllocEx(pTHS, pMasterDN->structLen);
    TrimDSNameBy(pMasterDN, 1, pdnServer);
          
    memset(&ReadArg, 0, sizeof(READARG));
    ReadArg.pObject = pdnServer;
    ReadArg.pSel = &EIS;
    InitCommarg(&ReadArg.CommArg);
    ReadArg.CommArg.Svccntl.dontUseCopy = FALSE;
    EIS.attSel = EN_ATTSET_LIST;
    EIS.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EIS.AttrTypBlock.attrCount = 1;
    EIS.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_DNS_HOST_NAME;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal = NULL;

    dwRet = DirRead(&ReadArg, &pReadRes);
    
    THFree(pdnServer);

    if(dwRet){
        DPRINT1(3, "DirRead returned unexpected error %d.\n", dwRet);
        return(dwRet);
    }

    for (i=0; i<pReadRes->entry.AttrBlock.attrCount; i++) {
        if (ATT_DNS_HOST_NAME == pReadRes->entry.AttrBlock.pAttr[i].attrTyp) {
            cbDnsAddr = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
            break;
        }
    }
    Assert(cbDnsAddr);

    // Make sure the DNS root name is null-terminated.
    *pwszFsmoDnsAddr = THReAllocEx(pTHS, 
                  pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal,
                  cbDnsAddr + sizeof(WCHAR));
    Assert( (*pwszFsmoDnsAddr)[cbDnsAddr/sizeof(WCHAR)] == L'\0');
    return(ERROR_SUCCESS);
}

DWORD
GetCrossRefForNDNC(
    THSTATE *      pTHS,
    DSNAME *       pNCDN
    )
//
// Create Cross-Ref object corresponding to the domain we're now adding to the
// pre-existing DS enterprise.  Presumed to happen outside of a transaction.
//
{
    DSNAME *                pdnPartitions = NULL;
    DWORD                   ulRet = ERROR_SUCCESS;
    ENTINFLIST              entinflistCrossRef;
    ADDENTRY_REPLY_INFO *   infoList = NULL;
    WCHAR *                 wszNamingFsmoDns = NULL;
    SecBuffer               secBuffer = { 0, SECBUFFER_TOKEN, NULL };
    SecBufferDesc           clientCreds = { SECBUFFER_VERSION, 1, &secBuffer };
    BOOL                    fRemoteNamingFsmo = TRUE;

   
    // This is the remote CR creation code.
                                            
    Assert(fNullUuid(&pNCDN->Guid));

    //
    // Create CR EntInf
    //
                                            
    ulRet = CreateCrossRefForNDNC(pTHS, 
                                  pNCDN, 
                                  &(entinflistCrossRef.Entinf));
    entinflistCrossRef.pNextEntInf = NULL;
    if(ulRet){
        Assert(pTHS->errCode);
        return(ulRet);
    }

    //
    // Get Naming FSMO DNS address.
    //
    
    pdnPartitions = (DSNAME*)THAllocEx(pTHS,
                                entinflistCrossRef.Entinf.pName->structLen);
    TrimDSNameBy(entinflistCrossRef.Entinf.pName, 1, pdnPartitions);
    ulRet = GetFsmoDnsAddress(pTHS, 
                              pdnPartitions,
                              &wszNamingFsmoDns,
                              &fRemoteNamingFsmo);
    if(ulRet){
        Assert(pTHS->errCode);
        return(ulRet);
    }

    //
    // Add remotely.
    //

  retry:

    if(fRemoteNamingFsmo){
        // First package up the credentials of this client.
        ulRet = GetRemoteAddCredentials(pTHStls,
                                        wszNamingFsmoDns,
                                        &clientCreds);
        if(ulRet){
            Assert(pTHS->errCode);
            return(ulRet);
        }
    }
    ulRet = RemoteAddOneObjectSimply(wszNamingFsmoDns, 
                                     ((fRemoteNamingFsmo) ? &clientCreds : NULL),
                                     &entinflistCrossRef,
                                     &infoList );

    if(ulRet || pTHS->errCode){
        
        // We'll have the thread error (pTHS->errCode & pTHS->pErrInfo)
        // set from the RemoteAddOneObjectSimply() function
        Assert(pTHS->errCode == ulRet);
        Assert(pTHS->pErrInfo);

        if(pTHS->errCode == serviceError &&
           (pTHS->pErrInfo->SvcErr.extendedErr == ERROR_DUP_DOMAINNAME ||
            pTHS->pErrInfo->SvcErr.extendedErr == ERROR_DS_CROSS_REF_EXISTS)
           ){

            // This means the cross-ref that we tried to create, conflicted
            // with an existing pre-created (as opposed to auto-created)
            // crossref, that hasn't yet replicated to this machine yet.  So
            // we'll clear the errors and pretend that we auto created the 
            // cross-ref and replicate it in.
            ulRet = 0;
            THClearErrors();

        } else if (pTHS->errCode == referralError){

            // We've got a referral, so we can pretend we knew the right DC
            // to goto anyway, and just go to that DC now.
            if (pTHS->pErrInfo && 
                pTHS->pErrInfo->RefErr.Refer.pDAL &&
                pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Buffer) {

                wszNamingFsmoDns = THAllocEx(pTHS, 
                        pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Length + sizeof(WCHAR));
                memcpy(wszNamingFsmoDns,
                       pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Buffer,
                       pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Length);
                if(fRemoteNamingFsmo){                 
                    FreeRemoteAddCredentials(&clientCreds);
                }
                // Don't know if we've got a remote naming FSMO, but just to
                // be safe, we'll specify to pretend it's remote.
                fRemoteNamingFsmo = TRUE;
                THClearErrors();
                goto retry;
            } else {

                Assert(!"Something wrong with the thread referral error state.");
                Assert(pTHS->errCode);
                if(fRemoteNamingFsmo){                 
                    FreeRemoteAddCredentials(&clientCreds);
                }
                // Don't THClearErrors(), the thread error state is invalid 
                // anyway, this means there is a bug in RemoteAddOneObjectSimply()
                // or IDL_DRSAddEntry() or one of the thread error setting
                // routines called by those functions.  Anyway, to recover
                // just set a fresh error, which will whack the existing thread
                // error and replace it.
                SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
                return(pTHS->errCode);
            }
            
        } else {

            // We've got a real error, so lets make sure an error is set
            // or set one and bail.

            if(!pTHS->errCode){
                Assert(!"If the RemoteAddOneObjectSimply() returned w/o setting the thread state error, that should be fixed.");
                SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE, 
                              DS_ERR_DRA_INTERNAL_ERROR, 
                              ulRet);
            }

            if(fRemoteNamingFsmo){                 
                FreeRemoteAddCredentials(&clientCreds);
            }

            Assert(pTHS->errCode);
            return(pTHS->errCode);

        }
    }

    if(fRemoteNamingFsmo){
        FreeRemoteAddCredentials(&clientCreds);
    }

    // Make sure the DS didn't decide to shutdown on us while we were gone.
    if (eServiceShutdown) {
        return(ErrorOnShutdown());
    }

    //
    // Replicate the Cross-Ref back to this server.
    //
     
    if(fRemoteNamingFsmo){
        // Only need to replicate if we aren't the Naming FSMO.
        ulRet = ReplicateCrossRefBack(entinflistCrossRef.Entinf.pName, 
                                      wszNamingFsmoDns);
        if(ulRet){
            // ReplicateCrossRefBack() doesn't set the thread error.
            SetSvcError(SV_PROBLEM_UNAVAILABLE,
                        ulRet);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }
    }

    // Make sure the DS didn't decide to shutdown on us while we were gone.
    if (eServiceShutdown) {
        return(ErrorOnShutdown());
    }

    return(pTHS->errCode);
}

DWORD
ValidateDomainDnsName(
    THSTATE *       pTHS,
    DSNAME *        pdnName
    )
{                    
    ATTRBLOCK *     pObjB;
    ULONG           i; 
    ULONG           ulErr;

    Assert(pdnName);
    Assert(pTHS && pTHS->errCode == ERROR_SUCCESS);

    ulErr = DSNameToBlockName(pTHS, pdnName, &pObjB, DN2BN_LOWER_CASE);
    if(ulErr){
        SetNamError(NA_PROBLEM_NAMING_VIOLATION, pdnName, ulErr);
    }

    for(i = 0; i < pObjB->attrCount && pTHS->errCode == ERROR_SUCCESS; i++){
        if(pObjB->pAttr[i].attrTyp != ATT_DOMAIN_COMPONENT){
            return SetNamError(NA_PROBLEM_NAMING_VIOLATION, pdnName,
                               DIRERR_BAD_ATT_SYNTAX);
        }
    }
    FreeBlockName(pObjB);

    return(pTHS->errCode);
}

DWORD
AddNCPreProcess(
    THSTATE *       pTHS,
    ADDARG *        pAddArg,
    ADDRES *        pAddRes
    )
{
    SYNTAX_INTEGER  iType;
    ATTR *          pAttrs = pAddArg->AttrBlock.pAttr; // Speed hack.
    ULONG           i, j;
    CLASSCACHE *    pCC;
    ULONG           oclass;
    ATTR *          pObjectClass = NULL;

    ADDARG *        pAddArgCopy = NULL;
    THSTATE *       pSaveTHS;
    ADDRES *        pSpareAddRes; // spare add res.
    COMMARG         CommArg; // Need this for the FindExactCrossRef() func.
    GUID            NcGuid = {0,0,0,0};
    CROSS_REF *     pCR = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    VOID *          pBuf = NULL;
    DWORD           dwSavedErrCode = 0;
    DIRERR *        pSavedErrInfo = NULL;


    DPRINT(2,"AddNCPreProcess() entered\n");

    Assert(VALID_THSTATE(pTHS));
    Assert(pAddArg);
    Assert(pAddRes);

    //
    // First, determine if this is and NC Head at all.
    //

    Assert(!pAddArg->pCreateNC);

    for(i=0; i< pAddArg->AttrBlock.attrCount; i++) {

        switch(pAttrs[i].attrTyp){
        
        case ATT_INSTANCE_TYPE:
            if(pAttrs[i].AttrVal.valCount == 1 &&
               pAttrs[i].AttrVal.pAVal->valLen == sizeof(SYNTAX_INTEGER) &&
               !(pAddArg->pCreateNC)){
               iType = * (SYNTAX_INTEGER *) pAttrs[i].AttrVal.pAVal->pVal;
               if(iType & IT_NC_HEAD) {
                   if(pTHS->fDRA || (iType & IT_WRITE)) {
                       pAddArg->pCreateNC = THAllocEx(pTHS, sizeof(CREATENCINFO));
                       break;
                   } else {
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     DIRERR_ADD_REPLICA_INHIBITED,
                                     iType);
                       Assert(pTHS->errCode);
                       return(pTHS->errCode);
                   }
               } else {  
                   // Not an NC, no more processing needed.
                   DPRINT(2,"AddNCPreProcess() is not processing a NC head, returning early.\n");
                   return(ERROR_SUCCESS);
               }
            }
            break;

        case ATT_OBJECT_CLASS:
            pObjectClass = &pAttrs[i];
            break;

        default:
            // Do nothing.
            break;

        } // End switch attribute type.

    } // End for each attribute.
    
    if(pAddArg->pCreateNC == NULL){
        // Instance type found to be a the usual case (internal ref), so bail out
        // now.
        DPRINT(2,"AddNCPreProcess() is not processing a NC head, returning early.\n");
        return(ERROR_SUCCESS);
    }

    //
    // We're adding an NC Head, setup the NcHeadInfo struct.
    //
    
    DPRINT(2, "AddNCPreProcess() is processing an NC Head add.\n");

    // else we have an NC Head of some sort, do further processing to
    // build up the CREATENCINFO structure in pAddArg.

    if(!pObjectClass){    
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    DIRERR_OBJECT_CLASS_REQUIRED);
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    
    for(i=0;i < pObjectClass->AttrVal.valCount; i++){
        Assert(sizeof(SYNTAX_INTEGER) == pObjectClass->AttrVal.pAVal[i].valLen);
        
        // Until each NC is standardized, we must change the behaviour of create
        // NC based on each type of NC we're creating.  A regular Non-Domain
        // Naming Context, a regular Domain Naming Context, or the special
        // Schema Naming Context, or the special Configuration Naming Context.
        switch(*(SYNTAX_INTEGER *)pObjectClass->AttrVal.pAVal[i].pVal){
        
        case CLASS_CONFIGURATION:
            // Creating a configuration NC.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);
            pAddArg->pCreateNC->iKind = CREATE_CONFIGURATION_NC;
            break;

        case CLASS_DMD:
            // Creating a schema NC.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);
            pAddArg->pCreateNC->iKind = CREATE_SCHEMA_NC;
            break;

        case CLASS_DOMAIN_DNS:
            // this is either a NDNC or a Domain.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);

            if(DsaIsInstalling()){
                pAddArg->pCreateNC->iKind = CREATE_DOMAIN_NC;
            } else {
                pAddArg->pCreateNC->iKind = CREATE_NONDOMAIN_NC;
            }
            break;
        case CLASS_ORGANIZATION:
            // mkdit.exe is creating the shipped dit (ntds.dit)
            if(DsaIsInstalling()){
                pAddArg->pCreateNC->iKind = CREATE_DOMAIN_NC;
            } else {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_BAD_INSTANCE_TYPE);
                Assert(pTHS->errCode);
                return(pTHS->errCode);
            }
            break;

        default:
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        DIRERR_BAD_INSTANCE_TYPE);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
            break;
        } // end switch on type of class
    } // end for each value

    Assert(VALID_CREATENCINFO(pAddArg->pCreateNC) && 
           "More than one NC Head type objectClass was defined!!\n");

    if(!fISADDNDNC(pAddArg->pCreateNC)){
        // For now the rest of this function only handles NDNCs, but the 
        // automatic cross-ref creation could be made to happen for the 
        // dcpromo code as well.
        return(ERROR_SUCCESS);
    }
                 
    if(ValidateDomainDnsName(pTHS, pAddArg->pObject)){
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    // See if we have the CrossRef for this NC?
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pAddArg->pObject, &CommArg);
    
    if(!pCR){

        // Darn, now we've got our work cut out for us, we'll have to
        //    
        //    1. Save and duplicate the Add/Res Args.
        //    2. Try a TestNDNCLocalAdd() to see if we should add the CR or not.
        //    3. If ( unexpected error in the LocalAdd )
        //    3a       error out,
        //       else 
        //    3b       abort transaction and continue.
        //    4. Remotely create the NC's CR object.
        //    5. Replicate it back to this server.
        //    6. Restart the transactions.
        //    7. FindExactCrossRef() again.
        //    8. Fall out and continue with the NC Head add operation.

        if(pTHS->transControl != TRANSACT_BEGIN_END){
            SetUpdError(UP_PROBLEM_AFFECTS_MULT_DSAS, 
                        DS_ERR_NO_CROSSREF_FOR_NC);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        // Step 1.
        pSpareAddRes = THAllocEx(pTHS, sizeof(ADDRES));
        pAddArgCopy = DeepCopyADDARG(pTHS, pAddArg, NULL);
        pAddArgCopy->pCreateNC->fTestAdd = TRUE;

        // BUGBUG Step 2 & 3 are yet to be completed, these are extra 
        // tests that would stop us from accidentally creating a CR
        // in cases where we could've know the LocalAdd would fail.

        // Step 2.
        Assert(VALID_THSTATE(pTHS));
        // Do stuff in DirAddEntry().
        // LocalAdd(pTHS, pAddArgCopy, pAddRes);

        // Step 3.
        //if(!pAddArgCopy->pCreateNC->fTestAdd){
        //
        //}
        
        // Step 3b
        Assert(!pTHS->fSAM);
        SyncTransEnd(pTHS, FALSE);
        SDP_LeaveAddAsReader();

        __try {

            // Step 4 & 5
            dwErr = GetCrossRefForNDNC(pTHS, pAddArg->pObject);
        
        // Step 6.
        } __finally {
            // Need to enter transaction before we set any errors and leave;
            if(!SDP_EnterAddAsReader()){
                Assert(eServiceShutdown);
                dwErr = ErrorOnShutdown();
            }
            Assert(!pTHS->fSAM);
            Assert(dwErr == 0 || pTHS->errCode);
            // SyncTransSet wacks the thread error state, so we're going
            // to save it and set it afterwards.
            dwSavedErrCode = pTHS->errCode;
            pSavedErrInfo = pTHS->pErrInfo;
            SyncTransSet(SYNC_WRITE);
        }

        // We needed to wait til we restarted the transaction to signal the
        // error and return, so that the transaction cleaning doesn't AV.
        
        if(dwErr != 0){
            pTHS->errCode = dwSavedErrCode;
            pTHS->pErrInfo = pSavedErrInfo;
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        // Step 7.
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        pCR = FindExactCrossRef(pAddArg->pObject, &CommArg);
        
        if(!pCR){

            // What the heck we should never be here, this means
            // that an error in creating and retrieving/replicating
            // back the cross ref didn't get percolated up
            
            // This assert can be re-enabled when the ReplicateCrossRefBack()
            // code is fixed up to replicate via the guid based DNS name.
            // BUGBUG Assert(!"We should never get to this state!\n");
            
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        
        }

    }

    // Step 8.
    // Now we should have the following:
    //    1) A Valid corresponding crossRef
    Assert(pCR);
    
    // First we want to take the ATT_MS_DS_SD_REFERENCE_DOMAIN
    // off the crossRef, and add it to the ????

    if(AddNDNCHeadCheck(pTHS, pCR, pAddArg)){
        // Error should have been set by AddNDNCHeadCheck()
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    if(pCR->pdnSDRefDom){
        // We've got a reference domain pre-set by the user, use that.
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        pAddArg->pCreateNC->pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg);
        pAddArg->pCreateNC->fSetRefDom = FALSE;
    } else {
        // Try to use a logical default for the reference domain.
        pAddArg->pCreateNC->pSDRefDomCR = GetDefaultSDRefDomCR(pAddArg->pObject);
        pAddArg->pCreateNC->fSetRefDom = TRUE;
    }

    if(pAddArg->pCreateNC->pSDRefDomCR == NULL ||
       pAddArg->pCreateNC->pSDRefDomCR->pNC->SidLen == 0){
        SetAttError(pAddArg->pObject, 
                    ATT_MS_DS_SD_REFERENCE_DOMAIN,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, 
                    NULL,
                    ERROR_DS_NO_REF_DOMAIN);
        return(pTHS->errCode);
    }

    Assert(pAddArg->pCreateNC->pSDRefDomCR)
    Assert(IsValidSid(&pAddArg->pCreateNC->pSDRefDomCR->pNC->Sid));

    // Put the NcGuid in the NC Head object ... this may or may not
    // be NULL.  If it is NULL, we'll get a GUID later for this object.
    pAddArg->pObject->Guid = pCR->pNC->Guid;
    if(fNullUuid(&pCR->pNC->Guid)){
        pAddArg->pCreateNC->fNullNcGuid = TRUE;
    }
    
    return(ERROR_SUCCESS);
}


BOOL
fIsNDNC(
    DSNAME *        pNC
    )
{
    CROSS_REF_LIST *pCRL = NULL;

    // gAnchor.pConfigDN & gAnchor.pDMD not defined during install, but we never
    // deal with NDNCs at install time.  Confusingly enough, config and schema
    // are not "NDNCs," although they're not domain NCs either.
    if(DsaIsInstalling() ||
       NameMatched(gAnchor.pConfigDN, pNC) ||
       NameMatched(gAnchor.pDMD, pNC)){
        return(FALSE);
    }
    
    for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
        if(NameMatched(pCRL->CR.pNC, pNC)){
            return fIsNDNCCR(&pCRL->CR);
        }
    }

    DPRINT1(0, "Failed to find CR for NC %ls.\n", pNC->StringName);

    return(FALSE);
}

BOOL
fIsNDNCCR(
    IN CROSS_REF * pCR
    )
{
    return // gAnchor.pConfigDN & gAnchor.pDMD not defined during install, but
           // we never deal with NDNCs at install time.
           !DsaIsInstalling()
           // Confusingly enough, config and schema are not "NDNCs," although
           // they're not domain NCs either.
           && !NameMatched(gAnchor.pConfigDN, pCR->pNC)
           && !NameMatched(gAnchor.pDMD, pCR->pNC)
           // But any other NTDS NC that is not a domain NC is an NDNC.
           && (pCR->flags & FLAG_CR_NTDS_NC)
           && !(pCR->flags & FLAG_CR_NTDS_DOMAIN);
}

ULONG 
ModifyCRForNDNC(
    THSTATE *       pTHS,
    DSNAME *        pDN,
    CREATENCINFO *  pCreateNC
    )
{
    MODIFYARG       ModArg;
    MODIFYRES       ModRes;
    ATTRVAL         pAttrVal[5];
    ATTRMODLIST     OtherMod[5];
    DWORD           dwCRFlags = 0;
    COMMARG         CommArg;
    CROSS_REF *     pCR;
    DSNAME *        pCRDN;
    BOOL            fDSASaved;
    WCHAR *         pwszArrStr[1];
    DS_NAME_RESULTW * pdsrDnsName = NULL;
    ULONG           ulRet;
    WCHAR *         wszDnsName = NULL;

    // Our modifications to the crossRef has to happen in two phases:
    //   A) first we'll do a straight modify to the crossRef to ENABLE 
    //      it, and get it all setup (set systemFlags, and Replicas).
    //   B) Then if necessary, we'll also post (add and delete) an 
    //      infrastructure update to update the GUID of the NCs.

    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pDN, &CommArg);
    Assert(pCR);
    
    // Modification 1
    // Make sure that the value of systemFlags is set correctly.
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
    ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModArg.FirstMod.AttrInf.AttrVal.pAVal = &pAttrVal[0];
    ModArg.FirstMod.AttrInf.AttrVal.pAVal[0].valLen = sizeof(dwCRFlags);
    ModArg.FirstMod.AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) &dwCRFlags;
    ModArg.FirstMod.pNextMod = &OtherMod[0];
    // The actual value of dwCRFlags is set below right after we get
    // the old value of the system flags and merge in the new stuff.
    
    // Modification 2
    // Remove the ENABLED = FALSE attribute.
    memset(&OtherMod, 0, sizeof(OtherMod));
    OtherMod[0].choice = AT_CHOICE_REMOVE_ATT;
    OtherMod[0].AttrInf.attrTyp = ATT_ENABLED;
    OtherMod[0].AttrInf.AttrVal.valCount = 0;
    OtherMod[0].pNextMod = &OtherMod[1]; 
    
    // Modification 3
    // Make this DSA a replica of the mSDS-NC-Replica-Locations attribute.
    OtherMod[1].choice = AT_CHOICE_ADD_ATT;
    OtherMod[1].AttrInf.attrTyp = ATT_MS_DS_NC_REPLICA_LOCATIONS;
    OtherMod[1].AttrInf.AttrVal.valCount = 1;
    OtherMod[1].AttrInf.AttrVal.pAVal = &pAttrVal[1];
    // Should make copy in the DSA DN.
    OtherMod[1].AttrInf.AttrVal.pAVal[0].valLen = gAnchor.pDSADN->structLen;
    OtherMod[1].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS,
                                                                    gAnchor.pDSADN->structLen);
    memcpy(OtherMod[1].AttrInf.AttrVal.pAVal[0].pVal, 
           gAnchor.pDSADN, 
           gAnchor.pDSADN->structLen);
    OtherMod[1].pNextMod = &OtherMod[2];
    
    // Modification 4
    // Set the dNSRoot properly.
    pwszArrStr[0] = pDN->StringName;
    ulRet = DsCrackNamesW(NULL,
                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                          DS_FQDN_1779_NAME,
                          DS_CANONICAL_NAME,
                          1,
                          pwszArrStr,
                          &pdsrDnsName);
    Assert(ulRet != ERROR_INVALID_PARAMETER);
    if(ulRet){
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    __try {
        Assert(pdsrDnsName);
        Assert(pdsrDnsName->cItems == 1);
        Assert(pdsrDnsName->rItems != NULL);
        if(pdsrDnsName->rItems[0].status != DS_NAME_NO_ERROR){
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pDN,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        Assert(pdsrDnsName->rItems[0].pDomain);

        wszDnsName = THAllocEx(pTHS, (wcslen(pdsrDnsName->rItems[0].pDomain) + 1) * 
                               sizeof(WCHAR));
        wcscpy(wszDnsName, pdsrDnsName->rItems[0].pDomain);
        OtherMod[2].choice = AT_CHOICE_REPLACE_ATT;
        OtherMod[2].AttrInf.attrTyp = ATT_DNS_ROOT;
        OtherMod[2].AttrInf.AttrVal.valCount = 1;
        OtherMod[2].AttrInf.AttrVal.pAVal = &pAttrVal[2];
        OtherMod[2].AttrInf.AttrVal.pAVal[0].valLen = wcslen(wszDnsName) * sizeof(WCHAR);
        OtherMod[2].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) wszDnsName;
        OtherMod[2].pNextMod = NULL;

    } __finally {
        DsFreeNameResultW(pdsrDnsName);
    }
        
    ModArg.count = 4;

    if(pCreateNC->fSetRefDom){
        Assert(pCreateNC->pSDRefDomCR);

        OtherMod[2].pNextMod = &OtherMod[3];

        // Modification 5
        // Set up the mS-DS-SD-Reference-Domain, if unspecified on the CR.
        OtherMod[3].choice = AT_CHOICE_ADD_ATT;
        OtherMod[3].AttrInf.attrTyp = ATT_MS_DS_SD_REFERENCE_DOMAIN;
        OtherMod[3].AttrInf.AttrVal.valCount = 1;
        OtherMod[3].AttrInf.AttrVal.pAVal = &pAttrVal[3];
        // Must copy in the DN, otherwise under just the right conditions we can 
        // corrupte the in memory cache.
        OtherMod[3].AttrInf.AttrVal.pAVal[0].valLen = pCreateNC->pSDRefDomCR->pNC->structLen;
        OtherMod[3].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS, 
                                                                        pCreateNC->pSDRefDomCR->pNC->structLen);
        memcpy(OtherMod[3].AttrInf.AttrVal.pAVal[0].pVal, 
               pCreateNC->pSDRefDomCR->pNC, 
               pCreateNC->pSDRefDomCR->pNC->structLen);
        OtherMod[3].pNextMod = NULL;
        
        ModArg.count = 5;
    }

    ModArg.pMetaDataVecRemote = NULL;
    pCRDN = THAllocEx(pTHS, pCR->pObj->structLen);
    memcpy(pCRDN, pCR->pObj, pCR->pObj->structLen);
    ModArg.pObject = pCRDN;
    InitCommarg(&ModArg.CommArg);
    
    fDSASaved = pTHS->fDSA;
    __try {
        
        
        if (DoNameRes(pTHS, 0, ModArg.pObject, &ModArg.CommArg,
                                   &ModRes.CommRes, &ModArg.pResObj)){
            // trouble we should never be here, there should have been a CR.
            Assert(!"The CR, should have already been checked for.\n");
            Assert(pTHS->errCode);
            __leave;
        }                                                             

            
        // If there was a Cross-Ref created, then security was not checked,
        // so now we will check if this paticular someone has permission to
        // modify the Cross-Ref object, if not the operation will fail as
        // a security error.
        pTHS->fDSA = FALSE;

        if(CheckModifySecurity(pTHS, &ModArg, NULL, NULL, NULL)){
            // There was a problem with security for modifying this object, we 
            // don't have permissions to complete this operation.
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        // Now that we've checked that we've permission to modify the
        // Cross-Ref, lets actually patch up the Cross-Ref locally, to
        // represent that this NC is instantiated and that this DC is
        // one of it's replicas.
        pTHS->fDSA = TRUE;

        if (DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &dwCRFlags,
                             sizeof(dwCRFlags), NULL)) {
            dwCRFlags = 0;
        }

        Assert(!(dwCRFlags & FLAG_CR_NTDS_DOMAIN));
        dwCRFlags |= FLAG_CR_NTDS_NC | FLAG_CR_NTDS_NOT_GC_REPLICATED;
        LocalModify(pTHS, &ModArg);
        if(pTHS->errCode){
            __leave;
        }

        // There is one final step, since the Domain Naming FSMO at the time
        // it created the CrossRef may not have know the GUID of the NC, we 
        // need to make an infrastructureUpdate that will update the nCName
        // attribute on the crossRef.
        if(pCreateNC->fNullNcGuid){
            Assert(!fNullUuid(&pDN->Guid));
            ForceChangeToCrossRef(pCRDN, pDN->StringName, &pDN->Guid, 0, NULL);
        }

    } __finally {
        pTHS->fDSA = fDSASaved;
    }


    return(pTHS->errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdnotify.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdnotify.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsctr.h>

// Core DSA headers.
#include <ntdsa.h>
#include <filtypes.h>
#include <scache.h>               // schema cache
#include <dbglobal.h>             // The header for the directory database
#include <mdglobal.h>             // MD global definition header
#include <mdlocal.h>              // MD local definition header
#include <dsatools.h>             // needed for output allocation
#include <samsrvp.h>              // to support CLEAN_FOR_RETURN()

// Logging headers.
#include "dsevent.h"              // header Audit\Alert logging
#include "mdcodes.h"              // header for error codes

// Assorted DSA headers.
#include "objids.h"               // Defines for selected classes and atts
#include "anchor.h"
#include "drautil.h"
#include "drserr.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "drsuapi.h"
#include "debug.h"                // standard debugging header
#include "dsconfig.h"             // Needed for default replication delays
#define DEBSUB "MDNOTIFY:"        // define the subsystem for debugging

#include <drancrep.h>
#include <fileno.h>
#define  FILENO FILENO_MDNOTIFY
#include <dsutil.h>                     // Tick time routines

extern SCHEMAPTR *CurrSchemaPtr;

/*
 * Data for DirNotify support
 */
// The source of hServer handles, only to be updated when a write lock is
// held on the MonitorList
ULONG ghDirWaitCur = 0;

// A reader/writer lock to control access to the Monitor List
RTL_RESOURCE        resDirNotify;

// Hash tables that form the Monitor list, one table for each type of
// notification request
#define DNT_MON_COUNT 256
#define DNT_MON_MASK (DNT_MON_COUNT - 1)
#define PDNT_MON_COUNT 256
#define PDNT_MON_MASK (PDNT_MON_COUNT - 1)
#define SUBTREE_MON_COUNT 256
#define SUBTREE_MON_MASK (SUBTREE_MON_COUNT - 1)
DirWaitHead *gpDntMon[DNT_MON_COUNT];
DirWaitHead *gpPdntMon[PDNT_MON_COUNT];
DirWaitHead *gpSubtreeMon[SUBTREE_MON_COUNT];

// The head of the global Notify Queue
DirNotifyItem * gpDirNotifyQueue = NULL;

// A critical section serializing all access to the Notify Queue.  Holders
// of the monitor list resource may claim this critical section, but not
// vice versa
CRITICAL_SECTION csDirNotifyQueue;

// An event that is triggered whenever new items are inserted into the
// notify queue
HANDLE hevDirNotifyQueue;

// A pair of variables used for serialization of removal of items from the
// monitor list, which also implies purging references from the notify queue.
// gpInUseWait points to the WaitList item that is currently being processed
// by the notify thread.  gfDeleteInUseWait is set by deregistration code to
// indicate to the notify thread that when it is done processing its current
// item (i.e., *gpInUseWait), it should free that item.  Both of these
// variables may only be written or read when csDirNotifyQueue is held.
DirWaitItem * volatile gpInUseWait = NULL;
volatile BOOL gfDeleteInUseWait = FALSE;
/*
 * end of DirNotify support
 */


/* PAUSE_FOR_BURST - wait this many seconds after noting a change in an NC
        before informing DSAs with replicas. We do this so that a
        burst of changes at the master will not cause a flood of update
        notifications. This value is set from the registry at startup
*/

int giDCFirstDsaNotifyOverride = -1;

/* PAUSE_FOR_REPL - wait this many seconds after notifying a DSA of a change
        in an NC before notifying another. We do this to give the first DSA a
        chance to get the changes before the next DSA attempts to do the same.
        This value is set from the registry at startup
*/

int giDCSubsequentDsaNotifyOverride = -1;

// Notify element.
// This list is shared between the ReplicaNotify API and the ReplNotifyThread.
// The elements on this list are fixed size.
// NC's to be notified are identified by NCDNT

typedef struct _ne {
    struct _ne *pneNext;
    ULONG ulNcdnt;          // NCDNT to notify
    DWORD dwNotifyTime;     // Time to send notification
    BOOL fUrgent;           // Notification was queued urgently
} NE;

/* pneHead - points to head of notification list.
*/
NE *pneHead = NULL;

// Internal list of DSA's to notify
// These elements are variable length.
// Appended are a number of MTX elements in one contiguous chunk.

typedef struct _mtxe {
        LIST_ENTRY  ListEntry;
        BOOL urgent;
        BOOL writable;
        UUID uuidDSA;
        MTX_ADDR mtxDSA;          // this must be the last field
                                  // this field is variable length
        } MTXE;

#define MTXE_SIZE( a ) FIELD_OFFSET( MTXE, mtxDSA )

/* csNotifyList - guards access to the notification list and to
   hReplNotifyThread. Only two routines access the notification list:

                NotifyReplicas - adds new entries to the list.

                ReplNotifyThread - removes items from the list and performs the
                        actual notification.

        this semaphore ensures they do not access the list at the same time.
*/
CRITICAL_SECTION csNotifyList;

/* hevEntriesInList - lets us know if there are entries in the list
   (signalled state) or if the list is empty (not-signalled state).
   It is atomatically reset whenever ReplNotifyThread falls through the
   WaitForSingleObject call, and set by NotifyReplicas (whenever it
   adds an entry to the notification list).
*/
HANDLE hevEntriesInList = 0;

/* hReplNotifyThread - Lets us know if the (one and only) ReplNotifyThread
   has been started yet. Once started the thread continues until shutdown,
   or at least it's supposed to.  If the value is NULL the thread hasn't
   been started.  If it's non-NULL then it's supposed to be a valid handle
   to the correct thread.  Its friend tidReplNotifyThread is filled in with
   the thread id at thread create time but is otherwise unused.  It's left
   as a global solely to help ease debugging.
   */
HANDLE  hReplNotifyThread = NULL;
DWORD   tidReplNotifyThread = 0;

#ifndef ARRAY_SIZE
#   define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif

void
ProcessNotifyEntry(
    IN NE * pne
    );

/* ReplNotifyThread - Waits for entries to appear in the notify list and then
*  sends notification messages to appropriate DSAs at appropriate time.
*
*  There is one notification thread in the DSA. It is created the first
*  time something is added to the notification list (by NotifyReplicas).
*/
unsigned __stdcall ReplNotifyThread(void * parm)
{
    ULONG   time;
    ULONG   ret;
    HANDLE  rgWaitHandles[] = {hevEntriesInList, hServDoneEvent};
    NE *    pne;

    // Users should not have to wait for this.  Even more, if we're so
    // busy that we can't spring a few cycles for this thread to run,
    // we don't *want* it to run, because all it's going to do is attract
    // more servers into bugging us for updates.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);

    time = (ULONG) INFINITE;     // Initially wait indefinitely

    while (!eServiceShutdown) {
        __try {   // Exception handler
            // Wait until there are new entries in the notification list, the
            // items in the list already are ready, or shutdown has been
            // initiated.
            WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles), rgWaitHandles,
                                   FALSE, time);
            if (eServiceShutdown) {
                __leave;
            }

            // Is it time to generate a notification?
            EnterCriticalSection(&csNotifyList);
            __try {
                pne = pneHead;

                if ((NULL != pneHead)
                    && (CompareTickTime( pneHead->dwNotifyTime,GetTickCount()) != 1)) {
                    // Dequeue this entry for processing.
                    pne = pneHead;
                    pneHead = pneHead->pneNext;
                }
                else {
                    // No entry to process now.
                    pne = NULL;
                }
            }
            __finally {
                LeaveCriticalSection(&csNotifyList);
            }

            if (eServiceShutdown) {
                __leave;
            }

            if (NULL != pne) {
                ProcessNotifyEntry(pne);
                DRAFREE(pne);
            }

            if (eServiceShutdown) {
                __leave;
            }

            // Set time to wait, either indefinitely if list is empty,
            // or until next item will be ready if list is non-empty.
            time = (ULONG) INFINITE;

            EnterCriticalSection(&csNotifyList);
            __try {
                if (pneHead != NULL) {
                    DWORD timeNow = GetTickCount();

                    if (CompareTickTime(pneHead->dwNotifyTime,timeNow) == 1) {
                        time = DifferenceTickTime( pneHead->dwNotifyTime,timeNow);
                    }
                    else {
                        time = 0;       // Ready now, so wait no longer
                    }

                    // Time is in milliseconds
                }
            }
            __finally {
                LeaveCriticalSection(&csNotifyList);
            }
        }
        __except (GetDraException((GetExceptionInformation()), &ret)) {
            // Exception handler just protects thread.
            ;
        }
    } /* while (!eServiceShutdown) */

    return 0;
}

DWORD
ResolveReplNotifyDelay(
     // this should change to an enum if we ever get more repl vals.
    BOOL             fFirstNotify,
    DWORD *          pdwDBVal
    )
{
    DWORD            dwReplNotifyDelay;

    // First the repl delay is given the default value, depending on its type.
    if(fFirstNotify){
        dwReplNotifyDelay = DEFAULT_DRA_START_PAUSE;
    } else {
        dwReplNotifyDelay = DEFAULT_DRA_INTERDSA_PAUSE;
    }

    // Next if a DB value existed, then we use the DB value instead.
    if(pdwDBVal){
        dwReplNotifyDelay = *pdwDBVal;
    }

    // Finally check the registry, for a machine specific override.
    if(fFirstNotify){
        if(giDCFirstDsaNotifyOverride != INVALID_REPL_NOTIFY_VALUE){
            dwReplNotifyDelay = giDCFirstDsaNotifyOverride;
        }
    } else {
        if(giDCSubsequentDsaNotifyOverride != INVALID_REPL_NOTIFY_VALUE){
            dwReplNotifyDelay = giDCSubsequentDsaNotifyOverride;
        }
    }

    return(dwReplNotifyDelay);
}

DWORD
GetReplNotifyDelayByNC(
    BOOL                 fFirstNotify,
    NAMING_CONTEXT *     pNC
    )
{
    CROSS_REF_LIST *     pCRL;

    // BUGBUG PERFORMANCE it would be faster to get these variables were
    // intersted in, onto gAnchor.pMasterNC variables, so we'd walk the
    // master NC list instead of the crossref list.
    for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
        if(NameMatched(pCRL->CR.pNC, pNC)){
            if(fFirstNotify){
                return(pCRL->CR.dwFirstNotifyDelay);
            } else {
                return(pCRL->CR.dwSubsequentNotifyDelay);
            }
        }
    }

    // Uh-oh we don't have a CR for this NC, this is must be for a CR of
    // a domain that was removed, and hasn't been removed on a GC yet.
    if(fFirstNotify){
        return(DEFAULT_DRA_START_PAUSE);
    } else {
        return(DEFAULT_DRA_INTERDSA_PAUSE);
    }
}

DWORD
GetFirstDelayByNCDNT(
    ULONG                  NCDNT
    )
{
    NAMING_CONTEXT_LIST *  pNCL;

    pNCL = FindNCLFromNCDNT(NCDNT, FALSE);

    if (pNCL != NULL) {
        return(GetReplNotifyDelayByNC(TRUE, pNCL->pNC));
    }

    Assert(!"Uh oh we don't have a NC for the provided DNT!!!\n");
    return(DEFAULT_DRA_START_PAUSE);
}

void
ProcessNotifyEntry(
    IN NE * pne
    )
/*++

Routine Description:

    Notify DSAs that replicate from us via RPC of changes in a given NC.

Arguments:

    pne (IN) - Describes NC, urgency, etc. associated with this notification.

Return Values:

    None.

--*/
{
    THSTATE *       pTHS;
    DSNAME *        pNC;
    REPLICA_LINK *  pDSARepsTo;
    DBPOS *         pDB;
    ULONG           len;
    ULONG           cbmtxe;
    LIST_ENTRY      MtxList, *pEntry;
    MTXE *          pmtxe;
    BOOL            fCommit;
    ULONG           bufSize=0;
    ATTCACHE *      pAttRepsTo;
    ATTCACHE *      pAttObjDistName;
    ULONG           ret;
    ULONG           ulSubseqReplNotifyPause;
    ULONG           RepsToIndex = 0;

    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    if (!pTHS) {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);
        //
        // PREFIX: This return will never be executed.  It is only here
        // to make PREFIX happy.
        //
        return;
    }
    pTHS->fIsValidLongRunningTask = TRUE;

    InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);

    __try {
        pAttRepsTo = SCGetAttById(pTHS, ATT_REPS_TO);
        pAttObjDistName = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);

        InitializeListHead(&MtxList);

        DBOpen(&pDB);
        __try {
            // Notify each of the DSAs keeping a replica. We
            // pause between each notification so we dont get
            // swamped by incoming replication requests.

            // Look at the repsto attribute on the NC prefix and notify
            // each DSA that has a replica.

            if (DBFindDNT(pDB, pne->ulNcdnt) ||
                !DBHasValues_AC(pDB, pAttRepsTo)) {
                __leave;
            }

            // Reconstruct DSNAME given NCDNT
            // Note, memory for pNC gets freed at end of loop
            if (ret = DBGetAttVal_AC(pDB, 1,
                                     pAttObjDistName,
                                     0, // alloc semantics
                                     0, &len,
                                     (UCHAR **)&pNC)) {
                DsaExcept(DSA_DB_EXCEPTION, ret, 0);
            }
            DPRINT2(2, "ReplNotifyThread: syncing DNT=0x%x, DS='%ws'!\n",
                    pne->ulNcdnt, pNC->StringName);

            // We can't just evaluate all the DSAs holding replicas
            // as we notify each, because we'd have the DB open too
            // long, so we build a list of the DSAs to notify.

            while (!DBGetAttVal_AC(pDB, ++RepsToIndex,
                                   pAttRepsTo,
                                   DBGETATTVAL_fREALLOC,
                                   bufSize, &len,
                                   (UCHAR **)&pDSARepsTo)) {
                bufSize = max(bufSize,len);

                VALIDATE_REPLICA_LINK_VERSION(pDSARepsTo);

                cbmtxe = MTXE_SIZE(pmtxe)
                         + MTX_TSIZE(RL_POTHERDRA(pDSARepsTo));

                // allocate memory for mtxe and save ptr in list
                pmtxe = THAllocEx(pTHS, cbmtxe);

                // copy in mtx
                memcpy(&(pmtxe->mtxDSA),
                       RL_POTHERDRA(pDSARepsTo),
                       pDSARepsTo->V1.cbOtherDra);
                pmtxe->writable = pDSARepsTo->V1.ulReplicaFlags & DRS_WRIT_REP;
                pmtxe->urgent = pne->fUrgent;
                pmtxe->uuidDSA = pDSARepsTo->V1.uuidDsaObj;
                InsertHeadList(&MtxList, &pmtxe->ListEntry);
            }

            if (bufSize) {
                THFreeEx(pTHS, pDSARepsTo);
                bufSize = 0;
            }

            //
            // Filter out DSAs whose ntdsDsa object doesn't exist
            // in the config container.
            // This is since otherwise I_DRSReplicaSync will fail & event will be logged
            // due to "No mutual auth."
            //
            for (pEntry = MtxList.Flink;
                 !eServiceShutdown && (pEntry != &MtxList);
                 pEntry = pEntry->Flink) {

                DSNAME  dsa;

                // reference entry
                pmtxe = CONTAINING_RECORD(pEntry, MTXE, ListEntry);

                // set dsname of dsa
                ZeroMemory(&dsa, sizeof(DSNAME));
                dsa.structLen = DSNameSizeFromLen(0);
                dsa.Guid = pmtxe->uuidDSA;

                Assert(!fNullUuid(&dsa.Guid));
                // try to find it
                ret = DBFindDSName(pDB, &dsa);

                if ( ret ) {
                    // didn't find it, rm from list & free.
                    pEntry = pEntry->Blink;
                    RemoveEntryList(&pmtxe->ListEntry);

                    // delete this one.
                    THFreeEx(pTHS, pmtxe);
                }
            }
        }
        __finally {
            DBClose(pDB, TRUE);
        }

        if (!IsListEmpty(&MtxList)) {
            // Having found all the DSAs, go through and notify them all

            ulSubseqReplNotifyPause = GetReplNotifyDelayByNC(FALSE, pNC);

            for (pEntry = MtxList.Flink;
                 !eServiceShutdown && (pEntry != &MtxList);
                 pEntry = pEntry->Flink) {

                LPWSTR pszServerName;

                // reference entry
                pmtxe = CONTAINING_RECORD(pEntry, MTXE, ListEntry);

                // get server name
                pszServerName = TransportAddrFromMtxAddrEx(&pmtxe->mtxDSA);

                ret = I_DRSReplicaSync(
                            pTHS,
                            pszServerName,
                            pNC,
                            NULL,
                            &gAnchor.pDSADN->Guid,
                            (   DRS_ASYNC_OP
                                | DRS_UPDATE_NOTIFICATION
                                | ( pmtxe->writable ? DRS_WRIT_REP : 0 )
                                | ( pmtxe->urgent ? DRS_SYNC_URGENT : 0 )
                            ) );
                DPRINT1(3,"I_DRSReplicaSync ret=0x%x\n", ret);

                if (eServiceShutdown) {
                    break;
                }

                if ((DRAERR_NoReplica == ret) || (DRAERR_BadNC == ret)) {
                    // The notified DSA does not source this NC from us;
                    // remove our Reps-To.
                    DirReplicaReferenceUpdate(
                        pNC,
                        pszServerName,
                        &pmtxe->uuidDSA,
                        DRS_ASYNC_OP | DRS_DEL_REF );
                }
                else if (ret) {
                    // Log notification failure.
                    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                                      DS_EVENT_SEV_BASIC,
                                      DIRLOG_DRA_NOTIFY_FAILED,
                                      szInsertSz(pmtxe->mtxDSA.mtx_name),
                                      szInsertWC(pNC->StringName),
                                      szInsertWin32Msg( ret ),
                                      NULL, NULL, NULL, NULL, NULL,
                                      sizeof( ret ),
                                      &ret );
                }

                pEntry = pEntry->Blink;
                RemoveEntryList(&pmtxe->ListEntry);
                THFreeEx(pTHS, pmtxe);
                THFreeEx(pTHS, pszServerName);

                WaitForSingleObject(hServDoneEvent,
                                    ulSubseqReplNotifyPause*1000);
            }

            THFreeEx(pTHS, pNC);
        }
    }
    __finally {
        InterlockedDecrement((ULONG *)&ulcActiveReplicationThreads);
        free_thread_state();
    }
}

/*
 Description:

    NotifyReplicas - The object ulNcdnt has been modified, decided if any replicas
    must be notified. We search for the objects NC prefix, and look to see
    if there are any replicas  and if there are we add the name of the
    NC prefix to the notification list.

    Note that this routine is no longer called directly.  Instead it is called by
    dbTransOut when a transaction has committed.

    pneHead points to a list of notification entries, sorted by increasing entry time.

 Arguments:

    ulNcdnt - NCDNT to be notified
    fUrgent - urgent replication requested

 Return Values:

*/
void APIENTRY NotifyReplicas(
                             ULONG ulNcdnt,
                             BOOL fUrgent
                             )
{
    DBPOS *pDB;
    UCHAR syntax;
    BOOL fFound;
    NE *pne, *pnePrev;
    USHORT cAVA;
    ATTCACHE *pAC;
    THSTATE *pTHS;

    DPRINT2(1,"Notifyreplicas, Ncdnt=0x%x, Urgent Flag = %d\n", ulNcdnt, fUrgent);

    DBOpen2(FALSE, &pDB);
    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    __try
    {
        if (DBFindDNT(pDB, ulNcdnt) ||
            !DBHasValues_AC(pDB, pAC)) {
            // Ok, NC has no replicas
            __leave;
        }

        // Insert entry in the list, if it is not already present
        // List is sorted by notifytime, but keyed uniquely on NCDNT
        // An item may be marked urgent or not
        // When promoting an existing non-urgent item, delete the item
        // and reinsert it at its new time.

        DPRINT(4, "Entering csNotifyList\n");
        EnterCriticalSection(&csNotifyList);

        __try {

            // Pass 1: look for existing entry.

            pnePrev = NULL;
            pne = pneHead;
            fFound=FALSE;
            while (pne != NULL) {
                if (pne->ulNcdnt == ulNcdnt) {
                    if ( (fUrgent) && (!pne->fUrgent) ) {
                        // Found non-urgent entry, delete it
                        if (pnePrev == NULL) {
                            pneHead = pne->pneNext;
                        } else {
                            pnePrev->pneNext = pne->pneNext;
                        }
                        DRAFREE(pne);
                        // entry is not found and will be readded
                    } else {
                        fFound = TRUE;
                    }
                    break;
                }
                pnePrev = pne;
                pne = pne->pneNext;
            }

            // Pass 2: Insert new entry in the ordered list (if not found)

            if (!fFound) {

                DWORD newNotifyTime;       // Time to send notification
                NE *pneNew;

                if (fUrgent) {
                    newNotifyTime = GetTickCount();  // now
                } else {
                    newNotifyTime = CalculateFutureTickTime( GetFirstDelayByNCDNT(ulNcdnt) * 1000 ); // convert to ms
                }

                // Find proper location in list
                // We are guaranteed an item with the ncdnt does not exist

                pnePrev = NULL;
                pne = pneHead;
                while (pne != NULL) {
                    if (CompareTickTime( newNotifyTime, pne->dwNotifyTime) == -1) {
                        break;
                    }
                    pnePrev = pne;
                    pne = pne->pneNext;
                }

                /* Allocate the Notify Element */

                pneNew = DRAMALLOCEX(sizeof(NE));

                /* Set up fixed part of NE */
                pneNew->pneNext = pne;
                pneNew->ulNcdnt = ulNcdnt;
                pneNew->dwNotifyTime = newNotifyTime;
                pneNew->fUrgent = fUrgent;

                // Insert item at proper point

                if (pnePrev == NULL) {
                    pneHead = pneNew;
                } else {
                    pnePrev->pneNext = pneNew;
                }

                // A new entry is present

                SetEvent(hevEntriesInList);

                if (NULL == hReplNotifyThread) {

                    // Start notify thread

                    hReplNotifyThread = (HANDLE)
                      _beginthreadex(NULL,
                                     0,
                                     ReplNotifyThread,
                                     NULL,
                                     0,
                                     &tidReplNotifyThread);
                }

            } // if (!fFound)
            DPRINT(4, "Leaving csNotifyList\n");
       }
       __finally {
            LeaveCriticalSection(&csNotifyList);
       }
    }
    __finally
    {
       DBClose(pDB, TRUE);
    }
}

/* MonitorList: Theory and Practice
 *
 * The data structure referred to as the Monitor List is, conceptually, an
 * unordered list of object notification requests.  Each (successful) call
 * to DirNotifyRegister adds an entry to the Monitor List, and each call to
 * DirNotifyUnRegister removes an entry.  We need to have the ability to
 * quickly find all ML items that refer to a specific DNT or PDNT, so
 * instead of a simple list we use the data structure that follows.
 *
 * There are two 256 element hash tables, one each for DNT and PDNT lookups.
 * Each hash table cell can be the start of an unordered linked list of
 * DirWaitHeads.  Each DirWaitHead is the start of a separate unordered
 * linked list of all the ML items referring to a specific DNT.
 *
 * A lookup therefore consists of hashing the DNT to find a hash table cell
 * (we simply take the low order byte of the DNT, relying on the fact DNTs
 * are uniformly distributed in these bits).  We then walk the list of
 * DirWaitHeads until either we find the one for the DNT of interest or the
 * list is exhausted.  If we found a DirWaitHead, then it has a pointer to
 * a linked list of all items that must be enumerated.
 */

/*++ AddToMonitorList
 *
 * INPUT:
 *   pItem    - pointer to a filled out monitor list item
 *   choice   - the choice argument from the register request
 * OUTPUT:
 *   phServer - filled in with an opaque handle that can later be used
 *              to remove the item from the monitor list
 * RETURN VALUE:
 *   0        - success
 *   non-0    - failure, with pTHStls->errCode set.
 */
ULONG
AddToMonitorList(DirWaitItem *pItem,
                 UCHAR choice,
                 DWORD *phServer)
{
    unsigned index;
    DirWaitHead * pHead, **ppHead;

    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));

    /* Obtain a write lock on the monitor list */
    RtlAcquireResourceExclusive(&resDirNotify, TRUE);
    __try {
        switch (choice) {
          case SE_CHOICE_BASE_ONLY:
            index = pItem->DNT & DNT_MON_MASK;
            ppHead = &gpDntMon[index];
            break;

          case SE_CHOICE_IMMED_CHLDRN:
            index = pItem->DNT & PDNT_MON_MASK;
            ppHead = &gpPdntMon[index];
            break;

          case SE_CHOICE_WHOLE_SUBTREE:
            index = pItem->DNT & SUBTREE_MON_MASK;
            ppHead = &gpSubtreeMon[index];
            break;

          default:
            SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                          DIRERR_UNKNOWN_OPERATION,
                          choice);
            __leave;
        }

        /* ppHead now points to the hash cell on whose list the head for the
         * item we want should be.  Walk the list to see if such a head exists.
         */
        pHead = *ppHead;
        while (pHead &&
               pHead->DNT != pItem->DNT) {
            ppHead = &pHead->pNext;
            pHead = pHead->pNext;
        }
        
        if (!pHead) {
            /* If no head was found (possibly because the hash cell was empty),
             * create a new head and insert it in the hash list, and then
             * put our item on the head as its only list element.  ppHead
             * points to the place where a pointer to this new head shouldn
             * go, either in a hash cell or in the last head on the chain's
             * pNext pointer field.
             */
            pHead = malloc(sizeof(DirWaitHead));
            if (!pHead) {
                SetSysErrorEx(ENOMEM,
                              ERROR_NOT_ENOUGH_MEMORY, sizeof(DirWaitHead));
                __leave;
            }
            pHead->DNT = pItem->DNT;
            pHead->pNext = NULL;
            pItem->pNextItem = NULL;
            pHead->pList = pItem;
            *ppHead = pHead;
        }
        else {
            /* There was already a head element present for this DNT, so
             * just hook our item in at the head of the item list.
             */
            Assert(pHead->DNT == pItem->DNT);
            pItem->pNextItem = pHead->pList;
            pHead->pList = pItem;
        }

        /* Allocate a new server operation handle */
        *phServer = pItem->hServer = ++ghDirWaitCur;

        INC(pcMonListSize);
        DPRINT2(2,
                "Registered type %d notification for object with DNT=0x%x\n",
                choice,
                pItem->DNT);
    }
    __finally {
        RtlReleaseResource(&resDirNotify);
    }
    return pTHStls->errCode;
}

/*++ FreeWaitItem
 *
 * Takes a pointer to a filled in WaitItem and frees it and all subsidiary
 * data structures.  Simply here for convenience sake to keep callers
 * from having to remember which fields must be freed separately.
 *
 * INPUT:
 *   pWaitItem - pointer to item to be freed
 */
void FreeWaitItem(DirWaitItem * pWaitItem)
{
    if (pWaitItem->pSel->AttrTypBlock.attrCount) {
        Assert(pWaitItem->pSel->AttrTypBlock.pAttr);
        free(pWaitItem->pSel->AttrTypBlock.pAttr);
    }
    free(pWaitItem->pSel);
    free(pWaitItem);
}

/*++ PurgeWaitItemFromNotifyQueue
 *
 * This routine walks the notify queue and removes all elements that
 * refer to the specified wait item.
 *
 * INPUT:
 *  pWaitItem - pointer to the item to be purged
 * RETURN VALUE:
 *  none
 */
void PurgeWaitItemFromNotifyQueue(DirWaitItem * pWaitItem)
{
    DirNotifyItem * pList, **ppList;

    EnterCriticalSection(&csDirNotifyQueue);

    ppList = &gpDirNotifyQueue;
    pList = gpDirNotifyQueue;
    while (pList) {
        if (pList->pWaitItem == pWaitItem) {
            /* This notify queue element refers to our wait item.  Kill it */
            *ppList = pList->pNext;
            free(pList);
            pList = *ppList;
            DEC(pcNotifyQSize);
        }
        else {
            /* Not the droids we're looking for.  Move on. */
            ppList = &pList->pNext;
            pList = pList->pNext;
        }
    }

    /*
     * We've now removed all traces of the wait item from the notify queue.
     * Before we can free the wait item, though, we have to check to see if
     * is in use by a notification that is currently being processed.  If so,
     * leave a polite reminder to the notify thread to free the item for us.
     * If not, free it ourselves.
     */
    if (gpInUseWait == pWaitItem) {
        /* The wait item is in use.  Request that it be killed. */
        gfDeleteInUseWait = TRUE;
    }
    else {
        /* No one else refers to the item.  Kill it. */
        FreeWaitItem(pWaitItem);
    }

    LeaveCriticalSection(&csDirNotifyQueue);
}

/*++ RemoveFromMonitorListAux
 *
 * This routine exhaustively searches all wait items attached to a single
 * hash table, searching for one with the specified hServer.  If such an
 * item is found it is freed.  If not, then a flag is returned indicating
 * that the other hash table should be searched.
 *
 * Note: Assumes that a write lock is held on the monitor list
 *
 * INPUT:
 *  hServer   - the handle of the item to remove
 *  pHashCell - pointer to a hash table base
 *  HashCount - count of cells in the hash table
 * RETURN VALUE:
 *  TRUE      - the item was not found
 *  FALSE     - the item was found and deleted
 */
ULONG
RemoveFromMonitorListAux(DWORD hServer,
                         DirWaitHead **pHashCell,
                         unsigned HashCount)
{
    unsigned       index;
    DirWaitHead  * pHead = NULL;
    DirWaitItem  * pItem, ** ppItem;
    BOOL           fContinue = TRUE;

    Assert((pHashCell == gpDntMon) || (pHashCell == gpPdntMon) || (pHashCell == gpSubtreeMon));

    /* For each cell in the hash table */
    for (index = 0; (index < HashCount) && fContinue; index++) {
        pHead = pHashCell[index];
        
        /* For each head on the chain */
        while (pHead) {
            pItem = pHead->pList;
            ppItem = &pHead->pList;

            /* For each item on the list, check the hServer */
            while (pItem &&
                   pItem->hServer != hServer) {
                ppItem = &pItem->pNextItem;
                pItem = pItem->pNextItem;
            }

            if (pItem) {
                Assert(pItem->hServer == hServer);
                /* we found our item, so suture it out of the list */
                *ppItem = pItem->pNextItem;

                /* set the loop termination conditions */
                pHead = NULL;
                fContinue = FALSE;
                
                DEC(pcMonListSize);

                PurgeWaitItemFromNotifyQueue(pItem);
            }
            else {
                /* our item wasn't on this head's list, so move on to
                 * the next head
                 */
                pHead = pHead->pNext;
            }
        }
    }

    return fContinue;
}

/*++ RemoveFromMonitorList
 *
 * This routine removes a monitor list entry, identified by hServer,
 * from the monitor list.
 *
 * INPUT:
 *   hServer - handle of item to be removed
 * RETURN VALUE:
 *   0       - success
 *   non-0   - item was not found
 */
ULONG
RemoveFromMonitorList(DWORD hServer)
/*
 * returns TRUE if item not found
 */
{
    BOOL fContinue;
    DirWaitHead ** pHashCell;

    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));
    RtlAcquireResourceExclusive(&resDirNotify, TRUE);

    /* Search the DNT table */
    fContinue = RemoveFromMonitorListAux(hServer,
                                         gpDntMon,
                                         DNT_MON_COUNT);

    /* If we didn't find it in the DNT table, search the PDNT table */
    if (fContinue) {
        fContinue = RemoveFromMonitorListAux(hServer,
                                             gpPdntMon,
                                             PDNT_MON_COUNT);

        /* If we didn't find it in the PDNT table, search the NCDNT table */
        if (fContinue) {
            fContinue = RemoveFromMonitorListAux(hServer,
                                                 gpSubtreeMon,
                                                 SUBTREE_MON_COUNT);
        }
    }

    RtlReleaseResource(&resDirNotify);

    return fContinue;
}

/*++ DirNotifyRegister
 *
 * Exported API that allows a caller to register for notifications on an
 * object (or to its children).  Notifications will be sent whenever the
 * object(s) are modified until a matched DirNotifyUnRegister call is made.
 *
 * INPUT:
 *   pSearchArg - details about the object(s) to be monitored
 *   pNotifyArg - details about how the notification is to be done
 * OUTPUT:
 *   ppNotifyRes - filled in with result details.
 * RETURN VALUE:
 *   0           - success
 *   non-0       - failure, details in pTHStls->errCode
 */
ULONG
DirNotifyRegister(
                  SEARCHARG *pSearchArg,
                  NOTIFYARG *pNotifyArg,
                  NOTIFYRES **ppNotifyRes
)
{
    THSTATE*     pTHS = pTHStls;
    NOTIFYRES   *pNotifyRes;
    ULONG        dwException, ulErrorCode, dsid;
    DWORD        dwNameResFlags = NAME_RES_QUERY_ONLY;
    PVOID        dwEA;
    DWORD        dnt;
    ULONG        err;
    ENTINFSEL   *pPermSel;
    DirWaitItem *pItem;
    PFILTER      pInternalFilter = NULL;
    DWORD        it;

    Assert(VALID_THSTATE(pTHS));
    __try {
        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            /* Allocate the results buffer. */
            *ppNotifyRes = pNotifyRes = THAllocEx(pTHS, sizeof(NOTIFYRES));

            // Turn the external filter into an internal one.  This also
            // simplifies the filter, so a TRUE filter will end up
            // looking TRUE, even if they did (!(!(objectclass=*)))
            // internalize and register the filter with the DBlayer

            if ((err = DBMakeFilterInternal(pTHS->pDB,
                                 pSearchArg->pFilter,
                                 &pInternalFilter)) != ERROR_SUCCESS)
            {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, err);
                __leave;
            }

            /* The resultant filter better be trivial. */
            if (pInternalFilter &&
                (pInternalFilter->pNextFilter ||
                 (pInternalFilter->choice != FILTER_CHOICE_ITEM) ||
                 (pInternalFilter->FilterTypes.Item.choice !=
                  FI_CHOICE_TRUE))) {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_NOTIFY_FILTER_TOO_COMPLEX);
                __leave;
            }

            if(pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
                dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;
            }

            err = DoNameRes(pTHS,
                            dwNameResFlags,
                            pSearchArg->pObject,
                            &pSearchArg->CommArg,
                            &pNotifyRes->CommRes,
                            &pSearchArg->pResObj);
            if (err) {
                __leave;
            }

            /* we've found the object, snag its DNT */
            dnt = pTHS->pDB->DNT;

            /* make a permanent heap copy of the selection */
            pPermSel = malloc(sizeof(ENTINFSEL));
            if (!pPermSel) {
                SetSysErrorEx(ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                              sizeof(ENTINFSEL));
                __leave;
            }
            *pPermSel = *(pSearchArg->pSelection);
            if (pPermSel->AttrTypBlock.attrCount) {
                Assert(pPermSel->AttrTypBlock.pAttr);
                Assert(pPermSel->attSel != EN_ATTSET_ALL);
                pPermSel->AttrTypBlock.pAttr =
                  malloc(pPermSel->AttrTypBlock.attrCount * sizeof(ATTR));
                if (!pPermSel->AttrTypBlock.pAttr) {
                    SetSysErrorEx(
                            ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                            (pPermSel->AttrTypBlock.attrCount * sizeof(ATTR)));
                    free(pPermSel);
                    __leave;
                }
                memcpy(pPermSel->AttrTypBlock.pAttr,
                       pSearchArg->pSelection->AttrTypBlock.pAttr,
                       pPermSel->AttrTypBlock.attrCount * sizeof(ATTR));
            }
            else {
                pPermSel->AttrTypBlock.pAttr = NULL;
            }
        
            /* create a wait item... */
            pItem = malloc(sizeof(DirWaitItem));
            if (!pItem) {
                if (pPermSel->AttrTypBlock.pAttr) {
                    free(pPermSel->AttrTypBlock.pAttr);
                }
                free(pPermSel);
                SetSysErrorEx(ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                              sizeof(DirWaitItem));
                __leave;
            }
            pItem->hClient = pNotifyArg->hClient;
            pItem->pfPrepareForImpersonate = pNotifyArg->pfPrepareForImpersonate;
            pItem->pfTransmitData = pNotifyArg->pfTransmitData;
            pItem->pfStopImpersonating = pNotifyArg->pfStopImpersonating;
            pItem->DNT = dnt;
            pItem->pSel = pPermSel;
            pItem->Svccntl = pSearchArg->CommArg.Svccntl;
            pItem->bOneNC = pSearchArg->bOneNC;

            /* ...and add it to the monitor list */
            if (AddToMonitorList(pItem,
                                 pSearchArg->choice,
                                 &pNotifyRes->hServer)) {
                /* it didn't work */
                Assert(pTHS->errCode);
                FreeWaitItem(pItem);
                __leave;
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN( pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pNotifyRes) {
        pNotifyRes->CommRes.errCode = pTHS->errCode;
        pNotifyRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

}

/*++ DirNotifyUnregister
 *
 * Requests that no more notifications be sent for a given monitor item
 *
 * INPUT:
 *   hServer - handle to the monitor item (originally returned in the
 *             NOTIFYRES passed back from the DirNotifyRegister call)
 * OUTPUT:
 *   ppNotifyRes - filled in with result details.
 * RETURN VALUE:
 *   0           - success
 *   non-0       - failure, details in pTHStls->errCode
 */
ULONG
DirNotifyUnRegister(
                    DWORD hServer,
                    NOTIFYRES **ppNotifyRes
)
{
    Assert(VALID_THSTATE(pTHStls));

    if (RemoveFromMonitorList(hServer)) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_UNKNOWN_OPERATION);
    }
    return pTHStls->errCode;
}

/*++ GetMonitorList
 *
 * Returns the list of monitor items for a specific DNT, from a single hash
 *
 * INPUT:
 *   DNT       - the DNT to search for
 *   pHashBase - the hash table to search in
 * RETURN VALUE
 *   NULL      - nothing found
 *   non-NULL  - a pointer to the head of a linked list of wait items
 */
DirWaitItem *
GetMonitorList(ULONG DNT,
               DirWaitHead **pHashBase,
               ULONG HashMask)
{
    DirWaitHead *pHead;

    Assert((pHashBase == gpDntMon) || (pHashBase == gpPdntMon) || (pHashBase == gpSubtreeMon));

    pHead = pHashBase[DNT & HashMask];

    while (pHead &&
           pHead->DNT != DNT) {
        pHead = pHead->pNext;
    }
    if (pHead) {
        Assert(pHead->DNT == DNT);
        return pHead->pList;
    }
    else {
        return NULL;
    }
}

/*++ AddToNotifyQueue
 *
 * This routine creates notify item from its arguments and inserts it
 * at the end of the notify queue.  Note that while we could have kept
 * a pointer to the last element in the queue and tacked on the entry
 * there, instead we walk the entire queue searching for duplicates
 * (entries for the same DNT and for the same wait item).  If a duplicate
 * is found, we junk the item we're adding, since it's already there.
 * The reasoning behind this is that there are two possiblities for
 * when the system is running, either the queue is short, and hence the
 * list traversal is cheap, or the queue is long, in which case the
 * duplicate removal is vital, to keep the notifier from becoming even
 * more backed up.
 *
 * INPUT:
 *   pWaitItem - pointer to the wait item to be added
 *   DNT       - DNT of the item being added
 * RETURN VALUE:
 *   none
 */
void
AddToNotifyQueue(DirWaitItem *pWaitItem,
                ULONG DNT
)
{
    DirNotifyItem * pNotifyItem;
    DirNotifyItem * pList, **ppList;

    /* Build the notify item */
    pNotifyItem = malloc(sizeof(DirNotifyItem));
    if (!pNotifyItem) {
        return;
    }
    pNotifyItem->pWaitItem = pWaitItem;
    pNotifyItem->DNT = DNT;
    pNotifyItem->pNext = NULL;

    EnterCriticalSection(&csDirNotifyQueue);
    __try {
        ppList = &gpDirNotifyQueue;
        pList = gpDirNotifyQueue;
        while (pList) {
            if ((pList->DNT == DNT) &&
                (pList->pWaitItem == pWaitItem)) {
                /* An identical entry is already in the (badly backed up!)
                 * queue, so just throw this one away.
                 */
                DPRINT1(3,"Discarding redundant notify for object 0x%x\n",DNT);
                free(pNotifyItem);
                __leave;
            }
            ppList = &(pList->pNext);
            pList = pList->pNext;
        }

        /* We got to the end of the queue without finding a duplicate,
         * so add this item to the end of the queue.  As always when
         * adding a new entry, signal the queue event.
         */
        *ppList = pNotifyItem;
        INC(pcNotifyQSize);
        SetEvent(hevDirNotifyQueue);
    }
    __finally {
        LeaveCriticalSection(&csDirNotifyQueue);
    }
}

void
NotifyWaitersPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++
    Called by the code that tracks modified objects when committing to
    transaction level 0.  We now walk that list and, for each object
    on it, see if anyone is monitoring updates.  If so, we add the appropriate
    entry(ies) to the notify queue.

    NOTE:  This code MUST NEVER CAUSE an exception.  We are called after we have
    committed to the DB, so if we can't manage to notify waiters, then they
    don't get notified.  But, there are other X...Y..PostProcess calls that MUST
    be called, so we can't cause an exception which would prevent them from
    being called.   Of course, it would be best if in addition to not excepting,
    we never fail.

    RETURN VALUE:
       none
--*/
{
    MODIFIED_OBJ_INFO *pTemp;
    unsigned     i;
    int          j;
    DirWaitItem *pItem;
    DWORD ThisDNT;

    if (eServiceShutdown) {
        return;
    }

    Assert(VALID_THSTATE(pTHS));

    if(!pTHS->JetCache.dataPtr->pModifiedObjects ||
       !fCommitted ||
       pTHS->transactionlevel > 0 ) {
        // Nothing changed, or not committing or committing to a non zero
        // transaction level.  Nothing to do.
        return;
    }

    // OK, we're committing to transaction level 0.  Go through all the DNTs
    // we've saved up for this transaction and notify the appropriate waiters.


    /* get a read lock on the monitor list */
    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));
    RtlAcquireResourceShared(&resDirNotify, TRUE);
    for(pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        pTemp;
        pTemp = pTemp->pNext) {

        for(i=0;
            i<pTemp->cItems;
            i++) {

            if(!pTemp->Objects[i].fNotifyWaiters) {
                // Although this object changed, we were told to ignore it.
                continue;
            }

            ThisDNT = pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-1];
            DPRINT3(5,
                    "Checking for clients monitoring DNT 0x%x, "
                    "NCDNT 0x%x.  Change type %d\n",
                    ThisDNT,
                    pTemp->Objects[i].ulNCDNT,
                    pTemp->Objects[i].fChangeType);

            if(pTemp->Objects[i].fChangeType != MODIFIED_OBJ_intrasite_move) {
                /* Get the list of people monitoring this object */
                // Note we don't do this for intrasite moves, just modifies.
                // For moves within a single NC, there will be two elements in
                // this linked list.  1 will be of type _modified, the other
                // will be for type _intrasite_move.  Lets not trigger two
                // notifications for the object if someone is monitoring the
                // DNT.
                // For moves out of this NC, there will only be one element in
                // the linked list.  It will be of type _intersite_move.  Thus
                // we will only do one notification for this if someone is
                // tracking the DNT.
                pItem = GetMonitorList(ThisDNT,
                                       gpDntMon,
                                       DNT_MON_MASK);
                /* Add each of them to the notify queue */
                while (pItem) {
                    DPRINT1(3,"Enqueueing notify for object 0x%x\n",
                            ThisDNT);
                    AddToNotifyQueue(pItem, ThisDNT);
                    pItem = pItem->pNextItem;
                }
            }


            // Get the list of people monitoring this object's parent's children
            // Note we do this regardless of the change type
            pItem = GetMonitorList(pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-2],
                                   gpPdntMon,
                                   PDNT_MON_MASK);
            /* Add each of them to the notify queue */
            while (pItem) {
                DPRINT2(3,"Enqueueing notify for object 0x%x, PDNT 0x%x\n",
                        ThisDNT,
                        pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-2]);
                AddToNotifyQueue(pItem, ThisDNT);
                pItem = pItem->pNextItem;
            }

            if(pTemp->Objects[i].fChangeType !=  MODIFIED_OBJ_intrasite_move) {
                // Get the list of people monitoring this object's naming
                // context.
                // Note we only do this for changes that are NOT moves within a
                // single NC.  This is because moves within a single NC result
                // in two elements in the linked list, one of type
                // intrasite_move, one of type _modified.  Let's not trigger two
                // notificiations in such cases.  Normal (non-move)
                // modifications result in only one element in the list of type
                // _modified.  Moves outside an NC result in only one element in
                // the list, and it is of type _intersite_move
                //
                j=pTemp->Objects[i].cAncestors;
                do {
                    --j;
                    pItem = GetMonitorList(pTemp->Objects[i].pAncestors[j],
                                           gpSubtreeMon,
                                           SUBTREE_MON_MASK);
                    /* Add each of them to the notify queue */
                    while (pItem) {
                        DPRINT2(3,"Enqueueing notify for object 0x%x, subtree 0x%x\n",
                                ThisDNT,
                                pTemp->Objects[i].pAncestors[j]);
                        AddToNotifyQueue(pItem, ThisDNT);
                        pItem = pItem->pNextItem;
                    }
                } while ((j > 1) &&
                         (pTemp->Objects[i].pAncestors[j] !=
                          pTemp->Objects[i].ulNCDNT));
            }
        }
    }
    RtlReleaseResource(&resDirNotify);
}

/*++ ProcessNotifyItem
 *
 * THis routine is called by the DirNotifyThread to process a single
 * NotifyQueue element.  The basic procedure is to find the object in
 * question, use a callback into head code to impersonate the client,
 * read the object, use another callback to transmit the results to
 * the client, and then use a third callback to de-impersontate.
 *
 * PERFHINT: This cries out for reuse of thread states.
 *
 * INPUT:
 *   pNotifyItem - the notify queue element to be processed
 */
void
ProcessNotifyItem(DirNotifyItem * pNotifyItem)
{
    THSTATE * pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    DirWaitItem * pWaitItem = pNotifyItem->pWaitItem;
    void * pClientCrap = NULL;
    DWORD err;
    ENTINF entinf;
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ULONG it;

    if (!pTHS) {
        return;
    }
    __try {
        SYNC_TRANS_READ();
        __try {
            /* Find the object */
            err = DBFindDNT(pTHS->pDB, pNotifyItem->DNT);
            if (err) {
                // If we were triggered because of an intersite_move (i.e.
                // moving an object to another NC), the DBFindDNT will
                // fail because the process of moving the object has left it
                // temporarily (on a GC) or permanantly (on non-GCs) a phantom.
                // There's not much we can do in this case, because the object
                // no longer exists on this server (not even as a tombstone!)
                // and we can't read it to send back a notification.  There
                // is no mechanism defined to allow us to chain to a DC in
                // another domain to read the object and return data from there,
                // so the unfortunate outcome is that interdomain moves cause
                // objects to vanish silently, with no notification.
                LogUnhandledErrorAnonymous(err);
                __leave;
            }

            if (pNotifyItem->pWaitItem->bOneNC &&
                pNotifyItem->DNT != pNotifyItem->pWaitItem->DNT) {
                /* We're doing a single NC wait, and the item that triggered
                 * is not the same as the item being waited on, which means
                 * that we're doing a subtree search of somesort.  We need
                 * to verify that the triggering object is in the same NC
                 * as the base object.  Since we only support base and
                 * immediate children notifies right now, the only way this
                 * could not be is if the triggering item is an NC head.
                 */
                if (DBGetSingleValue(pTHS->pDB,
                                     ATT_INSTANCE_TYPE,
                                     &it,
                                     sizeof(it),
                                     NULL)
                    || (it & IT_NC_HEAD)) {
                    /* Either we can't read the instance type or it
                     * says that this is an NC head, and therefore not
                     * in the NC we want.
                     */
                    err = DSID(FILENO, __LINE__);
                    __leave;
                }
            }

            if (!((*pWaitItem->pfPrepareForImpersonate)(pWaitItem->hClient,
                                                        pWaitItem->hServer,
                                                        &pClientCrap))) {
                /* The impersonation setup failed, we have nothing to do */
                err = DSID(FILENO, __LINE__);
                __leave;
            }

            if(IsObjVisibleBySecurity(pTHS, FALSE)) {
                /* Get the SD off the object (needed for GetEntInf) */
                if (DBGetAttVal(pTHS->pDB,
                                1,
                                ATT_NT_SECURITY_DESCRIPTOR,
                                0,
                                0,
                                &ulLen,
                                (PUCHAR *)&pSec))
                    {
                        // Every object should have an SD.
                        Assert(!DBCheckObj(pTHS->pDB));
                        ulLen = 0;
                        pSec = NULL;
                    }

                /* Get the data, using the client's security context */
                err = GetEntInf(pTHS->pDB,
                                pWaitItem->pSel,
                                NULL,
                                &entinf,
                                NULL,
                                pWaitItem->Svccntl.SecurityDescriptorFlags,
                                pSec,
                                0,          // flags
                                NULL,
                                NULL);
            }
            else {
                err = DSID(FILENO, __LINE__);
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        /* If we got something, send it away */
        if ((0 == err) && (!eServiceShutdown)) {
            DPRINT3(4,"Transmitting notify for (%x,%x) %S\n",
                    pWaitItem->hClient,
                    pWaitItem->hServer,
                    entinf.pName->StringName);
            (*pWaitItem->pfTransmitData)(pWaitItem->hClient,
                                         pWaitItem->hServer,
                                         &entinf);
        }

        /* Go back to being ourself */
        (*pWaitItem->pfStopImpersonating)(pWaitItem->hClient,
                                          pWaitItem->hServer,
                                          pClientCrap);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    free_thread_state();
}

/*++ DirNotifyThread
 *
 * This routine is a long-lived thread in the DSA.  It loops forever,
 * pulling the first item off of the Notify Queue and processing it.
 * If no more items are available it sleeps, waiting for some to appear
 * or for the process to shut down.
 */
ULONG DirNotifyThread(void * parm)
{
    HANDLE ahEvents[2];
    DirNotifyItem * pNotifyItem;

    ahEvents[0] = hevDirNotifyQueue;
    ahEvents[1] = hServDoneEvent;

    // Users should not have to wait for this.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    do {
        EnterCriticalSection(&csDirNotifyQueue);
      PluckNextFromQueue:
        pNotifyItem = gpDirNotifyQueue;
        if (gpDirNotifyQueue) {
            /* Advance the queue one step */
            gpDirNotifyQueue = gpDirNotifyQueue->pNext;
            /* Mark the item we're processing */
            gpInUseWait = pNotifyItem->pWaitItem;
            DEC(pcNotifyQSize);
        }
        LeaveCriticalSection(&csDirNotifyQueue);

        // exit the loop if we are shutting down or going into single user mode
        if (eServiceShutdown || DsaIsSingleUserMode()) {
            break;
        }

        if (!pNotifyItem) {
            /* nothing to process */
            goto Sleep;
        }

        ProcessNotifyItem(pNotifyItem);

        if (eServiceShutdown) {
            continue;
        }

        free(pNotifyItem);

        EnterCriticalSection(&csDirNotifyQueue);
        if (gfDeleteInUseWait) {
            /* the wait item we were using has been removed from the wait
             * lists and should be deleted now that we're done with it
             */
            FreeWaitItem(gpInUseWait);
            gfDeleteInUseWait = FALSE;
        }
        gpInUseWait = NULL;
        goto PluckNextFromQueue;

      Sleep:
        if (!eServiceShutdown) {
            WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);
        }
    } while (!eServiceShutdown);

    return 0;
}

/*++ DirPrepareForImpersonate
 *
 * Helper routine for threads beginning the processing a a notification.
 * It sets fDSA and keeps track of its previous value in malloc'ed memory.
 */
BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        )
{
    BOOL *pfDSA=NULL;
    THSTATE *pTHS = pTHStls;

    pfDSA = (BOOL *)malloc(sizeof(BOOL));
    if(!pfDSA) {
        return FALSE;
    }

    *pfDSA = pTHS->fDSA;
    pTHS->fDSA = TRUE;
    *ppImpersonateData = pfDSA;

    return TRUE;
}

/*++ DirStopImpersonating
 *
 * Helper routine for threads ending the processing of a notification.
 * It sets fDSA back to its previous value and frees the memory allocated
 * to hold the previous value.
 */
VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        )
{
    BOOL *pfDSA = (BOOL *)pImpersonateData;
    THSTATE *pTHS = pTHStls;

    if(!pfDSA) {
        return;
    }

    pTHS->fDSA = *pfDSA;
    free(pfDSA);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdmoddn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdmoddn.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains routines for changing an object's DN prefix, a.k.a.
    moving an object. These routines implement DirModifyDN.

    An object can be moved within an NC, across NC boundaries, or across
    domain boundaries (which means moving it across machine boundaries in
    the first version of the product, since there is one DSA per machine).

Author:

    Exchange DS Team

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    04-Jun-97
        Added routines for cross-NC and cross-domain moves.
    ChrisMay    16-May-97
        Changes per code review: changed local-move vs remote-move detection
        logic, added service control flag, clean up, more attribute fix-up
        routines.
    ChrisMay    18-Jun-97
        Changes per code review, enabled inter-domain move if the target DSA
        name is different from DSA originating the move, bug fixes, added the
        proxy-object-name attribute, added routine to free readres memory.
    ChrisMay    07-Oct-97
        Collapsed separate phantom and proxy transactions into one transact-
        ion.

--*/



#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA Headers

#include <ntdsa.h>
#include <scache.h>     // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>       // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>       // needed for output allocation
#include <samsrvp.h>            // to support CLEAN_FOR_RETURN()
#include <drsuapi.h>            // I_DRSInterDomainMove
#include <ntdsctr.h>

// SAM Interoperability Headers

#include <mappings.h>

// Logging Headers
#include <dstrace.h>
#include "dsevent.h"        // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"        // header for error codes

// Assorted DSA Headers

#include "objids.h"             // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include <permit.h>             // permission constants
#include "debug.h"      // standard debugging header
#include "drameta.h"
#include <sdconvrt.h>           // SampGetDefaultSecurityDescriptorForClass
#include <dsjet.h>
#include <dbintrnl.h>
#include <sdprop.h>             // SD Propagator routines
#include <drserr.h>
#include <dsconfig.h>

#include "sspi.h"               // credential handling support
#include "kerberos.h"           // MICROSOFT_KERBEROS_NAME_A
#include "sddl.h"               // Convert*SecurityDescriptor
#include "lmaccess.h"           // UF_* constants
#include <xdommove.h>

#define DEBSUB "MDMODDN:"       // define the subsystem for debugging
#include <fileno.h>
#define  FILENO FILENO_MDMODDN

// Macros And Constants

#define DEBUG_BUF_SIZE          256

// PADDING is added to dynamically allocated DSNAME buffers to accommodate
// any extra bytes that are added during the construction of a DN (such as
// commas, "CN=", etc. by functions such as AppendRDN.

#define PADDING                 32
#define MAX_MACHINE_NAME_LENGTH (MAX_COMPUTERNAME_LENGTH + 3)

// External Functions

extern ULONG AcquireRidFsmoLock(DSNAME *pDomainDN, int msToWait);
extern VOID  ReleaseRidFsmoLock(DSNAME *pDomainDN);
extern BOOL  IsRidFsmoLockHeldByMe();

// Internal Functions

ULONG
DirModifyDNWithinDomain(
    IN MODIFYDNARG*  pModifyDNArg,
    IN MODIFYDNRES** ppModifyDNRes
    );

ULONG
DirModifyDNAcrossDomain(
    IN  MODIFYDNARG* pModifyDNArg,
    OUT MODIFYDNRES** ppModifyDNRes
    );

int 
CheckForSchemaRenameAllowed(
    THSTATE *pTHS
    );

extern const GUID INFRASTRUCTURE_OBJECT_GUID;


//============================================================================
//
//                      DN Modification (a.k.a. Move Object)
//
//============================================================================

ULONG
DirModifyDN(
    IN  MODIFYDNARG* pModifyDNArg,
    OUT MODIFYDNRES** ppModifyDNRes
    )

/*++

Routine Description:

    This routine is the server-side entry point for moving an object, a.k.a.
    modify DN.

    If the incoming pModifyDNArg does not specify a destination DSA inside
    the pModifyDNArg parameter (i.e. NULL value), it is assumed that this
    is an intra-NC move, and LocalModifyDN is invoked.  Otherwise it is
    assumed to be a cross domain move.

Arguments:

    pModifyDNArg - Pointer, structure containing the source object name,
        the new parent name, and the object's attributes.

    ppModifyDNRes - Pointer, outcome results, if the move failed for any
        reason, the error information is contained in this structure.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    if (eServiceShutdown) {
        return(ErrorOnShutdown());
    }

    if ( !pModifyDNArg->pDSAName )
    {
        return(DirModifyDNWithinDomain(pModifyDNArg, ppModifyDNRes));
    }

    return(DirModifyDNAcrossDomain(pModifyDNArg, ppModifyDNRes));
}

//============================================================================
//
//                  DN Modification Across Domain Boundaries
//
//============================================================================

#if DBG

VOID
FpoSanityCheck(
    THSTATE *pTHS,
    ATTR    *pAttr)

/*++

  Routine Description:

    According to MurliS, universal groups may not have FPOs as members.
    We only get here if we're moving a universal group.  Test the claim.

  Arguments:

    pTHS - THSTATE pointer.

    pAttr - ATTR representing the membership.

  Return Values:

    TRUE on success, FALSE otherwise
    
--*/

{
    DWORD   i;
    DSNAME  *pMember;
    ATTRTYP class;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(ATT_MEMBER == pAttr->attrTyp);

    for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
    {
        pMember = (DSNAME *) pAttr->AttrVal.pAVal[i].pVal;

        if (    !DBFindDSName(pTHS->pDB, pMember)
             && !DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS, &class,
                                  sizeof(class), NULL) )
        {
             Assert(CLASS_FOREIGN_SECURITY_PRINCIPAL != class);
        }
    }
}

#endif

ULONG
VerifyObjectForMove(
    THSTATE     *pTHS,
    READRES     *pReadRes,
    DSNAME      *pNewName,
    DSNAME      **ppSourceNC,
    DSNAME      **ppExpectedTargetNC,
    CLASSCACHE  **ppCC
    )

/*++

Routine Description:

    Verify that an object is a legal cross domain move candidate.

Arguments:

    pReadRes - Pointer to READRES which contains ALL the object's attrs.

    pNewName - Pointer to DSNAME for desired new name in remote domain.

    ppSourceNC - Updated on success with pointer to DSNAME of source object NC.

    ppExpectedTargetNC - Updated on success with pointer to DSNAME of
        expected NC pNewName will go in.  Used to sanity check knowledge
        information with the destination.

        ppCC - Updated on success with pointer to object's CLASSCACHE entry.

Return Value:

    pTHS->errCode

--*/

{
    ULONG                   i, j;
    ATTR                    *pAttr;
    CLASSCACHE              *pCC = NULL;            //initialized to avoid C4701
    DWORD                   dwTmp;
    BOOL                    boolTmp;
    NT4SID                  domSid;
    ULONG                   objectRid;
    ULONG                   primaryGroupRid = 0;    // 0 == invalid RID value
    DWORD                   groupType = 0;
    DWORD                   cMembers = 0;
    ATTR                    *pMembers = NULL;
    NT4SID                  tmpSid;
    DWORD                   tmpRid;
    COMMARG                 commArg;
    CROSS_REF               *pOldCR;
    CROSS_REF               *pNewCR;
    ULONG                   iSamClass;
    BOOL                    fSidFound = FALSE;
    NTSTATUS                status;
    ULONG                   cMemberships;
    PDSNAME                 *rpMemberships;
    ATTCACHE                *pAC;
    ULONG                   len;
    SYNTAX_DISTNAME_BINARY  *puc;
    DWORD                   flagsRequired;

    // SAM reverse membership check requires an open transaction.
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    *ppSourceNC = NULL;
    *ppExpectedTargetNC = NULL;
    *ppCC = NULL;

    // Perform sanity checks against various attributes.

    for ( i = 0; i < pReadRes->entry.AttrBlock.attrCount; i++ )
    {
        pAttr = &pReadRes->entry.AttrBlock.pAttr[i];

        switch ( pAttr->attrTyp )
        {
        case ATT_OBJECT_CLASS:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (   (NULL == (pCC = SCGetClassById(pTHS, dwTmp)))
                 || pCC->bDefunct)
            {
                return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                    DIRERR_OBJ_CLASS_NOT_DEFINED));
            }
            else if ( pCC->bSystemOnly )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOD_SYSTEM_ONLY));
            }

            *ppCC = pCC;

            // Disallow move of selected object classes.  The same object
            // may have failed on another test later on, but this is a
            // convenient and easy place to catch some obvious candidates.

            for ( j = 0; j < pAttr->AttrVal.valCount; j++ )
            {
                Assert(sizeof(DWORD) == pAttr->AttrVal.pAVal[j].valLen);
                switch ( * (DWORD *) pAttr->AttrVal.pAVal[j].pVal )
                {
                // Keep following list alphabetical.
                case CLASS_ADDRESS_BOOK_CONTAINER:
                case CLASS_ATTRIBUTE_SCHEMA:
                case CLASS_BUILTIN_DOMAIN:
                case CLASS_CERTIFICATION_AUTHORITY:         // Trevor Freeman
                case CLASS_CLASS_SCHEMA:
                case CLASS_CONFIGURATION:
                case CLASS_CRL_DISTRIBUTION_POINT:          // Trevor Freeman
                case CLASS_CROSS_REF:
                case CLASS_CROSS_REF_CONTAINER:
                case CLASS_DMD:
                case CLASS_DOMAIN:
                case CLASS_DSA:
                case CLASS_FOREIGN_SECURITY_PRINCIPAL:
                // Following covers phantom update objects as well as
                // proxies for cross domain moves.
                case CLASS_INFRASTRUCTURE_UPDATE:
                case CLASS_LINK_TRACK_OBJECT_MOVE_TABLE:
                case CLASS_LINK_TRACK_OMT_ENTRY:
                case CLASS_LINK_TRACK_VOL_ENTRY:
                case CLASS_LINK_TRACK_VOLUME_TABLE:
                case CLASS_LOST_AND_FOUND:
                case CLASS_NTDS_CONNECTION:
                case CLASS_NTDS_DSA:
                case CLASS_NTDS_SITE_SETTINGS:
                case CLASS_RID_MANAGER:
                case CLASS_RID_SET:
                case CLASS_SAM_DOMAIN:
                case CLASS_SAM_DOMAIN_BASE:
                case CLASS_SAM_SERVER:
                case CLASS_SITE:
                case CLASS_SITE_LINK:
                case CLASS_SITE_LINK_BRIDGE:
                case CLASS_SITES_CONTAINER:
                case CLASS_SUBNET:
                case CLASS_SUBNET_CONTAINER:
                case CLASS_TRUSTED_DOMAIN:

                    return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                        ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
                }
            }

            break;

        case ATT_SYSTEM_FLAGS:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (    (dwTmp & FLAG_DOMAIN_DISALLOW_MOVE)
                 || (dwTmp & FLAG_DISALLOW_DELETE) )
            {
                // Use same error message as for intra-NC case.
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_ILLEGAL_MOD_OPERATION));
            }

            break;

        case ATT_IS_CRITICAL_SYSTEM_OBJECT:

            boolTmp = * (BOOL *) pAttr->AttrVal.pAVal[0].pVal;

            if ( boolTmp )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_ILLEGAL_MOD_OPERATION));
            }

            break;

        case ATT_PRIMARY_GROUP_ID:

            Assert(0 == primaryGroupRid);
            primaryGroupRid = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;
            break;

        case ATT_GROUP_TYPE:

            Assert(0 == groupType);
            groupType = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;
            break;

        case ATT_MEMBER:

            Assert(0 == cMembers);
            pMembers = pAttr;
            cMembers = pAttr->AttrVal.valCount;
            break;

        case ATT_USER_ACCOUNT_CONTROL:

            // Note that the DS persists UF_* values as per lmaccess.h,
            // not USER_* values as per ntsam.h.   Restrict moves of DCs 
            // and trust objects.  WKSTA and server can move.


            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (    (dwTmp & UF_SERVER_TRUST_ACCOUNT)           // DC
                 || (dwTmp & UF_INTERDOMAIN_TRUST_ACCOUNT) )    // SAM trust
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            break;

        case ATT_OBJECT_SID:

            Assert(!fSidFound);
            Assert(pAttr->AttrVal.pAVal[0].valLen <= sizeof(NT4SID));

            SampSplitNT4SID(    (NT4SID *) pAttr->AttrVal.pAVal[0].pVal,
                                &domSid,
                                &objectRid);

            if ( objectRid < SAMP_RESTRICTED_ACCOUNT_COUNT )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            fSidFound = TRUE;
            break;

        case ATT_INSTANCE_TYPE:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;
        
            if (    !(dwTmp & IT_WRITE)
                 || (dwTmp & IT_NC_HEAD)
                 || (dwTmp & IT_UNINSTANT) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            break;

        case ATT_IS_DELETED:

            boolTmp = * (BOOL *) pAttr->AttrVal.pAVal[0].pVal;

            if ( boolTmp )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOVE_DELETED_OBJECT));
            }

            break;

        // Add additional ATTRTYP-specific validation cases here ...
        }
    }

    // In theory, there are many cases where it is legal to move groups.
    // For example, account groups which have no members and are not a 
    // member of any account groups themselves.  Or resource groups which
    // are themselves not members of other resource groups.  Given that
    // explaining all this to the customer is difficult and that most 
    // groups can be converted to universal groups, we boil it down to
    // two simple rules.  We will move any kind of group except a local
    // group if it has no members and we will move universal groups 
    // with members.

    if ( GROUP_TYPE_BUILTIN_LOCAL_GROUP & groupType )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
    }
    else if ( (GROUP_TYPE_ACCOUNT_GROUP & groupType) && cMembers )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_ACCOUNT_GROUP));
    }
    else if ( (GROUP_TYPE_RESOURCE_GROUP & groupType) && cMembers )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_RESOURCE_GROUP));
    }
    else if ( GROUP_TYPE_UNIVERSAL_GROUP & groupType )
    {
#if DBG
        if ( cMembers && pMembers )
        {
            FpoSanityCheck(pTHS, pMembers);
        }
#endif
        
    }

    // Disallow moves of security principals which are members of 
    // account groups as once the principal is in another domain, the
    // carried forward memberships would be ex-domain, and therefore
    // illegal as per the definition of an account group.

    if ( fSidFound && SampSamClassReferenced(pCC, &iSamClass) )
    {
        // fSidFound ==> SampSamClassReferenced, but not vice versa.
        Assert(fSidFound ? SampSamClassReferenced(pCC, &iSamClass) : TRUE);

        status = SampGetMemberships(
                            &pReadRes->entry.pName,
                            1,
                            gAnchor.pDomainDN,
                            RevMembGetAccountGroups,
                            &cMemberships,
                            &rpMemberships,
                            0,
                            NULL,
                            NULL);

        if ( !NT_SUCCESS(status) )
        {
            return(SetSvcError( SV_PROBLEM_BUSY,
                                RtlNtStatusToDosError(status)));
        }
        else if ( 1 == cMemberships )
        {
            SampSplitNT4SID(&rpMemberships[0]->Sid, &tmpSid, &tmpRid);

            // Bail if the membership SID doesn't represent the user's
            // primary group RID.  We compare the RID and domain SID
            // separately.

            if (    (primaryGroupRid != tmpRid)
                 || !RtlEqualSid(&tmpSid, &domSid) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS));
            }
        }
        else if ( cMemberships > 1 )
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS));
        }
    }

    // Verify that this is really a cross domain move.  We could be faked
    // into a cross forest move if someone added cross-refs for the other
    // forest.  So we check for cross-ref existence AND whether its for a
    // domain or not.

    flagsRequired = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);

    Assert(pReadRes->entry.pName->NameLen && pNewName->NameLen);
    InitCommarg(&commArg);

    if (    !(pOldCR = FindBestCrossRef(pReadRes->entry.pName, &commArg))
         || (flagsRequired != (pOldCR->flags & flagsRequired)) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pReadRes->entry.pName,
                            DIRERR_CANT_FIND_EXPECTED_NC));
    }
    else if (    !(pNewCR = FindBestCrossRef(pNewName, &commArg)) 
              || (flagsRequired != (pNewCR->flags & flagsRequired)) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pNewName,
                            DIRERR_CANT_FIND_EXPECTED_NC));
    }
    else if ( NameMatched(pOldCR->pNC, pNewCR->pNC) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewName,
                            ERROR_DS_SRC_AND_DST_NC_IDENTICAL));
    }
    else if (    NameMatched(pOldCR->pNC, gAnchor.pConfigDN)
              || NameMatched(pNewCR->pNC, gAnchor.pConfigDN)
              || NameMatched(pOldCR->pNC, gAnchor.pDMD)
              || NameMatched(pNewCR->pNC, gAnchor.pDMD) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pNewName,
                            ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
    }

    *ppSourceNC = pOldCR->pNC;
    *ppExpectedTargetNC = pNewCR->pNC;

    // Disallow move of well known objects.

    Assert(NameMatched(gAnchor.pDomainDN, pOldCR->pNC));    // product 1

    if (    !(pAC = SCGetAttById(pTHS, ATT_WELL_KNOWN_OBJECTS))
         || DBFindDSName(pTHS->pDB, gAnchor.pDomainDN) )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
    }

    for ( i = 1; TRUE; i++ )
    {
        puc = NULL;
        dwTmp = DBGetAttVal_AC(pTHS->pDB, i, pAC, 0, 0, &len, (UCHAR **) &puc);

        if ( 0 == dwTmp )
        {
            if ( NameMatched(pReadRes->entry.pName, NAMEPTR(puc)) )
            {
                THFreeEx(pTHS, puc);
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            THFreeEx(pTHS, puc);
        } 
        else if ( DB_ERR_NO_VALUE == dwTmp )
        {
            break;      // for loop
        }
        else
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR, 
                                DIRERR_INTERNAL_FAILURE));
        }
    }

    return(0);
}

ULONG
InterDomainMove(
    WCHAR           *pszDstAddr,
    ENTINF          *pSrcObject,
    DSNAME          *pDestinationDN,
    DSNAME          *pExpectedTargetNC,
    SecBufferDesc   *pClientCreds,
    DSNAME          **ppAddedName
    )
{
    THSTATE             *pTHS = pTHStls;
    DWORD               cb, dwErr, outVersion;
    DRS_MSG_MOVEREQ     moveReq;
    DRS_MSG_MOVEREPLY   moveReply;
    DSNAME              *pDstObject;

    Assert(VALID_THSTATE(pTHS));
    // We're about to go off machine - should not have transaction or locks.
    Assert(!pTHS->transactionlevel && !pTHS->fSamWriteLockHeld);

    *ppAddedName = NULL;

    // Initialize request and reply.

    memset(&moveReply, 0, sizeof(DRS_MSG_MOVEREPLY));
    memset(&moveReq, 0, sizeof(DRS_MSG_MOVEREQ));
    moveReq.V2.pSrcDSA = gAnchor.pDSADN;
    moveReq.V2.pSrcObject = pSrcObject;
    moveReq.V2.pDstName = pDestinationDN;
    moveReq.V2.pExpectedTargetNC = pExpectedTargetNC;
    moveReq.V2.pClientCreds = (DRS_SecBufferDesc *) pClientCreds;
    moveReq.V2.PrefixTable = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
    moveReq.V2.ulFlags = 0;

    dwErr = I_DRSInterDomainMove(pTHS,
                                 pszDstAddr,
                                 2,
                                 &moveReq,
                                 &outVersion,
                                 &moveReply);

    if ( dwErr )
    {
        // We used to distinguish between connect errors and server-side
        // errors.  For connection failures, we used
        // SV_PROBLEM_UNAVAILABLE/RPC_S_SERVER_UNAVAILABLE
        // otherwise
        // SV_PROBLEM_DIR_ERROR/DIRERR_INTERNAL_FAILURE
        // Now, since the rpc api returns win32 errors, use those.
        // If the call fails, we treat them all as unavailable errors:

        return(SetSvcError( SV_PROBLEM_UNAVAILABLE, dwErr ));
    }
    else if ( 2 != outVersion )
    {
        return(SetSvcError( SV_PROBLEM_DIR_ERROR, 
                            DIRERR_INTERNAL_FAILURE));
    }
    else if ( moveReply.V2.win32Error )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM, 
                            moveReply.V2.win32Error));
    }

    *ppAddedName = moveReply.V2.pAddedName;
    return(0);
}

ULONG
PrePhantomizeChildCleanup(
    THSTATE     *pTHS,
    BOOL        fChildrenAllowed
    )
/*++

  Routine Description:

    This routine is now used for general reparenting of orphaned children by both
    replicator and system callers.

    This routine moves the children of an about to be phantomized object to
    the Lost&Found container.  This is required and acceptable for various
    reasons.  The source of a cross domain move disallows move of an object
    with children.  However, this does not guarantee that there are no 
    children at the move destination (move destination holds source NC if
    it is a GC).  Replication latency can also result in there being children
    in existence when a replicated-in proxy object is processed.  I.e. While
    replica 1 of some NC sourced a cross domain move of object O, a child of O
    was added at replica 2 of the source NC.

    The mvtree utility exacerbates this problem as follows.  Assume a parent
    object P and a child object C at the move source.  mvtree creates a 
    temporary parent P' at the source and moves C under it such that the
    original parent P is now a leaf and can be cross domain moved prior to
    its children.  This insures that all cross domain moves are to their
    "final" location and thus any ex-domain references from the source are
    accurate - modulo further moves in the destination NC of course.  If 
    mvtree operations outpace replication (which is likely given that we
    employ a replication notification delay) then the destination ends up
    phantomizing parent P while C is still really its child.

    Now consider the following DNT relationships at the destination.

        RDN     DNT     PDNT    NCDNT
        parent  10      X       1
        child   11      10      1

    Noting that at the destination we don't just phantomize parent P but
    also add it to the destination NC (reusing its DNT), then were we to 
    just phantomize P we would end up with the following:


        RDN     DNT     PDNT    NCDNT
        parent  10      X       2
        child   11      10      1

    This is an invalid database state as there is a mismatch between the
    child's NCDNT (1) and the NCDNT of its parent (2) as identified by 
    its PDNT (10).

    The remedy is to move the children of the about to be phantomized
    object to their NC's Lost&Found container.  In the case where children
    exist due to the mvtree algorithm, they will most likely move ex-domain
    shortly anyway.  In the replication latency case, they will languish 
    in Lost&Found until someone realizes they are missing.

  Arguments:

    pTHS - active THSTATE whose pTHS->pDB is positioned on the parent
        object whose children are to be moved.

    fChildrenAllowed - Flag indicating whether we think its OK if the 
        object being phantomized has children or not.

  Return Values:

    pTHS->errCode

--*/
{
    DSNAME                      *pParentDN = NULL;
    RESOBJ                      *pResParent = NULL;
    PDSNAME                     *rpChildren = NULL;
    DWORD                       iLastName = 0;
    DWORD                       cMaxNames = 0;
    BOOL                        fWrapped = FALSE;
    BOOL                        savefDRA;
    ULONG                       len;
    DSNAME                      *pLostAndFoundDN = NULL;
    DWORD                       lostAndFoundDNT;
    MODIFYDNARG                 modifyDnArg;
    MODIFYDNRES                 modifyDnRes;
    DWORD                       cMoved = 0;
    PROPERTY_META_DATA_VECTOR   *pmdVector = NULL;
    DWORD                       i;
    DWORD                       ccRdn;
    ATTRVAL                     rdnAttrVal = { 0, NULL };
    ATTR                        rdnAttr = { 0, { 1, &rdnAttrVal } };
    ATTCACHE                    *pacRDN;
    CLASSCACHE                  *pccChild;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(DBCheckObj(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    savefDRA = pTHS->fDRA;
    // This code requires fDRA in order mangle names,
    // rename arbitrary objects, and merge remote meta data vectors.
    pTHS->fDRA = TRUE;

    __try
    {
        // Grab a RESOBJ for the parent for later use.

        if ( DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                         0, 0, &len, (UCHAR **) &pParentDN) )
        {
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            __leave;
        }

        pResParent = CreateResObj(pTHS->pDB, pParentDN);
        
        // Take a read lock on the parent.  This will cause escrowed updates
        // (by other transactions) to fail thereby insuring no other thread
        // creates a new child while we're in the process of moving the current
        // set of children.  Then get all first level children.
    
        if (    DBClaimReadLock(pTHS->pDB)
             || DBGetDepthFirstChildren(pTHS->pDB, &rpChildren, &iLastName,
                                        &cMaxNames, &fWrapped, TRUE) )
        {
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            __leave;
        }
    
        // If no children are expected/allowed, then DBGetDepthFirstChildren
        // should have returned one element which is the parent itself.
        // This one DSNAME is returned in DBGETATTVAL_fSHORTNAME form.  All
        // others should include a string name.

        Assert(fChildrenAllowed 
                    ? TRUE 
                    : (    !fWrapped
                        && (1 == iLastName) 
                        && !memcmp(&pParentDN->Guid, 
                                   &rpChildren[0]->Guid, 
                                   sizeof(GUID))) )
    
        if (    !fWrapped
             && (1 == iLastName) 
             && !memcmp(&pParentDN->Guid, &rpChildren[0]->Guid, sizeof(GUID)) )
        {
            // Nothing to do, but position back at parent before returning.

            if ( DBFindDNT(pTHS->pDB, pResParent->DNT) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            }

            __leave;
        }
    
        // Find the Lost&Found container's DSNAME.  Although we now
        // support pNCL->LostAndFoundDNT field in the gAnchor lists, 
        // the field is uninitialized if the NC was added since the 
        // last boot.  I.e. The lost and found container for the NC
        // in question must exist locally when the CR was added to the
        // list - which isn't the case for recently added NCs.  Thus
        // we get the NC's Lost&Found the hard way here.
    
        if (    DBFindDNT(pTHS->pDB, pResParent->NCDNT)
             || !GetWellKnownDNT(pTHS->pDB,
                                 (GUID *) GUID_LOSTANDFOUND_CONTAINER_BYTE,
                                 &lostAndFoundDNT)
             || (INVALIDDNT == lostAndFoundDNT)
             || DBFindDNT(pTHS->pDB, lostAndFoundDNT)
             || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, 
                            &len, (UCHAR **) &pLostAndFoundDN) )
        {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                        ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER);
            __leave;
        }

        // Construct a one element metadata vector which is used to insure
        // that any RDN changes we make as we put objects in Lost&Found
        // lose out to other RDN changes from "real" clients.
    
        pmdVector = (PROPERTY_META_DATA_VECTOR *) 
                            THAllocEx(pTHS, sizeof(PROPERTY_META_DATA_VECTOR));
        pmdVector->dwVersion = 1;
        pmdVector->V1.cNumProps = 1;
        pmdVector->V1.rgMetaData[0].attrType = ATT_RDN;
        pmdVector->V1.rgMetaData[0].timeChanged = DBTime();
        pmdVector->V1.rgMetaData[0].uuidDsaOriginating = pTHS->InvocationID;
        pmdVector->V1.rgMetaData[0].usnOriginating = DBGetNewUsn();
        // pmdVector->V1.rgMetaData[0].usnProperty can be left as 0 - it will
        // be overwritten with the local USN at which the change is applied.
        ReplUnderrideMetaData(pTHS, ATT_RDN, &pmdVector, NULL);

        // Build constant parts of MODIFYDNARG.
    
        memset(&modifyDnArg, 0, sizeof(modifyDnArg));
        modifyDnArg.pNewParent = pLostAndFoundDN;
        InitCommarg(&modifyDnArg.CommArg);
        modifyDnArg.pMetaDataVecRemote = pmdVector;
        modifyDnArg.pResParent = pResParent;
        modifyDnArg.pNewRDN = &rdnAttr;
        rdnAttrVal.pVal = (UCHAR *) 
                    THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);

        // For each child, mangle its RDN so as to guarantee lack of name
        // conflicts in Lost&Found, then do the local rename.  We don't 
        // need to do the iLastName down to 0 then cMaxNames down to iLastName
        // iteration algorithm as we don't care which order we process the
        // children in.  Use mark and free to mark so we don't bloat the heap.

        pacRDN = SCGetAttById(pTHS, ATT_RDN);

        do // while ( fWrapped )
        {
            for ( i = 0; i < (fWrapped ? cMaxNames : iLastName); i++ )
            {
                if ( !memcmp(&pParentDN->Guid, 
                             &rpChildren[i]->Guid, 
                             sizeof(GUID)) )
                {
                    // Skip the parent.
                    continue;
                }
    
                if (    DBFindDSName(pTHS->pDB, rpChildren[i])
                     || DBGetAttVal_AC(pTHS->pDB, 1, pacRDN, 
                                       DBGETATTVAL_fCONSTANT, 
                                       sizeof(WCHAR) * MAX_RDN_SIZE, 
                                       &len, &rdnAttrVal.pVal) )
                {
                    SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                    __leave;
                }
                
                modifyDnArg.pResObj = CreateResObj(pTHS->pDB, rpChildren[i]);
                pccChild = SCGetClassById(
                                    pTHS, 
                                    modifyDnArg.pResObj->MostSpecificObjClass);
                // Use the object rdnType and not the object's class rdnattid
                // because a superceding class may have a different rdnattid
                // than the superceded class had when this object was created.
                GetObjRdnType(pTHS->pDB, pccChild, &rdnAttr.attrTyp);
                ccRdn = len / sizeof(WCHAR);
                MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT, 
                          &rpChildren[i]->Guid,
                          (WCHAR *) rdnAttrVal.pVal, &ccRdn);
                rdnAttrVal.valLen = ccRdn * sizeof(WCHAR);
                memset(&modifyDnRes, 0, sizeof(modifyDnRes));
    
                if ( LocalModifyDN(pTHS, &modifyDnArg, &modifyDnRes) )
                {
                    UCHAR *pString=NULL;
                    DWORD cbString=0;

                    CreateErrorString(&pString, &cbString);
                    LogEvent8WithData( DS_EVENT_CAT_GARBAGE_COLLECTION,
                                       DS_EVENT_SEV_ALWAYS,
                                       DIRLOG_DSA_CHILD_CLEANUP_FAILURE,
                                       szInsertDN(pParentDN),
                                       szInsertDN(rpChildren[i]),
                                       szInsertWC2(rdnAttrVal.pVal, ccRdn),
                                       szInsertDN(pLostAndFoundDN),
                                       szInsertSz(pString?pString:""),
                                       NULL, NULL, NULL,
                                       sizeof(pTHS->errCode),
                                       &pTHS->errCode );
                    if (pString) {
                        THFreeEx(pTHS,pString);
                    }
                    __leave;
                }

                THFreeEx(pTHS, modifyDnArg.pResObj);
                THFreeEx(pTHS, modifyDnArg.pResParent);
            }

            for ( i = 0; i < (fWrapped ? cMaxNames : iLastName); i++ )
            {
                THFreeEx(pTHS, rpChildren[i]);
            }

            THFreeEx(pTHS, rpChildren);
            rpChildren = NULL;

            // Position back at parent.  Need this if fWrapped or if
            // we are returning to caller.
        
            if ( DBFindDNT(pTHS->pDB, pResParent->DNT) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;
            }

            if (    fWrapped
                 && DBGetDepthFirstChildren(pTHS->pDB, &rpChildren, &iLastName,
                                            &cMaxNames, &fWrapped, TRUE) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;
            }

        } while ( fWrapped );
    }
    __finally
    {
        pTHS->fDRA = savefDRA;
    }

    if ( pParentDN ) THFreeEx(pTHS, pParentDN);
    if ( pResParent ) THFreeEx(pTHS, pResParent);
    if ( pLostAndFoundDN ) THFreeEx(pTHS, pLostAndFoundDN);
    if ( pmdVector ) THFreeEx(pTHS, pmdVector);
    if ( rdnAttrVal.pVal ) THFreeEx(pTHS, rdnAttrVal.pVal);

    return(pTHS->errCode);
}

ULONG
PhantomizeObject(
    DSNAME  *pOldDN,
    DSNAME  *pNewDN,
    BOOL    fChildrenAllowed
    )
/*++

Routine Description:

    This routine converts an object into a phantom so that group-membership 
    references (via DNT) are maintained.  If pOldDN is a phantom, then it
    merely renames the phantom (or insures it has the same name).

Arguments:

    pOldDn - Pointer to DSNAME to phantomize.  This DSNAME must have the
        current string name of the object.

    pNewDN - Pointer to DSNAME of resulting phantom.  This DSNAME
        must have a string name.

    fChildrenAllowed - Flag indicating whether we think its OK if the 
        object being phantomized has children or not.

Return Value:

    pTHStls->errCode

--*/

{
    THSTATE                     *pTHS;
    DWORD                       dwErr;
    WCHAR                       oldRdnVal[MAX_RDN_SIZE];
    WCHAR                       newRdnVal[MAX_RDN_SIZE];
    ATTRTYP                     oldRdnTyp;
    ATTRTYP                     newRdnTyp;
    ULONG                       oldRdnLen;
    ULONG                       newRdnLen;
    DSNAME                      *pParentDN = NULL;
    BOOL                        fRealObject = FALSE;
    BOOL                        fChangedRdn = FALSE;
    ATTRVAL                     attrVal = { 0, (UCHAR *) newRdnVal };
    ATTCACHE                    *pAC;
    ULONG                       len;
    SYNTAX_DISTNAME_BINARY      *pOldProxy = NULL;
    DSNAME                      *pTmpDN;
    GUID                        guid;
    GUID                        *pGuid = &guid;
    DWORD                       ccRdn;
    DWORD                       objectStatus;
    PROPERTY_META_DATA_VECTOR   *pMetaDataVec;
    PROPERTY_META_DATA          *pMetaData;
    BOOL                        fMangledRealObjectName = FALSE;
#if DBG
    DSNAME                      *pDbgDN;
#endif

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(pOldDN->NameLen > 0);
    Assert(pNewDN->NameLen > 0);

    // Pave the way for the new name in case it is in use.
    // If old and new string names are the same, then we won't have
    // a name conflict as new name will promote existing phantom with
    // the same name - so we can bypass this check.

    if ( NameMatchedStringNameOnly(pOldDN, pNewDN) )
    {
        goto Phantomize;
    }

    pTmpDN = (DSNAME *) THAllocEx(pTHS, pNewDN->structLen);
    pTmpDN->structLen = pNewDN->structLen;
    pTmpDN->NameLen = pNewDN->NameLen;
    memcpy(pTmpDN->StringName, 
           pNewDN->StringName, 
           sizeof(WCHAR) * pNewDN->NameLen);

    objectStatus = dwErr = DBFindDSName(pTHS->pDB, pTmpDN);

    switch ( dwErr )
    {
    case 0:
    case DIRERR_NOT_AN_OBJECT:

        // The target name is in use - duplicate key errors will occur in
        // the PDNT-RDN index unless we mangle one of the names - which one?
        // We can get here two ways - either we're the source of a cross
        // domain move doing post remote add cleanup, or we're the replicator
        // processing a proxy object for its side effect.  Even if we're a
        // GC, in neither case are we authoritative for the new DN's NC and
        // know that the machines which are authoritative for the new DN's
        // NC will eventually resolve any name conflict.  So we unilaterally
        // mangle the DN of the conflicting entry.  If it is a phantom to 
        // begin with the stale phantom daemon will ultimately make it right.
        // If it is a real object we whack its metadata to lose name conflicts,
        // thus any better name as decided upon by the authoritative replicas
        // will take effect when they get here.

        if (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID,
                                     DBGETATTVAL_fCONSTANT, sizeof(GUID),
                                     &len, (UCHAR **) &pGuid))
             || (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_RDN,
                                     DBGETATTVAL_fCONSTANT, 
                                     MAX_RDN_SIZE * sizeof(WCHAR),
                                     &len, (UCHAR **) &attrVal.pVal))
             || (ccRdn = len / sizeof(WCHAR),
                 MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT, pGuid,
                           (WCHAR *) attrVal.pVal, &ccRdn),
                 attrVal.valLen = sizeof(WCHAR) * ccRdn,
                 dwErr = DBResetRDN(pTHS->pDB, &attrVal)) )
        {
            return(SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                 DIRERR_DATABASE_ERROR, 
                                 dwErr));
        }

        if ( 0 == objectStatus )
        {
            fMangledRealObjectName = TRUE;

            if (    (dwErr = DBGetAttVal(pTHS->pDB, 1, 
                                         ATT_REPL_PROPERTY_META_DATA,
                                         0, 0, &len, (UCHAR **) &pMetaDataVec))
                 || (ReplUnderrideMetaData(pTHS, ATT_RDN, &pMetaDataVec, &len),
                     dwErr = DBReplaceAttVal(pTHS->pDB, 1, 
                                             ATT_REPL_PROPERTY_META_DATA,
                                             len, pMetaDataVec)) )
            {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                     DIRERR_DATABASE_ERROR, 
                                     dwErr));
            }

            THFreeEx(pTHS, pMetaDataVec);
        }
    
        if ( dwErr = DBUpdateRec(pTHS->pDB) )
        {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                     DIRERR_DATABASE_ERROR, 
                                     dwErr));
        }
            
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // No such object - no name conflict.
        break;

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

Phantomize:

    // Phantomize old object.

    dwErr = DBFindDSName(pTHS->pDB, pOldDN);

    switch ( dwErr )
    {
    case 0:

        // Found real object.
        fRealObject = TRUE;

        // Check if callers are providing current string name - but only
        // if we didn't just mangle it ourselves.

        Assert( fMangledRealObjectName 
                    ? TRUE 
                    : (    !DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                        0, 0, &len, (UCHAR **) &pDbgDN)
                        && NameMatchedStringNameOnly(pOldDN, pDbgDN)) );

        // Move children to Lost&Found to avoid PDNT/NCDNT mismatch when
        // parent is moved to new NC but children still point to parent.

        if ( PrePhantomizeChildCleanup(pTHS, fChildrenAllowed) )
        {
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        break;

    case DIRERR_NOT_AN_OBJECT:

        // Found phantom.
        break;
        
    case DIRERR_OBJ_NOT_FOUND:

        // No such object.
        return(SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND));

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    // DBResetParent requires a DSNAME with a string name.
    Assert(pNewDN->NameLen);

    // Derive parent and RDN info for subsequent DBReset* calls.

    pParentDN = (DSNAME *) THAllocEx(pTHS, pNewDN->structLen);

    if (    GetRDNInfo(pTHS, pOldDN, oldRdnVal, &oldRdnLen, &oldRdnTyp)
         || GetRDNInfo(pTHS, pNewDN, newRdnVal, &newRdnLen, &newRdnTyp)
         || (oldRdnTyp != newRdnTyp)
         || TrimDSNameBy(pNewDN, 1, pParentDN) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    attrVal.valLen = sizeof(WCHAR) * newRdnLen;
    fChangedRdn = (    (oldRdnLen != newRdnLen) 
                    || (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                            oldRdnVal, oldRdnLen,
                                            newRdnVal, newRdnLen)) );

    // Remove ATT_PROXIED_OBJECT property if it exists.  This is so that
    // if the object is moved back, and the phantom promoted to a real 
    // object again, that the new object doesn't get the old object's
    // property value.  See logic in IDL_DRSRemoteAdd which adds the
    // value we really want.

    pAC = SCGetAttById(pTHS, ATT_PROXIED_OBJECT_NAME);
    switch ( dwErr = DBGetAttVal_AC(pTHS->pDB, 1, pAC, 0, 0, 
                                    &len, (UCHAR **) &pOldProxy) )
    {
    case DB_ERR_NO_VALUE:   pOldProxy = NULL; break;
    case 0:                 Assert(len && pOldProxy); break;
    default:                return(SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                                 DIRERR_DATABASE_ERROR, 
                                                 dwErr));
    }

    // If real object, use DBPhysDel to convert it into a phantom yet 
    // leave all links to it intact.  The object won't really be physically 
    // deleted as it still has a ref count for itself.  Reset parentage and
    // RDN for both object and phantom cases.  Specify flag that says it 
    // is OK to create the new parent as another phantom if required.
    // Remove NCDNT if this was a real object as phantoms don't have one.
    // Normally DBPhysDel removes ATT_PROXIED_OBJECT_NAME so only do it
    // if we're not calling DBPhysDel AND the property exists.


    if (    (dwErr = (fRealObject 
                            ? DBPhysDel(pTHS->pDB, TRUE, NULL) 
                            : 0))
         || (dwErr = DBResetParent(pTHS->pDB, pParentDN,
                                   (DBRESETPARENT_CreatePhantomParent |
                                    (fRealObject ?
                                     DBRESETPARENT_SetNullNCDNT :
                                     0))))
         || (dwErr = (fChangedRdn 
                            ? DBResetRDN(pTHS->pDB, &attrVal)
                            : 0))
         || (dwErr = ((!fRealObject && pOldProxy)
                            ? DBRemAttVal_AC(pTHS->pDB, pAC, len, pOldProxy)
                            : 0))
         || (dwErr = DBUpdateRec(pTHS->pDB)) )
    {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
    }

    THFreeEx(pTHS, pParentDN);

    return(pTHS->errCode);
}

ULONG
CreateProxyObject(
    DSNAME                  *pProxyObjectName,
    DSNAME                  *pProxiedObjectName,
    SYNTAX_DISTNAME_BINARY  *pOldProxyVal
    )
/*++

  Routine Description:

    Create an "infrastructure" object with the desired ATT_PROXIED_OBJECT_NAME.
    Then delete it so it propagates as a tombstone and eventually disappears.

  Parameters:

    pProxyObjectName - DSNAME of proxy object to create.

    pProxiedObjectName - DSNAME of object which is to be proxied.

    pOldProxyVal - NULL or pointer to moved object's ATT_PROXIED_OBJECT_NAME.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE                 *pTHS = pTHStls;
    DWORD                   winErr;
    DWORD                   objectClass = CLASS_INFRASTRUCTURE_UPDATE;
    // Set various system flags to insure proxy objects stay in the
    // Infrastructure container so that unseen proxies move with the
    // RID FSMO - see GetProxyObjects().
    DWORD                   systemFlags = (   FLAG_DOMAIN_DISALLOW_RENAME
                                            | FLAG_DISALLOW_MOVE_ON_DELETE
                                            | FLAG_DOMAIN_DISALLOW_MOVE );
    ATTRVAL                 classVal =  { sizeof(DWORD), 
                                          (UCHAR *) &objectClass };
    ATTRVAL                 nameVal =   { 0, NULL };
    ATTRVAL                 flagsVal =  { sizeof(DWORD),
                                          (UCHAR *) &systemFlags };
    ATTR                    attrs[3] = 
        {   
            { ATT_OBJECT_CLASS,           { 1, &classVal } },
            { ATT_PROXIED_OBJECT_NAME,    { 1, &nameVal } },
            { ATT_SYSTEM_FLAGS,           { 1, &flagsVal } },
        };
    ADDARG                  addArg;
    REMOVEARG               remArg;
    SYNTAX_ADDRESS          blob;
    DSNAME                  *pParentObj = NULL;

    // Assert good environment and correctness of names.

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel > 0);
    Assert(fNullUuid(&pProxyObjectName->Guid));
    Assert(!fNullUuid(&pProxiedObjectName->Guid));
    Assert(pProxyObjectName->NameLen);
    Assert(pProxiedObjectName->NameLen);

    // Construct SYNTAX_DISTNAME_BINARY property value.
    // Proxy object's ATT_PROXIED_OBJECT_NAME holds the epoch number of
    // the proxied object prior to move.

    MakeProxy(  pTHS,
                pProxiedObjectName,
                PROXY_TYPE_PROXY,
                pOldProxyVal
                    ? GetProxyEpoch(pOldProxyVal)
                    : 0,
                &nameVal.valLen,
                (SYNTAX_DISTNAME_BINARY **) &nameVal.pVal);

    memset(&addArg, 0, sizeof(addArg));
    addArg.pObject = pProxyObjectName;
    addArg.AttrBlock.attrCount = 3;
    // addArg.AttrBlock.pAttr needs to be THAlloc'd so that lower layers
    // can realloc it in due course.
    addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(attrs));
    memcpy(addArg.AttrBlock.pAttr, attrs, sizeof(attrs));
    InitCommarg(&addArg.CommArg);

    // Contruct parent RESOBJ.

    pParentObj = (DSNAME *) THAllocEx(pTHS, pProxyObjectName->structLen);
    if (    TrimDSNameBy(pProxyObjectName, 1, pParentObj) 
         || DBFindDSName(pTHS->pDB, pParentObj) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pProxyObjectName,
                            DIRERR_BAD_NAME_SYNTAX));
    }
    addArg.pResParent = CreateResObj(pTHS->pDB, pParentObj);

    // Set/clear fCrossDomainMove so VerifyDsnameAtts accepts a value
    // for ATT_PROXIED_OBJECT_NAME.
    pTHS->fCrossDomainMove = TRUE;
    
    // pTHS->fDSA should have been set by caller.
    Assert(pTHS->fDSA);

    _try
    {
        if ( 0 == LocalAdd(pTHS, &addArg, FALSE) )
        {
            memset(&remArg, 0, sizeof(REMOVEARG));
            remArg.pObject = pProxyObjectName;
            InitCommarg(&remArg.CommArg);
            remArg.pResObj = CreateResObj(pTHS->pDB, pProxyObjectName);
            LocalRemove(pTHS, &remArg);

            // N.B. Since the object was added and removed in the same
            // transaction the replicator can not pick this object up between
            // the add and remove.  It will replicate the final, deleted
            // state of the object only.  Furthermore, since ATT_OBJECT_CLASS
            // and ATT_PROXIED_OBJECT_NAME are not removed during deletion 
            // (see SetDelAtt), therefore we are guaranteed that replicas
            // receiving this proxy object will have ATT_OBJECT_CLASS,
            // ATT_IS_DELETED, and ATT_PROXIED_OBJECT_NAME available in
            // the replicated data and can use this to unambiguously identify
            // the object as a valid proxy for processing.
        }
    }
    _finally
    {
        pTHS->fCrossDomainMove = FALSE;
    }

    return(pTHS->errCode);
}

VOID
FreeRemoteAddCredentials(
    SecBufferDesc   *pSecBufferDesc
    )
/*++

  Routine Description:

    Free the credentials blob returned by GetRemoteAddCredentials.

  Parameters:

    pSecBufferDesc - Pointer to struct filled by GetRemoteAddCredentials.

  Return Values:

    None

--*/
{
    ULONG i;

    if ( pSecBufferDesc )
    {
        for ( i = 0; i < pSecBufferDesc->cBuffers; i++ )
        {
            FreeContextBuffer(pSecBufferDesc->pBuffers[i].pvBuffer);
        }
    }
}

ULONG
GetRemoteAddCredentials(
    THSTATE         *pTHS,
    WCHAR           *pDstDSA,
    SecBufferDesc   *pSecBufferDesc
    )
/*++

  Routine Description:

    Impersonate client and get security blob which represents their 
    credentials which will be used for the actual DirAddEntry call at
    the destination.  See comments in IDL_DRSRemoteAdd for the remote
    add security model.

  Parameters:

    pDstDSA - Name of destination DSA we will bind to.

    pSecBufferDesc - Pointer to credentials struct to fill in.

  Return Values:

    pTHStls->errCode

--*/
{
    SECURITY_STATUS         secErr = SEC_E_OK;
    ULONG                   winErr;
    CredHandle              hClient;
    TimeStamp               ts;
    CtxtHandle              hNewContext;
    ULONG                   clientAttrs;
    LPWSTR                  pszServerPrincName = NULL;

    __try {
        if ( winErr = DRSMakeMutualAuthSpn(pTHS, pDstDSA, NULL,
                                           &pszServerPrincName) )
        {
            SetSvcError(SV_PROBLEM_UNAVAILABLE, winErr);
            __leave;
        }

        if ( winErr = ImpersonateAnyClient() )
        {
            SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH, 
                        winErr);
            __leave;
        }

        secErr = AcquireCredentialsHandleA(
                                NULL,                       // pszPrincipal
                                MICROSOFT_KERBEROS_NAME_A,  // pszPackage
                                SECPKG_CRED_OUTBOUND,       // fCredentialUse
                                NULL,                       // pvLogonId
                                NULL,                       // pAuthData
                                NULL,                       // pGetKeyFn
                                NULL,                       // pvGetKeyArgument
                                &hClient,                   // phCredential
                                &ts);                       // ptsExpiry
        
        if ( SEC_E_OK != secErr )
        {
            SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH, secErr);
        } 
        else
        {
            secErr = InitializeSecurityContext(
                                &hClient,                   // phCredential
                                NULL,                       // phContext
                                pszServerPrincName,         // pszTargetName
                                ISC_REQ_ALLOCATE_MEMORY,    // fContextReq
                                0,                          // Reserved1
                                SECURITY_NATIVE_DREP,       // TargetRep
                                NULL,                       // pInput
                                0,                          // Reserved2
                                &hNewContext,               // phNewContext
                                pSecBufferDesc,             // pOutput
                                &clientAttrs,               // pfContextAttributes
                                &ts);                       // ptsExpiry
        
            if ( SEC_E_OK == secErr )
            {
                DeleteSecurityContext(&hNewContext);
            }
            else
            {
                // SecBufferDesc may hold error information.
                SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH, secErr);
            }
        
            FreeCredentialsHandle(&hClient);
        }
        
        UnImpersonateAnyClient();

    } __finally {
        if (NULL != pszServerPrincName) {
            free(pszServerPrincName);
        }
    }

    return pTHS->errCode;
}

ULONG
ReadAllAttrsForMove(
    DSNAME                  *pObject,
    READRES                 **ppReadRes,
    RESOBJ                  **ppResObj,
    SYNTAX_DISTNAME_BINARY  **ppOldProxyVal
    )
/*++

  Routine Description:

    Reads all attributes off an object for shipment to another domain 
    for cross domain move.

  Parameters:

    pObject - Pointer to DSNAME of object to be read.

    ppReadRes - Address of READRES pointer which receives DirRead result.

    ppResObj - Address of RESOBJ pointer which receives RESOBJ on success.

    ppOldProxyVal - Address of SYNTAX_DISTNAME_BINARY which receives the
        object's ATT_PROXIED_OBJECT_NAME property if present.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    DWORD       dwErr;
    READARG     readArg;
    ENTINFSEL   entInfSel;
    BOOL        fDsaSave;
    // Move some operational attributes, too
    ATTR        attrs[2] = { { ATT_NT_SECURITY_DESCRIPTOR,  { 0, NULL } },
                             { ATT_REPL_PROPERTY_META_DATA, { 0, NULL } } };
    ULONG       i;
    ATTR        *pAttr;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    *ppOldProxyVal = NULL;

    // Set up args to read every possible attribute - metadata, DS, etc.

    memset(&entInfSel, 0, sizeof(ENTINFSEL));
    memset(&readArg, 0, sizeof(READARG));
    InitCommarg(&readArg.CommArg);
    readArg.CommArg.Svccntl.SecurityDescriptorFlags = 
            (   SACL_SECURITY_INFORMATION
              | OWNER_SECURITY_INFORMATION
              | GROUP_SECURITY_INFORMATION
              | DACL_SECURITY_INFORMATION );
    readArg.CommArg.Svccntl.dontUseCopy = FALSE;
    readArg.pObject = pObject;
    readArg.pSel = &entInfSel;
    readArg.pSel->attSel = EN_ATTSET_ALL_WITH_LIST;
    readArg.pSel->infoTypes = EN_INFOTYPES_TYPES_VALS;
    readArg.pSel->AttrTypBlock.attrCount = 2;
    readArg.pSel->AttrTypBlock.pAttr = attrs;
    *ppReadRes = THAllocEx(pTHS, sizeof(READRES));
    
    // Perform read as fDSA so as to bypass access checking.
    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    _try
    {

        if ( 0 == (dwErr = DoNameRes(   pTHS,
                                        NAME_RES_QUERY_ONLY,
                                        readArg.pObject,
                                        &readArg.CommArg,
                                        &(*ppReadRes)->CommRes,
                                        &readArg.pResObj) ) )
        {
            if ( 0 == (dwErr = LocalRead(   pTHS, 
                                            &readArg, 
                                            *ppReadRes) ) )
            {
                *ppResObj = readArg.pResObj;

                // Extract the ATT_PROXIED_OBJECT_NAME property if it exists.

                for ( i = 0, pAttr = (*ppReadRes)->entry.AttrBlock.pAttr;
                      i < (*ppReadRes)->entry.AttrBlock.attrCount; 
                      i++, pAttr++ )
                {
                    if ( ATT_PROXIED_OBJECT_NAME == pAttr->attrTyp )
                    {
                        Assert(1 == pAttr->AttrVal.valCount);
                        Assert(PROXY_TYPE_MOVED_OBJECT == 
                                    GetProxyType((SYNTAX_DISTNAME_BINARY *) 
                                                pAttr->AttrVal.pAVal->pVal));
                        *ppOldProxyVal = (SYNTAX_DISTNAME_BINARY *)
                                                pAttr->AttrVal.pAVal->pVal;
                        break;
                    }
                }
            }
        }
    }
    _finally
    {
        pTHS->fDSA = fDsaSave;
    }

    Assert(pTHS->errCode == dwErr);
    return(dwErr);
}


DWORD 
ReReadObjectName (
    THSTATE *pTHS,
    DSNAME  *pOldDN,
    DSNAME  **ppNewObjectName
    ) 
/*++

  Routine Description:

    Re-read an object form the database.

  Parameters:

    pOldDN - Pointer to DSNAME to re-read.
    ppNewObjectName - New Object Name

  Return Values:

    Error Code or 0 for success

--*/
{
    DWORD       dwErr;
    ULONG       len;

    dwErr = DBFindDSName(pTHS->pDB, pOldDN);

    switch ( dwErr )
    {
    case 0:
        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR **) ppNewObjectName)) {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                 DIRERR_DATABASE_ERROR, 
                                 dwErr));
        }

        #if DBG
            Assert (" Ignorable Assertion. Object changed name while moving" && NameMatchedStringNameOnly(pOldDN, *ppNewObjectName));
        #endif

        break;

    case DIRERR_NOT_AN_OBJECT:
        // out object already became a Phantom

        *ppNewObjectName = pOldDN;
        break;
        
    case DIRERR_OBJ_NOT_FOUND:

        // No such object.
        return(SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND));

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    return 0;
}


ULONG
LockDNForRemoteOperation(
    DSNAME  *pDN
    )
/*++

  Routine Description:

    Locks a DN for the duration of a cross domain move w/o holding a 
    transaction open for the duration.  Lock should be freed via
    DBUnlockStickyDN().

  Parameters:

    pDN - Pointer to DSNAME to lock.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    DWORD       flags = (DB_LOCK_DN_WHOLE_TREE | DB_LOCK_DN_STICKY);

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    
    if ( DBLockDN(pTHS->pDB, flags, pDN) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY));
    }

    return(pTHS->errCode);
}

ULONG
MakeNamesForRemoteAdd(
    DSNAME  *pOriginalDN,
    DSNAME  *pNewParentDN,
    ATTR    *pNewRdn,
    DSNAME  **ppDestinationDN,
    DSNAME  **ppProxyDN
    )
/*++

  Routine Description:

    Construct all the names we're going to need for cross domain move.

  Parameters:

    pObject - Full name of original object AFTER name resolution. 
        I.e. GUID, SID, etc are correct.

    pNewParentDN - DSNAME of new parent after move.

    pNewRdn - RDN of moved object.

    ppDestinationDN - Pointer to DSNAME which receives destination DN.
        I.e. Has same GUID as pObject, but no SID, new string name.

    ppProxyDN - Pointer to DSNAME which receives name of local proxy object.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   cChar;
    WCHAR   pwszGuid[40];
    GUID    guid;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!fNullUuid(&pOriginalDN->Guid));

    // Construct destination DN.  New parent must have a string name.

    if ( !pNewParentDN->NameLen )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewParentDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    cChar =   // parent string name
              pNewParentDN->NameLen 
              // new RDN
            + (pNewRdn->AttrVal.pAVal[0].valLen / sizeof(WCHAR))
              // tag and delimiters
            + MAX_RDN_KEY_SIZE;

    *ppDestinationDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cChar));

    if ( AppendRDN(pNewParentDN, 
                   *ppDestinationDN, 
                   DSNameSizeFromLen(cChar),
                   (WCHAR *) &pNewRdn->AttrVal.pAVal[0].pVal[0], 
                   pNewRdn->AttrVal.pAVal[0].valLen / sizeof(WCHAR), 
                   pNewRdn->attrTyp) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewParentDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    // Destination DN should have no SID (will be assigned by destination
    // if required) and same GUID as original object.

    (*ppDestinationDN)->SidLen = 0;
    memset(&(*ppDestinationDN)->Sid, 0, sizeof(NT4SID));
    memcpy(&(*ppDestinationDN)->Guid, &pOriginalDN->Guid, sizeof(GUID));

    // Construct proxy DN.  It is an object in the "infrastructure" container
    // whose RDN is a string-ized GUID.

    if ( !gAnchor.pInfraStructureDN )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, 
                           ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER));
    }

    DsUuidCreate(&guid);
    swprintf(   pwszGuid,
                L"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x",
                guid.Data1,     guid.Data2,     guid.Data3,     guid.Data4[0],
                guid.Data4[1],  guid.Data4[2],  guid.Data4[3],  guid.Data4[4],
                guid.Data4[5],  guid.Data4[6],  guid.Data4[7]);
    cChar =   gAnchor.pInfraStructureDN->NameLen    // parent string name
            + 32                                    // new RDN
            + 10;                                   // tag and delimiters
    *ppProxyDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cChar));
    
    if ( AppendRDN(gAnchor.pInfraStructureDN,
                   *ppProxyDN,
                   DSNameSizeFromLen(cChar),
                   pwszGuid, 
                   32,
                   ATT_COMMON_NAME) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            gAnchor.pInfraStructureDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    // Clear out GUID and SID.

    (*ppProxyDN)->SidLen = 0;
    memset(&(*ppProxyDN)->Sid, 0, sizeof(NT4SID));
    memset(&(*ppProxyDN)->Guid, 0, sizeof(GUID));

    return(pTHS->errCode);
}

ULONG
CheckRidOwnership(
    DSNAME  *pDomainDN)
/*++

  Routine Description:

    Insures that we really are the RID FSMO role owner for this move.
    This is required to insure that no two replicas of the source domain
    move their copy of an object to two different domains concurrently.
    This is prevented by:

        1) A RID lock is held while performing the move - specifically
           while transitioning from a real object to a phantom.

        2) All proxy objects are created in the infrastructure container.
           This makes them easy to find for step (3).

        3) All proxy objects move with the RID FSMO.  Since the destination
           of the FSMO transfer must apply all the changes that came with the
           FSMO before claiming FSMO ownership, it will end up phantomizing
           any object which has already been moved of the prior FSMO role
           owner.  Thus there is no local object to move anymore and the 
           problem is prevented.  See logic in ProcessProxyObject in ..\dra
           for how we deal with objects that are moved out and then back
           in to the same domain.

  Parameters:

    pDomainDN - pointer to DSNAME of domain whose RID is to be locked.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE *pTHS = pTHStls;
    DSNAME  *pRidManager;
    DSNAME  *pRidRoleOwner;
    ULONG   len;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));  // product 1

    if (    DBFindDSName(pTHS->pDB, pDomainDN)
         || DBGetAttVal(pTHS->pDB, 1, ATT_RID_MANAGER_REFERENCE,
                        0, 0, &len, (UCHAR **) &pRidManager)
         || DBFindDSName(pTHS->pDB, pRidManager)
         || DBGetAttVal(pTHS->pDB, 1, ATT_FSMO_ROLE_OWNER,
                        0, 0, &len, (UCHAR **) &pRidRoleOwner) )
    {
        SetSvcError(SV_PROBLEM_DIR_ERROR,
                    DIRERR_INTERNAL_FAILURE);
    }
    else if ( !NameMatched(pRidRoleOwner, gAnchor.pDSADN) )
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_INCORRECT_ROLE_OWNER);
    }

    return(pTHS->errCode);
}

ULONG
EncryptSecretData(
    THSTATE *pTHS,
    ENTINF  *pEntinf
    )
/*++

  Description:

    This routine is called from within I_DRSInterDomainMove between the
    bind which sets up RPC session keys between source and destination and
    the actual _IDL_DRSInterDomainMove call.  In other words, we acquire
    encryption keys on the bind, then call back here to encrypt secret data,
    then ship the secret data.  There is a performance penalty in this 
    approach as we read secret attributes twice.  However, this is a much
    safer approach for now (10/22/98) rather than restructure the entire
    inter domain move code to bind first, then do all checks locally, monkey
    tranactions, etc.  Besides, not all objects have secret data and those
    that do may not have all secret attributes, so its doubtful that given
    the entire cost of moving the object to another machine that these extra
    reads are the performance killers.

  Arguments:

    pTHS - Active THSTATE.

    pEntinf - ENTINF pointer whose secret properties need to be re-read
        as fDRA so that session encryption occurs.

  Return Values:

    Win32 error code - pTHS->errCode is not set.  The call stack looks as
    follows:

        DirModifyDNAcrossDomain
            InterDomainMove
                I_DRSInterDomainMove
                    EncryptSecretData

    InterDomainMove sets pTHS->errCode as required.

--*/
{
    ULONG   i, j, inLen;
    ULONG   ret = ERROR_DS_DRA_INTERNAL_ERROR;
    ATTR    *pAttr;

    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->transactionlevel);
    Assert(!pTHS->pDB);
    Assert(pEntinf && pEntinf->pName && pEntinf->AttrBlock.attrCount);

    // First check if there even are any secret attributes thereby saving
    // the cost of a useless DBOpen.

    for ( i = 0; i < pEntinf->AttrBlock.attrCount; i++ )
    {
        if ( DBIsSecretData(pEntinf->AttrBlock.pAttr[i].attrTyp) )
        {
            break;
        }
    }

    if ( i >= pEntinf->AttrBlock.attrCount )
    {
        return(0);
    }

    DBOpen2(TRUE, &pTHS->pDB);
    pTHS->fDRA = TRUE;              // required to enable session encryption

    __try
    {
        if ( ret = DBFindDSName(pTHS->pDB, pEntinf->pName) )
        {
            __leave;
        }

        for ( i = 0; i < pEntinf->AttrBlock.attrCount; i++ )
        {
            pAttr = &pEntinf->AttrBlock.pAttr[i];

            if ( DBIsSecretData(pAttr->attrTyp) )
            {
                for ( j = 0; j < pAttr->AttrVal.valCount; j++ )
                {
                    inLen = pAttr->AttrVal.pAVal[j].valLen;

                    if ( ret = DBGetAttVal(pTHS->pDB,
                                           j + 1,
                                           pAttr->attrTyp,
                                           DBGETATTVAL_fREALLOC,
                                           inLen,
                                           &pAttr->AttrVal.pAVal[j].valLen,
                                           &pAttr->AttrVal.pAVal[j].pVal) )
                    {
                        __leave;
                    }
                }
            }
        }
    }
    __finally
    {
        DBClose(pTHS->pDB, TRUE);
        pTHS->fDRA = FALSE;
    }

    return(ret);
}

ULONG
NotifyNetlogonOfMove(
    THSTATE     *pTHS,
    DSNAME      *pObj,
    CLASSCACHE  *pCC
    )
/*++

  Description:

    Notify Netlogon of the fact that an object has left the domain.  This is
    not a synchronous notification.  Instead, data is hung off the thread
    state such that if the enclosing transaction commits, then Netlogon will
    be notified.

  Arguments:

    pTHS - Valid THSTATE pointer.

    pObj - DSNAME of object being removed.

    pCC - CLASSCACHE for object being removed.

  Return Values:

    pTHS->errCode

--*/
{
    ULONG   iSamClass;
    ULONG   iLsaClass;
    ATTRTYP lsaAttr = ATT_USER_ACCOUNT_CONTROL;

    Assert(VALID_THSTATE(pTHS));

    // Set DB position.

    if ( DBFindDSName(pTHS->pDB, pObj) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR));
    }

    // Notifications use DomainServerRoleBackup as a place holder value
    // which is ignored since the role transfer parameter is FALSE.

    if ( SampSamClassReferenced(pCC, &iSamClass) )
    {
        if (SampAddToDownLevelNotificationList(pObj, iSamClass, 0,
                                           SecurityDbDelete, FALSE,
                                           FALSE, DomainServerRoleBackup))
        {
            // 
            // the above routine failed 
            // 
            return (pTHS->errCode);
        }
    }

    if ( SampIsClassIdLsaClassId(pTHS, pCC->ClassId, 1, &lsaAttr, &iLsaClass) )
    {
         if (SampAddToDownLevelNotificationList(pObj, iSamClass, iLsaClass,
                                            SecurityDbDelete, FALSE, FALSE,
                                            DomainServerRoleBackup))
         {
             // 
             // the above routine failed 
             // 
             return (pTHS->errCode);
         }
    }

    return(pTHS->errCode);
}

VOID
LogCrossDomainMoveStatus(
    IN DWORD Severity,
    IN DWORD Mid,
    IN PWCHAR String1,
    IN PWCHAR String2,
    IN DWORD  ErrCode
    )
{
    LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
             Severity,
             Mid,
             szInsertWC(String1),
             szInsertWC(String2),
             (ErrCode == 0) ? NULL : szInsertInt(ErrCode)
             );
}

DWORD
CheckCrossDomainRemoveSecurity(
    THSTATE     *pTHS,
    DWORD       DNT,
    CLASSCACHE  *pCC,
    RESOBJ      *pResObj
    )
{
    // Position back at object.

    if ( DBFindDNT(pTHS->pDB, DNT) )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
    }

    
    CheckRemoveSecurity(FALSE, pCC, pResObj);
    return CheckObjDisclosure(pTHS, pResObj, TRUE);
     
}

ULONG
DirModifyDNAcrossDomain(
    IN  MODIFYDNARG     *pModifyDNArg,
    OUT MODIFYDNRES     **ppModifyDNRes
    )
{
    THSTATE                 *pTHS = pTHStls;
    DWORD                   i, dwErr = 0;
    READRES                 *pReadRes = NULL;
    SecBuffer               secBuffer = { 0, SECBUFFER_TOKEN, NULL };
    SecBufferDesc           clientCreds = { SECBUFFER_VERSION, 1, &secBuffer };
    DWORD                   lockDnFlags = (DB_LOCK_DN_WHOLE_TREE 
                                                | DB_LOCK_DN_STICKY);
    DWORD                   lockDnErr = 1;
    DWORD                   lockRidErr = 1;
    DWORD                   credErr = 1;
    DSNAME                  *pDestinationDN;
    DSNAME                  *pProxyDN;
    DSNAME                  *pCaseCorrectRemoteName;
    DSNAME                  *pSourceNC;
    DSNAME                  *pExpectedTargetNC;
    DSNAME                  *pMovedObjectName;
    ULONG                   dwException = 0, ulErrorCode, dsid;
    PVOID                   dwEA;
    BOOL                    fDone = FALSE;
    DBPOS                   *pDB;
    SYNTAX_DISTNAME_BINARY  *pOldProxyVal = NULL;
    DWORD                   errCleanBeforeReturn;
    CLASSCACHE              *pCC;
    BOOL                    fChecksOnly = FALSE;

    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors

    __try   // outer try/except
    {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyDNRes = THAllocEx(pTHS, sizeof(MODIFYDNRES));
        if (pTHS->errCode) {
            __leave;
        }

        // This operation should not be performed on read-only objects.
        pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

        Assert(pModifyDNArg->pDSAName);

        if (   (0 == pModifyDNArg->pObject->NameLen)
            || (NULL == pModifyDNArg->pNewParent)
            || (0 == pModifyDNArg->pNewParent->NameLen)) {
            // Demand that the caller give us string names, though they
            // may be stale and thus log entries are misleading.

            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION);
            __leave;
        }

        DPRINT2(1,"DirModifyDNAcrossDomain(%ws->%ws) entered\n",
                pModifyDNArg->pObject->StringName,
                pModifyDNArg->pNewParent->StringName);

        __try   // outer try/finally
        {
            // Empty string means to perform checks only but not 
            // the actual move.

            if ( 0 == wcslen(pModifyDNArg->pDSAName) )
            {
                fChecksOnly = TRUE;
            }
                
            // Acquire the RID FSMO lock before opening a transaction to
            // insure that the value doesn't change out from under us.
            // Can assume gAnchor.pDomainDN for product 1.

            if ( AcquireRidFsmoLock(gAnchor.pDomainDN, 3000) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;    // outer try/finally
            }
            lockRidErr = 0;

            // Note that we hold the RID FSMO lock while we are off
            // machine, but not a transaction.  It is deemed acceptable
            // to block RID FSMO operations till the remote add returns.

            Assert(0 == pTHS->transactionlevel);
            errCleanBeforeReturn = 1;
            SYNC_TRANS_READ();
            __try   // read transaction try/finally
            {
                // Read the object in all its glory and verify that it is a 
                // legal cross domain move candidate.  All pre-remote-add
                // activities are done in a single transaction for efficiency.
                // All post-remote-add activities are done in a single
                // transaction for atomicity.  If the remote add succeeds 
                // and local cleanup fails, then we will have an object with 
                // the same GUID on both sides.

                if (    // Read all attrs.
                        (dwErr = ReadAllAttrsForMove(
                                        pModifyDNArg->pObject, 
                                        &pReadRes,
                                        &(pModifyDNArg->pResObj),
                                        &pOldProxyVal))) {
		    __leave;
		}

		// Determine the object's class.
		if(!(pCC = SCGetClassById(pTHS,
					  pModifyDNArg->pResObj->MostSpecificObjClass))) {

		    SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
				DIRERR_OBJECT_CLASS_REQUIRED);
		    __leave;
		}

		// Verify delete rights.
		if( (dwErr = CheckCrossDomainRemoveSecurity(
                                                 pTHS, 
                                                 pModifyDNArg->pResObj->DNT, 
                                                 pCC,
                                                 pModifyDNArg->pResObj))
                    // Construct all the names we are going to need.
                     || (dwErr = MakeNamesForRemoteAdd(
                                            pReadRes->entry.pName,
                                            pModifyDNArg->pNewParent,
                                            pModifyDNArg->pNewRDN,
                                            &pDestinationDN,
                                            &pProxyDN))

                        // We issue a JetLock on the object, since
                        // there is a possibility that before we take this lock, 
                        // and after this trans is opened, the object can be changed
                     || DBClaimReadLock(pTHS->pDB)
                        // Lock the string name w/o holding a transaction open.
                     || (dwErr = lockDnErr = LockDNForRemoteOperation(
                                        pReadRes->entry.pName))
                        // Check if object can be legally moved.
                     || (dwErr = VerifyObjectForMove(
                                        pTHS,
                                        pReadRes, 
                                        pDestinationDN,
                                        &pSourceNC,
                                        &pExpectedTargetNC,
                                        &pCC))
                        // Another check if object can be legally moved.
                     || (dwErr = NoDelCriticalObjects(pModifyDNArg->pResObj->pObj, 
                                                      pModifyDNArg->pResObj->DNT))
                        // Make sure object is childless.
                     || (dwErr = (fChecksOnly
                                    ? 0
                                    : NoChildrenExist(pModifyDNArg->pResObj)))
                     || (dwErr = CheckRidOwnership(pSourceNC)) )
                {
                    __leave; // read transaction try/finally
                }

                errCleanBeforeReturn = 0;
            }
            __finally   // read transaction try/finally
            {
                CLEAN_BEFORE_RETURN(errCleanBeforeReturn);
            }

            if ( errCleanBeforeReturn || pTHS->errCode )
            {
                if ( !pTHS->errCode )
                {
                    SetSvcError(SV_PROBLEM_DIR_ERROR, 
                                DIRERR_INTERNAL_FAILURE);
                }

                __leave; // outer try/finally
            }

            // Bail now if we were only to check whether object can be moved.

            if ( fChecksOnly )
            {
                fDone = TRUE;
                __leave;    // outer try/finally
            }

            // GetRemoteAddCredentials and DRSRemoteAdd go off machine,
            // therefore verify there is no transaction open.
            Assert(0 == pTHS->transactionlevel);

            if (    // Get client creds for delegation at destination.
                    (dwErr = credErr = GetRemoteAddCredentials(
                                            pTHS,
                                            pModifyDNArg->pDSAName,
                                            &clientCreds))
                // Ask remote side to add object with same GUID and new name.
                || (dwErr = InterDomainMove(pModifyDNArg->pDSAName,
                                            &pReadRes->entry,
                                            pDestinationDN,
                                            pExpectedTargetNC,
                                            &clientCreds,
                                            &pCaseCorrectRemoteName)) ) 
            {
                Assert(dwErr == pTHS->errCode);
                __leave; // outer try/finally
            }

            // Remote add went OK - do local cleanup in one transaction.
            // We know that failure to perform local cleanup results in 
            // the same object in both source and destination domain.
            // xdommove.doc documents how the admin should clean this
            // up - delete src object.  But in the hopes that this is
            // strictly a transient resource error, we try 3 times
            // at one second intervals.

            Assert(!pTHS->errCode && !dwErr);

            for ( i = 0; i < 3; i++ )
            {
                if ( i )
                {
                    Sleep(1000);    // delay on all but first attempt
                }

                dwErr = 0;
                THClearErrors();

                // We need to handle our own exceptions here, not just
                // clean up in a __finally.  This is so that we are guaranteed
                // to reach the error mapping code which sets the distinguished
                // ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD error code.  Otherwise
                // we would blow out to the outer __except and end up failing
                // to inform the caller that cleanup is required.

                __try   // catch exceptions
                {
                    errCleanBeforeReturn = 1;
                    SYNC_TRANS_WRITE();
                    __try   // write transaction try/finally
                    {
                        // Do all cleanup as fDSA so as to avoid access checks.
        
                        pTHS->fDSA = TRUE;
        
                        // First notify Netlogon of the deletion.  This just
                        // adds a notification struct to the THSTATE and needs
                        // to happen before phantomization while the object
                        // still has properties left to read.

                        // Second cleanup item is to phantomize the old object.
                        // We do this even if we're a GC as the add in the dst
                        // domain will get back to us eventually and thus we
                        // don't need to fiddle with partial attribute sets,
                        // etc.

                        // Third cleanup item is to create a proxy object.
                        // CreateProxyObject requires a NULL guid in the 
                        // DSNAME.  If we're in the retry case, then the 
                        // prior DirAddEntry filled it in, so clear it always.


                        // by now the original object might have changed name
                        // this can happen if somebody renames the parent of this 
                        // object. we have better re-read the object from 
                        // the database

                        memset(&pProxyDN->Guid, 0, sizeof(GUID));

                        if (    (dwErr = ReReadObjectName (
                                            pTHS,
                                            pReadRes->entry.pName, 
                                            &pMovedObjectName))
                             || (dwErr = NotifyNetlogonOfMove(
                                            pTHS, pMovedObjectName, pCC))
                             || (dwErr = PhantomizeObject(
                                            pMovedObjectName,
                                            pCaseCorrectRemoteName,
                                            FALSE))
                             || (dwErr = CreateProxyObject(
                                            pProxyDN,
                                            pDestinationDN,
                                            pOldProxyVal)) )
                        {
                            __leave; // write transaction try/finally
                        }

                        errCleanBeforeReturn = 0;
                    }
                    __finally   // write transaction try/finally
                    {
                        pTHS->fDSA = FALSE;
                        CLEAN_BEFORE_RETURN(errCleanBeforeReturn);
                    }
                }
                __except(GetExceptionData(GetExceptionInformation(), 
                                          &dwException, &dwEA, 
                                          &ulErrorCode, &dsid))
                {
                    HandleDirExceptions(dwException, ulErrorCode, dsid);
                }

                if ( !errCleanBeforeReturn && !pTHS->errCode )
                {
                    break;      // success case!
                }
            }

            if ( errCleanBeforeReturn || pTHS->errCode )
            {
                // Know we have string names in args, thus can log them.

                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CROSS_DOMAIN_MOVE_CLEANUP_REQUIRED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         pTHS->errCode ? Win32ErrorFromPTHS(pTHS)
                             : ERROR_DS_INTERNAL_FAILURE);

                // Map error to a distinct "administrative cleanup required"
                // error code.  Make sure not to use SV_PROBLEM_BUSY else
                // LDAP head will retry the DirModifyDN call without the 
                // caller knowing it.  This second DirModifyDN will
                // get all the way to the destination, the destination (who
                // already has the object since the remote add succeeded the
                // first time around) will return a duplicate object error,
                // this is returned back to the client, and now the client
                // does not realize that the first call failed and cleanup
                // is required!  We'll have the same problem should wldap32.dll
                // ever retry on LDAP_BUSY errors.

                THClearErrors();
                dwErr = SetSvcError(SV_PROBLEM_DIR_ERROR, 
                                    ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD);
                __leave;    // outer try/finally
            }

            Assert(!dwErr && !pTHS->errCode);
            fDone = TRUE;
        }
        __finally   // outer try/finally
        {
            if ( !lockDnErr ) {
                DBUnlockStickyDN(pModifyDNArg->pObject);
            }

            if ( !lockRidErr ) {
                ReleaseRidFsmoLock(gAnchor.pDomainDN);
            }
    
            if ( !credErr ) {
                FreeRemoteAddCredentials(&clientCreds);
            }

            // Know we have string names in args, thus can log them.

            if ( pTHS->errCode || AbnormalTermination() )
            {
                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_CROSS_DOMAIN_MOVE_FAILED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         Win32ErrorFromPTHS(pTHS));
            }
            else if ( !fChecksOnly )
            {
                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_CROSS_DOMAIN_MOVE_SUCCEEDED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         0);
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) 
    {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if ( *ppModifyDNRes ) 
    {
        (*ppModifyDNRes)->CommRes.errCode = pTHS->errCode;
        (*ppModifyDNRes)->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    Assert(pTHS->errCode ? !fDone : fDone);
    return(pTHS->errCode);
}

//============================================================================
//
//                      DN Modification Within the Same Domain
//
//============================================================================

ULONG
DirModifyDNWithinDomain (
    MODIFYDNARG*  pModifyDNArg,
    MODIFYDNRES** ppModifyDNRes
        )
{
    THSTATE*       pTHS;
    MODIFYDNRES  * pModifyDNRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;


    DPRINT2(1,"DirModifyDNWithinNC(%ws->%ws) entered\n",
        pModifyDNArg->pObject->StringName,
        pModifyDNArg->pNewParent->StringName);


    // This operation should not be performed on read-only objects.
    pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

    // Initialize the THSTATE anchor and set a write sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyDNRes = pModifyDNRes = THAllocEx(pTHS, sizeof(MODIFYDNRES));
        if (pTHS->errCode) {
            __leave;
        }
        SYNC_TRANS_WRITE();                   // Set Sync point
        __try {
    
            // Inhibit update operations if the schema hasen't been loaded yet
            // or if we had a problem loading.

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, DIRERR_SCHEMA_NOT_LOADED);
                goto ExitTry;
            }
    
            // Perform name resolution to locate object.  If it fails, just
            // return an error, which may be a referral.  Note that we must
            // demand a writable copy of the object.
            pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               NAME_RES_IMPROVE_STRING_NAME,
                               pModifyDNArg->pObject,
                               &pModifyDNArg->CommArg,
                               &pModifyDNRes->CommRes,
                               &pModifyDNArg->pResObj)){

                // DoNameRes should have left us with a valid stringname
                Assert(pModifyDNArg->pResObj->pObj->NameLen);
                
                // Local Modify operation

                LocalModifyDN(pTHS,
                              pModifyDNArg,
                              pModifyDNRes);
            }

            ExitTry:;
        }
        __finally {
            if (pTHS->errCode != securityError) {
                // Security errors are logged separately
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ? 
                           DS_EVENT_SEV_EXTENSIVE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ? 
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pModifyDNArg->pObject),
                         NULL,
                         FILENO);
            }

            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pModifyDNRes) {
        pModifyDNRes->CommRes.errCode = pTHS->errCode;
        pModifyDNRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

} // DirModifyDN*/


int
CheckNameForRename(
        IN  THSTATE    *pTHS,
        IN  RESOBJ     *pResParent,
        IN  WCHAR      *pRDN,
        IN  DWORD       cchRDN,
        IN  DSNAME     *pDN
        )
/*++

Routine Description:

    Verify the given DSNAME is a valid name for an object to be renamed to;
    i.e., that it does not conflict with those of existing objects.

    NOTE: If you change this function, you may also want to change its sister
    function, CheckNameForAdd().

Arguments:

    pTHS - thread state
    pResParent - resobj for the proposed new (or existing, if just a rename, not
           a move) parent.
    pRDN - the RDN of the new name for the object.
    cchRDN - characters in pRDN.
    pDN (IN) - the proposed new name for an object.  Just used for error
             reporting. Should be the DN of pResParent + the RDN in pRDN.

Return Values:

    Thread state error code.

--*/
{
    DBPOS *     pDB = pTHS->pDB;
    ULONG       dbError;
    GUID        PhantomGuid;


    // Now, get the type from the name
    dbError = DBFindChildAnyRDNType(pTHS->pDB, pResParent->DNT, pRDN, cchRDN);
    
    switch ( dbError ) {
    case 0:
        // Local object with this name (dead or alive) already
        // exists.
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS, DIRERR_OBJ_STRING_NAME_EXISTS);
        break;

    case ERROR_DS_KEY_NOT_UNIQUE:
        // No local object with this name (dead or alive) already
        // exists, but one with the same key in the PDNT-RDN table exists.  In
        // that case, we don't allow the add (since the DB would bounce this
        // later anyway).
        SetUpdError(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_KEY_NOT_UNIQUE);
        break;    

    case DIRERR_OBJ_NOT_FOUND:
        // New name is locally unique.
        break;

    case DIRERR_NOT_AN_OBJECT:
        DPRINT2(1,
                "Found phantom for \"%ls\" @ DNT %u when searching by string name.\n",
                pDN->StringName, pDB->DNT);

        // Found a phantom with this name; get its GUID (if any).
        dbError = DBGetSingleValue(pDB, ATT_OBJECT_GUID, &PhantomGuid,
                                   sizeof(PhantomGuid), NULL);

        // Note that regardless of type, we're going to mangle the RDN value of
        // the existing phantom
        switch (dbError) {
        case DB_ERR_NO_VALUE:
            // Phantom has no guid; make one up.

            // In this case we could subsume the phantom by changing
            // all references to it to point to the DNT of the object we're
            // renaming then destroying the phantom, but for now we'll
            // simply rename it like we would a guided phantom.  If we ever
            // change to subsume, we need to add code here to check types.

            DsUuidCreate(&PhantomGuid);
            // Fall through...

        case 0:
            // The phantom either has no guid or has a guid that is
            // different from that of the object we're renaming.

            // Allow the object we're renaming to take ownership of the
            // name -- rename the phantom to avoid a name conflict, then
            // allow the rename to proceed.

            if ((dbError = DBMangleRDN(pDB, &PhantomGuid)) ||
                (dbError = DBUpdateRec(pDB))) {
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dbError);
            }
            break;

        default:
            // Unforeseen error return from DBGetSingleValue()
            // while trying to retrieve the phantom's GUID.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, dbError);
            break;
        }
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:
    default:
        // Bad object name.
        SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN, DIRERR_BAD_NAME_SYNTAX);
        break;
    }

    return pTHS->errCode;
}


//============================================================================
//
//                      DN Modification - Common Helper Routine
//
//============================================================================

// Find the object, check that the new name is ok, then change the object's
// name.

int
LocalModifyDN (THSTATE *pTHS,
               MODIFYDNARG *pModifyDNArg,
               MODIFYDNRES *pModifyDNRes
               )
{
    CLASSCACHE     *pCC;
    ATTCACHE       *pACSD;
    DSNAME         *pParentName = NULL;
    DSNAME         *pNewerName = NULL;
    DWORD          InstanceType;
    DWORD          ulNCDNT, ulNewerNCDNT;
    DWORD          err;
    DWORD          cbSec=0;
    PSECURITY_DESCRIPTOR pNTSD = NULL, pSec = NULL, *ppNTSD;
    ULONG          cbNTSD, ulLen, cAVA, LsaClass;
    BOOL           fMove, fRename, fSameName, fDefunct;
    DWORD          ActiveContainerID;
    unsigned       i;
    DSNAME         *pObjName = pModifyDNArg->pResObj->pObj;
    WCHAR          *pwNewRDNVal=NULL;
    DWORD           cchNewRDNVallen;
    BOOL           fFreeParentName = FALSE;
    BOOL           fNtdsaAncestorWasProtected;
    
    DPRINT2(1,"LocalModifyDN(%ws->%ws) entered\n",
            pObjName->StringName,
            pModifyDNArg->pNewParent->StringName);

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    // Callers guarantee that we have a resobj.  Furthermore, the pObj in the
    // resobj is guaranteed to have a string DN, pModifyDNArg->pObject is not
    // guaranteed to have the string name.  Therefore, we use
    // pModifyDNArg->pResObj->pObj exclusively in this routine.
    Assert(pModifyDNArg->pResObj);
    Assert(pObjName->NameLen);


    // These are for maintainance convenience, it's easier to read.
    pwNewRDNVal = (WCHAR *)pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal;
    cchNewRDNVallen = (pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen/
                       sizeof(WCHAR));
    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_MODIFYDN,
                     EVENT_TRACE_TYPE_START,
                     DsGuidModDN,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pObjName),
                     ((pModifyDNArg->pNewParent != NULL) ?
                      szInsertDN(pModifyDNArg->pNewParent) :
                      szInsertSz("")), 
                     szInsertWC2(pwNewRDNVal, cchNewRDNVallen),
                     NULL, NULL, NULL, NULL);
    
    // First, get the security descriptor for this object.
    pACSD = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
    if (DBGetAttVal_AC(pTHS->pDB, 1, pACSD,
                       0, 0,
                       &cbSec, (PUCHAR *)&pSec))
    {
        // Every object EXCEPT AUTO SUBREFS should have an SD, and those should
        // be renamed only by replication.
        Assert(pTHS->fSingleUserModeThread || DBCheckObj(pTHS->pDB));
        Assert(pTHS->fDRA || pTHS->fSingleUserModeThread);
        Assert(CLASS_TOP == pModifyDNArg->pResObj->MostSpecificObjClass);

        cbSec = 0;
        pSec = NULL;
    }

    // Determine the object's class.
    if(!(pCC = SCGetClassById(pTHS,
                              pModifyDNArg->pResObj->MostSpecificObjClass))) {
	SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
		    DIRERR_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    if (pTHS->fDRA) {
        // The replicator can move things under deleted objects
        pModifyDNArg->CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    // Compute the current parent's name
    pParentName = (DSNAME *)THAllocEx(pTHS,
                                      pObjName->structLen); 
    fFreeParentName = TRUE;
    TrimDSNameBy(pObjName, 1, pParentName);
    
    if(pModifyDNArg->pNewParent &&
       !NameMatched(pParentName, pModifyDNArg->pNewParent)) {
        // We are moving the object to a new parent.
        fMove = TRUE;

        // First, set ppNTSD to a non-null value.  ppNTSD is passed to
        // CheckParentSecurity, and a non-null value for this directs
        // CheckParentSecurity to do an access check for RIGHT_DS_ADD_CHILD.
        ppNTSD = &pNTSD;

        // Now, set up a pointer to the parents name.
        THFreeEx(pTHS, pParentName);
        fFreeParentName = FALSE;
        pParentName = pModifyDNArg->pNewParent;

    }
    else {
        // No new parent has been specified.  Set up some place holder values
        // so that the rest of the function doesn't care whether or not a new
        // parent was given.  Note that pParentName already points to the old
        // (and hence also the new) parent object's name.
        fMove = FALSE;
        ppNTSD = NULL;
    }
    
    // Look up the new parent
    if (err = DoNameRes(pTHS,
                        pModifyDNArg->fAllowPhantomParent ? 
                            (NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED) : 0,
                        pParentName,
                        &pModifyDNArg->CommArg,
                        &pModifyDNRes->CommRes,
                        &pModifyDNArg->pResParent)) {
        SetUpdError(SV_PROBLEM_BUSY,DIRERR_NO_PARENT_OBJECT);
        goto exit;
    }

    // Make sure we have appropriate rights to change the name of the object.
    if(CheckRenameSecurity(pTHS, pSec, pObjName, pCC,
                           pModifyDNArg->pResObj,
                           pModifyDNArg->pNewRDN->attrTyp,
                           fMove,
                           pModifyDNArg->pResParent)) {
        goto exit;
    }

    if(!pModifyDNArg->pNewRDN ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen ||
       pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen > ( MAX_RDN_SIZE *
                                                       sizeof(WCHAR)))  {
        // What? No RDN?  Hey, ya gotta give me an RDN, even if it is the same
        // as the current RDN.
        // Or, Hey! I don't take 0 length RDNs!
        // Or, Hey! That RDN is too long!
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
		    DIRERR_ILLEGAL_MOD_OPERATION);
	goto exit;
    }
    
    //
    // Go back to being positioned on the object being moved.
    //
    DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);

    // Check to see if this is an update in an active container
    CheckActiveContainer(pModifyDNArg->pResObj->PDNT, &ActiveContainerID);
    
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(pTHS,
                                     ACTIVE_CONTAINER_FROM_MODDN,
                                     pObjName,
                                     pCC,
                                     ActiveContainerID)) {
            goto exit;
        }
    }

    // Check if the class is defunct,
    // We do not allow any modifications on instances of defunct classes.
    // return same error as if the object class is not found

    // DSA and DRA threads are exempt from this

    if ( pCC->bDefunct && !pTHS->fDSA && !pTHS->fDRA ) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    DIRERR_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    // Check if it is a schema object rename. If it is, we need to
    // check that (1) we are not trying to rename a base schema object and 
    // (2) we are not trying to rename a defunct class/attribute.
    // If so, return appropriate error
    // (Again, DSA and DRA threads are allowed to do this
    // or if we have the special registry key set (the function checks that)

    if ( (pCC->ClassId == CLASS_ATTRIBUTE_SCHEMA) ||
           (pCC->ClassId == CLASS_CLASS_SCHEMA) ) {

         err = 0;
         err = CheckForSchemaRenameAllowed(pTHS);
         if (err) {
            // not allowed. error code is already set in thread state
            goto exit;
         } 
  
        // Signal a urgent replication. We want schema changes to
        // replicate out immediately to reduce the chance of a schema
        // change not replicating out before the Dc where the change is
        // made crashes

        pModifyDNArg->CommArg.Svccntl.fUrgentReplication = TRUE;
    }

    // only LSA can modify TrustedDomainObject and Secret Object
    if (!SampIsClassIdAllowedByLsa(pTHS, pCC->ClassId))
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // Don't allow renames/moves of tombstones, except if caller is the
    // replicator.
    if (pModifyDNArg->pResObj->IsDeleted && !pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
    }

    // So it is either not a schema object at all, or a rename is allowed
    // Proceed as usual

    // Get the NCDNT of the current object.
    ulNCDNT = pModifyDNArg->pResObj->NCDNT;

    // Use the object rdnType and not the object's class rdnattid
    // because a superceding class may have a different rdnattid
    // than the superceded class had when this object was created.
    if (!pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        ATTRTYP OldAttrTyp;
        extern int GetRdnTypeForDeleteOrRename (IN THSTATE  *pTHS,
                                                IN DSNAME   *pObj,
                                                OUT ATTRTYP *pRdnType);

         if (GetRdnTypeForDeleteOrRename(pTHS,
                                         pModifyDNArg->pResObj->pObj,
                                         &OldAttrTyp)) {
             goto exit;
         }
        // Wrong attribute for RDN
        if (OldAttrTyp != pModifyDNArg->pNewRDN->attrTyp) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
            goto exit;
        }
    }

    // Get the name of the new object by appending the new RDN to the
    // (potentially new) parent name.
    // First allocate memory for pNewerName. Allocate more than enough space
    pNewerName = (DSNAME *)THAllocEx(pTHS,pParentName->structLen +
                              (4+MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)) );
    AppendRDN(pParentName,
              pNewerName,
              pParentName->structLen
              + (4+MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)),
              pwNewRDNVal,
              cchNewRDNVallen,
              pModifyDNArg->pNewRDN->attrTyp);

    // Make sure the RDN is well formed.
    // Replication excluded so that we can have BAD_NAME_CHAR in RDN of
    // morphed names
    if (    !pTHS->fDRA
            && fVerifyRDN(pwNewRDNVal,cchNewRDNVallen) ) {
        SetNamError(NA_PROBLEM_NAMING_VIOLATION, pNewerName, DIRERR_BAD_ATT_SYNTAX);
        goto exit;
    }

    // For the sake of future simplicity, figure out now whether or not
    // the user is requesting that the RDN be changed
    {
        WCHAR RDNold[MAX_RDN_SIZE];
        ATTRTYP oldtype;
        ULONG oldlen;

        GetRDNInfo(pTHS,
            pObjName,
            RDNold,
            &oldlen,
            &oldtype);
        oldlen *= sizeof(WCHAR);

        if (   (oldlen != (cchNewRDNVallen * sizeof(WCHAR)))
            || memcmp(RDNold,
                      pwNewRDNVal,
                      oldlen)) {
            fRename = TRUE;
        }
        else {
            fRename = FALSE;
        }
    }

    // Is the new name the same as the old name (case-insensitive)?
    fSameName = NameMatched(pObjName, pNewerName);

    // Make sure new object name is not a descendant of the original object.
    if (!fSameName && NamePrefix(pObjName,pNewerName)) {
        // Yep, trying to move an object to be its own descendant.  Can't let
        // you do that.
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // lock the DN against multiple simultaneous insertions
    if (!fSameName
         && (pNewerName->NameLen > 2)
         && DBLockDN(pTHS->pDB, 0, pNewerName)) {
        // Someone's trying to use the new name.
        SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        goto exit;
    }

    // If we are reparenting, tree-lock the original object to avoid someone
    // moving an ancestor of the new name to be a descendant of the original
    // object, thus creating a disconnected cycle in the DIT.
    if((pObjName->NameLen > 2)
        && DBLockDN(pTHS->pDB, DB_LOCK_DN_WHOLE_TREE,
                    pObjName)) { 
        // Can't tree lock the object.  Oh, well, go home, since the
        // move can't be guaranteed to be safe.
        SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        goto exit;
    }
    
    // Get instance type since it is needed in both the DsaIsRunning and
    // DsaIsInstalling cases.
    InstanceType = pModifyDNArg->pResObj->InstanceType;

    if ( DsaIsRunning() && !pTHS->fSingleUserModeThread) {
        // Some extra checks that we don't bother doing when we are installing,
        // therefore allowing the install phase to violate some rules.
        // Single User Mode can also violate these checks

        // See if the instance type of the object will allow a rename

        if (    ( (InstanceType & IT_NC_HEAD) && (fMove || !pTHS->fDRA) )
             || ( !(InstanceType & IT_WRITE) && !pTHS->fDRA )
           )
        {
            // DRA can change the case of an NC head and rename and/or move
            // read-only objects.  Otherwise operations on NC heads and
            // read-only objects are disallowed.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE);
            goto exit;
        }

        // Check for various restrictions on moves and renames in
        // sensitive portions of the tree
        if (pTHS->fDRA) {
            // Don't argue with the replicator, let him pass.
            ;
        }
        else if (ulNCDNT == gAnchor.ulDNTDMD && fMove) {
                // Can't move objects in schema NC, but renames are ok
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC);
                goto exit;
        }
        else if (ulNCDNT == gAnchor.ulDNTConfig) {
            // Sigh.  The config NC is more complicated.  We allow moves
            // and renames only if certain bits are set on the object.
            ULONG ulSysFlags;

            err = DBGetSingleValue(pTHS->pDB,
                   ATT_SYSTEM_FLAGS,
                   &ulSysFlags,
                   sizeof(ulSysFlags),
                   NULL);
            if (err) {
                // An error means no value, which is flags of 0.
                ulSysFlags = 0;
            }
            
            if ((fMove && !(ulSysFlags &
                            (FLAG_CONFIG_ALLOW_MOVE |
                             FLAG_CONFIG_ALLOW_LIMITED_MOVE))) ||
                (fRename && !(ulSysFlags & FLAG_CONFIG_ALLOW_RENAME) 
                 && !IsExemptedFromRenameRestriction(pTHS, pModifyDNArg))) {
                // If the object had no flags set (and is not an exempted
                // rename), or we want to move and the move-allowed bit isn't
                // set, or we want to rename and the rename allowed bit isn't
                // set & the rename operation is not exempted from rename
                // restrictions, fail the op. 

                SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                              ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                              ulSysFlags);
                goto exit;
            }

            if (fMove && !(ulSysFlags & FLAG_CONFIG_ALLOW_MOVE)) {
                // Ok, one last test.  We want to move the object, and
                // moves are not forbidden on this object, but we restrict
                // moves on this object to only being to sibling containers.
                // That is, although we allow the object to change parent
                // containers, we do not allow it to change grandparent
                // containers.  Even further confusion has dorked around
                // with exactly what level of ancestor we demand to have
                // in common, so this is now controlled with a single define,
                // where 1 would be parent, 2 grandparent, 3 great-grandparent,
                // etc.
                // Yes, this is an ad hoc (some might say "ad hack") mechanism
                // to solve a nagging problem of how to control structure
                // in the DS, but, well, I couldn't think of anything better.
                #define ANCESTOR_LEVEL 3
                unsigned cNPold, cNPnew;
                DSNAME *pGrandParentOld, *pGrandParentNew;
    
                Assert(ulSysFlags & FLAG_CONFIG_ALLOW_LIMITED_MOVE);
    
                if (CountNameParts(pObjName, &cNPold) ||
                    CountNameParts(pNewerName, &cNPnew) ||
                    (cNPold != cNPnew) ||
                    (cNPold < ANCESTOR_LEVEL)) {
                    // Either we couldn't parse one of the names, or
                    // the new and old names are at different levels,
                    // or we're too close to the root.
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_MODIFYDN_WRONG_GRANDPARENT);
                    goto exit;
                }
    
                // We now know we're trying to move to an equal depth,
                // so we just have to test if it's the same grandparent
                pGrandParentOld =
                        THAllocEx(pTHS, pObjName->structLen);
    
                pGrandParentNew =
                        THAllocEx(pTHS, pParentName->structLen);
                    
                TrimDSNameBy(pObjName,
                         ANCESTOR_LEVEL,
                         pGrandParentOld);
                TrimDSNameBy(pParentName,
                         ANCESTOR_LEVEL - 1,
                         pGrandParentNew);
                if (!NameMatched(pGrandParentOld, pGrandParentNew)) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_MODIFYDN_WRONG_GRANDPARENT);
                }
                THFreeEx(pTHS, pGrandParentOld);
                THFreeEx(pTHS, pGrandParentNew);
                if (pTHS->errCode) {
                    goto exit;
                }
                #undef ANCESTOR_LEVEL
            }
        }
        else {
            // For any other container, we check for some other bits that
            // control whether we allow renames (the default behaviour is
            // reversed from the behaviour of the ConfigNC).  That is,
            // we disallow moves and renames only if certain bits are set on the
            // object. 
            ULONG ulSysFlags;
    
            err = DBGetSingleValue(pTHS->pDB,
                       ATT_SYSTEM_FLAGS,
                       &ulSysFlags,
                       sizeof(ulSysFlags),
                       NULL);
            if (!err) {
                // We have system flags.
                if(fRename && (ulSysFlags & FLAG_DOMAIN_DISALLOW_RENAME)
                    && !IsExemptedFromRenameRestriction(pTHS, pModifyDNArg)) {
                        // We're trying to rename, but the rename flag is set and 
                        // the current rename operation is not exempted from rename
                        // restrictions, which
                        // means we aren't allowed to do this.
    
                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                                      ulSysFlags);
                        goto exit;
                }
                    
                if (fMove && (ulSysFlags & FLAG_DOMAIN_DISALLOW_MOVE)) {
                    // Moves are restricted, return an error.
                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                                  ulSysFlags);
                    goto exit;
                }
            }
        }
    }

    // Make sure that the object doesn't already exist
    if (!fSameName &&
        CheckNameForRename(pTHS,
                           pModifyDNArg->pResParent,
                           pwNewRDNVal,
                           cchNewRDNVallen,
                           pNewerName)) {
        Assert(pTHS->errCode);
        goto exit;
    }

    
    // CheckParentSecurity has ensured that the parent exists and is alive.

    // What's the appropriate NCDNT for the object if we rename it?
    // NOTE: Ok to ALLOW_DELETED_PARENT in subsequent call as if we are not
    // fDRA, then prior CheckParentSecurity would have returned an error.

    if (!pTHS->fSingleUserModeThread) {
        if ( InstanceType & IT_NC_HEAD )
        {
            // Only replication is allowed to perform renames of NC heads, and
            // moves are disallowed even for replication.
            Assert( pTHS->fDRA || pTHS->fSingleUserModeThread);
            Assert( !fMove || pTHS->fSingleUserModeThread);
    
            ulNewerNCDNT = ulNCDNT;
        }
        else {
            if ( FindNcdntFromParent(pModifyDNArg->pResParent,
                                     FINDNCDNT_ALLOW_DELETED_PARENT,
                                     &ulNewerNCDNT
                                     )
                ){
                // Failed to derive NCDNT for the new name.
                // This should never happen, as above we verified that a qualified
                // parent exists, and that should be the only reason we could fail.
                Assert( !"Failed to derive NCDNT for new name!" );
                goto exit;
            }
    
            if((ulNCDNT != ulNewerNCDNT) &&
               (!pTHS->fDSA || DsaIsRunning())) {
                // The move is outside the NC and we are not the DSA or we are the
                // dsa but we are installed.  In that case, you can't move the
                // object as requested.
    
                // BUG: Reset the service error to cross-NC specific code for
                // subsequent cross-domain move.
    
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_ILLEGAL_MOD_OPERATION); 
                goto exit;
            }
        }
    }

    // CheckNameForRename moved us, but we're done there,
    // so move back
    DBFindDNT(pTHS->pDB,pModifyDNArg->pResObj->DNT);

    // Update the RDN
    if(ReSetNamingAtts(pTHS,
                       pModifyDNArg->pResObj,
                       fMove ? pModifyDNArg->pNewParent : NULL,
                       pModifyDNArg->pNewRDN,
                       TRUE,
                       pModifyDNArg->fAllowPhantomParent,
                       pCC)
       ||
       // Insert the object into the database for real.
       InsertObj(pTHS,
                 pObjName,
                 pModifyDNArg->pMetaDataVecRemote,
                 TRUE,
                 META_STANDARD_PROCESSING)) {
        goto exit;
    }

    // Only notify replicas if this is not the DRA thread. If it is, then
    // we will notify replicas near the end of DRA_replicasync. We can't
    // do it now as NC prefix is in inconsistent state

    if (!pTHS->fDRA && DsaIsRunning()) {
        // Currency of DBPOS must be at the target object
        DBNotifyReplicasCurrDbObj(pTHS->pDB,
                           pModifyDNArg->CommArg.Svccntl.fUrgentReplication );
    }

    // If this changed anything in the ancestry of the DSA object, we
    // need to recache junk onto the anchor, check for change of site, etc.
    // If an undeletable object changes its parentage, or one of the ancestors
    // of an undeletable object changes its parentage, rebuild the anchor
    // so that the list of undeletable's ancestors is updated
    if (fMove &&
        fDNTInProtectedList( pModifyDNArg->pResObj->DNT,
                             &fNtdsaAncestorWasProtected )) {
        if (fNtdsaAncestorWasProtected) {
            pTHS->fNlSiteNotify = TRUE;
        }
        pTHS->fAnchorInvalidated = TRUE;
    }

    // check to see if we are messing with an NC head for domain rename
    //
    if ((InstanceType & IT_NC_HEAD) && pTHS->fSingleUserModeThread) {
        DWORD  oldInstanceType = InstanceType;
        DWORD  oldNCDNT, newNCDNT, cb;

        Assert (pTHS->fSingleUserModeThread);
        DPRINT1 (0, "LocalModifyDn messing up with an NC head: %x\n", InstanceType);

        if (pModifyDNArg->pResParent->InstanceType & IT_NC_HEAD) {

            // our parent is an NC_HEAD, so we should have IT_NC_ABOVE set
            //
            if ( !(InstanceType & IT_NC_ABOVE) ) {
                InstanceType |= IT_NC_ABOVE;
            }
        }
        // our parent is not a NC head, so we should not have the NC_ABOVE set
        else if (InstanceType & IT_NC_ABOVE) {
            InstanceType ^= IT_NC_ABOVE;
        }


        // Derive the NCDNT.
        if ( FindNcdntSlowly(
                pNewerName,
                FINDNCDNT_DISALLOW_DELETED_PARENT,
                FINDNCDNT_ALLOW_PHANTOM_PARENT,
                &newNCDNT
                )
           )
        {
            // Failed to derive NCDNT.
            Assert(!"Failed to derive NCDNT");
            Assert(0 != pTHS->errCode);
            return pTHS->errCode;
        }


        // move to the object
        DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);
        
        err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_NCDNT, &oldNCDNT, sizeof (oldNCDNT), &cb);
        if (err) {
            Assert (FALSE);
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
            goto exit;
        }

        if (oldInstanceType != InstanceType) {

            DPRINT1 (0, "New Instancetype: %x\n", InstanceType);
            Assert (ISVALIDINSTANCETYPE (InstanceType));

            err = DBReplaceAttVal(pTHS->pDB, 1, ATT_INSTANCE_TYPE, sizeof (InstanceType), &InstanceType);

            switch(err) {
            case 0:
                // nothing to do.
                break;
            default:
                Assert (FALSE);
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                goto exit;
                break;
            }

            DBUpdateRec(pTHS->pDB);

            // this is similar to ModCheckCatalog
            // the difference is in the order of Dns passed.
            // we need the old one for the delete and the new one for the add
            // otherwise it fails with object not found

            if (err = DelCatalogInfo(pTHS, pModifyDNArg->pResObj->pObj, oldInstanceType)){
                DPRINT1(0,"Error while deleting global object info\n", err);
                goto exit;
            }

            if (err = AddCatalogInfo(pTHS, pNewerName)) {
                DPRINT1(0,"Error while adding global object info\n", err);
                goto exit;
            }
        }

        if (newNCDNT != oldNCDNT) {

            DPRINT2 (0, "Updating NCDNT for object: old/new NCDNT: %d / %d \n", oldNCDNT, newNCDNT );
            
            DBResetAtt(
                    pTHS->pDB,
                    FIXED_ATT_NCDNT,
                    sizeof( newNCDNT ),
                    &newNCDNT,
                    SYNTAX_INTEGER_TYPE
                    );

            DBUpdateRec(pTHS->pDB);
        }
    }


exit:
    if (pSec) {
        THFreeEx(pTHS, pSec);
    }
    if (fFreeParentName) {
        THFreeEx(pTHS, pParentName);
    }

    THFreeEx(pTHS, pNewerName);
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_MODIFYDN,
                     EVENT_TRACE_TYPE_END,
                     DsGuidModDN,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;            // incase we have an attribute error

} /*LocalModifyDN*/


int 
CheckForSchemaRenameAllowed(
    THSTATE *pTHS
    )

/*++
   Routine Description:
      Checks if the schema object is either a base schema object, or if it is
      defunct. Rename is not allowed in either case.
      fDSA, fDRA, and if the special registry key is set, are exempt

   Arguments:
      pTHS -- pointer to thread state
 
   Return Value:
      The error code set in the thread state  
--*/

{
    BOOL fDefunct, fBaseSchemaObj;
    ULONG sysFlags, err = 0;

    // All is allowed if fDSA or fDRA is set, or if the special registry flag 
    // to allow all changes is set

    if (pTHS->fDSA || pTHS->fDRA || gAnchor.fSchemaUpgradeInProgress) {
       return 0;
    }

    // Check if it is a base schema object
    // Find the systemFlag value on the object, if any
    // to determine is this is a base schema object

    err = DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &sysFlags,
                           sizeof(sysFlags), NULL);

    switch (err) {
          case DB_ERR_NO_VALUE:
             // Value does not exist. Not a base schema object
             fBaseSchemaObj = FALSE;
             break;
          case 0:
             // Value exists. Check the bit
             if (sysFlags & FLAG_SCHEMA_BASE_OBJECT) {
                fBaseSchemaObj = TRUE;
             }
             else {
                fBaseSchemaObj = FALSE;
             }
             break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
              return (pTHS->errCode);
    } /* switch */

    if (fBaseSchemaObj) {
        // no rename of base schema objs are allowed
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
        return (pTHS->errCode);
    }

    // allow renaming defunct classes/attrs after schema-reuse is enabled
    if (!ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        // not a base schema obj. Check if the object's IS_DEFUNCT attribute is set or not
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DEFUNCT, &fDefunct,
                               sizeof(fDefunct), NULL);

        switch (err) {
              case DB_ERR_NO_VALUE:
                 // Value does not exist. Not defunct
                 fDefunct = FALSE;
                 break;
              case 0:
                 // Value exists and is already in fDefunct
                 break;
              default:
                   // some other error. return
                  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
                  return (pTHS->errCode);
        } /* switch */

        if (fDefunct) {
            // Return object-not-found error
            SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND);
        }
    }
    return (pTHS->errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdread.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirRead API.

    DSA_DirRead() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <anchor.h>
#include <ntdsctr.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"         // Defines for selected classes and atts
#include "debug.h"          // standard debugging header
#define DEBSUB     "MDREAD:"            // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDREAD

// Internal functions

int LocalRead(THSTATE *pTHS, READARG *pReadArg, READRES *pReadRes);

VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    );



ULONG
DirRead(
        READARG*    pReadArg,
    READRES **  ppReadRes
        )
/*++
  pReadArg is the read argument
  ppOutBuf is the Result or Error output buffer addr.
--*/
{
    THSTATE*     pTHS;
    READRES *pReadRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirRead entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
    is required on every API transaction.  First the state DS is initialized
    and then either a read or a write sync point is established.
    */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppReadRes = pReadRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppReadRes = pReadRes = THAllocEx(pTHS, sizeof(READRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }
    SYNC_TRANS_READ();   /*Identify a reader trans*/
    __try {
        /* Perform name resolution to locate object.  If it fails,
         * just return an error, which may be a referral.
         */

        if (0 == DoNameRes(pTHS,
                               NAME_RES_QUERY_ONLY,
                   pReadArg->pObject,
                   &pReadArg->CommArg,
                   &pReadRes->CommRes,
                               &pReadArg->pResObj)){

        /* Local read operation */

        LocalRead(pTHS, pReadArg, pReadRes);
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN (pTHS->errCode);
    }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
    HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pReadRes) {
    pReadRes->CommRes.errCode = pTHS->errCode;
    pReadRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }
    return pTHS->errCode;
}  // DSA_DirRead


/*++ CmpACByAttType
 *
 * A simple function to be used with qsort and bsearch.  Compares ATTCACHE's
 * base on attrtyp.
 *
 ++*/
int __cdecl
CmpACByAttType(const void * keyval, const void * datum)
{
    ATTCACHE **ppACkey = (ATTCACHE **)keyval;
    ATTCACHE **ppACdatum = (ATTCACHE **)datum;

    return ((*ppACkey)->id - (*ppACdatum)->id);
}

/*++ CmpIndexedACByAttType
 *
 * A simple helper function for use in qsorting arrays of Indexed pACs by their
 * attrtyp's.  We do this so that we can remove duplicates from a user supplied
 * list of attributes without changing the ordering of the returned att's.
 */
int __cdecl
CmpIndexedACByAttType(const void * keyval, const void * datum)
{
    PINDEXED_AC pACkey = (PINDEXED_AC)keyval;
    PINDEXED_AC pACdatum = (PINDEXED_AC)datum;

    return (pACkey->AttCache->id - pACdatum->AttCache->id);
}


INT
GetAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN PDWORD pnAtts,
    IN BOOL fIgnoreError
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    DWORD i;
    DWORD nNext = 0;

    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(AttCache[nNext] =
                     SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else {

            nNext++;
        }
    }

    *pnAtts = nNext;
    return 0;
} // GetAttrFromSel


INT
AppendAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN DWORD cAttCache,
    IN BOOL fIgnoreError,
    IN BOOL fIgnoreDups
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries and append to an array
       of attcache's if there will be no duplicates after.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.
       pCC - the CLASSCACHE these entries belong to

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    unsigned i,k;
    unsigned j = cAttCache;
    unsigned cNewAtts, ListLength;
    BOOL     fFound;
    ATTCACHE *pAC;


    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(pAC = SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else if (!fIgnoreDups) {
            // append attribute if it's not already in the list
            if (j < 6) {
                // not worth doing bsearch
                for (k = 0; k < j; k++) {
                    if (pAC->id == AttCache[k]->id) {
                        fFound = TRUE;
                    }
                }
                if (!fFound) {
                    AttCache[j++] = pAC;
                } else {
                    fFound = FALSE;
                }
            } else {
                if (!bsearch(pAC, AttCache, cAttCache, sizeof(AttCache[0]), CmpACByAttType)) {
                    AttCache[j++] = pAC;
                }
            }
        } else {
            AttCache[j++] = pAC;
        }
    }

    if (j > (cAttCache + 1) && !fIgnoreDups) {
        //
        // We know that none of the atts that came in the EntInfSel are dups of atts
        // already in the attcache list, now make certain there were no dupes in the
        // EntInfSel.  Just sort the newly added atts and remove the duplicates.
        //
        cNewAtts = j - cAttCache;
        if (!IsACListSorted(&AttCache[cAttCache], cNewAtts)) {
            qsort(&AttCache[cAttCache], cNewAtts, sizeof(AttCache[0]), CmpACByAttType);
        }

        RemoveDuplicatesFromAttCache(&AttCache[cAttCache], cNewAtts);

    }

    return 0;
} // InsertAttrFromSel


VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    )
/*++

    Function Description:
       Remove duplicate attributes

    Arguments:
       AttCache - Array of ATTCACHE pointers
       nAtts - number of items in array

    Return Value.
       None

--*/
{
    DWORD i, j;
    BOOL  fGaps = FALSE;

    //
    // Do a linear search and NULL out all duplicates
    //

    for ( i=0; i < nAtts - 1; i++ ) {
        if (AttCache[i] == AttCache[i+1]) {
            AttCache[i] = NULL;
            fGaps = TRUE;
        }
    }

    //
    // Now remove any gaps left behind.
    //
    if (fGaps) {
        for (i=0;i<nAtts && AttCache[i]; i++) {
            ; // Still looking for first NULL
        }
        j = i + 1;
        while (j<nAtts) {
            if (NULL != AttCache[j]) {
                AttCache[i++] = AttCache[j];
            }
            j++;
        }
    }
} // RemoveDuplicatesFromAttCache


INT
GetEntInf(
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pSelRange,
    IN ENTINF *pEnt,
    IN RANGEINF *pRange,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN OUT PCACHED_AC CachedAC OPTIONAL,
    IN OPTIONAL RESOBJ *pResObj
    )
/*++

Function Description:
       Retrieve attribute data from the positioned object.  First some object
       header information is retrieved (DN and master or copy flag), then either
       some or all of the attributes are visited and data is returned.

Arguments:
       pDB - Database position to be used. Note that pDB != pDB->pTHS->pDB.
             We may be passing in a temporary pDB so that the primary pDB
             is not disturbed.
       pSel - describes what attributes to read.
       pEnt - returns the read attributes.
       CachedAC - Enables the caller to request and send a preformatted/sorted
            ATTCACHE array.
            if NULL, caller does not wish the array to be returned
            if not NULL and CacheAC->AC is NULL, caller is requesting that the array
                be returned
            if not NULL and CacheAC->AC is not NULL, caller is supplying the array
       pResObj - if present, used instead of fetching the object name

       pSecurity - the security descriptor of the object we are positioned on
                   this will be used to check read security of the object.
                   NOTE: it is required that this security descriptor is
                   the one of the object that we are positioned on.
                
       Flags - One of the following:
               GETENTINF_FLAG_CAN_REORDER    - Don't need to preserve the order
                                               of the attributes specified by 
                                               the caller.
               GETENTINF_FLAG_DONT_OPTIMIZE  - ?
               GETENTINF_GC_ATTRS_ONLY       - Return only GC attributes.
               GETENTINF_IGNORE_DUPS         - Don't waste time removing duplicates
                                               attributes.
               GETENTINF_NO_SECURITY         - Don't apply security.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{
    THSTATE             *pTHS = pDB->pTHS;
    ATTRBLOCK           AttrBlock;
    ULONG               i, k, cInAtts, attrCount, cOut;
    ATTCACHE            **rgpAC = NULL, **fullACList = NULL, **attList = NULL;
    ATTCACHE            **rgpACTemp = NULL;
    DWORD               fFlags, fNameFlags;
    DWORD               iType;
    DWORD               *piType=&iType;
    ATTR                *pAttr;
    CLASSCACHE          *pCC = NULL;
    ATTCACHE            *pObjclassAC = NULL;
    ATTRTYP             *pObjClasses = NULL;
    CLASSCACHE          **ppObjClassesCC = NULL, *pTempCC;
    DWORD               cObjClasses, cObjClasses_alloced;
    BOOL                fDoSecCheck;
    DWORD               nSelAttrs = 0;
    BOOL                fGetAll = FALSE;
    BOOL                fGetAllWithList = FALSE;
    BOOL                fMaintainOrder = FALSE;
    BOOL                fGcAttsOnly = FALSE;
    BOOL                fHaveAuxClass = FALSE;
    BOOL                fIgnoreDups;
    PDWORD              pOrderIndex = NULL;
    DWORD               classid = INVALID_ATT;
    DWORD               err;
    DSTIME              TimeToDie;

    if(pTHS->fDSA ||
       pTHS->fDRA ||
       Flags & GETENTINF_NO_SECURITY) {
        fDoSecCheck = FALSE;
    }
    else {
        fDoSecCheck = TRUE;
    }

    //
    // See if we should ignore nonGC attributes
    //

    fGcAttsOnly = (BOOL)(Flags & GETENTINF_GC_ATTRS_ONLY);
    fIgnoreDups = (BOOL)(Flags & GETENTINF_IGNORE_DUPS);

    // First, decide what form of values we want.
    fNameFlags = DBGETMULTIPLEATTS_fEXTERNAL;

    if( pSel == NULL ) {
        fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        fGetAll = TRUE;

    } else {
        switch(pSel->infoTypes) {
          case EN_INFOTYPES_TYPES_MAPI:
            // Return no values, just type information, and return the obj name
            // in MAPI format
            fNameFlags |= DBGETMULTIPLEATTS_fMAPINAMES;
            fFlags = 0;
            break;

          case EN_INFOTYPES_TYPES_ONLY:
            // Return no values, just type information
            fFlags = 0;
            break;

          case EN_INFOTYPES_SHORTNAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fSHORTNAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETMULTIPLEATTS_fSHORTNAMES;
            break;

          case EN_INFOTYPES_MAPINAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fMAPINAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETMULTIPLEATTS_fMAPINAMES;
            break;

          default:
            // Return values in normal external format.
            fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        }

        // If we are the DRA and we are asking for certain selections, we need to
        // tell the DBLayer that we dont want to get all ATTS.  The DBLayer knows
        // which ones to trim.

        switch ( pSel->attSel ) {

        case EN_ATTSET_ALL:
            fGetAll = TRUE;
            break;
        case EN_ATTSET_ALL_WITH_LIST:
            fGetAll = TRUE;
            fGetAllWithList = TRUE;
            nSelAttrs = pSel->AttrTypBlock.attrCount;
            break;

        case EN_ATTSET_ALL_DRA:     // fall through
        case EN_ATTSET_ALL_DRA_EXT:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA:
        case EN_ATTSET_LIST_DRA_EXT:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            break;

        case EN_ATTSET_ALL_DRA_PUBLIC:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA_PUBLIC:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION_PUBLIC;
            break;

        case EN_ATTSET_LIST:
            // intentionally do nothing
            break;

        default:
            Assert (!"Passed wrong value for pSel->attSel");
            break;
        }
    }

    if (NULL == pResObj) {
        // Get and set the DN
        ATTCACHE *pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
        if (i=DBGetMultipleAtts(pDB,
                                1,
                                &pAC,
                                NULL,
                                NULL,
                                &cOut,
                                &pAttr,
                                fNameFlags,
                                0)) {
            DPRINT(2,"Problem retrieving DN attribute\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_DN,
                     szInsertSz(""),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_DN);
        }

        pEnt->pName = (PDSNAME)pAttr[0].AttrVal.pAVal[0].pVal;

        if (pAttr) {
            THFreeEx (pTHS, pAttr->AttrVal.pAVal);
            THFreeEx (pTHS, pAttr);
            pAttr = NULL;
        }

        // instance type
        if(DBGetSingleValue(pDB,
                            ATT_INSTANCE_TYPE,
                            &iType,
                            sizeof(iType),
                            NULL)) {
            DPRINT(2, "Can't retrieve instance type\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertDN(pEnt->pName),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_CANT_RETRIEVE_INSTANCE);
        }
    }
    else {
        pEnt->pName = THAllocEx(pTHS, pResObj->pObj->structLen);
        memcpy(pEnt->pName,
               pResObj->pObj,
               pResObj->pObj->structLen);
        iType = pResObj->InstanceType;
    }

    pEnt->ulFlags = 0;
    if(iType & IT_WRITE) {
        pEnt->ulFlags |= ENTINF_FROM_MASTER;
    }
    // For performance, this feature only available to the replicator.
    // You can remove the fDRA check when you need this flag.
    if ( (pTHS->fDRA) &&
         (DBGetSingleValue(pDB,
                           ATT_MS_DS_ENTRY_TIME_TO_DIE,
                           &TimeToDie,
                           sizeof(TimeToDie),
                           NULL) == 0) ) {
        pEnt->ulFlags |= ENTINF_DYNAMIC_OBJECT;
    }

    if (fGetAll) { // also fGetAllWithList

        // we have to read all the attributes available on the object
        // this might include attributes contributed by the possible
        // auxClasses attached to the object
        // we will propably use these attributes later to do a security check
        // if fDoSecCheck is set

        // get the needed information for the objectClass on this object
        if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get auxClass .
        }

        cObjClasses_alloced = 0;

        if (ReadClassInfoAttribute (pDB,
                                    pObjclassAC,
                                    &pObjClasses,
                                    &cObjClasses_alloced,
                                    &cObjClasses,
                                    &ppObjClassesCC) ) {
            return pTHS->errCode;
        }

        if (!cObjClasses) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get class data.
        }

        classid = pObjClasses[0];
        pCC = ppObjClassesCC[0];

        // we had an auxClass. leave only the most specific classes
        if (cObjClasses > pCC->SubClassCount) {

            fHaveAuxClass = TRUE;

            for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {

                if (ppObjClassesCC[i]==NULL)
                    continue;

                for (k=pCC->SubClassCount; k<cObjClasses-1; k++) {
                    if ((i==k) || (ppObjClassesCC[k]==NULL)) {
                        continue;
                    }

                    if (pTempCC = FindMoreSpecificClass(ppObjClassesCC[i], ppObjClassesCC[k])) {
                        if (pTempCC == ppObjClassesCC[i]) {
                            ppObjClassesCC[k] = NULL;
                        }
                        else {
                            ppObjClassesCC[i] = NULL;
                            break;
                        }
                    }
                }
            }

            // we might have gaps in the ppAuxClassesCC, but we don't care

            // we are not interested in preserving the cache
            // since we are using auxClasses
            CachedAC = NULL;
        }
    }
    else if ( fDoSecCheck ) {

        // They are applying a security check (without specifying all, all+list) 
        // We don't have to generate the full list of attributes contributed 
        // by auxClasses and the list of attributes from the structural class
        // is enough.  So we need to get the class of  the object we are on.

        if(DBGetSingleValue(pDB,
                            ATT_OBJECT_CLASS,
                            &classid, sizeof(classid),
                            NULL) ||
           !(pCC = SCGetClassById(pTHS, classid))) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get class data.
        }
    }

    // Do this now, since we might bail out in the next if statement.
    pEnt->AttrBlock.attrCount = 0;

    //
    // If the caller passed us an attribute array, use it. Copy the saved copy to
    // the scratch copy.  The scratch copy may be changed by CheckReadSecurity()
    //

    if ( (CachedAC != NULL) && (CachedAC->AC != NULL) ) {

        if ( CachedAC->classId == classid ) {

            cInAtts = CachedAC->nAtts;
            rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));

            CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));

            pOrderIndex = CachedAC->pOrderIndex;
            goto have_array;
        } else {

            THFreeEx(pTHS,CachedAC->AC);
            CachedAC->AC = NULL;
        }
    }

    // Set up the the pInCols based on the pSel
    // first determine if we need to retrieve all attributes or a selection

    if ( fGetAll ) {

        DWORD ourCount;
        DWORD sizeAlloc;
        DWORD auxCount = 0;

        // Client did not provide an entifsel with explicitly listed atts.
        // or provided a list in addition to specifying all

        // Retrieve all attributes

        if ( fDoSecCheck || fGetAllWithList ) {

            ULONG j=0;

            Assert(pCC != NULL);

            // We need to apply security, so instead of sending a null list
            // of attcache pointers to DBGetMultipleAtts, read the class of the
            // current object, get the classcache object describing it, then
            // build the attcache array for all possible attributes.

            if (fHaveAuxClass) {

                for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {
                    if (ppObjClassesCC[i]) {
                        auxCount += ppObjClassesCC[i]->MayCount + ppObjClassesCC[i]->MustCount;
                        DPRINT2 (1, "AuxClasses[%d]: %s\n", i, ppObjClassesCC[i]->name);
                    }
                }
            }

            sizeAlloc = (pCC->MayCount + pCC->MustCount + nSelAttrs + auxCount) * sizeof(ATTCACHE *);

            if ( CachedAC != NULL ) {
                //
                // Allocate a scratch and a copy buffer.
                //

                sizeAlloc *= 2;
            }

            rgpAC = (ATTCACHE **) THAllocEx(pTHS,sizeAlloc);
            
            // Do we have an auxClass ?
            //

            if (!fHaveAuxClass) {

                attList = SCGetTypeOrderedList (pTHS, pCC);

                if (!attList) {
                    return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                }

                // maximum count of attributes for this class
                ourCount = pCC->MayCount + pCC->MustCount;

                j = 0;

                for(i=0;i<ourCount;i++) {

                    // defunct attributes are not returned
                    if (!attList[i]) {
                        continue;
                    }

                    if(attList[i]->bIsOperational) {
                        // These attributes are not returned unless explicitly asked
                        // for.  In this branch of the code, we know that an
                        // explicit list was not supplied.
                        continue;
                    }

                    // Check:
                    // If request came in through GC port make sure
                    // this is in the GC partial attribute list.
                    // Since j is already incremented, the attcache of
                    // of interest is pointed to by j-1

                    else if ( (attList[i]->bIsConstructed ) ||
                         (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {
                        
                        // GCport and not GC attribute. 
                        // Should not be passed down

                        continue;
                    }

                    else {
                        rgpAC[j] = attList[i];
                        j++;
                    }
                }

                cInAtts = j;

                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {

                    DWORD ret;

                    Assert(nSelAttrs == pSel->AttrTypBlock.attrCount);

                    if ( (ret = AppendAttrFromSel(pTHS,
                                                  pSel,
                                                  pEnt,
                                                  rgpAC,
                                                  cInAtts,
                                                  TRUE,
                                                  fIgnoreDups)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return ret;
                    }

                    // Count up the atts
                    for (j = 0; rgpAC[j] != NULL; j++);

                    cInAtts = j;
                }

                Assert(cInAtts <= (pCC->MayCount + pCC->MustCount + nSelAttrs));
            }
            else {
                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {
                    // Populate the ATTCACHE list from the Sel list
                    //
                    cInAtts = pSel->AttrTypBlock.attrCount;

                    if ( (err = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return err;
                    }

                    if (!IsACListSorted(rgpAC, cInAtts)) {
                        qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
                    }
                }
                else {
                    cInAtts = 0;
                }

                // start the loop with using the current class
                pTempCC = pCC;
                k = pCC->SubClassCount;    // loop counter for auxClasses

                rgpACTemp = THAllocEx(pTHS, sizeAlloc);

                while (pTempCC != NULL) {
                    j = cInAtts;

                    attList = SCGetTypeOrderedList (pTHS, pTempCC);

                    if (!attList) {
                        THFreeEx(pTHS,rgpAC);
                        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                    }

                    // maximum count of attributes for this class
                    ourCount = pTempCC->MayCount + pTempCC->MustCount;

                    for(i=0;i<ourCount;i++) {

                        // defunct attributes are not returned
                        if (!attList[i]) {
                            continue;
                        }

                        if(attList[i]->bIsOperational) {
                            // These attributes are not returned unless explicitly asked
                            // for.  In this branch of the code, we know that an
                            // explicit list was not supplied.
                            continue;
                        }

                        // Check:
                        // If request came in through GC port make sure
                        // this is in the GC partial attribute list.
                        // Since j is already incremented, the attcache of
                        // of interest is pointed to by j-1

                        else if ( (attList[i]->bIsConstructed ) ||
                             (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {

                            // GCport and not GC attribute. 
                            // Should not be passed down

                            continue;
                        }

                        else {
                            // if client has piggy backed a list, we are goint to insert them
                            // to this array later, otherwise we can finish up now.
                            rgpAC[j] = attList[i];
                            j++;
                        }
                    }

                    if (cInAtts == 0) {
                        cInAtts = j;
                    }
                    if (!fIgnoreDups && (0 != (j - cInAtts))) {
                        ATTCACHE **tmp;
                        MergeSortedACLists(pTHS,
                                           rgpAC,
                                           cInAtts,
                                           rgpAC + cInAtts,
                                           j - cInAtts,
                                           rgpACTemp,
                                           &cInAtts
                                           );
                        //
                        // swap the temp and the working copy of the AC list.
                        //
                        tmp = rgpAC; rgpAC = rgpACTemp; rgpACTemp = tmp;
                    }
                    
                    // find the next auxClass to use
                    if (k < cObjClasses-1) {
                        while (k<cObjClasses-1) {
                            if (pTempCC = ppObjClassesCC[k++]) {
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }


                if (!fIgnoreDups) {
                    RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
                }
                THFreeEx(pTHS, rgpACTemp); rgpACTemp = NULL;
            }
        }
        else {
            // We are not applying any security, just send a null list of
            // attcache pointers.
            cInAtts = 0;
        }
    }
    else {
        // Client provided an entifsel with explicitly listed atts.

        // allocate ATTCACHE structures for all selected attributes  and
        // get schema cache entry for attribute

        DWORD ret;
        DWORD sizeAlloc = pSel->AttrTypBlock.attrCount * sizeof(ATTCACHE*);
        PVOID buffer;

        if ( CachedAC != NULL ) {
            //
            // Allocate for the saved and scratch
            //

            sizeAlloc *= 2;
        }

        rgpAC = (ATTCACHE**)THAllocEx(pTHS,sizeAlloc);
        
        cInAtts = pSel->AttrTypBlock.attrCount;

        //
        // Populate the ATTCACHE list from the Sel list
        //

        if ( (ret = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {
            THFreeEx(pTHS,rgpAC);
            return ret;
        }

        if(cInAtts == 0) {
            // We're not looking for anything, we might as well bail out.
            THFreeEx(pTHS,rgpAC);
            return 0;
        }
        //
        // Sort it
        //

        if ( cInAtts > 1 && !fIgnoreDups) {

            //
            // if CAN_REORDER flag is set, then forget about creating an index.
            //

            if (Flags & GETENTINF_FLAG_CAN_REORDER) {

                qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
            } else if ( (Flags & GETENTINF_FLAG_DONT_OPTIMIZE) == 0) {

                PINDEXED_AC pIndexAC;

                //
                // The caller wants the index preserved, we need to allocate an
                // index array that will help us reorder the results back.
                //

                pIndexAC = (PINDEXED_AC)THAllocEx(pTHS,
                        cInAtts * (sizeof(DWORD) + sizeof(INDEXED_AC)));

                pOrderIndex =
                    (PDWORD)((PCHAR)pIndexAC + cInAtts * sizeof(INDEXED_AC));

                //
                // Copy the attcache array to a temp buffer for sorting. This
                // enables us to sort both array and index at the same time.
                // we use the index to reorder the result to the original order.
                //

                for (i=0;i < cInAtts; i++) {

                    pIndexAC[i].Index = i;
                    pIndexAC[i].AttCache = rgpAC[i];
                }

                qsort(pIndexAC, cInAtts, sizeof(INDEXED_AC), CmpIndexedACByAttType);

                //
                // ok, copy the index to return to the user
                //

                for (i=0;i < cInAtts; i++) {
                    pOrderIndex[i] = pIndexAC[i].Index;
                    rgpAC[i] = pIndexAC[i].AttCache;
                }

                // we return pOrderIndex as a pointer to somewhere in the block of pIndexAC
                // but we cannot free it, since it is in the middle of the block.
                // we need to add one more field to CACHED_AC for the whole pIndexAC
            }
            RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
        }
    }

    //
    // Send this back to the caller so they can use it to call us again
    // Make a saved copy since CheckReadSecurity() might modify the array.
    //

    if ( (CachedAC != NULL) && (cInAtts > 0) ) {
        Assert(CachedAC->AC == NULL);
        CachedAC->AC = rgpAC;
        CachedAC->classId = classid;
        rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));
        CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));
        CachedAC->nAtts = cInAtts;
        CachedAC->pOrderIndex = pOrderIndex;
    }

have_array:

    // now read all the relevant columns from the record

    if ( fDoSecCheck ) {
        // We need to trim the atts we are asking for based on security
        CheckReadSecurity(pTHS,
                          SecurityDescriptorFlags,
                          pSecurity,
                          pEnt->pName,
                          &cInAtts,
                          pCC,
                          rgpAC);
    }

    if (i=DBGetMultipleAtts(pDB,
                            cInAtts,
                            rgpAC,
                            pSelRange,
                            pRange,
                            &AttrBlock.attrCount,
                            &AttrBlock.pAttr,
                            fFlags,
                            SecurityDescriptorFlags)) {

        DPRINT(1,"GetEntInf: Error in GetMultipleAtts\n");
        if (!CachedAC) THFreeEx(pTHS,rgpAC);
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_RETRIEVE_ATTS, i);
    }

    //
    // Do we need to reorder the result?
    //

    if ( (pOrderIndex != NULL) &&
         (AttrBlock.attrCount > 1) ) {

        DWORD i,j;
        ATTR * pTmpAttr = THAllocEx(pTHS,cInAtts * sizeof(ATTR));

        Assert(AttrBlock.attrCount <= cInAtts);
        FillMemory(pTmpAttr, cInAtts * sizeof(ATTR), 0xFF);

        for (i=0, j=0; (i < cInAtts) && (j < AttrBlock.attrCount) ; i++) {

            if ( (rgpAC[i] != NULL) &&
                 (rgpAC[i]->id == AttrBlock.pAttr[j].attrTyp) ) {

                CopyMemory(&pTmpAttr[pOrderIndex[i]],
                           &AttrBlock.pAttr[j],
                           sizeof(ATTR));

                j++;
            }
        }

        //
        // ok, copy the entries from the tmp array back to the AttrBlock buffer
        //

        for (i=0,j=0;i<cInAtts;i++) {

            if ( pTmpAttr[i].attrTyp != 0xFFFFFFFF ) {
                CopyMemory(
                       &AttrBlock.pAttr[j],
                       &pTmpAttr[i],
                       sizeof(ATTR));

                Assert(j < AttrBlock.attrCount);
                j++;
            }
        }
        Assert(j == AttrBlock.attrCount);
        THFreeEx(pTHS,pTmpAttr);
    }

    // initialize the entinf
    pEnt->AttrBlock = AttrBlock;
    if (!CachedAC) THFreeEx(pTHS,rgpAC);
    return 0;
} /*GetIntInf*/

int
LocalRead (
        THSTATE *pTHS,
        READARG *pReadArg,
        READRES *pReadRes
        )
     /*++
       Get the selected attributes and optionally, their values from the current
       object.  If no attributes were found, return an error.
       --*/
{
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD       getEntInfFlags = 0;
    RESOBJ      *pResObj;
    DWORD err;

    PERFINC( pcTotalReads );
    INC_READS_BY_CALLERTYPE( pTHS->CallerType );

    // First, get the security descriptor for this object.
    // Don't bother if this is an internal read
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        DBPOS* pDB = pTHS->pDB;
        char objFlag;
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                &ulLen,
                &pSec,
                NULL,
                NULL,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
            );

        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        // Every object should have an SD.
        Assert(objFlag == 0 || ulLen > 0);
    }

    //
    // Can we reorder entries
    //

    SvccntlFlagsToGetEntInfFlags(&pReadArg->CommArg.Svccntl,&getEntInfFlags);

    if ((pReadArg->pResObj->pObj->NameLen)
        || (pReadArg->pSel->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObj = pReadArg->pResObj;
    }
    else {
        pResObj = NULL;
    }

    if (GetEntInf(pTHS->pDB,
                  pReadArg->pSel,
                  pReadArg->pSelRange,
                  &pReadRes->entry,
                  &pReadRes->range,
                  pReadArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObj)) {
        return (pTHS->errCode);
    }

    // it is an error if the user requested a list of attributes and none
    // where found. If a 0 list was requested, this is an O.K. existance test

    if (pReadRes->entry.AttrBlock.attrCount == 0 && pReadArg->pSel &&
        pReadArg->pSel->AttrTypBlock.attrCount > 0){
    ULONG u;

        DPRINT(2,"No user sel atts found .PR_PROBLEM_NO_ATTRIBUTE_OR_VAL\n");

    for (u = 0; u < pReadArg->pSel->AttrTypBlock.attrCount; u++) {
        SetAttError(pReadArg->pObject,
            pReadArg->pSel->AttrTypBlock.pAttr[u].attrTyp,
            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
            NULL,
            DIRERR_NO_REQUESTED_ATTS_FOUND);
    }
    }

    return pTHS->errCode;

}/*LocalRead*/


VOID
SvccntlFlagsToGetEntInfFlags(
    IN  SVCCNTL* Svccntl,
    OUT PDWORD Flags
    )
{
    if ( !Svccntl->fMaintainSelOrder ) {
        *Flags = GETENTINF_FLAG_CAN_REORDER;
    } else if (Svccntl->fDontOptimizeSel) {
        *Flags = GETENTINF_FLAG_DONT_OPTIMIZE;
    }

    //
    // if request came in through GC port, get only GC attributes
    //

    if (Svccntl->fGcAttsOnly) {
        *Flags |= GETENTINF_GC_ATTRS_ONLY;
    }

    return;
} // SvccntlFlagsToGetEntInfFlags


BOOL
IsACListSorted(
    IN ATTCACHE  **rgpAC,
    IN DWORD       cAtts
    )
/*++

Function Description:
       Checks a list of ATTCACHE pointers to see if it is already sorted.
       
Arguments:
       rgpAC - The list of ATTCACHE pointers to be checked.
       
       cAtts - A count of the ATTCACHE pointers in rgpAC
       
Return Value.
       Returns TRUE if the list is sorted, FALSE if not.
       
--*/
{
    unsigned i;

    for (i = 0; i<cAtts - 1; i++) {
        if (rgpAC[i]->id > rgpAC[i+1]->id) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
MergeSortedACLists(
    IN  THSTATE    *pTHS,
    IN  ATTCACHE  **rgpAC1,
    IN  DWORD       cAtts1,
    IN  ATTCACHE  **rgpAC2,
    IN  DWORD       cAtts2,
    IN OUT ATTCACHE **rgpACOut,
    OUT DWORD      *pcAttsOut
    )
/*++

Function Description:
       Merges to sorted lists of ATTCACHE arrays.
              
Arguments:
       rgpAC1, rgpAC2 - The lists of ATTCACHE pointers to be merged.
       
       cAtts1, cAtts2 - A count of the ATTCACHE pointers in the respective list.
       
       rgpACOut - A buffer that must be larger enough to hold both input lists.
                  This is where the merged list will be placed.
                  
       pcOutAtts - Where the size of the merged list is returned.
       
Return Value.

       n/a       
--*/
{
    ATTCACHE   **rgpACIndirect = NULL;
    unsigned   pos1 = 0, pos2 = 0, outPos = 0;
    int        cmp;

    *pcAttsOut = 0;

    for (;;) {
        cmp = CmpACByAttType(&rgpAC1[pos1], &rgpAC2[pos2]);
        if (cmp > 0) {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            if (pos2 == cAtts2) {
                break;
            }
        } else if (cmp < 0) {
            rgpACOut[outPos++] = rgpAC1[pos1++];
            if (pos1 == cAtts1) {
                break;
            }
        } else {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            pos1++;
            if (pos1 == cAtts1 || pos2 == cAtts2) {
                break;
            }
        }
    }

    //
    // One of the input lists has run out of elements.  Copy the rest
    // of the other list over.
    //
    if (pos1 == cAtts1) {
        rgpACIndirect = rgpAC2;
        pos1 = pos2;
        cAtts1 = cAtts2;
    } else {
        rgpACIndirect = rgpAC1;
    }
    while (pos1 < cAtts1) {
        rgpACOut[outPos++] = rgpACIndirect[pos1++];
    }

    *pcAttsOut = outPos;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdsearch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdsearch.c
//
//--------------------------------------------------------------------------


/*
Description:

    Implements the DirSearch API.

    DSA_DirSearch() is the main function exported from this module.

*/
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>            // Perf Hook

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "permit.h"
#include "filtypes.h"                   // For FI_CHOICE...
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "MDSEARCH:"              // define the subsystem for debugging

// LDAP errors
#include <winldap.h>

#include <fileno.h>
#define  FILENO FILENO_MDSEARCH

#include <dstrace.h>
#include "dsutil.h"



// Search Logging
ULONG gcTotalSearchesInLastPeriod = 0;
ULONG gcSearchInefficientThreshold = 10000;
ULONG gcSearchExpensiveThreshold = 5;
ULONG gcSearchInefficient_count = 0;
ULONG gcSearchExpensive_count = 0;
BOOL  isSearchPerformanceLoggingFirstTime = TRUE;
DSTIME timeLastSearchLoggingPerformed;

/* Internal functions */

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC
    );

DWORD
FindFirstSearchObject(
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart,
        PSECURITY_DESCRIPTOR *ppSecurity
        );

void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ);
void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals);
void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals);
VOID
SimpleBaseSearch (
        THSTATE   *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        );

BOOL
IsBaseOnlyAttPresent(
        SEARCHARG *pSearchArg
        );

void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirSearch(
          SEARCHARG*  pSearchArg,
          SEARCHRES **ppSearchRes
          )
{
    THSTATE*     pTHS;
    SEARCHRES *pSearchRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT1(1,"DirSearch(%ws) entered\n",pSearchArg->pObject->StringName);

   /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
      is required on every API transaction.  First the state DS is initialized
      and then either a read or a write sync point is established.
   */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppSearchRes = pSearchRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppSearchRes = pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if (   (eServiceShutdown >= eSecuringDatabase)
                || (   (eServiceShutdown >= eRemovingClients)
                    && (   !(pTHS->fDSA)
                        || (pTHS->fSAM)))) {
                ErrorOnShutdown();
                __leave;
            }
        }

        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            pSearchRes->CommRes.aliasDeref = FALSE;   /*Initialize to Default*/

            pSearchRes->PagedResult = pSearchArg->CommArg.PagedResult;

            // Assume no paged result
            memset(&pSearchRes->PagedResult,0,sizeof(PAGED_RESULT));

            /* Call main search function*/

            SearchBody(pTHS, pSearchArg, pSearchRes,0);

        } __finally {
            CLEAN_BEFORE_RETURN( pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pSearchRes) {
        pSearchRes->CommRes.errCode = pTHS->errCode;
        pSearchRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
} // DirSearch


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if this is a restarted operation.

   The continued operation was either on this DSA or this DSA or on a remote
   chained DSA.  This is determined using the isRemote flag.  Both the
   R_DirSearch remote DSA fns and the LocalSearch  function
   can be continued.  On input, pRestart indicates if the function is a
   continuation.  On output it indicates if a continuation is necessary.
   These functions are responsible for setting this flag.  It should be
   TRUE only  when a good return is generated and a continuation is necessary.

   Different information is needed to restart a local search from a remote
   one.  For a local call, we save the DN of the next object to be  returned.
   For foreign call we save a pointer to the beginning of the user's RPC
   output Buf, a pointer to the next entInfList to be returned and the
   remote DSA handle.

*/

void
SearchBody (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    PRESTART       pRestart;
    DWORD          dwNameResFlags = NAME_RES_QUERY_ONLY;

   pRestart = pSearchArg->CommArg.PagedResult.pRestart;    /* continuation? */

   if( pRestart != NULL ) {
       // all the data we need should be in PRESTART struct
       pSearchArg->pResObj = ResObjFromRestart(pTHS,
                                               pSearchArg->pObject,
                                               pRestart);
       LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
       // Search may have opened a sort table.  Some callers require that it be
       // closed.
       DBCloseSortTable(pTHS->pDB);
   }
   else          /* First transaction...Not a continuation.  */
   {
       /* We perform name resolution. Set the children needed flag
          according to if the search includes child objects.
          */

       if(pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
           dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;
           if(!pSearchArg->bOneNC) {
               // We are on a GC, thus it is OK to root a search from a phantom
               // as long as the search wasn't a base-only one.
               // Set the flags to show this.
               dwNameResFlags |= NAME_RES_PHANTOMS_ALLOWED;
           }
       }
       // If we're on a GC port we need to pass this flag to DoNameRes, so
       // we'll get referrals to all objects in NDNCs.
       dwNameResFlags |= (pSearchArg->bOneNC) ? 0 : NAME_RES_GC_SEMANTICS;

       if( 0 == DoNameRes(pTHS,
                          dwNameResFlags,
                          pSearchArg->pObject,
                          &pSearchArg->CommArg,
                          &pSearchRes->CommRes,
                          &pSearchArg->pResObj)) {
            LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
           // Search may have opened a sort table.  Some callers require that it
           // be closed.
           DBCloseSortTable(pTHS->pDB);
       }
   }
   return;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Main body of local search function.  We get as many objects as will fit
   into the output buffer.  If more data is available, we use a non-null
   partialoutcomequalifier to indicate to the user that there is more data.

   The steps are as follows:

   1 - Set the client filter.

   2 - a - If this is not a restarted transaction, we retrieve and test the
           filter against the base of the subtree or

       b - This is a restarted transaction so we reposition on the next
           entry to retrieve.  (Note that we assume that we have been called
           with the same exact filter ( this is expected)

   3 - We determine the scope of the call, this indicates if the client
       requested the base object only or the base and the immediate children.
       If it is base only we return.

   4 - a - Retrieve each child that passes the filter test.  (Note that the
           filter test is implicit in the DBGetNextSearchObj database call.)

       b - Try to retrieve its data into an entry info structure.
           If we failulSearchStatus because we are out of space, we leave the partial
           outcome qualifier to indicate to the client that there is more
           data and we return the name of the current object that we were
           not able to return. We also indicate that a restart is needed.

   5 - If there are no more children, we NULL out the partial outcome
       qualifier and return.
*/

#if DBG
DWORD gulInefficientSearchTrigger = 5000;
BOOL fBreakOnInefficientSearchTrigger = FALSE;
#endif

INT
LocalSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    ENTINFLIST *pEntInfList; /*Points to next output Entry info list*/
    RANGEINFLIST *pRangeInfList;
    ULONG        dwSearchStatus;
    COMMARG *  pCommArg;
    BOOL       fExitLoop = FALSE;
    BOOL       fFirstTime = TRUE;
    DWORD      cbSecurity;
    PSECURITY_DESCRIPTOR pSecurity=NULL;
    PRESTART   pArgRestart, pResRestart=NULL;
    POBJECT_TYPE_LIST pFilterSecurity;
    DWORD      *pResults;
    ULONG      FilterSecuritySize;
    ULONG      SearchFlags=0;
    PFILTER    pInternalFilter = NULL;
    INT        numAtts = 0; // holds total number of attributes found
                            // across all entries.  error if it stays == 0
    BOOL       *pbSortSkip=NULL;
    BOOL        bSkipEntInf = FALSE;
    DWORD       cASQRefCount = 0;
    DWORD       cASQRefAlloced = 0;
    DWORD       *pASQReferrals = NULL;

    CACHED_AC   cachedAC;
    DWORD       getEntInfFlags = 0;
    DWORD       err;
    BOOL        fVLVPresent, fASQPresent;
    ATTCACHE    *pSortAC = NULL;
    ATTCACHE    *pASQAC, *pACSD;
    VLV_REQUEST *pVLVRequest;
    ASQ_REQUEST *pASQRequest;
    PDSNAME     pParent = NULL;
    CLASSCACHE  *pCC;
    ULONG       cAtts;

    DPRINT1(1,"LocalSearch(%ws) entered\n",pSearchArg->pObject->StringName);

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_SEARCH,
                     EVENT_TRACE_TYPE_START,
                     DsGuidSearch,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertSz(SEARCHTYPE_STRING(pSearchArg->choice)),
                     szInsertDN(pSearchArg->pObject),
                     NULL, NULL, NULL, NULL, NULL);

    Assert(pSearchArg->pResObj);

    PERFINC(pcTotalSearches);
    INC_SEARCHES_BY_CALLERTYPE( pTHS->CallerType );
    gcTotalSearchesInLastPeriod++;

    pCommArg = &pSearchArg->CommArg;
    pArgRestart = pCommArg->PagedResult.pRestart;

    // Assert that we either don't have a restart structure OR we have said
    // that we are going to have one.  Note that it is legal to have
    // fPresent == TRUE and not actually have a pArgRestart
    Assert(!pArgRestart || pCommArg->PagedResult.fPresent);



    // check that they ask for a sort on an attribute that we know how to sort
    //
    if (pSearchArg->CommArg.SortType != SORT_NEVER) {

        pSortAC = SCGetAttById(pTHS, pSearchArg->CommArg.SortAttr);
        if (!pSortAC) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            goto exit;
        }

        // check whether we support sorting on this syntax.
        // all the operators that support >, support >=, <, <= are ok for sorting
        //
        if (!FLegalOperator (pSortAC->syntax, FI_CHOICE_GREATER)) {
            pSearchRes->SortResultCode = LDAP_INAPPROPRIATE_MATCHING;
            if (pSearchArg->CommArg.SortType == SORT_OPTIONAL) {
                pSearchArg->CommArg.SortType = SORT_NEVER;
            }
            else {
                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED_SORT_ORDER);
                goto exit;
            }
        }
    }


    // Check for VLV presence
    //
    pVLVRequest = &pCommArg->VLVRequest;
    fVLVPresent = pVLVRequest->fPresent;
    Assert(!pVLVRequest->pVLVRestart || fVLVPresent);
    if (fVLVPresent) {

        DPRINT5 (1, "VLV: before:%d after:%d cnt:%d target:%d res: 0x%x\n",
                                pVLVRequest->beforeCount,
                                pVLVRequest->afterCount,
                                pVLVRequest->contentCount,
                                pVLVRequest->targetPosition,
                                pVLVRequest->pVLVRestart);

        if (pVLVRequest->fseekToValue) {
            DPRINT1 (1, "VLV: seekToValue  seekVal: %ws\n",
                            pVLVRequest->seekValue.pVal);
        }

        // we don't support VLV without a sort request
        //
        if (pSearchArg->CommArg.SortType == SORT_NEVER) {

            // set this so to exit with VLV specific errors
            DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
            pTHS->pDB->Key.pVLV->Err = LDAP_SORT_CONTROL_MISSING;
            DBSetVLVResult (pTHS->pDB, &pSearchRes->VLVRequest, NULL);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        // we don't support VLV on base searches, unless we are also doing an ASQ
        //
        if (pSearchArg->choice == SE_CHOICE_BASE_ONLY &&
            !pSearchArg->CommArg.ASQRequest.fPresent) {

                // set this so to exit with VLV specific errors
                //
                DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
                pTHS->pDB->Key.pVLV->Err = LDAP_UNWILLING_TO_PERFORM;
                DBSetVLVResult (pTHS->pDB, &pSearchRes->VLVRequest, NULL);

                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
                goto exit;
        }
    }

    // check for ASQ presence
    pASQRequest = &pCommArg->ASQRequest;

    if (fASQPresent = pASQRequest->fPresent) {

	//
	// The client should be able to see this object
	// before we continue.
	//
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }

        // we support ASQ only on base searches
        //
        if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {

            pTHS->pDB->Key.asqRequest.Err = LDAP_UNWILLING_TO_PERFORM;
            DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        if (!(pASQAC = SCGetAttById (pTHS, pASQRequest->attrType))) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            goto exit;
        }

        DPRINT3 (1, "ASQ Scoped Query on %s(0x%x) linkID:0x%x\n",
                        pASQAC->name, pASQAC->id, pASQAC->ulLinkID);

        // we only support ASQ on certain attribute syntaxes
        //
        if (pASQAC->syntax != SYNTAX_DISTNAME_TYPE) {
            DPRINT1 (1, "Invalid Syntax on ASQ Attribute: %d\n", pASQAC->syntax);

            // set this so as to exit with ASQ specific errors
            //
            pTHS->pDB->Key.asqRequest.Err = LDAP_INVALID_SYNTAX;
            DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
            goto exit;
        }

        //
	// Client should have read permission on the attribute.
	//
	if (!(pCC = SCGetClassById(pTHS, pSearchArg->pResObj->MostSpecificObjClass))) {
	    SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJECT_CLASS_REQUIRED);
	    goto exit;
	}
	// First, get the security descriptor for this object.
	pACSD = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
	if (err = DBGetAttVal_AC(pTHS->pDB, 1, pACSD,
			   0, 0,
			   &cbSecurity, (PUCHAR *)&pSecurity))
	    {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
			 ERROR_DS_CANT_RETRIEVE_SD,
			 err);
	    goto exit;  
	}

	cAtts = 1;
	CheckReadSecurity(pTHS, 0, pSecurity, pSearchArg->pResObj->pObj, &cAtts, pCC, &pASQAC);
	THFreeEx(pTHS, pSecurity); pSecurity = NULL; 
	if (!pASQAC) {
	    //
	    // The client can't see this attribute.  Act as if the attribute simply 
	    // doesn't exist on this object.
	    //
	    goto exit;
	}

	// if we are a GC, possibly we have local copies of objects
        // without all the requested attributes.
        // check whether the requested attributes are all replicated to the GC
        if (gAnchor.fAmGC && !pSearchArg->bOneNC) {

            if (!pSearchArg->pSelection) {
                DPRINT(1, "ASQ Setting missing attrs to TRUE\n");
                pASQRequest->fMissingAttributesOnGC = TRUE;
            }
            else {
                DPRINT1(1, "ASQ Setting missing attrs to %s\n",
                        pCommArg->Svccntl.fMissingAttributesOnGC ? "TRUE" : "FALSE");
                pASQRequest->fMissingAttributesOnGC = pCommArg->Svccntl.fMissingAttributesOnGC;
            }
        }
    }

    // Assume not sorted
    pSearchRes->bSorted = FALSE;

    //Set the base object name if an alias has been dereferenced
    if (pSearchRes->CommRes.aliasDeref) {
        DWORD len;
        pSearchRes->baseProvided = TRUE;
        DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0,
                    &len, (PUCHAR *)&(pSearchRes->pBase)) ;
    }
    else {
        pSearchRes->baseProvided = FALSE;
    }

    if (pSearchArg->pSelection)
    {
        DPRINT2(4,"Attribute selection is <%c>, infotypes <%c>\n",
            (pSearchArg->pSelection->attSel),
            (pSearchArg->pSelection->infoTypes));

        // We allow certain constructed attributes to be asked for
        // only if it is a base search.
        if (IsBaseOnlyAttPresent(pSearchArg)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_NON_BASE_SEARCH, 0);
            goto exit;
        }
    } else{
        DPRINT(4,"No selection specified.\n");
    }

    // internalize and register the filter with the DBlayer
    // and check to see if the filter is valid

    if ((err = DBMakeFilterInternal(pTHS->pDB,
                         pSearchArg->pFilter,
                         &pInternalFilter)) != ERROR_SUCCESS ) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, err, 0);
        goto exit;
    }

    // initialize results
    pRangeInfList = &(pSearchRes->FirstRangeInf);
    pEntInfList = &(pSearchRes->FirstEntInf);
    pSearchRes->count = 0;     /* init num of entries counter to 0 */

    // Check for simplest case
    if(pInternalFilter &&
       !pInternalFilter->pNextFilter &&
       pInternalFilter->choice == FILTER_CHOICE_ITEM &&
       pInternalFilter->FilterTypes.Item.choice == FI_CHOICE_TRUE &&
       pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) {
        // This is a base object read, no filter.  Verify the parent, then do a
        // getentinf.
        SimpleBaseSearch(pTHS, pSearchArg,pSearchRes,flags);

        goto exit;
    }

    GetFilterSecurity(pTHS,
                      pInternalFilter,
                      pCommArg->SortType,
                      pCommArg->SortAttr,
                      (flags & SEARCH_AB_FILTER),
                      &pFilterSecurity,
                      &pbSortSkip,
                      &pResults,
                      &FilterSecuritySize);

    DBSetFilter(pTHS->pDB,
                pInternalFilter,
                pFilterSecurity,
                pResults,
                FilterSecuritySize,
                pbSortSkip
                );

    //
    // if this is not the first page and we are paging and the
    // size is 0, abort at this point.
    //      We need to generate referrals with the first page.
    //      If page size is 0, then the client is signalling us
    //      to abort the paging sequence. We do this check way
    //      down in the core and not on the ldap head so we
    //      can check the validity of client parameters
    //

    if ( (pArgRestart != NULL) &&
         (pCommArg->ulSizeLimit == 0) &&
         pCommArg->PagedResult.fPresent ) {

        // exit to avoid generating referrals on succeeding pages
        goto exit;
    }

    if (fVLVPresent) {
        DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
    }

    if (fASQPresent) {
        DBSetASQArgs (pTHS->pDB, pASQRequest, pCommArg);
    }

    // position on the first record that qualifies.
    SearchFlags = SEARCH_FLAGS((*pCommArg));

    dwSearchStatus = FindFirstSearchObject(pTHS->pDB,
                                           pSearchArg,
                                           pArgRestart,
                                           &pSecurity);


    if (DB_ERR_NEXTCHILD_NOTFOUND == dwSearchStatus) {
	//
	// There were no entries visible to the client.  If the 
	// base of the search is not visible to the client, then
	// make sure not to reveal it's existence.
	//
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }
    }

    if(dwSearchStatus == DB_ERR_CANT_SORT) {
        // A mandatory sort order was unavailable.  Other errors fall through
        // and are dealt with below.
        SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_UNKNOWN_ERROR);
        goto exit;
    }
    else if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
        AddCurrentObjectToAsqReferrals (pTHS,
                                        &cASQRefCount,
                                        &cASQRefAlloced,
                                        &pASQReferrals);
        bSkipEntInf = TRUE;
        dwSearchStatus = 0;
    }

    // Did we find a sort order?
    pSearchRes->bSorted = (pTHS->pDB->Key.ulSorted != SORT_NEVER);

    // we might be directed to leave the results in the
    // sort table and don't create the ENTINF in-memory list
    if (pSearchArg->fPutResultsInSortedTable) {
        pSearchRes->count = pTHS->pDB->Key.ulEntriesInTempTable;
    }

    ZeroMemory(&cachedAC, sizeof(cachedAC));

    SvccntlFlagsToGetEntInfFlags(&pCommArg->Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    while (   !dwSearchStatus
           && !fExitLoop
           && ((eServiceShutdown == eRunning)
               || ((eServiceShutdown == eRemovingClients)
                   && (pTHS->fDSA
                       && !pTHS->fSAM)))) {

        if((pSearchRes->count + cASQRefCount) >= pCommArg->ulSizeLimit) {

            DPRINT(4, "Size Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_SIZE_LIMIT;

            if( pCommArg->PagedResult.fPresent) {
                // Info from DB layer
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }

            fExitLoop = TRUE;
            continue;
        }
        else if (pTHS->pDB->Key.pVLV &&
                 (pSearchRes->count >= pTHS->pDB->Key.pVLV->requestedEntries) ) {

            DBCreateRestart(pTHS->pDB,
                            &pResRestart,
                            SearchFlags,
                            PA_PROBLEM_SIZE_LIMIT,
                            pSearchArg->pResObj);

            DBSetVLVResult (pTHS->pDB,
                            &pSearchRes->VLVRequest,
                            pResRestart);

            fExitLoop = TRUE;
            continue;
        }

        if (!bSkipEntInf) {
            if ((fFirstTime &&
                 GetEntInf(pTHS->pDB,
                           pSearchArg->pSelection,
                           pSearchArg->pSelectionRange,
                           &pEntInfList->Entinf,
                           &pRangeInfList->RangeInf,
                           pCommArg->Svccntl.SecurityDescriptorFlags,
                           pSecurity,
                           getEntInfFlags,
                           &cachedAC,
                           NULL)) ||
                (!fFirstTime &&
                    GetNextEntInf(pTHS->pDB,
                               pSearchArg->pSelection,
                               pSearchArg->pSelectionRange,
                               &pEntInfList,
                               &pRangeInfList,
                               pCommArg->Svccntl.SecurityDescriptorFlags,
                               pSecurity,
                               getEntInfFlags,
                               &cachedAC))){
                DPRINT(0,"Bad return building ENT\n");
                goto exit;
            }

            numAtts += pEntInfList->Entinf.AttrBlock.attrCount;
            fFirstTime = FALSE;
            pSearchRes->count++;
        }
        bSkipEntInf = FALSE;

        if (pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) {
            dwSearchStatus = DB_ERR_NEXTCHILD_NOTFOUND;
        } else {

            do {
                dwSearchStatus = DBGetNextSearchObject(pTHS->pDB,
                                                       pCommArg->StartTick,
                                                       pCommArg->DeltaTick,
                                                       &pSecurity,
                                                       SearchFlags);

                if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
                    AddCurrentObjectToAsqReferrals (pTHS,
                                                    &cASQRefCount,
                                                    &cASQRefAlloced,
                                                    &pASQReferrals);
                    bSkipEntInf = TRUE;
                    dwSearchStatus = 0;
                    break;
                }


                if (!dwSearchStatus) {
                    // Check if the parent is one we don't have rights to list contents of.

                    // we already checked security for this
                    if(pTHS->pDB->Key.ulSorted && pTHS->pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
                        break;
                    }
                    // check security
                    else if (IsObjVisibleBySecurity(pTHS, TRUE)) {
                        break;
                    }
                }

            } while ( !dwSearchStatus );
        }
    }

    if (eServiceShutdown
        && ((eServiceShutdown >= eSecuringDatabase)
            || (!pTHS->fDSA || pTHS->fSAM))) {
        SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);
    } else {

        switch (dwSearchStatus) {

        case DB_ERR_TIMELIMIT:
            DPRINT(4, "Time Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_TIME_LIMIT;

            if(pCommArg->PagedResult.fPresent) {
                // We were asked for paged results and we hit a time limit.
                // Build a paged results.  Note that we explicitly DO NOT come
                // through here if we hit a size limit.  In that case, we
                // already built the paged result above as soon as we found that
                // we hit the size limit.
                //

                // Info from DB layer
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }
            else if (fVLVPresent) {
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pTHS->pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case DB_ERR_NEXTCHILD_NOTFOUND:
            // This is the case of a complete search (i.e. no more objects to be
            // returned, even if paging was requested.


            if (fVLVPresent) {

                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pTHS->pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case 0:
            // This is the case of a sizeLimit reached.

            //
            // This is #if 0 instead of removed to allow for our bosses to
            // change their minds on the issue of whether we should be returning
            // an error or not
            //

#if 0
            if ((numAtts == 0) &&
                (pSearchRes->count != 0) &&
                (pSearchArg->pSelection) &&
                ((pSearchArg->choice != SE_CHOICE_BASE_ONLY) ||
                (pInternalFilter)                            ) &&
                (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

                // it is an error if the user requested a list of
                // attributes and none were found on any objects.

                SetAttError(pSearchArg->pObject, 0L,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                            DIRERR_NO_REQUESTED_ATTS_FOUND);
            }
#endif
            break;

        case DB_ERR_VLV_CONTROL:
            Assert (fVLVPresent);

            // we got a VLV related error. more info for this error
            // is found on the VLV_SEARCH on the pDB
            // we don't want to fail the call, just the specific part (VLV)
            DBSetVLVResult (pTHS->pDB,
                            &pSearchRes->VLVRequest,
                            NULL);
            break;

        default:
            DPRINT(1, "Bad error returned from DBGetNextSearchObj\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_CHILD,
                     szInsertWC(pSearchArg->pObject->StringName),
                     NULL,
                     NULL);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_CHILD,
                          dwSearchStatus);

        }
    }

    if (fASQPresent) {
        DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);
    }

    /* Generate a Partial Outcome Qualifier, if needed */
    if (!pArgRestart &&         /* only do this on first packet */
        !pTHS->errCode &&       /* only do if nothing has gone wrong */
        pSearchArg->choice != SE_CHOICE_BASE_ONLY && /* unnecessary */
        !fVLVPresent && /* if VLV we don't want this */
        !pSearchArg->CommArg.Svccntl.localScope) { /* don't if local only */

        GeneratePOQ(pTHS,
                    pSearchArg,
                    &pSearchRes->pPartialOutcomeQualifier);
    }

    if (cASQRefCount) {
        GenerateASQ_POQ (pTHS,
                         pSearchArg,
                         &pSearchRes->pPartialOutcomeQualifier,
                         cASQRefCount,
                         pASQReferrals);

        THFreeEx (pTHS, pASQReferrals);
    }

exit:

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_SEARCH,
                     EVENT_TRACE_TYPE_END,
                     DsGuidSearch,
                     szInsertUL(pTHS->errCode),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertSz (pTHS->searchLogging.pszFilter)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertSz (pTHS->searchLogging.pszIndexes)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pTHS->searchLogging.SearchEntriesVisited)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pTHS->pDB->SearchEntriesReturned)
                        : NULL),
                     NULL, NULL, NULL);

#if DBG

    //
    // Used to trackdown callers doing inefficient searches
    //

    if ( pTHS->searchLogging.SearchEntriesVisited > gulInefficientSearchTrigger ) {

        if ( pTHS->CallerType != CALLERTYPE_LDAP ) {

            KdPrint(("Search Entries Visited == %d\n",pTHS->searchLogging.SearchEntriesVisited));
            KdPrint(("Caller %s SearchArg %x\n",
                     GetCallerTypeString(pTHS),
                     pSearchArg));
            if ( fBreakOnInefficientSearchTrigger ) {
                DebugBreak();
            }
        }
    }
#endif

    // if we were asked for paged results, and we didn't hit any limit (size, time)
    // this means that we finished with searching, so we can account for it
    if ( (pCommArg->PagedResult.fPresent && !pSearchRes->pPartialOutcomeQualifier) ||
         (!pCommArg->PagedResult.fPresent) ) {

        DWORD searchExpensiveInefficient = 0;

        pTHS->searchLogging.SearchEntriesReturned = pTHS->pDB->SearchEntriesReturned;
        pTHS->searchLogging.SearchEntriesVisited = pTHS->pDB->SearchEntriesVisited;

        if (pTHS->pDB->SearchEntriesVisited >= gcSearchExpensiveThreshold) {
            gcSearchExpensive_count += 1;
            searchExpensiveInefficient |= 1;
        }

        if (pTHS->pDB->SearchEntriesVisited >= gcSearchInefficientThreshold) {
            if (pTHS->pDB->SearchEntriesVisited >= (10 * pTHS->pDB->SearchEntriesReturned) ) {
                gcSearchInefficient_count += 1;
                searchExpensiveInefficient |= 2;
            }
        }

        // check if we are asked to log all inefficient / expensive searches
        if ( searchExpensiveInefficient &&
             (DS_EVENT_SEV_INTERNAL <=
              gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_FIELD_ENGINEERING].ulLevel) ) {

            SearchPerformanceLogFilter (pTHS->pDB, pSearchArg);
        }
    }

    if(pSecurity) {
        THFreeEx(pTHS, pSecurity);
    }

    DPRINT2 (2, "Objects Visited: %d   Returned: %d\n",
                    pTHS->pDB->SearchEntriesVisited,
                    pTHS->pDB->SearchEntriesReturned);

    return pTHS->errCode;

} // LocalSearch



// -------------------------------------------------------------------------
//  performs logging of the various search operations that took place the
//  last period. this function is invoked from within the garbage collector
//  so they share the same invocation interval.
// -------------------------------------------------------------------------
void
SearchPerformanceLogging (void)
{
    DSTIME timeNow = DBTime();
    DSTIME timeElapsed;
    DWORD hours;

    // We are not interested in the first time this function is called,
    // which happens 15 minutes after starting the DS, since we are bundled
    // together with GarbageCollection
    if (isSearchPerformanceLoggingFirstTime) {
        isSearchPerformanceLoggingFirstTime = FALSE;
        timeLastSearchLoggingPerformed = timeNow;
        return;
    }

    timeElapsed = timeNow - timeLastSearchLoggingPerformed;

    hours = (DWORD)timeElapsed / 3600;

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_SEARCH_OPERATIONS,
             szInsertUL(hours),
             szInsertUL(gcTotalSearchesInLastPeriod),
             szInsertUL(gcSearchExpensive_count),
             szInsertUL(gcSearchInefficient_count),
             NULL, NULL, NULL, NULL);

    DPRINT4 (0, "SearchPerformanceLogging: %d total searches in %d hours, %d expensive, %d inefficient\n",
            gcTotalSearchesInLastPeriod, hours, gcSearchExpensive_count, gcSearchInefficient_count);

    // reset period loging variables
    gcSearchExpensive_count = gcSearchInefficient_count = gcTotalSearchesInLastPeriod = 0;
    timeLastSearchLoggingPerformed = timeNow;
}


void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg)
{
    LPSTR buff = THAllocEx(pDB->pTHS, DBFILTER_DUMP_SIZE);

    buff[0] = '\0';

    DBCreateSearchPerfLogFilter (pDB, pSearchArg->pFilter, buff, DBFILTER_DUMP_SIZE);

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_INTERNAL,
             DIRLOG_SEARCH_FILTER_LOGGING,
             szInsertWC (!pSearchArg->pObject->NameLen ? L"RootDSE" : pSearchArg->pObject->StringName),
             szInsertSz (buff),
             szInsertUL(pDB->SearchEntriesVisited),
             szInsertUL(pDB->SearchEntriesReturned),
             szInsertSz(GetCallerTypeString(pDB->pTHS)),
             NULL, NULL, NULL );

    DPRINT3 (1, "Filter %s\n Returned %d Visited %d\n",
                    buff,
                    pDB->SearchEntriesReturned,
                    pDB->SearchEntriesVisited);

    THFreeEx (pDB->pTHS, buff);
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Build the Ent Inf datastructure for the current object and add to
   the linked-list.  If we run out of RPC space, we throw away the partial
   object and sucessfully return.  Note however, that atleast 1 object must
   be able to fit in RPC space.
*/

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC
    )
{
    THSTATE *pTHS = pDB->pTHS;
    ENTINFLIST *pNewEntList;
    RANGEINFLIST *pNewRangeList = NULL;     //initialized to avoid C4701
    RANGEINF *pRangeInf = NULL;
    DPRINT(3, "GetNextEntInf entered\n");

    if(pRange) {
        // A range was specified, so we need to allocate a range list
        (*ppRangeInfList)->pNext = THAllocEx(pTHS, sizeof(RANGEINFLIST));
        pNewRangeList = (*ppRangeInfList)->pNext;
        pRangeInf = &(pNewRangeList->RangeInf);
    }
    (*ppEntInfList)->pNextEntInf = THAllocEx(pTHS, sizeof(ENTINFLIST));

    pNewEntList = (*ppEntInfList)->pNextEntInf;

    if (GetEntInf(pDB,
                  pSel,
                  pRange,
                  &(pNewEntList->Entinf),
                  pRangeInf,
                  SecurityDescriptorFlags,
                  pSecurity,
                  Flags,
                  CachedAC,
                  NULL)) {

        DPRINT(2,"Error in getting object info\n");
        return pTHS->errCode;
    }
    else {
         DPRINT1(5, "Object retrieved: %S\n", pNewEntList->Entinf.pName);
         *ppEntInfList = pNewEntList;
         if(pRange) {
             *ppRangeInfList = pNewRangeList;
         }
         return 0;
    }
}


/*-------------------------------------------------------------------------*/
/*
   Check if this is a continued operation (paged results).  Regardless, find
   the first object which matches the search.
*/

DWORD
FindFirstSearchObject (
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart,
        PSECURITY_DESCRIPTOR *ppSecurity
        )
{
    ULONG dwSearchStatus;
    BOOL fNegDelta=FALSE;
    ULONG LocalSearchFlags;
    ULONG SearchFlags;
    BOOL  fVLVSearch = FALSE;
    PRESTART pArgVLVRestart = NULL;

    if (pDB->Key.pVLV) {
        fVLVSearch = TRUE;
        pArgVLVRestart = pDB->Key.pVLV->pVLVRequest->pVLVRestart;
    }

    // we don't want Delta usage with VLV, since VLV imposes
    // its own delta usage
    Assert ( (pSearchArg->CommArg.Delta && !fVLVSearch) ||
             (!pSearchArg->CommArg.Delta) );

    // Set up the search flags we'll use to find the first object based on
    // restarting or simply going to the first element of the index, ignoring
    // deltas and security.
    SearchFlags = SEARCH_FLAGS(pSearchArg->CommArg);

    // Set up the search flags we'll use to move away from that object to the
    // object which is the real first object after we take into account security
    // and deltas.
    LocalSearchFlags = SearchFlags;

    switch(pSearchArg->CommArg.Delta) {
    case DB_MoveFirst:
        // Fall through
    case DB_MoveLast:
        // Fall through
    case 0:
        // No Delta anyway.

        // In all these cases, we don't need to change anything about direction
        // and we aren't backing up.
        break;
    default:
        if(pSearchArg->CommArg.Delta < 0) {
            fNegDelta = TRUE;
            pSearchArg->CommArg.Delta *= -1;
            // Switch the DB_SEARCH_FORWARD flag in the local search flags.
            LocalSearchFlags = REVERSE_SEARCH_FLAGS(pSearchArg->CommArg);
        }
        break;
    }

    if (pArgRestart) {
        // restarted operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            ppSecurity,
                                            SearchFlags
                                            );
    }
    else if (pArgVLVRestart) {
        // VLV operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgVLVRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            ppSecurity,
                                            SearchFlags
                                            );
    }
    else {
        DWORD dwIndexFlags = (pSearchArg->choice == SE_CHOICE_BASE_ONLY)
                                ? 0 : DBCHOOSEINDEX_fUSEFILTER;

        if(!(pSearchArg->CommArg.fForwardSeek)) {
            dwIndexFlags |= DBCHOOSEINDEX_fREVERSE_SORT;
        }

        if (pSearchArg->CommArg.PagedResult.fPresent) {
            dwIndexFlags |= DBCHOOSEINDEX_fPAGED_SEARCH;
        }

        if (fVLVSearch) {
            dwIndexFlags |= DBCHOOSEINDEX_fVLV_SEARCH;
        }

        if (SearchFlags & DB_SEARCH_DELETIONS_VISIBLE) {
            dwIndexFlags |= DBCHOOSEINDEX_fDELETIONS_VISIBLE;
        }

        // if the client asks to leave the results in a sorted table,
        // then we do that since we sort at the same time
        // otherwise we use the default mechanism,
        // which is creating a list of the returned entries in memory

        if (pSearchArg->fPutResultsInSortedTable) {
            dwIndexFlags |= DBCHOOSEINDEX_fUSETEMPSORTEDTABLE;
        }

        if ((dwSearchStatus = DBSetSearchScope(
                pDB,
                pSearchArg->choice,
                pSearchArg->bOneNC,
                pSearchArg->pResObj)) ||
            (dwSearchStatus = DBChooseIndex(
                    pDB,
                    pSearchArg->CommArg.StartTick,
                    pSearchArg->CommArg.DeltaTick,
                    pSearchArg->CommArg.SortAttr,
                    pSearchArg->CommArg.SortType,
                    dwIndexFlags,
                    pSearchArg->CommArg.MaxTempTableSize))) {
            return dwSearchStatus;
        }

#if DBG
        {
           KEY_INDEX *tmp_index;

           for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
               DPRINT3 (2, "Cantidate Idx: %s(%d) %d\n", tmp_index->szIndexName, tmp_index->bIsIntersection, tmp_index->ulEstimatedRecsInRange);
           }
        }
#endif

        // check to see what kind of search operation control we are passed
        //
        if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp) {

            DBGenerateLogOfSearchOperation (pDB);

            // if we are told not to find any object, but just optimize the filter,
            // return an error so as to finish searching.
            //
            if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp & SO_ONLY_OPTIMIZE) {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
        // if we are tracing, and we already don't have created the logfilter
        // we do this now
        else if (gpDsEventConfig->fTraceEvents) {
            DBGenerateLogOfSearchOperation (pDB);
        }

        if (pSearchArg->fPutResultsInSortedTable) {
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }

        // we don't want to find the first object here if we are doing VLV
        if (!fVLVSearch) {
            dwSearchStatus= DBGetNextSearchObject(pDB,
                                                  pSearchArg->CommArg.StartTick,
                                                  pSearchArg->CommArg.DeltaTick,
                                                  ppSecurity,
                                                  SearchFlags);
        }
    }


    // if we are doing a VLV search, then use special positioning for this
    if (fVLVSearch) {
        // if we are doing container based VLV, we have to check for
        // access rights on the container.
        if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

            // look up the container object.
            if(DBTryToFindDNT(pDB, pDB->Key.ulSearchRootDnt)) {
                // The container couldn't be found, hence it is empty.
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

            // Check access
            if(!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, FALSE)) {
                DPRINT(1, "Access Denied Listing Contents of VLV search.\n");

                // set count to zero, since we don't allow you to see any entries
                pDB->Key.pVLV->contentCount = 0;

                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }

        // At this point, we need to position ourselves correctly
        // on the specified entry.

        dwSearchStatus = DBPositionVLVSearch (pDB, pSearchArg, ppSecurity);

        return dwSearchStatus;
    }
    // if we are doing ASQ, we are already positioned. bail
    // we are not doing delta adjustements for ASQ
    else if (pDB->Key.asqRequest.fPresent) {
        return dwSearchStatus;
    }
    else if(dwSearchStatus && dwSearchStatus != DB_ERR_NEXTCHILD_NOTFOUND) {
        // Oops, we've already failed.  Other failures are handled below.
        return dwSearchStatus;
    }

    // Delta position adjustments
    if (pSearchArg->CommArg.Delta) {
        if(pSearchArg->CommArg.Delta == DB_MoveFirst) {
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      ppSecurity,
                                      SearchFlags);
            pSearchArg->CommArg.Delta = 0;
        }
        else if(pSearchArg->CommArg.Delta == DB_MoveLast) {
            // Drop any positioning we currently have, switch the forward bit in the
            // flags, and reposition.  We switch the forward bit so that we will go
            // to the end of the index instead of the beginning.
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      ppSecurity,
                                      REVERSE_SEARCH_FLAGS(pSearchArg->CommArg));
            if(dwSearchStatus == DB_ERR_TIMELIMIT) {
                // We bail out if we get this error.
                return dwSearchStatus;
            }
            DBMove(pDB, FALSE,
                   (pSearchArg->CommArg.fForwardSeek?DB_MoveNext:DB_MovePrevious));
            dwSearchStatus =  DB_ERR_NEXTCHILD_NOTFOUND;
            pSearchArg->CommArg.Delta = 0;
        }
        else if(dwSearchStatus && pSearchArg->CommArg.Delta && fNegDelta) {
            // We aren't on an object (so we are logically past the end of the
            // list), but we need to apply a delta backwards.  Force the code path
            // to back up.
            dwSearchStatus = 0;
        }
    }

    // At this point, we are on the beginning object of the search (that is,
    // we are either at the beginning of the index if DB_MoveFirst was
    // specified, the end if DB_MoveLast was specified, or somewhere in the
    // middle if we did a restart. Now, walk away
    // from that object applying security and the delta we were given to arrive
    // at the "real" first object.

    while(!dwSearchStatus) {
        // Found something, apply list rights.
        if(IsObjVisibleBySecurity(pDB->pTHS, TRUE)) {
            // List rights OK
            if(pSearchArg->CommArg.Delta) {
                // But we need to skip some.
                pSearchArg->CommArg.Delta--;
            }
            else {
                // And we don't need to skip any
                break;
            }
        }

        dwSearchStatus = DBGetNextSearchObject(
                pDB,
                pSearchArg->CommArg.StartTick,
                pSearchArg->CommArg.DeltaTick,
                ppSecurity,
                LocalSearchFlags );
    }

    if((dwSearchStatus == DB_ERR_NEXTCHILD_NOTFOUND) && fNegDelta) {
        // Not on a valid object, and we were backing up.  That means we should
        // find the first object.  Call recursively to avoid duplicate code, but
        // recursion depth will never be greater than 1.
        pSearchArg->CommArg.Delta = DB_MoveFirst;
        return FindFirstSearchObject (pDB,
                                      pSearchArg,
                                      pArgRestart,
                                      ppSecurity);
    }

    return dwSearchStatus;
}


void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals)
{
    DWORD DNT, actualRead;
    DWORD err;

    if (*ppASQReferrals == NULL) {
        *pcASQRefAlloced = 32;
        *ppASQReferrals = THAllocEx (pTHS, sizeof (DWORD) * (*pcASQRefAlloced));
    }
    else if (*pcASQRefCount >= *pcASQRefAlloced) {
        *pcASQRefAlloced = *pcASQRefAlloced * 2;
        *ppASQReferrals = THReAllocEx (pTHS, *ppASQReferrals, sizeof (DWORD) * (*pcASQRefAlloced));
    }

    if (err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_DNT, &DNT, sizeof (DNT), &actualRead)) {
        DPRINT1 (0, "Error reading DNT: 0x%x\n", err);
        return;
    }

    (*ppASQReferrals)[*pcASQRefCount] = DNT;

    *pcASQRefCount = *pcASQRefCount + 1;

    DPRINT1 (1, "ASQREF for DNT: 0x%x\n", DNT);

    return;
}

void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals)
{
    DBPOS * pDB = pTHS->pDB;
    DSNAME *pObject;
    ATTRBLOCK *pObjB = NULL;
    PARTIALOUTCOME * pPOQ;
    CONTREF *pContRef, **ppContRef;
    DWORD DNT, actualRead;
    DWORD err, i;


    DPRINT1 (0, "GENERATING %d refferral(s) for ASQ\n", cASQRefCount);

    pPOQ = *ppPOQ;

    if (pPOQ == NULL) {
        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;


    for (i=0; i<cASQRefCount; i++) {
        DNT = pASQReferrals[i];

        pObject = DBGetDSNameFromDnt (pDB, DNT);
        if (!pObject) {
            DPRINT (0, "Error getting DSNAME\n");
            return;
        }
        DPRINT1 (0, "ASQREF: %ws\n", pObject->StringName);

        err = DSNameToBlockName(pTHS, pObject, &pObjB, DN2BN_PRESERVE_CASE);
        if (err) {
            DPRINT (0, "Bad Name\n");
            return;
        }

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        pContRef->pTarget = pObject;

        pContRef->pNewFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at the DC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  pObjB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

        FreeBlockName(pObjB);
    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ)
{
    const DSNAME * const pObject = pSearchArg->pObject;
    const UCHAR choice = pSearchArg->choice;
    PARTIALOUTCOME * pPOQ;
    DBPOS * pDB = pTHS->pDB;
    ULONG it;
    ULONG len, iVal;
    DWORD err;
    ATTCACHE * pAC;
    DSNAME *pSRName = NULL;
    CONTREF *pContRef, **ppContRef;
    DSNAME *pName = NULL;
    WCHAR * pDNS;
    CROSS_REF *pCrossRef;
    ATTRTYP ObjClass;
    PSUBREF_LIST pDomainSubref;
    BOOL fDomainSubrefHit;
    DWORD i, nVal;
    DSA_ADDRESS_LIST *pDAL;

    pPOQ = *ppPOQ;

    if (!pSearchArg->bOneNC &&
        pSearchArg->choice != SE_CHOICE_IMMED_CHLDRN) {
        // The only time we issue referrals on a GC search should be
        // for the special ABView referrals, which we only issue for
        // one level searches.
        return;
    }
    if (pPOQ == NULL) {

        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;

        // WHy an admin limit?  Because the only case where we
        // generate a brand-new POQ here is from encountering NC
        // boundaries.  If we've already encountered a size or time
        // limit, we'll let that POQ code stand as is, and just return
        // the contrefs as a bonus.  Note the special handling of pPOQ
        // at the end of this routine for the other half of this logic.
    }
    pPOQ->count = 0;

    ObjClass = pSearchArg->pResObj->MostSpecificObjClass;
    it = pSearchArg->pResObj->InstanceType;

    if (pSearchArg->bOneNC) {
        // We need to go to the NC head to get the subref information. The
        // assert swears that if the search root is an NC head, then our resobj
        // NCDNT matches our DNT, meaning that we're going to the right place.
        Assert(   !!(it & IT_NC_HEAD)
               == !!(pSearchArg->pResObj->NCDNT == pSearchArg->pResObj->DNT));

        Assert(pPOQ->pUnexploredDSAs == 0);
        ppContRef = &pPOQ->pUnexploredDSAs;

        // Check the cache of ATT_SUB_REFS in gAnchor
        if (pSearchArg->pResObj->NCDNT == gAnchor.ulDNTDomain &&
            gAnchor.fDomainSubrefList) {

            // For each cached ATT_SUB_REFS
            for (pDomainSubref = gAnchor.pDomainSubrefList;
                 pDomainSubref;
                 pDomainSubref = pDomainSubref->pNextSubref) {

                fDomainSubrefHit = FALSE;

                // Is the subref subordinate to this object?
                if (choice == SE_CHOICE_WHOLE_SUBTREE) {
                    for (i = 0; i < pDomainSubref->cAncestors; ++i) {
                        if (*(pDomainSubref->pAncestors + i) == pSearchArg->pResObj->DNT) {
                            fDomainSubrefHit = TRUE;
                            break; // out of inner for
                        }
                    }
                }
                // Is the subref an immediate child of this object?
                else if (   (choice == SE_CHOICE_IMMED_CHLDRN)
                           && (pDomainSubref->cAncestors > 1)
                           && (*(pDomainSubref->pAncestors + 1) == pSearchArg->pResObj->DNT)) {
                    fDomainSubrefHit = TRUE;
                }
                // HIT. save a copy of the DSName
                if (fDomainSubrefHit) {
                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = THAllocEx(pTHS,
                                                  pDomainSubref->pDSName->structLen);
                    CopyMemory(pContRef->pTarget,
                               pDomainSubref->pDSName,
                               pDomainSubref->pDSName->structLen);
                    pPOQ->count++;
                }
            }
        }
        // Read the subrefs because the cache isn't valid for this search.
        else {
            err = DBFindDNT(pDB, pSearchArg->pResObj->NCDNT);
            if (err) {
                LogUnhandledError(err);
                return;
            }

            iVal = 1;
            pAC = SCGetAttById(pTHS, ATT_SUB_REFS);
            //
            // PREFIX: PREFIX complains that pAC hasn't been checked to
            // make sure that it is not NULL.  This is not a bug.  Since
            // a predefined constant was passed to SCGetAttById, pAC will
            // never be NULL.
            //

            Assert(pAC);

            while (0 == DBGetAttVal_AC(pDB,
                                       iVal,
                                       pAC,
                                       0,
                                       0,
                                       &len,
                                       (UCHAR**)&pSRName)) {
                pName = (DSNAME *)THAllocEx(pTHS, pSRName->structLen);
                if (((choice == SE_CHOICE_IMMED_CHLDRN) &&
                     (0 == TrimDSNameBy(pSRName, 1, pName)) &&
                     NameMatched(pObject, pName))
                    ||
                    ((choice == SE_CHOICE_WHOLE_SUBTREE) &&
                     NamePrefix(pObject, pSRName))) {

                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = pSRName;
                    pSRName = NULL;
                    pPOQ->count++;
                }
                else {
                    THFreeEx(pTHS, pSRName);
                }
                ++iVal;
                // Free memory allocated in this iteration of while
                THFreeEx(pTHS, pName);
            }
        }
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;
    while (pContRef) {
        // Find the in memory CrossRef structure corresponding to this NC
        pCrossRef = FindExactCrossRef(pContRef->pTarget,
                                      &pSearchArg->CommArg);
        if (!pCrossRef) {
            /*
             * Once replication has quiesced, we should have a cross-ref
             * for every sub-ref.  While replication is still going on,
             * though, we could easily have replicated in a sub-ref with
             * one naming context before we have fully synched the config
             * NC, meaning that the cross-ref would not have replicated in
             * yet.  This means that we can't make a blanket assertion that
             * we should have a cross ref.  Instead we can only assert that
             * this should be the case if replication is complete.
             */
            DPRINT1(0, "Can't find cross-ref for %ls\n",
                        pContRef->pTarget->StringName);
            LooseAssert(!"Can't find cross-ref object!", SubrefReplicationDelay);

            goto SkipIt;
        }

        if(!pCrossRef->bEnabled){
            // We don't generate referrals of any kind for disabled
            // crossRefs.  As far as the directory is concerned we this
            // part of the directory does not exist yet.
            goto SkipIt;
        }

        // No referrals?
        if (0 == pCrossRef->DnsReferral.valCount) {
            goto SkipIt;
        }

        // Add each dns name
        pContRef->pDAL = NULL; // just in case
        for (nVal = 0; nVal < pCrossRef->DnsReferral.valCount; ++nVal) {
            len = pCrossRef->DnsReferral.pAVal[nVal].valLen;
            pDNS = THAllocEx(pTHS, len);
            memcpy(pDNS, pCrossRef->DnsReferral.pAVal[nVal].pVal, len);

            Assert(len < 64*1024);

            len = AdjustDNSPort(pDNS, len, (pTHS->CipherStrength == 0));

            // Copy the address information into the Continuation
            pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
            pDAL->pNextAddress = pContRef->pDAL;
            pDAL->Address.Length = (unsigned short) len;
            pDAL->Address.MaximumLength = (unsigned short) len;
            pDAL->Address.Buffer = pDNS;
            pContRef->pDAL = pDAL;
        }
        if (choice == SE_CHOICE_IMMED_CHLDRN) {
            pContRef->bNewChoice = TRUE;
            pContRef->choice = SE_CHOICE_BASE_ONLY;
        }

        /* Since we have successfully processed this entry, step to the
         * next entry in the list.
         */
        ppContRef = &pContRef->pNextContRef;
        pContRef = pContRef->pNextContRef;
        continue;

        /* this line is not reached */
SkipIt:
        /* This contref was messed up for some reason, so we want to snip
         * it out of the list, so that all contrefs in our output list
         * are valid
         */
        pPOQ->count--;             // decrement the count of contrefs
        *ppContRef = pContRef->pNextContRef; // step around the element
        THFreeEx(pTHS, pContRef->pTarget); // free a sub part
        THFreeEx(pTHS, pContRef);          // free the contref
        pContRef = *ppContRef;     // reset our loop pointer
    }

    if ((ObjClass == CLASS_ADDRESS_BOOK_CONTAINER) &&
        (pSearchArg->choice == SE_CHOICE_IMMED_CHLDRN)) {
        // Ok, this was a one-level search under an ABView, which means
        // that we get to construct a magic search continuation.  The
        // search described will have be to a GC (always), have a base
        // object of root, be whole subtree, and have a filter that is
        // an AND of the input filter, a special Show-In this View filter,
        // and DISPLAY_NAME present (the index we maintain over Show-In is
        // compound over show-in and display-name, and is defined
        // ignore_any_null, so we can only use it in the display-name present
        // case.
        FILTER * pFilterTemp;

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        // re-base the search to the root
        pContRef->pTarget = THAllocEx(pTHS, DSNameSizeFromLen(0));
        pContRef->pTarget->structLen = DSNameSizeFromLen(0);

        // re-scope the search
        pContRef->bNewChoice = TRUE;
        pContRef->choice = SE_CHOICE_WHOLE_SUBTREE;

        // re-filter the search
        pContRef->pNewFilter = THAllocEx(pTHS, sizeof(FILTER));
        pContRef->pNewFilter->choice = FILTER_CHOICE_AND;
        pContRef->pNewFilter->FilterTypes.And.count = 3;
        pContRef->pNewFilter->FilterTypes.And.pFirstFilter =
            pFilterTemp = THAllocEx(pTHS, 2 * sizeof(FILTER));

        // First clause: Show-In is the address book in question
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
          ATT_SHOW_IN_ADDRESS_BOOK;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen =
          pSearchArg->pObject->structLen;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal =
          (UCHAR*)(pSearchArg->pObject);
        pFilterTemp->pNextFilter = &pFilterTemp[1];
        pFilterTemp++;

        // Second clause: Display-name present
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
            ATT_DISPLAY_NAME;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen = 0;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal = NULL;

        // Third clause: Pick up the filter they gave us.
        pFilterTemp->pNextFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at a GC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  gpRootDNB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


VOID
SimpleBaseSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        )
{
    ULONG                ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD               getEntInfFlags = 0;
    RESOBJ              *pResObjArg;
    PDSNAME             pParent = NULL;

    // Before we start, mark that we are as sorted as we were requested to be.
    pTHS->pDB->Key.ulSorted = pSearchArg->CommArg.SortType;
    pSearchRes->bSorted = (pTHS->pDB->Key.ulSorted != SORT_NEVER);

    // PERFINC(pcSearchSubOperations);
    pTHS->pDB->SearchEntriesVisited += 1;
    
    // First, make sure we have list content rights on the parent.
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            return;
        }

        // Now, get the security descriptor for this object.
        if(!(flags & SEARCH_UNSECURE_SELECT)) {
            DBPOS* pDB = pTHS->pDB;
            char objFlag;
            DWORD err;
            err = DBGetObjectSecurityInfo(
                    pDB,
                    pDB->DNT,
                    &ulLen,
                    &pSec,
                    NULL,
                    NULL,
                    &objFlag,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
                );
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            // Every object should have an SD.
            Assert(objFlag == 0 || ulLen > 0);
        }
    }

    SvccntlFlagsToGetEntInfFlags(&pSearchArg->CommArg.Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    if ((pSearchArg->pResObj->pObj->NameLen)
        || (pSearchArg->pSelection->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObjArg = pSearchArg->pResObj;
    }
    else {
        pResObjArg = NULL;
    }

    // Do the GetEntInf
    if(!GetEntInf(pTHS->pDB,
                  pSearchArg->pSelection,
                  pSearchArg->pSelectionRange,
                  &pSearchRes->FirstEntInf.Entinf,
                  &pSearchRes->FirstRangeInf.RangeInf,
                  pSearchArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObjArg)) {

#if 0
        //
        // This is #if 0 instead of removed to allow for our bosses to
        // change their minds on the issue of whether we should be returning
        // an error or not
        //

        if ((pSearchRes->FirstEntInf.Entinf.AttrBlock.attrCount == 0) &&
            (pSearchArg->pSelection) &&
            (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

            // it is an error if the user requested a list of
            // attributes and none were found on any objects.

            SetAttError(pSearchArg->pObject, 0L,
                        PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                        DIRERR_NO_REQUESTED_ATTS_FOUND);
        }
#endif
        // success, set the count.
        pSearchRes->count = 1;
    }

    if(pSec) {
        THFreeEx(pTHS, pSec);
    }

    return;
} // SimpleBaseSearch

BOOL
IsBaseOnlyAttPresent(
    SEARCHARG *pSearchArg
)
{
   ULONG i;
   ENTINFSEL *pSel = pSearchArg->pSelection;

   if (!pSel) {
      // no selection to check
      // return false, since constructed atts are returned
      // only when explicitly asked for, that is, there is
      // a selection
      return FALSE;
   }

   for (i=0; i<pSel->AttrTypBlock.attrCount; i++) {
       switch(pSel->AttrTypBlock.pAttr[i].attrTyp) {
          case ATT_TOKEN_GROUPS:
          case ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE:
              if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
                 // non-base search
                 return TRUE;
              }
              break;
          default:
             // more attributes may need to be added later
             ;
       }
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\msrpc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msrpc.c
//
//--------------------------------------------------------------------------

/*
Description:
    Routines to setup MS RPC, server side.
*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include <dsconfig.h>
#include "dsexcept.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB  "MSRPC:"                // Define subsystem for debugging

// RPC interface headers
#include <nspi.h>
#include <drs.h>

#include "msrpc.h"          /* Declarations of exports from this file */

#include <ntdsbcli.h>
#include <ntdsbsrv.h>

#include <fileno.h>
#define  FILENO FILENO_MSRPC

#define DRS_INTERFACE_ANNOTATION        "MS NT Directory DRS Interface"
#define NSP_INTERFACE_ANNOTATION        "MS NT Directory NSP Interface"

BOOL gbLoadMapi = FALSE;
ULONG gulLDAPServiceName=0;
PUCHAR gszLDAPServiceName=NULL;

char szNBPrefix[] ="ncacn_nb";

int gRpcListening = 0;
int gNumRpcNsExportedInterfaces = 0;
RPC_IF_HANDLE gRpcNsExportedInterface[MAX_RPC_NS_EXPORTED_INTERFACES];

char gRpcNSEntryName[MAX_NS_ENTRY_NAME_LEN];

ULONG ulMaxCalls;

BOOL StartServerListening(void);

/*
 * We should get this from nspserv.h, but it's defined with MAPI stuff there.
 */
extern UUID muidEMSAB;

RPC_STATUS RPC_ENTRY
DraIfCallbackFn(
    RPC_IF_HANDLE   InterfaceUuid,
    void            *Context
    )
/*++
    Clients use GSS_NEGOTIATE when binding to the DRA interface as
    prescribed by the security folks.  For various reasons, the negotiated
    protocol may be NTLM as opposed to Kerberos.  If the client security
    context was local system and NTLM is negotiated, then the client comes
    in as the null session which has few rights in the DS.  This causes 
    clients like the KCC, print spooler, etc. to get an incomplete view of 
    the world with correspondingly negative effects.  

    This routine insures that unauthenticated users will be rejected. These
    are the correct semantics from the client perspective as well.  
    I.e.  Either the client comes in with useful credentials that let him 
    see what he should, or he is rejected totally and should retry the bind.
--*/
{
    return(VerifyRpcClientIsAuthenticatedUser(Context, InterfaceUuid));
}

VOID InitRPCInterface( RPC_IF_HANDLE hServerIf )
{
    RPC_STATUS status;
    int i;

    // Allow unauthenticated users for all interfaces except DRA.

    if ( hServerIf == drsuapi_ServerIfHandle ) {
        status = RpcServerRegisterIfEx(hServerIf, NULL, NULL, 0,
                                       ulMaxCalls, DraIfCallbackFn);
    } else {
        status = RpcServerRegisterIf(hServerIf, NULL, NULL);
    }

    if ( status ) {
        DPRINT1( 0, "RpcServerRegisterIf = %d\n", status);
        LogAndAlertUnhandledError(status);

        if ( gfRunningInsideLsa )
        {
            // Don't exit process as this will kill the entire system!
            // Keep running w/o RPC interfaces.  LDAP can still function
            // and if this is a standalone server (i.e. no replicas)
            // that may be good enough.

            return;
        }
        else
        {
            // Original service based behavior.

            exit(1);
        }
    }
    DPRINT( 2, "InitRPCInterface(): Server interface registered.\n" );
    
    
    // If the handle is already in the array, don't add it into the array again
    // This checking is necessary because nspi can be opened/closed multiple times
    // without being reboot.

    for ( i = 0; 
          i<gNumRpcNsExportedInterfaces && gRpcNsExportedInterface[i]!=hServerIf;
          i ++ );
   
    if( i >= gNumRpcNsExportedInterfaces )
    {

        // export interface to RPC name service
        // we keep track of the interfaces we want to export to the RPC name
        // service because we export them and unexport them every time the
        // server starts and stops listening

        if (gNumRpcNsExportedInterfaces >= MAX_RPC_NS_EXPORTED_INTERFACES)
        {
            DPRINT(0,"Vector of interfaces exported to Rpc NS is too small\n");
            return;
        }
        gRpcNsExportedInterface[ gNumRpcNsExportedInterfaces++ ] = hServerIf;
    }
    // If server is currently listening export the interface. Otherwise,
    // it will be taken care of when the server starts listening

    if (gRpcListening) {
        MSRPC_RegisterEndpoints(hServerIf);
    } 
}


BOOL StartServerListening(void)
{
    RPC_STATUS  status;

    status = RpcServerListen(1,ulMaxCalls, TRUE);
    if (status != RPC_S_OK) {
        DPRINT1( 0, "RpcServerListen = %d\n", status);
    }

   return (status == RPC_S_OK);
}


VOID StartDsaRpc(VOID)
{
    if(gbLoadMapi) {
        InitRPCInterface(nspi_ServerIfHandle);
        DPRINT(0,"nspi interface installed\n");
    }
    else {
        DPRINT(0,"nspi interface installed\n");
    }

    InitRPCInterface(dsaop_ServerIfHandle);
    DPRINT(0,"dsaop interface installed\n");
}

VOID StartDraRpc(VOID)
{
    InitRPCInterface(drsuapi_ServerIfHandle);
    DPRINT(0,"dra (and duapi!) interface installed\n");
}


// Start the server listening. Ok to call this even if the server is already
// listening

void
MSRPC_Install(BOOL fRunningInsideLsa)
{
    int i;
    
    if (gRpcListening)
        return;

    // start listening if not running as DLL
    if (!fRunningInsideLsa)
      gRpcListening = StartServerListening();

    // export all registered interfaces to RPC name service

    for (i=0; i < gNumRpcNsExportedInterfaces; i++)
        MSRPC_RegisterEndpoints( gRpcNsExportedInterface[i] );
    
    if (fRunningInsideLsa) {
        gRpcListening = TRUE;
    }
    
}

VOID
MSRPC_Uninstall(BOOL fStopListening)
{
    RPC_STATUS status;
    int i;

    if ( fStopListening )
    {
        //
        // N.B.  This is the usual case.  The ds is responsible for
        // shutting down the rpc listening for the entire lsass.exe
        // process.  We do this because we are the ones that need to kill
        // clients and then safely secure the database.
        //
        // The only case where we don't do this is during the two phase
        // shutdown of demote, where we want to kill external clients
        // but not stop the lsa from listening
        //
        status = RpcMgmtStopServerListening(0) ;
        if (status) {
            DPRINT1( 1, "RpcMgmtStopServerListening returns: %d\n", status);
        }
        else {
            gRpcListening = 0;
        }
    }

    // unexport the registered interfaces

    for (i=0; i < gNumRpcNsExportedInterfaces; i++)
        MSRPC_UnregisterEndpoints( gRpcNsExportedInterface[i] );

}

void MSRPC_WaitForCompletion()
{
    RPC_STATUS status;

    if (status = RpcMgmtWaitServerListen()) {
        DPRINT1(0,"RpcMgmtWaitServerListen: %d", status);
    }
}

void
MSRPC_RegisterEndpoints(RPC_IF_HANDLE hServerIf)
{

    RPC_STATUS status;
    RPC_BINDING_VECTOR * RpcBindingVector;
    char *szAnnotation;
    
    if(hServerIf == nspi_ServerIfHandle && !gbLoadMapi) {
        return;
    }

    if (status = RpcServerInqBindings(&RpcBindingVector))
    {
        DPRINT1(1,"Error in RpcServerInqBindings: %d", status);
        LogUnhandledErrorAnonymous( status );
        return;
    }

    // set up annotation strings for ability to trace client endpoints to
    // interfaces

    if (hServerIf == nspi_ServerIfHandle)
        szAnnotation = NSP_INTERFACE_ANNOTATION;
    else if (hServerIf ==  drsuapi_ServerIfHandle)
        szAnnotation = DRS_INTERFACE_ANNOTATION;
    else
        szAnnotation = "";

    // register endpoints with the endpoint mapper

    if (status = RpcEpRegister(hServerIf, RpcBindingVector, 0, szAnnotation))
    {
        DPRINT1(0,"Error in RpcEpRegister: %d\nWarning: Not all protocol "
                "sequences will work\n", status);
        LogUnhandledErrorAnonymous( status );
    }

    RpcBindingVectorFree( &RpcBindingVector );
}

void
MSRPC_UnregisterEndpoints(RPC_IF_HANDLE hServerIf)
{

    RPC_STATUS status;
    RPC_BINDING_VECTOR * RpcBindingVector;

    if(hServerIf == nspi_ServerIfHandle && !gbLoadMapi) {
        // We never loaded this
        return;
    }

    if (status = RpcServerInqBindings(&RpcBindingVector))
    {
        DPRINT1(1,"Error in RpcServerInqBindings: %d", status);
        LogUnhandledErrorAnonymous( status );
        return;
    }

    // unexport endpoints

    if ((status = RpcEpUnregister(hServerIf, RpcBindingVector, 0))
        && (!gfRunningInsideLsa)) {
            // Endpoints mysteriously unregister themselves at shutdown time,
            // so we shouldn't complain if our endpoint is already gone.  If
            // we're not inside LSA, though, all of our endpoints should
            // still be here (because RPCSS is still running), and should
            // unregister cleanly.
        DPRINT1(1,"Error in RpcEpUnregister: %d", status);
        LogUnhandledErrorAnonymous( status );
    }

    /* DaveStr - removed 10/11/96 - don't want any name service dependence.

    if (status = RpcNsBindingUnexport(RPC_C_NS_SYNTAX_DEFAULT,
                                      gRpcNSEntryName, hServerIf, 0))
    {
        DPRINT1(1,"Error in RpcNsBindingUnexport: %d", status);
    }

    */

    RpcBindingVectorFree( &RpcBindingVector );
}

static const char c_szSysSetupKey[]       ="System\\Setup";
static const char c_szSysSetupValue[]     ="SystemSetupInProgress";

BOOL IsSetupRunning()
{
    LONG    err, cbAnswer;
    HKEY    hKey ;
    DWORD   dwAnswer = 0 ;  // assume setup is not running

    //
    // Open the registry Key and read the setup running value
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       c_szSysSetupKey,
                       0,
                       KEY_READ,
                       &hKey);

    if (ERROR_SUCCESS == err) {
        LONG lSize = sizeof(dwAnswer);
        DWORD dwType;

        err = RegQueryValueEx(hKey,
                              c_szSysSetupValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwAnswer,
                              &lSize);
        RegCloseKey(hKey);

        if (ERROR_SUCCESS == err) {

            return(dwAnswer != 0);
        }
    }

    return(FALSE);
}


// Prepare the global variable containing the per DSA RPC name service
// entry name

void
MSRPC_Init()
{

    char  szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    char *szTmp = szComputerName;
    char *szPrincipalName;
    DWORD dwComputerNameLen = sizeof(szComputerName)/sizeof(szComputerName[0]);
    BYTE rgbSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) rgbSD;
    PSECURITY_DESCRIPTOR pSDToUse = NULL;
    char *szEndpoint;
    RPC_STATUS  status = 0;
    unsigned ulPort;
    char achPort[16];
    RPC_PROTSEQ_VECTOR *pProtseqVector = NULL;
    unsigned i;
    RPC_POLICY rpcPolicy;
    BOOL fTcpRegistered = FALSE;

    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;
    
    strcpy(gRpcNSEntryName, NS_ENTRY_NAME_PREFIX);
    GetComputerName(szComputerName, &dwComputerNameLen);

    /*
     * Translate '-' into '_'
     */                                                 

    while (szTmp=strchr(szTmp,'-')) {
        *szTmp = '_';
    }
    strcat(gRpcNSEntryName,szComputerName);
    (void) _strupr(gRpcNSEntryName);

    if (GetConfigParam(TCPIP_PORT, &ulPort, sizeof(ulPort))) {
        ulPort = 0;
        DPRINT1(0,"%s key not found. Using default\n", TCPIP_PORT);
    } else {
        _ultoa(ulPort, achPort, 10);
        DPRINT2(0,"%s key forcing use of end point %s\n", TCPIP_PORT,
                achPort);
    }

    /*
     * construct the default security descriptor allowing access to all
     * this is used to allow authenticated connections over LPC.
     * By default LPC allows access only to the same account
     */

    if (!InitializeSecurityDescriptor(pSD,SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)) {
        DPRINT1(0, "Error %d constructing a security descriptor\n",
                GetLastError());
        LogUnhandledError(status);
        pSD = NULL;
    }


    /*
     * get the list of protseqs supported by the server and the network
     */

    if ((status = RpcNetworkInqProtseqs(&pProtseqVector)) != RPC_S_OK) {
        DPRINT1(0,"RpcNetworkInqProtseqs returned %d\n", status);
        /*
         * This appears to be normal during the GUI mode portion of upgrade,
         * so don't log anything in that case.  If it's not setup, complain.
         */
        if (!IsSetupRunning()) {
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_NO_RPC_PROTSEQS,
                     szInsertUL(status),
                     NULL,
                     NULL);
        }
        // Keep running as best we can w/o RPC interfaces.
        return;
    }

    /*
     * register the protseqs we want to support. Register endpoints for the
     * LPC (for backward compatibility we need to use a well known endpoint)
     * and for TCP/IP if we need a well known endpoint. Ignore NETBIOS protseqs
     * except for NETBIOS on NETBEUI to avoid confusing RAS (RAS could route
     * packets to the wrong lana if we use multiple NETBIOS stacks).
     * use a security descriptor only for named pipes and LPC
     */

    for (i=0; i<pProtseqVector->Count; i++) {

        szEndpoint = NULL;
        pSDToUse = NULL;

        if (!_strnicmp(pProtseqVector->Protseq[i], szNBPrefix,
            sizeof(szNBPrefix) -1)) {
            /*
             *  this is a NETBIOS Protseq. Is it NB_NB?
             */
            if (_stricmp(pProtseqVector->Protseq[i], NB_NB_PROTSEQ)){
                /*
                 *  no - we don't support this protseq so skip it
                 */
                continue;
            }
        } else if (!_stricmp(pProtseqVector->Protseq[i], UDP_PROTSEQ)) {
         /*
          *  this is a UDP Protseq. 
              *  we don't support this protseq so skip it
              */
             continue;
        } else if (!_stricmp(pProtseqVector->Protseq[i], LPC_PROTSEQ)) {
            /* this is the LPC Protseq - need to use a well known endpoint and
             * a security descriptor
             */
            szEndpoint = DS_LPC_ENDPOINT;
            pSDToUse = pSD;

        } else if (!_stricmp(pProtseqVector->Protseq[i], NP_PROTSEQ)) {
            /*
             * this is the NP Protseq - The defaults are appropriate.
             */
        } else if (!_stricmp(pProtseqVector->Protseq[i], TCP_PROTSEQ)) {
            /*
             * this is the TCP/IP protseq. If we need to use a specific port
             * to work through a firewall we set it now
             */
            fTcpRegistered = TRUE;
            if (ulPort) {
                szEndpoint = achPort;
            }
        }
        /*
         * register the protseq or protseq and endpoint for usage
         */
        if (szEndpoint) {
            status=RpcServerUseProtseqEpEx(pProtseqVector->Protseq[i],
                ulMaxCalls, szEndpoint, pSDToUse, &rpcPolicy );
        } else {
            status=RpcServerUseProtseqEx(pProtseqVector->Protseq[i],
                ulMaxCalls, pSDToUse, &rpcPolicy );
        }

        if (status != RPC_S_OK) {
            DPRINT2(0,
                    "RpcServerUseProtseqEx (%s) returned %d\n",
                    pProtseqVector->Protseq[i],
                    status);
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_RPC_PROTSEQ_FAILED,
                     szInsertSz(pProtseqVector->Protseq[i]),
                     szInsertUL(status),
                     NULL);

        }
    }

    RpcProtseqVectorFree(&pProtseqVector);

    // Unilaterally register TCP_PROTSEQ so as to cover cases where TCP
    // isn't up when we init due to, for example, DHCP failure.  The RPC
    // options we use should init the interface on the protocol if it
    // comes alive later.

    if ( !fTcpRegistered )
    {
        szEndpoint = ulPort ? achPort : NULL;
        if (szEndpoint) {
            status=RpcServerUseProtseqEpEx(TCP_PROTSEQ,
                ulMaxCalls, szEndpoint, pSDToUse, &rpcPolicy );
        } else {
            status=RpcServerUseProtseqEx(TCP_PROTSEQ,
                ulMaxCalls, pSDToUse, &rpcPolicy );
        }

        if (status != RPC_S_OK) {
            DPRINT2(0,
                    "RpcServerUseProtseqEx (%s) returned %d\n",
                    TCP_PROTSEQ,
                    status);
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_RPC_PROTSEQ_FAILED,
                     szInsertSz(TCP_PROTSEQ),
                     szInsertUL(status),
                     NULL);

        }
    }

    /*
     * register the authentication services (NTLM and Kerberos)
     */

    if ((status=RpcServerRegisterAuthInfo(SERVER_PRINCIPAL_NAME,
        RPC_C_AUTHN_WINNT, NULL, NULL)) != RPC_S_OK) {
        DPRINT1(0,"RpcServerRegisterAuthInfo for NTLM returned %d\n", status);
        LogUnhandledErrorAnonymous( status );
     }

    // Kerberos requires principal name as well.

    status = RpcServerInqDefaultPrincNameA(RPC_C_AUTHN_GSS_KERBEROS,
                                           &szPrincipalName);

    if ( RPC_S_OK != status )
    {
        LogUnhandledErrorAnonymous( status );
        DPRINT1(0,
                "RpcServerInqDefaultPrincNameA returned %d\n",
                status);
    }
    else
    {
        Assert( 0 != strlen(szPrincipalName) );

        // save the PrincipalName, since the LDAP head needs it constantly
        gulLDAPServiceName = strlen(szPrincipalName);
        gszLDAPServiceName = malloc(gulLDAPServiceName);
        if (NULL == gszLDAPServiceName) {
            LogUnhandledErrorAnonymous( ERROR_OUTOFMEMORY );
            DPRINT(0, "malloc returned NULL\n");
            return;
        }
        memcpy(gszLDAPServiceName, szPrincipalName, gulLDAPServiceName);

        // Register negotiation package so we will also accept clients
        // which provided NT4/NTLM credentials to DsBindWithCred, for
        // example.

        status = RpcServerRegisterAuthInfo(szPrincipalName,
                                           RPC_C_AUTHN_GSS_NEGOTIATE,
                                           NULL,
                                           NULL);

        if ( RPC_S_OK != status )
        {
            LogUnhandledErrorAnonymous( status );
            DPRINT1(0,
                    "RpcServerRegisterAuthInfo for Negotiate returned %d\n",
                    status);
        }

        status = RpcServerRegisterAuthInfo(szPrincipalName,
                                           RPC_C_AUTHN_GSS_KERBEROS,
                                           NULL,
                                           NULL);

        if ( RPC_S_OK != status )
        {
            LogUnhandledErrorAnonymous( status );
            DPRINT1(0,
                    "RpcServerRegisterAuthInfo for Kerberos returned %d\n",
                    status);
        }

        RpcStringFree(&szPrincipalName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\mdupdate.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdupdate.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <lmaccess.h>                   // UF_* definitions

#include <dsjet.h>

// Core DSA headers.
#include <attids.h>
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // DRS_MSG_*
#include <gcverify.h>                   // THSTATE.GCVerifyCache
#include <winsock.h>                    // htonl, ntohl
#include <windns.h>

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include <permit.h>                     // permission constants
#include "dstaskq.h"
#include "filtypes.h"                   // definitions for FILTER_CHOICE_*
#include "mappings.h"
#include "debug.h"                      // standard debugging header
#include "prefix.h"
#include "hiertab.h"
#include "mdglobal.h"                   // DBIsSecretData

#include "drameta.h"

#include "nlwrap.h"                     // for dsI_NetNotifyDsChange()

#include <lmcons.h>                     // DNLEN

#define DEBSUB "MDUPDATE:"              // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDUPDATE


/* extern from mdinidsa.h. Should not be used anywhere else */
extern int WriteSchemaVersionToReg(DBPOS *pDB);

//
// Boolean to indicate if DS is running as mkdit.exe (constructing the
// boot dit (aka ship dit, initial dit) winnt\system32\ntds.dit.
//
// mkdit.exe manages the schema cache on its own. This boolean is used
// to disable schema cache updates by the mainline code.
//
extern BOOL gfRunningAsMkdit;


/* MACROS */
/* Internal functions */

BOOL gbDoListObject = FALSE;

#if defined(DBG)
DWORD gdwLastGlobalKnowledgeOperationTime; // from debug.h
#endif

typedef struct _INTERIM_FILTER_SEC {
    ATTCACHE *pAC;
    BOOL **pBackPointer;
} INTERIM_FILTER_SEC;

// Get temp DBPOS from hVerifyAtts cache if it's there already, or allocate
// one and cache it if not.
#define HVERIFYATTS_GET_PDBTMP(hVerifyAtts) \
    ((NULL != (hVerifyAtts)->pDBTmp_DontAccessDirectly) \
        ? (hVerifyAtts)->pDBTmp_DontAccessDirectly \
        : (DBOpen2(FALSE, &(hVerifyAtts)->pDBTmp_DontAccessDirectly), \
            (hVerifyAtts)->pDBTmp_DontAccessDirectly))

DWORD
IsAccessGrantedByObjectTypeList (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ACCESS_MASK ulAccessMask,
        POBJECT_TYPE_LIST pObjList,
        DWORD cObjList,
        DWORD *pResults,
        DWORD flags
        );

int
VerifyDsnameAtts (
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal);

void
HandleDNRefUpdateCaching (
        THSTATE *pTHS
        );

BOOL
fLastCrRef (
        THSTATE * pTHS,
        DSNAME *pDN
        );


BOOL IsMember(ATTRTYP aType, int arrayCount, ATTRTYP *pAttArray);
BOOL IsAuxMember (CLASSSTATEINFO  *pClassInfo, ATTRTYP aType, BOOL fcheckMust, BOOL fcheckMay );

#define LOCAL_DSNAME    0
#define NONLOCAL_DSNAME 1

VOID ImproveDSNameAtt(DBPOS *pDBTemp,
                      DWORD LocalOrNot,
                      DSNAME *pDN,
                      BOOL *pfNonLocalNameVerified);

int
CheckModifyPrivateObject(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj);


// Control access rights that the DS understands.
const GUID RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER =
            {0xcc17b1fb,0x33d9,0x11d2,0x97,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_SCHEMA_MASTER =
            {0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_RID_MASTER    =
            {0xd58d5f36,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_DO_GARBAGE_COLLECTION =
            {0xfec364e0,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_RECALCULATE_HIERARCHY =
            {0x0bc1554e,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_ALLOCATE_RIDS         =
            {0x1abd7cf8,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_OPEN_ADDRESS_BOOK     =
            {0xa1990816,0x4298,0x11d1,0xad,0xe2,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_PDC            =
            {0xbae50096,0x4752,0x11d1,0x90,0x52,0x00,0xc0,0x4f,0xc2,0xd4,0xcf};
const GUID RIGHT_DS_ADD_GUID              =
            {0x440820ad,0x65b4,0x11d1,0xa3,0xda,0x00,0x00,0xf8,0x75,0xae,0x0d};
const GUID RIGHT_DS_CHANGE_DOMAIN_MASTER =
            {0x014bf69c,0x7b3b,0x11d1,0x85,0xf6,0x08,0x00,0x2b,0xe7,0x4f,0xab};
const GUID RIGHT_DS_REPL_GET_CHANGES =
            {0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_SYNC =
            {0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_MANAGE_TOPOLOGY =
            {0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_MANAGE_REPLICAS =
            {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2};
const GUID RIGHT_DS_RECALCULATE_SECURITY_INHERITANCE =
            {0x62dd28a8,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_CHECK_STALE_PHANTOMS =
            {0x69ae6200,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_UPDATE_SCHEMA_CACHE =
            {0xbe2bb760,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_REFRESH_GROUP_CACHE =
            {0x9432c620,0x033c,0x4db7,0x8b,0x58,0x14,0xef,0x6d,0x0b,0xf4,0x77};
/*-------------------------------------------------------------------------*/
/* If an instance type and value was not provided, we assume the object is
   an internal master INT_MASTER.  We also validate the instance type.
*/

int SetInstanceType(THSTATE *pTHS,
                    DSNAME *pDN,
                    CREATENCINFO * pCreateNC)
{
    SYNTAX_INTEGER iType;
    DB_ERR dbErr = 0;
    DWORD errCode = 0;

    DPRINT(2, "SetInstanceType entered\n");

    dbErr = DBGetSingleValue(pTHS->pDB,
                             ATT_INSTANCE_TYPE, &iType, sizeof(iType), NULL);
    if (dbErr) {
        // No instance type has yet been set.
        Assert(DB_ERR_NO_VALUE == dbErr);
        Assert(!pTHS->fDRA && "Disable if running ref count test");

        if (pCreateNC) {
            // NC creation.
            if (pCreateNC->fNcAbove){
                // We hold the parent NC above the one being added. ...
                iType = NC_MASTER_SUBREF;
            } else {
                // We don't hold the parent NC above this one ...
                iType = NC_MASTER;
            }

        } else {
            // Normal internal node creation.
            iType = INT_MASTER;
        }

        dbErr = DBAddAttVal(pTHS->pDB, ATT_INSTANCE_TYPE, sizeof(iType), &iType);
        if (dbErr) {
            errCode = SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                                    dbErr);
        }
    } else {
        // Check the instance type is OK.
        if (!ISVALIDINSTANCETYPE(iType)) {
            DPRINT1(2, "Bad InstanceType <%lu>\n", iType);

            errCode = SetAttError(pDN, ATT_INSTANCE_TYPE,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                  DIRERR_BAD_INSTANCE_TYPE);
        }
    }

    return errCode;
}/*SetInstanceType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int AddCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN){

    SYNTAX_INTEGER iType;
    DWORD rtn;

    DPRINT(2,"AddCatalogInfo entered\n");

    /* Update the system catalog if necessary.  The basic rules are that NC
       objects are added to the DSA catalog, Subordinate Refs are only added
       if the parent object exists.  These references are added to the
       catalog of its parent NC.  Internal References are added only
       if the parent object exists on the same DSA.
    */


    /* Position on the attribute instance.  */
    if(rtn = DBGetSingleValue(pTHS->pDB,
                              ATT_INSTANCE_TYPE, &iType, sizeof(iType), NULL)) {
        // No instance type set or instance type is smaller than it should be.
        DPRINT(2,"Couldn't retrieve the att instance dir error\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_INSTANCE,
                 szInsertDN(pDN),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_RETRIEVE_INSTANCE, rtn );
    }

    DPRINT1(3,"Object Instance Type is <%lx>\n", iType);

    if(iType & IT_NC_HEAD) {
        // These are Naming Context heads.
        ATTRTYP attrNCList;

        if (iType & IT_NC_ABOVE) {
            // These are subrefs of some flavor.
            if (ParentExists(PARENTMASTER + PARENTFULLREP, pDN)) {
                return pTHS->errCode;
            }

            // Add this NC to the subrefs list on the NC above it.
            if (AddSubToNC(pTHS, pDN, DSID(FILENO,__LINE__))) {
                return pTHS->errCode;
            }
        }

        if (!(iType & IT_UNINSTANT)) {
            // Add this NC to the appropriate NC list on the ntdsDsa object.
            if (iType & IT_WRITE) {
                attrNCList = ATT_HAS_MASTER_NCS;
            }
            else {
                attrNCList = ATT_HAS_PARTIAL_REPLICA_NCS;
            }

            if (AddNCToDSA(pTHS, attrNCList, pDN, iType)) {
                return pTHS->errCode;
            }

            if (!(iType & (IT_NC_COMING | IT_NC_GOING))) {
                // This NC is now completely instantiated -- it is okay to
                // advertise the presence of this NC to clients.
                //
                // Bug 103583 2000/04/21 JeffParh - Note that currently this
                // will notify netlogon to reload NDNCs more often than it
                // should.  We can't differentiate NDNCs from "normal" NCs here
                // because during the originating creation of the NDNC the flags
                // on the in-memory crossRef haven't yet been updated (because
                // we're still in the middle of the transaction that sets the
                // flags on the cross-ref).
                pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon = TRUE;

                if ( !(iType & IT_WRITE)) {
                    //
                    // We had just completed replication of a RO NC.
                    // It's time to fork a GC promotion task
                    // (mark thread so that we'll fork it on transaction commit)
                    //
                    pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion = TRUE;
                }
            }
        }
    }
    else {
        // These are not NC heads.
        if(ParentExists((iType & IT_WRITE)?PARENTMASTER:PARENTFULLREP, pDN))
            return pTHS->errCode;
    }

    DPRINT(3,"Good return from AddCatalogInfo\n");
    return 0;

}/*AddCatalogInfo*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
   /* Update the system catalog if necessary.  The basic rules are that NC
      objects are removed from the DSA catalog, Subordinate Refs removed
      from the NC.

      This function can be called when an object is deleted or when an
      object is modified.
   */


int
DelCatalogInfo (
        THSTATE *pTHS,
        DSNAME *pDN,
        SYNTAX_INTEGER iType
        )
{
    DPRINT(2,"DelCatalogInfo entered\n");

    DPRINT1(3,"Object Instance Type is <%lx>\n", iType);

    if (iType & IT_NC_HEAD) {
        // These are Naming Context heads.
        ATTRTYP attrNCList;

        if (iType & IT_NC_ABOVE) {
            // These are subrefs of some flavor.
            // Remove this NC from the subrefs list on the NC above it.
            if (DelSubFromNC(pTHS, pDN, DSID(FILENO,__LINE__))) {
                return pTHS->errCode;
            }
        }

        if (!(iType & IT_UNINSTANT)) {
            // Remove this NC from the appropriate NC list on the ntdsDsa object.
            if (iType & IT_WRITE) {
                attrNCList = ATT_HAS_MASTER_NCS;
            }
            else {
                attrNCList = ATT_HAS_PARTIAL_REPLICA_NCS;
            }

            if (DelNCFromDSA(pTHS, attrNCList, pDN)) {
                return pTHS->errCode;
            }
        }

        if (!(iType & (IT_NC_COMING | IT_NC_GOING))) {
            // This NC was completely instantiated but is no longer -- we should
            // stop advertising the presence of this NC to clients.
            if (fIsNDNC(pDN)) {
                pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon
                    = TRUE;
            }
        }
    }

    DPRINT(3,"Good return from DelCatalogInfo\n");
    return 0;

}/*DelCatalogInfo*/


CSACA_RESULT
CheckSecurityAttCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        DWORD flags
        )
/*++
  Returns a special enum value indicating that:
  csacaAllAccessGranted - All requested access was granted
  csacaAllAccessDenied  - No access was granted whatsoever
  csacaPartialGrant     - Access was granted to some attributes but not to
                          others.  The caller must look at the ATTCACHE array
                          to see which attributes have been granted (pAC still
                          filled in) and which have been denied (pAC NULLed)
--*/
{
    ULONG i, j, k;
    DWORD cObjList;
    ATTCACHE ***Sorted = NULL, **temp;
    ULONG propSets=0;
    DWORD *pResults;
    GUID *pCurrentPropSet;
    ATTCACHE *pPrevAttribute=NULL;
    POBJECT_TYPE_LIST pObjList;
    BOOL fGranted, fDenied;
    DWORD err;

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return csacaAllAccessGranted;
    }

    if(!pCC) {
        // We are missing some parameters.
        // set up for no access
        memset(rgpAC, 0, cInAtts * sizeof(ATTCACHE *));
        return csacaAllAccessDenied;
    }

    if(cInAtts) {
        // We actually have an ATTCACHE array to deal with.

        // First, group the ATTCACHEs by propset.  Actually, indirect by one to
        // maintain the original sort order, which we must maintain.

        Sorted = (ATTCACHE ***)THAllocEx(pTHS,cInAtts * sizeof(ATTCACHE**));
        for(i=0;i<cInAtts;i++) {
            if(rgpAC[i]) {
                Sorted[i] = &rgpAC[i];
            }
            else {
                Sorted[i] = NULL;
            }
        }

        propSets = 1;
        for(i=0;i<(cInAtts-1);) {
            if(!Sorted[i]) {
                i++;
                continue;
            }

            // First, skip over all the attributes at the front of the list that
            // are already grouped into a propset.
            while((i < (cInAtts - 1)) &&
                  Sorted[i+1]         &&
                  (memcmp(&(*Sorted[i])->propSetGuid,
                          &(*Sorted[i + 1])->propSetGuid,
                          sizeof(GUID)) == 0 )) {
                i++;
            }

            // Now, elements 0 through i in Sorted[] are already grouped by
            // propset, and Sorted[i+i] belongs in another propset than
            // Sorted[i]. Continue looking through Sorted[] for more attributes
            // in the same propset as Sorted[i].

            for(k=i+1,j=i+2; j < cInAtts; j++) {
                if(Sorted[j] &&
                   memcmp(&(*Sorted[i])->propSetGuid,
                          &(*Sorted[j])->propSetGuid,
                          sizeof(GUID)) == 0) {
                    // equal, swap
                    temp = Sorted[k];
                    Sorted[k] = Sorted[j];
                    Sorted[j] = temp;
                    k++;
                    // Now, elements 0 through (k - 1) in Sorted[] are
                    // grouped by propset.  Furthermore, Sorted[i] and
                    // Sorted[k - 1] are in the same propset.
                }
            }

            propSets++;
            i=k;
        }

    }

    // Now, create the list
    pObjList = (POBJECT_TYPE_LIST) THAllocEx( pTHS,
            (cInAtts + propSets + 1) * sizeof(OBJECT_TYPE_LIST));
    pResults = (LPDWORD) THAllocEx(pTHS,(cInAtts + propSets + 1) * sizeof(DWORD));
    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = &(pCC->propGuid);

    if(cInAtts) {
        // Ok, put the grouped GUIDS into the objlist structure.
        pCurrentPropSet = NULL;

        for(j=1,i=0;i<cInAtts;i++) {
            if(!Sorted[i]) {
                continue;
            }

            // we are not allowed to pass the same attribute (under the same)
            // propGuid more than once.
            // this will make sure this is not happening, since the
            // attributes are already sorted on propguid+attrGuid
            if (pPrevAttribute == (*Sorted[i])) {
                continue;
            }

            if(!pCurrentPropSet ||
               memcmp(&(*Sorted[i])->propSetGuid,
                      pCurrentPropSet,
                      sizeof(GUID))) {
                // Tripped into a new propset.
                pObjList[j].Level = ACCESS_PROPERTY_SET_GUID;
                pObjList[j].Sbz = 0;
                pObjList[j].ObjectType = &(*Sorted[i])->propSetGuid;
                pCurrentPropSet = &(*Sorted[i])->propSetGuid;

                j++;
            }
            pObjList[j].Level = ACCESS_PROPERTY_GUID;
            pObjList[j].Sbz = 0;
            pObjList[j].ObjectType = &(*Sorted[i])->propGuid;
            pPrevAttribute = *Sorted[i];
            j++;
        }

        cObjList = j;
    }
    else {
        cObjList = 1;
    }

    // Make the security check call.
    if(err = IsAccessGrantedByObjectTypeList(pSecurity,
                                             pDN,
                                             RightRequested,
                                             pObjList,
                                             cObjList,
                                             pResults,
                                             flags
                                             )) {
        // No access to anything.
        memset(rgpAC, 0, cInAtts * sizeof(ATTCACHE *));
        if (Sorted) {
            THFreeEx(pTHS,Sorted);
        }
        THFreeEx(pTHS, pObjList);
        THFreeEx(pTHS, pResults);
        return csacaAllAccessDenied;
    }

    if(!pResults[0]) {
        // We have full access to this object, return
        if (Sorted) {
            THFreeEx(pTHS,Sorted);
        }
        THFreeEx(pTHS, pObjList);
        THFreeEx(pTHS, pResults);
        return csacaAllAccessGranted;
    }

    // Filter the incoming list of attrs so that if they are not readable, we
    // drop them out of the list.

    // So far we haven't granted or denied anything
    fGranted = fDenied = FALSE;

    // Start by setting up j, our index into the Sorted array.
    // The Sorted array is in the same order as the pResults returned,
    // but may have extra embedded NULLs.  Skip any NULLs in the Sorted
    // list
    j=0;
    while((j < cInAtts) && !Sorted[j])  {
        j++;
    }

    for(i=1;i<cObjList;) {
        BOOL fOK=FALSE;

        Assert (pObjList[i].Level == ACCESS_PROPERTY_SET_GUID);
        if(!pResults[i]) {
            // Access to this propset is granted, skip over all the granted
            // props.
            fOK = TRUE;
            fGranted=TRUE;
        }
        i++;
        Assert(pObjList[i].Level == ACCESS_PROPERTY_GUID); // This is a prop.
        while(i < cObjList && (pObjList[i].Level == ACCESS_PROPERTY_GUID)) {
            if(!fOK && pResults[i]) {
                // Access to this prop is not granted.
                fDenied = TRUE;
                Assert(Sorted[j]); // We should have already skipped nulls.
                (*Sorted[j]) = NULL;
            }
            else {
                fGranted=TRUE;
            }
            i++;
            j++;
            // The Sorted array is in the same order as the pResults returned,
            // but may have extra embedded NULLs.  Skip any NULLs in the Sorted
            // list
            while((j < cInAtts) && !Sorted[j]) {
                j++;
            }
            // Assert the we are either done walking through the pResults array
            // or we still have elements in the Sorted array to consider.  That
            // is, we can't have exhausted the SortedArray unless we have also
            // exhausted the pResults array.
            Assert(i == cObjList || (j < cInAtts));
        }
    }
    if (Sorted) {
        THFreeEx(pTHS,Sorted);
    }

    THFreeEx(pTHS, pObjList);
    THFreeEx(pTHS, pResults);

    if(fGranted) {
        // We have rights to something...
        if (fDenied) {
            // ...but not everything
            return csacaPartialGrant;
        }
        else {
            // I guess we did get everything after all
            return csacaAllAccessGranted;
        }
    }

    // We didn't grant anything, so...
    return csacaAllAccessDenied;
}

DWORD
CheckSecurityClassCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInClasses,
        CLASSCACHE **rgpCC
        )
/*++
  Returns 0 if some access was granted, or an error code describing why all
  access was denied.

  NOTE.  rgpCC is 0 indexed.  pObjList and pResults are effectively 1 indexed.
  The 0th element of both of these two arrays is a holding space required by the
  call to IsAccessGrantedByObjectTypeList.  Make sure you use the right indexing
  for these arrays.

--*/
{
    ULONG i,j,k;
    DWORD cObjList;
    ULONG propSets=0;
    DWORD *pResults;
    GUID *pCurrentPropSet;
    POBJECT_TYPE_LIST pObjList;
    BOOL fGranted=FALSE;
    DWORD err;

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return 0;
    }

    if(!cInClasses) {
        // Nothing to do
        return ERROR_DS_SECURITY_CHECKING_ERROR;
    }

    // Now, create the list
    pObjList = (POBJECT_TYPE_LIST)
        THAllocEx(pTHS,(1+cInClasses) * sizeof(OBJECT_TYPE_LIST));
    pResults = (LPDWORD) THAllocEx(pTHS, ((1+cInClasses) * sizeof(DWORD)));

    // 0th entry in POBJECT_TYPE_LIST must be ACCESS_OBJECT_GUID so that
    // CliffV's API has something to match generic ACEs against.  So when
    // checking access for a class, we do as CliffV requires in the 0th
    // entry, and place the classes' guids in the Nth entries and call them
    // ACCESS_PROPERTY_SET_GUID.

    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = &gNullUuid;
    for(i=1;i<=cInClasses;i++) {
        pObjList[i].Level = ACCESS_PROPERTY_SET_GUID;
        pObjList[i].Sbz = 0;
        pObjList[i].ObjectType = &(rgpCC[i-1]->propGuid);
    }

    // Make the security check call.
    if(err = IsAccessGrantedByObjectTypeList(pSecurity,
                                             pDN,
                                             RightRequested,
                                             pObjList,
                                             cInClasses+1,
                                             pResults,
                                             0)) {
        // No access to anything.
        memset(rgpCC, 0, cInClasses*sizeof(CLASSCACHE *));
        THFreeEx(pTHS,pObjList);
        THFreeEx(pTHS,pResults);
        return err;
    }

    // Filter the incoming list of classes so that if they are not readable, we
    // drop them out of the list.

    for(i=1;i<=cInClasses;i++) {
        if(pResults[i]) {
            // Access not granted
            rgpCC[i-1] = NULL;
        }
        else {
            fGranted = TRUE;
        }
    }

    THFreeEx(pTHS,pObjList);
    THFreeEx(pTHS,pResults);

    if(fGranted) {
        // We have access to something
        return 0;
    }

    // we have no access to anything
    return ERROR_DS_INSUFF_ACCESS_RIGHTS;
}


BOOL
ValidateMemberAttIsSelf (
        ATTRMODLIST *pMemberAtt
        )
/*++

Routine Description.
    Verify that the the modification is only adding or removing me.

Arguments

    pMemberAtt - modification to check.

Return Values

    TRUE if the modification is adding or removing a single value, and the value
    is the caller.
    FALSE otherwise.

--*/
{
    DWORD err;
    PDSNAME pMemberDN;

    // In the extended write case, we allow only addition or deletion of a
    // single DN where that DN is the DN of the person making the call.

    if(pMemberAtt->AttrInf.AttrVal.valCount != 1)
        return FALSE;

    if(pMemberAtt->choice != AT_CHOICE_ADD_VALUES &&
       pMemberAtt->choice != AT_CHOICE_REMOVE_VALUES )
        return FALSE;


    // OK, we're adding or removing a single value.

    pMemberDN = (PDSNAME)pMemberAtt->AttrInf.AttrVal.pAVal->pVal;

    // First, make sure the thing you are trying to add has a SID, because
    // otherwise, it can't be a security principal, which means it can't be the
    // client who is trying to add this.
    if(err = FillGuidAndSid (pMemberDN)) {
        LogUnhandledError(err);
        return FALSE;
    }

    // Now make sure that there is a SID
    if(!pMemberDN->SidLen) {
        return FALSE;
    }

    // Now, see if we are this sid.
    if(!IAmWhoISayIAm(&pMemberDN->Sid, pMemberDN->SidLen)) {
        return FALSE;
    }

    // You are indeed just trying to mess with your own name, go ahead and let
    // you.
    return TRUE;

}

int
CheckRenameSecurity (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSecurity,
        DSNAME *pDN,
        CLASSCACHE *pCC,
        RESOBJ * pResObj,
        ATTRTYP rdnType,
        BOOL    fMove,
        RESOBJ * pResParent
        )
/*++

Routine Description.
    Verify that the caller has WRITE_PROPERTY on the RDN attribute and the
    attribute which is the RDN (e.g. common-name).

Arguments

    pSecurity - Security Descriptor to use for the Access Check.

    pDN - DSNAME of the object that pSecurity came from.  Doesn't require string
          portion, just object guid and sid.

    pCC - CLASSCACHE * for the class to check RDN attributes for.

Return Values

    0 if all went well, an error otherwise.  Sets an error in the THSTATE if an
    error occurs.

--*/
{
    ATTCACHE *rgpAC[2];
    CSACA_RESULT accRes;
    PSECURITY_DESCRIPTOR pNTSD;
    ULONG                cbNTSD;
    DWORD        err;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return 0;
    }

    if(fMove &&
       !IsAccessGrantedParent(RIGHT_DS_DELETE_CHILD,pCC,FALSE) &&
       !IsAccessGranted(pSecurity,
                        pResObj->pObj,
                        pCC,
                        RIGHT_DS_DELETE_SELF,
                        TRUE )) {
        // We don't have access to remove the object from it's current
        // location. The TRUE param to the second call to IsAccessGranted
        // forced IsAccessGranted to set an error already, so just return
        // it.
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }
    
    if(!(rgpAC[0] = SCGetAttById(pTHS, ATT_RDN)) ||
       !(rgpAC[1] = SCGetAttById(pTHS, rdnType))) {
        LogUnhandledError(DIRERR_MISSING_REQUIRED_ATT);
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_MISSING_REQUIRED_ATT);
    }

    // check if the user is allowed to change an object that is in the
    // configuration NC or schema NC
    if (CheckModifyPrivateObject(pTHS,
                                 pSecurity,
                                 pResObj)) {
        // it is not allowed to rename this object on this DC
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }


    accRes = CheckSecurityAttCacheArray(pTHS,
                                        RIGHT_DS_WRITE_PROPERTY,
                                        pSecurity,
                                        pDN,
                                        2,
                                        pCC,
                                        rgpAC,
                                        0);
    if(accRes == csacaAllAccessDenied) {
        // Failed for some reason to get any access.
        SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
		    ERROR_ACCESS_DENIED);
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }

    // CheckSecurityAttCacheArray claims we had some kind of access.  See if we
    // got what we needed.
    if(!rgpAC[0] || !rgpAC[1]) {
        // Failed to have write access to the RDN and the RDN att.
        SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                    DIRERR_INSUFF_ACCESS_RIGHTS );
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }

        // Verify that we can do this.  
    // (i.e. security rights and schema validation)
    if (!pTHS->fSingleUserModeThread &&
        (err = CheckParentSecurity(pResParent,
                                  pCC, 
                                  FALSE,
                                  fMove ? &pNTSD : NULL, 
                                  &cbNTSD))) {
        // !!! looking at CheckParentSecurity, seems like err == pTHS->errCode
        Assert(err == pTHS->errCode);
        return CheckObjDisclosure(pTHS, pResParent, TRUE);
    }

    return 0;
}

void
CheckReadSecurity (
        THSTATE *pTHS,
        ULONG SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG * pcInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC
        )
{
    ATTCACHE *pACSD = NULL;        //intialized to avoid C4701
    LONG secDescIndex=-1;
    ULONG i;
    ACCESS_MASK DesiredAccess;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return;
    }

    // Look through the list for NT_SECURITY_DESCRIPTOR
    for(i=0; i < *pcInAtts; i++) {
        if(rgpAC[i]) {
            // We skip NULLs in the rgpAC array.
            switch(rgpAC[i]->id) {
            case ATT_NT_SECURITY_DESCRIPTOR:
                // Found a security descriptor request.  Keep hold of the
                // attcache pointer for later and null out the element in the
                // array so that the CheckSecurity call later doesn't apply
                // normal security checks to this attribute.
                pACSD = rgpAC[i];
                rgpAC[i] = NULL;
                if(secDescIndex == -1) {
                    // If SD is asked for multiple times, it will be denied for
                    // all except possibly the last one.
                    secDescIndex = i;
                }
                break;
            }
            if ( rgpAC[i] && ((ATT_PEK_LIST == rgpAC[i]->id) ||
                            (DBIsSecretData(rgpAC[i]->id))) ) {
                // We will ALWAYS deny read property on these attributes.  If
                // you have to ask, you can't have it.  If any more attributes
                // are deemed to be invisible in the future, they should be
                // added to this case of the switch (note that this only denies
                // access to attributes in the selection list of a read or
                // search, see the routine GetFilterSecurityHelp below to deny
                // access to attributes in filters.)
                rgpAC[i] = NULL;
            }
        }
    }

    if(secDescIndex != -1) {
        // Mask out to just the important bits
        SecurityInformation &= (SACL_SECURITY_INFORMATION  |
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION    );
        if(!SecurityInformation) {
            // Asking for nothing in the flags is the same as asking for
            // everything.
            SecurityInformation = (SACL_SECURITY_INFORMATION  |
                                   OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION    );
        }

        //
        // Set the desired access based upon the requested SecurityInformation
        //

        DesiredAccess = 0;
        if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
            DesiredAccess |= ACCESS_SYSTEM_SECURITY;
        }
        if ( SecurityInformation &  (DACL_SECURITY_INFORMATION  |
                                     OWNER_SECURITY_INFORMATION |
                                     GROUP_SECURITY_INFORMATION)
            ) {
            DesiredAccess |= READ_CONTROL;
        }

        // Make the access check to see that we have rights to change this.
        if(!IsAccessGranted (pSecurity,
                             pDN,
                             pCC,
                             DesiredAccess,
                             FALSE )) {
            // The caller doesn't have rights to mess with the SD in the way
            // they said they wanted to.
            secDescIndex = -1;
        }
    }




    CheckSecurityAttCacheArray(pTHS,
                               RIGHT_DS_READ_PROPERTY,
                               pSecurity,
                               pDN,
                               *pcInAtts,
                               pCC,
                               rgpAC,
                               0);

    // Don't check to see what kind of access we got for the read.  Read
    // operations never return security errors.

    if (secDescIndex != -1) {
        // We need to re-enable an attcache pointer in the array to the SD pAC
        rgpAC[secDescIndex] =  pACSD;
    }
}

CROSS_REF *
FindCrossRefBySid(PSID pSID)
{
    CROSS_REF_LIST *pCRL = gAnchor.pCRL;

    while (pCRL) {
        if (pCRL->CR.pNC->SidLen &&
            EqualSid(pSID,
                     &(pCRL->CR.pNC->Sid))) {
            return &(pCRL->CR);
        }
        pCRL = pCRL->pNextCR;
    }
    return NULL;
}

int
CheckSecurityOwnership(THSTATE *pTHS,
                       PSECURITY_DESCRIPTOR pSD,
                       RESOBJ * pResObj)
{
    PSID pSID=NULL;
    BOOL defaulted;
    NT4SID domSid;
    ULONG  objectRid;

    // pSID is NULL if pSD does not contain an owner
    if (   GetSecurityDescriptorOwner(pSD, &pSID, &defaulted)
        && pSID) {

        SampSplitNT4SID( (NT4SID *)pSID, &domSid, &objectRid);

        if (!EqualPrefixSid(&domSid,
                            &(gAnchor.pDomainDN->Sid))) {
            /* If the SIDs don't match, generate an error */
            CROSS_REF *pCR;
            pCR = FindCrossRefBySid(&domSid);


            if (!pCR) {
                // generate a cross reference for the Root domain
                pCR = FindCrossRefBySid(&(gAnchor.pRootDomainDN->Sid));
            }

            if (pCR) {
                if (pResObj) {
                    /* If we found a cross ref, refer the user to the right domain */
                    GenCrossRef(pCR, pResObj->pObj);
                }
                else {
                    /* We don't know where to refer to, sorry. */
                    SetSecError(SE_PROBLEM_NO_INFORMATION,
                                ERROR_DS_NO_CROSSREF_FOR_NC);
                }
            }
            else {
                /* We don't know where to refer to, sorry. */
                SetSecError(SE_PROBLEM_NO_INFORMATION,
                            ERROR_DS_NO_CROSSREF_FOR_NC);
            }
        }
    }
    else {
        /* Can't read the SD owner?  Don't allow the operation */
        SetSecError(SE_PROBLEM_NO_INFORMATION,
                    ERROR_DS_NO_CROSSREF_FOR_NC);
    }
    return pTHS->errCode;
}

int
CheckTakeOwnership(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj)
{
    if (!gAnchor.fAmRootDomainDC
        && (   (pResObj->NCDNT == gAnchor.ulDNTDMD)
            || (pResObj->NCDNT == gAnchor.ulDNTConfig)
            || (pResObj->DNT == gAnchor.ulDNTDMD)
            || (pResObj->DNT == gAnchor.ulDNTConfig))) {
        // We only do these checks if this DC is not in the root domain
        // and the object being modified is in either the schema or config NC

        return CheckSecurityOwnership (pTHS, pSD, pResObj);

    }
    return pTHS->errCode;
}

int
CheckModifyPrivateObject(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj)
{
    if (!gAnchor.fAmRootDomainDC
        && (   (pResObj->NCDNT == gAnchor.ulDNTDMD)
            || (pResObj->NCDNT == gAnchor.ulDNTConfig)
            || (pResObj->DNT == gAnchor.ulDNTDMD)
            || (pResObj->DNT == gAnchor.ulDNTConfig))) {
        // We only do these checks if this DC is not in the root domain
        // and the object being modified is in either the schema or config NC

        UCHAR rmControl;
        DWORD cbSD=0;
        DWORD err;

        if (pSD == NULL) {
            // Find the security descriptor attribute
            if(err = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                         0,0,
                         &cbSD, (PUCHAR *)&pSD)) {
                // No SD found. We assume the object is therefore locked down
                return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_CANT_RETRIEVE_SD,
                             err);
            }
        }


        // try to get the resource manager (RM) control field from the SD
        //
        err = GetSecurityDescriptorRMControl (pSD, &rmControl);

        if (err == ERROR_SUCCESS) {
            // this is a private object

            // we have something in this field. check to see if this
            // makes this object a private object
            if (rmControl & SECURITY_PRIVATE_OBJECT) {
                return CheckSecurityOwnership (pTHS, pSD, pResObj);
            }
        }
        // INVALID_DATA means the RMcontrol bit is not Set.
        // Other return codes are errors
        else if (err != ERROR_INVALID_DATA) {

            /* Can't read the RM control?  Don't allow the operation */
            SetSecError(SE_PROBLEM_NO_INFORMATION,
                        ERROR_DS_NO_CROSSREF_FOR_NC);
        }
    }
    return pTHS->errCode;
}


int
CheckModifySecurity (
        THSTATE *pTHS,
        MODIFYARG* pModifyArg,
        BOOL       *pfCheckDNSHostNameValue,
        BOOL       *pfCheckAdditionalDNSHostNameValue,
        BOOL       *pfCheckSPNValues
        )
{
    ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
    ATTRMODLIST *pSDAtt=NULL;
    ATTRMODLIST *pMemberAtt=NULL;
    ULONG       count, i;
    ULONG       ulLen;
    ATTCACHE    *pAC;
    ATTCACHE    **rgpAC;
    ATTCACHE    **rgpACExtended;
    CLASSCACHE  *pCC=NULL;
    PSECURITY_DESCRIPTOR pOldSD;        // SD already on the object.
    PSECURITY_DESCRIPTOR pMergedSD;     // SD to write on the object.
    PSECURITY_DESCRIPTOR pUseSD;        // SD to check access with.
    PSECURITY_DESCRIPTOR pSetSD;        // SD Passed in by Client
    SECURITY_DESCRIPTOR_CONTROL sdcOldSD, sdcSetSD;
    BOOL        fMustInheritParentACEs;
    BOOL        fReplacingAllSDParts;
    DWORD       sdRevision;
    DWORD       cbOldSD=0;
    DWORD       cbMergedSD;
    DWORD       cbSetSD;
    BOOL        bModSD=FALSE;
    ULONG       classP;
    UCHAR       *pVal;
    DWORD       error;
    ULONG       samclass;
    DWORD       err;
    DWORD       memberFound = 0;
    BOOL        fsmoRoleFound = FALSE;
    BOOL        dnsHostNameFound = FALSE;
    BOOL        additionalDnsHostNameFound = FALSE;
    BOOL        servicePrincipalNameFound = FALSE;
    BOOL        fIsDerivedFromComputer = FALSE;
    CSACA_RESULT accRes;
    GUID        *ppGuid[1];

    // The SD propagator should never be here.
    Assert(!pTHS->fSDP);

    if ( DsaIsInstalling() ) {
        return 0;
    }

    // If access Checks have already done then bail out
    if (pTHS->fAccessChecksCompleted ) {
        return 0;
    }

    // Anyone else must find out if the SD is being modified.
    if(pTHS->fDRA) {
        // We don't go through the normal check, so do a quick look through the
        // list to see if we are touching the SD.
        for (count = 0; count < pModifyArg->count; count++){
            if(pAttList->AttrInf.attrTyp == ATT_NT_SECURITY_DESCRIPTOR) {
                // Yes, queue a SD propagation
                if(error = DBEnqueueSDPropagation(pTHS->pDB, TRUE)) {
                    // We failed to enqueue the propagation, fail the call
                    return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                                         error);
                 }
                return 0;
            }
            pAttList = pAttList->pNextMod;   /*Next mod*/
        }
        return 0;
    }

    // Look up the classcache.
    if (!(pCC = SCGetClassById(pTHS,
                               pModifyArg->pResObj->MostSpecificObjClass))) {
        // Failed to get the class cache pointer.
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_OBJECT_CLASS_REQUIRED);
    }



    // Find the security descriptor attribute
    if(err = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                         0,0,
                         &cbOldSD, (PUCHAR *)&pOldSD)) {
        // No SD found. We assume the object is therefore locked down
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_CANT_RETRIEVE_SD,
                             err);
    }

    //build the list of attrtyps we are modifying in this call.
    rgpAC =
        (ATTCACHE **)THAllocEx(pTHS,pModifyArg->count * sizeof(ATTCACHE *));

    for (count = 0, i=0; count < pModifyArg->count; count++){
        if(pAC = SCGetAttById(pTHS, pAttList->AttrInf.attrTyp)) {
            // Look up the attribute.
            rgpAC[i++] = pAC;

            switch (pAC->id) {
            case ATT_NT_SECURITY_DESCRIPTOR:
                // Special call for the security descriptor.
                // We only allow replacement of the SD, not removing (attribute
                // or values) or addind (attribute or values).

                if(pAttList->choice != AT_CHOICE_REPLACE_ATT) {
                    // Set aunwilling to perform
                    THFreeEx(pTHS,rgpAC);
                    return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                       DIRERR_ILLEGAL_MOD_OPERATION);
                }

                // We don't do normal security checks, remove this from this
                // list of attributes to check.
                i--;

                // Keep track of the value, since we'll need to do magic on this
                // later, and replace the last SD we try to write using this
                // modification with a merged SD.
                pSDAtt = pAttList;
                break;

            case ATT_MEMBER:
                memberFound++;
                // Keep track of the value, since we might need to check it
                // later if we do a check for WriteSelf.
                pMemberAtt = pAttList;
                break;

            case ATT_UNICODE_PWD:
            case ATT_USER_PASSWORD:

                // Ignore this attribute on Sam objects
                // as loopback will make SAM check for appropriate access

                if (SampSamClassReferenced(pCC,&samclass)) {
                    i--;
                }
                break;

            case ATT_FSMO_ROLE_OWNER:
                fsmoRoleFound = TRUE;
                break;

            case ATT_DNS_HOST_NAME:
                dnsHostNameFound = TRUE;
                break;

            case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                additionalDnsHostNameFound = TRUE;
                break;


            case ATT_SERVICE_PRINCIPAL_NAME:
                servicePrincipalNameFound = TRUE;
                break;

            default:
                break;
            }
        }
        else {

            THFreeEx(pTHS,rgpAC);
            SAFE_ATT_ERROR(pModifyArg->pObject,
                           pAttList->AttrInf.attrTyp,
                           PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                           DS_ERR_ATT_NOT_DEF_IN_SCHEMA);
        }

        pAttList = pAttList->pNextMod;   /*Next mod*/
    }

    if(pSDAtt) {
        // We got a new security descriptor.  Make the call to see if
        // the old security descriptor allows the new security descriptor to be
        // written.  The call also performs magic and returns a merged security
        // descriptor which we should write.
        PSECURITY_DESCRIPTOR pTempSD;
        SECURITY_INFORMATION SecurityInformation =
            pModifyArg->CommArg.Svccntl.SecurityDescriptorFlags;
        ACCESS_MASK SDAccess = 0;

#define SEC_INFO_ALL (SACL_SECURITY_INFORMATION  | \
                      OWNER_SECURITY_INFORMATION | \
                      GROUP_SECURITY_INFORMATION | \
                      DACL_SECURITY_INFORMATION    )

        // Mask out to just the important bits
        SecurityInformation &= SEC_INFO_ALL;
        if(!SecurityInformation) {
            // Asking for nothing in the flags is the same as asking for
            // everything.
            SecurityInformation = SEC_INFO_ALL;
        }

        if(!pTHS->fDSA) {
            // Need to check security before we let you touch SDs
            if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
                SDAccess |= ACCESS_SYSTEM_SECURITY;
            }
            if ( SecurityInformation & (OWNER_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION)) {
                SDAccess |= WRITE_OWNER;
                if (CheckTakeOwnership(pTHS,
                                       pOldSD,
                                       pModifyArg->pResObj)) {
                    // This DC will not allow taking ownership of this obj
                    THFreeEx(pTHS,rgpAC);
                    return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
                }
            }
            if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
                SDAccess |= WRITE_DAC;
            }

            // Make the access check to see that we have rights to change this.
            if(!IsAccessGranted (pOldSD,
                                 pModifyArg->pObject,
                                 pCC,
                                 SDAccess,
                                 TRUE)) {
                // The caller doesn't have rights to mess with the SD in the
                // way they said they wanted to.
                THFreeEx(pTHS,rgpAC);
                return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
            }
        }

        // Ok, we have rights, go ahead and merge the SD.

        // Save the original security descriptor passed in by the client
        // This is used by the hack below to reduce security descriptor
        // propagation events
        pSetSD = pSDAtt->AttrInf.AttrVal.pAVal->pVal;
        cbSetSD= pSDAtt->AttrInf.AttrVal.pAVal->valLen;

        // if the old SD is inheritance-protected and the new one is not,
        // then we have to grab parent's SD and do an SD CREATE. This is
        // because we want to put the inherited ACEs (that are not present
        // in the old SD) into the new SD.
        // We must first do a MERGE with current SD and then (if needed)
        // CREATE with parentSD.
        // The only exception is when all SD parts (DACL, SACL, Group
        // and Owner info) are modified: in this case the MERGE step
        // can be skipped because pSetSD contains all new info that must
        // replace the original info

        // grab SD control value for Set and Old SDs
        GetSecurityDescriptorControl(pSetSD, &sdcSetSD, &sdRevision);
        GetSecurityDescriptorControl(pOldSD, &sdcOldSD, &sdRevision);

        fMustInheritParentACEs =
            ((SecurityInformation & DACL_SECURITY_INFORMATION) &&
             (sdcOldSD & SE_DACL_PROTECTED) && !(sdcSetSD & SE_DACL_PROTECTED))
            ||
            ((SecurityInformation & SACL_SECURITY_INFORMATION) &&
             (sdcOldSD & SE_SACL_PROTECTED) && !(sdcSetSD & SE_SACL_PROTECTED));
        fReplacingAllSDParts = SecurityInformation == SEC_INFO_ALL;

        ppGuid[0] = &pCC->propGuid;

        if (fMustInheritParentACEs && fReplacingAllSDParts) {
            // pSetSD contains all the non-inherited info we need to put into the new SD.
            // The inherited ACEs are picked up from the parent's SD (see below)
            pMergedSD = pSetSD;
            cbMergedSD = cbSetSD;
        }
        else {
            // we either need to pick up inherited ACEs from the old SD
            // or not all SD parts are being set, so we need to pick up remaining
            // (unchanged) parts from the old SD
            if (error = MergeSecurityDescriptorAnyClient(
                            pOldSD,
                            cbOldSD,
                            pSetSD,
                            cbSetSD,
                            SecurityInformation,
                            (pTHS->fDSA?MERGE_AS_DSA:0),
                            ppGuid,
                            1,
                            &pMergedSD,
                            &cbMergedSD)) {
                THFreeEx(pTHS,rgpAC);
                return SetAttError(pModifyArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                   NULL, error);
            }
        }

        if (fMustInheritParentACEs) {
            // have to grab parent's SD so that inherited ACE get into the new
            PDSNAME                 pParentDN = NULL;
            CLASSCACHE              *pParentCC = NULL;
            PSECURITY_DESCRIPTOR    pParentSD = NULL;     // SD of parent
            DWORD                   cbParentSD;
            PSECURITY_DESCRIPTOR    pNewSD;
            DWORD                   cbNewSD;

            // grab parent info (this uses Search table so that currency is not disturbed)
            error = DBGetParentSecurityInfo(pTHS->pDB, &cbParentSD, &pParentSD, &pParentCC, &pParentDN);

            if (error == 0) {

                error = MergeSecurityDescriptorAnyClient(
                            pParentSD,
                            cbParentSD,
                            pMergedSD,
                            cbMergedSD,
                            SecurityInformation,
                            MERGE_CREATE | (pTHS->fDSA?MERGE_AS_DSA:0),
                            ppGuid,
                            1,
                            &pNewSD,
                            &cbNewSD);
            }

            if (pParentDN) {
                THFreeEx(pTHS, pParentDN);
            }

            if (pParentSD) {
                THFreeEx(pTHS, pParentSD);
            }
            if (!fReplacingAllSDParts) {
                Assert(pMergedSD != pSetSD);
                // we did a merge, free the memory
                DestroyPrivateObjectSecurity(&pMergedSD);
            }

            if (error) {
                THFreeEx(pTHS,rgpAC);
                return SetAttError(pModifyArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                   NULL, error);
            }

            // the new sd is what we need
            pMergedSD = pNewSD;
            cbMergedSD = cbNewSD;
        }

        pTempSD = (PSECURITY_DESCRIPTOR)THAllocEx(pTHS, cbMergedSD);
        memcpy(pTempSD,pMergedSD,cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD=pTempSD;

        pSDAtt->AttrInf.AttrVal.pAVal->pVal = pMergedSD;
        pSDAtt->AttrInf.AttrVal.pAVal->valLen = cbMergedSD;

        // we should be using the old SD to check permissions for this MODIFY
        pUseSD = pOldSD;

        // Since we're changing the SD here, we need to enque a propagation of
        // the change.

        if (!((pTHS->fSAM)
            && (cbOldSD==cbSetSD)
            && (memcmp(pOldSD,pSetSD,cbOldSD)==0)))
        {
            // Murlis: Hack To reduce unnecessary security descriptor propagations
            // till SAM is modified to write back only properties that it has
            // modified Do not enquue the change if SAM were just setting the old
            // security descriptor back on the object.

            if(error = DBEnqueueSDPropagation(pTHS->pDB, pTHS->fDSA)) {
                // We failed to enqueue the propagation.  Fail the call.
                THFreeEx(pTHS,rgpAC);
                return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                                     error);
            }
        }
    }
    else {

        pUseSD = pOldSD;
    }

    if(pTHS->fDSA) {
        // We don't actually need to make any checks if we are the DSA, we've
        // only come this far in order to do the SD merge above.
        THFreeEx(pTHS,rgpAC);
        return 0;
    }

    // RAID: 343097
    // check if the user is allowed to change an object that is in the
    // configuration NC or schema NC
    if (CheckModifyPrivateObject(pTHS,
                                 pOldSD,
                                 pModifyArg->pResObj)) {
        // it is not allowed to change this object on this DC
        THFreeEx(pTHS,rgpAC);
        return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
    }

    if(!i) {
        // We don't seem to have any more attributes to check security rights
        // on.  Therefore, either we were passed in an empty list of
        // modifications, or a list that only included SDs and UNICODE_PASSWORDs
        // on SAM objects.  These two kinds of attributes have already been
        // dealt with via other code paths, and since we're here, we must have
        // already been granted access to those attributes.  Anyway, there is
        // nothing more to do, so return.
        THFreeEx(pTHS,rgpAC);
        return 0;
    }

    // Special check for control access rights if you are messing with the
    // fsmoRoleOwner attribute.
    if(fsmoRoleFound) {
        GUID ControlGuid;

        switch (pCC->ClassId) {
        case CLASS_INFRASTRUCTURE_UPDATE:
            ControlGuid = RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER;
            break;

        case CLASS_DMD:
            ControlGuid = RIGHT_DS_CHANGE_SCHEMA_MASTER;
            break;

        case CLASS_RID_MANAGER:
            ControlGuid = RIGHT_DS_CHANGE_RID_MASTER;
            break;

        case CLASS_DOMAIN:
            ControlGuid = RIGHT_DS_CHANGE_PDC;
            break;

        case CLASS_CROSS_REF_CONTAINER:
            ControlGuid = RIGHT_DS_CHANGE_DOMAIN_MASTER;
            break;

        default:
            fsmoRoleFound = FALSE;
            break;
        }

        if(fsmoRoleFound &&
           !IsControlAccessGranted(pUseSD,
                                   pModifyArg->pObject,
                                   pCC,
                                   ControlGuid,
                                   TRUE)) {
            THFreeEx(pTHS,rgpAC);
	    return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
        }
    }


    // Make a copy of the attcache array we're going to use for the check.  We
    // use this copy during processing of insufficient rights checks, below.
    rgpACExtended = (ATTCACHE **)THAllocEx(pTHS,pModifyArg->count * sizeof(ATTCACHE *));
    memcpy(rgpACExtended, rgpAC, pModifyArg->count * sizeof(ATTCACHE *));

    // Now make the call to see if we have WRITE rights on all the properties we
    // are messing with.
    accRes = CheckSecurityAttCacheArray(
            pTHS,
            RIGHT_DS_WRITE_PROPERTY,
            pUseSD,
            pModifyArg->pObject,
            i,
            pCC,
            rgpAC,
            0);

    if(accRes != csacaAllAccessGranted) {
        // Find out if this is derived from a computer, since we need to know
        // while doing this extended check.
        if(pCC->ClassId != CLASS_COMPUTER) {
            DWORD j;
            fIsDerivedFromComputer = FALSE;
            for (j=0; !fIsDerivedFromComputer && j<pCC->SubClassCount; j++) {
                if (pCC->pSubClassOf[j] == CLASS_COMPUTER) {
                    fIsDerivedFromComputer = TRUE;
                }
            }
        }
        else {
            fIsDerivedFromComputer = TRUE;
        }


        // We were denied all access for some reason.  Check for extended
        // access.
        accRes = CheckSecurityAttCacheArray(
                pTHS,
                RIGHT_DS_WRITE_PROPERTY_EXTENDED,
                pUseSD,
                pModifyArg->pObject,
                i,
                pCC,
                rgpACExtended,
                0);

        while(i) {
            // Any properties we don't have normal WRITE_PROPERTY rights to have
            // been replaced with a NULL in rgpAC.  Any that we don't have
            // WRITE_PROPERTY_EXTENDED rights to have been replace with a NULL
            // in rgpACExtended.
            i--;
            if(!rgpAC[i]) {
                BOOL fError = FALSE;
                // Null in rgpAC means that we were denied WRITE_PROPERTY
                // access.  See if we were granted WRITE_PROPERTY_EXTENDED on
                // this attribute.
                if(!rgpACExtended[i]) {
                    // Nope.  Neither WRITE_PROPERTY nor
                    // WRITE_PROPERTY_EXTENDED.   Error out.
                    fError = TRUE;
                }
                else switch(rgpACExtended[i]->id) {
                case ATT_MEMBER:
                    Assert(memberFound);
                    // No normal rights to member, but we do have extended
                    // rights.  Verify that the value we are writing is correct.
                    if((memberFound != 1) ||
                       !ValidateMemberAttIsSelf(pMemberAtt)) {
                        // Nope, even though we have the extended rights, we
                        // don't have the correct value.
                        fError = TRUE;
                    }
                    break;

                case ATT_DNS_HOST_NAME:
                    Assert(dnsHostNameFound);
                    // No normal rights to this attribute, but extended rights.
                    // If this class is derived from computer, then we will
                    // allow certain modifications to this attribute, based
                    // on the modification value.
                    // NOTE: we don't check the value here.  After the mods
                    // are done, we check the value if we were granted
                    // rights because of this case.
                    if(!fIsDerivedFromComputer) {
                        fError = TRUE;
                    }
                    else {
                        // Yep, we'll allow this modulo a check of the values
                        // written later.
                        if(pfCheckDNSHostNameValue) {
                            *pfCheckDNSHostNameValue = TRUE;
                        }
                    }
                    break;

                case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                    Assert(additionalDnsHostNameFound);
                    // No normal rights to this attribute, but extended rights.
                    // If this class is derived from computer, then we will
                    // allow certain modifications to this attribute, based
                    // on the modification value.
                    // NOTE: we don't check the value here.  After the mods
                    // are done, we check the value if we were granted
                    // rights because of this case.
                    if(!fIsDerivedFromComputer) {
                        fError = TRUE;
                    }
                    else {
                        // Yep, we'll allow this modulo a check of the values
                        // written later.
                        if(pfCheckAdditionalDNSHostNameValue) {
                            *pfCheckAdditionalDNSHostNameValue = TRUE;
                        }
                    }
                    break;


                case ATT_SERVICE_PRINCIPAL_NAME:
                    Assert(servicePrincipalNameFound);
                    // No normal rights to this attribute, but extended rights.
                    // If this class is derived from computer, then we will
                    // allow certain modifications to this attribute, based
                    // on the modification value.
                    // NOTE: we don't check the value here.  After the mods
                    // are done, we check the value if we were granted
                    // rights because of this case.
                    if(!fIsDerivedFromComputer) {
                        fError = TRUE;
                    }
                    else {
                        // Yep, we'll allow this modulo a check of the values
                        // written later.
                        if(pfCheckSPNValues) {
                            *pfCheckSPNValues = TRUE;
                        }
                    }
                    break;

                default:
                    // No normal rights to this attribute, but extended rights.
                    // But, we don't have special handling for this. This means
                    // no rights.
                    fError = TRUE;
                    break;
                }

                if(fError) {
                    THFreeEx(pTHS,rgpAC);
                    THFreeEx(pTHS,rgpACExtended);
                    SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                                       DIRERR_INSUFF_ACCESS_RIGHTS );
                    return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
                }
            }
        }
    }
    THFreeEx(pTHS,rgpAC);
    THFreeEx(pTHS,rgpACExtended);
    return CheckObjDisclosure(pTHS, pModifyArg->pResObj, TRUE);
#undef SEC_INFO_ALL
}/*CheckModifySecurity*/

int
CheckAddSecurity (
        THSTATE *pTHS,
        CLASSCACHE *pCC,
        ADDARG *pAddArg,
        PSECURITY_DESCRIPTOR pParentSD,
        ULONG cbParentSD,
        GUID *pGuid
        )
/*++

Routine Description
   Calculate the merged SD we are going to put on the object based on the
   parents SD (passed in as a parameter) and the SD in the AddArg, or the SD
   which is default for this class if none was specified in the AddArg.  The
   newly created SD is either tacked onto the AddArgs list of entries (if no SD
   was already in the list) or is put into the AddArg in place of an existing SD
   (everything must be THAlloc'ed)

   N.B. if pTHS->fDSA, then the caller MUST provided an SD in the ADDARG.
   N.B. if the object being added is a new NC root, then the pParentSD should be
   passed in as NULL.  This is not enforced, but is expected.

Arguements

    pCC - class cache pointer to the class of the object we are adding.

    pAddArg - AddArg describing the add we're trying to do.

    pParentSD - pointer to the parents SD.  Used to calculate inheritance into
    the SD we write on the object.

    cbParentSD - count of bytes of pParentSD


Return Values

    0 if all went well, a direrr otherwise.

--*/
{
    ATTCACHE    *pAC;
    BOOL        bFoundMemberOnce = FALSE;
    ULONG       count;
    PSECURITY_DESCRIPTOR pSetSD=NULL;
    PSECURITY_DESCRIPTOR pMergedSD=NULL;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    DWORD       cbSetSD = 0;         //initialized to avoid C4701
    DWORD       cbMergedSD=0;
    DWORD       cbTempSD;
    DWORD       cbUseSD;
    DWORD       rtn;
    ULONG       sdIndex = 0;        //initialized to avoid C4701
    ATTRVAL     *newAttrVal=NULL;
    COMMARG     CommArg; // Need this for the FindBestCrossRef() func.
    CROSS_REF * pCR;
    PSID        pDomSid = NULL;
    GUID        *ppGuid[1];

    // The flags we're going to pass to the MergeSecurityDescriptor call
    // We need to set MERGE_AS_DSA if we are DSA or DRA to avoid client
    // impersonation  in MergeSecurityDescriptor
    ULONG       MergeFlags = (MERGE_CREATE |
                              ((pTHS->fDSA || pTHS->fDRA)?MERGE_AS_DSA:0));
    NAMING_CONTEXT_LIST * pNCL = NULL;

    // The SD propagator should never be here.
    Assert(!pTHS->fSDP);

    Assert( DsaIsRunning() || pTHS->fDSA || pTHS->fDRA);

    // Look through the AddArg's entries looking for the Security
    // Descriptor

    for (count=0; count < pAddArg->AttrBlock.attrCount; count++) {

        pAC = NULL;
        if (!(pAC = SCGetAttById(pTHS,
                                 pAddArg->AttrBlock.pAttr[count].attrTyp))) {
            DPRINT1(2, "Att not in schema <%lx>\n",
                    pAddArg->AttrBlock.pAttr[count].attrTyp);
            // Continue processing if the attribute error was sucessful
            SAFE_ATT_ERROR(pAddArg->pObject,
                           pAddArg->AttrBlock.pAttr[count].attrTyp,
                           PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                           DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        }

        if(ATT_NT_SECURITY_DESCRIPTOR == pAC->id ){
            // Keep track of the last provided SD.  Note that if two SDs are
            // provided, the call will fail later anyway.
            pSetSD = pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal->pVal;
            cbSetSD= pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal->valLen;
            sdIndex = count;
            break;
        }

    }

    if(pTHS->errCode)
        return pTHS->errCode;

    if(!pSetSD && pTHS->fDRA && (pCC->ClassId == CLASS_TOP)) {
        // Replicating in an auto-generated-subref skip further SD
        // processing
        return 0;
    }

    // Create the Security Descriptor for the object based on the Parent SD and
    // (in order of preference) the provided SD, the default SD, or a NULL
    // pointer.

    if(pSetSD) {
        // We have been provided a SD. Set up the replacement pointer to stuff
        // the new SD we are about to create back into the addarg in place of
        // that security descriptor.
        newAttrVal = pAddArg->AttrBlock.pAttr[sdIndex].AttrVal.pAVal;
        if(pTHS->fDSA) {
            // The assumption is that if we are adding this as an in-process
            // client, then the SD provided is nothing more that the default SD
            // plus an owner and a group.  Since that is so, set the MerfeFlags
            // to appropriately reflect this.
            MergeFlags |= MERGE_DEFAULT_SD;
        }

        // If we are fDRA then we are basically replicating in a new object
        // which should have a valid SD at this point. Thus, the SD is not the
        // default SD, so don't set MERGE_DEFAULT_SD.
    }
    else {
        // Use whatever form of default SD we have (might be a NULL pointer and
        // 0 length).

        if(pAddArg->pCreateNC &&
           pAddArg->pCreateNC->iKind != CREATE_NONDOMAIN_NC){
            // Currently the only type of NC head we can add w/o an explicit
            // provided security descriptor is an NDNC.
            Assert(!"Currently we can't add NON NDNC heads unless we have a SD.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            return(pTHS->errCode);
        }

        if(!pAddArg->pCreateNC &&
           (DsaIsInstalling() ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTDomain ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTConfig ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTDMD) ){
            // This is a shortcut for Domain/Schema/Config NCs, so we
            // don't have to look up the SD Reference Domain SID.
            pDomSid = NULL;
        } else {

            if(pAddArg->pCreateNC){
                // The reference domain may not have been set on the
                // cross-ref yet, so we get the ref dom SID for the
                // default security descriptor creation from the cached
                // create NC info structure.
                pDomSid = &pAddArg->pCreateNC->pSDRefDomCR->pNC->Sid;
                MergeFlags |= MERGE_OWNER;

            } else {

                // We know this object is internal to an NC, and we need the
                // cross-ref of this NC to figure out it's SD Reference SID.
                // However, it turns out that this DN hasn't been validated
                // yet for correctness, so passing in a bad DN will make
                // FindBestCrossRef gives us a NULL, and then we'll AV in
                // GetSDRefDomSid().  However, since we've already done a
                // DoNameRes() on the parent object in DirAddEntry(), we'll
                // FindBestCrossRef() on the parent instead, so we know we'll
                // get a valid CR.

                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
                pCR = FindBestCrossRef(pAddArg->pResParent->pObj, &CommArg);
                if(pCR == NULL){
                    SetSvcError(SV_PROBLEM_DIR_ERROR, 
                                DIRERR_CANT_FIND_EXPECTED_NC);
                    return(pTHS->errCode);
                }
                pDomSid = GetSDRefDomSid(pCR);
                Assert(pDomSid);
                if(pTHS->errCode){
                    // There was an error in GetSDRefDomSid()
                    return(pTHS->errCode);
                }
            }

            Assert(pDomSid && IsValidSid(pDomSid));
        }

        Assert(pDomSid == NULL ||
               IsValidSid(pDomSid));

        // The pDomSid parameter can be NULL, and then the default domain of
        // the DC will be used for default string SD translation, we'll need
        // to change this in Blackcomb.
        SCGetDefaultSD(pTHS, pCC, pDomSid,
                       &pSetSD, &cbSetSD);
        if(pTHS->errCode){
            return(pTHS->errCode);
        }

        Assert(pSetSD);
        Assert(cbSetSD);

        MergeFlags |= MERGE_DEFAULT_SD;

        // No security descriptor was provided to us.  Therefore, we need to
        // tweak the add argument to add the security descriptor we have
        // calculated for the object.

        count = pAddArg->AttrBlock.attrCount;
        pAddArg->AttrBlock.attrCount++;
        pAddArg->AttrBlock.pAttr = THReAllocEx(pTHS,
                                               pAddArg->AttrBlock.pAttr,
                                               (pAddArg->AttrBlock.attrCount *
                                                sizeof(ATTR)));
        newAttrVal = THAllocEx(pTHS, sizeof(ATTRVAL));

        pAddArg->AttrBlock.pAttr[count].AttrVal.valCount = 1;
        pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal = newAttrVal;
        pAddArg->AttrBlock.pAttr[count].attrTyp =
            ATT_NT_SECURITY_DESCRIPTOR;
    }

    ppGuid[0] = &pCC->propGuid;

    // Do the merge.
    if(rtn = MergeSecurityDescriptorAnyClient(
            pParentSD,
            cbParentSD,
            pSetSD,
            cbSetSD,
            pAddArg->CommArg.Svccntl.SecurityDescriptorFlags,
            MergeFlags,
            ppGuid,
            1,
            &pTempSD,
            &cbTempSD)) {
        return SetAttError(pAddArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL, rtn);
    }

    // Copy the merged SD into THAlloced memory and free the memory allocated
    // by MergeSecurityDescriptorAnyClient
    pMergedSD = (PSECURITY_DESCRIPTOR)THAllocEx(pTHS, cbTempSD);
    memcpy(pMergedSD,pTempSD,cbTempSD);
    DestroyPrivateObjectSecurity(&pTempSD);
    cbMergedSD=cbTempSD;
    // Place the new SD into the addarg
    newAttrVal->pVal = pMergedSD;
    newAttrVal->valLen = cbMergedSD;

    return pTHS->errCode;

}/*CheckAddSecurity*/

int
ModifyAuxclassSecurityDescriptor (IN THSTATE *pTHS,
                                  IN DSNAME *pDN,
                                  IN COMMARG *pCommArg,
                                  IN CLASSCACHE *pClassSch,
                                  IN CLASSSTATEINFO *pClassInfo,
                                  IN RESOBJ * pResParent)
/*++

Routine Description
    Modifies the Security Descriptor of an object that has an auxClass attached,
    whenever the auxClass changed.
    As a result new ACLs might become effective on the particular object.
    Unfortunately we have to read the parent SD todo the merging.

Arguements

    pDn - the DN of the object we are modifying

    pCommArg - the COMMARG of the respecting ADDARG/MODIFYARG

    pClassSch - the structural class of the object we are modifying

    pClassInfo - all the info about the classes on this object

    pResParent - possibly the parent related info (used when we cannot use DBPOS)
                 for parent positioning

    pResParent - possibly the parent related info (used when we cannot use DBPOS)
                 for parent positioning

Return Values

    0 if all went well, a direrr otherwise.

--*/
{
    GUID **ppGuid, **ppGuidTemp;
    ULONG GuidCount = 0;
    ULONG i;

    ATTCACHE *pAC;
    DWORD  pcbSDBuff=0;
    PUCHAR pSDBuff=NULL;
    PSECURITY_DESCRIPTOR pNewSD=NULL;
    ULONG  cbNewSD;
    DWORD  err = 0;
    DWORD  oldPDNT;
    DBPOS  *pDB = pTHS->pDB;

    PDSNAME                 pParentDN = NULL;
    CLASSCACHE              *pParentCC = NULL;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;     // SD of parent
    DWORD                   cbParentSD;


    if (!pClassInfo || ( pClassInfo && !pClassInfo->fObjectClassChanged)) {
        return 0;
    }

    GuidCount = 1 + pClassInfo->cNewAuxClasses;

    ppGuidTemp = ppGuid = THAllocEx (pTHS, sizeof (GUID *) * GuidCount);

    *ppGuidTemp++ = &(pClassSch->propGuid);

    for (i=0; i<pClassInfo->cNewAuxClasses; i++) {
        *ppGuidTemp++ = &(pClassInfo->pNewAuxClassesCC[i]->propGuid);
    }

    DPRINT1 (1, "Modifying AuxClass Security Descriptor: %d\n", GuidCount);

    if ( !(pAC = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR))) {
        return SetAttError(pDN, ATT_NT_SECURITY_DESCRIPTOR,
                           PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                           ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
    }

    // Get the SD on the object.
    err = DBGetAttVal_AC(pDB,
                         1,
                         pAC,
                         DBGETATTVAL_fREALLOC,
                         pcbSDBuff,
                         &pcbSDBuff,
                         &pSDBuff);

    if (err || !pSDBuff || !pcbSDBuff) {
        err = 0;
        goto End;
    }

    __try {

        oldPDNT = pDB->PDNT;

        if (pResParent) {
            pDB->PDNT = pResParent->DNT;
        }

        // grab parent info (this uses Search table so that currency is not disturbed)
        err = DBGetParentSecurityInfo(pDB, &cbParentSD, &pParentSD, &pParentCC, &pParentDN);

    }
    __finally {
        pDB->PDNT = oldPDNT;
    }

    if (err == 0) {

        // we will do this merge as if we were the DSA,
        // since if the user was setting the SD in this
        // transaction, in a bad way, this already will
        // have been caught

        // we are interested in only setting the ACL parts

        // do the actual merging
        err = MergeSecurityDescriptorAnyClient(
                    pParentSD,
                    cbParentSD,
                    pSDBuff,
                    pcbSDBuff,
                    (SACL_SECURITY_INFORMATION  |
                        OWNER_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         DACL_SECURITY_INFORMATION    ),
                    MERGE_CREATE | MERGE_AS_DSA,
                    ppGuid,
                    GuidCount,
                    &pNewSD,
                    &cbNewSD);
    }

    if (pParentDN) {
        THFreeEx(pTHS, pParentDN);
    }

    if (pParentSD) {
        THFreeEx(pTHS, pParentSD);
    }

    if (err) {
        return SetAttError(pDN, ATT_NT_SECURITY_DESCRIPTOR,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL, err);
    }

    // Remove the object's current SD
    if (err = DBRemAttVal_AC(pTHS->pDB,
                             pAC,
                             pcbSDBuff,
                             pSDBuff)) {
        SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR);
        goto End;
    }

    // Add the new SD.
    if (err = DBAddAttVal_AC(pTHS->pDB, pAC, cbNewSD, pNewSD)) {
        SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR);
        goto End;
    }

End:
     if(pNewSD) {
         DestroyPrivateObjectSecurity(&pNewSD);
     }

     return err;
#undef SEC_INFO_ALL
}

VOID
GetFilterSecurityForItem(
        THSTATE *pTHS,
        ATTRTYP aType,
        BOOL **pbSkip,
        INTERIM_FILTER_SEC **ppIF,
        BOOL fABFilter,
        DWORD *pSecSize,
        DWORD *pAllocSize
        )
{
    // Now deal with the
    switch(aType) {
    case ATT_OBJECT_CLASS:
        // By convention, we do NOT apply security to object class in
        // filters.  This allows the common ldap idiom of searching
        // with a filter of (objectclass=*) to mean find all objects.
        (*pbSkip) = NULL;
        break;
    case ATT_DBCS_PWD:
    case ATT_UNICODE_PWD:
    case ATT_PEK_LIST:
    case ATT_SUPPLEMENTAL_CREDENTIALS:
    case ATT_CURRENT_VALUE:
    case ATT_PRIOR_VALUE:
    case ATT_INITIAL_AUTH_INCOMING:
    case ATT_INITIAL_AUTH_OUTGOING:
    case ATT_TRUST_AUTH_INCOMING:
    case ATT_TRUST_AUTH_OUTGOING:
    case ATT_USER_PASSWORD:

        // We will ALWAYS deny READ_PROPERTY on these attributes.  If
        // you have to ask, you can't have it.  If any more attributes
        // are deemed to be invisible in the future, they should be
        // added to this case of the switch (note that this only denies
        // access to attributes in the filter of a search, see the
        // routine CheckReadSecurity above to deny access to attributes
        // in selection lists.)
        (*pbSkip) =THAllocEx(pTHS, sizeof(BOOL));
        *(*pbSkip) = TRUE;
        break;

    case ATT_SHOW_IN_ADDRESS_BOOK:
        if(fABFilter) {
            // Filters doing "Address Book" type filters (i.e. look for
            // all objects with SHOW_IN set to a specific value) should
            // already have checked that the address book should be
            // visible. Therefore, do not apply security to this filter
            // item.
            (*pbSkip) = NULL;
            break;
        }
        // Otherwise, fall through to do normal security.
    default:
        // build the filter security structure for evaluating with
        // specific SDs later.
        if(*pSecSize == *pAllocSize) {
            *pAllocSize = *pAllocSize * 2 + 10;
            *ppIF = THReAllocEx(pTHS,
                                *ppIF,
                                *pAllocSize*sizeof(INTERIM_FILTER_SEC));
        }

        (*ppIF)[*pSecSize].pAC = SCGetAttById(pTHS, aType);
        (*ppIF)[*pSecSize].pBackPointer = pbSkip;
        *pSecSize += 1;
        break;
    }
    return;
}

BOOL
GetFilterSecurityHelp (
        THSTATE *pTHS,
        FILTER *pFilter,
        INTERIM_FILTER_SEC **ppIF,
        BOOL fABFilter,
        DWORD *pSecSize,
        DWORD *pAllocSize
        )
{
    ULONG count;
    ATTRTYP aType;

    if(!pFilter)
        return TRUE;

    // Walk the filter, building a list of the attributes in the filter and
    // pointer back to the filter element which referenced them.

    switch (pFilter->choice){
        // count number of filters are anded together.  If any are false
        // the AND is false.
    case FILTER_CHOICE_AND:
        count = pFilter->FilterTypes.And.count;
        for (pFilter = pFilter->FilterTypes.And.pFirstFilter;
             count--;
             pFilter = pFilter->pNextFilter){
            GetFilterSecurityHelp (pTHS,
                                   pFilter,ppIF,
                                   fABFilter,
                                   pSecSize,
                                   pAllocSize );
        }
        break;

        // count number of filters are ORed together.  If any are true
        // the OR is true.
    case FILTER_CHOICE_OR:
        count = pFilter->FilterTypes.Or.count;
        for (pFilter = pFilter->FilterTypes.Or.pFirstFilter;
             count--;
             pFilter = pFilter->pNextFilter){
            GetFilterSecurityHelp (pTHS,
                                   pFilter,ppIF,
                                   fABFilter,
                                   pSecSize,
                                   pAllocSize);
        } /*for*/
            break;

    case FILTER_CHOICE_NOT:
        GetFilterSecurityHelp(pTHS,
                              pFilter->FilterTypes.pNot, ppIF,
                              fABFilter,
                              pSecSize,
                              pAllocSize);
        break;

        // Apply the chosen test to the database attribute on the current
        // object.
    case FILTER_CHOICE_ITEM:

        // First, find the type of the attribute this item filters on.
        switch(pFilter->FilterTypes.Item.choice) {
        case FI_CHOICE_PRESENT:
            aType = pFilter->FilterTypes.Item.FilTypes.present;
            break;

        case FI_CHOICE_SUBSTRING:
            aType = pFilter->FilterTypes.Item.FilTypes.pSubstring->type;
            break;

        default:
            aType = pFilter->FilterTypes.Item.FilTypes.ava.type;
        }

        GetFilterSecurityForItem(
                pTHS,
                aType,
                &pFilter->FilterTypes.Item.FilTypes.pbSkip,
                ppIF,
                fABFilter,
                pSecSize,
                pAllocSize);
        return TRUE;
        break;

    default:
        return FALSE;
        break;
    }  /*switch FILTER*/

    return TRUE;

} /* GetFilterSecurityHelp */
BOOL
GetFilterSecurity (
        THSTATE *pTHS,
        FILTER *pFilter,
        ULONG   SortType,
        ATTRTYP SortAtt,
        BOOL fABFilter,
        POBJECT_TYPE_LIST *ppFilterSecurity,
        BOOL **ppbSortSkip,
        DWORD **ppResults,
        DWORD *pSecSize
        )
{
    ULONG count,i,j;
    ULONG AllocSize = 10;
    INTERIM_FILTER_SEC *pIF;
    INTERIM_FILTER_SEC *pIF2;
    DWORD *pResults;
    DWORD cIF=0;
    POBJECT_TYPE_LIST pObjList;
    GUID *pCurrentPropSet;
    DWORD cPropSets, cProps;
    ATTCACHE *pCurrentAC=NULL;

    *ppFilterSecurity = NULL;
    *ppResults = NULL;
    *pSecSize = 0;

    *pSecSize = 0;
    pIF = THAllocEx(pTHS, 10 * sizeof(INTERIM_FILTER_SEC));

    if(SortType != SORT_NEVER) {
        // Hey, they are going to want us to sort.  Make sure this ends up in
        // the security to check.
        GetFilterSecurityForItem(
                pTHS,
                SortAtt,
                ppbSortSkip,
                &pIF,
                fABFilter,
                &cIF,
                &AllocSize);
    }
    else {
        *ppbSortSkip = NULL;
    }

    if(!GetFilterSecurityHelp(pTHS,
                              pFilter,
                              &pIF,
                              fABFilter,
                              &cIF,
                              &AllocSize))
        return FALSE;


    if(!cIF)                            // Nothing to apply security to.
        return TRUE;

    // We have the list of Interim_Filter_Sec's, with the possibility of dups.
    // Rearrange the list to first group duplicates, then group by propset.

    if(cIF > 2) {
        // two element lists are already grouped.
        cProps = 0;
        cPropSets = 0;
        // First, group all properties together
        for(count=0; count < cIF; count++) {
            cProps++;
            i=count+1;
            while( i < cIF && (pIF[count].pAC == pIF[i].pAC)) {
                count++;
                i++;
            }
            j = i+1;
            while(j<cIF) {
                if(pIF[count].pAC == pIF[j].pAC) {
                    INTERIM_FILTER_SEC IFTemp;
                    // Found one.
                    IFTemp = pIF[i];
                    pIF[i] = pIF[j];
                    pIF[j] = IFTemp;
                    count++;
                    i++;
                }
                j++;
            }
        }

        // Now that they are grouped, sort them into propset order
        pIF2 = THAllocEx(pTHS,cIF * sizeof(INTERIM_FILTER_SEC));
        j=0;
        for(count=0;count<cIF;count++) {
            if(!pIF[count].pAC)
                continue;
            cPropSets++;
            pCurrentPropSet = &pIF[count].pAC->propSetGuid;
            pIF2[j++] = pIF[count];
            pIF[count].pAC = NULL;
            for(i=count+1;i<cIF;i++) {
                if(!pIF[i].pAC)
                    continue;
                if(memcmp(pCurrentPropSet,
                          &pIF[i].pAC->propSetGuid,
                          sizeof(GUID)) == 0) {
                    // Yes, this is the propset we're sifting for.
                    pIF2[j++] = pIF[i];
                    pIF[i].pAC = NULL;
                }
            }
        }
        memcpy(pIF,pIF2,cIF * sizeof(INTERIM_FILTER_SEC));
        THFreeEx(pTHS,pIF2);
    }
    else {
        // maximal numbers
        cPropSets = cIF;
        cProps = cIF;
    }


    // pIF holds an array of INTERIM_FILTER_SECs, grouped by propset and then
    // grouped by property.



    // Now, create an obj list used later for a security check.
    pObjList = THAllocEx(pTHS, (cPropSets + cProps + 1) * sizeof(OBJECT_TYPE_LIST));
    pResults = THAllocEx(pTHS, (cPropSets + cProps + 1) * sizeof(DWORD));

    // pObjList[0] will be filled in later with a class guid.
    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = NULL;

    // Ok, put the grouped GUIDS into the objlist structure.
    pObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    pObjList[1].Sbz = 0;
    pObjList[1].ObjectType = &pIF[0].pAC->propSetGuid;
    pCurrentPropSet = &pIF[0].pAC->propSetGuid;

    for(j=1,i=0;i<cIF;i++) {
        if(pIF[i].pAC != pCurrentAC) {
            // This entry does not refer to the same attribute as the last
            // entry.  We need to add a new entry into the obj list to
            // correspond to this new attribute

            // First, keep track of this new attribute
            pCurrentAC = pIF[i].pAC;

            // Inc the increment in the objlist.  This variable tracks the last
            // filled in element in the objlist.
            j++;
            // J is now the index of the element in the objlist to fill in.

            if(memcmp(&(pCurrentAC->propSetGuid),
                      pCurrentPropSet,
                      sizeof(GUID))) {
                // Hey, we tripped into a new propset.  We need an entry in the
                // objlist for this new prop set.
                pObjList[j].Level = ACCESS_PROPERTY_SET_GUID;
                pObjList[j].Sbz = 0;
                pObjList[j].ObjectType = &pCurrentAC->propSetGuid;
                pCurrentPropSet = &pCurrentAC->propSetGuid;

                // Inc again, since we still need to put an entry for the
                // attribute into the objlist.
                j++;
            }

            // Fill in the entry for the attribute.
            pObjList[j].Level = ACCESS_PROPERTY_GUID;
            pObjList[j].Sbz = 0;
            pObjList[j].ObjectType = &pCurrentAC->propGuid;
        }

        // OK, if this entry in the pIF is a new attribute, we've added the
        // information from that new attribute to the objlist.  If it wasn't a
        // new attribute, we didn't do anything.  In either case, j is the index
        // of the last object filled in, and we need to set the backpointer up.

        // For the curious: pIF[i].pBackPointer points to the pbSkip field of
        // some item filter element.  When we go to evaluate security later, we
        // use the objlist we've built here in a call to the security
        // functions.  Furthermore, we use pResults as the place for the
        // security function to put the results of the security check.  So, we
        // set the pbSkip pointer in the item filter to point to the appropriate
        // element in the pResults array.  When we evaluate the filter, we check
        // pResults[x] via pbSkip, and if non-zero (i.e. failed the security
        // check for reading), we evaluate the filter as if that item had no
        // value in the database.
        *(pIF[i].pBackPointer) = &pResults[j];
    }

    *ppResults = pResults;
    *ppFilterSecurity = pObjList;
    // j is an index (0 based).  Remember to add in one extra to get the count
    *pSecSize = j + 1;

    THFreeEx(pTHS, pIF);
    return TRUE;
}/* GetFilterSecurity */



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int GetObjSchema(DBPOS *pDB, CLASSCACHE **ppClassSch){

   ATTRTYP ObjClass;
   DWORD err = 0;

   // Object class
   if((err=DBGetSingleValue(pDB, ATT_OBJECT_CLASS, &ObjClass,
                       sizeof(ObjClass), NULL)) ||
      !(*ppClassSch = SCGetClassById(pDB->pTHS, ObjClass))) {

      DPRINT(2, "Couldn't find Object class \n");

      return SetUpdErrorEx(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           DIRERR_OBJ_CLASS_NOT_DEFINED, err);
   }

   return 0;

}/*GetObjSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int GetObjRdnType(DBPOS *pDB, CLASSCACHE *pCC, ATTRTYP *pRdnType){

    // rdnType
    // If no rdnType is present then use the rdnattid from the class
    // defn. If the class doesn't have an rdnattid, return ATT_COMMON_NAME.
    if(DBGetSingleValue(pDB, FIXED_ATT_RDN_TYPE, pRdnType,
                        sizeof(*pRdnType), NULL)) {
        if (pCC->RDNAttIdPresent) {
            *pRdnType = pCC->RdnIntId;
        } else {
            *pRdnType = ATT_COMMON_NAME;
        }
    }

    return 0;

}/*GetObjRdnType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
CallerIsTrusted(
    IN THSTATE *pTHS
     )
/*++
Routine Description
    The caller is trusted if the caller is
        replicating
        AD
        promoting
        upgrading
        running as mkdit

Paramters
    pTHS - thread struct, obviously

Return
    0 caller is not trusted
    1 caller is trusted
--*/
{
    extern BOOL gfRunningAsMkdit;

    // The caller is trusted if the caller is
    //    replicating
    //    AD (calling itself)
    //    promoting
    //    upgrading
    //    running as mkdit

    if (   pTHS->fDRA
        || pTHS->fDSA
        || DsaIsInstalling()
        || gAnchor.fSchemaUpgradeInProgress
        || gfRunningAsMkdit) {
        return 1;
    }
    return 0;
}/*CallerIsTrusted*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int ValidateAuxClass (THSTATE *pTHS,
                      DSNAME *pDN,
                      CLASSCACHE *pClassSch,
                      CLASSSTATEINFO  *pClassInfo)
{
    CLASSCACHE      *pCC;
    DWORD           objClassCount, baseIdx;
    DWORD           err;
    DWORD           cCombinedObjClass;
    ATTRTYP         *pCombinedObjClass;

    if (pClassInfo->cNewAuxClasses == 0) {
        return 0;
    }

    // if one of the auxClasses is a class that is already on the
    // object's hierarchy, this is an error
    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {
        if (pClassInfo->pNewAuxClasses[objClassCount] == pClassSch->ClassId) {
            DPRINT1 (0, "AuxClass containes a class (0x%x) already on the object hierarchy\n", pClassInfo->pNewAuxClasses[objClassCount]);

            return SetAttError(pDN, ATT_OBJECT_CLASS,
                               PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                               ERROR_DS_ATT_VAL_ALREADY_EXISTS);
        }
        for (baseIdx=0; baseIdx < pClassSch->SubClassCount; baseIdx++) {
            if (pClassInfo->pNewAuxClasses[objClassCount] == pClassSch->pSubClassOf[baseIdx]) {
                DPRINT1 (0, "AuxClass containes a class (0x%x) already on the object hierarchy\n", pClassInfo->pNewAuxClasses[objClassCount]);

                return SetAttError(pDN, ATT_OBJECT_CLASS,
                                   PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                   ERROR_DS_ATT_VAL_ALREADY_EXISTS);
            }
        }
    }

    // all the superclasses of the new auxClasses
    // should exist in the combined objectClass hierarchy

    objClassCount = pClassInfo->cNewAuxClasses + 1 + pClassSch->SubClassCount;
    pCombinedObjClass = THAllocEx (pTHS, sizeof (ATTRTYP) * objClassCount);

    pCombinedObjClass[0] = pClassSch->ClassId;
    cCombinedObjClass = 1;

    for (objClassCount=0; objClassCount<pClassSch->SubClassCount; objClassCount++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassSch->pSubClassOf[objClassCount];
    }

    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassInfo->pNewAuxClasses[objClassCount];
    }

    qsort(pCombinedObjClass,
          cCombinedObjClass,
          sizeof(ATTRTYP),
          CompareAttrtyp);


    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {

        for (baseIdx=0; baseIdx < pClassInfo->pNewAuxClassesCC[objClassCount]->SubClassCount; baseIdx++) {

            if (!bsearch(&pClassInfo->pNewAuxClassesCC[objClassCount]->pSubClassOf[baseIdx],
                         pCombinedObjClass,
                         cCombinedObjClass,
                         sizeof(ATTRTYP),
                         CompareAttrtyp)) {

                DPRINT1 (0, "AuxClass hierarchy containes a class (0x%x) that is not on the object hierarchy\n",
                         pClassInfo->pNewAuxClassesCC[objClassCount]->pSubClassOf[baseIdx]);

                SetAttError(pDN, ATT_OBJECT_CLASS,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                   ERROR_DS_ILLEGAL_MOD_OPERATION);

                THFreeEx (pTHS, pCombinedObjClass);

                return pTHS->errCode;
            }
        }
    }

    THFreeEx (pTHS, pCombinedObjClass);

    return pTHS->errCode;
}

int ValidateObjClass(THSTATE *pTHS,
                     CLASSCACHE *pClassSch,
                     DSNAME *pDN,
                     ULONG cModAtts,
                     ATTRTYP *pModAtts,
                     CLASSSTATEINFO  **ppClassInfo)
{
    ULONG   count, auxClsCount;
    ATTRTYP *pMust;
    ATTR    *pAttr;
    ULONG   i;
    BOOL    CheckMust = FALSE, CheckMay = FALSE;
    ULONG   err;
    CLASSCACHE *pCC;
    CLASSSTATEINFO  *pClassInfo = NULL;

    Assert (ppClassInfo);

    if (pTHS->fDRA ||
        (pTHS->fSAM && pTHS->fDSA)){
        // Replication is allowed to perform modifications that violate the
        // schema, OR if it's SAM calling us and he's swearing that he's
        // only modifying SAM owned attributes, we'll trust him.
        return 0;
    }

    // this means that we changed the objectClass/auxClass
    if ( (pClassInfo = *ppClassInfo) != NULL) {

        if (ValidateAuxClass (pTHS, pDN, pClassSch, pClassInfo)) {
            return pTHS->errCode;
        }

        // since we changed objectClass or auxClass
        // we have todo a full validation

        CheckMay = TRUE;
        CheckMust = TRUE;

        goto mustMayChecks;
    }
    // we haven't changed objectClass. have to see whether we have an auxClass
    // on the object
    else  {
        pClassInfo = ClassStateInfoCreate(pTHS);
        if (!pClassInfo) {
            return pTHS->errCode;
        }
        if (ppClassInfo) {
            *ppClassInfo = pClassInfo;
        }

        if (ReadClassInfoAttribute (pTHS->pDB,
                                    pClassInfo->pObjClassAC,
                                    &pClassInfo->pNewObjClasses,
                                    &pClassInfo->cNewObjClasses_alloced,
                                    &pClassInfo->cNewObjClasses,
                                    NULL) ) {
            return pTHS->errCode;
        }

        BreakObjectClassesToAuxClassesFast (pTHS, pClassSch, pClassInfo);

        if (ValidateAuxClass (pTHS, pDN, pClassSch, pClassInfo)) {
            return pTHS->errCode;
        }

    }


    /* For each attribute touched during this modification, check
     * to see if it was a may-have (good), must-have (bad), or neither
     * (really bad).  The theory is that assuming that the object was
     * in compliance when we started, and we've only touched legal
     * may-have attributes, we could not have brought the object out
     * of compliance.
     */
    for (i=0; i<cModAtts; i++) {
        if (IsMember(pModAtts[i],
                     pClassSch->MustCount,
                     pClassSch->pMustAtts)) {
            /* The attribute touched was a must-have.  That means that
             * we need to do a full check to make sure that all the must-
             * haves are present on the current version of the object.
             */
            CheckMust = TRUE;
        }
        else if (pClassInfo && IsAuxMember (pClassInfo, pModAtts[i], TRUE, FALSE)) {

            // so we touched a must have from an auxClass
            // we need a fullCheck

            CheckMust = TRUE;
        }
        else {
            if ( (!IsMember(pModAtts[i],
                            pClassSch->MayCount,
                            pClassSch->pMayAtts) ) &&
                (!pClassInfo ||
                 (pClassInfo && !IsAuxMember (pClassInfo, pModAtts[i], FALSE, TRUE))) ) {

                /* This attribute was neither a may-have nor a must-have.
                 * Odds are that this is going to end up as an error, but
                 * it could be some weird case where the attribute used to
                 * be legal an is no longer and is being removed.  Anyway,
                 * we're not trying to optimize the error path, but the
                 * normal success path.  Flag this for a full check of all
                 * attributes, which will also set the appropriate error.
                 */
                CheckMay = TRUE;
            }
            else {
                /* This is the case we actually like, which is that the
                 * attribute being modified was a may-have.  If all of
                 * the attributes are in this category, we can get off
                 * easy and just return success.
                 */
            }
        }
    }

mustMayChecks:

    if (CheckMust) {
        /* Check that all required attributes with their values are on the obj*/

        pMust = pClassSch->pMustAtts;

        for (count = 0 ; count < pClassSch->MustCount; count++){
            if(!DBHasValues(pTHS->pDB, *(pMust + count))) {

                DPRINT1(1, "Missing Required Att. <%lu>\n", *(pMust + count));

                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_MISSING_REQUIRED_ATT);
            }
        }/*for*/


        // now check for mustHaves from the auxClasses on this object
        if (pClassInfo && pClassInfo->cNewAuxClasses) {
            for (auxClsCount = 0 ; auxClsCount < pClassInfo->cNewAuxClasses; auxClsCount++){

                pCC = pClassInfo->pNewAuxClassesCC[auxClsCount];
                Assert (pCC);

                pMust = pCC->pMustAtts;
                for (count = 0 ; count < pCC->MustCount; count++) {

                    if(!DBHasValues(pTHS->pDB, *(pMust + count))) {
                        DPRINT2(1, "Missing Required Att. <0x%x> from AuxClass\n", *(pMust + count), pCC->ClassId);

                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           ERROR_DS_MISSING_REQUIRED_ATT);
                    }
                }
            }
        }
    }

    if (CheckMay) {
        /*Make sure that all atts on the object are defined for the class*/

        DBGetMultipleAtts(pTHS->pDB,
                          0,
                          NULL,
                          NULL,
                          NULL,
                          &count,
                          &pAttr,
                          0,
                          0);

        for(i=0;i<count;i++) {
            if (!IsMember(pAttr[i].attrTyp, pClassSch->MustCount,
                          pClassSch->pMustAtts)  &&
                !IsMember(pAttr[i].attrTyp, pClassSch->MayCount,
                          pClassSch->pMayAtts)   &&
                ((pClassInfo == NULL) ||
                 (!IsAuxMember (pClassInfo, pAttr[i].attrTyp, TRUE, TRUE))) ){
                    DPRINT2 (1, "Attr 0x%x is not a member of class 0x%x\n",
                            pAttr[i].attrTyp, pClassSch->ClassId);

                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_ATT_NOT_DEF_FOR_CLASS);
            }
        }
    }

    return 0;
}/*ValidateObjClass*/


HVERIFY_ATTS
VerifyAttsBegin(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pObj,
    IN  ULONG       dntOfNCRoot,
    IN  ADDCROSSREFINFO * pCRInfo
    )
/*++

Routine Description:

    Create a verify atts handle to be passed to future calls to AddAttVals,
    ReplaceAttVals, etc.

    Caller *MUST* free the handle with VerifyAttsEnd() when done, even under
    exceptional circumstances.

Arguments:

    pTHS (IN)

    pObj (IN) - DSNAME of the object being added/modified.

    dntOfNCRoot (IN) - The DNT of the root of this NC, or INVALIDDNT if this
        operation is creating (not modifiying) the NC root.

Return Values:

    HVERIFY_ATTS handle.  Throws memory exceptions.

--*/
{
    HVERIFY_ATTS hVerifyAtts;

    hVerifyAtts = THAllocEx(pTHS, sizeof(*hVerifyAtts));
    hVerifyAtts->pObj = pObj;
    hVerifyAtts->NCDNT = dntOfNCRoot;
    hVerifyAtts->pCRInfo = pCRInfo;

    return hVerifyAtts;
}

void
VerifyAttsEnd(
    IN      THSTATE *       pTHS,
    IN OUT  HVERIFY_ATTS *  phVerifyAtts
    )
/*++

Routine Description:

    Closes a verify atts handle created by a previous call to VerifyAttsBegin().

Arguments:

    pTHS (IN)

    phVerifyAtts (IN/OUT) - Ptr to previously allocated handle.  Set to NULL on
        return.

Return Values:

    None.

--*/
{
    Assert(NULL != *phVerifyAtts);

    if (NULL != (*phVerifyAtts)->pDBTmp_DontAccessDirectly) {
        // This DBPOS doesn't have its own transaction, so fCommit = TRUE is
        // ignored.
        DBClose((*phVerifyAtts)->pDBTmp_DontAccessDirectly, TRUE);
    }

    THFreeEx(pTHS, *phVerifyAtts);
    *phVerifyAtts = NULL;
}

int
VerifyAttsGetObjCR(
    IN OUT  HVERIFY_ATTS    hVerifyAtts,
    OUT     CROSS_REF **    ppObjCR
    )
/*++

Routine Description:

    Derives and caches the cross-ref corresponding to the object.

Arguments:

    hVerifyAtts (IN/OUT) - Ptr to previously allocated handle.  On return
        references the derived cross-ref.

    ppObjCR (OUT) - On return, holds a ptr to the cross-ref corresponding to
        the object's NC.

Return Values:

    pTHS->errCode

--*/
{
    NAMING_CONTEXT_LIST *pNCL;
    CROSS_REF *pCR;

    if (NULL != hVerifyAtts->pObjCR_DontAccessDirectly) {
        // Already cached -- success!
        *ppObjCR = hVerifyAtts->pObjCR_DontAccessDirectly;
        return 0;
    }

    *ppObjCR = NULL;

    // Cache a ptr to the cross ref for the NC containing the object we're
    // adding/modifying.
    if (INVALIDDNT != hVerifyAtts->NCDNT) {
        // We're modifying an NC root or adding/modifying an interior node.
        if ((NULL == (pNCL = FindNCLFromNCDNT(hVerifyAtts->NCDNT, TRUE)))
            || (NULL == (pCR = FindExactCrossRef(pNCL->pNC, NULL)))) {
            Assert(!"Modifying existing object in unknown NC?");
            return SetNamError(NA_PROBLEM_NO_OBJECT,
                               NULL,
                               DIRERR_OBJ_NOT_FOUND);
        }
    } else {
        // We're performing an add of the root of this NC and thus have not
        // yet allocated a DNT for it.
        if (NULL == (pCR = FindExactCrossRef(hVerifyAtts->pObj, NULL))) {
            Assert(!"No crossRef in gAnchor for NC being created?");
            return SetNamError(NA_PROBLEM_NO_OBJECT,
                               NULL,
                               DIRERR_OBJ_NOT_FOUND);
        }
    }

    *ppObjCR = hVerifyAtts->pObjCR_DontAccessDirectly = pCR;

    // Success!
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add the attribute and its values to the object. */

int
AddAtt(
    THSTATE *       pTHS,
    HVERIFY_ATTS    hVerifyAtts,
    ATTCACHE *      pAttSchema,
    ATTRVALBLOCK *  pAttrVal
    )
{
    // The reason this is not done in the originating write case is that this
    // call enforces that the attributes does not already have values. We want
    // to permit on an originating write the scenario where the same attribute
    // appears multiple times in the input change list, each time adding additional
    // values.  However, for the replicator this call is essential since it
    // assures that the attribute's metadata is marked as changed.
    if (pTHS->fDRA) {
        /* Add the attribute type*/
        if (AddAttType(pTHS, hVerifyAtts->pObj, pAttSchema)) {
            return pTHS->errCode;
        }
    }

    /* Add att values */
    return AddAttVals(pTHS,
                      hVerifyAtts,
                      pAttSchema,
                      pAttrVal,
                      AAV_fCHECKCONSTRAINTS | AAV_fENFORCESINGLEVALUE);
}/*AddAtt*/

int
ReplaceAtt(
    THSTATE *       pTHS,
    HVERIFY_ATTS    hVerifyAtts,
    ATTCACHE *      pAttSchema,
    ATTRVALBLOCK *  pAttrVal,
    BOOL            fCheckAttValConstraint
    )
/*++
  Description:
      Replace all the values of an attribute with the values passed in.

  Parameters:
     pTHS - THSTATE for this thread.
     hVerifyAtts - verify atts handle returned by prior call to
         VerifyAttsBegin().
     pAttSchema - schema cache entry for attribute to be modified.
     pAttrVal - new values to put on the object.
     fCheckAttValConstraint - flag describing whether we should check
         constraints or not.

  Return value.
      0 if all went well.
      Non-zero error type if something went wrong.  If this is the case, a full
          error structure in the THSTATE is filled out, including the win32
          error code.
--*/
{
    DWORD    vCount;
    DWORD     err;
    ATTRVAL  *pAVal;

    if(pAttSchema->isSingleValued && (pAttrVal->valCount > 1)) {
        // The attribute we wish to replace values on is single valued and the
        // caller gave us more than one value. So we have too many values.

        return SetAttError(hVerifyAtts->pObj, pAttSchema->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           DIRERR_SINGLE_VALUE_CONSTRAINT);
    }


    // Check constraints only if we were asked to and we're not
    // a replication thread. In free builds fDSA overrides
    // constraint checks for performance. Checked builds still
    // do checks to catch problems

#if DBG
    if ( fCheckAttValConstraint &&  !pTHS->fDRA ) {
#else
    if ( fCheckAttValConstraint && !(pTHS->fDRA || pTHS->fDSA)) {
#endif

        pAVal = pAttrVal->pAVal;
        for(vCount = 0; vCount < pAttrVal->valCount; vCount++){
            // Check constraints only if we were asked to and we're not
            // a replication thread. In free builds fDRA overrides
            // constraint checks for performance. Checked builds still
            // do checks to catch problems
            err = CheckConstraint( pAttSchema, pAVal );

            if ( 0 != err ){

                // Continue processing if the attribute error was sucessful

                SAFE_ATT_ERROR_EX(hVerifyAtts->pObj, pAttSchema->id,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                                  err, 0);
            }

            pAVal++;
        }
    }

    if(pTHS->errCode) {
        return pTHS->errCode;
    }

    if(err = VerifyDsnameAtts(pTHS, hVerifyAtts, pAttSchema, pAttrVal)) {
        // VerifyDsnameAtts should set an error in the THSTATE if an error
        // occurred.
        Assert(pTHS->errCode);
        return err;
    }
    // OK, the view of the attribute they want is legal.

    err = DBReplaceAtt_AC(pTHS->pDB, pAttSchema, pAttrVal,NULL);

    switch(err) {
    case 0:
        // nothing to do.
        break;
    case DB_ERR_VALUE_EXISTS:
        // constraint violation,
        SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                       PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                       ERROR_DS_ATT_VAL_ALREADY_EXISTS);
        break;
    default:
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        break;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add the attribute and its values to the object. */

int
AddAttType (
        THSTATE *pTHS,
        DSNAME *pObject,
        ATTCACHE *pAttSchema
        )
{
    DWORD rtn;
    ULONG tempSyntax;    /*Temp variable used to hold att syntax*/

    /* Add the attribute type*/

    rtn = DBAddAtt_AC(pTHS->pDB, pAttSchema, (UCHAR)pAttSchema->syntax);
    switch(rtn) {

    case 0:
        return 0;

    case DB_ERR_ATTRIBUTE_EXISTS:
        return SetAttError(pObject, pAttSchema->id,
                           PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                           DIRERR_ATT_ALREADY_EXISTS);

    case DB_ERR_BAD_SYNTAX:
        tempSyntax = (ULONG) (pAttSchema->syntax);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_BAD_ATT_SCHEMA_SYNTAX,
                 szInsertUL(tempSyntax),
                 szInsertUL(pAttSchema->id),
                 NULL);

        return SetAttError(pObject, pAttSchema->id,
                           PR_PROBLEM_INVALID_ATT_SYNTAX, NULL,
                           DIRERR_BAD_ATT_SCHEMA_SYNTAX);

    default:
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);

    } /*select*/


}/*AddAttType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add attribute values to the object.  Check the various value
   constraints (single-valued and range limits), if a value fails continue
   processing to validate all values.
*/

int
AddAttVals(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAttSchema,
    ATTRVALBLOCK *pAttrVal,
    DWORD dwFlags
    )
{
    ATTRVAL *pAVal;
    UCHAR outSyntax;
    ULONG vCount;
    int returnVal;
    unsigned err;
    BOOL fCheckConstraints = !!(dwFlags & AAV_fCHECKCONSTRAINTS);
    BOOL fEnforceSingleValue = !!(dwFlags & AAV_fENFORCESINGLEVALUE);
    BOOL fPermissive = !!(dwFlags & AAV_fPERMISSIVE);

    if (returnVal = VerifyDsnameAtts(pTHS, hVerifyAtts, pAttSchema, pAttrVal)) {
        return returnVal;
    }

   /* Single-Value constraint check.  if fEnfoceSingleVale == FALSE, we are
      doing a modify call, which is allowed to violate single valuedness during
      the call, but must end up with a legal object. */

    if (fEnforceSingleValue                      &&
        pAttSchema->isSingleValued               &&
        ((pAttrVal->valCount > 1)      ||
         (DBHasValues_AC(pTHS->pDB,
                         pAttSchema)   &&
          pAttrVal->valCount          )   )      ) {
        // We are supposed to enforce single valuedness
        //            AND
        // the attribute is single valued
        //            AND
        // (
        //   Either we are simply adding multiple values
        //        OR
        //   The object has values AND we are adding new values.
        // )
        // So we have too many values.

        return SetAttError(hVerifyAtts->pObj, pAttSchema->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           DIRERR_SINGLE_VALUE_CONSTRAINT);
    }

    /* Add the attribute values for this attribute.  */

    pAVal = pAttrVal->pAVal;

    for(vCount = 0; vCount < pAttrVal->valCount; vCount++){

        // Check constraints only if we were asked to and we're not
        // a replication thread. In free builds fDRA overrides
        // constraint checks for performance. Checked builds still
        // do checks to catch problems

#if DBG
        if ( !fCheckConstraints || pTHS->fDRA ) {
#else
        if ( !fCheckConstraints || pTHS->fDRA || pTHS->fDSA) {
#endif
            err = 0;
        }
        else {
            err = CheckConstraint( pAttSchema, pAVal );
        }

        if ( 0 != err ){

            /* Continue processing if the attribute error was sucessful*/

            SAFE_ATT_ERROR_EX(hVerifyAtts->pObj, pAttSchema->id,
                              PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                              err, 0);
        }
        else {
            err = DBAddAttVal_AC(pTHS->pDB, pAttSchema,
                                 pAVal->valLen, pAVal->pVal);
            switch(err) {
            case 0:
                break;

            case DB_ERR_VALUE_EXISTS:
                /* Continue processing if the attribute error was sucessful*/

                if (!fPermissive) {
                    SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                                   PR_PROBLEM_ATT_OR_VALUE_EXISTS, pAVal,
                                   DIRERR_ATT_VAL_ALREADY_EXISTS);
                }
                break;

            case DB_ERR_SYNTAX_CONVERSION_FAILED:
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                               PR_PROBLEM_INVALID_ATT_SYNTAX, pAVal,
                               DIRERR_BAD_ATT_SYNTAX);
                break;

            case DB_ERR_NOT_ON_BACKLINK:
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                               DIRERR_NOT_ON_BACKLINK);
                break;

            default:
                return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);

            } /*switch*/
        }

        pAVal++;

    }/*for*/

    return pTHS->errCode;

}/*AddAttVals*/

BOOL
DsCheckConstraint(
    IN ATTRTYP  attID,
    IN ATTRVAL *pAttVal,
    IN BOOL     fVerifyAsRDN
        )
/*++
  NOTE NOTE NOTE:
      This routine is exported.  Don't mess with it.

  Description:
      This routine checks the attribute and value passed in for schema
      constraints, and for the extra constraints applied to RDNs if necessary.
      It is intended to be called by out of core DS clients (i.e. SAM) to verify
      an attribute before trying to use it.  We expect a valid THSTATE to be
      accessible.

  Parameters
      attID   - internal attribute ID of the attribute being checked
      pAttVal - the specific value being checked
      fVerifyAsRDN - Do we need to check the extra things we require of RDN
              attributes.

  Return Values:
      Returns TRUE if we can verify that the attribute value assertion passed in
      does not violate any known constraints.  Returns FALSE if we can not
      verify this for any reason (e.g. no THSTATE will result in a FALSE
      return).

--*/
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC;
    Assert(pTHS);
    if(!pTHS) {
        return FALSE;
    }

    pAC = SCGetAttById(pTHS, attID);
    Assert(pAC);
    if(!pAC) {
        return FALSE;
    }

    if(CheckConstraint(pAC, pAttVal)) {
        return FALSE;
    }

    if(fVerifyAsRDN) {
        // They want to know if this would be valid as an RDN
        if(pAC->syntax != SYNTAX_UNICODE_TYPE) {
            // Only UNICODE atts are RDNs
            return FALSE;
        }

        if((pAttVal->valLen/sizeof(WCHAR)) > MAX_RDN_SIZE) {
            // Too long for any RDN
            return FALSE;
        }

        if(fVerifyRDN((WCHAR *)pAttVal->pVal,
                      pAttVal->valLen / sizeof(WCHAR))) {
            // Characters are invalid.
            return FALSE;
        }
    }

    return TRUE;
}


/*++

Routine Description
   Check that an attribute conforms to any schema range constraints and that
   any given security descriptors are valid.

Arguements

    pAttSchema - pointer to the schema cache of the attribute we are adding
       values for.

   pAttVal - pointer to the value we are adding.

Return Values

    0 if all went well, a WIN32 error code otherwise.

--*/
unsigned
CheckConstraint (
        ATTCACHE *pAttSchema,
        ATTRVAL *pAttVal
        )
{
    unsigned err=0;
    SYNTAX_ADDRESS *pAddr;
    ULONG cBlobSize, cNoOfChar;

    switch (pAttSchema->syntax){
    case SYNTAX_INTEGER_TYPE:
        if ( pAttVal->valLen != sizeof(LONG)
            || (    pAttSchema->rangeLowerPresent
                && ((SYNTAX_INTEGER) pAttSchema->rangeLower)
                             > *(SYNTAX_INTEGER *)(pAttVal->pVal))
            || (   pAttSchema->rangeUpperPresent
                && ((SYNTAX_INTEGER) pAttSchema->rangeUpper)
                         < *(SYNTAX_INTEGER *)(pAttVal->pVal))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;
    case SYNTAX_OBJECT_ID_TYPE:
        if ( pAttVal->valLen != sizeof(LONG)
            || (    pAttSchema->rangeLowerPresent
                && pAttSchema->rangeLower > *(ULONG *)(pAttVal->pVal))
            || (    pAttSchema->rangeUpperPresent
                && pAttSchema->rangeUpper < *(ULONG *)(pAttVal->pVal))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;
    case SYNTAX_TIME_TYPE:
        if ( pAttVal->valLen != sizeof(DSTIME) ) {
            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;

    case SYNTAX_I8_TYPE:
        if ( pAttVal->valLen != sizeof(LARGE_INTEGER)) {
            // rangeLower/Upper are 32bits and so aren't very useful for
            // setting limits on a 64bit integer. Ignore range checking
            // for now.
            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;


    case SYNTAX_BOOLEAN_TYPE:
        if ( pAttVal->valLen != sizeof(BOOL)
            || (    pAttSchema->rangeLowerPresent
                && pAttSchema->rangeLower > (ULONG)(*(BOOL *)(pAttVal->pVal)))
            || (    pAttSchema->rangeUpperPresent
                && pAttSchema->rangeUpper < (ULONG)(*(BOOL *)(pAttVal->pVal)))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;

    case SYNTAX_UNICODE_TYPE:
        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > (pAttVal->valLen / sizeof(WCHAR))
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < (pAttVal->valLen / sizeof(WCHAR))) {
            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;


    case SYNTAX_OCTET_STRING_TYPE:
    case SYNTAX_SID_TYPE:

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;

    case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        //  We need to make sure that security descriptors are usable

        // BUGBUG this probably should also be checking for a fully
        // resolved security descriptor.  Can't remember what flag
        // Murli told me to check, but he did.  This should check
        // that it also has an owner and group SID, or check this
        // further up.

        if(!IsValidSecurityDescriptor(pAttVal->pVal)) {
            DPRINT(1, "Unusable security descriptor.\n");
            err = ERROR_DS_SEC_DESC_INVALID;
        }

        break;

    case SYNTAX_DISTNAME_TYPE:

        // range checking doesn't make sense
        break;

    case SYNTAX_DISTNAME_BINARY_TYPE:

        // This can be DNBinary or OR-Name
        // Check the binary part for range
        // no. of bytes should fall within range

        pAddr = DATAPTR( (SYNTAX_DISTNAME_BINARY *) pAttVal->pVal);
        cBlobSize = PAYLOAD_LEN_FROM_STRUCTLEN(pAddr->structLen);

        if ( pAttSchema->rangeLowerPresent
             && pAttSchema->rangeLower > cBlobSize
             || pAttSchema->rangeUpperPresent
             && pAttSchema->rangeUpper < cBlobSize) {

             err = ERROR_DS_RANGE_CONSTRAINT;
         }

         break;

    case SYNTAX_DISTNAME_STRING_TYPE:
        // This can be DNString or Access-Point
        // This is a unicode string and no. of chars should fall within range

         pAddr = DATAPTR( (SYNTAX_DISTNAME_STRING *) pAttVal->pVal);
         cNoOfChar = PAYLOAD_LEN_FROM_STRUCTLEN(pAddr->structLen)/2;

         if ( pAttSchema->rangeLowerPresent
              && pAttSchema->rangeLower > cNoOfChar
              || pAttSchema->rangeUpperPresent
              && pAttSchema->rangeUpper < cNoOfChar) {

              err = ERROR_DS_RANGE_CONSTRAINT;
          }
        break;

    default: /* all string types */

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;

    }/*switch*/

    return err;

}/*CheckConstraint*/

/*++

Routine Description
   Check that an EntryTTL conforms to any schema range constraints

Arguements

    pAttSchema - pointer to the schema cache of the attribute we are adding
       values for.

   pAttVal - pointer to the value we are adding.

Return Values

    0 if all went well, a WIN32 error code otherwise.

--*/
BOOL
CheckConstraintEntryTTL (
        IN  THSTATE     *pTHS,
        IN  DSNAME      *pObject,
        IN  ATTCACHE    *pACTtl,
        IN  ATTR        *pAttr,
        OUT ATTCACHE    **ppACTtd,
        OUT LONG        *pSecs
        )
{
    LONG        Secs;
    ATTCACHE    *pACTtd;
    extern LONG DynamicObjectDefaultTTL;
    extern LONG DynamicObjectMinTTL;

    // single valued
    if (pAttr->AttrVal.valCount > 1) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_SINGLE_VALUE_CONSTRAINT);
        return FALSE;
    }

    // integer
    if (pAttr->AttrVal.pAVal->valLen != sizeof(LONG)) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_INVALID_ATTRIBUTE_SYNTAX);
        return FALSE;
    }

    // get time-to-live in seconds and adjust if needed
    memcpy(&Secs, pAttr->AttrVal.pAVal->pVal, sizeof(LONG));

    // 0 means take the default
    if (Secs == 0) {
        Secs = DynamicObjectDefaultTTL;
    }
    // Too small, lengthen
    if (Secs < DynamicObjectMinTTL) {
        Secs = DynamicObjectMinTTL;
    }
    // Constraints
    if (   Secs < (LONG)pACTtl->rangeLower
        || Secs > (LONG)pACTtl->rangeUpper) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_RANGE_CONSTRAINT);
        return FALSE;
    }

    // attrcache for time to die
    pACTtd = SCGetAttById(pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE);
    if (!pACTtd) {
        SetAttError(pObject, ATT_MS_DS_ENTRY_TIME_TO_DIE,
                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        return FALSE;
    }

    // Defunct?
    if (pACTtd->bDefunct && !pTHS->fDRA && !pTHS->fDSA) {
        SetAttError(pObject, ATT_MS_DS_ENTRY_TIME_TO_DIE,
                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        return FALSE;
    }

    *ppACTtd = pACTtd;
    *pSecs = Secs;

    return TRUE;

}/*CheckConstraintEntryTTL*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
// InsertObj
// Replace an object or add a new one, both via the multitalented DBRepl.

int InsertObj(THSTATE *pTHS,
              DSNAME *pDN,
              PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
              BOOL bModExisting,
              DWORD dwMetaDataFlags)
{
    DBPOS *pDBTmp;
    DWORD  fAddFlags;
    int   err;
    BOOL   fCommit = FALSE;
    DPRINT1(2,"InsertObj entered: %S\n", pDN->StringName);

    if (!pTHS->fDRA && (NULL != pMetaDataVecRemote)) {
        // Only the replicator can merge remote meta data vectors.
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           DIRERR_REPLICATOR_ONLY);
    }

    if (bModExisting) {
        fAddFlags = 0;
    }
    else {
        DBOpen2(FALSE, &pDBTmp);
        __try {
            // See if we are adding or modifying an object. If we are replacing
            // a deleted object, DBFind will not find it because it's not an
            // object at this point as we removed the object flag. So we
            // re-add it.

            if (!DBFindDSName(pDBTmp, pDN)) {
                /* Existing object */
                fAddFlags = 0;
            } else {
                /* Adding new object or reviving deleted object. */
                fAddFlags = DBREPL_fADD;
                if (IsRoot(pDN)) {
                    fAddFlags |= DBREPL_fROOT;
                }
            }
            fCommit = TRUE;
        }
        __finally {
            DBClose(pDBTmp, fCommit);
        }
    }

    switch (err = DBRepl(   pTHS->pDB,
                            pTHS->fDRA,
                            fAddFlags,
                            pMetaDataVecRemote,
                            dwMetaDataFlags)){
      case 0:
        DPRINT(3,"Object sucessfully added\n");
        return 0;
        break;
      case DB_ERR_DATABASE_ERROR:
        DPRINT(0,"Database error error returned generate DIR_ERROR\n");

        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        break;
      default:   /*All other error should never happen*/
        DPRINT1(0,"Unknown DBADD error %u returned generate DIR_ERROR\n", err);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CODE_INCONSISTENCY,
                 szInsertSz("InsertObj"),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY,
                             err);
        break;
    }/*switch*/

}/*InsertObj*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Small helper routine to increment the global gNoOfSchChangeSinceBoot.
   The global keeps count of the no. of schema changes since last reboot,
   and is incremented once on each originating schema change on this DC, and
   once on a successful schema NC sync (including schema fsmo transfer) if
   any actual schema changes are brought in. When the schema cache is loaded,
   the current value of this global is cached, indicating how uptodate the
   schema cache is.

   When a schema NC replication is done, the cached value in the thread
   state's schema pointer is compared with the global to decide if the
   cache is uptodate with all prior changes in this DC (including replicated
   in changes), since any replicated in schema changes will be validated
   against this cache. The variable is updated and read only within the
   critical section. When a schema replication starts, the critical section
   is first entered before reading this value, and the critical section is
   held for the entire packet processing (not necessarily the entire NC
   processing). Similarly, all originating writes write this variable in the
   critical section through this function. This ensures that a replicated-in
   schema change and originating schema changes are serialized, and the
   replicated-in change cannot see a backdated schema cache and still
   continue.

*/

VOID
IncrementSchChangeCount(THSTATE *pTHS)
{
    EnterCriticalSection(&csNoOfSchChangeUpdate);
    __try {
         gNoOfSchChangeSinceBoot++;
    }
    __finally {
          LeaveCriticalSection(&csNoOfSchChangeUpdate);
    }
}


DWORD
ObjCachingPreProcessTransactionalData (
        BOOL fCommit
        )
{
    // Don't actually have any work to do to prepare, at least so far.
    return TRUE;
}

VOID
FreeCrossRefListEntry(
    IN OUT CROSS_REF_LIST **ppCRL
    )
/*++

Routine Description:

    Free the malloc'ed memory associated w/*ppCRL. Assumes
    *ppCRL has been removed from or was never on the global
    cross ref list.

Arguments:

    ppCRL - pointer to address of cross_ref_list

Return Value:

    None. Sets *ppCRL to NULL

--*/
{
    DWORD i;
    CROSS_REF_LIST *pCRL;

    if (NULL == (pCRL = *ppCRL)) {
        return;
    }
    *ppCRL = NULL;

    if (pCRL->CR.pNC) {
        free(pCRL->CR.pNC);
    }
    if (pCRL->CR.pNCBlock) {
        free(pCRL->CR.pNCBlock);
    }
    if (pCRL->CR.pObj) {
        free(pCRL->CR.pObj);
    }
    if (pCRL->CR.NetbiosName) {
        free(pCRL->CR.NetbiosName);
    }
    if (pCRL->CR.DnsName) {
        free(pCRL->CR.DnsName);
    }
    if (pCRL->CR.DnsAliasName) {
        free(pCRL->CR.DnsAliasName);
    }
    if (pCRL->CR.pdnSDRefDom) {
        free(pCRL->CR.pdnSDRefDom);
    }
    if (pCRL->CR.DnsReferral.pAVal) {
        for (i = 0; i < pCRL->CR.DnsReferral.valCount; ++i) {
            if (pCRL->CR.DnsReferral.pAVal[i].pVal) {
                free(pCRL->CR.DnsReferral.pAVal[i].pVal);
            }
        }
        free(pCRL->CR.DnsReferral.pAVal);
    }
    free(pCRL);
}

VOID
ObjCachingPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
{
    OBJCACHE_DATA *pTemp, *pTemp2;
    DWORD         err;
    BOOL          catalogChanged;

    Assert(VALID_THSTATE(pTHS));

    if ( !fCommitted ) {
        // Aborted transaction - throw away all the data of
        // this (possibly nested) transaction.

        // Free up anything in the pData.
        pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;
        pTHS->JetCache.dataPtr->objCachingInfo.pData = NULL;

        while(pTemp) {
            pTemp2 = pTemp;
            pTemp = pTemp->pNext;
            if(pTemp2->pMTX) {
                free(pTemp2->pMTX);
            }
            if(pTemp2->pRootDNS) {
                free(pTemp2->pRootDNS);
            }
            if(pTemp2->pCRL) {
                Assert(pTemp2->pCRL->CR.pNC);
                Assert(pTemp2->pCRL->CR.pNCBlock);
                Assert(pTemp2->pCRL->CR.pObj);
                FreeCrossRefListEntry(&pTemp2->pCRL);
            }
        }

        if (pTHS->fCatalogCacheTouched) {
            // free catalog_updates data
            CatalogUpdatesFree(&pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates);
            CatalogUpdatesFree(&pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates);
        }
    }
    else if (pTHS->JetCache.transLevel > 0) {
        // Committing, to non-zero level.  Propagate the objCaching info to the
        // outer transaction.

        Assert(pTHS->JetCache.dataPtr->pOuter);
        if(pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fRecalcMapiHierarchy
                = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fSignalSCache = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fNotifyNetLogon = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fSignalGcPromotion = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.pData) {
            if(!pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData) {
                pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
            }
            else {
                // Tack onto the end of outer.
                pTemp = pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pTHS->JetCache.dataPtr->objCachingInfo.pData;

            }
        }

        if (pTHS->fCatalogCacheTouched) {
            // merge catalog updates to the outer transaction
            CatalogUpdatesMerge(
                &pTHS->JetCache.dataPtr->pOuter->objCachingInfo.masterNCUpdates,
                &pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates
                );
            CatalogUpdatesMerge(
                &pTHS->JetCache.dataPtr->pOuter->objCachingInfo.replicaNCUpdates,
                &pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates
                );
        }
    }
    else {
        // OK, we're committing to transaction level 0.  Give the people who
        // care about this data a chance to do something with it, then delete
        // the data.

        if(pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy &&
           DsaIsRunning() &&
           gfDoingABRef) {
            if(0==WaitForSingleObject(hevHierRecalc_OKToInserInTaskQueue, 0)) {
                ResetEvent(hevHierRecalc_OKToInserInTaskQueue);
                InsertInTaskQueue(TQ_BuildHierarchyTable,
                                  (void *)((DWORD) HIERARCHY_DO_ONCE),
                                  15);
            }

        }
        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache) {
            SCSignalSchemaUpdateLazy();
            // the schema fsmo cannot be transferred for a few seconds after
            // it has been transfered or after a schema change (excluding
            // replicated or system changes). This gives the schema admin a
            // chance to change the schema before having the fsmo pulled away
            // by a competing schema admin who also wants to make schema
            // changes.
            if (!pTHS->fDRA && !pTHS->fDSA) {
                SCExtendSchemaFsmoLease();
            }
        }
        if(pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon) {
            dsI_NetNotifyDsChange(NlNdncChanged);
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion) {
            InsertInTaskQueueSilent(
                TQ_CheckGCPromotionProgress,
                NULL,
                0,
                TRUE);
        }


        pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;
        while(pTemp) {
            switch(pTemp->type) {
            case OBJCACHE_ADD:
                // Doing an add cache
                Assert(pTemp->pCRL);

                AddCRLToMem(pTemp->pCRL);
                // The AddCRLToMem grabbed the CRL and put it in the in-memory
                // list.  Let go of it here to avoid freeing it.
                pTemp->pCRL = NULL;
                if(pTemp->pMTX) {
                    Assert(pTemp->pRootDNS);
                    // Just recached the Cross-Ref for the root domain,
                    // presumably due to a modification.  In case ATT_DNS_ROOT
                    // was updated...
                    // Update gAnchor.pwszRootDomainDnsName.

                    EnterCriticalSection(&gAnchor.CSUpdate);
                    __try {
                        if ( NULL != gAnchor.pwszRootDomainDnsName ) {
                            DELAYED_FREE( gAnchor.pwszRootDomainDnsName );
                        }

                        gAnchor.pwszRootDomainDnsName = pTemp->pRootDNS;
                        pTemp->pRootDNS = NULL;

                        if (NULL != gAnchor.pmtxDSA) {
                            DELAYED_FREE(gAnchor.pmtxDSA);
                        }

                        gAnchor.pmtxDSA = pTemp->pMTX;
                        pTemp->pMTX = NULL;
                    }
                    __finally {
                        LeaveCriticalSection( &gAnchor.CSUpdate );
                    }
                }

                // If we're doing an add AND the pDN is set, it's because we
                // need to tell LSA about this change.
                if(pTemp->pDN) {
                    // pDN is THAllocOrg'ed
                    SampNotifyLsaOfXrefChange(pTemp->pDN);
                }
                break;

            case OBJCACHE_DEL:
                Assert(pTemp->pDN);
                Assert(!pTemp->pMTX);
                Assert(!pTemp->pCRL);
                Assert(!pTemp->pRootDNS);
                err = DelCRFromMem(pTHS, pTemp->pDN);
                // DelCRFromMem returns a boolean.  Assert success.
                Assert(err);
                break;

            default:
                Assert(!"Post process obj caching invalid type.\n");
                break;
            }
            pTemp2 = pTemp;
            pTemp = pTemp->pNext;
            if(pTemp2->pMTX) {
                free(pTemp2->pMTX);
            }
            if(pTemp2->pRootDNS) {
                free(pTemp2->pRootDNS);
            }

            if(pTemp2->pCRL) {

                Assert(pTemp2->pCRL->CR.pNC);
                Assert(pTemp2->pCRL->CR.pNCBlock);
                Assert(pTemp2->pCRL->CR.pObj);

                free(pTemp2->pCRL->CR.pNC);
                free(pTemp2->pCRL->CR.pNCBlock);
                free(pTemp2->pCRL->CR.pObj);
                free(pTemp2->pCRL);
            }

            // We've modified something in the cross ref cache.
            // Tell the KCC to look around and see if it needs to do anything
            // when it gets its chance to run.
#ifndef DONT_RUN_KCC_AFTER_CHANGING_CROSSREF
            pTHS->fExecuteKccOnCommit = TRUE;
#endif
        } // while
        if (pTHS->JetCache.dataPtr->objCachingInfo.pData != NULL && !DsaIsInstalling()) {
            // we had something changed in CR list
            // schedule a cr cache rebuild to ensure data is valid even if two threads overlapped their updates
            // BUGBUG we just need to fix RebuildRefCache to be safe while the DS's is in a running state.
            //InsertInTaskQueueSilent(TQ_RebuildRefCache, NULL, 0, FALSE);
        }

        if (pTHS->fCatalogCacheTouched) {
            // apply catalog updates
            catalogChanged =
                CatalogUpdatesApply(&pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates, &gAnchor.pMasterNC) ||
                CatalogUpdatesApply(&pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates, &gAnchor.pReplicaNC);

            if (catalogChanged && !DsaIsInstalling()) {
                // schedule a catalog rebuild to ensure data is valid even if two threads overlapped their updates
                InsertInTaskQueueSilent(TQ_RebuildCatalog, NULL, 0, FALSE);
            }
        }

#if defined(DBG)
        if (pTHS->fCatalogCacheTouched || pTHS->JetCache.dataPtr->objCachingInfo.pData) {
            // NC cache was updated or CR cache was updated
            gdwLastGlobalKnowledgeOperationTime = GetTickCount();
        }
#endif
    } // if
    return;
}


int
AddObjCaching(THSTATE *pTHS,
              CLASSCACHE *pClassSch,
              DSNAME *pDN,
              BOOL fAddingDeleted,
              BOOL fIgnoreExisting)
/*++
  Description:
      This routine tracks changes that should be made to global in-memory data
      structures when certain object classes are added.  The actual changes to
      the global in-memory data structures are not done until
      ObjCachingPostProcessTransactionalData().  This way, if the transaction is
      not successfully committed, we don't actually change the data structures.

--*/

{
    UCHAR  syntax;
    DSNAME *pParent;
    ULONG i;
    int err;
    SCHEMAPTR * pSchema = pTHS->CurrSchemaPtr;
    PrefixTableEntry * pNewPrefix = pTHS->NewPrefix;
    CROSS_REF_LIST *pCRL = NULL;
    MTX_ADDR       *pmtxAddress=NULL;
    WCHAR          *pDNSRoot=NULL;
    OBJCACHE_DATA  *pObjData = NULL;

    // Since the only things we check currently are CLASS_CROSS_REF,
    // CLASS_CLASS_SCHEMA, and CLASS_ATTRIBUTE_SCHEMA, and none of these
    // need any processing in the fAddingDeleted case, we can test here.
    // If other cases get added which do require fAddingDeleted processing,
    // then the test will need to be replicated in each case that needs it.

    // CLASS_MS_EXCH_CONFIGURATION_CONTAINER and CLASS_ADDRESS_BOOK_CONTAINER
    // are also tracked.  These can affect the MAPI hierarchy.  The same logic
    // regarding fAddingDeleted applies.

    if (  fAddingDeleted
       && (CLASS_INFRASTRUCTURE_UPDATE != pClassSch->ClassId) ) {
        return(0);
    }

    switch (pClassSch->ClassId) {
    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
    case CLASS_ADDRESS_BOOK_CONTAINER:
        // This may have affected the MAPI hierarchy.  Do a recalc.
        pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy = TRUE;
        break;

    case CLASS_CROSS_REF:
        // Cross-Ref objects can exist anywhere in NT5.
        pObjData = THAllocOrgEx(pTHS, sizeof(OBJCACHE_DATA));
        pObjData->type = OBJCACHE_ADD;

        err = MakeStorableCRL(
                pTHS,
                pTHS->pDB,
                pDN,
                &pCRL,
                fIgnoreExisting);

        if (!err) {
            if (pCRL->CR.DnsName
                && ( NULL != gAnchor.pRootDomainDN )
                && NameMatched( gAnchor.pRootDomainDN, pCRL->CR.pNC ) ) {
                // Just recached the Cross-Ref for the root domain,
                // presumably due to a modification.  In case ATT_DNS_ROOT
                // was updated...

                CHAR *pszServerGuid = NULL;
                RPC_STATUS rpcStatus;
                DWORD cch;
                CHAR *pchDnsName=NULL;
                LONG cb;
                ULONG  dnslen = 0;

                // Need to realloc this to get it to be NULL terminated.
                dnslen = wcslen(pCRL->CR.DnsName) * sizeof(WCHAR);
                if (NULL != (pDNSRoot = malloc(dnslen + sizeof(WCHAR)))) {
                    memcpy(pDNSRoot, pCRL->CR.DnsName, dnslen);
                    pDNSRoot[dnslen/sizeof(WCHAR)] = L'\0';

                    Assert(NULL != gAnchor.pDSADN);
                    Assert(!fNullUuid(&gAnchor.pDSADN->Guid));

                    // OK, create the mtx address. We're going to just construct
                    // it here, rather than call DRA routines.

                    // Stringize the server's GUID.
                    rpcStatus = UuidToStringA(&gAnchor.pDSADN->Guid,
                                              &pszServerGuid);
                } else {
                    rpcStatus = RPC_S_OUT_OF_MEMORY;
                }

                if ( RPC_S_OK == rpcStatus ) {

                    __try {
                        Assert(36 == strlen(pszServerGuid));

                        pchDnsName = (PUCHAR) String8FromUnicodeString(
                                                      FALSE,
                                                      CP_UTF8,
                                                      pDNSRoot,
                                                      dnslen/sizeof(WCHAR),
                                                      &cb,
                                                      NULL);
                        
                        cch = (36 /* guid */ +
                               8 /* "._msdcs." */ +
                               cb +
                               1 /* \0 */);

                        pmtxAddress =  malloc(MTX_TSIZE_FROM_LEN(cch));
                        if(!pmtxAddress) {
                            __leave;
                        }
                        
                        pmtxAddress->mtx_namelen = cch; //includes null-term
                        sprintf(&pmtxAddress->mtx_name[0],
                                "%s._msdcs.%s",
                                pszServerGuid,
                                pchDnsName);
                        THFreeEx(pTHS, pchDnsName);
                    }
                    __finally {
                        RpcStringFreeA(&pszServerGuid);
                    }
                }
                else {
                    // Failed to convert server GUID to string.
                    LogUnhandledError( rpcStatus );
                }
            }

            // Now, build the transactional data structure.
            pObjData->pCRL = pCRL;
            pObjData->pMTX = pmtxAddress;
            pObjData->pRootDNS = pDNSRoot;
            pObjData->pNext = NULL;
            // Tack this onto the end, it's a queue

            if(pTHS->JetCache.dataPtr->objCachingInfo.pData) {
                OBJCACHE_DATA *pTemp =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pObjData;
            }
            else {
                pTHS->JetCache.dataPtr->objCachingInfo.pData = pObjData;
            }
        }
        break;

    case CLASS_CLASS_SCHEMA:
        //
        // Update in memory schema cache
        //

        // PERFHINT: why go to all this name trouble?  We should be positioned on
        // the object we are adding, so (pDB->PDNT == gAnchor.ulDNTDMD) should
        // get us the same thing, shouldn't it?
        pParent = THAllocEx(pTHS, pDN->structLen);
        TrimDSNameBy(pDN, 1, pParent);

        // mkdit.exe manages the schema cache on its own. Don't update.
        if (   !gfRunningAsMkdit
            && (NameMatched(gAnchor.pDMD, pParent) || DsaIsInstalling())) {

            if (pTHS->cNewPrefix > 0) {
                if ( DsaIsInstalling() ) {
                    // Add new prefixes directly to cache during install.
                    for (i=0; i<pTHS->cNewPrefix; i++) {
                        if (!AddPrefixToTable(&pNewPrefix[i],
                                              &(pSchema->PrefixTable.pPrefixEntry),
                                              &(pSchema->PREFIXCOUNT))) {
                            InterlockedIncrement(
                                    &pSchema->PrefixTable.PrefixCount);
                        }
                    }
                }

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            InterlockedIncrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if ( DsaIsInstalling() ) {
                // Let it add to cache directly during install
                AddClassToSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        THFreeEx(pTHS, pParent);
        break;

    case CLASS_ATTRIBUTE_SCHEMA:
        //
        // Update in memory schema cache
        //

        // PERFHINT: why go to all this name trouble?  We should be positioned on
        // the object we are adding, so (pDB->PDNT == gAnchor.ulDNTDMD) should
        // get us the same thing, shouldn't it?
        pParent = THAllocEx(pTHS, pDN->structLen);
        TrimDSNameBy(pDN, 1, pParent);

        // mkdit.exe manages the schema cache on its own. Don't update.
        if (   !gfRunningAsMkdit
            && (NameMatched(gAnchor.pDMD, pParent) || DsaIsInstalling())) {

            // This may be a bogus assert.
            Assert(DsaIsInstalling() || pTHS->pDB->PDNT == gAnchor.ulDNTDMD);

            if (pTHS->cNewPrefix > 0) {
                if ( DsaIsInstalling() ) {
                    // Add new prefixes directly to cache during install.
                    for (i=0; i<pTHS->cNewPrefix; i++) {
                        if (!AddPrefixToTable(&pNewPrefix[i],
                                              &(pSchema->PrefixTable.pPrefixEntry),
                                              &(pSchema->PREFIXCOUNT))) {
                            InterlockedIncrement(
                                &pSchema->PrefixTable.PrefixCount);
                        }
                    }
                }

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            InterlockedIncrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }


            if ( DsaIsInstalling() ) {
                // Let it add to cache directly during install
                AddAttToSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        THFreeEx(pTHS, pParent);
        break;


    case CLASS_INFRASTRUCTURE_UPDATE:
        if ( DsaIsRunning() ) {
            // Too complicated to handle inline
            HandleDNRefUpdateCaching(pTHS);
        }
        break;

    default:
        /* no other kinds of objects are cached */
        ;
    }

    return pTHS->errCode;

}/*AddObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function removes cache references and shema objects from memory.  We
   have no rollback feature associated with this cache.

   NOTE: It is assumed that all database operations that may err,
   have already been performed and we have a sucessful transaction so far.
   If this function completes normally then we are done.  Note that this
   routine may fail, but if it does so it should leave memory structures
   unaltered, or restore them appropriately.

*/

int DelObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  RESOBJ *pRes,
                  BOOL fCleanUp)
{
    BOOL fLastRef;
    int err = 0;
    OBJCACHE_DATA *pObjData;

    switch (pClassSch->ClassId) {

    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
    case CLASS_ADDRESS_BOOK_CONTAINER:
        pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy = TRUE;
        break;

    case CLASS_CROSS_REF:
        pObjData = THAllocOrgEx(pTHS, sizeof(OBJCACHE_DATA));
        err = 0;
        if(fCleanUp && fLastCrRef(pTHS, pRes->pObj)) {
            // This was the last reference to some subref.  Delete it.
            err = DelAutoSubRef(pRes->pObj);
            Assert(!err || pTHS->errCode);
        }
        if(!err) {
            // OK, successful so far.  Add this to the transactional data.
            pObjData->type = OBJCACHE_DEL;
            pObjData->pDN = THAllocOrgEx(pTHS, pRes->pObj->structLen);
            pObjData->pNext = NULL;
            memcpy(pObjData->pDN, pRes->pObj, pRes->pObj->structLen);
            // Tack this onto the end, it's a queue
            if( pTHS->JetCache.dataPtr->objCachingInfo.pData) {
                OBJCACHE_DATA *pTemp =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pObjData;
            }
            else {
                pTHS->JetCache.dataPtr->objCachingInfo.pData = pObjData;
            }
        }

        break;

    case CLASS_CLASS_SCHEMA:
        // Don't update the in memory schema cache if running as mkdit.exe.
        // mkdit.exe manages the schema cache on its own.
        if (!gfRunningAsMkdit && pRes->PDNT == gAnchor.ulDNTDMD) {

            InterlockedDecrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if ( DsaIsInstalling() ) {
                // Allow direct access to scache during install
                DelClassFromSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }

        }
        break;


    case CLASS_ATTRIBUTE_SCHEMA:
        // Don't update the in memory schema cache if running as mkdit.exe.
        // mkdit.exe manages the schema cache on its own.
        if (!gfRunningAsMkdit && pRes->PDNT == gAnchor.ulDNTDMD) {

            InterlockedDecrement(
                &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
                // successful schema change. Up the global that keeps track of
                // no. of schema changes since last reboot.
                IncrementSchChangeCount(pTHS);
            }

            if ( DsaIsInstalling() ) {
                // Allow direct access to scache during install
                DelAttFromSchema();

            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
           }
       }
       break;

    default:
        /* uncached class */
        ;
    }

    return err;

}/*DelObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function modifies cache entries for attibute and class objects.
   For other objects, it just calls DelObjCaching and AddObjCaching

   NOTE: It is assumed that all database operations that may err,
   have already been performed and we have a sucessful transaction so far.
   If this function completes normally then we are done.

*/

int ModObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  ULONG cModAtts,
                  ATTRTYP *pModAtts,
                  RESOBJ *pRes)
{
    ULONG i;
    int err;
    DBPOS *pDB;

    switch (pClassSch->ClassId) {
    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
        // This may have affected the MAPI hierarchy.  Do a recalc.
        for(i=0;i<cModAtts;i++) {
            switch(pModAtts[i]) {
            case ATT_TEMPLATE_ROOTS:
            case ATT_GLOBAL_ADDRESS_LIST:
            case ATT_ADDRESS_BOOK_ROOTS:
                pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy =
                    TRUE;
                break;
            default:
                break;
            }
            return 0;
        }
        break;

    case CLASS_CROSS_REF:
        // The objcaching is via a queue, so pushe the delete first, then the
        //add
        return(DelObjCaching (pTHS, pClassSch, pRes, FALSE) ||
               AddObjCaching (pTHS, pClassSch, pRes->pObj, FALSE, TRUE));
        break;

    case CLASS_CLASS_SCHEMA:
        /* Update in memory class schema if this is a class schema obj under
         * The governing DMD for this DSA.
         */
        if (pRes->PDNT == gAnchor.ulDNTDMD) {

            if (pTHS->cNewPrefix > 0) {
                // there should not be any new prefix created or brought in by
                // replication during install

                Assert(DsaIsRunning());

                // free so that later schema object add/modifies, if any,
                // by the same thread (possible in replication) do not
                // add the prefixes again

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            // Allow direct modification during install
            if ( DsaIsInstalling() ) {
                return ModClassInSchema ();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
       }
       break;

    case CLASS_ATTRIBUTE_SCHEMA:
        /* Update in memory att schema if this is an att schema obj under
         * The governing DMD for this DSA.
         */
        if (pRes->PDNT == gAnchor.ulDNTDMD) {
            if (pTHS->cNewPrefix > 0) {
                // there should not be any new prefix created or brought in by
                // replication during install

                Assert(DsaIsRunning());

                // free so that later schema object add/modifies, if any,
                // by the same thread (possible in replication) do not
                // add the prefixes again

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            // Allow direct modification during install
            if ( DsaIsInstalling() ) {
                return ModAttInSchema ();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        break;

    case CLASS_NTDS_DSA:
        // not transactionally aware.
        if (NameMatched(gAnchor.pDSADN, pRes->pObj)) {
            // modified the NTDS-DSA object for this server
            // update gAnchor with changes
            return ModLocalDsaObj();
        }
        break;

    case CLASS_DMD:
        // not transactionally aware.

        // Schema version may have changed, so write it to registry.
        // Sinc schema container will be modified only very rarely,
        // we write the version no. out registry whenever it is touched
        // (provided it is our schema container)

        if (pRes->DNT == gAnchor.ulDNTDMD) {

            // pTHStls->pDB is already positioned on the object

            err = 0;
            pDB = pTHS->pDB;

            Assert(pDB);

            err = WriteSchemaVersionToReg(pDB);

            if (err) {
                LogUnhandledError(err);
                DPRINT1(0,"WriteSchemaVersionToReg(); %d\n", err);
            }

        }
        break;

    default:
        break;
    }

    return 0;

}/*ModObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Reset gAnchor.fAmVirtualGC based on the domain count in the entperprise.
   If there is only one domain, then we're virtually a GC.  Some components,
   eg: SAM, leverage this notion.
*/

VOID
ResetVirtualGcStatus()
{
    // *** Caller is responsible for acquiring gAnchor.CSUpdate. ***

    unsigned        cDomains = 0;
    CROSS_REF_LIST  *pCRL = gAnchor.pCRL;

    while ( pCRL ) {

        if ( pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN ) {
            ++cDomains;
        }

        pCRL = pCRL->pNextCR;
    }

    gAnchor.uDomainsInForest = cDomains;

    if ( gAnchor.fAmGC || (cDomains <= 1)) {
        gAnchor.fAmVirtualGC = TRUE;
    }
    else {
        gAnchor.fAmVirtualGC = FALSE;
    }
    return;
}

DWORD
CRAlloc(
    OUT VOID **ppMem,
    IN DWORD nBytes
    )
/*++

Routine Description:

    malloc nBytes of memory. Free with free

Arguments:

    pMem - return address of malloced memory
    nBytes - bytes to malloc

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - malloc failed; *pMem set to NULL
    ERROR_SUCCESS - malloc succeeded; *pMem set to allocated memory

--*/
{
    if (NULL == (*ppMem = malloc(nBytes))) {
        MemoryPanic(nBytes);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    return ERROR_SUCCESS;
}


/*++
  Description:
    Make a malloced data structure holding a Cross Reference List.  This
    function may be called from a transaction or at initialization time.

  INPUT:
    pTHS    - thread state
    pDB     - may not be pTHS->pDB
    pObj    - OPTIONAL DN of cross ref
    ppCRL   - if no error, address of malloc'ed cross ref
              if error, set to NULL
    fIgnoreExisting - Ignore existing cross ref

--*/

ULONG
MakeStorableCRL(THSTATE *pTHS,
                DBPOS *pDB,
                DSNAME *pObj,
                CROSS_REF_LIST **ppCRL,
                BOOL fIgnoreExisting)
{
    DWORD           i, nVal, nAtts, err, cOut = 0;
    ATTR            *pAttr = NULL;
    CROSS_REF_LIST  *pCRL = NULL;
    ATTRBLOCK       *pNCBlock = NULL;
    ATTRVAL         *pAVal;
    CROSS_REF       *pCRexisting;

    ATTRTYP aAttids[] = {
        ATT_NC_NAME,
        ATT_OBJ_DIST_NAME,
        ATT_SYSTEM_FLAGS,
        ATT_NETBIOS_NAME,
        ATT_DNS_ROOT,
        ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY,
        ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY,
        ATT_MS_DS_SD_REFERENCE_DOMAIN,
        ATT_MS_DS_DNSROOTALIAS,
        ATT_ENABLED
    };
    ATTCACHE *ppAC[sizeof(aAttids) / sizeof (ATTRTYP)];

    // Initialize a new CROSS_REF_LIST entry
    if (err = CRAlloc(&pCRL, sizeof(CROSS_REF_LIST))) {
        goto cleanup;
    }
    memset(pCRL, 0, sizeof(CROSS_REF_LIST));
    pCRL->CR.dwFirstNotifyDelay = ResolveReplNotifyDelay(TRUE, NULL);
    pCRL->CR.dwSubsequentNotifyDelay = ResolveReplNotifyDelay(FALSE, NULL);
    pCRL->CR.bEnabled = TRUE; // defaults to TRUE if not present

    //
    // Read attributes from the cross ref object
    //

    // Don't bother reading the object's DN if the caller passed it in.
    // Skip undefined attributes (TODO: remove when ATT_MS_DS_DNSROOTALIAS
    // exists everywhere)
    for (i = nAtts = 0; i < sizeof(aAttids) / sizeof (ATTRTYP); ++i) {
        if ((pObj == NULL || aAttids[i] != ATT_OBJ_DIST_NAME)
            && (ppAC[nAtts] = SCGetAttById(pTHS, aAttids[i]))) {
            ++nAtts;
        }
    }
    if (err = DBGetMultipleAtts(pDB,
                                nAtts,
                                ppAC,
                                NULL,
                                NULL,
                                &cOut,
                                &pAttr,
                                DBGETMULTIPLEATTS_fEXTERNAL,
                                0)) {
        DPRINT1(0, "MakeStorableCRL: could not read attributes; error %d\n", err);
        goto cleanup;
    }

    // Process the returned attributes
    for(i = 0; i < cOut; ++i) {

        // Ignore attributes w/no values
        if (0 == pAttr[i].AttrVal.valCount || 0 == pAttr[i].AttrVal.pAVal->valLen) {
            continue;
        }

        // Make the code more readable
        pAVal = pAttr[i].AttrVal.pAVal;

        switch(pAttr[i].attrTyp) {

        // NC Name
        case ATT_NC_NAME:
            if (err = CRAlloc(&pCRL->CR.pNC, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pNC, pAVal->pVal, pAVal->valLen);
            break;

        // DN
        case ATT_OBJ_DIST_NAME:
            if (err = CRAlloc(&pCRL->CR.pObj, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pObj, pAVal->pVal, pAVal->valLen);
            break;

        // Ref Domain
        case ATT_MS_DS_SD_REFERENCE_DOMAIN:
            if (err = CRAlloc(&pCRL->CR.pdnSDRefDom, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pdnSDRefDom, pAVal->pVal, pAVal->valLen);
            break;

        // Netbios
        case ATT_NETBIOS_NAME:
            Assert((pAVal->valLen + sizeof(WCHAR)) <= ((DNLEN + 1 ) * sizeof(WCHAR)));
            if (err = CRAlloc(&pCRL->CR.NetbiosName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.NetbiosName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.NetbiosName[pAVal->valLen / sizeof(WCHAR)] = L'\0';
            break;

        // DNS
        case ATT_DNS_ROOT:
            if (err = CRAlloc(&pCRL->CR.DnsName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.DnsName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.DnsName[pAVal->valLen / sizeof(WCHAR)] = L'\0';

            // DnsName (above) is a copy of the first value. A copy is
            // used to avoid confusing the old code that thinks a cross
            // ref has one and only one dns name. Which is true
            // for Active Directory's NC cross refs although it might not
            // be true for the user-created cross refs. At any rate, the
            // code will use DnsName when a DNS name is needed and will use
            // the values stored here when generating a referral.
            if (err = CRAlloc(&pCRL->CR.DnsReferral.pAVal,
                               pAttr[i].AttrVal.valCount * sizeof(ATTRVAL))) {
                goto cleanup;
            }
            for (nVal = 0; nVal < pAttr[i].AttrVal.valCount; ++nVal) {
                // Ignore empty values
                if (0 == pAVal[nVal].valLen) {
                    continue;
                }
                if (err = CRAlloc(&pCRL->CR.DnsReferral.pAVal[nVal].pVal, 
                                   pAVal[nVal].valLen)) {
                    goto cleanup;
                }
                pCRL->CR.DnsReferral.pAVal[nVal].valLen = pAVal[nVal].valLen;
                memcpy(pCRL->CR.DnsReferral.pAVal[nVal].pVal,
                       pAVal[nVal].pVal,
                       pAVal[nVal].valLen);
                ++pCRL->CR.DnsReferral.valCount;
            }
            break;

        // DNS Alias
        case ATT_MS_DS_DNSROOTALIAS:
            if (err = CRAlloc(&pCRL->CR.DnsAliasName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.DnsAliasName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.DnsAliasName[pAVal->valLen / sizeof(WCHAR)] = L'\0';
            break;

        // System Flags
        case ATT_SYSTEM_FLAGS:
            memcpy(&pCRL->CR.flags, pAVal->pVal, sizeof(DWORD));
            break;

        // First delay
        case ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY:
            memcpy(&pCRL->CR.dwFirstNotifyDelay, pAVal->pVal, sizeof(DWORD));
            pCRL->CR.dwFirstNotifyDelay = ResolveReplNotifyDelay(TRUE, &pCRL->CR.dwFirstNotifyDelay);
            break;

        // Subsequent delay
        case ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY:
            memcpy(&pCRL->CR.dwSubsequentNotifyDelay, pAVal->pVal, sizeof(DWORD));
            pCRL->CR.dwSubsequentNotifyDelay = ResolveReplNotifyDelay(FALSE, &pCRL->CR.dwSubsequentNotifyDelay);
            break;

        // Enabled
        case ATT_ENABLED:
            memcpy(&pCRL->CR.bEnabled, pAVal->pVal, sizeof(DWORD));
            break;

        default:
            DPRINT1(0, "MakeStorableCRL: don't understand attribute %x\n", pAttr[i].attrTyp);

        } // switch attrtype

    } // for each attr

    // Use the caller's pObj
    if (pObj && !pCRL->CR.pObj) {
        if (err = CRAlloc(&pCRL->CR.pObj, pObj->structLen)) {
            goto cleanup;
        }
        memcpy(pCRL->CR.pObj, pObj, pObj->structLen);
    }

    // Missing nc name or dn
    if (!pCRL->CR.pNC || !pCRL->CR.pObj) {
        err = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // Convert NC name into block name
    if (err = DSNameToBlockName(pTHS, pCRL->CR.pNC, &pNCBlock, DN2BN_LOWER_CASE)) {
        goto cleanup;
    }
    if (NULL == (pCRL->CR.pNCBlock = MakeBlockNamePermanent(pNCBlock))) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // check for pre-existing cross ref
    if (!(pTHS->fDSA || pTHS->fDRA) && !fIgnoreExisting) {
        COMMARG FakeCommArg;
        InitCommarg(&FakeCommArg);
        FakeCommArg.Svccntl.dontUseCopy = FALSE;
        pCRexisting = FindCrossRef(pNCBlock, &FakeCommArg);
        if ( pCRexisting
            && BlockNamePrefix(pTHS, pNCBlock, pCRexisting->pNCBlock)) {
            Assert(NameMatched(pCRL->CR.pNC, pCRexisting->pNC));
            // The only way this could happen is if a CR is already present
            // for the exact NC we're trying to add a CR for now.  Although
            // the DS handles this, we don't want to encourage people in
            // doing so.  Therefore fail the operation unless it's the DS
            // itself or the replicator who's creating the object, or we
            // have asked to ignore this case since a prior deletion will
            // remove this before adding the new one.
            Assert(!"We should never hit this, as we moved this error condition to be checked in VerifyNcName()");
            SetSvcError(SV_PROBLEM_INVALID_REFERENCE, DIRERR_CROSS_REF_EXISTS);
            err = ERROR_DS_CROSS_REF_EXISTS;
            goto cleanup;
        }
    }

cleanup:
    if (pNCBlock) {
        FreeBlockName(pNCBlock);
    }

    // Free the ATTR array from DBGetMultipleAtts
    DBFreeMultipleAtts(pDB, &cOut, &pAttr);

    // sets pCRL to NULL
    if (err) {
        FreeCrossRefListEntry(&pCRL);
    }

    // Return cross ref list entry
    *ppCRL = pCRL;

    return err;
}


VOID
AddCRLToMem (
        CROSS_REF_LIST *pCRL
        )
/*++
  Description:
      Put an already allocated CROSS_REF_LIST into the global list held on the
      anchor.
--*/
{
    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {

        pCRL->pNextCR = gAnchor.pCRL;
        if (gAnchor.pCRL) {
            gAnchor.pCRL->pPrevCR = pCRL;
        }
        gAnchor.pCRL = pCRL;

        ResetVirtualGcStatus();

    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }
}

BOOL
fLastCrRef (
        THSTATE *pTHS,
        DSNAME *pObj
        )
/*++
  Description:
    Find out if there are more than one references to a given NC in the global
    CR list
--*/
{
    CROSS_REF_LIST *pCRL;
    DWORD count = 0;

    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        for (pCRL= gAnchor.pCRL; (pCRL && count < 2) ; pCRL = pCRL->pNextCR){
            if (NameMatched(pCRL->CR.pObj, pObj)){
                count++;
            }
        }/*for*/
    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    if(count < 2) {
        return TRUE;
    }
    return FALSE;
} /*fLastCrRef*/

BOOL
DelCRFromMem (
        THSTATE *pTHS,
        DSNAME *pObj
        )
/*++
  Description:
    Removes a CR from the global cross ref list, if it exists there, and delay
    frees.

  NOTE:
    If called at transaction level 0 and a malloc fails here WE LEAK THE MEMORY
    THAT WOULD NORMALLY BE DELAY-FREED!  This is because we are being called
    from PostProcessTransactionalData, which is NOT ALLOWED TO FAIL!.

--*/
{
    CROSS_REF_LIST *pCRL;
    CROSS_REF_LIST *pCRLi; // pointer to a CR for finding dead SIDs.
    DWORD_PTR * pointerArray;
    ULONG ptrsToFree;
    ULONG i, nVal;
    ATTRVAL *pAVal;

    DPRINT(2,"DelCRFromMem entered.. delete the CR with name\n");

    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {

        for (pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR){

            if (NameMatched(pCRL->CR.pObj, pObj)){

                // Remove link from double linked chain

                if (pCRL->pNextCR != NULL)
                    pCRL->pNextCR->pPrevCR = pCRL->pPrevCR;

                if (pCRL->pPrevCR != NULL)
                    pCRL->pPrevCR->pNextCR = pCRL->pNextCR;


                // If removing the first CR, update the global pointer to
                // point to the next CR (or NULL if the list is empty)

                if (gAnchor.pCRL == pCRL)
                    gAnchor.pCRL = pCRL->pNextCR;

                break;
            }
        } /*for*/

        if(pCRL){
            // Find all the dead cached SIDs in NDNCs.
            for(pCRLi = gAnchor.pCRL; pCRLi != NULL; pCRLi = pCRLi->pNextCR){
                // We destroy all NDNC's cacheing links to this CR's Sid.
                if(pCRLi->CR.pSDRefDomSid == &pCRL->CR.pNC->Sid){
                    // We shouldn't be here for domains.
                    Assert(!(pCRLi->CR.flags & FLAG_CR_NTDS_DOMAIN));
                    pCRLi->CR.pSDRefDomSid = NULL;
                }
            }
        }

        ResetVirtualGcStatus();

    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    if (!pCRL) {
        /* Huh.  This CR wasn't cached, so we can't very well uncache it.
         * We don't have any work to do, so we'll just return success.
         */
        return TRUE;
    }

    // Free the CR.
    ptrsToFree = 4;
    if ( pCRL->CR.NetbiosName ) {
        ptrsToFree++;
    }
    if ( pCRL->CR.DnsName ) {
        ptrsToFree++;
    }
    if ( pCRL->CR.DnsAliasName ) {
        ptrsToFree++;
    }
    if ( pCRL->CR.pdnSDRefDom) {
        ptrsToFree++;
    }
    if ( pCRL->CR.DnsReferral.valCount) {
        ptrsToFree += pCRL->CR.DnsReferral.valCount + 1;
    }

    pointerArray = (DWORD_PTR *)malloc((ptrsToFree+1) * sizeof(DWORD_PTR));
    if (!pointerArray) {
        /* this is bogus.  We can't even get 20 bytes! */
        if (pTHS->JetCache.transLevel == 0) {
            // We are called from a place that is not allowed to fail.  Just
            // return (and leak).
            return TRUE;
        }
        MemoryPanic((ptrsToFree+1) * sizeof(DWORD_PTR));
        return FALSE;
    }
    pointerArray[0] = ptrsToFree;
    pointerArray[1] = (DWORD_PTR)pCRL->CR.pNC;
    pointerArray[2] = (DWORD_PTR)pCRL->CR.pNCBlock;
    pointerArray[3] = (DWORD_PTR)pCRL->CR.pObj;
    pointerArray[4] = (DWORD_PTR)pCRL;
    i=5;
    if ( pCRL->CR.NetbiosName ) {
        pointerArray[i] = (DWORD_PTR)pCRL->CR.NetbiosName;
        i++;
    }
    if ( pCRL->CR.DnsName ) {
        pointerArray[i] = (DWORD_PTR)pCRL->CR.DnsName;
        i++;
    }
    if ( pCRL->CR.DnsAliasName ) {
        pointerArray[i] = (DWORD_PTR)pCRL->CR.DnsAliasName;
        i++;
    }
    if ( pCRL->CR.pdnSDRefDom ) {
        pointerArray[i] = (DWORD_PTR)pCRL->CR.pdnSDRefDom;
        i++;
    }
    if ( pCRL->CR.DnsReferral.valCount) {
        pAVal = pCRL->CR.DnsReferral.pAVal;
        pointerArray[i] = (DWORD_PTR)pAVal;
        i++;
        for (nVal = 0; nVal < pCRL->CR.DnsReferral.valCount; ++nVal, ++pAVal) {
            pointerArray[i] = (DWORD_PTR)(pAVal->pVal);
            i++;
        }
    }

    DelayedFreeMemoryEx(pointerArray, 3600);

    return TRUE;

}/*DelCRFromMem*/


int AddClassToSchema()
/*++
  Description:
     Add an object class to the in memory class schema cache.  Not all
     attributes of the class schema are needed for the directory.  We only
     cache the ATT_GOVERNS_ID, ATT_RDN_ATT_ID, ATT_SUB_CLASS_OF, ATT_MUST_CONTAIN
     and ATT_MAY_CONTAIN.

     All Temp memory is allocated from transaction memory space.  This is
     automatically freed at the end of the transaction.

  Returns:
     0 on success
     Error otherwise
*/
{
   CLASSCACHE *pCC, *tempCC;
   int rtn;
   THSTATE *pTHS = pTHStls;
   BOOL tempDITval;

   DPRINT(2,"AddClassToSchema entered\n");

   if (rtn = SCBuildCCEntry(NULL, &pCC)) {
      return rtn;
   }

   // Check if class is already in cache
   if (tempCC = SCGetClassById(pTHS, pCC->ClassId)) {
      // class is already in cache
      // Decrement ClsCount since it was incremented in AddObjCaching
      // The object already in cache has already increased the count
      // when it was loaded
      InterlockedDecrement(
                  &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));
      return rtn;
   }

   /* Call function to add the new class to the cache*/
   /* Set pTHS->UpdateDITStructure to TRUE to indicate that it
      is not a validation cache load, so that the classcache
      will not be added to the hashed-by-schemaGuid table, which
      is added only during validation cache load during schema update
    */

   tempDITval = pTHS->UpdateDITStructure;

   __try {
      pTHS->UpdateDITStructure = TRUE;

      if ((rtn = SCResizeClsHash(pTHS, 1))
          || (rtn = SCAddClassSchema(pTHS, pCC))) {

         DPRINT1(2,"Couldn't add class to memory cache rtn <%u>\n",rtn);
         LogEvent(DS_EVENT_CAT_SCHEMA,
           DS_EVENT_SEV_MINIMAL,
           DIRLOG_CANT_CACHE_CLASS,
           NULL,
           NULL,
           NULL);

         rtn = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_CACHE_CLASS,rtn);
      }
   }
   __finally {
      pTHS->UpdateDITStructure = tempDITval;
   }

   return rtn;

}/*AddClassToSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Del an object class from the  memory class schema cache.  */


int
DelClassFromSchema (
        )
{
    THSTATE *pTHS = pTHStls;
    ULONG len;
    int    rtn;
    SYNTAX_OBJECT_ID  ClassID;
    SYNTAX_OBJECT_ID *pClassID=&ClassID;
    DPRINT(2,"DelClassToSchema entered\n");

    /* Get the class that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_GOVERNS_ID,
                         DBGETATTVAL_fCONSTANT,
                         sizeof(ClassID),
                         &len,
                         (UCHAR **) &pClassID)){
        DPRINT(2,"Couldn't retrieve the objects class\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_GOVERNSID_MISSING,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_GOVERNSID_MISSING,rtn);
    }

    /* Call function to remove the class from the cache*/


    if (rtn = SCDelClassSchema (ClassID)){

        DPRINT1(2,"Couldn't del class from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_CLASS_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_REMOVE_CLASS_CACHE, rtn);
    }

    return 0;

}/*DelClassFromSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Modify a class definition in the schema memory cache. */

int
ModClassInSchema (
        )
{
    THSTATE *pTHS=pTHStls;
    ULONG len;
    SYNTAX_OBJECT_ID  ClassID;
    SYNTAX_OBJECT_ID *pClassID=&ClassID;
    int rtn;

    /* Get the CLASS ID that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_GOVERNS_ID,
                         DBGETATTVAL_fCONSTANT, sizeof(ClassID), &len,
                         (UCHAR **)&pClassID)){
        DPRINT(2,"Couldn't retrieve the schema's class id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to modify the Class schema in the cache*/

    if (rtn = SCModClassSchema (pTHS, ClassID)){

        DPRINT1(2,"Couldn't del Attribute from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_REMOVE_ATT_CACHE,
                             rtn);
    }
    return 0;

}/*ModClassInSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add an Attribute schema to the in memory att schema cache.  Not all
   propertioes of the att schema are needed for the directory.  We only
   cache the ATT_ATTRIBUTE_ID, ATT_ATTRIBUTE_SYNTAX, ATT_IS_SINGLE_VALUED
   ,ATT_RANGELOWER,and ATT_RANGE_UPPER.
*/

int AddAttToSchema()
{
   ATTCACHE *pAC, *tempAC;
   int rtn, err=0;
   THSTATE *pTHS = pTHStls;
   BOOL tempDITval;

   DPRINT(2,"AddAttToSchema entered\n");

   if (rtn = SCBuildACEntry(NULL, &pAC)) {
       return rtn;
   }

   // Check if attribute is already in cache
   if (tempAC = SCGetAttById(pTHS, pAC->id)) {

      // Attribute with same id already in cache. However, this
      // may not be the same attribute, as in the source machine,
      // the old attribute may have been deleted and a new attribute
      // added again that uses the same OID. So we need to compare this
      // two attributes and see if they are the same. If they are the same,
      // we do nothing, else, we delete the old attribute from the cache
      // and add the new one.
      // For now, we just compare the syntax

      // Decrement AttCount since it was incremented in AddObjCaching
      // The object already in cache has already increased the count
      // when it was loaded. We will either leave it the same or delete it
      // and add a new cache entry. Either way th no. of entries remain
      // the same
      InterlockedDecrement(
                  &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

      if (pAC->syntax == tempAC->syntax) {

          // The syntaxes are the same.
          // Since this is called only during install time,
          // the attribute also has a column (either it is
          // part of the boot dit, in which case the initial
          // LoadSchemaInfo created the col, or it is a new
          // replicated in attribute, in which case the column is
          // created when it is added to the cache below)

          return rtn;
      }

      // The syntaxes are not the same. We will treat this as a new
      // attribute and create a new col for it further down in this function.
      // But before that, we want to delete the old column and cache entry

      err = DBDeleteCol(tempAC->id, tempAC->syntax);
      if (err ==  JET_errSuccess) {
          LogEvent(DS_EVENT_CAT_SCHEMA,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_SCHEMA_DELETED_COLUMN,
                   szInsertUL(tempAC->jColid), szInsertUL(tempAC->id), szInsertUL(tempAC->syntax));
      }
      else {
          LogEvent(DS_EVENT_CAT_SCHEMA,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                   szInsertUL(tempAC->jColid), szInsertUL(tempAC->id), szInsertUL(err));
       }

      SCDelAttSchema(pTHS, tempAC->id);

   }

   /* Call function to add the new Attribute schema to the cache*/
   // Create a Jet Column, since this is a new attribute (otherwise
   // it would have been in the cache, since schema objects are added
   // to the cache immediately during install, and this function is
   // called only during install)

   tempDITval = pTHS->UpdateDITStructure;

   __try {
      pTHS->UpdateDITStructure = TRUE;

      if ((rtn = SCResizeAttHash(pTHS, 1))
          || (rtn = SCAddAttSchema(pTHS, pAC, TRUE, FALSE))) {
         DPRINT1(2,"Couldn't add Attribute to memory cache rtn <%u>\n",rtn);
         LogEvent(DS_EVENT_CAT_SCHEMA,
           DS_EVENT_SEV_MINIMAL,
           DIRLOG_CANT_CACHE_ATT,
           NULL,
           NULL,
           NULL);

         rtn = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_CACHE_ATT, rtn);
      }
   }
   __finally {
      pTHS->UpdateDITStructure = tempDITval;
   }

   if (rtn) {
       return rtn;
   }

   // Make sure that the right attribute is in the cache
   if (!(tempAC = SCGetAttById(pTHS, pAC->id))) {
     DPRINT1(0,"Attribute %s not in cache \n", pAC->name);
   }
   else {
     // the one in cache should be the same one as the one built from the dit
     Assert(tempAC==pAC);
   }

   return 0;

}/*AddAttToSchema*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Remove an attribute definition from the schema memory cache. */

int
DelAttFromSchema (
        )
{
    THSTATE *pTHS=pTHStls;
    UCHAR  syntax;
    ULONG len;
    SYNTAX_OBJECT_ID AttID;
    SYNTAX_OBJECT_ID *pAttID=&AttID;
    int rtn;

    DPRINT(2,"DelAttFromSchema entered\n");

    /* Get the ATT ID that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_ATTRIBUTE_ID,
                   DBGETATTVAL_fCONSTANT, sizeof(AttID), &len,
                   (UCHAR **)&pAttID)){
        DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to del the Attribute schema from the cache*/

    if (rtn = SCDelAttSchema (pTHS, AttID)){

        DPRINT1(2,"Couldn't del Attribute from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_REMOVE_ATT_CACHE,rtn);
    }
    return 0;

}/*DelAttFromSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Modify an attribute definition in the schema memory cache. */

int
ModAttInSchema (
        )
{
    ULONG len;
    SYNTAX_OBJECT_ID AttID;
    SYNTAX_OBJECT_ID *pAttID=&AttID;
    int rtn;
    THSTATE *pTHS=pTHStls;

    // Get the ATT ID that this schema record governs
    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_ATTRIBUTE_ID,
                         DBGETATTVAL_fCONSTANT, sizeof(AttID),
                         &len,
                         (UCHAR **)&pAttID)) {

        DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to update the cache from the database */

    if (rtn = SCModAttSchema (pTHS, AttID)){

        DPRINT1(2,"Couldn't update Attribute in memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_REMOVE_ATT_CACHE,
                             rtn);
    }
    return 0;

}/*ModAttInSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Update gAnchor with modifications made to the NTDS-DSA object
   corresponding to this DSA.
*/

int
ModLocalDsaObj( void )
{
    int iErr;

    iErr = UpdateNonGCAnchorFromDsaOptions( FALSE /* not startup */);

    if (!iErr) {
        iErr = UpdateGCAnchorFromDsaOptionsDelayed( FALSE /* not startup */);
    }

    if ( iErr )
    {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, iErr);
    }
    else
    {
        return 0;
    }
}/*ModLocalDsaObj*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Remove a set of attribute values from a specific attribute. */


int
RemAttVals(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal,
    BOOL fPermissive
    )
{
    ATTRVAL *pAVal;
    ULONG vCount;
    DWORD err;

    // delete values for this attribute.

    pAVal = pAttrVal->pAVal;

    for(vCount = 0; vCount < pAttrVal->valCount; vCount++){

        if (err = DBRemAttVal_AC(pTHS->pDB,
                                 pAC,
                                 pAVal->valLen,
                                 pAVal->pVal)) {

            // Continue processing if the attribute error was sucessful
            if (!fPermissive ||
                err != DB_ERR_VALUE_DOESNT_EXIST) {
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, pAVal,
                               DIRERR_CANT_REM_MISSING_ATT_VAL);
            }
        }

        pAVal++;

    }/*for*/

    return pTHS->errCode;

}/*RemAttVals*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the first value of an attribute that is known to exist.  It is an
   error if it doesn't exist.
*/

int
GetExistingAtt(DBPOS *pDB,
               ATTRTYP type,
               void *pOutBuf,
               ULONG buffSize)
{
   UCHAR  syntax;
   ULONG len;
   UCHAR *pVal;
   DWORD rtn;

   DPRINT1(2,"GetExistingAtt entered. get att type <%lu>\n",type);

   if(rtn = DBGetSingleValue(pDB, type, pOutBuf, buffSize, NULL)) {
       DPRINT(2,"Couldn't Get att assume directory  error\n");
       LogEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_MISSING_EXPECTED_ATT,
                szInsertUL(type),
                szInsertSz(GetExtDN(pDB->pTHS, pDB)),
                NULL);

       return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_MISSING_EXPECTED_ATT,
                            rtn);
   }

   return 0;

}/*GetExistingAtt*/

int __cdecl
CompareAttrtyp(
        const void * pv1,
        const void * pv2
        )
/*
 * Cheap function needed by qsort & bsearch
 */
{
    // Using *pv1 - *pv2 only works when all values for *pv1 and *pv2
    // are all positive or all negative. Eg, try qsorting the array
    // (0x70000000, 0x70000001, 0xe0000000, 5) and bsearching
    // for 5.
    return ((*(ATTRTYP *)pv1 > *(ATTRTYP *)pv2) ? 1
            : (*(ATTRTYP *)pv1 < *(ATTRTYP *)pv2) ? -1
            : 0);
}

/*-------------------------------------------------------------------------*/
BOOL IsMember(ATTRTYP aType, int arrayCount, ATTRTYP *pAttArray){

   int count;

   if (arrayCount < 6) {
       /* Too few entries for bsearch to be worth it */
       for (count = 0 ; count < arrayCount; count++, pAttArray++){
           if (aType == *pAttArray)
             return TRUE;
       }
   }
   else {
       if (bsearch(&aType,
                   pAttArray,
                   arrayCount,
                   sizeof(ATTRTYP),
                   CompareAttrtyp)) {
           return TRUE;
       }
   }
   return FALSE;
}/*IsMember*/

BOOL IsAuxMember (CLASSSTATEINFO  *pClassInfo, ATTRTYP aType, BOOL fcheckMust, BOOL fcheckMay )
{
    DWORD count;
    CLASSCACHE *pCC;

    if (!pClassInfo->cNewAuxClasses) {
        return FALSE;
    }

    for (count=0; count < pClassInfo->cNewAuxClasses; count++) {

        pCC = pClassInfo->pNewAuxClassesCC[count];

        if ((fcheckMust && IsMember (aType, pCC->MustCount, pCC->pMustAtts)) ||
            (fcheckMay && IsMember (aType, pCC->MayCount, pCC->pMayAtts)) ) {
                return TRUE;
        }
    }

    return FALSE;
}


/*++ IsAccessGrantedByObjectTypeList

Routine Description:

    Checks for the specified access on the specified type list using the
    specified Security Descriptor.  A return of 0 means that the pResults
    have been filled in with access info.  Non-zero is an error code associated
    with not being able to check the access (not that access was checked and
    denied, but that access was't checked).
--*/

DWORD
IsAccessGrantedByObjectTypeList (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ACCESS_MASK ulAccessMask,
        POBJECT_TYPE_LIST pObjList,
        DWORD cObjList,
        DWORD *pResults,
        DWORD flags
        )
{
    DWORD  error, i;
    ULONG  ulLen;
    THSTATE *pTHS=pTHStls;

    Assert(pObjList);
    Assert(cObjList);
    Assert(pResults);

    // Assume full access
    for(i=0;i<cObjList;i++)
        pResults[i]=0;

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return 0;
    }

    if(!pNTSD || !pDN || !ulAccessMask) {
        // We are missing some parameters.
        return ERROR_DS_SECURITY_CHECKING_ERROR;
    }

    // Check access in this Security descriptor. If an error occurs during
    // the process of checking permission access is denied.
    if(error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDN,                        // DSNAME of the object
            ulAccessMask,               // access mask
            pObjList,                   // Object Type List
            cObjList,                   // Number of objects in list
            NULL,
            pResults,                   // access status array
            flags,
            NULL                        // authz client context (grab from THSTATE)
            )) {
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error, ulAccessMask);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 NULL,
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }

    // Permission checking was successful.  The attcache array has nulls for
    // those attributes we don't have rights to.
    return 0;

} /* IsAccessGrantedByObjectTypeList*/

BOOL
IsAccessGrantedParent (
        ACCESS_MASK ulAccessMask,
        CLASSCACHE *pInCC,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the parent of the current object in the directory,
    not touching database positioning or state.

Parameters
    ulAccessMask - right requested.
    pInCC - a classcache to use instead of the classcache of the
            parent. Optional.
    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    THSTATE *pTHS = pTHStls;
    CSACA_RESULT   retval;
    ULONG  ulLen;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    CLASSCACHE *pCC=NULL;
    PDSNAME pDN = NULL;
    DWORD   err;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return TRUE;
    }

    // Find the security descriptor attribute, classcache and dn of the parent
    if(err = DBGetParentSecurityInfo(pTHS->pDB, &ulLen, &pNTSD, &pCC, &pDN)) {
        // Didn't get the info we need. We assume the object is therefore locked
        // down, since we can't check the security.
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_RETRIEVE_SD, err);
        }
        return FALSE;
    }

    if(pInCC) {
        // The caller provided a classcache pointer to use instead of the
        // classcache of the parent.a
        pCC = pInCC;
    }
    else if(!pCC) {
        // Failed to get the class cache pointer.
        LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);
        if(fSetError) {
            SetSvcError(SV_PROBLEM_BUSY, DIRERR_OBJECT_CLASS_REQUIRED);
        }
        THFreeEx (pTHS, pNTSD);
        THFreeEx (pTHS, pDN);

        return FALSE;
    }

    // Security descriptor found. Check access.
    retval = CheckSecurityAttCacheArray (
            pTHS,
            ulAccessMask,
            pNTSD,
            pDN,
            0,
            pCC,
            NULL,
            0);

    THFreeEx (pTHS, pNTSD);
    THFreeEx (pTHS, pDN);

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }

        return FALSE;
    }

    return TRUE;
}

BOOL
IsAccessGrantedSimple (
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the current object.  Reads all necessary info from
    the current object.
Parameters

    ulAccessMask - right requested.

    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    THSTATE *pTHS = pTHStls;
    CSACA_RESULT   retval;
    ULONG  ulLen;
    ULONG  classP;
    UCHAR  *pVal;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    CLASSCACHE *pCC = NULL;        //initialized to avoid C4701
    ULONG cbNTSD;
    DSNAME  TempDN;
    DWORD   rtn;

    if (pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    // Look up the Security Descriptor.
    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                         0,0,
                         &cbNTSD, (PUCHAR *)&pNTSD)) {
        // No SD found. We assume the object is therefore locked down
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_RETRIEVE_SD,
                          rtn);
        }
        return FALSE;
    }

    // We need to look up the DSName. Use the shortcut version, since we just
    // need a guid and sid.
    TempDN.structLen = DSNameSizeFromLen(0);
    TempDN.NameLen = 0;
    if(rtn = DBFillGuidAndSid(pTHS->pDB, &TempDN)) {
        LogUnhandledError(DIRERR_MISSING_REQUIRED_ATT);
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_MISSING_REQUIRED_ATT, rtn);
        }
        return FALSE;
    }

    // Look up the classcache.
    pVal = (PUCHAR)&classP;
    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_CLASS,
                         DBGETATTVAL_fINTERNAL | DBGETATTVAL_fCONSTANT,
                         sizeof(classP),
                         &ulLen, &pVal)
       || !(pCC = SCGetClassById(pTHS, classP))) {
        // Failed to get the class cache pointer.
        LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_OBJECT_CLASS_REQUIRED, rtn);
        }
        return FALSE;
    }

    // Security descriptor found. Check access.
    retval = CheckSecurityAttCacheArray (
            pTHS,
            ulAccessMask,
            pNTSD,
            &TempDN,
            0,
            pCC,
            NULL,
            0);

    THFreeEx (pTHS, pNTSD);

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    // Some kind of rights granted.
    return TRUE;
}


BOOL
IsControlAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        GUID ControlGuid,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    control access right (specified as a pointer to a GUID).

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must be
    filled in, the string is optional

    pCC - the ClassCache pointer.

    ControlGuid - guid of the control access being requested.

    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    DWORD            err;
    BOOL             fChecked, fGranted;
    OBJECT_TYPE_LIST ObjList[2];
    DWORD            Results[2];
    THSTATE     *pTHS = pTHStls;

    if(pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    fChecked = FALSE;
    fGranted = FALSE;

    if(!pNTSD || !pDN || !pCC || fNullUuid(&ControlGuid)) {
        if(fSetError) {
            // Didn't succeed in making the isaccess check
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        ERROR_DS_SECURITY_CHECKING_ERROR);
        }
    }
    else {
        // Now, create the list
        ObjList[0].Level = ACCESS_OBJECT_GUID;
        ObjList[0].Sbz = 0;
        ObjList[0].ObjectType = &pCC->propGuid,
        // Every control access guid is considered to be in it's own property
        // set. To achieve this, we treat control access guids as property set
        // guids.
        ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
        ObjList[1].Sbz = 0;
        ObjList[1].ObjectType = &ControlGuid;

        // Make the security check call.
        err = IsAccessGrantedByObjectTypeList(pNTSD,
                                              pDN,
                                              RIGHT_DS_CONTROL_ACCESS,
                                              ObjList,
                                              2,
                                              Results,
                                              0);
        if(!err) {
            fChecked = TRUE;
        }
        else if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        err);
        }
    }


    if(fChecked) {
        // OK, we checked access.  Now, access is granted if either we were
        // granted access on the entire object (i.e. Results[0] is NULL) or we
        // were granted explicit rights on the access guid (i.e. Results[1] is
        // NULL).
        fGranted = (!Results[0] || !Results[1]);

        if(!fGranted && fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        DIRERR_INSUFF_ACCESS_RIGHTS );
        }
    }

    return fGranted;
}

BOOL
IsAccessGrantedAttribute (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    access mask for the specified attributes.

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must
    be filled in, the string is optional

    pCC - the ClassCache pointer.

    ulAccessMask - right requested.

    fSetError - whether or not the call should set an error if it fails.

    cInAtts - the number of attributes in rgpAC

    rgpAC - the array of the attributes beeing checked.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    CSACA_RESULT    retval;

    retval = CheckSecurityAttCacheArray(pTHS,
                           ulAccessMask,
                           pNTSD,
                           pDN,
                           cInAtts,
                           pCC,
                           rgpAC,
                           0
                           );

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if (fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
IsAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    access mask.

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must
    be filled in, the string is optional

    pCC - the ClassCache pointer.

    ulAccessMask - right requested.

    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    CSACA_RESULT    retval;
    THSTATE     *pTHS = pTHStls;

    if(pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    retval = CheckSecurityAttCacheArray (
            pTHS,
            ulAccessMask,
            pNTSD,
            pDN,
            0,
            pCC,
            NULL,
            0);

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if (fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
IsObjVisibleBySecurity(THSTATE *pTHS, BOOL fUseCache)
{
    // Typing hack
#define VIEWCACHE pTHS->ViewSecurityCache
    VIEW_SECURITY_CACHE_ELEMENT *pCacheVals;
    DWORD ThisPDNT = pTHS->pDB->PDNT;
    DWORD ThisDNT  = pTHS->pDB->DNT;
    DWORD i, err, it;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return TRUE;
    }
    if((ThisPDNT == ROOTTAG) || (ThisDNT == ROOTTAG)) {
        // Also allow everyone to list immediately under root.
        return TRUE;
    }


    // First, look through the cache if we have one, create a cache if we don't
    // have one.

    if(fUseCache) {
        if(VIEWCACHE) {
            pCacheVals = VIEWCACHE->CacheVals;
            // The cache is preloaded with nulls, short circuit if we find one
            for(i=0;pCacheVals[i].dnt && i<VIEW_SECURITY_CACHE_SIZE;i++) {
                if(pCacheVals[i].dnt == ThisPDNT) {
                    // A cache hit.
                    switch(pCacheVals[i].State) {
                    case LIST_CONTENTS_ALLOWED:
                        // We are granted rights to read this object.
                        return TRUE;
                        break;

                    case LIST_CONTENTS_DENIED:
                        // We are denied rights to read this object.
                        return FALSE;
                        break;

                    case LIST_CONTENTS_AMBIGUOUS:
                        // We don't know enough just based on the parent, we
                        // have to look at the object itself.
                        // Check for RIGHT_DS_LIST_OBJECT on the object.
                        if(gbDoListObject) {
                            return IsAccessGrantedSimple(RIGHT_DS_LIST_OBJECT,
                                                         FALSE);
                        }
                        else {
                            return FALSE;
                        }
                        break;
                    }
                }
            }
        }
        else {
            // We don't yet have a cache.  Make one if we can.
            VIEWCACHE = THAllocEx(pTHS,sizeof(VIEW_SECURITY_CACHE));
        }
    }

    // If we got here, we missed in the cache.

    if(IsAccessGrantedParent(RIGHT_DS_LIST_CONTENTS,
                             NULL,
                             FALSE)) {
        if(fUseCache) {
            // We can see, so put the parent in the cache with state
            // LIST_CONTENTS_ALLOWED.
            VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
                ThisPDNT;
            VIEWCACHE->CacheVals[VIEWCACHE->index].State =
                LIST_CONTENTS_ALLOWED;
            VIEWCACHE->index =
                (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
        }
        return TRUE;
    }

    // We weren't granted normal access, check for the object view rights.
    if(gbDoListObject &&
       IsAccessGrantedParent(RIGHT_DS_LIST_OBJECT,
                             NULL,
                             FALSE)) {
        if(fUseCache) {
            // We are granted ambiguous rights based on the parent.
            VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
                ThisPDNT;
            VIEWCACHE->CacheVals[VIEWCACHE->index].State =
                LIST_CONTENTS_AMBIGUOUS;
            VIEWCACHE->index =
                (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
        }
        // Check for RIGHT_DS_LIST_OBJECT on the object.
        return IsAccessGrantedSimple(RIGHT_DS_LIST_OBJECT,FALSE);
    }

    // Not granted yet.  There's a special case, that is where the instance type
    // of the object is NC head.  Since it has no parent in the NC, and since
    // security doesn't cross NC boundaries, you can always see these.  Check
    // for that.
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_INSTANCE_TYPE,
                           &it,
                           sizeof(it),
                           NULL);
    if(err) {
        LogUnhandledError(err);
        // Couldn't find the instance type?  Well, that means we're not getting
        // granted rights to this.
    }
    else {
        if(it & IT_NC_HEAD) {
            // Yep, it's an NC head, so grant viewing rights on this thing.
            if(fUseCache) {
                // We can see, so put the parent in the cache with state
                // LIST_CONTENTS_ALLOWED.
                VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
                    ThisPDNT;
                VIEWCACHE->CacheVals[VIEWCACHE->index].State =
                    LIST_CONTENTS_ALLOWED;
                VIEWCACHE->index =
                    (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
            }
            return TRUE;
        }
    }

    // OK, not granted at all, so put the parent in the cache with state
    // LIST_CONTENTS_DENIED.
    if(fUseCache) {
        VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
            ThisPDNT;
        VIEWCACHE->CacheVals[VIEWCACHE->index].State =
            LIST_CONTENTS_DENIED;
        VIEWCACHE->index =
            (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
    }

    return FALSE;
#undef VIEWCACHE
}

DWORD
FindFirstObjVisibleBySecurity(
    THSTATE       *pTHS,
    ULONG          ulDNT,
    DSNAME       **ppParent
    )
/*++

Routine Description

    Given the DNT of an existing object, search for the first object in 
    the hierarchy that is visible by this client.
    
Parameters

    pTHS - a valid thread state.
    ulDNT  - the DNT of an object that exists on this server.
    ppParent - where to put the DSNAME of an object visible by the client.
    
Return Values

    0
            
--*/
{
    DBPOS  *pDB = pTHS->pDB;
    ULONG            cbActual;
    DWORD            err;

    // Start at the object provided.
    err = DBFindDNT(pDB, ulDNT);
    if (err) {
        Assert(!err || !"FindFirstObjVisibleBySecurity: couldn't find first object");
        pDB->DNT = ROOTTAG;
    }

    // And move up the hierarchy until we reach an object that is visible to
    // this client.
    while (pDB->DNT != ROOTTAG && (!DBCheckObj(pDB) || !IsObjVisibleBySecurity(pTHS, TRUE))) {
        err = DBFindDNT(pDB, pDB->PDNT);
        if (err) {
            //
            // This shouldn't happen so bail if it does.
            //
            pDB->DNT = ROOTTAG;
        }
    }

    if (pDB->DNT != ROOTTAG) {
        // OK, we're on an object, go ahead and pull its name.
        DBGetAttVal(pDB, 1,  ATT_OBJ_DIST_NAME, 0, 0, &cbActual, (PCHAR *)ppParent);
    } else {
        *ppParent = NULL;
    }

    return 0;

}

DWORD
CheckObjDisclosure(
    THSTATE       *pTHS,
    RESOBJ        *pResObj,
    BOOL          fCheckForSecErr
    )
/*++

Routine Description

    If there is current security error, check whether the client
    is allowed to know the existence of the base of the operation
    and set no such object if not.
    
Parameters

    pTHS - a valid thread state.
    pResObj - The base of the op to be checked.
    fCheckForSecErr - If this is true then CheckObjDisclosure will only
                      perform the disclosure check if a security error
                      has already been set.
        
Return Values

    returns the current threadstate error code if the object is visible to 
    the client, otherwise returns 2 for nameError.
        
--*/
{
    DWORD    err;
    PDSNAME  pParent;

    if ((!fCheckForSecErr) || (securityError == pTHS->errCode)) {
        err = DBFindDNT(pTHS->pDB, pResObj->DNT);

        if (!IsObjVisibleBySecurity(pTHS, FALSE)) {
            THClearErrors();
            FindFirstObjVisibleBySecurity(pTHS,
                                          pResObj->PDNT,
                                          &pParent);

            SetNamError(NA_PROBLEM_NO_OBJECT, pParent, DIRERR_OBJ_NOT_FOUND);
            THFreeEx(pTHS, pParent);
        }
    }
    return pTHS->errCode;
}

DWORD
InstantiatedParentCheck(
    THSTATE *          pTHS,
    ADDCROSSREFINFO *  pChildCRInfo,
    CROSS_REF *        pParentCR,
    ULONG              bImmediateChild
    )
/*++

Routine Description:

    This routine verifies the pChildCRInfo to check whether the
    parent is instatiated.

Arguments:

    pChildCRInfo - This info from the PreTransVerifyNcName() func.
    pParentCR - This is the superior crossRef, it's actually, only
        a true parent CR to the Child CR being added if
        bImmediateChild is true.
    bImmediateChild - Whether the parent CR is an immediate parent
        or just a superior CR.

Return value:

    DIRERR
    - also sets thstate err

--*/
{
    Assert(pParentCR);
    Assert(pChildCRInfo);
    Assert(pTHS);

    //
    // Check whether the immediate parent object is instantiated.
    //
    if(pChildCRInfo->ulDsCrackParent == ERROR_SUCCESS &&
       pChildCRInfo->ulParentCheck == ERROR_SUCCESS){

        if(fNullUuid(&pChildCRInfo->ParentGuid)){

            // This means that the instantiated parent check never
            // got run in PreTransVerifyNcName().  There are several
            // valid reasons, there was no CR (at that time), or the
            // CR had no NTDS_NC flag.
            if(pParentCR->flags & FLAG_CR_NTDS_NC){
                LooseAssert(!"We must've just added or changed this CR.",
                            GlobalKnowledgeCommitDelay);
                SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_NC_IN_CACHE);
                return(pTHS->errCode);
            }

            // At any rate, irrelevant if there was a slight global
            // memory cache timing problem, or were here because the
            // parent CR has no FLAG_CR_NTDS_NC, we can't claim that
            // the Parent Obj is instantiated.
            SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
            return(pTHS->errCode);

        } else {

            if(bImmediateChild &&
               !fNullUuid(&pParentCR->pNC->Guid)){

                // If both the CR GUID and the Parent obj GUID are
                // non-NULL, and the child NC is an immediate child
                // of the parent NC, then the GUIDs should match.

                if(memcmp(&pParentCR->pNC->Guid,
                          &pChildCRInfo->ParentGuid,
                          sizeof(GUID)) == 0){
                    // This means the GUIDs match, return success.
                    return(ERROR_SUCCESS);
                } else {
                    // The object we returned, was not the CR's NC
                    // object.  Return error.
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    return(pTHS->errCode);
                }
            }

            // We checked that the parent was instatiated.
            return(ERROR_SUCCESS);

        }

    } else {

        // There was an actual failure trying to reach the parent NC,
        // and verify the parent object is insantiated.  NOTE: the
        // parent NC and parent object could be different objects.

        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        return(pTHS->errCode);

    }

    Assert(!"Should never reach this point.");
    SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
    return(pTHS->errCode);
}

DWORD
ChildConflictCheck(
    THSTATE *          pTHS,
    ADDCROSSREFINFO *  pCRInfo
    )
/*++

Routine Description:

    This routine verifies the pChildCRInfo to check whether there
    is not conflicting child object with this data.

Arguments:

    pChildCRInfo - This info from the PreTransVerifyNcName() func.

Return value:

    DIRERR
    - also sets thstate err

--*/
{
    if( pCRInfo->ulDsCrackChild ){
        // This means we couldn't even locate a responsible parent, we must
        // set a couldn't verify nCName attribute.
        SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION,
                      ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2,
                      pCRInfo->ulDsCrackChild);
        return(pTHS->errCode);
    }

    if( !pCRInfo->ulChildCheck ) {
        // If we've gotten here, it means that there is a conflicting child
        // object.
        Assert(pCRInfo->wszChildCheck);
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_OBJ_STRING_NAME_EXISTS);
        return(pTHS->errCode);
    }

    if( pCRInfo->wszChildCheck ) {
        // This would mean that we never tried to check for a conflicting
        // child due to some operations error that occured before we even
        // called the VerifyByCrack routines in PreTransVerifyNcName.  So
        // we must return that we couldn't verify the nCName attribute.
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        return(pTHS->errCode);
   }

    return(ERROR_SUCCESS);
}



int
VerifyNcName(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTRVALBLOCK *pAttrVal,
    ATTCACHE *pAC
    )
{
// Makes subsequent code more readable
#define VNN_OK         Assert(pTHS->errCode == 0); \
                       fNCNameVerified = TRUE; \
                       DPRINT1(1, "Cross Ref nCName Verified OK at DSID-%X\n", DSID(FILENO, __LINE__)); \
                       __leave;
#define VNN_Error      Assert(pTHS->errCode && !fNCNameVerified); \
                       DPRINT1(1, "Cross Ref nCName NOT Verified ... Failure at DSID-%X\n", DSID(FILENO, __LINE__)); \
                       __leave;

    ADDCROSSREFINFO *  pChildCRInfo = hVerifyAtts->pCRInfo;
    DSNAME *           pDN = (DSNAME*)pAttrVal->pAVal->pVal;

    DSNAME *           pDNTmp;
    CROSS_REF *        pParentCR;
    COMMARG            CommArg;  // yes it's fake - we don't want the client's
    DWORD              dwErr;
    BOOL               fNCNameVerified = FALSE;
    DBPOS *            pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);
    ULONG              bImmediateChild = FALSE;
    ULONG              bEnabledParentCR;
    unsigned           rdnlen;
    WCHAR              rdnbuf[MAX_RDN_SIZE];
    ATTRTYP            ChildRDNType;
    ATTRTYP            ParentRDNType;
    DSNAME *           pdnImmedParent = NULL;
    GUID               NcGuid;

    Assert(!pTHS->fDRA);
    Assert(!DsaIsInstalling());
    Assert(pChildCRInfo);
    Assert(pDN);

    // The NC name (a.k.a. ATT_NC_NAME or nCName) is a special attribute,
    // because it almost always needs to point to something we don't
    // have.  In this function like its helper PreTransVerifyNcName(),
    // we'll refer to the nCName attr to be added as the child (or child
    // CR), and the enclosing CR (if any) as the parent henceforward.
    // Though the "parent CR" is not necessarily an immediately enclosing
    // parent, 95% of the time this is the case.
    // Further we'll have a concept of internal vs. external CR.  An
    // internal CR will be a CR for a NC that is part of the Active
    // Directory (AD) naming space.  An external CR, will be a CR for
    // some part of the LDAP name space outside the AD.  Finally, we'll
    // also have the concept of inside vs. outside the AD naming space,
    // this is very closely linked to internal vs. external, but usually
    // refers to if whether the parent CR is an internal or external CR.
    // If the parent CR is an internal CR, then the child we're trying to
    // add is being added inside the AD naming space.  If the parent CR is
    // and external CR, then the child we're trying to add is outside the
    // AD naming space.

    // internal vs. external CR (often external CR is known as a foreign CR)
    //            a CR can be internal by either having Enabled == FALSE or
    //            having FLAG_CR_NTDS_NC set in it's systemFlags.
    // inside vs. outside AD naming space
    //            inside if the containing parent CR is an AD CR, else
    //            outside.
    // child vs. parent CR/NC
    //            The child CR (or nCName) is the nCName attribute that we're
    //            currently trying to add.  The Parent CR is what ever CR
    //            contains the child CR.
    // parent obj vs. parent CR/NC
    //            The parent object, is the actual immediate parent object,
    //            The parent CR/NC is just the enclosing CR/NC for the child.
    //            These two are one and the same if bImmediateChild is TRUE.

    //
    //   parent
    //     |-----child (this is what we're adding)
    //
    // To verify the nCName, we need several pieces of state:
    //
    //    Child DN.                     (pDN)
    //    Child RDNType                 (ChildRDNType)
    //    Child CR enabled attr         (pChildCRInfo->bEnabled)
    //    Child CR systemFlags attr     (pChildCRInfo->ulSysFlags)
    //    Child directly below parent   (bImmediateChild)
    //    Parent Obj instantiated       (bInstantiedParentObj)
    //    Parent RDNType                (ParentRDNType)
    //    Superior CR enabled attr      (bEnabledParentCR)
    //    Superior CR systemFlags       (pParentCR->flags)
    //    Enclosing/Superior Cross-Ref  (pParentCR)
    //
    // NOTE: Deceptively, the "Parent CR" may not actually be a parent, but
    // may be just a superior (great grand parent, etc.)  However, Parent Obj
    // refers to the immediate parent object, not the whatever the parent CR
    // points to.  Of course if bImmediateChild is TRUE, then these are one
    // and the same.  The reason to leave it as Parent, is because in 95% of
    // the cases, this is how you should think of it, so it's reasonable to
    // leave the variable named as parent.

    // The approximate rules we're trying adhere to goes something like this:
    //
    // A) If the child crossRef is external then it doesn't need follow any
    //    naming conventions.
    // B) If the child crossRef (external or internal) is inside the AD naming
    //    space we need to check it for a conflicting child in the DS, and
    //    that the child is directly below and instantiated object.
    // C) If the child crossRef is internal to the AD and a seperate tree,
    //    then we only need to check that all it's RDNType's conform to the
    //    DC= standard.
    // D) If the child crossRef is internal to the AD, and inside the existing
    //    naming space, then we need to ensure that the crossRef is added
    //      a) Immediately below an instantiated parent NC.
    //      b) if the child RDNType is "DC", then the parent must be "DC=".
    //      c) if the child is a domain CR, then the parent must be a domain CR.

    // I think this helps clarity, it makes the intention overly clear.
    //
    // VNN_OK;     =  Assert(pTHS->errCode == 0);
    //                fNCNameVerified = TRUE;
    //                <Print out success, and DSID.>;
    //                __leave;
    //
    // VNN_Error;  =  Assert(pTHS->errCode);
    //                <Print out error, and DSID>;
    //                __leave;
    //

    __try {

        //
        // First, some basic setup checks, before we go any further.
        //

        // We expect to have the pChildCRInfo setup by PreTransVerifyNcName().
        if(!pChildCRInfo){
            Assert(!"Why was pChildCRInfo not supplied!?!");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_Error;
        }

        // This attribute is a single valued attribute.
        if (pAttrVal->valCount != 1) {
            SetAttError(hVerifyAtts->pObj,
                        pAC->id,
                        PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                        NULL,
                        ERROR_DS_SINGLE_VALUE_CONSTRAINT);
            VNN_Error;
        }

        // Perform an otherwise worthless test to make sure that the NCname
        // doesn't match the name of the object being added.  Since the object
        // being added is still mid-addition it's a little flakey to deal with
        // (e.g., it's presently a phantom), and it's easier to screen out
        // this degenerate case now.
        if ( NameMatchedStringNameOnly(hVerifyAtts->pObj, pDN) ) {
            SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                        DIRERR_NAME_REFERENCE_INVALID);
            VNN_Error;
        }

        //
        // Get some Parent CR info.
        //

        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        pParentCR = FindBestCrossRef(pDN, &CommArg);

        if(pParentCR){

            //
            // First a quick degenerate case check.
            //
            if(NameMatchedStringNameOnly(pParentCR->pNC, pDN)){
                // This means that we're trying to add a crossRef for one
                // that already exists, i.e. that the "parent" and "child"
                // CR, are turning out to be one and the same nCName value.
                // This isn't OK.
                SetSvcError(SV_PROBLEM_INVALID_REFERENCE,
                            ERROR_DS_CROSS_REF_EXISTS);
                VNN_Error;
            }

            // 1. bEnabledParentCR
            //
            // We want to know whether the Parent CR is enabled or not
            // so we know whether it's part of the AD naming space.
            //
            dwErr = DBFindDSName(pDBTmp, pParentCR->pObj);
            if (dwErr) {
                // We should have a CR, but can't read it?  Bad
                SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION,
                              ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2,
                              dwErr);
                LooseAssert(!"We found a CR in the ref-cache, but couldn't \
                            get to the object", GlobalKnowledgeCommitDelay);
                VNN_Error;
            }
            if (dwErr = DBGetSingleValue(pDBTmp,
                                         ATT_ENABLED,
                                         &bEnabledParentCR,
                                         sizeof(bEnabledParentCR),
                                         NULL)){
                // By default it's enabled, if the attr is not present.
                Assert(dwErr == DB_ERR_NO_VALUE);
                bEnabledParentCR = TRUE;
            }

            // 2. bImmediateChild
            //
            // Is the Child CR an actual immediate Child of the Parent CR we
            // found.
            //
            pdnImmedParent = THAllocEx(pTHS, pDN->structLen);
            if(TrimDSNameBy(pDN, 1, pdnImmedParent)){
                // If the name isn't root, but still can't be trimmed,
                // then the name passed in must have been junk.  Another,
                // possibility is root, but it can't be root if we found
                // a crossRef above it.
                SetNamError(NA_PROBLEM_BAD_NAME,
                            pDN,
                            DIRERR_BAD_NAME_SYNTAX);
                VNN_Error;
            }
            bImmediateChild = NameMatchedStringNameOnly(pdnImmedParent, pParentCR->pNC);

        }

        //
        // Now verify the nCName attr is legal.
        //

        // Note: The only way to leave this function before this point, has been
        // through an error path.
        //
        // With the first two levels of if/else, we seperate this into 4 cases:
        // if(external child CR){
        //     if(under internal parent CR (this means in AD naming space)){
        //     } else { // not under CR or under external parent CR.
        //     }
        // } else { // internal child CR
        //     if(no parent CR){
        //     } else { // Parent CR enclosing
        //     }
        //
        // NOTE: All these tests are in a certain order, do not change
        // the order unless you know what you are doing.


        if(pChildCRInfo->bEnabled == TRUE &&
           !(pChildCRInfo->ulSysFlags & FLAG_CR_NTDS_NC)){

            // The Simple Case:

            // The Child CR is external, i.e. not an AD crossRef.  In this case,
            // we've only need to check if the CR is grafted on inside the current
            // AD naming space, and if so, make sure it doesn't conflict with an
            // existing child object.

            if(pParentCR &&
               ((pParentCR->flags & FLAG_CR_NTDS_NC) || !bEnabledParentCR)){

                // This external child CR that we're trying to add, is hanging off
                // of the AD naming space somewhere.  The only thing left we need
                // to check is that it isn't conflicting with some child somewhere,
                // and that it is parent is instantiated.

                // We need to ensure that the immediate parent object is
                // insantiated above this CR, so there are no holes.
                if(InstantiatedParentCheck(pTHS, pChildCRInfo,
                                           pParentCR, bImmediateChild)){
                    // InstantiatedParentCheck() sets the thstate error.
                    VNN_Error;
                }

                // Check that there is not conflicting child.
                if(ChildConflictCheck(pTHS, pChildCRInfo) ){
                    // ChildConflictCheck() sets the thstate error.
                    VNN_Error;
                }

                VNN_OK;

            } else {

                // It's not internal to the AD naming space at all.  I.e. this
                // child CR is not internal, nor is the parent CR, or there is
                // no parent CR.

                VNN_OK;

            }

            Assert(!"Should never reach here.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_Error;

        } else {

            // The Complex Case:

            // The Child CR is internal, i.e. it's an AD crossRef.  In this case,
            // we must apply several tests to verify that it's OK.

            if(!pParentCR){

                // There is no parent CR, meaning this "child CR" is not a child
                // at all, it's actually a new tree.  All we have to do is test
                // that the nCName satisfies the DOMAIN_COMPONENT naming
                // restrictions and we're done.

                if( ValidateDomainDnsName(pTHS, pDN) ){
                    // ValidateDomainDnsName sets it's own errors.
                    VNN_Error;
                }

                // New tree domain CR creations should exit here.
                VNN_OK;

            } else {

                // There is a parent CR.  This is also where the most typical
                // CR creations will end up.  This case requires the most
                // verification.

                // To start with we only allow immediate children
                if(!bImmediateChild){
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // The Parent CR must be a NTDS CR.
                if(!(pParentCR->flags & FLAG_CR_NTDS_NC)){
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // If child is of type DC, parent must be of type DC.
                if(dwErr = GetRDNInfo(pTHS, pDN, rdnbuf, &rdnlen, &ChildRDNType) ||
                   GetRDNInfo(pTHS, pParentCR->pNC, rdnbuf, &rdnlen, &ParentRDNType) ||
                   (ChildRDNType == ATT_DOMAIN_COMPONENT &&
                    ParentRDNType != ATT_DOMAIN_COMPONENT) ){
                    // This combined with the ValidateDomainDnsName() function
                    // for new trees, will enforce DC= only naming syntaxes for
                    // all new NCs within the AD.
                    // NOTE: This constraint was not enforced in the previous
                    // version of VerifyNcName().
                    if(dwErr){
                        // Something is wrong with the child CR's last RDN.
                        SetUpdError(UP_PROBLEM_NAME_VIOLATION, dwErr);
                    } else {
                        // We've got a DC component mismatch.
                        SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                    DIRERR_NAME_REFERENCE_INVALID);
                    }

                    VNN_Error;
                }

                // We must have the parent instantiated, to create a child
                // CR.
                if(InstantiatedParentCheck(pTHS, pChildCRInfo,
                                           pParentCR, bImmediateChild)){
                    // We think you should not be allowed to create an AD crossRef
                    // enabled or disabled if the parent NC is not instantiated.
                    // NOTE: This constraint was not enforced in the previous
                    // version of VerifyNcName(), though it was supposed to be.
                    // InstatiatedParentCheck() sets the thstate error.
                    VNN_Error;
                }

                // We need to check that there are no conflicting children.
                if(ChildConflictCheck(pTHS, pChildCRInfo) ){
                    // ChildConflictCheck() sets the thstate error.
                    VNN_Error;
                }

                // If we're adding a Domain CR, make sure the parent is also
                // a domain.
                if( pChildCRInfo->ulSysFlags & FLAG_CR_NTDS_DOMAIN &&
                    !(pParentCR->flags & FLAG_CR_NTDS_DOMAIN) ){
                    // It'd be better to have this exact error, but for domains.
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // Children domain CR creations should exit here.
                VNN_OK;

            }

            Assert(!"Should never reach here either.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_OK;

        }

    } __finally {

        // Either we verified the nCName, or we set an error, because the
        // new nCName broke the rules we require for a valid nCName.
        Assert(fNCNameVerified || pTHS->errCode);

        if ( !fNCNameVerified
            && (pTHS->errCode == 0)) {
            Assert(!"We should never be here, but we've covered our butts.");
            SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        }

        // We said in PreTransVerifyNcName() that we'd free this here.
        if(pChildCRInfo){
            if(pChildCRInfo->wszChildCheck) { THFreeEx(pTHS, pChildCRInfo->wszChildCheck); }
            THFreeEx(pTHS, pChildCRInfo);
        }

    }

    // This is set if we hit an "OK;"
    if(fNCNameVerified){

        // We need to set the GUID on this nCName attribute.

        if(pParentCR &&
           ((pParentCR->flags & FLAG_CR_NTDS_NC) || !bEnabledParentCR)){

            // This is one of those cases where it's inside the existing AD
            // naming space, we need to give this nCName attribute a GUID,
            // like we used to.

            Assert(fNullUuid(&pDN->Guid) &&
                   "Should not have a GUID specified, unless by user.");
            DsUuidCreate(&pDN->Guid);

        } else {

            // Else outside the AD naming space, we don't need to give it
            // a GUID, we need to null out the GUID supplied.  We might
            // considering giving this case a GUID too someday, but we'll
            // need to check how Win2k boxes treat a seperate tree CR w/
            // a GUID.  If they use the GUID, we're good, if they create
            // there own, we can't give this a GUID.

            ImproveDSNameAtt(NULL, NONLOCAL_DSNAME, pDN, NULL);
        }
    }

#undef VNN_OK
#undef VNN_Error

    return(pTHS->errCode);
}

int
VerifyRidAvailablePool(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    DWORD err;
    LARGE_INTEGER RidAvailablePool;

    // If it is the RID available pool that is being written then
    // check that the RID available pool is only being rolled forward
    // not rolled back

    Assert(!pTHS->fDRA);
    if (pTHS->fDSA) {
        // No checking for the DS itself
        return 0;
    }

    if ((NULL == pAttrVal) ||
        (1 != pAttrVal->valCount )) {
        //
        // Badly formed input data
        //

        return SetAttError(hVerifyAtts->pObj,
                           pAC->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           ERROR_DS_SINGLE_VALUE_CONSTRAINT);

    }
    else if (sizeof(LARGE_INTEGER) != pAttrVal->pAVal->valLen) {
        return SetAttError(hVerifyAtts->pObj, pAC->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           ERROR_DS_RANGE_CONSTRAINT);
    }

    if (0 == (err = DBGetSingleValue(pTHS->pDB,
                                     ATT_RID_AVAILABLE_POOL,
                                     &RidAvailablePool,
                                     sizeof(RidAvailablePool),
                                     NULL))) {
        LARGE_INTEGER * pNewRidAvailablePool=
          (LARGE_INTEGER *) pAttrVal->pAVal->pVal;

        if ((pNewRidAvailablePool->LowPart < RidAvailablePool.LowPart)
            || (pNewRidAvailablePool->HighPart < RidAvailablePool.HighPart)) {

            //
            // Unsuccessful validation. Fail the call
            //

            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               ERROR_DS_RANGE_CONSTRAINT);
        }

        return 0;
    }
    else {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_DATABASE_ERROR, err);
    }
}

int
VerifyObjectCategory(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG ObjClass;
    int retCode = 0;
    DSNAME *pDN= (DSNAME *) pAttrVal->pAVal->pVal;
    DBPOS *pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);

    // Object-Category must point to an existing class-schema object
    // (Except during install, but we do not come here during
    // install anyway)

    // The Default-Object-Category attribute on a class-schema object
    // can be set in the addarg. During Install, the attribute can
    // be set to an yet non-existent object, since the class that the
    // attribute is pointing to may not have been created yet (depending
    // on the order in which they are added from schema.ini). However,
    // during normal operation, this attribute is allowed to point to
    // only an exisiting object, or the object being added in this
    // transaction

    if (DBFindDSName(pDBTmp, pDN)) {
        // Not an existing object. Check if it is
        // the current object

        if ((pAC->id != ATT_DEFAULT_OBJECT_CATEGORY)
            || !NameMatched(pDN, hVerifyAtts->pObj)) {

            // Either no default-object-category attribute,
            // or the value is not set to the current object either
            // Something is wrong with this DSName.  I don't
            // care what.  Set an attribute error.
            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               DIRERR_NAME_REFERENCE_INVALID);
        }
        // We are here means the current object is added as
        // value for the default-object-category attribute,
        // so it is ok. We don't need to check if this is
        // a class-schema object, since no one else can have
        // default-object-category anyway (and so, if it is
        // on any other type of object, it will be caught later
        // during schema constraint check anyway.
    }
    else {
        // Object exists. Check its object class
        if (DBGetSingleValue(pDBTmp, ATT_OBJECT_CLASS, &ObjClass,
                            sizeof(ObjClass), NULL)
            || (ObjClass != CLASS_CLASS_SCHEMA) ) {
            // either error getting the object class, or it is not
            // a class-schema object
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               DIRERR_OBJECT_CLASS_REQUIRED);
        }
    }

    return 0;
}

int
VerifyServerPrincipalName(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG vCount;
    ATTRVAL *pAVal;

    // Validate syntax of SPN
    Assert(!pTHS->fDRA);
    if (pTHS->fDSA) {
        // No checking for the DS itself
        return 0;
    }

    // Set up index pointer.
    pAVal = pAttrVal->pAVal;

    for (vCount = 0; vCount < pAttrVal->valCount; vCount++) {
        LPWSTR pwstrSpn = THAllocEx( pTHS, pAVal->valLen + sizeof(WCHAR) );
        DWORD status;

        // Create a null terminated string from the attribute value
        memcpy( pwstrSpn, pAVal->pVal, pAVal->valLen );
        pwstrSpn[pAVal->valLen / 2] = L'\0';

        // Validate the SPN using this routine from ntdsapi.dll
        status = DsCrackSpnW(
            pwstrSpn,
            NULL, NULL,
            NULL, NULL,
            NULL, NULL,
            NULL
            );

        THFreeEx( pTHS, pwstrSpn );

        if (status != ERROR_SUCCESS) {
            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               DIRERR_NAME_REFERENCE_INVALID);
        }

        // Next val...
        pAVal++;
    }
    return 0;
}

int
VerifyGenericDsnameAtt(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG vCount;
    ATTRVAL *pAVal;
    BOOL fVerified;
    ULONG retCode = 0;
    CROSS_REF *pRefCR;
    DBPOS *pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);
    CROSS_REF *pObjCR;

    if (VerifyAttsGetObjCR(hVerifyAtts, &pObjCR)) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    // Set up index pointer.
    pAVal = pAttrVal->pAVal;

    // Walk through the values.
    for (vCount = 0; vCount < pAttrVal->valCount; vCount++){
        DSNAME *pDN = DSNameFromAttrVal(pAC, pAVal);

        if (pDN) {
            // Verify that pDN is the name of a real object and improve its
            // GUID/SID.

            // If pDN is a valid name, we impose additional restrictions on
            // which objects can be referenced by which other objects.
            // Specifically, we do not yet have efficient ways to fix up string
            // DNs of objects not held on GCs (i.e., references *to* objects in
            // NDNCs) or to fix up string DNs of objects where no one replica
            // (IM candidate) has only NCs that other replicas of the NC in
            // question are guaranteed to also have (i.e., references *from*
            // objects in NDNCs, since a given NDNC can be hosted by DCs of any
            // domain).
            //
            // Thus we enforce the following rules to ensure the stale phantom
            // cleanup daemon does not need to worry about fixing up references
            // into or out of NDNCs:
            //
            // Objects in NDNCs can reference:
            //      Any object in the same NDNC.
            //      Any object in config/schema.
            //      Any NC root.
            //      (i.e., NOT objects in other NDNCs or domain NCs.)
            //
            // Objects in config/schema/domain NCs can reference:
            //      Any object in any domain NC.
            //      Any object in config/schema.
            //      Any NC root.
            //      (i.e., NOT objects in NDNCs.)
            //
            // As an exception, values of non-replicated linked attributes can
            // reference any object present on the local machine.  (Linked
            // requirement comes from need to be able to efficiently enumerate
            // such references when an NC is removed -- see DBPhysDel.)

            if (DBFindDSName(pDBTmp, pDN)) {
                // Referred-to object is not instantiated in the local database.
                ImproveDSNameAtt(NULL, NONLOCAL_DSNAME, pDN, &fVerified);

                if ( !fVerified ) {
                    // Something is wrong with this DSName.  I don't
                    // care what.  Set an attribute error.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                }

                // The verification cache enforces that the non-local
                // DSNAMEs are not GUID/SID-only.
                Assert(pDN->NameLen);

                pRefCR = FindBestCrossRef(pDN, NULL);

                if (NULL == pRefCR) {
                    // Couldn't find the cross ref normally.  Look in the
                    // transactional view.  Note that we look only for exact
                    // matches -- i.e., we allow adding references to the root
                    // of the NC in the same transaction as the corresponding
                    // crossRef, but not to any interior nodes.  (We could add
                    // such support later if needed, however.)
                    OBJCACHE_DATA *pTemp
                        = pTHS->JetCache.dataPtr->objCachingInfo.pData;

                    while (pTemp) {
                        switch(pTemp->type) {
                        case OBJCACHE_ADD:
                            if (NameMatched(pTemp->pCRL->CR.pNC, pDN)) {
                                Assert(!pRefCR);
                                pRefCR = &pTemp->pCRL->CR;
                            }
                            pTemp = pTemp->pNext;
                            break;
                        case OBJCACHE_DEL:
                            if (pRefCR
                                && NameMatched(pTemp->pDN, pRefCR->pObj)) {
                                pRefCR = NULL;
                            }
                            pTemp = pTemp->pNext;
                            break;
                        default:
                            Assert(!"New OBJCACHE_* type?");
                            pRefCR = NULL;
                            pTemp = NULL;
                        }
                    }
                }

                if (NULL == pRefCR) {
                    // Don't know what NC the referred-to object is in.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                } else if (NameMatched(pRefCR->pNC, pObjCR->pNC)
                           || NameMatched(pRefCR->pNC, gAnchor.pDMD)
                           || NameMatched(pRefCR->pNC, gAnchor.pConfigDN)) {
                    // Referred-to object is in the same NC as the referencing
                    // object or referred-to object is in the config or schema
                    // NCs.  Note that the referred-to object is in an NC that's
                    // instantiated on this DSA but the referred-to object
                    // itself is not present locally.  However, the referred-to
                    // object has been verified by another DSA (a GC or the DSA
                    // given us via the "verify names" control), so the
                    // reference is okay.
                    ;
                } else if (NameMatched(pRefCR->pNC, pDN)) {
                    // Referred-to object is the root of an NC.  These
                    // references are always okay.
                    ;
                } else if (pObjCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                    // Referring object is in an interior node of an NC not
                    // replicated to GCs (synonymous with an NDNC as of this
                    // writing).  From previous checks we already know that the
                    // referred-to object is an interior node of an NC other
                    // than config, schema, or that of the referring object.
                    // This is not allowed.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                } else if (pRefCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                    // Referred-to object is in an interior node of an NC not
                    // replicated to GCs (i.e., in an NDNC).  From previous
                    // checks we already know that the referring object is in
                    // an NC that is replicated to GCs (i.e., config, schema,
                    // or a domain NC as of this writing).  This is not allowed.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                }

                // Non-local reference is valid.
            }
            else if (pAC->ulLinkID && DBIsObjDeleted(pDBTmp)) {
                // Referred-to object is deleted, which makes it an invalid
                // target for a linked attribute.
                return SetAttError(hVerifyAtts->pObj,
                                   pAC->id,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                   NULL,
                                   DIRERR_NAME_REFERENCE_INVALID);
            }
            else {
                // Referred-to object is a live, instantiated object in the
                // local database.  Enforce the rules re cross NC references
                // described above.

                // Not that we attempt to "pass" this check through as
                // many simple cases as we can early on in order to reduce
                // the number of paths where we must pay performance
                // penalties to read additional attributes, perform extra
                // cache lookups, etc.

                if (!(pAC->bIsNotReplicated && pAC->ulLinkID)
                    && (pDBTmp->NCDNT != hVerifyAtts->NCDNT) // may be INVALIDDNT
                    && (pDBTmp->NCDNT != gAnchor.ulDNTDMD)
                    && (pDBTmp->NCDNT != gAnchor.ulDNTConfig)) {
                    // The referred-to object is not an interior node of
                    // the same NC as the referencing object (although
                    // it may be the root of the referencing object's NC)
                    // and is not an interior node of either the config or
                    // schema NC.

                    NAMING_CONTEXT_LIST * pNCL;
                    SYNTAX_INTEGER iType;

                    retCode = GetExistingAtt(pDBTmp,
                                             ATT_INSTANCE_TYPE,
                                             &iType,
                                             sizeof(iType));
                    if (retCode) {
                        Assert(retCode == pTHS->errCode);
                        return retCode;
                    }

                    if (iType & IT_NC_HEAD) {
                        // It's always okay to reference an NC head -- they
                        // can't be renamed, and if they were then that
                        // knowledge would have to published to all DCs in
                        // the forest via the config NC (thus alleviating
                        // the need for the stale phantom cleanup daemon to
                        // query a GC for the name and publish it to the
                        // other replicas).
                        ;
                    } else if (pObjCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                        // Referring object is in an NC not replicated to GCs
                        // (an NDNC as of this writing) and referred-to object
                        // is an interior node of another NC that is neither
                        // config nor schema.  This is not allowed.
                        return SetAttError(hVerifyAtts->pObj,
                                           pAC->id,
                                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                           NULL,
                                           DIRERR_NAME_REFERENCE_INVALID);
                    } else {
                        // Referring object is in an NC replicated to GCs and
                        // the referred-to object is an interior node of another
                        // NC that is neither config nor schema (i.e., a domain
                        // NC or NDNC).  Referred-to object must be in an NC
                        // that's also replicated to GCs (i.e., a domain NC).
                        pNCL = FindNCLFromNCDNT(pDBTmp->NCDNT, FALSE);
                        Assert(NULL != pNCL);

                        if ((NULL == pNCL)
                            || (NULL
                                == (pRefCR
                                    = FindExactCrossRef(pNCL->pNC, NULL)))
                            || (pRefCR->flags
                                & FLAG_CR_NTDS_NOT_GC_REPLICATED)) {
                            // Failure to resolve NC of the referred-to
                            // object or it's not replicated to GCs.
                            return SetAttError(hVerifyAtts->pObj,
                                               pAC->id,
                                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                               NULL,
                                               DIRERR_NAME_REFERENCE_INVALID);
                        }
                    }
                }

                // Local reference is valid.
                ImproveDSNameAtt(pDBTmp, LOCAL_DSNAME, pDN, NULL);
            }
        }

        // Next val...
        pAVal++;
    }

    // Success!
    return 0;
}



/*++
Routine Description:
    Verify that any Dsname valued atts actually refer to objects in this
    enterprise or meet some constraints if not.

    One special case is for the creation of crossref objects, which by
    necessity must refer to objects that aren't necessarily instantiated.
    We check that the NC-Name on a CrossRef either refers to an object
    outside the scope of our enterprise, or would be the immediate child of
    an object instantiated on this server.  If the NC-Name is a potential
    child of an NC not instantiated on this server, the user will be
    referred to the server holding the best enclosing NC.  If this server
    holds the best enclosing NC, but the NC-Name is not an immediate child
    (i.e., there would be a gap between the subref and its nearest parent),
    an UpdateError(NamingViolation) will be returned.  Additionally, if the
    NC-Name refers to an object instantiated on this server, we will succeed
    if and only if the object referred to is in fact an NC_HEAD.

    THIS ROUTINE MUST EITHER INSURE THE DSNAME'S GUID AND SID ARE CORRECT
    OR NULL THEM OUT SO AS TO AVOID BACK DOOR SETTING OF A PHANTOM'S GUID
    AND SID.  See further comments in ImproveDSNameAtt and
    UpdatePhantomGuidAndSid().

    Simple tests are performed inline, more complex tests are farmed out
    to attribute-specific worker routines.

Arguments:
    pTHS
    hVerifyAtts - handle returned from previous call to VerifyAttsBegin()
    pAC - attcache * of attribute we are trying to write.
    pAttrVal - list of attribute values we are trying to write.

Return Value
    0 if the attribute is not dsname valued OR the dsnames referred to in
        pAttr already exist OR it's an "allowable" phantom.
    non-zero error type code if one of the dsnames referred to does not exist.
        Sets an error in the THSTATE if one is encountered.

--*/
int
VerifyDsnameAtts (
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    int retCode=0;                      // Assume nothing will go wrong.

    // The DRA may add phantoms, as may anyone at install time
    if (pTHS->fDRA || DsaIsInstalling()) {
        return 0;
    }

    Assert(hVerifyAtts->pObj);

    switch (pAC->id) {
      case ATT_NC_NAME:
        retCode = VerifyNcName(pTHS,
                               hVerifyAtts,
                               pAttrVal,
                               pAC);
        break;

      case ATT_RID_AVAILABLE_POOL:
        retCode = VerifyRidAvailablePool(pTHS,
                                         hVerifyAtts,
                                         pAC,
                                         pAttrVal);
        break;

      case ATT_DEFAULT_OBJECT_CATEGORY:
      case ATT_OBJECT_CATEGORY:
        retCode = VerifyObjectCategory(pTHS,
                                       hVerifyAtts,
                                       pAC,
                                       pAttrVal);
        break;

      case ATT_SERVICE_PRINCIPAL_NAME:
        retCode = VerifyServerPrincipalName(pTHS,
                                            hVerifyAtts,
                                            pAC,
                                            pAttrVal);
        break;

      case ATT_FSMO_ROLE_OWNER:
        // There are two ways that the FSMO role owner attribute can get
        // set: (a) by the DSA itself during a controlled role-transfer
        // operation or (b) in an emergency override where an administrator
        // is whacking the value because the current role-owner is dead,
        // unreachable, or held by hostile forces.  We can detect case (a)
        // by noticing that fDSA is set, and we will trust whatever value
        // the DSA is setting.  For case (b), we're already in dangerous
        // territory, and we want to make sure that the caller puts a useful
        // value in.  Since the only valid value we truly know of at this
        // point is this DSA (i.e., claiming the role-ownership for this
        // server), the DN of this DSA is the only value we'll permit.
        if (pTHS->fDSA ||
            NameMatched((DSNAME*)pAttrVal->pAVal->pVal, gAnchor.pDSADN)) {
            // Either trusted caller or good value.
            retCode= 0;
        }
        else {
            // Someone other than the DSA itself is attempting to set the
            // role owner to something other than this particular DSA.
            retCode = SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                  DIRERR_INVALID_ROLE_OWNER);
        }
        break;

      case ATT_PROXIED_OBJECT_NAME:
        // No external client may set this name.  Only routine which may
        // set this is CreatyProxyObject - and then only with fDSA and
        // fCrossDomainMove set.

        if ( pTHS->fDSA && pTHS->fCrossDomainMove ) {
            retCode = 0;
        }
        else {
            retCode = SetAttError(hVerifyAtts->pObj,
                                  pAC->id,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                  NULL,
                                  DIRERR_NAME_REFERENCE_INVALID);
        }
        break;

        // Attributes with generic checks, but skip them when fDSA
    case ATT_MS_DS_REPLICATES_NC_REASON:
        if (pTHS->fDSA) {
            retCode = 0;
            break;
        }
        // fall through

    default:
        // Check any attribute with a DSNAME buried in it

        switch (pAC->syntax) {
          case SYNTAX_DISTNAME_TYPE:
          case SYNTAX_DISTNAME_STRING_TYPE:
          case SYNTAX_DISTNAME_BINARY_TYPE:
            if ( pTHS->fCrossDomainMove ) {
                // We did the specials checking by ATTRTYP, now we let through
                // everything else if this is a cross domain move.  Cross
                // domain move code before here validated that the caller is a
                // bona fide peer DC, so we will trust that he is giving us
                // good DSNAME references within the enterprise.  We *could*
                // verify DSNAME atts as a separate step before opening the
                // first transaction, but it is simpler, and seemingly safe,
                // to trust our peer.
                retCode = 0;
            }
            else {
                retCode = VerifyGenericDsnameAtt(pTHS,
                                                 hVerifyAtts,
                                                 pAC,
                                                 pAttrVal);
            }
            break;

          default:
            // Not a DSNAME-based attribute
            retCode = 0;
        }
    }

    return retCode;
}


PDSNAME
DSNameFromAttrVal(
    ATTCACHE    *pAC,
    ATTRVAL     *pAVal)

/*++

Description:

    Returns the pointer to an embedded DSNAME or NULL if
    the attribute value doesn't contain a DSNAME.

    This routine expects the values to be in EXTERNAL form.  There is also a routine in
    dbobj.c which handles values in internal form.

Arguments:

    pAC - ATTCACHE pointer for the attribute.

    pAVal - ATTRVAL pointer whose DSNAME we are to extract.

Returns:

    Valid PDSNAME or NULL

--*/

{
    DSNAME  *pDN = NULL;

    switch(pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        // Easy case, the whole value is a dsname.
        pDN = (DSNAME *)pAVal->pVal;
        // Make sure value isn't crap
        Assert(pAVal->valLen >= DSNameSizeFromLen(0));
        break;
    case SYNTAX_DISTNAME_BINARY_TYPE:
    case SYNTAX_DISTNAME_STRING_TYPE:
        {
            // Ok, pull the DSName out of the complex structure.
            SYNTAX_DISTNAME_STRING *pDA =
                (SYNTAX_DISTNAME_STRING *)pAVal->pVal;

            pDN = ((DSNAME *)&pDA->Name);

            // Make sure value is good
            Assert(pDN->structLen >= DSNameSizeFromLen(0));
        }
    }

    return(pDN);
}




//-----------------------------------------------------------------------
//
// Function Name:            WriteSchemaObject
//
// Routine Description:
//
//    Writes to the Schema Object on a Schema Update as a Conflict
//    Resolution Mechanism. Its not the best way but serves the purpose.
//
// Author: RajNath
// Date  : [3/26/1997]
//
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
WriteSchemaObject()
{
    DBPOS *pDB;
    DWORD err=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    THSTATE *pTHS;
    ULONG cLen;
    UCHAR *pBuf;
    DWORD versionNo, netLong;

    if ( DsaIsInstalling() )
    {
        //
        // not when installing ...
        //
        return 0;
    }

    DBOpen2(TRUE, &pDB);
    if (NULL == pDB) {
        return DB_ERR_DATABASE_ERROR;
    }

    pTHS=pDB->pTHS;
    Assert(!pTHS->fDRA);

    __try  {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
            // Read the current version no., if any
            err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fREALLOC,
                                 0, &cLen, (UCHAR **) &pBuf);
            switch (err) {
                case DB_ERR_NO_VALUE:
                    // first value added
                    cLen = SCHEMA_INFO_PREFIX_LEN + sizeof(versionNo) + sizeof(UUID);
                    pBuf = (UCHAR *) THAllocEx(pTHS, cLen);
                    versionNo = 1;
                    // version no. is stored in network data format for
                    // uniformity across little-endian/big-endian m/cs

                    netLong = htonl(versionNo);
                    memcpy(pBuf,SCHEMA_INFO_PREFIX, SCHEMA_INFO_PREFIX_LEN);
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN],&netLong,sizeof(netLong));
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN+sizeof(netLong)],
                           &pTHS->InvocationID,
                           sizeof(UUID));
                    break;
                case 0:
                    // value exists, length will be the same
                    // version no. is stored in network data format for
                    // uniformity across little-endian/big-endian m/cs. So
                    // convert accordingly (but be careful to be properly
                    // aligned for ntohl!)

                    memcpy(&versionNo, &pBuf[SCHEMA_INFO_PREFIX_LEN], sizeof(versionNo));
                    versionNo = ntohl(versionNo);
                    versionNo++;
                    netLong = htonl(versionNo);
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN],&netLong,sizeof(netLong));
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN+sizeof(netLong)],
                           &pTHS->InvocationID,
                           sizeof(UUID));
                    break;
                default:
                    // other error
                    __leave;

            }  /* switch */

            if ((err= DBRemAtt_AC(pDB, ac)) != DB_ERR_SYSERROR) {
                err = DBAddAttVal_AC(pDB, ac, cLen, pBuf);
            }

            if (!err) {
                err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
            }
        }
        if (0 == err) {
            fCommit = TRUE;
        }

    }
    __finally {
        DBClose(pDB,fCommit);
    }

    if (err){
        // common practice is to return this error when the modification of
        // metadata fails.
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION,
                      err);
    }

    return err;

} // End WriteSchemaObject

VOID ImproveDSNameAtt(
        DBPOS *pDBTmp,
        DWORD   LocalOrNot,
        DSNAME  *pDN,
        BOOL    *pfNonLocalNameVerified)

/*++

Description:

    Improves the GUID and SID of a DSNAME valued attribute.

Arguments:

    pDBTmp - pDB that we used to do a DBFindDSName on the pDN.  Should only be
             NON-NULL in the LocalOrNot == LOCAL_DSNAME case, and in that case,
             currency should be on the object pDN.

    LocalOrNot - Flag indicating locality - eg: did DSNAME pass DBFindDSName.

    pDN - Pointer to DSNAME in the ADDARG or MODIFYARG.  Yes, we are modifying
        the caller's arguments.  See comments below.

    pfNonLocalNameVerified - pointer to optional BOOL which indicates if a
        non-local DSNAME was verified against the GC.

--*/

{
    ENTINF  *pEntinfTmp;
    DSNAME  *pDNTmp = NULL;
    CROSS_REF *pCR;
    COMMARG  CommArg;

    switch(LocalOrNot) {
    case NONLOCAL_DSNAME:
        Assert(!pDBTmp);
        pEntinfTmp = GCVerifyCacheLookup(pDN);
        if ((NULL!=pEntinfTmp) && (NULL != (pDNTmp = pEntinfTmp->pName)))  {
            // The non-local name was verified against the GC and we
            // consider the cached version to be better than the
            // ATTRVALBLOCK version because it has the proper GUID and
            // possibly SID.  So overwrite the ATTRVALBLOCK DSNAME with the
            // verified DSNAME to insure that the resulting phantom has the
            // right GUID, SID, casing, etc. Note that the GC verified name
            // may be longer than the ATTRBLOCK version. This may happen if
            // the attrblock version is a SID or a GUID only name, and the
            // GCVerified Version contains the string name also
            Assert(pDNTmp);

        } else {

            // OK, we failed to find this DN in the GC verification cache,
            // but it just so happens that we've got a cache of NC Heads in
            // addition to the GC verification cache.  We'll use this if
            // pDN is an NC head.

            Assert(pDNTmp == NULL);
            InitCommarg(&CommArg);
            CommArg.Svccntl.dontUseCopy = FALSE;
            pCR = FindExactCrossRef(pDN, &CommArg);
            if(pCR && NameMatched(pCR->pNC, pDN)){

                // The object we're Improving is an actual NC Head, so
                // we've got a hit, just a little more verification:
                if(pCR->flags & FLAG_CR_NTDS_DOMAIN &&
                   !fNullUuid(&pCR->pNC->Guid)){
                    // We've got a valid Domain, ie must have GUID & SID.
                    pDNTmp = pCR->pNC;
                }

                if((pCR->flags & FLAG_CR_NTDS_NC) &&
                   !(pCR->flags & FLAG_CR_NTDS_DOMAIN) &&
                   !fNullUuid(&pCR->pNC->Guid)){
                    // We've got a valid NC (Config, Schema, or NDNC),
                    // ie we've got a non-NULL GUID.
                    pDNTmp = pCR->pNC;
                }

            }

        }

        if(pDNTmp){
            // We got a NC Head gAnchor cache hit, so we don't have to
            // error out.

            if (pDN->structLen >= pDNTmp->structLen)
            {
                //
                // if the passed in buffer can hold the
                // DSNAME that we found, copy it over.
                // Mark the name as verified
                //

                memcpy(pDN, pDNTmp, pDNTmp->structLen);
                if ( pfNonLocalNameVerified )
                    *pfNonLocalNameVerified = TRUE;
            }
            else
            {
                //
                // This will happen if the client passed in a
                // GUID only or SID only name and the name in the GC verify
                // cache will also have the string name in it. Unfortunately
                // we cannot improve the DS name Att, because that would make
                // us realloc the callers arguments. Passing in GUID or SID
                // based name is important only for manipulating memberships
                // in groups, and SAM takes care of this case by substituting
                // the verified name while making the modify call. For manipulation
                // of other classes / attributes we will fail the call.
                //
              if ( pfNonLocalNameVerified )
                   *pfNonLocalNameVerified = FALSE;
            }

        } else {

            // We couldn't verify this non-local name in the GCCache.  In order
            // to avoid sneaky attempts to change an object's GUID or SID by
            // referencing it in a DSNAME-valued attribute, null the GUID and
            // SID (non-verified non-local dsname atts shouldn't have SIDs or
            // GUIDs).
            memset(&pDN->Guid, 0, sizeof(GUID));
            pDN->SidLen = 0;
            if ( pfNonLocalNameVerified ){
                *pfNonLocalNameVerified = FALSE;
            }
        }

        break;

    case LOCAL_DSNAME:
        // We have a DSNAME about to be referenced, and that DSNAME can be
        // successfully found via DBFindDSName.  As a matter of fact, we are
        // positioned on the object in question.  Since ExtIntDist will try to
        // reference by GUID, we need to make sure that if there is a GUID on
        // the object, that it is the correct GUID. So, whack the ATTRVALBLOCK
        // value's GUID and SID to be the correct values to avoid sneaky
        // attempts to change an object's GUID or SID by referencing it in a
        // DSNAME-valued attribute.
        Assert(pDBTmp);
        memset(&pDN->Guid, 0, sizeof(GUID));
        pDN->SidLen = 0;
        DBFillGuidAndSid(pDBTmp, pDN);
        break;
    default:
        Assert((LOCAL_DSNAME == LocalOrNot) || (NONLOCAL_DSNAME == LocalOrNot));
    }

    return;
}

#if DBG
BOOL CheckCurrency(DSNAME *pShouldBe)
{

    ULONG len;
    DSNAME *pCurObj=0;
    THSTATE     *pTHS = pTHStls;

    DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                0, 0, &len, (CHAR **)&pCurObj);
    if (!NameMatched(pShouldBe, pCurObj)) {
        DPRINT2(0, "Someone lost DB currency, we're on '%S' but should be on '%S'\n",
                pCurObj->StringName, pShouldBe->StringName);
        Assert(!"Currency lost");
        return FALSE;
    }
    if (pCurObj) {
        THFreeEx(pTHS, pCurObj);
    }
    return TRUE;
}
#endif

ULONG
DoSecurityChecksForLocalAdd(
    ADDARG      *pAddArg,
    CLASSCACHE  *pCC,
    GUID        *NewObjectGuid,
    BOOL        fAddingDeleted
    )
/*++

    Routine Description

        This Routine Does all the Security Checks needed for An Add operation.
        It Checks the security on the parent and then checks the Add arg for
        rights on the object. It also calls the routines that will generate a
        merged security descriptor to be used in the Parent.


    Parameters:

        AddArg -- Pointer to the Add Arg for the Add Operation
        Class Cache -- Pointer to the Class Cache for the Class of the object in
                       question.
        NewObjectGuid  -- Guid of the new object
        fAddingDeleted -- TRUE if Adding a Deleted Object.
        fCreatingNewNC -- TRUE if Creating a new NC


    Return Values

        0 Upon Success.
        Upon an Error this routine will return the error and also set pTHStls->errCode

--*/
{
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    ULONG                cbNTSD = 0;
    THSTATE              *pTHS = pTHStls;

    // Bail if Security Checks have already been done.
    if (pTHS->fAccessChecksCompleted)
        return 0;

    if (!pAddArg->pCreateNC) {
        //
        // Check Security on the Parent
        //
        if (CheckParentSecurity(pAddArg->pResParent,
                                pCC,
                                fAddingDeleted,
                                &pNTSD,
                                &cbNTSD)) {

	    return CheckObjDisclosure(pTHS, pAddArg->pResParent, TRUE);
        }
    }
    //
    // Check Add Security. Also replace the security Descriptor
    // on the object with the merged descriptor
    //

    if ( 0 != CheckAddSecurity(pTHS,
                               pCC,
                               pAddArg,
                               pNTSD,
                               cbNTSD,
                               NewObjectGuid))
    {
        return CheckObjDisclosure(pTHS, pAddArg->pResParent, TRUE);
    }

    THFreeEx(pTHS, pNTSD);

    return 0;

}

ULONG
CheckRemoveSecurity(
        BOOL fTree,
        CLASSCACHE * pCC,
        RESOBJ *pResObj )
/*++

    Does Security Checks for Removes.

    Actual security checks should be done first so that non security 
    errors aren't returned if the client doesn't have permission to perform
    the op.
    
    Parameters:

        fTree     -- bool, are we trying to delete a whole tree?
        pCC       -- Pointer to the Class Cache

    Return Values
        0 Upon Success.
        Upon an Error this routine will return the error and also set pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    ULONG       ulSysFlags;

    // Bail if Security Checks have already been done.
    if (pTHS->fAccessChecksCompleted)
        return 0;

    // check if the user is allowed to change an object that is in the
    // configuration NC or schema NC
    if (CheckModifyPrivateObject(pTHS,
                             NULL,
                             pResObj)) {
        // it is not allowed to delete this object on this DC
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }


    if(fTree) {
        if (!IsAccessGrantedSimple(RIGHT_DS_DELETE_TREE,TRUE)) {
            return CheckObjDisclosure(pTHS, pResObj, TRUE);
        }
    }
    else {
        if ((!IsAccessGrantedSimple(RIGHT_DS_DELETE_SELF,TRUE))
            && (!IsAccessGrantedParent(RIGHT_DS_DELETE_CHILD,pCC,FALSE))) {

            return CheckObjDisclosure(pTHS, pResObj, TRUE);
	}
    }

    if (!(pTHS->fDSA || pTHS->fDRA)) {
        if(!DBGetSingleValue(pTHS->pDB,
                             ATT_SYSTEM_FLAGS,
                             &ulSysFlags,
                             sizeof(ulSysFlags),
                             NULL)) {
            // We have system flags.
            if(ulSysFlags & FLAG_DISALLOW_DELETE) {
                // We're trying to delete, but the flags say that that is a no
                // no.
                return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                   DIRERR_CANT_DELETE);
            }
        }
    }


    return 0;
}

ULONG
CheckIfEntryTTLIsAllowed(
        THSTATE *pTHS,
        ADDARG  *pAddArg )
/*++

    Check system flags, delete permission, and NC.

    Parameters:

        pTHS - thread state
        pAddArg - add args

    Return Values
        0 Upon Success.
        Otherwise, pTHS->errCode is set

--*/
{
    ULONG       ulSysFlags;
    CROSS_REF   *pCR;

    // always allowed
    if (DsaIsInstalling() || pTHS->fDRA || pTHS->fDSA) {
        return 0;
    }

    // check system flags for non-deletable object
    if(!DBGetSingleValue(pTHS->pDB,
                         ATT_SYSTEM_FLAGS,
                         &ulSysFlags,
                         sizeof(ulSysFlags),
                         NULL)) {
        // flags disallow delete
        if(ulSysFlags & FLAG_DISALLOW_DELETE) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_CANT_DELETE);
        }
    }

    // Not allowed in SchemaNC or ConfigNC
    if (   (pAddArg->pResParent->NCDNT == gAnchor.ulDNTDMD)
        || (pAddArg->pResParent->NCDNT == gAnchor.ulDNTConfig)
        || (pAddArg->pResParent->DNT == gAnchor.ulDNTDMD)
        || (pAddArg->pResParent->DNT == gAnchor.ulDNTConfig)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_NOT_SUPPORTED);
    }

    // If not a whistler enterprise, dynamic objects must be in an NDNC
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WHISTLER) {
        pCR = FindBestCrossRef(pAddArg->pObject, NULL);
        if (   !pCR
            || !(pCR->flags & FLAG_CR_NTDS_NC)
            || (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_NOT_SUPPORTED);
        }
    }

    return 0;
}

BOOL
IsAccessGrantedAddGuid (
        PDSNAME pDN,
        COMMARG *pCommArg
        )
{
    CROSS_REF           *pCR = NULL;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    DWORD                ulLen = 0;
    DSNAME              *pName;
    ATTRTYP              classP;
    CLASSCACHE          *pCC=NULL;
    THSTATE             *pTHS = pTHStls;
    PUCHAR               pVal = (PUCHAR)&classP;
    DWORD                err;

    // First, you can't do this at all unless this is a GC
    if(!gAnchor.fAmGC) {
        return FALSE;
    }

    // Find the best cross reference for this name
    pCR = FindBestCrossRef(pDN, pCommArg);
    if(!pCR) {
        return FALSE;
    }

    pName = pCR->pNC;
    if(DBFindDSName(pTHS->pDB, pName)) {
        // Couldn't find that name
        return FALSE;
    }

    // Get the security descriptor
    if(err = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                         0,0,
                         &ulLen, (PUCHAR *)&pNTSD)) {
        return FALSE;
    }

    ulLen = 0;

    if(DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_CLASS,
                   DBGETATTVAL_fINTERNAL | DBGETATTVAL_fCONSTANT,
                   sizeof(classP),
                   &ulLen, &pVal)
       || !(pCC = SCGetClassById(pTHS, classP))) {
        return FALSE;
    }

    return IsControlAccessGranted(pNTSD,
                                  pName,
                                  pCC,
                                  RIGHT_DS_ADD_GUID,
                                  FALSE);
}


VOID
ModCrossRefCaching(
    THSTATE *pTHS,
    CROSS_REF *pCR
    )

/*++

Routine Description:

Queue this up as if it were a modObjCaching of
a cross ref.  In order to do that, we must open a new
DBPOS, position on the CR object, remove and add its
object caching, and then go back to the old DBPOS to
hide what we just did from callers.

Arguments:

    pTHS - 
    pCR - Cross reference object being refreshed

Return Value:

    None

--*/

{
    DWORD err;
    DBPOS *pDBtmp, *pDBsafe;
    CLASSCACHE *pCrossRefCC;
    RESOBJ DummyRes;
    DSNAME *pCRName;

    DBOpen2(FALSE, &pDBtmp);
    pDBsafe = pTHS->pDB;
    pTHS->pDB = pDBtmp;
    __try {
        err = DBFindDSName(pDBtmp, pCR->pObj);
        if (err) {
            __leave;
        }

        pCRName = THAllocOrgEx(pTHS, pCR->pObj->structLen);
        memcpy(pCRName, pCR->pObj, pCR->pObj->structLen);

        DummyRes.pObj = pCRName;
        pCrossRefCC = SCGetClassById(pTHS, CLASS_CROSS_REF);

        DelObjCaching (pTHS, pCrossRefCC, &DummyRes, FALSE);

        err = AddObjCaching(pTHS, pCrossRefCC, pCRName, FALSE, FALSE);
        if(!err) {
            // Keep track of the DN of the object also, since we
            // use the existance of the DN on an ADD record to
            // trigger us to notify LSA.
            OBJCACHE_DATA *pObjData =
                pTHS->JetCache.dataPtr->objCachingInfo.pData;

            Assert(pObjData);
            // The AddObjCaching will have put its transactional
            // data at the end of the queue, so we must walk
            // to the end of the list to find it.
            while (pObjData->pNext) {
                pObjData = pObjData->pNext;
            }
            Assert(pObjData->type == OBJCACHE_ADD);
            pObjData->pDN = pCRName;
        }
    } __finally {
        DBClose(pDBtmp, TRUE);
        pTHS->pDB = pDBsafe;
    }

} /* ModCrossRefCaching */


/* HandleDNRefUpdateCaching
 *
 * This routine gets passed in the name of a InfrastructureUpdate object
 * that is being added (presumably replicated in).  We must check to see
 * if the reference update it's carrying is the name of an NC, and if so,
 * whether our cross-ref cache for that NC is missing data (specifically
 * the GUID and/or SID of the NC).  If so, we need to update the cache.
 * We do that by finding the name of the CrossRef object corresponding
 * to the NC and refreshing its object caching data.  Oh, and we have to
 * do all of this without affecting database currency.
 */
void
HandleDNRefUpdateCaching (
        THSTATE *pTHS
        )
{
    DWORD len;
    DWORD err;
    DSNAME *pRef = NULL;
    COMMARG FakeCommArg;
    CROSS_REF *pCR = NULL;

    len = 0;
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_DN_REFERENCE_UPDATE,
                      0,
                      0,
                      &len,
                      (UCHAR **)&pRef);
    if (0 == err) {
        // First check: is this reference an ncname?
        InitCommarg(&FakeCommArg);
        Assert(!FakeCommArg.Svccntl.dontUseCopy); // read-only is okay
        pCR = FindExactCrossRef(pRef, &FakeCommArg);
        if ( pCR ) {
            // Yes, it's a cross ref.

            // Ok the reference is an nc name - does the in memory
            // version need  improving?
            if(   (fNullUuid(&pCR->pNC->Guid) &&
                   !fNullUuid(&pRef->Guid))
               || ((0 == pCR->pNC->SidLen) &&
                   (0 < pRef->SidLen) ) ) {

                ModCrossRefCaching( pTHS, pCR );
            }
        }
    }
}


/* The following data structure is used to hold the data required
   when doing ValidateSPNsAndDnsHostName() */
typedef struct {
    ATTRVALBLOCK *pOriginalDNSHostName;             // the original DNS Host Name
    ATTRVALBLOCK *pOriginalAdditionalDNSHostName;   // the original additional DNS Host Name
    ATTRVALBLOCK *pOriginalSamAccountName;          // the original SamAccountName
    ATTRVALBLOCK *pOriginalSPNs;                    // the original ServicePricipalName
    ATTRVALBLOCK *pCurrentDNSHostName;              // the current DNS Host Name
    ATTRVALBLOCK *pCurrentAdditionalDNSHostName;    // the current Additional DNS Host Name
    ATTRVALBLOCK *pCurrentSamAccountName;           // the current SamAccountName
    ATTRVALBLOCK *pCurrentAdditionalSamAccountName; // the current addtional Sam Account Name
    ATTRVALBLOCK *pCurrentSPNs;                     // the current ServicePricipalName
    ATTRVALBLOCK *pCurrentSvrRefBL;                 // the current SvrRefBL;
    ATTRVALBLOCK *pUpdatedAdditionalSamAccountName; // the updated AdditionalSamAccountName;
    BYTE         *pOrgMask;                         // An array of flags for Original AdditionalDNSHostName
    BYTE         *pCurrMask;                        // An array of flags for Current AdditionalDNSHostName
    ATTRVAL      *pOrgGeneratedSamAccountName;      // The Sam Account Names generated from original AdditionalDnsHostName
    ATTRVAL      *pCurrGeneratedSamAccountName;     // The Sam Account Names generated from current AdditionalDnsHostName
    BOOL         fAdditionalDNSHostNameUnchanged:1; // if the AdditionalDNSHostName is changed
    BOOL         fDNSHostNameUnchanged:1;           // if the DnsHostName is changed
    BOOL         fSamAccountNameUnchanged:1;        // if the SamAccountName is changed
} SPN_DATA_COLLECTION;


DWORD VerifyUniqueSamAccountName ( THSTATE      *pTHS,
                                   WCHAR        *SamAccountNameToCheck,
                                   DWORD        cbSamAccountNameToCheck,
                                   ATTRVALBLOCK *pCurrentSamAccountName )

/* verify if the given SamAccountName is unique domainwise in the space
   of ATT_SAM_ACCOUNT_NAME and ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
   However, we allow the SamAccountName to be the same as the
   ATT_SAM_ACCOUNT_NAME of the same account.

   Parameters:
     SamAccountNameToCheck:    the SamAccountName to verify;
     cbSamAccountNameToCheck:  the size of SamAccountNameToCheck in byte;
     pCurrentSamAccountName:   the SamAccountName of the current object;

   Return value:
    0 if success; win32 error otherwise.

*/

{
    DWORD err = 0;
    FILTER SamAccountNameFilter, OrFilter, AdditionalSamAccountNameFilter;
    BOOL fSamAccountSame = FALSE;
    WCHAR buff[MAX_COMPUTERNAME_LENGTH+2];

    BOOL fDSASave;
    DBPOS *pDBSave;

    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    Assert(1==pCurrentSamAccountName->valCount);

    //
    // check if SamAccountNameToCheck is the same as the current SamAccountName
    //

    if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            (WCHAR*)pCurrentSamAccountName->pAVal->pVal,
                            pCurrentSamAccountName->pAVal->valLen/sizeof(WCHAR),
                            SamAccountNameToCheck,
                            cbSamAccountNameToCheck/sizeof(WCHAR) ) ) {
          fSamAccountSame = TRUE;
    }

    // add '$' to the end
    swprintf(buff, L"%s$",SamAccountNameToCheck);

    //save current DBPOS etc
    fDSASave = pTHS->fDSA;
    pDBSave  = pTHS->pDB;

    __try {
        memset(&SearchArg,0,sizeof(SearchArg));
        SearchArg.pObject = gAnchor.pDomainDN;
        SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
        SearchArg.bOneNC  = TRUE;

        // set search filters
        // (ATT_SAM_ACCOUNT_NAME=samAccountName || ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME=samAccountName)
        memset(&OrFilter,0, sizeof(OrFilter));
        OrFilter.choice = FILTER_CHOICE_OR;
        OrFilter.FilterTypes.Or.pFirstFilter = &SamAccountNameFilter;

        memset(&SamAccountNameFilter,0,sizeof(SamAccountNameFilter));
        SamAccountNameFilter.choice = FILTER_CHOICE_ITEM;
        SamAccountNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SAM_ACCOUNT_NAME;
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbSamAccountNameToCheck+sizeof(WCHAR);
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)buff;
        SamAccountNameFilter.pNextFilter = &AdditionalSamAccountNameFilter;

        memset(&AdditionalSamAccountNameFilter,0,sizeof(AdditionalSamAccountNameFilter));
        AdditionalSamAccountNameFilter.choice = FILTER_CHOICE_ITEM;
        AdditionalSamAccountNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbSamAccountNameToCheck+sizeof(WCHAR);
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)buff;

        SearchArg.pFilter = &OrFilter;

        InitCommarg(&SearchArg.CommArg);

        //return two objects only
        SearchArg.CommArg.ulSizeLimit = 2;

        memset(&SearchRes,0,sizeof(SearchRes));


        //open another DBPOS
        pTHS->pDB = NULL;
        DBOpen(&(pTHS->pDB));

        __try {

            if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
                __leave;
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

            if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                __leave;
            }

            // it fails if 1 ) we got two objects, or  2) one object and the
            // samAccountNameToCheck is different from pCurrentSamAccountName.
            if (   SearchRes.count > 1
                || (SearchRes.count > 0 && !fSamAccountSame ) ) {
                err = ERROR_DS_NAME_NOT_UNIQUE;
                __leave;
            }

        }
        __finally {
            // faster to commit a read transaction than rollback
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __finally{
        //restore the saved value
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
    }

    return err;
}

DWORD SpnCase( WCHAR * pServiceName,
               DWORD cchServiceName,
               WCHAR * pInstanceName,
               DWORD cchInstanceName,
               WCHAR * pDNSHostName,
               DWORD cchDNSHostName,
               WCHAR * pSamAccountName,
               DWORD cchSamAccountName )
/* This function will try to match the service name and
instance name of the spn with the dnshostname and samaccountname.
It returns:
0  -- no match;
1  -- the instance name of the SPN matches the DNSHostName.
2  -- the service name of the SPN matches the DNSHostName.
3  -- both the service name and the instance name of the SPN
      matches the DNSHostName.
4  -- the SPN is two-part, and matches the samAccountName

Parameters:
    pServiceName  :  the service name part of the spn;
    cchServiceName:  the length of pServiceName in char;
    pInstanceName :  the instance name part of the spn;
    cchInstanceName: the lenght of pInstanceName in char;
    pDNSHostName  :  the DNS Host name to match;
    cchDNSHostName:  the length of pDNSHostName in char;
    pSamAccountName: the SamAccountName to match;
    cchSamAccountName: the length of pSamAccountName in char.

Return value:
    see above
*/
{

    DWORD switchFlags = 0;
    // First, check for the sam account name case
    if(
       (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pServiceName,
                            cchServiceName - 1,
                            pInstanceName,
                            cchInstanceName - 1)) &&
       // Yep, this is a 'two-part-spn' where part 2 and 3 of the
       // cracked SPNs are the same.  This might be affected.
       (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pSamAccountName,
                            cchSamAccountName,
                            pInstanceName,
                            cchInstanceName - 1))) {
        switchFlags = 4;
    }
    else {
        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pDNSHostName,
                               cchDNSHostName,
                               pInstanceName,
                               cchInstanceName - 1)) {
            switchFlags = 1;
        }

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pDNSHostName,
                               cchDNSHostName,
                               pServiceName,
                               cchServiceName - 1)) {
            switchFlags |= 2;
        }

    }
    return switchFlags;
}


BOOL  SpnInsertIntoAddList( THSTATE      * pTHS,
                            BOOL         fAddToNewList,
                            WCHAR        * pNewSpn,
                            DWORD        cbNewSpn,
                            ATTRVALBLOCK * pCurrentSPNs,
                            ATTRVAL      * pNewSpnList,
                            DWORD        * pcNewSpnList,
                            DWORD        * pcAllocated,
                            BYTE         * pSPNMask )

/* Insert an SPN into the pNewSpnList, but first
we will check:
    1. if the SPN is already in pCurrentSPNs, if so, mark it as
       "don't delete" in the flag array pSPNMask;
    2. if it is already in pNewSpnList;
    3. if all of the above fails, and fAddToNewList is set, we will
       add it into pNewSpnList, allocate more memory if necessary.

Parameters:
   pTHS :          the thread state;
   fAddToNewList:  whether or not to add the object to the list;
   pNewSpn:        the new spn to add;
   cbNewSpn:       the length of the spn in byte;
   pCurrentSPNs:   the ATTRVALBLOCK that holds the current SPNs;
   pNewSpnList:    the spns to add;
   pcNewSpnList:   how many items in pNewSpnList;
   pcAllocated :   the number of slots allocated;
   pSPNMask:       the flags for the current SPNs.

Return value:
  TRUE  : if the new spn is added into the list;
  FALSE : otherwise.
*/

{
    DWORD i;

    //check if the new SPN is already in the pCurrentSPNs
    for (i=0; i<pCurrentSPNs->valCount; i++) {

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pNewSpn,
                               cbNewSpn/sizeof(WCHAR),
                               (WCHAR*)pCurrentSPNs->pAVal[i].pVal,
                               pCurrentSPNs->pAVal[i].valLen/sizeof(WCHAR))) {
            pSPNMask[i] |= 0x2;   //"don't delete"
            return FALSE;
        }

    }

    if (!fAddToNewList) {
        return FALSE;
    }

    //check if the new SPN is already in pNewSpnList
    for (i=0; i<*pcNewSpnList; i++) {

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pNewSpn,
                               cbNewSpn/sizeof(WCHAR),
                               (WCHAR*)pNewSpnList[i].pVal,
                               pNewSpnList[i].valLen/sizeof(WCHAR))) {

            return FALSE;
        }

    }

    Assert(*pcNewSpnList<=*pcAllocated);

    //allocate memory if necessary
    if (*pcNewSpnList==*pcAllocated) {
        pNewSpnList = THReAllocEx(pTHS,pNewSpnList,sizeof(ATTRVAL)*((*pcAllocated)+16));
        *pcAllocated += 16;
    }

    // add it to the list
    pNewSpnList[*pcNewSpnList].pVal = (UCHAR*)pNewSpn;
    pNewSpnList[*pcNewSpnList].valLen = cbNewSpn;
    (*pcNewSpnList)++;

    return TRUE;

}


DWORD
FixupSPNsOnComputerObject (
        THSTATE *pTHS,
        DSNAME *pDN,
        CLASSCACHE *pCC,
        SPN_DATA_COLLECTION * pDataSet
)

/*++
  Update SPNs:  delete those obsolete values, and add new ones.

Parameters:
  pDN: the DN of the computer object;
  pCC: classcache of the class of the object being changed;
  pDataSet: pointer to the all necessary data.

Return value:
    0 on success; win32 error otherwise.
--*/
{
    DWORD i;
    DWORD err = 0;
    DWORD len, cbVal;
    ATTCACHE *pAC = SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
    WCHAR *pCurrentHostName;
    USHORT InstancePort;
    WCHAR  *pServiceClass, *pServiceName, *pInstanceName;
    DWORD  cchServiceClass, cchServiceName, cchInstanceName;
    WCHAR  *pNewVal;
    DWORD  cbNewVal;
    DWORD  switchFlags;
    WCHAR *pNewDNSHostName=NULL;
    DWORD  cchNewDNSHostName=0;
    WCHAR *pOldDNSHostName=NULL;
    DWORD  cchOldDNSHostName=0;
    WCHAR *pNewSamAccountName=NULL;
    DWORD  cchNewSamAccountName=0;
    WCHAR *pOldSamAccountName=NULL;
    DWORD  cchOldSamAccountName=0;

    BYTE * pCurrentSPNMask = NULL;
    DWORD  cNewSpnList = 0;
    ATTRVAL *pNewSpnList = NULL;
    DWORD  cAllocated = 0;
    DWORD iOrg, iCurr;
    DWORD result;
    BOOL  fAdded;
    BOOL  fSkipDNSHostName, fSkipSamAccountName;

    Assert(pAC);

    if(!pDataSet->pCurrentSPNs ||
       pDataSet->pCurrentSPNs->valCount == 0) {
        // No SPNs, nothing to fix.
        return 0;
    }

    // Get the DNS host Names.
    if(pDataSet->pCurrentDNSHostName) {
        if(pDataSet->pCurrentDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewDNSHostName = pDataSet->pCurrentDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pNewDNSHostName =  (WCHAR *)pDataSet->pCurrentDNSHostName->pAVal->pVal;
    }

    if(pDataSet->pOriginalDNSHostName) {
        if(pDataSet->pOriginalDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchOldDNSHostName = pDataSet->pOriginalDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pOldDNSHostName =  (WCHAR *)pDataSet->pOriginalDNSHostName->pAVal->pVal;
    }

    // Get the SAM account Names.
    if(pDataSet->pCurrentSamAccountName) {
        if(pDataSet->pCurrentSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewSamAccountName = (pDataSet->pCurrentSamAccountName->pAVal->valLen/sizeof(WCHAR));
        pNewSamAccountName =  (WCHAR *)pDataSet->pCurrentSamAccountName->pAVal->pVal;
    }

    if(pDataSet->pOriginalSamAccountName) {
        if(pDataSet->pOriginalSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchOldSamAccountName = (pDataSet->pOriginalSamAccountName->pAVal->valLen / sizeof(WCHAR));
        pOldSamAccountName =  (WCHAR *)pDataSet->pOriginalSamAccountName->pAVal->pVal;
    }

    // skip checking DNSHostName(SamAccountName) if
    // 1) DNSHostName(SamAccountName) is not changed
    // or 2) either original or new DNSHostName(SamAccountName)
    // is empty.

    fSkipDNSHostName = pDataSet->fDNSHostNameUnchanged || !pOldDNSHostName || !pNewDNSHostName;

    fSkipSamAccountName = pDataSet->fSamAccountNameUnchanged || !pOldSamAccountName || !pNewSamAccountName;

    //
    // if none of the additionalDnsHostName, dnsHostName, or SamAccountName is changed,
    // we don't need to go into this time-comsuming process.
    //

    if (   pDataSet->fAdditionalDNSHostNameUnchanged
        && fSkipDNSHostName
        && fSkipSamAccountName )
    {
        return 0;
    }

    //
    // allocate an array of flags for the SPNs. Later, we will mark 0x1 bitwise to indicate
    // this item will be deleted; and mark 0x2 bitwise to indicate "don't delete" this item.
    // At the end, only those with flag==1 will be deleted.
    //
    pCurrentSPNMask = THAllocEx(pTHS,pDataSet->pCurrentSPNs->valCount*sizeof(BYTE));

    //pre-allocate some space for the new SPNs
    cAllocated = 32;
    pNewSpnList = THAllocEx(pTHS,sizeof(ATTRVAL)*cAllocated);

    len = 256;
    pServiceClass = THAllocEx(pTHS, len);
    pServiceName  = THAllocEx(pTHS, len);
    pInstanceName = THAllocEx(pTHS, len);

    // Now, loop over the SPNs
    for(i=0;i<pDataSet->pCurrentSPNs->valCount;i++) {

        if((pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR)) > len ) {
            // Need to grow the buffers.
            len = pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR);
            pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
            pServiceName  = THReAllocEx(pTHS, pServiceName, len);
            pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
        }

        cchServiceClass = len/sizeof(WCHAR);
        cchServiceName = len/sizeof(WCHAR);
        cchInstanceName = len/sizeof(WCHAR);

        //  Break into components
        err = DsCrackSpnW((WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                          &cchServiceClass, pServiceClass,
                          &cchServiceName,  pServiceName,
                          &cchInstanceName, pInstanceName,
                          &InstancePort);

        if(err) {
            // Huh?
            goto cleanup;
        }

        // let's see which case it matches.
        switchFlags = SpnCase( pServiceName,
                               cchServiceName,
                               pInstanceName,
                               cchInstanceName,
                               pOldDNSHostName,
                               cchOldDNSHostName,
                               pOldSamAccountName,
                               cchOldSamAccountName );

        switch(switchFlags) {
        case 0:
            //
            // Case 0: the SPN does not match anything for
            // primary DNSHostName or primary SamAccountName.
            // We will do a search on all the deleted values of
            // the original additionalDNSHostName, if the SPN matches
            // either the dns name or its derived samAccountName, We
            // marked as 'delete'(0x1 bitmask).
            //
            if (!pDataSet->fAdditionalDNSHostNameUnchanged) {

                for(iOrg=0; iOrg<pDataSet->pOriginalAdditionalDNSHostName->valCount; iOrg++)
                {
                    if (!pDataSet->pOrgMask[iOrg]) {
                        result =  SpnCase( pServiceName,
                                           cchServiceName,
                                           pInstanceName,
                                           cchInstanceName,
                                           (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                           pDataSet->pOriginalAdditionalDNSHostName->pAVal[iOrg].valLen/sizeof(WCHAR),
                                           (WCHAR*)pDataSet->pOrgGeneratedSamAccountName[iOrg].pVal,
                                           pDataSet->pOrgGeneratedSamAccountName[iOrg].valLen/sizeof(WCHAR) );
                        if (result) {
                            // mark it as "delete"
                            pCurrentSPNMask[i] |= 0x1;
                            break;

                        }

                    }
                }
            }
            break;
        case 1:
            //
            // Case 1: the instance name of the SPN matches the
            // primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for every newly
            // added value in additionalDNSHostName.
            //
            if (fSkipDNSHostName){
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // the DNS_HOST_NAME is changed.

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pServiceName,
                                      pNewDNSHostName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                    goto cleanup;
                }

                //mark old one as deleted
                pCurrentSPNMask[i] |= 0x1;

                //insert the new one into the list
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            for (iCurr=0; iCurr<pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pServiceName,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                 }



                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }

                pNewVal = NULL;
                cbNewVal = 0;
            }
            break;


        case 2:
            //
            // Case 2: the service name of the SPN matches the
            // primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //

            if (fSkipDNSHostName) {
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // DNS_HOST_NAME is changed.

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pNewDNSHostName,
                                      pInstanceName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                }


                //mark old one as deleted
                pCurrentSPNMask[i] |= 0x1;

                //insert the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }

                pNewVal = NULL;
                cbNewVal = 0;
             }

            //add new spns generated from ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME

            for (iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      pInstanceName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                }


                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                //(Because the user may have deleted it intentionally.)

                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }
            break;


        case 3:
            //
            // Case 3: both the service name and the instance name
            // of the SPN matches the primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //
            if(fSkipDNSHostName){
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // DNS_HOST_NAME is changed.
                err = WrappedMakeSpnW(pTHS,
                                     pServiceClass,
                                     pNewDNSHostName,
                                     pNewDNSHostName,
                                     InstancePort,
                                     NULL,
                                     &cbNewVal,
                                     &pNewVal);
                if(err) {
                  goto cleanup;
                }

                // delete the old one
                pCurrentSPNMask[i] |= 0x1;

                // add the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            //add new spns generated from ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME

            for (iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {
                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                  goto cleanup;
                }

                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;


            }
            break;

        case 4:
            //
            // Case 4: the SPN matches the primary samAccountName.
            // We will replace the SPN
            // with one with the new samAccountName is necessary.
            // And we will make sure that the SPN that contains
            // non-deleted additionalSamAccountName won't be deleted.
            // We also construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //

            if (fSkipSamAccountName) {
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // SAM_ACCOUNT_NAME is changed
                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pNewSamAccountName,
                                      pNewSamAccountName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                    goto cleanup;
                }

                // delete the old one
                pCurrentSPNMask[i] |= 0x1;

                // add the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;

            }

            // for each newly added AdditionalDNSHostName,
            // use its derived samAccountName to construct spn.
            for (iCurr=0; iCurr<pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                      (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                  goto cleanup;
                }


                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList(pTHS,
                                              !pDataSet->pCurrMask[iCurr],
                                              pNewVal,
                                              cbNewVal,
                                              pDataSet->pCurrentSPNs,
                                              pNewSpnList,
                                              &cNewSpnList,
                                              &cAllocated,
                                              pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            break;

        default:
            Assert(!"You can't get here!\n");
            err = DB_ERR_UNKNOWN_ERROR;
            goto cleanup;
        }

     } //for


    // delete all the values marked "delete"(1) only
    for (i=0;i<pDataSet->pCurrentSPNs->valCount; i++) {
        if (1 == pCurrentSPNMask[i]) {
            DBRemAttVal_AC(pTHS->pDB,
                           pAC,
                           pDataSet->pCurrentSPNs->pAVal[i].valLen,
                           pDataSet->pCurrentSPNs->pAVal[i].pVal);
        }
    }


    // add new values
    for(i=0;i<cNewSpnList;i++) {
        if(!err) {
            err = DBAddAttVal_AC(pTHS->pDB,
                                 pAC,
                                 pNewSpnList[i].valLen,
                                 pNewSpnList[i].pVal);
            if(err == DB_ERR_VALUE_EXISTS) {
                err = 0;
                continue;
            }
            if (err) {
                goto cleanup;
            }
        }

    }


cleanup:

    for(i=0;i<cNewSpnList;i++) {
        THFreeEx(pTHS, pNewSpnList[i].pVal);
    }

    THFreeEx(pTHS, pNewSpnList);
    THFreeEx(pTHS,pCurrentSPNMask);

    if( pServiceClass ) THFreeEx(pTHS, pServiceClass);
    if( pServiceName ) THFreeEx(pTHS, pServiceName);
    if( pInstanceName ) THFreeEx(pTHS, pInstanceName);

    return err;
}



DWORD
SPNValueCheck (
        THSTATE *pTHS,
        SPN_DATA_COLLECTION * pDataSet
        )
/*++
  Description:
      Look at the value of the current ATT_SERVICE_PRINCIPAL_NAME attribute.
      Make sure that
      1) Only two part SPNs have been added or removed.
      2) If an SPN has been added or removed, it references the DNS name
         described in the original or final value of the DNS_HOST_NAME
         attribute.
         -- OR --
         it references the original or final value of ATT_SAM_ACCOUNT_NAME
            of the machine.
         -- OR --
         it references the original/final values of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
            or ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.


  Parameters:
      pTHS - thread state to use.
      pDataSet - the collection of data.

  Return value:
       0 on success, non-zero on failure.

--*/
{
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD rtn;
    DWORD minCount = 0;
    BOOL  fFound;
    BOOL *pIsInCurrent=NULL;
    DWORD err;
    USHORT InstancePort;
    DWORD  len;
    WCHAR  *pVal;
    WCHAR  *pServiceClass, *pServiceName, *pInstanceName;
    DWORD  cchServiceClass, cchServiceName, cchInstanceName;
    WCHAR  *pNewDNSHostName = NULL;
    DWORD  cchNewDNSHostName = 0;
    WCHAR  *pNewSamAccountName = NULL;
    DWORD  cchNewSamAccountName = 0;
    WCHAR  *pOldDNSHostName = NULL;
    DWORD  cchOldDNSHostName = 0;
    WCHAR  *pOldSamAccountName = NULL;
    DWORD  cchOldSamAccountName = 0;
    DWORD  OriginalSPNCount;
    DWORD  CurrentSPNCount;
    BOOL   fLegal;

    if(!pDataSet->pOriginalSPNs && !pDataSet->pCurrentSPNs) {
        // No change to SPNs
        return 0;
    }

    // Get the DNSHostNames. Check that we do indeed have a DNSHostNames.
    if(pDataSet->pCurrentDNSHostName) {
        if(pDataSet->pCurrentDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewDNSHostName = pDataSet->pCurrentDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pNewDNSHostName =  (WCHAR *)pDataSet->pCurrentDNSHostName->pAVal->pVal;
    }

    if(pDataSet->pOriginalDNSHostName) {
        if(pDataSet->pOriginalDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }


        // OK, get simpler variables to it.
        cchOldDNSHostName = pDataSet->pOriginalDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pOldDNSHostName =  (WCHAR *)pDataSet->pOriginalDNSHostName->pAVal->pVal;
    }

    // Get the SamAccountNames. Check that we do indeed have a DNSHostNames.
    if(pDataSet->pCurrentSamAccountName) {
        if(pDataSet->pCurrentSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewSamAccountName = pDataSet->pCurrentSamAccountName->pAVal->valLen / sizeof(WCHAR);
        pNewSamAccountName =  (WCHAR *)pDataSet->pCurrentSamAccountName->pAVal->pVal;
    }

    if(pDataSet->pOriginalSamAccountName) {
        if(pDataSet->pOriginalSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }


        // OK, get simpler variables to it.
        cchOldSamAccountName = pDataSet->pOriginalSamAccountName->pAVal->valLen / sizeof(WCHAR);
        pOldSamAccountName =  (WCHAR *)pDataSet->pOriginalSamAccountName->pAVal->pVal;
    }

    if(!cchOldDNSHostName && !cchNewDNSHostName &&
       !cchOldSamAccountName && !cchNewSamAccountName) {
        // No values anywhere
        return DB_ERR_NO_VALUE;
    }



    // The usual scenario for deltas is that something has been added to the end
    // of the list of things in the pCurrentSPNs, and perhaps something has been
    // removed from the pCurrentSPNs in the middle.  The following algorithm is
    // efficient for that data pattern.

    OriginalSPNCount = (pDataSet->pOriginalSPNs?pDataSet->pOriginalSPNs->valCount:0);
    CurrentSPNCount =  (pDataSet->pCurrentSPNs?pDataSet->pCurrentSPNs->valCount:0);

    pIsInCurrent = THAllocEx(pTHS, OriginalSPNCount * sizeof(DWORD));



    i=0;
    len = 128;
    pServiceClass = THAllocEx(pTHS, len);
    pServiceName  = THAllocEx(pTHS, len);
    pInstanceName = THAllocEx(pTHS, len);
    while(i < CurrentSPNCount) {
        Assert(pDataSet->pCurrentSPNs);
        j = minCount;
        fFound = FALSE;
        while(!fFound && (j < OriginalSPNCount)) {
            Assert(pDataSet->pOriginalSPNs);

            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 (WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                                 pDataSet->pCurrentSPNs->pAVal[i].valLen /sizeof(WCHAR),
                                 (WCHAR *)pDataSet->pOriginalSPNs->pAVal[j].pVal,
                                 pDataSet->pOriginalSPNs->pAVal[j].valLen /sizeof(WCHAR));

            if(rtn == 2) {
                // Found it.
                fFound = TRUE;
                pIsInCurrent[j] = TRUE;
                break;
            }
            j++;
        }


        if(!fFound) {
            // Have a value in the new list that wasnt in the old list.  Verify
            // it.

            if(len <  (pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR))) {
                // Make sure the buffers are long enough.
                len           = pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR);
                pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
                pServiceName  = THReAllocEx(pTHS, pServiceName, len);
                pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
            }

            cchServiceClass = len/sizeof(WCHAR);
            cchServiceName = len/sizeof(WCHAR);
            cchInstanceName = len/sizeof(WCHAR);
            //  Break into components
            err = DsCrackSpnW((WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                              &cchServiceClass, pServiceClass,
                              &cchServiceName,  pServiceName,
                              &cchInstanceName, pInstanceName,
                              &InstancePort);

            if(err) {
                // Huh?  Just bail
                return err;
            }
            // Only two part SPNs are legal.  Thus pServiceName == pInstanceName
            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 pServiceName,
                                 cchServiceName,
                                 pInstanceName,
                                 cchInstanceName);

            if(rtn != 2) {
                // Not a legal change.
                THFreeEx(pTHS, pIsInCurrent);
                return 1;
            }

            // Only changes that map to the current or old dnshostname or the
            // current or old SAM Account name are legal.
            if(   (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewDNSHostName,
                                       cchNewDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new dns host name.  How about the old one?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldDNSHostName,
                                       cchOldDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the old dns host name either.  How about the new sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewSamAccountName,
                                       cchNewSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new sam account name either.  How about the old sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldSamAccountName,
                                       cchOldSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))) {

                // Let's check the current AdditionaldnshostName and additionalSamAccountName

                fLegal = FALSE;

                // check in the original additionaldnshostname
                if (pDataSet->pOriginalAdditionalDNSHostName) {
                    for ( k=0; !fLegal && k < pDataSet->pOriginalAdditionalDNSHostName->valCount; k++) {
                      if ( 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                               (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].pVal,
                                               pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                               pInstanceName,
                                               cchInstanceName))
                      {
                          // yes it is legal
                          fLegal = TRUE;
                      }

                    }
                }


                // check in the current additionaldnshostname list, see if it matches any newly added name
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pCurrentAdditionalDNSHostName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalDNSHostName->valCount; k++) {
                        if (!pDataSet->pCurrMask[k]     //only the newly added ones
                            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                   (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].pVal,
                                                   pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                                   pInstanceName,
                                                   cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                    }
                }

                //check in the currentAdditionalSamAccountName list
                if (pDataSet->pCurrentAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }

                //check in the updatedAdditionalSamAccountName list
                if ( !pDataSet->fAdditionalDNSHostNameUnchanged
                     && pDataSet->pUpdatedAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pUpdatedAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }


               if (!fLegal) {
                   // Nope, not a valid name.
                   THFreeEx(pTHS, pIsInCurrent);
                   return 1;

               }

            }

            // OK, this is a legal change.

        }
        else {
            if(j == minCount) {
                minCount++;
            }
        }
        i++;
    }

    // Now, look through the originals for values not found in the current list
    for(i=minCount;i<OriginalSPNCount;i++) {
        Assert(pDataSet->pOriginalSPNs);
        if(!pIsInCurrent[i]) {
            // A value in the original is not in the current.
            if(len <  (pDataSet->pOriginalSPNs->pAVal[i].valLen + sizeof(WCHAR))) {
                // Make sure the buffers are long enough.
                len           = pDataSet->pOriginalSPNs->pAVal[i].valLen + sizeof(WCHAR);
                pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
                pServiceName  = THReAllocEx(pTHS, pServiceName, len);
                pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
            }

            cchServiceClass = len/sizeof(WCHAR);
            cchServiceName = len/sizeof(WCHAR);
            cchInstanceName = len/sizeof(WCHAR);
            //  Break into components
            err = DsCrackSpnW((WCHAR *)pDataSet->pOriginalSPNs->pAVal[i].pVal,
                              &cchServiceClass, pServiceClass,
                              &cchServiceName,  pServiceName,
                              &cchInstanceName, pInstanceName,
                              &InstancePort);

            if(err) {
                // Huh?  Just bail
                return err;
            }
            // Only two part SPNs are legal.  Thus pServiceName == pInstanceName
            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 pServiceName,
                                 cchServiceName,
                                 pInstanceName,
                                 cchInstanceName);

            if(rtn != 2) {
                // Not a legal change.
                THFreeEx(pTHS, pIsInCurrent);
                return 1;
            }

            // Only changes that map to the current or old dnshostname or the
            // current or old SAM Account name are legal.
            if(   (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewDNSHostName,
                                       cchNewDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new dns host name.  How about the old one?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldDNSHostName,
                                       cchOldDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the old dns host name either.  How about the new sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewSamAccountName,
                                       cchNewSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new sam account name either.  How about the old sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldSamAccountName,
                                       cchOldSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))) {


                // Let's check the current AdditionaldnshostName and additionalSamAccountName

                fLegal = FALSE;

                // check in the original additionaldnshostname
                if (pDataSet->pOriginalAdditionalDNSHostName) {
                    for ( k=0; !fLegal && k < pDataSet->pOriginalAdditionalDNSHostName->valCount; k++) {
                      if ( 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                               (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].pVal,
                                               pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                               pInstanceName,
                                               cchInstanceName))
                      {
                          // yes it is legal
                          fLegal = TRUE;
                      }

                    }
                }

                // check in the current additionaldnshostname list, compare those newly added ones only
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pCurrentAdditionalDNSHostName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalDNSHostName->valCount; k++) {
                        if (!pDataSet->pCurrMask[k]
                            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                   (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].pVal,
                                                   pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                                   pInstanceName,
                                                   cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                    }
                }

                //check in the currentAdditionalSamAccountName list
                if (pDataSet->pCurrentAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }

                //check in the updatedAdditionalSamAccountName list
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pUpdatedAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pUpdatedAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }


               if (!fLegal) {
                   // Nope, not a valid name.
                   THFreeEx(pTHS, pIsInCurrent);
                   return 1;

               }


            }
            // OK, this is a legal change.
        }
    }

    THFreeEx(pTHS, pIsInCurrent);

    // We didn't fail out before now, so any changes found were legal.
    return 0;
}


DWORD
DNSHostNameValueCheck (
        THSTATE *pTHS,
        ATTRVALBLOCK *pCurrentDNSHostName,
        ATTRVALBLOCK *pCurrentSamAccountName
        )
/*++
  Description:
      Look at the value of the current DNS Host name.  Make sure that it is the
      concatenation of ATT_SAM_ACCOUNT_NAME with the '$' removed, and one of the
      allowed DNS suffixes (the DNS address of the domain is always the first
      allowed suffix -- see RebuildAnchor)

  Parameters:
      pTHS - thread state to use.
      pCurrentDNSHostName - an attrvalblock containing the current dns host
             name.

  Return value:
       0 on success, non-zero on failure.

--*/
{
    DWORD err, cbSamAccountName;
    WCHAR *pSamAccountName, *pTemp;
    UNICODE_STRING ComputerName, NewHost;
    WCHAR pComputerNameString[CNLEN+1];
    DWORD cbNewHostName;
    WCHAR *pNewHostName;
    PWCHAR *curSuffix;
    BOOL matchingSuffixFound;

    // Check that we do indeed have a DNSHostName.
    if(!pCurrentDNSHostName ||
       pCurrentDNSHostName->valCount != 1 ||
       ! pCurrentDNSHostName->pAVal->valLen ) {
        // No value for DNSHost name.  Fail
        return DB_ERR_NO_VALUE;
    }

    // Check that we do indeed have a SamAccountName.
    if(!pCurrentSamAccountName ||
       pCurrentSamAccountName->valCount != 1 ||
       ! pCurrentSamAccountName->pAVal->valLen ) {
        // No value for Sam Account name.  Fail
        return DB_ERR_NO_VALUE;
    }


    // OK, get simpler variables to it.
    cbNewHostName = pCurrentDNSHostName->pAVal->valLen;
    pNewHostName =  (WCHAR *)pCurrentDNSHostName->pAVal->pVal;

    // NOTE: we expect the caller to have already stripped the '$'
    cbSamAccountName = pCurrentSamAccountName->pAVal->valLen;
    pSamAccountName = (WCHAR *)pCurrentSamAccountName->pAVal->pVal;

    // Now, get the name of the computer from the DNS Host Name.
    ComputerName.Length = 0;
    ComputerName.MaximumLength = (CNLEN+1)*sizeof(WCHAR);
    ComputerName.Buffer = pComputerNameString;

    NewHost.Length = NewHost.MaximumLength = (USHORT)cbNewHostName;
    NewHost.Buffer = pNewHostName;

    err = RtlDnsHostNameToComputerName(&ComputerName,
                                       &NewHost,
                                       FALSE);
    if(err) {
        return err;
    }

    // make sure the value == SamAccountName - $
    err = CompareStringW(DS_DEFAULT_LOCALE,
                         DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                         pSamAccountName,
                         cbSamAccountName/sizeof(WCHAR),
                         pComputerNameString,
                         ComputerName.Length/sizeof(WCHAR));

    if(err != 2) {
        return DB_ERR_UNKNOWN_ERROR;
    }


    // The right hand side (everything after the first ".") of the new DHN
    // and the old DHN are the same as the DNS name of the domain. Get pTemp to
    // point to the right place in the buffer holding the current DNSHostName.
    pTemp = pNewHostName;
    while(*pTemp != 0 && *pTemp != L'.') {
        pTemp++;
    }
    if(*pTemp == 0) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    pTemp++;

    // try to find a matching DNS suffix
    Assert(gAnchor.allowedDNSSuffixes);
    matchingSuffixFound = FALSE;
    for (curSuffix = gAnchor.allowedDNSSuffixes; *curSuffix != NULL; curSuffix++) {
        if (DnsNameCompare_W(pTemp, *curSuffix)) {
            matchingSuffixFound = TRUE;
            break;
        }
    }
    if(!matchingSuffixFound) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    return 0;
}


DWORD
AdditionalDNSHostNameValueCheck (
        THSTATE *pTHS,
        ATTRVALBLOCK *pCurrentAdditionalDNSHostName,
        BYTE * pMask
        )
/*++
  Description:
      Look at the values of the current Additional DNS Host name.  Make sure that its
      suffix matches one of the allowed DNS suffixes (the DNS address of the domain
      is always the first allowed suffix -- see RebuildAnchor)

  Parameters:
      pTHS - thread state to use.
      pCurrentAdditionalDNSHostName - an attrvalblock containing the current additional
             dns host name.
      pMask - the mask for additional dns host name, only those with !pMask[i] will be checked


  Return value:
       0 on success, non-zero on failure.

--*/
{
    WCHAR *pTemp;
    PWCHAR *curSuffix;
    BOOL matchingSuffixFound;
    DWORD i;

    for ( i=0; i<pCurrentAdditionalDNSHostName->valCount; i++ ) {
        if (!pMask[i]) {
            //new item
            pTemp = (WCHAR*)pCurrentAdditionalDNSHostName->pAVal[i].pVal;
            while(*pTemp != 0 && *pTemp != L'.') {
                pTemp++;
            }
            if(*pTemp == 0) {
                return DB_ERR_UNKNOWN_ERROR;
            }

            pTemp++;
            matchingSuffixFound = FALSE;

            for (curSuffix = gAnchor.allowedDNSSuffixes; *curSuffix != NULL; curSuffix++) {
                if (DnsNameCompare_W(pTemp, *curSuffix)) {
                    matchingSuffixFound = TRUE;
                    break;
                }
            }
            if (!matchingSuffixFound) {
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

    }

    return 0;
}

DWORD
FixupServerDnsHostName(
    THSTATE         *pTHS,                  // required
    ATTCACHE        *pAC_DHS,               // required
    ATTCACHE        *pAC_BL,                // required
    ATTRVALBLOCK    *pCurrentSvrRefBL,      // required
    ATTRVALBLOCK    *pOriginalDNSHostName,  // may be NULL
    ATTRVALBLOCK    *pCurrentDNSHostName    // may be NULL
    )
/*++

  Description:

    If ATT_DNS_HOST_NAME has changed AND (ATT_SERVER_REFERENCE_BL exists
    OR has changed) AND it references an object in the config container,
    update that object's ATT_DNS_HOST name property if it is derived from
    CLASS_SERVER.

  Arguments:

    pTHS - Valid THSTATE.

    pAC_DHS - ATTCACHE entry for ATT_DNS_HOST_NAME.

    pAC_BL - ATTCACHE entry for ATT_SERVER_REFERENCE_BL.

    pCurrentScrRefBL - Post-update value of computer's server reference BL.

    pOriginalDNSHostName - Pre-update value of computer's DNS host name.

    pCurrentDNSHostName - Post-update value of computer's DNS host name.

  Return Values:

    pTHS->errCode

--*/
{
    // See if we need to update ATT_DNS_HOST_NAME on the related
    // CLASS_SERVER object.

    DWORD       i, dwErr = 0;
    ATTRVAL     *pOriginalDHS = NULL;
    ATTRVAL     *pCurrentDHS = NULL;
    ATTRVAL     *pCurrentBL = NULL;
    CROSS_REF   *pCR;
    COMMARG     commArg;
    ATTRTYP     attrTyp;
    CLASSCACHE  *pCC;
    BOOL        fBlIsServer = FALSE;
    DBPOS       *pDB = NULL;
    BOOL        fCommit = FALSE;
    BOOL        fChanged = FALSE;

    Assert(pTHS && pAC_DHS && pAC_BL && pCurrentSvrRefBL);
    Assert((ATT_DNS_HOST_NAME == pAC_DHS->id) && (pAC_DHS->isSingleValued));
    Assert(ATT_SERVER_REFERENCE_BL == pAC_BL->id);

    if ( pOriginalDNSHostName ) {
        pOriginalDHS = (ATTRVAL *) pOriginalDNSHostName->pAVal;
    }

    if ( pCurrentDNSHostName ) {
        pCurrentDHS = (ATTRVAL *) pCurrentDNSHostName->pAVal;
    }

    if ( pCurrentSvrRefBL ) {
        pCurrentBL = (ATTRVAL *) pCurrentSvrRefBL->pAVal;
    }

    if (    (!pOriginalDHS &&  pCurrentDHS)
         || ( pOriginalDHS && !pCurrentDHS)
         || ( pOriginalDHS &&  pCurrentDHS &&
              (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                   (WCHAR *) pOriginalDHS->pVal,
                                   pOriginalDHS->valLen / sizeof(WCHAR),
                                   (WCHAR *) pCurrentDHS->pVal,
                                   pCurrentDHS->valLen / sizeof(WCHAR))) ) ) {
        // Something has changed - now see if the ATT_SERVER_REFERENCE_BL
        // we need to chase is in the config container.

        InitCommarg(&commArg);
        pCR = FindBestCrossRef((DSNAME *) pCurrentBL->pVal, &commArg);

        if (    pCR
             && gAnchor.pConfigDN
             && NameMatched(pCR->pNC, gAnchor.pConfigDN) ) {

            // Check whether the BL object is derived from CLASS_SERVER
            // and write the new value if required.  We do this in a new,
            // nested transaction so as not to disturb the existing DBPOS
            // in terms of positioning nor DBRepl state/requirements.

            DBOpen2(TRUE, &pDB);
            __try {
                // Since we're checking against the config container which
                // we know is local and since this is a back link, we
                // definitely expect the object to be found.
                if (    (dwErr = DBFindDSName(pDB,
                                              (DSNAME *) pCurrentBL->pVal))
                     || (dwErr = DBGetSingleValue(pDB, ATT_OBJECT_CLASS,
                                                  &attrTyp, sizeof(attrTyp),
                                                  NULL))
                     || !(pCC = SCGetClassById(pTHS, attrTyp)) ) {

                    // If !dwErr then this was the !pCC case.
                    if ( !dwErr ) {
                        dwErr = DIRERR_INTERNAL_FAILURE;
                    }
                    LogUnhandledError(dwErr);
                    SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                    __leave;
                }

                // Check for CLASS_SERVER.
                if ( CLASS_SERVER == pCC->ClassId ) {
                    fBlIsServer = TRUE;
                } else {
                    for ( i = 0; i < pCC->SubClassCount; i++ ) {
                        if ( CLASS_SERVER == pCC->pSubClassOf[i] ) {
                            fBlIsServer = TRUE;
                            break;
                        }
                    }
                }

                if ( !fBlIsServer ) {
                    // Nothing to do.
                    __leave;
                }

                // We are positioned on the object pointed to by
                // ATT_SERVER_REFERENCE_BL and all checks have been
                // satisfied.  Now update its ATT_DNS_HOST_NAME.
                // Keep in ming that pOriginalDHS represents the original
                // value on the computer object.  I.e. We do not know
                // whether the server object currently has a value.

                if ( pCurrentDHS ) {
                    if ( dwErr = DBReplaceAtt_AC(pDB, pAC_DHS,
                                                 pCurrentDNSHostName,
                                                 &fChanged) ) {
                        SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                        __leave;
                    }
                } else {


                    dwErr = DBRemAtt_AC(pDB, pAC_DHS);
                    if ( (dwErr != DB_success) && (dwErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) ) {
                        SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                        __leave;
                    }
                }

                if ( dwErr = DBRepl(pDB, FALSE, 0, NULL,
                                    META_STANDARD_PROCESSING) ) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                    __leave;
                }

                fCommit = TRUE;
            } __finally {
                DBClose(pDB, fCommit);
            }
        }
    }

    return(pTHS->errCode);
}

DWORD FixupAdditionalSamAccountName(  THSTATE      *pTHS,
                                      ATTCACHE     *pAC,
                                      SPN_DATA_COLLECTION * pDataSet )
/* This function will do:
    1. if a new value is added to ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME, we
       will check if the corresponding SamAccountName name is unique in
       the domain, and if yes add the samAccountName into
       ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME attribute.

    2. if a value of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is deleted, and no
       other value in ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME corresponds to its
       SamAccountName, the SamAccountName will be deleted from
       ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.

   Parameters:
    pAC:     the ATTCACHE pointer for ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;
    pDataSet: all the necessary data;

   Return value: 0 on success; win32 error otherwise.

*/
{

    DWORD i, j, iCurr;
    DWORD err = 0;
    BYTE * pSamAccountNameMask  = NULL;
    ATTRVAL * pNewSamAccountName = NULL;
    DWORD cNewSamAccountName = 0;
    BOOL fFound;
    WCHAR buff[MAX_COMPUTERNAME_LENGTH+2];

    //
    // Allocate an array of flags for pCurrentAdditionalSamAccountName list.
    // In the rest of this function, each value in pCurrentadditionalSamAccountName
    // will be examined and those that have corresponding DNSHostNames in
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME will be marked "don't delete"(2).
    // Those unmarked will be deleted from ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    //
    if (pDataSet->pCurrentAdditionalSamAccountName->valCount) {
        pSamAccountNameMask=
            THAllocEx(pTHS, sizeof(BYTE)*pDataSet->pCurrentAdditionalSamAccountName->valCount);
    }

    //
    // Allocate some space to store the values to be added to additionalsamAccountName.
    // A new SamAccountName will be be stored here temporily, and at the end, they
    // will be added to ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME attribute.
    //
    if (pDataSet->pCurrentAdditionalDNSHostName->valCount) {
        pNewSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*pDataSet->pCurrentAdditionalDNSHostName->valCount);
    }

    //
    // Loop over the current values in ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
    //
    for( iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++ )
    {
        fFound = FALSE;

        //
        // Search in the current values of ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME
        //
        for (j = 0; j < pDataSet->pCurrentAdditionalSamAccountName->valCount; j++) {

            if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                    pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen/sizeof(WCHAR),
                                    (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[j].pVal,
                                    pDataSet->pCurrentAdditionalSamAccountName->pAVal[j].valLen/sizeof(WCHAR)) ) {

                // Already there, mark it as "don't delete",
                // So this item will not be deleted later.
                pSamAccountNameMask[j] |= 0x2;
                fFound = TRUE;
                break;
            }
        }

        //  Yes, the value exists.
        //  Try next one.
        if (fFound) {
            continue;
        }

        // Let's try to find it in the new samAccountName list
        for (i=0; i<cNewSamAccountName; i++) {
            if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                    pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen/sizeof(WCHAR),
                                    (WCHAR*)pNewSamAccountName[i].pVal,
                                    pNewSamAccountName[i].valLen/sizeof(WCHAR) ) ) {
                fFound = TRUE;
                break;

            }
        }

        // Yes, it is already in the new samAccountName list
        // try next one.
        if (fFound) {
            continue;
        }

        //
        // This is a new value.  Before we add it into the list,
        // Let's check if it is unique domainwise in the space
        // of ATT_SAM_ACCOUNT_NAME and ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
        //
        err = VerifyUniqueSamAccountName( pTHS,
                                          (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                          pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen,
                                          pDataSet->pCurrentSamAccountName );

        if (err) {
            goto goodbye;
        }

        //
        // add to the new list
        //
        Assert(cNewSamAccountName<pDataSet->pCurrentAdditionalDNSHostName->valCount);

        pNewSamAccountName[cNewSamAccountName] = pDataSet->pCurrGeneratedSamAccountName[iCurr];
        cNewSamAccountName++;


    } //for

    //
    // delete those that are not marked, since no value in
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME corresponds to it.
    //
    for( i = 0; i < pDataSet->pCurrentAdditionalSamAccountName->valCount; i++ )
    {
        if ( !pSamAccountNameMask[i] ) {

            // it could be with or without '$' at the end
            // delete them both.
            swprintf(buff,L"%s$",pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].pVal);

            DBRemAttVal_AC(pTHS->pDB,
                           pAC,
                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen+sizeof(WCHAR),
                           buff);

            DBRemAttVal_AC(pTHS->pDB,
                           pAC,
                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen,
                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].pVal);


        }

    }

    //
    // add new ones
    //
    for (i=0; i < cNewSamAccountName; i ++) {

        // add '$' to the end
        swprintf(buff,L"%s$",pNewSamAccountName[i].pVal);

        err = DBAddAttVal_AC(pTHS->pDB,
                             pAC,
                             pNewSamAccountName[i].valLen+sizeof(WCHAR),
                             buff );

        if (DB_ERR_VALUE_EXISTS==err) {
            err = 0;
            continue;
        }
        if (err) {
            goto goodbye;
        }
    }

goodbye:

    if (pSamAccountNameMask) {
        THFreeEx(pTHS, pSamAccountNameMask);
    }

    THFreeEx(pTHS, pNewSamAccountName);

    return err;

}



DWORD
ValidateSPNsAndDNSHostName (
        THSTATE    *pTHS,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        BOOL       fCheckDNSHostNameValue,
        BOOL       fCheckAdditionalDNSHostNameValue,
        BOOL       fCheckSPNValues,
        BOOL       fNewObject
        )
/*++
  Description:
      This routine does a few things for computer objects (or objects descended from
      computers), but only if this isn't the DRA or SAM.  It is expected to be
      called after modifications are done during a local modify, but before the
      object has been updated to the DB.

      1) If told to check the DNSHostNameValue, calls the routine that verifies
      the ATT_DNS_HOST_NAME has only changed in legal ways. (See
      DNSHostNameValueCheck(), above.)

      2) If told to check the AdditionalDNSHostNameValue, calls the routine
      that verifies the ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME has only changed
      in legal ways. (See AdditionalDNSHostNameValueCheck(), above.)

      3) If told to check the SPNValues, calls the routine that verifies
      the ATT_SERVICE_PRINCIPAL_NAME attribute has only changed in legal
      ways. (See SPNValueCheck(), above.)

      4) Derive the corresponding ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME from
      ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME; Delete the obsolete values.
      (see FixupAdditionalSamAccountName, above.)

      5) Update the values of ATT_SERVICE_PRINCIPAL_NAME based on the
      current value of ATT_DNS_HOST_NAME and ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
      (see FixupSPNValues() above.)

      6) If ATT_DNS_HOST_NAME has changed AND (ATT_SERVER_REFERENCE_BL exists
      OR has changed) AND it references an object in the config container,
      update that object's ATT_DNS_HOST name property if it is derived from
      CLASS_SERVER.

      NOTE:  We are told to check DNSHostName value if the caller failed the
      security check for modifying the DNSHostName, but was granted a specific
      control access right that allows limited modifications anyway.  The same
      goes for check SPNValues and AdditionalDNSHostName.

  Parameters:
      pTHS - the thread state.
      pDN  - DN of the object being changed.
      pCC  - classcache of the class of the object being changed.
      fCheckDNSHostNameValue - should I check the ATT_DNS_HOST_NAME?
      fCheckAdditionalDNSHostNameValue - should I check the
                                    ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
      fCheckSPNValues - should I check the ATT_SERVICE_PRINCIPAL_NAME
      fNewObject - If this object is newly added

  Return Values:
      0 on success, an error otherwise.  Also, the error is set in the thread
      state.
--*/
{
    ATTCACHE     *ACs[6];
    ATTR         *pOriginalAttr=NULL;
    ATTR         *pCurrentAttr=NULL;
    ATTR         *pUpdatedAttr=NULL;
    DWORD         cOriginalOut=0;
    DWORD         cCurrentOut=0;
    DWORD         cUpdatedOut=0;
    DWORD         i, j, rtn, err, iClass;

    SPN_DATA_COLLECTION DataSet;

    DWORD        length;
    DWORD        iOrg, iCurr;

    DWORD        UF_Control;

    if ( pTHS->fDRA ) {
        // Replication is allowed to perform modifications that violate the
        // spn/dns host name consistancy restritctions.
        return(0);
    }

    // N.B. We must do the checks in the fSAM case because:
    //
    // 1) A change to ATT_SAM_ACCOUNT_NAME is ultimately performed by SAM
    //    via loopback, yet we want to update SAM account name dependent SPNs.
    //
    // 2) In the loopback case, the core DS merges in non-SAM attributes on
    //    the first SAM write.  Eg: If the external client writes the SAM
    //    account name and the display name in the same call, this will come
    //    in on the same DirModifyEntry call to the DS.
    //
    // Thus there is no notion that if fSAM is set, then only SAM attributes
    // are referenced.

    // If this isn't a computer object, just leave.

    // Computers of any stripe are security principals which are SAM objects.
    if ( !SampSamClassReferenced(pCC, &iClass) ) {
        return(0);
    }

    // CLASS_USER is a "computer" when the right account control bits are set.
    switch( SampDeriveMostBasicDsClass(pCC->ClassId) ) {
    case CLASS_COMPUTER:
        break;
    case CLASS_USER:
        if ( err = DBGetSingleValue(pTHS->pDB, ATT_USER_ACCOUNT_CONTROL,
                                    &UF_Control, sizeof(UF_Control), NULL) ) {
            //Hmm, not there. How come?
            //Assert(!"Trouble with accessing ATT_USER_ACCOUT_CONTROL on a computer object");
            return(0);
        }
        if (    !(UF_WORKSTATION_TRUST_ACCOUNT & UF_Control)
             && !(UF_SERVER_TRUST_ACCOUNT & UF_Control) ) {
            return(0);
        }

        break;
    default:
        return(0);
    }

    memset(&DataSet,0,sizeof(DataSet));

    ACs[0] = SCGetAttById(pTHS, ATT_DNS_HOST_NAME);
    ACs[1] = SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME);
    ACs[2] = SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
    ACs[3] = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME);
    ACs[4] = SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME);
    ACs[5] = SCGetAttById(pTHS, ATT_SERVER_REFERENCE_BL);

    // Now, get various properties from the current object (i.e. after mods
    // have been applied.)  In this case we do want the server reference BL
    // therefore att count is 6.
    if (err=DBGetMultipleAtts(pTHS->pDB,
                              6,
                              ACs,
                              NULL,
                              NULL,
                              &cCurrentOut,
                              &pCurrentAttr,
                              DBGETMULTIPLEATTS_fEXTERNAL,
                              0)) {

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
    }

    // Now, get the dnshostname and service principal names from the original
    // object (i.e. before mods have been applied.), if this object is not newly
    // added, in which case there is no original value.
    // Now, get various properties from the original object (i.e. before mods
    // have been applied.)  In this case we do not want the server reference BL
    // since you can't change the BL on an originating write to this object.
    // Therefore att count is 4.
    if (!fNewObject &&
        (err=DBGetMultipleAtts(pTHS->pDB,
                               4,
                               ACs,
                               NULL,
                               NULL,
                               &cOriginalOut,
                               &pOriginalAttr,
                               (DBGETMULTIPLEATTS_fOriginalValues |
                                DBGETMULTIPLEATTS_fEXTERNAL  ),
                               0))) {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
    }

    // Get pointers to the individual AttrTypes;
    // NOTE: Values stored in the DS are not NULL terminated.  However, most of
    // the processing here requires that the values be NULL terminated.  So,
    // we're going to extend the buffers and null terminate everything.
    for(i=0;i<cCurrentOut;i++) {
        switch(pCurrentAttr[i].attrTyp) {
        case ATT_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pCurrentSamAccountName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pCurrentSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;

        case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pCurrentAdditionalSamAccountName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pCurrentAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;


        case ATT_DNS_HOST_NAME:
            DataSet.pCurrentDNSHostName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentDNSHostName->valCount;j++) {
                DataSet.pCurrentDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentDNSHostName->pAVal[j].pVal,
                                (DataSet.pCurrentDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;


        case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
            DataSet.pCurrentAdditionalDNSHostName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentAdditionalDNSHostName->valCount;j++) {
                DataSet.pCurrentAdditionalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentAdditionalDNSHostName->pAVal[j].pVal,
                                (DataSet.pCurrentAdditionalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_SERVICE_PRINCIPAL_NAME:
            DataSet.pCurrentSPNs = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentSPNs->valCount;j++) {
                DataSet.pCurrentSPNs->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentSPNs->pAVal[j].pVal,
                                (DataSet.pCurrentSPNs->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_SERVER_REFERENCE_BL:
            DataSet.pCurrentSvrRefBL = &pCurrentAttr[i].AttrVal;
            // Extension with NULL terminator not required.
            break;

        default:
            // Huh?
            LogUnhandledError(pCurrentAttr[i].attrTyp);
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_COULDNT_UPDATE_SPNS,
                                 pCurrentAttr[i].attrTyp);
        }
    }

    for(i=0;i<cOriginalOut;i++) {
        switch(pOriginalAttr[i].attrTyp) {
        case ATT_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pOriginalSamAccountName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pOriginalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;

        case ATT_DNS_HOST_NAME:
            DataSet.pOriginalDNSHostName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalDNSHostName->valCount;j++) {
                DataSet.pOriginalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalDNSHostName->pAVal[j].pVal,
                                (DataSet.pOriginalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
            DataSet.pOriginalAdditionalDNSHostName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalAdditionalDNSHostName->valCount;j++) {
                DataSet.pOriginalAdditionalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalAdditionalDNSHostName->pAVal[j].pVal,
                                (DataSet.pOriginalAdditionalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;


        case ATT_SERVICE_PRINCIPAL_NAME:
            DataSet.pOriginalSPNs =  &pOriginalAttr[i].AttrVal;;
            for(j=0;j<DataSet.pOriginalSPNs->valCount;j++) {
                DataSet.pOriginalSPNs->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalSPNs->pAVal[j].pVal,
                                (DataSet.pOriginalSPNs->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        default:
            // Huh?
            LogUnhandledError(pOriginalAttr[i].attrTyp);
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_COULDNT_UPDATE_SPNS,
                                 pOriginalAttr[i].attrTyp);
        }
    }

    // sanity check
    if ( !DataSet.pCurrentSamAccountName ) {
        Assert(!"Empty Sam Account Name!\n");

        return  SetAttError(pDN,
                            ATT_SAM_ACCOUNT_NAME,
                            PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                            NULL,
                            DIRERR_BAD_ATT_SYNTAX);

    }


    // if the attributes don't have value, we will allocate an ATTRVALBLOCK for
    // it anyway, so the handling will be uniform.

    if (!DataSet.pOriginalAdditionalDNSHostName) {
        DataSet.pOriginalAdditionalDNSHostName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }
    if (!DataSet.pCurrentAdditionalDNSHostName) {
        DataSet.pCurrentAdditionalDNSHostName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }

    if (!DataSet.pCurrentAdditionalSamAccountName) {
        DataSet.pCurrentAdditionalSamAccountName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }


    //
    // Calculate which values of additional dns host name were added,
    // and which were deleted.
    // For the original ones, pOrgMask[i]=0 means the name is deleted;
    // for the current ones, pCurrMask[i]=0 means the name is newly added.
    //

    if (DataSet.pOriginalAdditionalDNSHostName->valCount) {
        DataSet.pOrgMask =
            THAllocEx(pTHS,sizeof(BYTE)*DataSet.pOriginalAdditionalDNSHostName->valCount);
    }

    if (DataSet.pCurrentAdditionalDNSHostName->valCount) {
        DataSet.pCurrMask =
            THAllocEx(pTHS,sizeof(BYTE)*DataSet.pCurrentAdditionalDNSHostName->valCount);
    }

    for (iOrg = 0; iOrg < DataSet.pOriginalAdditionalDNSHostName->valCount; iOrg++) {

        for(iCurr = 0; iCurr < DataSet.pCurrentAdditionalDNSHostName->valCount; iCurr++){

            if(0 == DataSet.pCurrMask[iCurr]
               && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                      DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                      (WCHAR*)DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                      DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].valLen/sizeof(WCHAR),
                                      (WCHAR*)DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].valLen/sizeof(WCHAR))) {
            // The name is in both original and current AdditionalDNSHostName, mark it.
            DataSet.pOrgMask[iOrg] = DataSet.pCurrMask[iCurr] = 1;
            break;
            }

        }

    }


    //
    // check if anything changed for ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
    //

    // same size?
    DataSet.fAdditionalDNSHostNameUnchanged =
        (DataSet.pOriginalAdditionalDNSHostName->valCount==DataSet.pCurrentAdditionalDNSHostName->valCount) ;


    // check if any name in Original ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is deleted
    for ( iOrg = 0;
          DataSet.fAdditionalDNSHostNameUnchanged && iOrg <DataSet.pOriginalAdditionalDNSHostName->valCount;
          iOrg++ )
    {
        if (!DataSet.pOrgMask[iOrg]) {
            DataSet.fAdditionalDNSHostNameUnchanged = FALSE;
        }
    }

    // check if any name in Current ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is newly added
    for ( iCurr = 0;
          DataSet.fAdditionalDNSHostNameUnchanged && iCurr <DataSet.pCurrentAdditionalDNSHostName->valCount;
          iCurr++ )
    {
        if (!DataSet.pCurrMask[iCurr]) {
            DataSet.fAdditionalDNSHostNameUnchanged = FALSE;
        }
    }


    //
    // We don't allow the change of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME in W2K domain mode
    //

    if (   !DataSet.fAdditionalDNSHostNameUnchanged
        && gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WHISTLER ) {
        rtn =  SetAttError(pDN,
                           ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           ERROR_DS_NOT_SUPPORTED);

        goto cleanup;
    }


    //
    // check if ATT_DNS_HOST_NAME is changed
    //

    if (   (    DataSet.pOriginalDNSHostName != NULL
            &&  DataSet.pCurrentDNSHostName != NULL
            &&  2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)DataSet.pOriginalDNSHostName->pAVal[0].pVal,
                                    DataSet.pOriginalDNSHostName->pAVal[0].valLen/sizeof(WCHAR),
                                    (WCHAR*)DataSet.pCurrentDNSHostName->pAVal[0].pVal,
                                    DataSet.pCurrentDNSHostName->pAVal[0].valLen/sizeof(WCHAR))
            )
         || (DataSet.pOriginalDNSHostName == DataSet.pCurrentDNSHostName) ) {

        DataSet.fDNSHostNameUnchanged = TRUE;
    }
    else {
        DataSet.fDNSHostNameUnchanged = FALSE;
    }



    //
    // check if ATT_SAM_ACCOUNT_NAME is changed
    //

    if (        DataSet.pOriginalSamAccountName != NULL
            &&  DataSet.pCurrentSamAccountName != NULL
            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                   (WCHAR*)DataSet.pOriginalSamAccountName->pAVal[0].pVal,
                                   DataSet.pOriginalSamAccountName->pAVal[0].valLen/sizeof(WCHAR),
                                   (WCHAR*)DataSet.pCurrentSamAccountName->pAVal[0].pVal,
                                   DataSet.pCurrentSamAccountName->pAVal[0].valLen/sizeof(WCHAR)) )
    {

        DataSet.fSamAccountNameUnchanged = TRUE;
    }
    else {
        DataSet.fSamAccountNameUnchanged = FALSE;
    }


    //
    // First, check if the change of ATT_DNS_HOST_NAME is legitimiate if required.
    //

    if(fCheckDNSHostNameValue) {
        err = DNSHostNameValueCheck(pTHS,
                                    DataSet.pCurrentDNSHostName,
                                    DataSet.pCurrentSamAccountName );

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_DNS_HOST_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }

    //
    // Then, check the ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME if required.
    //

    if(    fCheckAdditionalDNSHostNameValue
        && !DataSet.fAdditionalDNSHostNameUnchanged ) {
        err = AdditionalDNSHostNameValueCheck(pTHS,
                                              DataSet.pCurrentAdditionalDNSHostName,
                                              DataSet.pCurrMask );

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }


    //
    // Now generate a sam account name for each name in additionalDNSHostName
    // and cache them for later use.  There are two places we will use it:
    // FixupAdditionalSamAccountName() and FixupSPNsOnComputerObject().
    //

    if (DataSet.pOriginalAdditionalDNSHostName->valCount) {
        DataSet.pOrgGeneratedSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*DataSet.pOriginalAdditionalDNSHostName->valCount);
    }
    if (DataSet.pCurrentAdditionalDNSHostName->valCount) {
        DataSet.pCurrGeneratedSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*DataSet.pCurrentAdditionalDNSHostName->valCount);
    }

    for (iOrg=0; iOrg<DataSet.pOriginalAdditionalDNSHostName->valCount; iOrg++) {

        DataSet.pOrgGeneratedSamAccountName[iOrg].pVal =
            THAllocEx(pTHS,(MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR) );

        length = MAX_COMPUTERNAME_LENGTH+1;

        // we only need to use those deleled ones
        if (!DataSet.pOrgMask[iOrg] &&
            !DnsHostnameToComputerNameW((WCHAR*)DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                        (WCHAR*)DataSet.pOrgGeneratedSamAccountName[iOrg].pVal,
                                         &length ))
        {
            rtn = SetSvcError(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE);
            goto cleanup;
        }
        DataSet.pOrgGeneratedSamAccountName[iOrg].valLen = length * sizeof(WCHAR);
    }

    for (iCurr=0; iCurr < DataSet.pCurrentAdditionalDNSHostName->valCount; iCurr++) {

        DataSet.pCurrGeneratedSamAccountName[iCurr].pVal =
            THAllocEx(pTHS,(MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR) );

        length = MAX_COMPUTERNAME_LENGTH+1;

        if (!DnsHostnameToComputerNameW((WCHAR*)DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                        (WCHAR*)DataSet.pCurrGeneratedSamAccountName[iCurr].pVal,
                                        &length ))
        {
            rtn = SetSvcError(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE);
            goto cleanup;
        }
        DataSet.pCurrGeneratedSamAccountName[iCurr].valLen = length * sizeof(WCHAR);
    }


    //
    // ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME is generated from
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME.
    // Now fix up ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    //

    err = FixupAdditionalSamAccountName(pTHS,
                                        ACs[4],     //ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME
                                        &DataSet );

    if(err) {

        rtn =  SetAttError(pDN,
                           ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           DIRERR_BAD_ATT_SYNTAX);

        goto cleanup;

    }


    //
    // Now, check the SPN values.
    //

    if(fCheckSPNValues) {

        // ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME could be updated in
        // FixupAdditionalSamAccountName(). We will need the updated
        // values when checking the SPN values.

        if (!DataSet.fAdditionalDNSHostNameUnchanged) {
            if (err=DBGetMultipleAtts(pTHS->pDB,
                                      1,
                                      &(ACs[4]),
                                      NULL,
                                      NULL,
                                      &cUpdatedOut,
                                      &pUpdatedAttr,
                                      DBGETMULTIPLEATTS_fEXTERNAL,
                                      0)) {

                 rtn =  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                      ERROR_DS_COULDNT_UPDATE_SPNS,
                                      err);
                 goto cleanup;
             }

            for (i=0;i<cUpdatedOut; i++) {

              if( pUpdatedAttr->attrTyp==ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME ){

                // NOTE: not only null terminate, but trim any trailing '$'
                DataSet.pUpdatedAdditionalSamAccountName = &pUpdatedAttr[i].AttrVal;
                for(j=0;j<DataSet.pUpdatedAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pUpdatedAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                    if(PWVAL[CCHVAL - 1] == L'$') {
                        PWVAL[CCHVAL - 1] = 0;
                        PAVAL.valLen -= sizeof(WCHAR);
                    }
                    else {
                        PWVAL = THReAllocEx(pTHS,
                                            PWVAL,
                                            PAVAL.valLen + sizeof(WCHAR));
                    }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
                }
                break;

              }

            }
        } // end of "if (!DataSet.fAdditionalDNSHostNameUnchanged)"


        // check if the SPN change is legitimate
        err = SPNValueCheck(pTHS,
                            &DataSet);

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_SERVICE_PRINCIPAL_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }



    //
    // A SPN is based on ATT_DNS_HOST_NAME, ATT_SAM_ACCOUNT_NAME,
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME, or ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    // If any of these attributes is changed, the ATT_SERVICE_PRINCIPAL_NAME
    // attribute need to be updated.
    // Now, fixup the SPNs.
    //

    err = FixupSPNsOnComputerObject(pTHS,
                                    pDN,
                                    pCC,
                                    &DataSet );


    if(err) {
        rtn =  SetSvcErrorEx(SV_PROBLEM_BUSY,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
        goto cleanup;
    }

    //
    // Fixup DNS host name on referenced server object if req'd.
    //

    if ( DataSet.pCurrentSvrRefBL ) {
        if ( err = FixupServerDnsHostName(pTHS, ACs[0], ACs[5],
                                          DataSet.pCurrentSvrRefBL,
                                          DataSet.pOriginalDNSHostName,
                                          DataSet.pCurrentDNSHostName) )  {
            // ValidateServerReferenceBL sets pTHS->errCode itself.
            rtn = err;
            goto cleanup;
        }
    }


    //
    // All went well.
    //
    rtn = 0;



cleanup:

    if (DataSet.pCurrGeneratedSamAccountName) {
        for (i=0;i<DataSet.pCurrentAdditionalDNSHostName->valCount;i++) {
            if (DataSet.pCurrGeneratedSamAccountName[i].pVal)
            {
                THFreeEx(pTHS,DataSet.pCurrGeneratedSamAccountName[i].pVal);
            }

        }
        THFreeEx(pTHS,DataSet.pCurrGeneratedSamAccountName);
    }

    if (DataSet.pOrgGeneratedSamAccountName) {
        for (j=0;j<DataSet.pOriginalAdditionalDNSHostName->valCount;j++) {
            if (DataSet.pOrgGeneratedSamAccountName[j].pVal)
            {
                THFreeEx(pTHS,DataSet.pOrgGeneratedSamAccountName[j].pVal);
            }

        }
        THFreeEx(pTHS,DataSet.pOrgGeneratedSamAccountName);
    }

    if (DataSet.pCurrMask) {
        THFreeEx(pTHS,DataSet.pCurrMask);
    }

    if (DataSet.pOrgMask) {
        THFreeEx(pTHS,DataSet.pOrgMask);

    }

    return rtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\parsedn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       parsedn.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file is compiled into ntdsa.dll and is included in ntdsapi\parsedn.c.

    This module collects in one place all DN parsing and helper routines
    so that they can be used by the core and compiled in src\ntdsapi.
    As such, these routines should not log events, depend on THSTATE, etc.
    They should stand on their own with no environmental dependencies.

    Routine that are exported out of the core dll are marked as follows:
N.B. This routine is exported to in-process non-module callers

Author:

    Dave Straube    (davestr)   26-Oct-97

Revision History:

    Dave Straube    (davestr)   26-Oct-97
        Genesis - no new code, just repackaging from mdname.c.
    Aaron Siegel    (t-asiege)  24-Jul-98
        Brought NameMatched () here from mdname.c.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "PARSEDN:"           // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PARSEDN


#define KEY_COMMONNAME L"CN"
#define KEY_LOCALITYNAME L"L"
#define KEY_STATEORPROVINCENAME L"ST"
#define KEY_ORGANIZATIONNAME L"O"
#define KEY_ORGANIZATIONALUNITNAME L"OU"
#define KEY_COUNTRYNAME L"C"
#define KEY_STREETADDRESS L"STREET"
#define KEY_DOMAINCOMPONENT L"DC"

#define WCCNT(x) ((sizeof(x) - sizeof(WCHAR))/sizeof(WCHAR))

// Size in characters of tags (e.g., "DEL", "CNF") embedded in mangled RDNs.
#define MANGLE_TAG_LEN  (3)

// Size in characters of string (e.g.,
// "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8", where # is BAD_NAME_CHAR)
// appended to an RDN by MangleRDN().
#define MANGLE_APPEND_LEN   (1 + MANGLE_TAG_LEN + 1 + 36)

// This constant is the number of characters of an RDN that we will keep when we
// mangle an RDN.
// (MAX_MANGLE_RDN_BASE + MANGLE_APPEND_LEN)*sizeof(WCHAR) + JET_CRUD <=
//                                           JET_cbKeyMost
// JET_CRUD is space for a DWORD overhead for constructing a key.  This is
// necessary because mangled names have to be used as RDNs, and RDNs must have
// unique keys in the PDNT-RNDN index.
#define MAX_MANGLE_RDN_BASE 75

unsigned
AttrTypeToKeyLame (
        ATTRTYP attrtyp,
        WCHAR *pOutBuf
        )
/*++
Routine Description:
    Translates an attrtype to a well known key value (primarily used in string
    representations of DNs e.g. O or OU of OU=Foo,O=Bar).

Arguments
    attrtyp - the attrtyp to translate from.
    pOutBuf - preallocated buffer to copy the key to.  Must be long enough
              for (MAX_RDN_KEY_SIZE - 1) wchars.

Return Values
    the count of charactes in the key the attrtyp implied, or 0 if the attrtyp
    did not have a known key.
--*/
{

#ifndef CLIENT_SIDE_DN_PARSING
#ifdef INCLUDE_UNIT_TESTS
{
    extern DWORD dwUnitTestIntId;
    // always generate IID-syntaxed DNs
    if (dwUnitTestIntId == 1) {
        return (AttrTypeToIntIdString(attrtyp, pOutBuf, MAX_RDN_KEY_SIZE));
    }
}
#endif INCLUDE_UNIT_TESTS
#endif !CLIENT_SIDE_DN_PARSING

    switch (attrtyp) {
        case ATT_COMMON_NAME:
            memcpy(pOutBuf,
                   KEY_COMMONNAME,
                   sizeof(WCHAR)*WCCNT(KEY_COMMONNAME));
            return WCCNT(KEY_COMMONNAME);
            break;

        case ATT_LOCALITY_NAME:
            memcpy(pOutBuf,
                   KEY_LOCALITYNAME,
                   sizeof(WCHAR)*WCCNT(KEY_LOCALITYNAME));
            return WCCNT(KEY_LOCALITYNAME);
            break;

        case ATT_STATE_OR_PROVINCE_NAME:
            memcpy(pOutBuf,
                   KEY_STATEORPROVINCENAME,
                   sizeof(WCHAR)*WCCNT(KEY_STATEORPROVINCENAME));
            return WCCNT(KEY_STATEORPROVINCENAME);
            break;

        case ATT_STREET_ADDRESS:
            memcpy(pOutBuf,
                   KEY_STREETADDRESS,
                   sizeof(WCHAR)*WCCNT(KEY_STREETADDRESS));
            return WCCNT(KEY_STREETADDRESS);
            break;

        case ATT_ORGANIZATION_NAME:
            memcpy(pOutBuf,
                   KEY_ORGANIZATIONNAME,
                   sizeof(WCHAR)*WCCNT(KEY_ORGANIZATIONNAME));
            return WCCNT(KEY_ORGANIZATIONNAME);
            break;

        case ATT_ORGANIZATIONAL_UNIT_NAME:
            memcpy(pOutBuf,
                   KEY_ORGANIZATIONALUNITNAME,
                   sizeof(WCHAR)*WCCNT(KEY_ORGANIZATIONALUNITNAME));
            return WCCNT(KEY_ORGANIZATIONALUNITNAME);
            break;

        case ATT_COUNTRY_NAME:
            memcpy(pOutBuf,
                   KEY_COUNTRYNAME,
                   sizeof(WCHAR)*WCCNT(KEY_COUNTRYNAME));
            return WCCNT(KEY_COUNTRYNAME);
            break;

        case ATT_DOMAIN_COMPONENT:
            memcpy(pOutBuf,
                   KEY_DOMAINCOMPONENT,
                   sizeof(WCHAR)*WCCNT(KEY_DOMAINCOMPONENT));
            return(WCCNT(KEY_DOMAINCOMPONENT));
            break;

        default:;
    }
    return 0;
}

unsigned
AttrTypeToKey (
        ATTRTYP attrtyp,
        WCHAR *pOutBuf
        )
/*++
Routine Description:
    Translates an attrtype to a key value (primarily used in string
    representations of DNs e.g. O or OU of OU=Foo,O=Bar). Note that if no string
    key is known, this routine builds a key of the format "OID.X.Y.Z" where
    X.Y.Z is the unencoded OID.

Arguments
    attrtyp - the attrtyp to translate from.
    pOutBuf - preallocated buffer to copy the key to. Must be at
              least MAX_RDN_KEY_SIZE wide chars in length.

Return Values
    the count of charactes in the key the attrtyp implied, or 0 if the attrtyp
    did not have a known key.

N.B. This routine is exported to in-process non-module callers
--*/
{
    DWORD       nChars;
    ATTCACHE    *pAC;
    THSTATE     *pTHS;

    if (0 != (nChars = AttrTypeToKeyLame(attrtyp, pOutBuf))) {
        return nChars;
    }
#ifdef CLIENT_SIDE_DN_PARSING
    return 0;
#else CLIENT_SIDE_DN_PARSING

    // Legacy check. Is this possible?
    if (NULL == (pTHS = pTHStls)) {
        return 0;
    }

    // Ok, this is an att that we have no tag for.
    // Try to fetch the ldap display name from the scache.
    //
    // Handle DNs of the form foo=xxx,bar=yyy, where foo and bar are the
    // LdapDisplayNames of arbitrary attributes that may or may not be
    // defined in the schema. KeyToAttrType is enhanced to call
    // SCGetAttByName if KeyToAttrTypeLame fails, and before trying the
    // OID decode.  The rest of this change consists of enhancing the
    // default clause of AttrTypeToKey to call SCGetAttById and to return
    // a copy of the pAC->name (LdapDisplayName).
    if (   (pAC = SCGetAttById(pTHS, attrtyp))
        && (pAC->nameLen)
        && (pAC->name) ) {
        // Convert cached ldap display name (UTF8) into UNICODE
        // Note: the scache is kept in UTF8 format for the ldap head.
        if (0 != (nChars = MultiByteToWideChar(CP_UTF8,
                                               0,
                                               pAC->name,
                                               pAC->nameLen,
                                               pOutBuf,
                                               MAX_RDN_KEY_SIZE))) {
            return nChars;
        }
        // LDN too long; FALL THRU
    }

    // Express in IID format
    // Never too long because "IID.32bit-decimal" fits in MAX_RDN_KEY_SIZE
    return (AttrTypeToIntIdString(attrtyp, pOutBuf, MAX_RDN_KEY_SIZE));
#endif CLIENT_SIDE_DN_PARSING
}


ATTRTYP
KeyToAttrTypeLame(
        WCHAR * pKey,
        unsigned cc
        )
/*++
Routine Description:
    Translates a key value (primarily used in string representations of DNs
    e.g. O or OU of OU=Foo,O=Bar) to the attrtype for the attribute it implies.

    Doesn't handle OID.X.Y.Z or IID.X

Arguments
    pKey - pointer to the key to be translated from.
    cc - count of charactes in the key.

Return Values
    the attrtyp implied, or 0 if the key did not correspond to a known attrtyp.
--*/
{
    WCHAR wch;

    if (cc ==0 || pKey == NULL) {
        return 0;
    }

    // ignore trailing spaces
    while (cc && pKey[cc-1] == L' ') {
	    --cc;
    }

    switch (*pKey) {
    case L'C':        // C or CN
    case L'c':

        // KEY_COMMONNAME: CN
        if ((cc == WCCNT(KEY_COMMONNAME)) &&
                 ((wch = *(++pKey)) == L'N' || (wch == L'n')) )  {
            return ATT_COMMON_NAME;
        }
        // KEY_COUNTRYNAME: C
        else if ( cc == WCCNT(KEY_COUNTRYNAME) ) {
            return ATT_COUNTRY_NAME;
        }

        return 0;

    case L'D':        // DC
    case L'd':

        // KEY_DOMAINCOMPONENT: DC
        if ((cc == WCCNT(KEY_DOMAINCOMPONENT)) &&
            ((wch = *(++pKey)) == L'C' || (wch == L'c')) )  {

            return(ATT_DOMAIN_COMPONENT);
        }

        return 0;
	
    case L'O':        // O, OU, or OID
    case L'o':

        // KEY_ORGANIZATIONALUNITNAME: OU
        if ((cc == WCCNT(KEY_ORGANIZATIONALUNITNAME)) &&
                 ((wch = *(++pKey)) == L'U' || (wch == L'u')) ) {
            return ATT_ORGANIZATIONAL_UNIT_NAME;
        }
        // KEY_ORGANIZATIONNAME: O
        else if (cc == WCCNT(KEY_ORGANIZATIONNAME)) {
            return ATT_ORGANIZATION_NAME;
        }

        // Note that this could have been an OID, which the real
        // KeyToAttrType must handle
        return 0;

    case L'S':        // ST or STREET
    case L's':
	
        if ( (cc == WCCNT(KEY_STATEORPROVINCENAME)) &&
              ((wch = *(++pKey)) == L'T' || (wch == L't')) ) {
                return ATT_STATE_OR_PROVINCE_NAME;
        }
        else if ( (cc == WCCNT(KEY_STREETADDRESS)) &&
                  (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    pKey,
                                    cc,
                                    KEY_STREETADDRESS,
                                    cc) ) ) {

            return ATT_STREET_ADDRESS;
        }

        return 0;

    case L'L':        // L
    case L'l':
        if (cc == 1) {
            return ATT_LOCALITY_NAME;
        }
    }

    return 0;           // failure case
}


// A collection of macros, tiny functions, and definitions to help
// collect all DN special character processing.

/*++IsSpecial
 *
 * Returns TRUE if the character passed in is one of the designated
 * "special" characters in string DNs.
 *
 * N.B.  This routine must be kept in sync with the definition of
 *       DN_SPECIAL_CHARS in dsatools.h.
 *
 * The special characters are: \n \r \" # + , ; < = > \\
 *
 */

static char ___isspecial[128] =
//   0  1  2  3  4  5  6  7  8  9
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   0
     1, 0, 0, 1, 0, 0, 0, 0, 0, 0,  //   1
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   2
     0, 0, 0, 0, 1, 1, 0, 0, 0, 0,  //   3
     0, 0, 0, 1, 1, 0, 0, 0, 0, 0,  //   4
     0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  //   5
     1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  //   6
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   7
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   8
     0, 0, 1, 0, 0, 0, 0, 0, 0, 0,  //   9
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   10
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   11
     0, 0, 0, 0, 0, 0, 0, 0 };      //   12

//clearer define but with more cycles per execution.
//#define ISSPECIAL(cc) ( ((cc) > L'\\') ? FALSE : ___isspecial[(cc)] )
//less clear but the fastest!
#define ISSPECIAL(cc) (((cc) & 0xff80) ? FALSE : ___isspecial[(cc)])

__forceinline BOOL
IsUnescapedDNSepChar (
        const WCHAR *pBase,
        const WCHAR *pCurrent
        )
/*++

Description:
    Returns TRUE if the character pointed at by pCurrent is an unescaped DN
    separator character.


Assumptions:
    pBase is the beginning of a DSName string, pCurrent points somewhere in that
    string.  pBase cannot begin with an escape character.

--*/
{
    DWORD numEscapes=0;

    if(!IsDNSepChar(*pCurrent)) {
        // Not even a separator, much less an escaped one.
        return FALSE;
    }

    // OK, it's a separator character.  Let's see if it is escaped.
    pCurrent--;
    while(pCurrent >= pBase && *pCurrent == L'\\') {
        // yet another escape character
        numEscapes++;
        pCurrent--;
    }
    if(pCurrent < pBase) {
        // Huh? escapes all the way back to the beginning of the string?
        // That isn't legal, since we need a tag, not just a value.
        return FALSE;
    }

    // An odd number of escapes means that the last escape pairs with the
    // DNSepChar we found.  An even number of escapes means that the escapes
    // pair up with themselves, so the DNSepChar we found is real.
    return (!(numEscapes & 1));
}

/*++ StepToNextDNSep
 *
 * Given a pointer into string DN, this routine returns a pointer to the
 * next DN separator, paying attention to quoted values.  It also skips the
 * first character if it is a separator.
 *
 * INPUT:
 *    pString   - pointer into string DN
 *    pLastChar - Last non-NULL character of the string
 *    ppNextSep - pointer to pointer to receive pointer to next sep
 * OUTPUT:
 *    ppNextSep filled in
 * RETURN VALUE:
 *    0         - success
 *    non-0     - DIRERR code
 */
unsigned StepToNextDNSep(const WCHAR * pString,
                         const WCHAR * pLastChar,
                         const WCHAR **ppNextSep,
                         const WCHAR **ppStartOfToken,
                         const WCHAR **ppEqualSign)
{
    const WCHAR * p;
    BOOL inQuote = FALSE;
    BOOL fDone = FALSE;

    p = pString;

    if((*p == L',') || (*p == L';')) {
        p++;                            // we want to step past this sep
    }

    // Skip leading spaces.
    while (*p == L' ' || *p == L'\n') {
        p++;
    }

    if(ppStartOfToken) {
        *ppStartOfToken = p;
    }
    if(ppEqualSign) {
        *ppEqualSign = NULL;
    }

    while ((fDone == FALSE) && (p <= pLastChar)) {
        switch (*p) {
          case L'"':            // start (or end) of a quoted chunk
            inQuote = !inQuote;
            ++p;
            break;

          case L'\\':           // one off escape
            ++p;                // so skip an extra character
            if (p > pLastChar) {
                return DIRERR_NAME_UNPARSEABLE;
            }
            ++p;
            break;

          case L',':            // a DN separator
          case L';':
            if (inQuote) {
                ++p;
            }
            else {
                fDone = TRUE;
            }
            break;

          case L'=':            // maybe an equal separating tag and value
            if (!inQuote && ppEqualSign) {
                *ppEqualSign = p;
            }
            ++p;
            break;

          case L'\0':

            if ( inQuote ) {
                p++;
            } else {
                fDone = TRUE;       // gotta stop at NULLs
            }
            break;

          default:
            ++p;
        }
    }

    Assert(p <= (pLastChar+1));

    if (inQuote) {              // did we end inside a quote?
        return DIRERR_NAME_UNPARSEABLE;
    }
    else {                      // otherwise things were ok
        *ppNextSep = p;
        return 0;
    }
} // StepToNextDNSep


BOOL
TrimDSNameBy(
       DSNAME *pDNSrc,
       ULONG cava,
       DSNAME *pDNDst
       )
/*++

Routine Description:

    Takes in a dsname and copies the first part of the dsname to the
    dsname it returns.  The number of AVAs to remove are specified as an
    argument.

Arguments:

    pDNSrc - the source Dsname

    cava - the number of AVAs to remove from the first name

    pDNDst - the destination Dsname

Return Values:

    0 if all went well, the number of AVAs we were unable to remove if not

 N.B. This routine is exported to in-process non-module callers
--*/
{
    PWCHAR pTmp, pSep, pLast;
    unsigned len;
    unsigned err;

    // If they're trying to shorten the root, bail out
    if (IsRoot(pDNSrc)) {
        return cava;
    }

    memset(pDNDst, 0, sizeof(DSNAME));

    pTmp = pDNSrc->StringName;
    pLast = pTmp + pDNSrc->NameLen - 1;
    len = 0;

    do {
        err = StepToNextDNSep(pTmp, pLast, &pSep, NULL, NULL);
        if (err) {
            return cava;        // this was as far as we got
        }
        pTmp = pSep;
        --cava;
    } while (cava && *pSep);

    if (cava) {
        // We ran out of name before we ran out of AVAs
        return cava;
    }

    if (*pTmp == L'\0') {
        // we threw away everything, so now we have the root
        pDNDst->NameLen = 0;
    }
    else {

        //
        // skip separator
        //

        ++pTmp;

        //
        // remove white spaces
        //

        while ((*pTmp == L' ') || (*pTmp == L'\n')) {
            pTmp++;
        }

        len = (unsigned int)(pTmp - pDNSrc->StringName);
        pDNDst->NameLen = pDNSrc->NameLen - len;
        memcpy(pDNDst->StringName, pTmp, pDNDst->NameLen*sizeof(WCHAR));
        pDNDst->StringName[pDNDst->NameLen] = L'\0';
    }

    pDNDst->structLen = DSNameSizeFromLen(pDNDst->NameLen);

    return 0;
}

// Returns TRUE if this is the root
// In a perfect world root would always have a name length of 0
BOOL IsRoot(const DSNAME *pName)
{
    if (    (   (0 == pName->NameLen)
             || ((1 == pName->NameLen) && (L'\0' == pName->StringName[0])) )
         && fNullUuid(&pName->Guid)
         && (0 == pName->SidLen) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

unsigned
CountNameParts(
            const DSNAME *pName,
            unsigned *pCount
            )
/*++

Routine Description:

    Returns a count of name parts (i.e., the level).

Arguments:

    pName - pointer to DSNAME to evaluate
    pCount - pointer to be filled with part count

Return Values:

    0 - success, non-zero DIRERR error code

    N.B. This routine is exported to in-process non-module callers
--*/
{
    unsigned c;
    const WCHAR *p, *q, *pLast;
    PWCHAR tokenStart;
    unsigned err;

    if (IsRoot(pName)) {
        *pCount = 0;
        return 0;
    }

    c = 0;
    p = pName->StringName;
    pLast = p + pName->NameLen - 1;

    do {
        err = StepToNextDNSep(p, pLast, &q, &tokenStart, NULL);
        if (err) {
            // couldn't find a separator
            return err;
        }

        //
        // empty name part (should never have sequential separators)
        //

        if ( tokenStart == q ) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        ++c;
        p = q;
    } while (*p);

    *pCount = c;
    return 0;

} // CountNameParts


/*++ GetRDNInfo
 *
 *  Given a pointer to a string DN, returns type and value information
 *  about the RDN.  The caller must provide a buffer that is MAX_RDN_SIZE
 *  long in order to receive the RDN value.
 *
 * INPUT
 *   pDN      - pointer to string DN
 *   pRDNVal  - pointer to a buffer to fill in with the RDN value
 * OUTPUT
 *   pRDNVal  - filled in with address of start of value portion of RDN
 *              in the input string DN
 *   pRDNlen  - filled in with the count of characters in the RDN value
 *   pRDNtype - filled in with the attribute type of the RDN
 * RETURN VALUE
 *   0 on success, DIRERR code on error
 */
#ifdef CLIENT_SIDE_DN_PARSING
unsigned GetRDNInfoLame(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
{
    WCHAR * pTmp, *pRDNQuotedVal, *pLast;
    unsigned i;
    unsigned ccKey, ccQuotedVal;
    unsigned err;

    Assert(!IsRoot(pDN));

    i = 0;

    // Determine length of RDN

    pLast = (PWCHAR)pDN->StringName + pDN->NameLen - 1;
    err = StepToNextDNSep(pDN->StringName, pLast, &pTmp, NULL, NULL);
    if (err) {
        return err;
    }

    i = (unsigned)(pTmp - pDN->StringName);
    Assert(i <= pDN->NameLen);

    // Use existing routine to parse out key and value

    err = GetTopNameComponent(pDN->StringName,
                              i,
                              &pTmp,
                              &ccKey,
                              &pRDNQuotedVal,
                              &ccQuotedVal);
    if (err) {
        return err;
    }

    // Convert the key string into an ATTRTYP.  Caller could
    // be trying to parse a garbage name in which case name component
    // pointer is NULL and/or name component count is zero.

    if ( (NULL == pTmp) || (0 == ccKey) )
    {
        return DIRERR_NAME_UNPARSEABLE;
    }
    else
    {
        // Caller may want the RDN, not the type. For example,
        // when syntactically cracking a FQDN into a canonical name.
        if (pRDNtype) {
            *pRDNtype = KeyToAttrTypeLame(pTmp, ccKey);
            if (*pRDNtype == 0) {
                return DIRERR_NAME_TYPE_UNKNOWN;
            }
        }

        // Unquote the value
        if(!ccQuotedVal) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // caller may want the rdnType, not the RDN
        if (pRDNVal) {
            *pRDNlen = UnquoteRDNValue(pRDNQuotedVal, ccQuotedVal, pRDNVal);
            if (*pRDNlen == 0) {
                return DIRERR_NAME_UNPARSEABLE;
            }
        }
    }

    return 0;
}
#else
unsigned GetRDNInfo(THSTATE *pTHS,
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
{
    WCHAR * pTmp, *pRDNQuotedVal, *pLast;
    unsigned i;
    unsigned ccKey, ccQuotedVal;
    unsigned err;

    Assert(!IsRoot(pDN));

    i = 0;

    // Determine length of RDN

    pLast = (PWCHAR)pDN->StringName + pDN->NameLen - 1;
    err = StepToNextDNSep(pDN->StringName, pLast, &pTmp, NULL, NULL);
    if (err) {
        return err;
    }

    i = (unsigned)(pTmp - pDN->StringName);
    Assert(i <= pDN->NameLen);

    // Use existing routine to parse out key and value

    err = GetTopNameComponent(pDN->StringName,
                              i,
                              &pTmp,
                              &ccKey,
                              &pRDNQuotedVal,
                              &ccQuotedVal);
    if (err) {
        return err;
    }

    // Convert the key string into an ATTRTYP.  Caller could
    // be trying to parse a garbage name in which case name component
    // pointer is NULL and/or name component count is zero.

    if ( (NULL == pTmp) || (0 == ccKey) )
    {
        return DIRERR_NAME_UNPARSEABLE;
    }
    else
    {
        *pRDNtype = KeyToAttrType(pTHS, pTmp, ccKey);
        if (*pRDNtype == 0) {
            return DIRERR_NAME_TYPE_UNKNOWN;
        }

        // Unquote the value
        if(!ccQuotedVal) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // caller may want the rdnType, not the RDN
        if (pRDNVal) {
            *pRDNlen = UnquoteRDNValue(pRDNQuotedVal, ccQuotedVal, pRDNVal);
            if (*pRDNlen == 0) {
                return DIRERR_NAME_UNPARSEABLE;
            }
        }
    }

    return 0;
}
#endif

unsigned GetRDNInfoExternal(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
{

#ifndef CLIENT_SIDE_DN_PARSING
    THSTATE *pTHS = (THSTATE*)pTHStls;

    return GetRDNInfo(pTHS,
                      pDN,
                      pRDNVal,
                      pRDNlen,
                      pRDNtype);
#else
    return GetRDNInfoLame(
                      pDN,
                      pRDNVal,
                      pRDNlen,
                      pRDNtype);
#endif
} // GetRDNInfoExternal


/*++ GetRDN
 *
 * Return the address and length of the first RDN in the specified DN
 * and the address and length of the rest of the DN.
 *
 * The RDN values are assumed to be quoted. Use UnQuoteRDN to create
 * a printable value.
 *
 * INPUT
 *   ppDN   - pointer to pointer to DN
 *   pccVal - pointer to count of characters in DN
 *
 * OUTPUT
 *   ppDN   - ponter to pointer to rest of DN; undefined if *pccDN is 0
 *   pccDN  - ponter to count of rest of characters in DN
 *   ppKey  - pointer to pointer to Key in DN; undefined if *pccKey is 0
 *   pccKey - pointer to count of characters in Key
 *   ppVal  - pointer to pointer to Val in DN; undefined if *pccVal is 0
 *   pccVal - pointer to count of characters in Val
 *
 * RETURN VALUE
 *   0      - OKAY, output params are defined
 *   non-0  - ERROR, output params are undefined.
 *
 * N.B. This routine is exported to in-process non-module callers
 */

unsigned GetRDN(const WCHAR **ppDN,
                unsigned    *pccDN,
                const WCHAR **ppKey,
                unsigned    *pccKey,
                const WCHAR **ppVal,
                unsigned    *pccVal)
{
    unsigned dwErr;
    unsigned ccRDN;
    WCHAR *pToken;
    WCHAR *pLast;

    // initialize output params
    *pccKey = 0;
    *pccVal = 0;

    // nothing to do
    if (*pccDN == 0) {
        return 0;
    }

    // determine length of RDN (skipping leading separators)
    pLast = (WCHAR *)(*ppDN + (*pccDN - 1));
    dwErr = StepToNextDNSep(*ppDN, pLast, ppDN, &pToken, NULL);
    if (dwErr) {
        return dwErr;
    }
    ccRDN = (unsigned)(*ppDN - pToken);

    // Use existing routine to parse out key and value
    dwErr = GetTopNameComponent(pToken,
                                ccRDN,
                                ppKey,
                                pccKey,
                                ppVal,
                                pccVal);
    if (dwErr) {
        return dwErr;
    }

    *pccDN = (unsigned)(pLast - *ppDN) + 1;
    return 0;
}


/*++ AppendRDN - Append an RDN to an existing DSNAME
 *
 * INPUT:
 *   pDNBase - name to append to
 *   pDNNew  - pointer to buffer to fill in with new name, must be preallocated
 *   ulBufSize - size of pDNNew buffer, in bytes
 *   pRDNVal - RDN value, in raw unquoted form
 *   RDNlen  - length of RDN value in wchars, 0 means null terminated
 *   AttId   - id of attribute in RDN
 *
 * RETURN VALUE
 *   0       - no error
 *   -1      - invalid argument
 *   non-0   - minimum size required for output buffer.
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned AppendRDN(DSNAME *pDNBase,
                   DSNAME *pDNNew,
                   ULONG  ulBufSize,
                   WCHAR *pRDNVal,
                   ULONG RDNlen,
                   ATTRTYP AttId)
{
    WCHAR * pTmp;
    int i;
    int quotesize;
    ULONG ulBufNeeded, ccRemaining;

    Assert(pDNBase->StringName[pDNBase->NameLen] == L'\0');

    if (RDNlen == 0) {
        RDNlen = wcslen(pRDNVal);
    }

    ulBufNeeded = pDNBase->structLen + (RDNlen + 4) * sizeof(WCHAR);
    if (ulBufSize < ulBufNeeded) {
        return ulBufNeeded;
    }

    memcpy(pDNNew, pDNBase, sizeof(*pDNNew));
    memset(&pDNNew->Guid, 0, sizeof(pDNNew->Guid));
    memset(&pDNNew->Sid, 0, sizeof(pDNNew->Sid));
    pDNNew->SidLen = 0;

    i = AttrTypeToKey(AttId, pDNNew->StringName);
    if (i != 2) {
        if (i == 0) {
            // unknown attrtype
            return -1;
        }
        ulBufNeeded += (i - 2)*sizeof(WCHAR);
        if (ulBufSize < ulBufNeeded) {
            return ulBufNeeded;
        }
    }
    pDNNew->StringName[i++] = L'=';

    Assert(ulBufSize > DSNameSizeFromLen(i));
    ccRemaining = (ulBufSize - DSNameSizeFromLen(i)) / sizeof(WCHAR);
    quotesize = QuoteRDNValue(pRDNVal,
                              RDNlen,
                              &pDNNew->StringName[i],
                              ccRemaining);

    if ((unsigned)quotesize <= ccRemaining) {
        i += quotesize;
    } else {
        return DSNameSizeFromLen(pDNBase->NameLen + quotesize + 2);
    }

    if (IsRoot(pDNBase)) {
        pDNNew->StringName[i] = L'\0';
        pDNNew->NameLen = i;
    }
    else {
        Assert(   (0 == pDNBase->NameLen)
               || (pDNBase->StringName[pDNBase->NameLen-1] != L'\0'));

        if ( 0 != pDNBase->NameLen )
            pDNNew->StringName[i++] = L',';

        ulBufNeeded = DSNameSizeFromLen(i + pDNBase->NameLen);
        if (ulBufSize < ulBufNeeded) {
            return ulBufNeeded;
        }

        memcpy(&pDNNew->StringName[i],
               pDNBase->StringName,
               (pDNBase->NameLen+1)*sizeof(WCHAR));
        pDNNew->NameLen = i + pDNBase->NameLen;
        pDNNew->StringName[pDNNew->NameLen] = L'\0';
    }

    pDNNew->structLen = DSNameSizeFromLen(pDNNew->NameLen);
    return 0;
}

/*++GetTopNameComponent
 *
 * Given a pointer to a string name, returns the information about the
 * key string and quoted value for the top level naming RDN.  The pointers
 * returned are pointers into the DN string.  Note that the RDN value
 * must be unquoted before being used.
 *
 * INPUT
 *    pName  - pointer to the string name
 *    ccName - count of characters in the name
 * OUTPUT
 *    ppKey  - filled in with pointer to the Key portion of the top RDN
 *    pccKey - filled in with count of characters in Key
 *    ppVal  - filled in with pointer to the Value portion of the top RDN
 *    pccVal - filled in with count of characters in Value
 * RETURN VALUE
 *    0      - success
 *    0, but all output parameters also 0 - name is root
 *    non-0  - name is unparseable, value is direrr extended error
 */
unsigned
GetTopNameComponent(const WCHAR * pName,
                    unsigned ccName,
                    const WCHAR **ppKey,
                    unsigned *pccKey,
                    const WCHAR **ppVal,
                    unsigned *pccVal)
{
    const WCHAR *pTmp;
    unsigned len, lTmp;

    *pccKey = *pccVal = 0;
    *ppKey = *ppVal = NULL;

    if (ccName == 0) {
        // root
        return 0;
    }

    // Set up a pointer to the end of the string dsname.
    pTmp = pName + ccName - 1;

    // First, skip any trailing space, as it can never be interesting
    while (ccName > 0 &&
           (*pTmp == L' ' ||
            *pTmp == L'\n')) {
        unsigned cc = 0;

        if( (ccName > 1) && (*(pTmp-1) == L'\\') ) {
            for( cc=1; (ccName>(cc+1)) && (*(pTmp-cc-1)==L'\\'); cc++ )
                continue;
        }

        if( cc & 0x1 ) //Odd number of '\\'. Space is escaped.
            break;

        --pTmp;
        --ccName;
    }

    if(!ccName) {
        // Only spaces, this is also root.
        return 0;
    }

    // Now, see if those spaces were spaces after a separator, and skip the
    // separator if they were.
    else if ((*pTmp == L'\0') || IsUnescapedDNSepChar(pName,pTmp)) {
        // OK, the next character is also uninteresting to us, and we should
        // ignore it.
        // NOTE:  This effectively promotes the NULL character to be an
        // unescaped DNSepChar.  I'm not sure we want to do that.
        --ccName;
        --pTmp;

        // Since we just ate a separator, we should now skip trailing spaces
        // (these spaces must be in between an RDN value and an RDN separator in
        // a valid DSName, i.e. "cn=foo  ,"

        while (ccName > 0 &&        // ignore trailing spaces
               (*pTmp == L' ' ||
                *pTmp == L'\n')) {
            unsigned cc = 0;

            if( (ccName > 1) && (*(pTmp-1) == L'\\') ) {
                for( cc=1; (ccName>(cc+1)) && (*(pTmp-cc-1)==L'\\'); cc++ )
                    continue;
            }

            if( cc & 0x1 ) //Odd number of '\\'. Space is escaped.
                break;

            --pTmp;
            --ccName;
        }

        if (ccName == 0) {
            // Return success, even for strings like "    ,    ".
            return 0;
        }
    }


    if(pTmp == pName) {
        // Case where all we had was a single character + 0 or more whitespace.
        // This is unparsable.
        return DIRERR_NAME_UNPARSEABLE;
    }

    Assert(pTmp > pName);

    // step backwards to find the previous DN separator, paying attention
    // to the possibility of escaped or quoted values, and the possibility
    // that this is first component, and hence we'll run out of string
    // without encountering a separator.

    len = 1;
    do {
        if (*pTmp == L'"') {
            unsigned cc = 0;

            if( (pName <= (pTmp-1)) && (*(pTmp-1) == L'\\')) {
                //Need to find out the number of '\\'
                for( cc = 1; (pName <= (pTmp-cc-1)) && (*(pTmp-cc-1) == L'\\'); cc++ )
                    continue;
            }

            if( cc & 0x1 ) {
                // Odd number of '\\'. This is just a random escaped quote, so step over it
                // and its escape character
                pTmp -= 2;
                len += 2;
                if (pTmp <= pName) {
                    return DIRERR_NAME_UNPARSEABLE;
                }
            }
            else {
                // this should be the end of a quoted string, so walk back
                // looking for the start of the quote, ignoring everything
                // else along the way
                do {
                    --pTmp;
                    ++len;
                } while ((pTmp > pName) &&
			 (*pTmp != L'"') ||
                         ((*pTmp == L'"') &&
                          (*(pTmp - 1) == L'\\')));
                if (pTmp <= pName) {
                    return DIRERR_NAME_UNPARSEABLE;
                }
		--pTmp;		// step over the leading quote
		++len;
            }
        }
        else {
            --pTmp;
            ++len;
        }
    } while (!IsUnescapedDNSepChar(pName,pTmp) &&
             pTmp > pName);

    if (IsUnescapedDNSepChar(pName,pTmp)) {
        if (pTmp <= pName) {
            // first char in name is a separator?  get real
            return DIRERR_NAME_UNPARSEABLE;
        }
        else {
            // we must be sitting directly on top of a separator char,
            // so step forward one to get to the first char after.
            ++pTmp;
            --len;
        }
    }

    // step over any leading spaces
    while (*pTmp == L' ' || *pTmp == L'\n') {
        ++pTmp;
        --len;
    }

    // Ok, pTmp is now pointing to the start of the AVA, and len is the
    // count of characters remaining until the last non-blank.  Step forward
    // until we find the equal sign that marks the break between the
    // key and the value.

    *ppKey = pTmp;

    lTmp = 0;
    while (!ISSPECIAL(*pTmp) && len) {
        ++pTmp;
        --len;
        ++lTmp;
    }

    if (len == 0 || lTmp == 0 || *pTmp != L'=') {
        // Either we ran all the way through the component string without
        // finding an equal, or the very first character we encountered was
        // an equal, or we encountered some special character other than
        // an equal that is not allowed in the key component.  In any case,
        // this is bad, and we'll complain.
        return DIRERR_NAME_UNPARSEABLE;
    }

    *pccKey = lTmp;

    // step over the equal separator
    Assert(*pTmp == L'=');
    ++pTmp;
    --len;

    // step over leading whitespace in the value
    while (*pTmp == L' ' || *pTmp == L'\n') {
        ++pTmp;
        --len;
        if (len == 0) {
            // we ran out of component without ever encountering a non-blank
            return DIRERR_NAME_UNPARSEABLE;
        }
    }

    *ppVal = pTmp;

    if ( !len )
        return DIRERR_NAME_UNPARSEABLE;

    *pccVal = len;

    return 0;
}

/*++ QuoteRDNValue
 *
 * This routine will perform adequate quoting of a value so that it
 * can be embedded as an RDN value in a string DN.  The output buffer
 * must be preallocated.
 *
 * INPUT
 *   pVal   - pointer to raw value
 *   ccVal  - count of characters in value
 *   pQuote - pointer to output buffer
 *   ccQuoteBufMax - size of output buffer in chars
 * OUTPUT
 *   pQuote - filled in with quoted value
 * RETURN VALUE
 *   0      - invalid input
 *   non-0  - count of characters used in quoted string.  If larger than
 *            ccQuoteBufMax then the quoting was incomplete, and the
 *            routine must be called again with a larger buffer
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned QuoteRDNValue(const WCHAR * pVal,
                       unsigned ccVal,
                       WCHAR * pQuote,
                       unsigned ccQuoteBufMax)
{
    unsigned u;
    const WCHAR *pVCur;
    WCHAR *pQCur;
    int iBufLeft;

    //
    // No input params? Return error.
    //
    if( (pVal == NULL) || (ccVal == 0) ) {
        return 0;
    }

    //
    // Spaces at the beginning or end of the RDN require escaping.
    //
    if( (*pVal == L' ') || (*(pVal+ccVal-1) == L' ') ) {
        goto FullQuote;
    }

    //
    // Assume no escaping is needed and move RDN into the output buffer
    //
    pVCur = pVal;
    pQCur = pQuote;
    iBufLeft = (int) ccQuoteBufMax;

    for (u=0; u < ccVal; u++) {

        if (   (*pVCur == L'\0')
            || ISSPECIAL(*pVCur)) {
            goto FullQuote;
        }
        if (iBufLeft > 0) {
            *pQCur = *pVCur;
            --iBufLeft;
        }
        ++pQCur;
        ++pVCur;
    }

    //
    // If there is space, add a terminating NULL so that the returned
    // value can be printed. As a courtesy to the caller.
    //
    if (iBufLeft > 0) {
        *pQCur = L'\0';
    }

    // If we get to here, we have transcribed the value, which did not
    // need any escaping;
    return ccVal;

FullQuote:

    // If we get to here, we have discovered that at least one character
    // in the value needs escaping.

    pQCur = pQuote;
    pVCur = pVal;
    iBufLeft = (int) ccQuoteBufMax;

    // escape the first leading space if any.
    if (L' ' == *pVCur && iBufLeft > 1 && ccVal > 1) {
            *pQCur++ = L'\\';
            *pQCur++ = L' ';
            iBufLeft -= 2;
            pVCur++;
            ccVal--;
    }
    for (u=0; u<ccVal; u++) {
        if (ISSPECIAL(*pVCur)) {
            if (iBufLeft > 0) {
                *pQCur = L'\\';
                --iBufLeft;
            }
            ++pQCur;
        }
        if (L'\n' == *pVCur || L'\r' == *pVCur) {
            // escape newlines and carriage returns because
            // it makes life easier on applications like
            // ldifde that need to represent DN's in text files
            // where these characters are delimiters.  Since
            // this is not one of the special characters
            // listed in RFC2253 it must be escaped with its
            // hex character code.
            if (iBufLeft > 0) {
                *pQCur++ = L'0';
                --iBufLeft;
            }
            if (iBufLeft > 0) {
                if (L'\n' == *pVCur) {
                    *pQCur = L'A';
                } else {
                    *pQCur = L'D';
                }
                --iBufLeft;
            }
        } else {
            if (iBufLeft > 0) {
                *pQCur = *pVCur;
                --iBufLeft;
            }
        }
        ++pQCur;
        ++pVCur;
    }
    // Check for a trailing space that requires escaping.
    if (L' ' == *(pVCur-1)) {
        if (iBufLeft > 0) {
            *(pQCur-1) = L'\\';
            *pQCur = L' ';
            --iBufLeft;
        }
        ++pQCur;
    }

    //
    // If there is space, add a terminating NULL so that the returned
    // value can be printed. As a courtesy to the caller.
    //
    if (iBufLeft > 0) {
        *pQCur = L'\0';
    }

    return (unsigned)(pQCur - pQuote);

}


/*++ UnquoteRDNValue
 *
 * This routine will perform adequate unquoting of a value so that it
 * cannot be embedded as an RDN value in a string DN.  The output buffer
 * must be preallocated and is assumed to be at least MAX_RDN_SIZE chars
 * in length.
 *
 * INPUT
 *   pQuote  - pointer to quoted value
 *   ccQuote - count of characters in quoted value
 *   pVal    - pointer to output buffer
 * OUTPUT
 *   pVal    - filled in with raw value
 * RETURN VALUE
 *   0       - failure
 *   non-0   - count of chars in value
 */
unsigned UnquoteRDNValue(const WCHAR * pQuote,
                         unsigned ccQuote,
                         WCHAR * pVal)
{
    const WCHAR * pQCur;
    WCHAR *pVCur;
    unsigned u = 0;
    unsigned vlen = 0;
    unsigned unencodedLen;

    //
    // Invalid params. Return error (or assert in CHK builds).
    //
    Assert(pQuote);
    Assert(pVal);
    if (pQuote == NULL || pVal == NULL) {
        return 0;
    }

    if ( !ccQuote )
        return 0;

    pQCur = pQuote;
    pVCur = pVal;

    while (*pQCur == L' '  ||
           *pQCur == L'\n' ||
           *pQCur == L'\r'   ) {
        ++pQCur;                // step over leading spaces
        if (++u > ccQuote) {
            return 0;
        }
    }

    if (*pQCur == L'"') {       // "quoted values"
        ++pQCur;                // step over open quote
        ++u;
        do {
            if (*pQCur == L'\\') {
                ++pQCur;
                ++u;
            }
            if(vlen == MAX_RDN_SIZE) {
                // Oops, we were already maxed out.
                return 0;
            }
            *pVCur++ = *pQCur++;
            ++u;
            ++vlen;
        } while (*pQCur != L'"' && u <= ccQuote);

        if (u > ccQuote) {
            return 0;
        }

         if (*pQCur != L'"') { // we should be at the end of the value
            return 0;
        }
        ++pQCur;
        ++u;
        while (u < ccQuote) {
            switch (*pQCur) {
              case L' ':        // extra whitespace is ok
              case L'\n':
              case L'\r':
                break;

              default:          // more junk after the value is not
                return 0;
            }
            ++pQCur;
            ++u;
        }

        //
        // Unsuccessful conversion; give up
        //
        if (vlen != (unsigned)(pVCur - pVal)) {
            return 0;
        }

    }
    else if (*pQCur == L'#') {  // #hex string
        WCHAR acTmp[3];
        char * pTmpBuf = malloc(ccQuote); // more than needed
        char * pUTF = pTmpBuf;
        if (!pUTF) {
            return 0;       //fail to malloc
        }
        vlen = 0;
        acTmp[2] = 0;
        ++pQCur;                // step over #
        ++u;
        while (u < ccQuote) {
            if (u == ccQuote-1) {
                free(pTmpBuf);
                return 0;       // odd char count
            }

            acTmp[0] = towlower(*pQCur++);
            acTmp[1] = towlower(*pQCur++);
            u += 2;
            if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                pUTF[vlen++] = (char) wcstol(acTmp, NULL, 16);
            }
            else {
                free(pTmpBuf);
                return 0;  // non-hex digit
            }

        }

        // ok, we now have a buffer of <vlen> characters which must be an ASN.1
        // BER encoding of a string.  Let's verify.

        if(vlen < 3) {
            // we need at least three bytes of vlen, one for the magic 4, one
            // for a length, and one for a value.
            free(pTmpBuf);
            return 0;
        }

        // First byte must be 4, which is the magical value saying that this is
        // a BER encoded string
        if(*pUTF != 4) {
            free(pTmpBuf);
            return 0;
        }

        // OK, first byte was 4.  Skip the first byte.
        vlen--;
        pUTF++;
        // Now, the next part must encode a length.
        if(*pUTF & 0x80) {
            unsigned bytesInLen;
            // Because this byte has the high bit set, the low order bits tell
            // me how many of the following bytes are the length
            bytesInLen = *pUTF & 0x7f;
            pUTF++;
            vlen--;

            if((!bytesInLen) ||
               (bytesInLen > vlen) ||
               (bytesInLen > 4 )       ) {
                // Either this value is not one we can handle (we don't
                // handle values bigger than a DWORD or smaller than a byte)
                // -or- the buffer passed in doesn't have enough bytes to
                // actually hold the length we were told to expect.
                // In either case, we're sunk.
                free(pTmpBuf);
                return 0;
            }

            unencodedLen = 0;
            // OK, build the value, dealing with the byte-reversal
            for(;bytesInLen; bytesInLen--) {
                unencodedLen = (unencodedLen << 8) + *pUTF;
                pUTF++;
                vlen--;
            }
        }
        else {
            // Since the high order bit is not set, then this byte is the
            // length.
            unencodedLen = *pUTF;
            pUTF++;
            vlen--;
        }

        if((!vlen) ||
            // No length left for the buffer.  Bail
           (vlen != unencodedLen)) {
            // The decoded length didn't match the bytes we have left
            free(pTmpBuf);
            return 0;
        }

        // ok, we now have a value of <vlen> characters, presumably in
        // UTF8, which we now need to convert into Unicode, because all
        // we can deal with are strings.

        // Note that if the WideChar version is > MAX_RDN_SIZE, the call will
        // fail, and vlen == 0
        vlen = MultiByteToWideChar(CP_UTF8,
                                   0,
                                   pUTF,
                                   vlen,
                                   pVal,
                                   MAX_RDN_SIZE);
        free(pTmpBuf);
    }
    else {                      // normal value
        // step along, copying characters
        do {
            if (*pQCur == L'\\') { // char is a pair
                ++pQCur;
                ++u;
                if ( (u < ccQuote) &&
                    ( ISSPECIAL(*pQCur)     //It's a special character
                      || ( (*pQCur == L' ') &&//It's a leading or trailing space
                    ((pQCur==pQuote + 1) ||(pQCur==pQuote + ccQuote - 1)) ) )) {
                    if(vlen == MAX_RDN_SIZE) {
                        // Oops, we were already maxed out.
                        return 0;
                    }
                    *pVCur++ = *pQCur++;
                    ++u;
                    ++vlen;
                }
                else {
                    //Check to see if there are two hex digits
                    if( ((u + 1) < ccQuote) &&
                        iswxdigit( *pQCur ) &&
                        iswxdigit( *(pQCur + 1) ) )
                    {
                        int iByte;

                        if(vlen == MAX_RDN_SIZE) {
                            // Oops, we were already maxed out.
                            return 0;
                        }
                        swscanf( pQCur, L"%2x", &iByte );
                        *pVCur++ = (WCHAR)iByte;
                        pQCur += 2;
                        u += 2;
                        ++vlen;
                    }
                    else
                        return 0;   // unacceptable escape sequence
                }
            }
            else {              // char is normal stringchar
                if((vlen == MAX_RDN_SIZE) || // Oops, we were already maxed out.
                   (ISSPECIAL(*pQCur))) {   // char is special

                    return 0;
                }
                *pVCur++ = *pQCur++;
                ++u;
                ++vlen;
            }
        } while (u < ccQuote);

        //
        // Unsuccessful conversion; give up
        //
        if (vlen != (unsigned)(pVCur - pVal)) {
            return 0;
        }

    }

    return vlen;

}

/* This function compares two DN's and returns TRUE if they match
 * N.B. This routine is exported to in-process non-module callers
 *
 * Moved here from mdname.c by Aaron Siegel (t-asiege)
 * CLIENT_SIDE_DN_PARSING #ifdefs also added by t-asiege
 */

int
NameMatched(const DSNAME *pDN1, const DSNAME *pDN2)
{
    // Check for an easily detected match, either because the GUIDs match
    // or because the string names are identical (modulo case).

    if (memcmp(&gNullUuid, &pDN1->Guid, sizeof(GUID)) &&
	memcmp(&gNullUuid, &pDN2->Guid, sizeof(GUID))) {
	// Both DNs have GUIDs...
	if (memcmp(&pDN1->Guid, &pDN2->Guid, sizeof(GUID))) {
	    // ...and they don't match
	    return FALSE;
	}
	else {
	    // ...and they match
	    return TRUE;
	}
    }

    // Check to see if the SIDs match, but only if we can't compare stringnames
    if (pDN1->SidLen &&
	pDN2->SidLen &&
	((0 == pDN1->NameLen) || (0 == pDN2->NameLen))) {
	// Both DNs have SIDs...
	if ((pDN1->SidLen != pDN2->SidLen) ||
	    memcmp(&pDN1->Sid, &pDN2->Sid, pDN1->SidLen)) {
	    // ...and they don't match
	    return FALSE;
	}
	else {
	    // ...and they match
	    return TRUE;
	}
    }

    return(NameMatchedStringNameOnly(pDN1, pDN2));
}

// N.B. This routine is exported to in-process non-module callers
int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2)
{
    unsigned count1, count2;
    WCHAR rdn1[MAX_RDN_SIZE], rdn2[MAX_RDN_SIZE];
    ATTRTYP type1, type2;
    ULONG rdnlen1, rdnlen2;
    ULONG len1, len2;
    WCHAR *pKey, *pQVal;
    DWORD ccKey, ccQVal;
    PVOID thsBlob = NULL;
    int i;

#ifndef CLIENT_SIDE_DN_PARSING
    THSTATE* pTHS = pTHStls;
#endif


    // Check to see if the string names are identical
    if ((pDN1->NameLen == pDN2->NameLen) &&
        (0 == memcmp(pDN1->StringName,pDN2->StringName, pDN1->NameLen*sizeof(WCHAR)))) {
        return TRUE;
    }

    // If we get to this point we are unable to determine name matching by
    // comparing fixed size DSNAME fields, and have determined that the
    // quoted strings for the two names are not identical.  However, since
    // the quoting mechanism is not one-to-one, there can be multiple
    // quoted representations for a single DN.  Therefore we now need to
    // check for less-obvious matches by breaking out the individual
    // name components and comparing them.  We try to do this in the most
    // efficient manner possible, by trying the most likely to fail comparisons
    // first.  Before any of that we've got to verify that we've really got
    // two string names to work with, though.
    if ((0 == pDN1->NameLen) || (0 == pDN2->NameLen)) {
        return FALSE;
    }

    // Check to see if the number of name parts differs.
    if (CountNameParts(pDN1, &count1) ||
        CountNameParts(pDN2, &count2) ||
        (count1 != count2)) {
        return FALSE;
    }
    // A quick extra check.  If the names have no parts (just blanks?) then
    // they match by definition
    if (0 == count1) {
        return TRUE;
    }

    // Check to see if the RDNs differ (names are more likely to differ
    // in RDN than in topmost component)
    if (GetRDNInfoExternal(pDN1, rdn1, &rdnlen1, &type1) ||
        GetRDNInfoExternal(pDN2, rdn2, &rdnlen2, &type2) ||
        (type1 != type2) ||
        (2 != CompareStringW(DS_DEFAULT_LOCALE,
                             DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                             rdn1,
                             rdnlen1,
                             rdn2,
                             rdnlen2))) {
        return FALSE;
    }

    // Sheesh.  These names aren't GUID comparable and the full strings
    // don't match, but they have the same number of name components and
    // their RDNs match.  Now we need to walk through the rest of the
    // components one by one to see if they match.  We walk from the top
    // down because that's the way the support routines work.  Note that
    // we only have to look at count1-1 components, because we already
    // compared the least significant RDN.  If the names have only one
    // component then this will be a zero trip loop.
    len1 = pDN1->NameLen;
    len2 = pDN2->NameLen;
    for (i=count1-1; i>0; i--) {
	// First one
	if (GetTopNameComponent(pDN1->StringName,
				len1,
				&pKey,
				&ccKey,
				&pQVal,
				&ccQVal)) {
	    // Can't be parsed? no match
	    return FALSE;
	}
	len1 = (ULONG)(pKey - pDN1->StringName);
#ifdef CLIENT_SIDE_DN_PARSING
	type1 = KeyToAttrTypeLame(pKey, ccKey);
#else
	type1 = KeyToAttrType (pTHS, pKey, ccKey);
#endif
	rdnlen1 = UnquoteRDNValue(pQVal, ccQVal, rdn1);

	// then the other
	if (GetTopNameComponent(pDN2->StringName,
				len2,
				&pKey,
				&ccKey,
				&pQVal,
				&ccQVal)) {
	    // Can't be parsed? no match
	    return FALSE;
	}
	len2 = (ULONG)(pKey - pDN2->StringName);
#ifdef CLIENT_SIDE_DN_PARSING
	type2 = KeyToAttrTypeLame(pKey, ccKey);
#else
	type2 = KeyToAttrType (pTHS, pKey, ccKey);
#endif
	rdnlen2 = UnquoteRDNValue(pQVal, ccQVal, rdn2);

	if ((type1 != type2) ||
            (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
				 rdn1,
				 rdnlen1,
				 rdn2,
				 rdnlen2))) {
	    // RDNs don't match
	    return FALSE;
	}
    }

    // Well, we've exhausted every known way in which the names could
    // differ, so they must be the same
    return TRUE;
}

DWORD
MangleRDNWithStatus(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    )
/*++

Routine Description:

    Transform an RDN in-place into a unique RDN based on the associated
    object's GUID in order to eliminate name conflicts.

    Example:
        GUID = a746b716-0ac0-11d2-b376-0000f87a46c8
        Original RDN = "SomeName"

        New RDN = "SomeName#TAG:a746b716-0ac0-11d2-b376-0000f87a46c8", where
            '#' is the BAD_NAME_CHAR and TAG varies depending on eMangleFor.

    The BAD_NAME_CHAR is used to guarantee that no user-generated name could be
    in conflict, and the GUID is used to guarantee no system-generated name
    could be in conflict.

Arguments:

    eMangleFor (IN) - Reason for mangling the RDN; one of 
        MANGLE_OBJECT_RDN_FOR_DELETION, MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
        or MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT.

    pGuid (IN) - GUID of the object to rename.
    
    pszRDN (IN/OUT) - the RDN.  Buffer must be large enough to hold MAX_RDN_SIZE
        WCHARs.
    
    pcchRDN (IN/OUT) - size in characters of the RDN.

Return Values:

    DWORD - Win32 error status

--*/
{
    RPC_STATUS  rpcStatus;
    LPWSTR      pszGuid;
    LPWSTR      pszTag;
    LPWSTR      pszAppend;
    GUID        EmbeddedGuid;

    Assert(!fNullUuid(pGuid));

    rpcStatus = UuidToStringW(pGuid, &pszGuid);
    if (RPC_S_OK != rpcStatus) {
        Assert(RPC_S_OUT_OF_MEMORY == rpcStatus);
        return rpcStatus;
    }

    switch (eMangleFor) {
    default:
        Assert(!"Logic Error");
        // Fall through...
    case MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
    case MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
        pszTag = L"CNF";
        break;

    case MANGLE_OBJECT_RDN_FOR_DELETION:
        pszTag = L"DEL";
        break;
    }
    
    if (IsMangledRDN(pszRDN, *pcchRDN, &EmbeddedGuid, NULL)) {
        // RDN is already mangled (but perhaps with a different tag).
        // Un-mangle it just before we mangle it again, so we don't end up
        // with mutliple manglings on the same RDN (e.g.,
        // "SomeName#CNF:a746b716-0ac0-11d2-b376-0000f87a46c8" \
        //      "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8").
        Assert(0 == memcmp(pGuid, &EmbeddedGuid, sizeof(GUID)));
        Assert(*pcchRDN > MANGLE_APPEND_LEN);
        *pcchRDN -= MANGLE_APPEND_LEN;
    }
    
    // Chop off trailing characters of RDN if necessary to hold appended data.
    Assert(MAX_MANGLE_RDN_BASE + MANGLE_APPEND_LEN <= MAX_RDN_SIZE);
    
    pszAppend = pszRDN + min(MAX_MANGLE_RDN_BASE, *pcchRDN);

    _snwprintf(pszAppend,
               MANGLE_APPEND_LEN,
               L"%c%s:%s",
               BAD_NAME_CHAR,
               pszTag,
               pszGuid);

    *pcchRDN = (DWORD)(pszAppend - pszRDN + MANGLE_APPEND_LEN);

    RpcStringFreeW(&pszGuid);

    return ERROR_SUCCESS;
}


BOOL
IsMangledRDN(
        IN  WCHAR * pszRDN,
        IN  DWORD   cchRDN,
        OUT GUID *  pGuid,
        OUT MANGLE_FOR *peMangleFor
    )
/*++

Routine Description:

    Detect whether an RDN has been mangled by a prior call to MangleRDN().
    If so, decode the embedded GUID and return it to the caller.

Arguments:

    pszRDN (IN) - The RDN.
    
    cchRDN (IN) - Size in characters of the RDN.

    pGuid (OUT) - On return, holds the decoded GUID if found.

Return Values:

    TRUE - RDN was mangled; *pGuid holds the GUID passed to MangleRDN().
    
    FALSE - The RDN was not mangled.

--*/
{
    BOOL        fDecoded = FALSE;
    LPWSTR      pszGuid;
    RPC_STATUS  rpcStatus;

#define SZGUIDLEN (36)
    if ((cchRDN > MANGLE_APPEND_LEN)
        && (BAD_NAME_CHAR == pszRDN[cchRDN - MANGLE_APPEND_LEN])) {
        WCHAR szGuid[SZGUIDLEN + 1];

        // The RDN has indeed been mangled; decode it.
        pszGuid = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1 + MANGLE_TAG_LEN + 1;
        
        // Unfortunately the RDN is not null-terminated, so we need to copy and
        // null-terminate it before we can hand it to RPC.
        memcpy(szGuid, pszGuid, SZGUIDLEN * sizeof(szGuid[0]));
        szGuid[SZGUIDLEN] = L'\0';

        rpcStatus = UuidFromStringW(szGuid, pGuid);
        
        if (RPC_S_OK == rpcStatus) {
            if(peMangleFor) {
                LPWSTR pTag = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1;
                if(!memcmp(pTag,
                           L"CNF",
                           MANGLE_TAG_LEN)) {
                    // Note: On a request to mangle for either
                    // MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT or
                    // MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, 
                    // we use the string "CNF".  If you ask why here, we always
                    // map back to  MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
                    *peMangleFor= MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT;
                }
                else {
                    //pszTag = L"DEL";           
                    *peMangleFor = MANGLE_OBJECT_RDN_FOR_DELETION;
                }
            }
            fDecoded = TRUE;
        }
        else {
            Assert(RPC_S_OK == rpcStatus);
        }
    }

    return fDecoded;
}

BOOL IsMangledRDNExternal(
          WCHAR * pszRDN,
          ULONG   cchRDN,
          PULONG  pcchUnMangled OPTIONAL
          )
{
   GUID GuidToIgnore;
   MANGLE_FOR MangleForToIgnore;
   BOOL IsMangled = FALSE;


   IsMangled = IsMangledRDN(pszRDN,cchRDN,&GuidToIgnore,&MangleForToIgnore);

   if (ARGUMENT_PRESENT(pcchUnMangled)) {
       if (IsMangled) {
           *pcchUnMangled = cchRDN - MANGLE_APPEND_LEN;
       }
       else {
           *pcchUnMangled = cchRDN;
       }
   }

   return(IsMangled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\nlwrap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nlwrap.c
//
//--------------------------------------------------------------------------

/* 
    This file contains wrappers for various netlogon routines and either
    stubs them out or passes them on to netlogon depending on whether
    we're running as an executable or inside the lsass process.

    Remember to use STATUS_NOT_IMPLEMENTED, not STATUS_SUCCESS for 
    routines which have OUT parameters.
*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nlwrap.h>                     // wrapper prototypes

extern BOOL gfRunningInsideLsa;

NTSTATUS
dsI_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetNotifyNtdsDsaDeletion(
                                DnsDomainName,
                                DomainGuid,
                                DsaGuid,
                                DnsHostName);
}

NTSTATUS
dsI_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonReadChangeLog(
                                InContext,
                                InContextSize,
                                ChangeBufferSize,
                                ChangeBuffer,
                                BytesRead,
                                OutContext,
                                OutContextSize);
}

NTSTATUS
dsI_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonNewChangeLog(ChangeLogHandle);
}

NTSTATUS
dsI_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetLogonAppendChangeLog(
                                ChangeLogHandle,
                                ChangeBuffer,
                                ChangeBufferSize);
}

NTSTATUS
dsI_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetLogonCloseChangeLog(ChangeLogHandle, Commit);
}

NTSTATUS
dsI_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonLdapLookupEx(
                                Filter,
                                SockAddr,
                                Response,
                                ResponseSize);
}

NTSTATUS
dsI_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetLogonSetServiceBits(ServiceBitsOfInterest, ServiceBits);
}

VOID
dsI_NetLogonFree(
    IN PVOID Buffer
    )
{
    if ( !gfRunningInsideLsa ) {
        return;
    }

    I_NetLogonFree(Buffer);
}

NTSTATUS
dsI_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetNotifyDsChange(DsChangeType);
}

NET_API_STATUS
dsDsrGetDcNameEx2(
    IN LPWSTR ComputerName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return(DsrGetDcNameEx2(
                        ComputerName,
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        Flags,
                        DomainControllerInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\oidconv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       OidConv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Conversion routines from OID<->ATTR Types
    Orignally in xds.

    The OID encoding and decoding routines in this module are based
    on the explanations of BER encoding of OIDs found in "A Layman's
    guide to a Subset of ASN.1, BER, and DER", by Burton S. Kaliski Jr,
    which is available as http://www.rsa.com/pub/pkcs/ascii/layman.asc.
    The most relevant content is in section 5.9 (Object Identifiers).

    This file is now closely related to scache.c, since all accesses to
    the prefix table are through the thread-specific schema pointer

Revision History

    Don Hacherl (DonH) 7-17-96  added string DN conversion functions
    Arobinda Gupta (Arobindg) 5-8-97 added dynamic prefix table
                                     loading\unloading
    Arobinda Gupta (ArobindG) 5-22-97 dynamix prefix table support

--*/
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <objids.h>
#include <dsconfig.h>

// Assorted DSA headers
#include <dsevent.h>
#include <mdcodes.h>
#include <debug.h>
#define DEBSUB "OIDCONV:"

//Prefix Table header
#include <prefix.h>

#include <dstaskq.h>
#include <anchor.h>
#include <drameta.h>


#include <fileno.h>
#define  FILENO FILENO_SCACHE

typedef struct
{
    ULONG       Ndx;
    DWORD       NextSuffix;
    DWORD       EndSuffix;
}OIDPOOL;

extern int RecalcPrefixTable();


// Local functions
int AddPrefixIfNeeded(OID_t *Prefix,
                      unsigned PrefixLength,
                      DWORD *ndx);
int AssignIndex(OID_t *NewPrefix,
                unsigned PrefixLength,
                DWORD *ndx);
int ParseAndLoad(PrefixTableEntry *PrefixTable,
                 ULONG PREFIXCOUNT,
                 UCHAR *pBuf);

BOOL ReplaceHardcodedPrefix(PrefixTableEntry *PrefixTable,
                            PrefixTableEntry *NewPrefix);

// External function (defined in scchk.c) to free prefix tabale)
extern void SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT);

// From various X series headers:
#define OMP_O_MH_C_OR_NAME  "\126\006\001\002\005\013\035"
#define OMP_O_DS_C_ACCESS_POINT  "\x2B\x0C\x02\x87\x73\x1C\x00\x85\x3E"

OID_EXPORT(MH_C_OR_NAME);
OID_EXPORT(DS_C_ACCESS_POINT);


// Known MS Prefixes. The runtime prefix table loads these.


PrefixTableEntry MSPrefixTable[] =
{
    {_dsP_attrTypePrefIndex, {_dsP_attrTypePrefLen, _dsP_attrTypePrefix}},
    {_dsP_objClassPrefIndex, {_dsP_objClassPrefLen, _dsP_objClassPrefix}},
    {_msP_attrTypePrefIndex, {_msP_attrTypePrefLen, _msP_attrTypePrefix}},
    {_msP_objClassPrefIndex, {_msP_objClassPrefLen, _msP_objClassPrefix}},
    {_dmsP_attrTypePrefIndex, {_dmsP_attrTypePrefLen, _dmsP_attrTypePrefix}},
    {_dmsP_objClassPrefIndex, {_dmsP_objClassPrefLen, _dmsP_objClassPrefix}},
    {_sdnsP_attrTypePrefIndex, {_sdnsP_attrTypePrefLen, _sdnsP_attrTypePrefix}},
    {_sdnsP_objClassPrefIndex, {_sdnsP_objClassPrefLen, _sdnsP_objClassPrefix}},
    {_dsP_attrSyntaxPrefIndex, {_dsP_attrSyntaxPrefLen, _dsP_attrSyntaxPrefix}},
    {_msP_attrSyntaxPrefIndex, {_msP_attrSyntaxPrefLen, _msP_attrSyntaxPrefix}},
    {_msP_ntdsObjClassPrefIndex, {_msP_ntdsObjClassPrefLen, _msP_ntdsObjClassPrefix}},
    {_Ldap_0AttPrefIndex, {_Ldap_0AttLen, _Ldap_0AttPrefix}},
    {_Ldap_1AttPrefIndex, {_Ldap_1AttLen, _Ldap_1AttPrefix}},
    {_Ldap_2AttPrefIndex, {_Ldap_2AttLen, _Ldap_2AttPrefix}},
    {_Ldap_3AttPrefIndex, {_Ldap_3AttLen, _Ldap_3AttPrefix}},
    {_msP_ntdsExtnObjClassPrefIndex, {_msP_ntdsExtnObjClassPrefLen,
                                      _msP_ntdsExtnObjClassPrefix}},
    {_Constr_1AttPrefIndex, {_Constr_1AttLen, _Constr_1AttPrefix}},
    {_Constr_2AttPrefIndex, {_Constr_2AttLen, _Constr_2AttPrefix}},
    {_Constr_3AttPrefIndex, {_Constr_3AttLen, _Constr_3AttPrefix}},
    {_Dead_AttPrefIndex_1, {_Dead_AttLen_1, _Dead_AttPrefix_1}},
    {_Dead_ClassPrefIndex_1, {_Dead_ClassLen_1, _Dead_ClassPrefix_1}},
    {_Dead_AttPrefIndex_2, {_Dead_AttLen_2, _Dead_AttPrefix_2}},
    {_Dead_ClassPrefIndex_2, {_Dead_ClassLen_2, _Dead_ClassPrefix_2}},
    {_Dead_AttPrefIndex_3, {_Dead_AttLen_3, _Dead_AttPrefix_3}},
    {_Dead_ClassPrefIndex_3, {_Dead_ClassLen_3, _Dead_ClassPrefix_3}},
    {_Dead_ClassPrefIndex_4, {_Dead_ClassLen_4, _Dead_ClassPrefix_4}},
    {_Dead_AttPrefIndex_4, {_Dead_AttLen_4, _Dead_AttPrefix_4}},
    {_DynObjPrefixIndex, {_DynObjLen, _DynObjPrefix}},
    {_InetOrgPersonPrefixIndex,{_InetOrgPersonLen, _InetOrgPersonPrefix}},
    {_labeledURIPrefixIndex,{_labeledURILen, _labeledURIPrefix}},
    {_unstructuredPrefixIndex,{_unstructuredLen, _unstructuredPrefix}},
};

// Dummy Prefix to void out an intermediate entry in the prefix table
// The index does not really matter, since it would never be used
// Also, by definition of an OID, no OID can create this prefix
// (since the first decimal in an OID must be 0,1,or 2, and the
// second less than 40 (we check this), so 40x(firstdecimal)+second
// decimal can not be more than 120
//
// The invalid prefix index (_invalidPrefIndex) must be a value that
// will never occur in practice when translating an OID into an attid.
// Otherwise, PrefixMapOpenHandle will create an rgMappings array that
// may return this invalid prefix. For example, pretend the invalid
// prefix was 0 (which it was), and that 0 was in use as a valid index
// (which it is). The rgMappings array would then have two entries for
// 0, one for the invalid entry and one for the valid entry. PrefixMapAttr
// may then return the invalid entry (which it did) and replication will
// fail.
//

#define _invalidPrefIndex  (FIRST_INTID_PREFIX)
#define _invalidPrefix     "\xFF"
#define _invalidPrefLen    1



///////////////////////////////////////////////////////////////////////
// Loads MS-specific prefixes in a prefix table.
// Memory for MAX_PREFIX_COUNT no. of prefix table entries  is
// assumed to be already allocated (in SCSchemaCacheInit)
//
// Return Value:  0 on success, non-0 on error
//
///////////////////////////////////////////////////////////////////////

int InitPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
    ULONG i;
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;


    Assert(PrefixTable && PREFIXCOUNT >= MSPrefixCount);

    // Initialize (necessary?)
    for (i=0; i<PREFIXCOUNT; i++) {
        PrefixTable[i].prefix.elements = NULL;
        PrefixTable[i].prefix.length = 0;
    }

    // Load the hardcoded MS prefixes
    for (i=0; i<MSPrefixCount; i++) {
        PrefixTable[i].ndx = MSPrefixTable[i].ndx;
        PrefixTable[i].prefix.length = MSPrefixTable[i].prefix.length;
        if (SCCallocWrn(&PrefixTable[i].prefix.elements, 1, strlen(MSPrefixTable[i].prefix.elements) + 1 )) {
            return 1;
        }
        memcpy( PrefixTable[i].prefix.elements, MSPrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);
    }

    // Update the thread state to reflect the Prefix Count
     pSchemaPtr->PrefixTable.PrefixCount += MSPrefixCount;

     return 0;

}


///////////////////////////////////////////////////////////////////////
// Load the user defined prefixes, if any, from the prefix-map
// attribute in schema container
//
// Arguments: PrefixTable -- start of prefix table
//            PREFIXCOUNT -- size of table
//
// Return value: 0 on success, non-0 on error
//////////////////////////////////////////////////////////////////////

int InitPrefixTable2(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
    DSNAME *pSchemaDMDName = NULL;
    DBPOS *pDB = NULL;
    int err = 0;
    UCHAR *pBuf;
    ULONG cLen, totalSize;
    ULONG newSize, newPREFIXCOUNT;
    char temp[100];
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;


     // Get the schema container


    DBOpen2(TRUE, &pDB);

    // The call to DBOpen2 will call DBTransIn, which, if we are going from 
    // transaction level 0 to 1 (i.e., we are at transaction level 1 now after the DBOpen2 call),
    // and fDRA is 1, will call THRefresh, and we will lose the schema pointer.
    // This can be very bad when this is called from RecalcPrefixTable
    // in the process of assigning a new index for a new prefix, since the
    // cache that we had in the thread state is the recalc cache, which we
    // will free later (the prefix table part at least); so guess what happens
    // if THRefresh puts in the global schema cache again. So restore the saved
    // off recalc schema cache. Note that InitPrefixTable2 is called from 3
    // places: (1) normal schema cache load, (2) validatioon cache load, and 
    // (3) from RecalcPrefixTable when trying to assign index to a new prefix.
    // fDRA can never do the first two, and the third case is the case we are
    // considering here.
  
 
    if ( (pTHS->transactionlevel == 1) && pTHS->fDRA) {
       pTHS->CurrSchemaPtr = pSchemaPtr;
    }

    // In other cases, it should already be the same

    Assert(pTHS->CurrSchemaPtr == pSchemaPtr);

    __try {
       // Schema cache is loaded and hence gAnchor.pDMD is defined at
       // this point

       if (gAnchor.pDMD == NULL) {
              DPRINT(0, "Couldn't find DMD name/address to load\n");
              err = 1;
              __leave;
          }

        // PREFIX: dereferencing NULL pointer 'pDB' 
        //         DBOpen2 returns a non-NULL pDB or throws an exception
       if( DBFindDSName(pDB, gAnchor.pDMD) ) {
         DPRINT(0, "Cannot find DMD in dit\n");
         err = 1;
         __leave;
       }

       // schema cache should already be loaded at this point, as
       // DBGetAttVal needs that
       if (err = DBGetAttVal(pDB,
                      1,
                      ATT_PREFIX_MAP,
                      DBGETATTVAL_fREALLOC,
                      0,
                      &cLen,
                      (UCHAR **) &pBuf)) {

            if (err ==  DB_ERR_NO_VALUE) {
             // This is fine, as there may not be any user-defined
             // prefixes
              err = 0;
              __leave;
             }

            // otherwise, some error. Return the error
            DPRINT(0, "Error reading prefix-map attribute\n");
            __leave;
       }

       // Now see if the table space is sufficient

       memcpy(&newSize, pBuf, sizeof(ULONG));
       newSize += MSPrefixCount;

       if (newSize > PREFIXCOUNT) {
          // Make sure there is sufficient space later

          newPREFIXCOUNT = START_PREFIXCOUNT;
          while ( newSize > newPREFIXCOUNT) {
                newPREFIXCOUNT += START_PREFIXCOUNT;
          }

          if (SCReallocWrn(&PrefixTable, newPREFIXCOUNT*sizeof(PrefixTableEntry))) {
             DPRINT(0,"Error reallocing prefix table\n");
             err = 1;
             __leave;
          }

          // Zero memory, leaving already loaded MS prefixes intact
          ZeroMemory(&PrefixTable[MSPrefixCount], (newPREFIXCOUNT-MSPrefixCount)*sizeof(PrefixTableEntry));

          // update the thread's schemaptr
          pSchemaPtr->PrefixTable.pPrefixEntry = PrefixTable;
          PREFIXCOUNT = newPREFIXCOUNT;
          pSchemaPtr->PREFIXCOUNT = PREFIXCOUNT;
       }

       // Do a check on the total size in the prefix map, just in
       // case the value is corrupted. TotalSize starts at byte 4
       memcpy(&totalSize, &pBuf[4], sizeof(ULONG));
       if (totalSize != cLen) {
         // the size in the prefix map is not the same as the
         // size read. Something is wrong!
         DPRINT(0,"Prefix Map corrupted\n");
         err = 1;
         __leave;
       }

       // Now parse the binary value and load into table
       err = ParseAndLoad(PrefixTable, PREFIXCOUNT, pBuf);

    }
    __finally {
        if (pDB) {        
            DBClose(pDB, FALSE);
        }
    }
    return err;
}


//////////////////////////////////////////////////////////////////////
// Parses the binary prefix-map attribute read from the schema, and
// loads the prefix table with the prefixes. Called from InitPrefixTable2
// only
//
// Arguments:  PrefixTable  -- pointer to prefix table
//             PREFIXCOUNT  -- size of table
//             pBuf         -- ptr to start of binary blob that is the
//                             prefix-map attribute read from the schema
//
// Return value: 0 on success, non-0 on error
/////////////////////////////////////////////////////////////////////

int ParseAndLoad(PrefixTableEntry *PrefixTable,
                  ULONG PREFIXCOUNT,
                  UCHAR *pBuf)
{
    ULONG totalSize, dummy, nextByte = 0;
    ULONG i = 0;
    USHORT index, length;
    int ulongSize, ushortSize;
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;

    // USHORT = 16bits, ULONG = 32bits

    ulongSize = sizeof(ULONG);
    ushortSize = sizeof(USHORT);
    Assert(ulongSize==4);
    Assert(ushortSize==2);

    // skip the MS-specific prefixes (which are always loaded in
    // consecutive positions at the beginning of the table

    while ((PrefixTable[i].prefix.elements != NULL)
             && (i < PREFIXCOUNT)) {
        i++;
    }

    // i is now positioned on the first free entry in the table

    if (i == PREFIXCOUNT) {
     // No free space in table
      DPRINT(0,"Prefix Table Full?\n");
      return 1;
    }

    // Now parse the string

    // skip the first 4 bytes with the no. of prefixes
    memcpy(&dummy, &pBuf[nextByte], ulongSize);
    nextByte += ulongSize;

    // read the first 4 bytes containing the  size of the value
    memcpy(&totalSize, &pBuf[nextByte], ulongSize);
    nextByte += ulongSize;

    // Now read the prefixes one by one
    while( nextByte < totalSize) {

        if (i == PREFIXCOUNT) {
            // No free space in table
            DPRINT(0,"Prefix Table Full?\n");
            return 1;
         }
        Assert(PrefixTable[i].prefix.elements == NULL);

        // This is a prefix, so should have at least 4 bytes
        if ((nextByte + 4) > totalSize) {
          // something is wrong
          DPRINT(0,"Corrupted prefix\n");
          return 1;
        }

        // pick up the first two bytes (the index)

        memcpy(&index, &pBuf[nextByte], ushortSize);
        PrefixTable[i].ndx = (DWORD) index;
        nextByte += ushortSize;

        // pick up the next two bytes (Prefix length)

        memcpy(&length, &pBuf[nextByte], ushortSize);
        PrefixTable[i].prefix.length = length;
        nextByte += ushortSize;

        // Check if the length is valid. We don't want an AV
        // because the length got corrupted and we end up trying to
        // copy from after the end of the map
        // nextByte is now positioned at the beginning of the prefix

        if ( (nextByte + PrefixTable[i].prefix.length) > totalSize) {
          // something is wrong
          DPRINT1(0,"Length of Prefix is corrupted (index %d)\n",PrefixTable[i].ndx);
          return 1;
        }

        // Now copy the prefix itself

        if (SCCallocWrn(&PrefixTable[i].prefix.elements, 1, PrefixTable[i].prefix.length + 1)) {
           DPRINT(0,"Error allocating memory for prefix\n");
           return 1;
        }

        memcpy(PrefixTable[i].prefix.elements, &pBuf[nextByte], PrefixTable[i].prefix.length);
        nextByte += PrefixTable[i].prefix.length;

        // If this prefix we just added to the table is the same as
        // an earlier prefix loaded from the hardcoded table, replace
        // the copy of the hardcoded entry with the entry from the DIT.
        // The DIT always wins because the hardcoded entry in the new
        // binaries may collide with an existing prefix added with the
        // old binaries. Simply put, the system was upgraded and the ndx
        // used prior to the upgrade must be maintained because there
        // may be objects in the DIT that reference the attids based
        // on that ndx.
        if (!ReplaceHardcodedPrefix(PrefixTable, &PrefixTable[i])) {
            // This entry did not replace a hardcoded entry,
            // advance to the next free entry
            i++;

            // Increment the Prefix Count in the current threads schema ptr
            pSchemaPtr->PrefixTable.PrefixCount++;

        } // else a hardcoded entry was replaced; this entry is still free


      } /* while */


    return 0;
}



/////////////////////////////////////////////////////////////////////
// Appends a new prefix to the end of the prefix map
//
// Arguments: NewPrefix -- Prefix to be added
//            ndx       -- Index of new prefix
//            pBuf      -- start of prefix map to append to
//            fFirst    -- TRUE means first ever prefix in prefix-map
//                         FALSE means prefix-map already exists
//
// Assumes space is already allocated  at the end of pBuf
//
// Return Value: 0 on success, 1 on error
///////////////////////////////////////////////////////////////////

int AppendPrefix(OID_t *NewPrefix,
                 DWORD ndx,
                 UCHAR *pBuf,
                 BOOL fFirst)
{
    ULONG totalSize, oldTotalSizeSave, count, i, nextByte = 0, nextByteSave;
    ULONG Length = NewPrefix->length;

    int ulongSize, ushortSize;

    // USHORT = 16bits, ULONG = 32bits

    ulongSize = sizeof(ULONG);
    ushortSize = sizeof(USHORT);
    Assert(ulongSize==4);
    Assert(ushortSize==2);

    if (fFirst) {
        // Prefix-map does not exist, so need to create it

           totalSize = 2*ulongSize + 2*ushortSize + Length;
           count = 1;
           memcpy(pBuf,&count,ulongSize);
           pBuf+=ulongSize;
           memcpy(pBuf,&totalSize,ulongSize);
           pBuf+=ulongSize;
           memcpy(pBuf,&ndx,ushortSize);
           pBuf+=ushortSize;
           memcpy(pBuf,&Length,ushortSize);
           pBuf+=ushortSize;
           memcpy(pBuf,NewPrefix->elements,Length);
           return 0;
    }

    // Else, prefix-map already exists, need to append to it

    // update the no. of prefixes
    memcpy(&count, pBuf, ulongSize);
    count++;
    memcpy(pBuf, &count, ulongSize);

    nextByte += ulongSize;

    // Increment size of map.
    // 2 for the index, 2 for length, plus the prefix length
    memcpy(&totalSize, &pBuf[nextByte], ulongSize);

    oldTotalSizeSave = totalSize;

    totalSize += 2*ushortSize + Length;

    // Write new TotalSize back
    memcpy(&pBuf[nextByte], &totalSize, ulongSize);

    nextByte = oldTotalSizeSave; // beginning of place to write;

    // Write ndx in the first 2 bytes at the end of map
    memcpy(&pBuf[nextByte], &ndx, ushortSize);
    nextByte  += ushortSize;

    // Write length in the next 2 bytes
    memcpy(&pBuf[nextByte], &Length, ushortSize);
    nextByte  += ushortSize;

    // write the prefix
    memcpy(&pBuf[nextByte], NewPrefix->elements, Length);

    return 0;
}



/////////////////////////////////////////////////////////////////////
// Creates a new index for a new prefix object and adds it to a
// thread-specific storage
//
// Arguments: Prefix       -- the OID string with the new prefix (NOT
//                            just the actual prefix)
//            PrefixLength -- Length of the prefix in the OID string
//            ndx          -- Place to return the newly created index
//
// Returns: 0 on sucess, non-0 on error
/////////////////////////////////////////////////////////////////////

int AddPrefixIfNeeded(OID_t *Prefix,
                      unsigned PrefixLength,
                      DWORD *ndx)
{
    THSTATE *pTHS=pTHStls;
    DWORD i;
    PrefixTableEntry *ptr;
    int fNew;

    // We are here means that the prefix is not found in the global
    // prefix table. So first find an unused index (or the index
    // assigned to this prefix if it is already created by an earlier
    // schema operation, but the global schema cache is not yet
    // been updated)

    fNew = AssignIndex(Prefix, PrefixLength, &i);

    if (fNew == -1) {
      // Some error occured
      return 1;
    }

    if (fNew == 1) {

      // truely a new prefix, store it in the thread state

       pTHS->cNewPrefix++;
       if (pTHS->cNewPrefix == 1) {
         // This is the first new prefix

            ptr = (PrefixTableEntry *) THAllocOrgEx(pTHS, sizeof(PrefixTableEntry));
       }
       else {
         // Not the first new prefix for this thread

            ptr = (PrefixTableEntry *) THReAllocOrgEx(pTHS, pTHS->NewPrefix,
                          (pTHS->cNewPrefix)*(sizeof(PrefixTableEntry)));
       }

       pTHS->NewPrefix = ptr;

       // position on place to write

       ptr += pTHS->cNewPrefix - 1;
       ptr->ndx = i;
       ptr->prefix.length = PrefixLength;
       ptr->prefix.elements = THAllocOrgEx(pTHS, PrefixLength+1);
       if (ptr->prefix.elements == NULL) {
          DPRINT(0,"AddPrefix: Error allocating prefix space\n");
          // Reset new prefix count
          pTHS->cNewPrefix--;
          return 1;
       }
       memcpy(ptr->prefix.elements, Prefix->elements, ptr->prefix.length);

    }

    // return the index for the prefix
    *ndx = i;

    return 0;

}



/////////////////////////////////////////////////////////////////////////
// Finds a new random index that does not currently exist in the
// prefix table.  This function is called only by AddPrefix.
//
// WARNING: DB Currency is reset!
//
// Arguments: Prefix       -- the OID string with the new prefix (NOT
//                            just the actual prefix)
//            PrefixLength -- Length of the prefix in the OID string
//            ndx          -- Place to return the index
//
// Return Value: DB Currency is reset!
//               1 if the prefix is not already in the dit/thread-specific
//               new prefix storage, 0 if it is in the dit/Thread-storage
//               (but not yet in the schema cache, otherwise the prefix
//               would have been found earlier in FindPrefix)
//               -1 on error.
//
////////////////////////////////////////////////////////////////////////

int AssignIndex(OID_t *NewPrefix,
                unsigned PrefixLength,
                DWORD *ndx)
{
    THSTATE *pTHS=pTHStls;
    DWORD TempNdx;
    ULONG i, PREFIXCOUNT;
    SCHEMAPTR *OldSchemaPtr;
    PrefixTableEntry *PrefixTable, *ptr;
    ULONG CurrPrefixCount, newSize, newPREFIXCOUNT;
    int err=0, returnVal;

    // Save pTHS->CurrSchemaPtr
    OldSchemaPtr = pTHS->CurrSchemaPtr;

    // At this point, pTHS->pDB should be null, since these are
    // called from the head before the Dir APIs. So no need to save
    // currency.

    Assert(pTHS->pDB == NULL);

    DBOpen2(FALSE,&pTHS->pDB);

    // Recalc thread-specifc prefix table from dit

    __try {
       if (err=RecalcPrefixTable()) {
          // error during RecalcPrefixTable
          // Set return val to indicate error
           returnVal = -1;
           __leave;
       }

       PREFIXCOUNT = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->PREFIXCOUNT;
       PrefixTable = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->PrefixTable.pPrefixEntry;

       // If there is any new prefix in thread-specific storage, add
       // it to the prefix table. This is needed since the head may
       // call FindPrefix multiple times with the same prefix before
       // the prefix is added to the dit. Also, replication thread
       // may add multiple prefixes in a single thread, and we need
       // to look at the prefixes' indices to make sure that a new prefix
       // gets a unique index

       if (pTHS->NewPrefix != NULL) {
         ptr = (PrefixTableEntry *) pTHS->NewPrefix;
         for (i=0; i<pTHS->cNewPrefix; i++, ptr++) {
            if (AddPrefixToTable(ptr, &PrefixTable, &PREFIXCOUNT)) {
               DPRINT(0,"AssignIndex:Error adding new prefix to prefix table\n");
               // Free the prefix table of the cache used for validation
                SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

               // Set return val to indicate error
                returnVal = -1;
                __leave;
            }
         }
       }

       // First check if prefix is already in dit (This is possible when
       // a prefix has been added as part of a previous successful schema
       // object update, but the schema cache has not been updated yet)
       // In this case, just return the stored index

       for (i=0; i<PREFIXCOUNT; i++) {
          if (PrefixTable[i].prefix.elements != NULL) {
             if ( (PrefixTable[i].prefix.length == PrefixLength) &&
                 (memcmp(PrefixTable[i].prefix.elements,
                     NewPrefix->elements,PrefixLength) == 0)) {

                // Prefix is found, return the corresponding index

                *ndx = PrefixTable[i].ndx;

                // Free the cache used for validation
                SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

                // Set return value to indicate not really a new prefix
                // (so that it won't be added to the thread on return)
                returnVal = 0;
                __leave;
              }
           }
        }

       // Prefix is truely new. New index need to be assigned to it
       // first generate a random index between 100 and 65,500
       // and check if clashing with any existing prefix

       {
       BOOL flag = TRUE;

       srand((unsigned) time(NULL));

       while (flag) {
           TempNdx = rand() % _invalidPrefIndex;

           // check if clashing with MS-prefix reservered index range
           if (TempNdx < MS_RESERVED_PREFIX_RANGE) {
              continue;
           }

         // check if its a duplicate index
           for (i=0; i<PREFIXCOUNT; i++) {
              if (PrefixTable[i].ndx == TempNdx) {
                break;
              }
           }
           if (i == PREFIXCOUNT) {
            // index is not duplicate
             flag = FALSE;
           }
       }

       // return the index
       *ndx = TempNdx;

       // free the thread-specific schema cache used for validation
       SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

       // Set return value to indicate this is truely a new prefix
       // (so that it will be added to the thread on return)
       returnVal = 1;
       __leave;

       }


    } /* try */
    __finally {
       // Restore the schema pointer
       pTHS->CurrSchemaPtr = OldSchemaPtr;

       DBClose(pTHS->pDB,FALSE);
    }

    return returnVal;
}

////////////////////////////////////////////////////////////////////////
// Adds a PrefixTableEntry structure to a Prefix Table
//
// Arguments: NewPrefix   -- entry to add
//            Table       -- Start of Prefix Table
//            PREFIXCOUNT -- Size of table
//
// return Value: 0 on success, non-0 on error
////////////////////////////////////////////////////////////////////////
int AddPrefixToTable(PrefixTableEntry *NewPrefix,
                     PrefixTableEntry **ppTable,
                     ULONG *pPREFIXCOUNT)
{
    ULONG i;
    ULONG CurrPREFIXCOUNT = (*pPREFIXCOUNT);
    PrefixTableEntry *Table = (*ppTable);
 


    // Find the first free entry in the table
    for (i=0; i<CurrPREFIXCOUNT; i++) {
      if (Table[i].prefix.elements == NULL) {
          break;
      }
    }

    // If table is full, grow it

    if (i == CurrPREFIXCOUNT) {

      DPRINT(0,"AddPrefixToTanle: Prefix Table is full, growing prefix table\n");
      // Grow table to twice the current size

      if (SCReallocWrn(&Table, 2*CurrPREFIXCOUNT*sizeof(PrefixTableEntry))) {
        DPRINT(0, "Error reallocing prefix table\n");
        return 1;
      }

      // zero out the unloaded part, since it may contain junk and
      // so freeing may fail

      ZeroMemory(&Table[CurrPREFIXCOUNT], CurrPREFIXCOUNT*sizeof(PrefixTableEntry));

      // ok, we have now doubled the size, and i is correctly pointing
      // to the first free entry. But we need to return this new size
      // and the new table pointer.
      // Return it irrespective of success or failure later in this
      // function since the table size is already grown and the table is
      // realloced.

      (*pPREFIXCOUNT) = 2*CurrPREFIXCOUNT;
      (*ppTable) = Table;
    }

    // Add prefix to table

    Table[i].ndx = NewPrefix->ndx;
    Table[i].prefix.length = NewPrefix->prefix.length;
    if (SCCallocWrn(&Table[i].prefix.elements, 1, NewPrefix->prefix.length + 1 )) {
       DPRINT(0, "AddPrefixToTable: Mem. Allocation error\n");
       return 1;
    }
    memcpy( Table[i].prefix.elements, NewPrefix->prefix.elements,
                        Table[i].prefix.length);

    // If the same prefix is also loaded from the hardcoded table,
    // replace it. Should never happen here, but just to be sure
    (VOID)ReplaceHardcodedPrefix(Table, &Table[i]);

    return 0;
}


////////////////////////////////////////////////////////////////////////
//
//  Checks if the prefix NewPrefix is in the first part of the
//  PrefixTable that is hardcoded (that is, the first MsPrefixCount
//  no. of prefixes. If so, replace that prefix since NewPrefix
//  got created implies that that hardcoded prefix wasn't there
//  because of older binaries when this prefix got created
//
//  Arguments:
//      PrefixTable - Pointer to the prefix table
//      NewPrefix - pointer to the prefix
//
//  Return Value:
//      TRUE if replaced entry; FALSE if it did not
//
/////////////////////////////////////////////////////////////////////////
BOOL ReplaceHardcodedPrefix(PrefixTableEntry *PrefixTable,
                            PrefixTableEntry *NewPrefix)
{

    ULONG i;

    for (i=0; i<MSPrefixCount; i++) {
        Assert(PrefixTable[i].prefix.elements);
        if ( (PrefixTable[i].prefix.length == NewPrefix->prefix.length)
                && (memcmp(PrefixTable[i].prefix.elements,
                            NewPrefix->prefix.elements,
                            PrefixTable[i].prefix.length) == 0)) {

            // replacing a previously replaced entry is okay if the
            // ndx matches. It should never happen, but there are no
            // known problems with dup entries that have the same ndx.
            Assert(   PrefixTable[i].ndx < MS_RESERVED_PREFIX_RANGE
                   || PrefixTable[i].ndx == NewPrefix->ndx);

            // Don't replace a previously replaced entry.
            if (PrefixTable[i].ndx >= MS_RESERVED_PREFIX_RANGE) {
                continue;
            }

            // replace hardcoded entry with entry from DIT
            free(PrefixTable[i].prefix.elements);
            PrefixTable[i].prefix.length = NewPrefix->prefix.length;
            PrefixTable[i].prefix.elements = NewPrefix->prefix.elements;
            PrefixTable[i].ndx = NewPrefix->ndx;

            // Free entry read from DIT
            NewPrefix->prefix.length = 0;
            NewPrefix->prefix.elements = NULL;
            NewPrefix->ndx = 0;

            return TRUE;
        }
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
int WritePrefixToSchema(THSTATE *pTHS)
{
    DBPOS *pDB = NULL;
    DWORD err = 0;
    BOOL fCommit = FALSE;

    __try  {
        // if any new prefixes were created,
        // write it to the prefix-map

        if (pTHS->NewPrefix != NULL) {

           ULONG cLen, totalSize, i;
           USHORT length, index;
           UCHAR *pBuf;
           PrefixTableEntry *ptr;
           int ulongSize, ushortSize;
           DSNAME *pDMD;

           ulongSize = sizeof(ULONG);
           ushortSize = sizeof(USHORT);
           Assert(ulongSize==4);
           Assert(ushortSize==2);


           DBOpen(&pDB);

           if ( DsaIsRunning() ) {
               pDMD = gAnchor.pDMD;
           }
           else {
               // Installing.  Write prefix table to the new DMD rather than the
               // one in O=Boot.
               WCHAR       *pSchemaDNName = NULL;
               DWORD       ccbSchemaDNName = 0;
               ULONG       SchemaDNSize, SchemaDNLength;

               err = GetConfigParamAllocW(SCHEMADNNAME_W, &pSchemaDNName, &ccbSchemaDNName);

               if (!err) {
                   SchemaDNLength = wcslen( pSchemaDNName );
                   SchemaDNSize = DSNameSizeFromLen( SchemaDNLength );
                   pDMD = (DSNAME*) THAllocEx( pTHS, SchemaDNSize );

                   pDMD->structLen = SchemaDNSize;
                   pDMD->NameLen = SchemaDNLength;
                   wcscpy( pDMD->StringName, pSchemaDNName );
                   free (pSchemaDNName); 
               }
               else {
                   _leave;
               }
           }

           if ( (err = DBFindDSName(pDB, pDMD)) == 0) {

               ptr = (PrefixTableEntry *) pTHS->NewPrefix;

               for (i=0; i<pTHS->cNewPrefix; i++, ptr++) {
                  err = DBGetAttVal(pDB,
                                    1,
                                    ATT_PREFIX_MAP,
                                    DBGETATTVAL_fREALLOC,
                                    0,
                                    &cLen,
                                    (UCHAR **) &pBuf);

                  switch (err) {
                   case DB_ERR_NO_VALUE:
                   // this is the first new prefix that is being added ever

                      totalSize = 2*ulongSize + 2*ushortSize + ptr->prefix.length;
                      pBuf = (UCHAR *) THAllocEx(pTHS, totalSize);
                      if (AppendPrefix(&(ptr->prefix), ptr->ndx, pBuf, TRUE)) {
                        __leave;
                      }
                      break;
                   case 0:
                     // prefix-map already exists

                     totalSize = cLen + 2*ushortSize + ptr->prefix.length;

                     pBuf = (UCHAR *) THReAllocEx(pTHS, pBuf, totalSize);
                     if (AppendPrefix(&(ptr->prefix), ptr->ndx, pBuf, FALSE)) {
                       __leave;
                     }
                     break;
                   default :
                       // Some error occured in DBGetAttVal
                     __leave;
                  } /* switch */

                 // Write the new prefix-map
                 if ((err = DBRemAtt(pDB, ATT_PREFIX_MAP)) != DB_ERR_SYSERROR) {
                     err = DBAddAttVal(pDB, ATT_PREFIX_MAP, totalSize, pBuf);
                 }
                 if (err) {
                   __leave;
                 }
               } /* for */


           if (!err) {
              err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
            }
          } /* DBFindDSName */

      } /* pTHS->NewPrefix != NULL */

      if (0 == err) {
          fCommit = TRUE;
      }
    } /* try */
    __finally {
       if (pDB) {
        DBClose(pDB,fCommit);
       }
    }


    if (err){
    // this error is really misleading.  Surely we can do better?
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
    }

    return err;

} // End WritePrefixToSchema


///////////////////////////////////////////////////////////////////////
// Returns the ndx and the length of the prefix of a given OID. If the
// prefix doesn't exist, a new prefix is created , new unused ndx assigned to
// it, and is stored in th pTHS's NewPrefix field. The new prefix will
// later be made persistent if this is a schema object add/modify and the
// object is added to the dit.
//
// Arguments: OID    - OID string
//            index  - index corresponding to OID prefix returned in this
//            length - length of prefix returned in this
//            longId - Set to 1 on return if it is found that the last
//                     decimal in the dotted decimal OID string is encoded
//                     in 3 or more bytes, otherwise set to 0 on return.
//                     This is used on return for special encodings
//                     of the attrtype
//
// Returns TRUE on success, FALSE otherwise
////////////////////////////////////////////////////////////////////////

BOOL FindPrefix(OID_t *OID,
                DWORD *index,
                unsigned *length,
                int  *longID,
                BOOL fAddToTable)
{
    DECLAREPREFIXPTR
    DWORD i, ndx;
    unsigned PrefixLen;

    // make sure we have an OID, and that it is at least 2 chars long.
    if((!OID) || (!(OID->elements)) || (OID->length < 2))
        return FALSE;

    

    if ((OID->length > 2) &&
        (((unsigned char *)(OID->elements))[OID->length - 2] & 0x80)) {
          PrefixLen = OID->length - 2;
      if ( (((unsigned char *)(OID->elements))[OID->length - 3] & 0x80)) {
        // Last decimal encoded took three or more octets. Will need special
        // encoding in attrtype. See OidStrToAttrType for details
        *longID = 1;
      }
      // no special encoding in attrtyp needed
      else {
        *longID = 0;
      }
    }
    else {
        PrefixLen = OID->length - 1;
    }

    // Look through the table for this prefix;
    for(i=0;i<PREFIXCOUNT ;i++) {
        /* Prefixes must match all but the last 1 or two bytes of
         * the OID string depending on the nature of the string,
         * and the location where the suffix starts (why? because
         * it's the nature of ASN.1 encoding.) So, don't compare
         * memory unless the prefix is the right length
         */

        if ((PrefixTable[i].prefix.elements != NULL) &&
            (PrefixTable[i].prefix.length == PrefixLen) &&
            (0 == memcmp(PrefixTable[i].prefix.elements,
                         OID->elements,
                         PrefixTable[i].prefix.length))) {
            *index = PrefixTable[i].ndx;
        *length= PrefixTable[i].prefix.length;
            return TRUE;
        }
    }

    if (!fAddToTable) {
        return FALSE;
    }

    // The execution is here means no prefix is found in the global
    // prefix table. So add a new prefix (or find it if the prefix
    // is already added but not yet updated in the schema cache)
    // and return the index it maps to

     if (AddPrefixIfNeeded(OID, PrefixLen, &ndx)) {
          DPRINT(0, "Error adding new prefix\n");
          return FALSE;
       }
     *index = ndx;
     *length= PrefixLen;

    return TRUE;

}


// Returns the index into the prefix table in "index" if the given ndx is found

BOOL FindNdx(DWORD ndx, DWORD *index)
{
    DECLAREPREFIXPTR
    DWORD i;

    // Look through the table for this prefix;
    for(i=0;i<PREFIXCOUNT ;i++) {
    /* Prefixes must match all but the last 1 or two bytes of
     * the OID string depending on the nature of the string,
     * and the location where the suffix starts (why? because
     * it's the nature of ASN.1 encoding.) So, don't compare
     * memory unless the prefix is the right length
     */

    if ((PrefixTable[i].prefix.elements != NULL) &&
        (PrefixTable[i].ndx == ndx)) {
        *index = i;
        return TRUE;
    }

    }

    return FALSE;
}


// returns 0 on success, non-0 on failure
ULONG OidToAttrCache (OID_t *OID, ATTCACHE ** ppAC)
{
    THSTATE *pTHS=pTHStls;
    DECLAREPREFIXPTR
    ATTRTYP attrtyp;
    DWORD   Ndx;
    unsigned Length;
    int LongID = 0;

    *ppAC = NULL;

    if(!FindPrefix(OID, &Ndx, &Length, &LongID, TRUE)) {
        return 1;
    }

    attrtyp = Ndx << 16;

    // handle the case where we have two bytes after the prefix;
    if (  OID->length == Length + 2 )
    {
      attrtyp += ( ((unsigned char *)OID->elements)[OID->length - 2] & 0x7f ) << 7;
      if (LongID == 1) {
        // Put a 1 in the 16th bit to indicate that both bytes of the
        // attrtype is to be considered during the reverse mapping
        // See OidStrToAttrTyp for Details
      attrtyp |= (0x8000);
      }
    }

    attrtyp += ((unsigned char *)OID->elements)[OID->length - 1];

    // check the tokenized OID hash table
    if (*ppAC = SCGetAttByExtId(pTHS, attrtyp)) {
        return 0;
    }
    else {
        return 2;
    }
}


ATTRTYP
KeyToAttrType (
        THSTATE *pTHS,
        WCHAR * pKey,
        unsigned cc
        )
/*++
Routine Description:
    Translates a key value (primarily used in string representations of DNs
    e.g. O or OU of OU=Foo,O=Bar) to the attrtype for the attribute it implies.

Arguments
    pKey - pointer to the key to be translated from.
    cc - count of charactes in the key.

Return Values
    the attrtyp implied, or 0 if the key did not correspond to a known attrtyp.
--*/
{
    ATTRTYP     at;
    ATTCACHE    *pAC;
    DWORD       cName;
    PUCHAR      pName;
    BOOL        fIntId;
    ULONGLONG   ullVal;

    // 99% case
    if (0 != (at = KeyToAttrTypeLame(pKey, cc))) {
        return at;
    }

    if (cc == 0 || pKey == NULL) {
        return 0;
    }

    // Check for the ldap display name in the schema cache.
    //
    // Handle DNs of the form foo=xxx,bar=yyy, where foo and bar are the
    // LdapDisplayNames of arbitrary attributes that may or may not be 
    // defined in the schema. KeyToAttrType is enhanced to call 
    // SCGetAttByName if KeyToAttrTypeLame fails, and before trying the
    // OID decode.  The rest of this change consists of enhancing the 
    // default clause of AttrTypeToKey to call SCGetAttById and to return
    // a copy of the pAC->name (LdapDisplayName).
    //
    // Convert UNICODE pKey into UTF8 for scache search
    // Note: the scache is kept in UTF8 format for the ldap head.
    pName = THAllocEx(pTHS, cc);
    cName = WideCharToMultiByte(CP_UTF8,
                                0,
                                pKey,
                                cc,
                                pName,
                                cc,
                                NULL,
                                NULL);
    if (   (cName == cc) 
        && (pAC = SCGetAttByName(pTHS, cc, pName)) ) {
        at = pAC->id;
    }
    THFreeEx(pTHS, pName);

    //
    // FOUND AN LDN
    //
    if (at) {
        return at;
    }

    //
    // Not an LDN. See if it is an OID or an IID
    //

    // ignore trailing spaces
    while (cc && pKey[cc-1] == L' ') {
        --cc;
    }

    // Skip leading "OID." or "IID."
    fIntId = FALSE;
    if (   (cc > 3)
        && (   pKey[0] == L'O' 
            || pKey[0] == L'I'
            || pKey[0] == L'o'
            || pKey[0] == L'i')
        && (pKey[1] == L'I' || pKey[1] == L'i')
        && (pKey[2] == L'D' || pKey[2] == L'd')
        && (pKey[3] == L'.')) {

        // IID.xxx
        if (pKey[0] == L'I' || pKey[0] == L'i') {
            fIntId = TRUE;
        }
        pKey += 4;
        cc -= 4;
    }

    // Must have at least one digit!
    if (cc == 0) {
        return 0;
    }

    //
    // Key is a number representing the msDS-IntId
    //
    if (fIntId) {
        // Validate and convert string into a DWORD
        ullVal = (ULONGLONG)0;
        while (cc) {
            if (iswdigit(*pKey)) {
                ullVal = (ullVal * (ULONGLONG)10) + (*pKey - L'0');
                // 32bit Overflow
                if (ullVal > (ULONGLONG)0xFFFFFFFF) {
                    return 0;
                }
            } else {
                // not a decimal digit
                return 0;
            }
            --cc;
            ++pKey;
        }
        return (ATTRTYP)ullVal;
    }

    //
    // Must be an OID
    //

    if (iswdigit(*pKey)) {
        // Possibly a literal OID.
        OID oid;
        OID_t Encoded;
        char buf[128];
        ATTRTYP attrtype;
        
        // Allocate room for the oid struct (each decimal can only
        // be paired with one dot, except the last, which has none)
        oid.cVal = cc/2 + 1;
        oid.Val = (unsigned *) THAlloc(((cc/2) + 1)*(sizeof(unsigned)));
        if (!oid.Val) {
            return 0;    //Failure.
        }
        
        // turn the OID.1.2.3 string into an OID structure
        if (OidStringToStruct(pTHS, pKey, cc, &oid) != 0) {
            THFreeEx(pTHS,oid.Val);
            return 0;   // Failure.
        }

        // produce a BER encoded version of the OID
        Encoded.length = EncodeOID(&oid, buf, sizeof(buf));
        THFreeEx(pTHS,oid.Val);
        if (!Encoded.length) {
            return 0;   // Failure.
        }
        Encoded.elements = buf;

        // convert from the encoded OID to an ATTRTYP
        if (OidToAttrType(pTHS, TRUE, &Encoded, &at)) {
            return 0;   // Failure.
        }
        
        // AttrTypes are internal ids (msDS-IntId).
        return SCAttExtIdToIntId(pTHS, at);
    }

    return 0;
}

ULONG
OidToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        OID_t *OID,
        ATTRTYP *attrtyp
        )
/*++
Routine Description:
    Given an encoded OID (a.k.a. the binary value handed to the ds by the XDS
    interface), find the internal attrtyp encoding.  Also, if asked to, add
    the prefix to the prefix attribute in the DS if it does not already
    exist.

Arguments:
    fAddTotable - if the prefix is not found, add it to the prefix attribute
    OID - the encoded OID.
    attrtyp - pointer to an attrtyp to fill in.

Return Values:
    0 if all went well, a core error code otherwise.
--*/
{
    DECLAREPREFIXPTR
    DWORD   Ndx;
    unsigned Length;
    ATTCACHE * pAC;
    CLASSCACHE * pCC;
    BOOL    found = FALSE;
    int LongID = 0;


    if(!FindPrefix(OID,&Ndx, &Length, &LongID, fAddToTable)) {
        return PR_PROBLEM_UNDEFINED_ATT_TYPE;
    }

    *attrtyp = Ndx << 16;

    // handle the case where we have two bytes after the prefix;
    if (  OID->length == Length + 2 )
    {
      *attrtyp += ( ((unsigned char *)OID->elements)[OID->length - 2] & 0x7f ) << 7;
      if (LongID == 1) {
        // Put a 1 in the 16th bit to indicate that both bytes of the
        // attrtype is to be considered during the reverse mapping.
        // This is to take care of the case when the last decimal
        // in the dotted decimal string is mapped in 3 or 4 octets.
        // If the last decimal in the dotted decimal string mapped onto
        // more than one octet, the encoding scheme earlier used to just
        // put the last 7 bits of the last two octets of the BER encoded
        // OID into the last 14-bits of the attrtype, with the top two
        // bits set to 0. The decoding scheme (from attrtype to BER
        // encoding) used simply checks if bit 8-15 (counting from bit 0)
        // of the attrtype is > 0  to determine
        // if the prefix length is OID length - 2 or not (OID length -1)
        // This worked fine as long as the last decimal fitted within 2 bytes
        // in the BER encoding (decimals upto 16383, actually even 127 less
        // than that because of another bug in the encoding process, fixed
        // along with this in EncodeOID). However,
        // if the decimal becomes too big so that it is encoded in 3 or more
        // octets, for some decimals (depending on the bit string in the last
        // two bytes; for example, for 16384, where the last 16 bits in the
        // attrtype would be all 0), the decoding scheme used to infer the
        // bytes from the attrtype to be appended to the prefix
        // incorrectly (1 instead of 2), thereby giving out wrong
        // oids when printed out. Putting a 1 in the 16th bit (which is
        // unused anyway) makes sure that both bytes are appended to the
        // prefix during the decoding process in such cases.
        // [CAUTION] ArobindG 7/28/97: We do this only for 3 octets or more,
        // and not for two, since this will result in a different internal
        // id for an OID compared to the earlier schema, and many existing
        // OIDs have the last decimal encoded into two octets and we do not
        // want their internal ids changed (since dogfood machines are
        // already running with them)

      *attrtyp |= (0x8000);
      }

    }

    *attrtyp += ((unsigned char *)OID->elements)[OID->length - 1];

    return 0;
}

ULONG
AttrTypeToOid (
        ATTRTYP attrtyp,
        OID_t *OID
        )
/*++
Routine Description:
    Given an attrtype, return the encoded OID (a.k.a. the binary value returned
    to the DUA across the XDS interface.)

Arguments:
    attrtyp - the attrtyp to fill encode.
    OID - structure to hold the encoded OID.

Return Values:
    0 if all went well, non-zero on failure
--*/
{
    DECLAREPREFIXPTR
    DWORD   i, ndx;

    ndx = ( attrtyp & 0xFFFF0000 ) >> 16;
    if (FindNdx(ndx, &i) == FALSE) {
        LogEvent(DS_EVENT_CAT_XDS_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_CODE_INCONSISTENCY,
                 NULL,
                 NULL,
                 NULL);
        return 1;
    }


    if ((attrtyp & 0xFFFF ) < 0x80) {
      OID->length = PrefixTable[i].prefix.length + 1;
      OID->elements = THAlloc (OID->length);
      if ( OID->elements == NULL) {
          return 2;
      }
      memcpy (OID->elements, PrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);

      (( unsigned char *)OID->elements)[ OID->length - 1 ] =
          ( unsigned char ) ( attrtyp & 0xFF );
    }
    else {
      OID->length = PrefixTable[i].prefix.length + 2;
      OID->elements = THAlloc (OID->length);
      if ( OID->elements == NULL) {
          return 3;
      }
      memcpy (OID->elements, PrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);

      (( unsigned char *)OID->elements)[ OID->length - 1 ] =
          ( unsigned char ) (attrtyp  & 0x7F );

      // Note here that the 16th bit in the attrtype may be a 1, since
      // the encoding of the decimal may have taken 3 or 4 octets. So
      // or'ing with FF80 and then right shifting by 7 may still leave
      // a 1 in the 9th bit, and hence a number greater than what can fit
      // in 1 byte (unsigned char). Does not matter since the typecasting
      // to unsigned char assigns only the lower 8 bits. So left this
      // unchanged.

      (( unsigned char *)OID->elements)[ OID->length - 2 ] =
          ( unsigned char )  (( (attrtyp & 0xFF80) >> 7 ) | 0x80 );
    }

    return 0;
}

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.
 *    ccEncoded - count of chars in pEncoded
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID or buffer too small)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned EncodeOID(OID *pOID, unsigned char * pEncoded, unsigned ccEncoded) {
    int i;
    unsigned len;
    unsigned val;

    // check for obviously invalid OIDs or outbuf sizes

    if (ccEncoded == 0
        || pOID->cVal <= 2
        || pOID->Val[0] > 2
        || (pOID->Val[0] < 2 && pOID->Val[1] > 39)) {
        return 0;       // error
    }

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    // PERFHINT -- The value can be directly checked against the hex value
    // instead of building up the bit patterns in a strange way.

    for (i=2; i<pOID->cVal; i++) {
        val = pOID->Val[i];
        if (val > ((0x7f << 14) | (0x7f << 7) | 0x7f) ) {
            // Do we need 4 octets to represent the value?
            // Make sure it's not 5
            // Assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
            if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
              DPRINT1(0,"Decimal %u in OID too big\n", val);
              return 0;   // we can't encode things this big
            }
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
        }
        if (val > ((0x7f << 7) | 0x7f) ) {
            // Do we need 3 octets to represent the value?
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
        }
        if (val > 0x7f) {
            // Do we need 2 octets to represent the value?
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
        }
        // Encode the low 7 bits into the last octet for this value
        // buffer too small
        if (len == ccEncoded) {
            return 0;
        }
        pEncoded[len++] = val & 0x7f;
    }

    return len;
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len < 2) {
    return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
    j = 0;
    val = pEncoded[i] & 0x7f;
    while (pEncoded[i] & 0x80) {
        val <<= 7;
        ++i;
        if (++j > 4 || i >= len) {
        // Either this value is bigger than we can handle (we
        // don't handle values that span more than four octets)
        // -or- the last octet in the encoded string has its
        // high bit set, indicating that it's not supposed to
        // be the last octet.  In either case, we're sunk.
        return FALSE;
        }
        val |= pEncoded[i] & 0x7f;
    }
    Assert(i < len);
    pOID->Val[cval] = val;
    ++cval;
    ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}



#define iswdigit(x) ((x) >= L'0' && (x) <= L'9')

OidStringToStruct (
        THSTATE *pTHS, 
        WCHAR * pString,
        unsigned len,
        OID * pOID
        )
/*++
Routine Description:
    Translates a string of the format "OID.X.Y.Z"  or "X.Y.Z"
    to an oid structure of the format {count=3, val[]={X,Y,Z}}

Arguments
    pString - the string format oid.
    pLen - the length of pString in characters.
    pOID - pointer to an OID structure to fill in.  Note: the value field must
    be pre-allocated and the len field should hold the number of values
    pre-allocated.

Return Values
    o if successfull, non-0 if a failure occurred.
--*/
{
    int i;
    int numVals = pOID->cVal;
    unsigned val;
    ULARGE_INTEGER val64, checkVal;
    WCHAR * pCur = pString;
    WCHAR * pEnd = pString + len;
    WCHAR * pTemp;
    BOOL  fFoundDot=TRUE;


    checkVal.QuadPart = 0xFFFFFFFF;

    // Must have non-zero-length
    if (len == 0) {
        return 1;
    }

    if (*pCur == L'O' || *pCur == L'o') {
       // The string must start with OID.

        if (len < 5 || // must be at least as long as "OID.1"
            (*++pCur != L'I' && *pCur != L'i') ||
            (*++pCur != L'D' && *pCur != L'd') ||
            (*++pCur != L'.')) {
            return 1;
        }
        // The string starts with OID. Ok to proceed. Make
        // pCur point to the first character after the '.'
        pCur++;
     }

    // pCur is now positioned on the first character in the
    // first decimal in the string (if the string didn't start
    // with OID., I will assume it starts with a decimal. If not,
    // it will fail in the code below as desired)

    pOID->cVal = 0;

    // Skip spaces at the end
    pTemp = pEnd - 1;
    while ( (pTemp > pCur) && (*pTemp == L' ') ) {
       pTemp--;
    }
    pEnd = pTemp + 1;
    
    while (pCur < pEnd) {
        fFoundDot = FALSE;
        if (!iswdigit(*pCur)) {
            return 2;
        }
        val = *pCur - L'0';
        val64.QuadPart = *pCur - L'0';
        ++pCur;
        while (pCur < pEnd && *pCur != L'.') {
            if (!iswdigit(*pCur)) {
                // not a digit
                return 3;
            }
              
            val = 10*val + *pCur - L'0';
            val64.QuadPart = 10*(val64.QuadPart) + *pCur - L'0';

            // This value should fit in 32 bits, as we load this into
            // a 32 bit value and EncodeOID later assumes that the value
            // indeed fits in 32 bits

            if (val64.QuadPart > checkVal.QuadPart) {
               // Value does not fit in 32 bits. Too big anyway, since
               // BER encoding is valid for only values that fit in 28
               // bits. Reject the string

               return 5;
             }

            ++pCur;
        }
        // Keep track of whether we found a dot for the last character.
        fFoundDot = (pCur < pEnd);
        if(pOID->cVal >= numVals) {
            return 4;
        }
        pOID->Val[pOID->cVal] = val;
        pOID->cVal++;
        ++pCur;
    }

    // If the last character we found was a dot, then this is an invalid
    // string.  Otherwise, everything is OK.
    return fFoundDot;
}

unsigned
AttrTypeToIntIdString (
        ATTRTYP attrtyp,
        WCHAR   *pOut,
        ULONG   ccOut
        )
/*++
Routine Description:
    Translates an attrtyp into a string of the format "IID.X"
    where X is the base 10 representation of the attrtyp
    (which should be the msDs-IntId, not the tokenized OID)

Arguments
    attrtyp - to be converted (msDs-IntId)
    pOut - preallocated string to fill in.
    ccOut - count of chars in pOut

Return Values
    number of characters in the resulting string.
--*/
{
    OID Oid;

    Oid.cVal = 1;
    Oid.Val = &attrtyp;

    ccOut = OidStructToString(&Oid, pOut, ccOut);
    if (ccOut) {
        // change OID. -> IID.
        Assert(*pOut == L'O');
        *pOut = L'I';
    }
    return (unsigned)ccOut;
}

unsigned
OidStructToString (
        OID *pOID,
        WCHAR *pOut,
        ULONG ccOut
        )
/*++
Routine Description:
    Translates a structure in the format
         {count=3, val[]={X,Y,Z}}
    to a string of the format "OID.X.Y.Z".

Arguments
    pOID - pointer to an OID structure to translate from.
    pOut - preallocated string to fill in.
    ccOut - count of chars in pOut

Return Values
    0 if not enough space; otherwise the
    number of characters in the resulting string.
--*/
{
    int i;
    WCHAR *pCur = pOut, *pEnd, *pVal;
    WCHAR Val[16]; // large enough to convert a 32bit number
                   // into an unsigned decimal string including
                   // the terminating NULL

    // need enough space for at least OID.X
    if (ccOut < 5) {
        return 0;
    }

    // pEnd is the first char past the end of pOut
    pEnd = pOut + ccOut;

    // pOut = "OID"
    *pCur++ = L'O';
    *pCur++ = L'I';
    *pCur++ = L'D';

    // .X.Y.Z...
    for (i=0; i<pOID->cVal; i++) {
        if (pCur == pEnd) {
            return 0;
        }
        *pCur++ = L'.';
        _ultow(pOID->Val[i], Val, 10);
        for (pVal = Val; *pVal; ) {
            if (pCur == pEnd) {
                return 0;
            }
            *pCur++ = *pVal++;
        }
    }
    return (unsigned)(pCur - pOut);
}

int
AttrTypToString (
        THSTATE *pTHS,
        ATTRTYP attrTyp,
        WCHAR *pOutBuf,
        ULONG cLen
        )
/*++
Routine Description:
    Given an attrtype, return the dotted string representation in unicode.

Arguments:
    attrTyp - the attribute type to convert
    pOutBuf - pointer to a buffer to hold the unicode string.  
    cLen - length of the buffer in no. of characters

Return Values:
    the len of the string as characters, 
    -1 for errors other that insufficient buffer size
    -2 for insufficient buffer size
--*/
{
    OID_t Oid;
    OID                  oidStruct;
    unsigned             len;
    BOOL                 fOK;
    WCHAR                *pTemp;
    ULONG                cMaxChar;

    // First, build the OID describing the attrtype
    if(AttrTypeToOid (attrTyp, &Oid)) {
        return -1;
    }

    // Allocate space in oidStruct to hold the decoded decimals in the
    // dotted decimal string. Number of elements in the dotted string cannot
    // be more than Oid.length (length in bytes of the BER encoded string) + 1.
    // This is the case where each byte in the BER encoded string unencodes to a
    // single element in the oid structure (the other option is that it takes
    // multiple bytes in the BER encoding to get one element in the oid
    // structure).  The additional element is because the first byte in the BER
    // encoding ALWAYS encodes for two elements in the OID structure.  As an
    // example, the BER encoding 0x55,0x05,Ox7 translates to 1.2.5.7 (the first
    // 0x55 translates to 1.2., while the rest are single byte encodings.)
    // plus 1 (since the first two decimals in the dotted decimal string
    // are encoded into a single byte)

    oidStruct.Val = (unsigned *) THAlloc((1 + Oid.length)*(sizeof(unsigned)) );
    if (!oidStruct.Val) {
        return -1;   //fail to alloc
    }

    fOK = DecodeOID(Oid.elements, Oid.length, &oidStruct);
    THFreeEx(pTHS,Oid.elements);
    if(!fOK) {
        THFreeEx(pTHS,oidStruct.Val);
        return -1;
    }

    // Now, turn the OID to a string
    // OidStructToString expects a big enough buffer, so give it one. Note that 
    // the max no. of characters that can be there in the final string is
    // 3 (for "OID") + 1 (for ".") for each of the decimals, plus at most 9
    // for the string representation of each of the decimals (since each decimal
    // can be at most (2^28 - 1) from the nature of BER encoding)
    // So if the buffer supplied is big enough, use it directly,
    // else alloc a local buffer and use it, then copy to the output buffer
   // the actual no. of characters if buffer size is sufficient
   
    cMaxChar = 3 + 10*oidStruct.cVal;
    
    if (cLen >= cMaxChar) {
       len = OidStructToString(&oidStruct, pOutBuf, cLen);
    }
    else {
       pTemp = (WCHAR *) THAlloc(cMaxChar * sizeof(WCHAR));
       if (!pTemp) {
           THFreeEx(pTHS,oidStruct.Val);
           return -1;  //fail to alloc
       }
       len = OidStructToString(&oidStruct, pTemp, cMaxChar);

       // check if the buffer supplied to us is big enough
       if (cLen < len) {
         // buffer not big enough
         THFreeEx(pTHS,oidStruct.Val);
         THFreeEx(pTHS,pTemp);
         return (-2);
       }

       // ok, buffer is big enough. Copy to output
       memcpy(pOutBuf, pTemp, len*sizeof(WCHAR));
       THFreeEx(pTHS,pTemp);
    }

    THFreeEx(pTHS,oidStruct.Val);
    return len;

}

int
StringToAttrTyp (
        THSTATE *pTHS,
        WCHAR   *pInString,
        ULONG   len,
        ATTRTYP *pAttrTyp
        )
/*++
Routine Description:
    Given an attrtype, return the dotted string representation in unicode.

Arguments:
    attrTyp - the attribute type to convert
    pOutBuf - pointer to a buffer to hold the unicode string.  Must be large
    enough

Return Values:
    the len of the string as characters, -1 if something went wrong.
--*/
{
    OID oidStruct;
    // Each character in the OID string can take at most 4 octets
    // in the BER encoding
    OID_t EncodedOID;
    ULONG cbEncoded = (4 * len) * sizeof(unsigned char);
    unsigned char *Encoded = (unsigned char *)THAlloc(cbEncoded);

    if (!Encoded) {
        return -1; //fail to alloc
    }


    EncodedOID.elements = Encoded;

    // First, turn the string into an OID struct.

    // Allocate space first. Can be at most len no. of elements
    oidStruct.cVal = len;
    oidStruct.Val = (unsigned *) THAlloc((len*(sizeof(unsigned))));
    if (!oidStruct.Val) {
        THFreeEx(pTHS,Encoded);
        return -1; //fail to alloc
    }


    if(   OidStringToStruct(pTHS, pInString,len,&oidStruct)     
       // Turn the OID struct into an encoded OID.
       || !(EncodedOID.length = EncodeOID(&oidStruct, Encoded, cbEncoded))
       // Now, turn the encoded oid into an attrtyp
       || OidToAttrType(pTHS, TRUE, &EncodedOID, pAttrTyp))
    {
        THFreeEx(pTHS,Encoded);
        THFreeEx(pTHS,oidStruct.Val);
        return -1;
    }
    
    THFreeEx(pTHS,Encoded);
    THFreeEx(pTHS,oidStruct.Val);
    return 0;
}


#if DBG
////////////////////////////////////////////////////////////////////////////
// Debug routine to print out a prefix table
//////////////////////////////////////////////////////////////////////
void PrintPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
   ULONG i;
   UCHAR temp[200];
   DWORD       ib;
   BYTE *      pb;


   for (i=0; i<PREFIXCOUNT; i++) {
     pb = (LPBYTE) PrefixTable[i].prefix.elements;
     if (pb != NULL) {
       for ( ib = 0; ib < PrefixTable[i].prefix.length; ib++ )
        {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
        }
       temp[2*PrefixTable[i].prefix.length]='\0';
       DPRINT4(0,"%2d. Ndx=%-4d Length=%-3d Prefix=%s\n",i,PrefixTable[i].ndx,PrefixTable[i].prefix.length, temp);
     }
   }
  DPRINT(0, "Exitting Prefix table Print\n");
}
#endif


// Simple SCHEMA_PREFIX_MAP_ENTRY comparison routine for use by qsort().
int __cdecl CompareMappings(const void * pvMapping1, const void * pvMapping2)
{
    SCHEMA_PREFIX_MAP_ENTRY * pMapping1 = (SCHEMA_PREFIX_MAP_ENTRY *) pvMapping1;
    SCHEMA_PREFIX_MAP_ENTRY * pMapping2 = (SCHEMA_PREFIX_MAP_ENTRY *) pvMapping2;

    return (int)pMapping1->ndxFrom - (int)pMapping2->ndxFrom;
}


BOOL
PrefixTableAddPrefixes(
    IN  SCHEMA_PREFIX_TABLE *   pRemoteTable
    )
/*++

Routine Description:

    Scan the given prefix table and add entries in our own table for any
    missing prefixes.

Arguments:

    pTable (IN) - Table to incorporate into our own.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    THSTATE               * pTHS=pTHStls;
    BOOL                    ok = TRUE;
    DWORD                   iRemote, iLocal;
    SCHEMA_PREFIX_TABLE   * pLocalTable;
    OID_t                 * pPrefixStr;
    DWORD                   ndx;

    pLocalTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    for (iRemote = 0; ok && (iRemote < pRemoteTable->PrefixCount); iRemote++) {
        pPrefixStr = &pRemoteTable->pPrefixEntry[iRemote].prefix;

        // Do we already have this prefix?
        for (iLocal = 0; iLocal < pLocalTable->PrefixCount; iLocal++) {
            if ((pLocalTable->pPrefixEntry[iLocal].prefix.length == pPrefixStr->length)
                && (0 == memcmp(pLocalTable->pPrefixEntry[iLocal].prefix.elements,
                                pPrefixStr->elements,
                                pPrefixStr->length))) {
                // Found matching local prefix.
                break;
            }
        }

        if (iLocal == pLocalTable->PrefixCount) {
            // Local prefix not found; add it.
            if (AddPrefixIfNeeded(pPrefixStr, pPrefixStr->length, &ndx)) {
                DPRINT(0, "Failed to incorporate new OID prefix.\n");
                ok = FALSE;
            }
        }
    }

    return ok;
}


SCHEMA_PREFIX_MAP_HANDLE
PrefixMapOpenHandle(
    IN  SCHEMA_PREFIX_TABLE *   pTableFrom,
    IN  SCHEMA_PREFIX_TABLE *   pTableTo
    )
/*++

Routine Description:

    Generate a mapping handle given two prefix tables for use in later calls to
    PrefixMapAttr() and PrefixMapTypes().

    Caller is responsible for eventually calling PrefixMapCloseHandle() on
    the returned handle.

Arguments:

    pTableFrom (IN) - holds the prefixes for the ATTRTYPs being mapped from.
    pTableTo (IN) - holds the prefixes for the ATTRTYPs being mapped to.

Return Values:

    The generated handle.

--*/
{
    THSTATE *                   pTHS = pTHStls;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap;
    OID_t *                     pPrefixStr;
    DWORD                       iFrom, iTo;
    SCHEMA_PREFIX_TABLE *       pLocalTable;
    PrefixTableEntry *          pNewPrefix = (PrefixTableEntry *) pTHS->NewPrefix;

    pLocalTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    hPrefixMap = THAllocEx(pTHS, SchemaPrefixMapSizeFromLen(pTableFrom->PrefixCount));

    hPrefixMap->pTHS = pTHS;
    if (pTableFrom == pLocalTable) {
        hPrefixMap->dwFlags = SCHEMA_PREFIX_MAP_fFromLocal;
    }
    else if (pTableTo == pLocalTable) {
        hPrefixMap->dwFlags = SCHEMA_PREFIX_MAP_fToLocal;
    }

    for (iFrom = 0; (iFrom < pTableFrom->PrefixCount); iFrom++) {
        // Only the lower 16 bits of an ndx should be significant.
        Assert((ULONG) (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx
               == pTableFrom->pPrefixEntry[iFrom].ndx);

        pPrefixStr = &pTableFrom->pPrefixEntry[iFrom].prefix;

        for (iTo = 0; (iTo < pTableTo->PrefixCount); iTo++) {
            // Only the lower 16 bits of an ndx should be significant.
            Assert((ULONG) (USHORT) pTableTo->pPrefixEntry[iTo].ndx
                   == pTableTo->pPrefixEntry[iTo].ndx);

            if ((pPrefixStr->length
                 == pTableTo->pPrefixEntry[iTo].prefix.length)
                && !memcmp(pPrefixStr->elements,
                           pTableTo->pPrefixEntry[iTo].prefix.elements,
                           pPrefixStr->length)) {

                // Found matching prefix; generate a mapping entry.
                hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxFrom
                    = (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx;

                hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxTo
                    = (USHORT) pTableTo->pPrefixEntry[iTo].ndx;

                hPrefixMap->cNumMappings++;
                break;
            }
        }

        if ((iTo == pTableTo->PrefixCount)
             && (hPrefixMap->dwFlags & SCHEMA_PREFIX_MAP_fToLocal)) {
            // No matching prefix found in the global cache; do we have one
            // in our thread's new prefix table?
            for (iTo = 0; iTo < pTHS->cNewPrefix; iTo++) {
                // Only the lower 16 bits of an ndx should be significant.
                Assert((ULONG) (USHORT) pNewPrefix[iTo].ndx
                       == pNewPrefix[iTo].ndx);

                if ((pPrefixStr->length
                     == pNewPrefix[iTo].prefix.length)
                    && !memcmp(pPrefixStr->elements,
                               pNewPrefix[iTo].prefix.elements,
                               pPrefixStr->length)) {

                    // Found matching prefix; generate a mapping entry.
                    hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxFrom
                        = (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx;

                    hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxTo
                        = (USHORT) pNewPrefix[iTo].ndx;

                    hPrefixMap->cNumMappings++;
                    break;
                }
            }
        }

        // Note that if no matching prefix was found in pTableTo, we simply fail
        // to add an entry in the mapping table for the corresponding "from"
        // ndx.  SUCH FAILURES ARE *NOT* FATAL.  If an attempt is later made to
        // map this ndx, a failure will be generated at that time.  If not, it
        // doesn't matter that we were unable to generate a mapping.
    }

    if (hPrefixMap->cNumMappings < pTableFrom->PrefixCount) {
        // Not all prefixes were mapped; release the memory allocated for the
        // unused mapping entries back to the heap.
        hPrefixMap = THReAllocEx(pTHS,
                                 hPrefixMap,
                         SchemaPrefixMapSizeFromLen(hPrefixMap->cNumMappings));
    }

    // Sort the mapping table by ndxFrom.
    qsort(&hPrefixMap->rgMapping[0],
          hPrefixMap->cNumMappings,
          sizeof(hPrefixMap->rgMapping[0]),
          &CompareMappings);

    return hPrefixMap;
}


BOOL
PrefixMapTypes(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN      DWORD                     cNumTypes,
    IN OUT  ATTRTYP *                 pTypes
    )
/*++

Routine Description:

    Map one or more ATTRTYPs from one prefix table to another.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    cNumTypes (IN) - number of types to convert.
    pTypes (IN/OUT) - array of types to convert.

Return Values:

    TRUE - attribute type(s) converted successfully.
    FALSE - conversion failed.

--*/
{
    SCHEMA_PREFIX_MAP_ENTRY *   pMapping;
    SCHEMA_PREFIX_MAP_ENTRY     MappingKey;
    DWORD                       iType;
    BOOL                        ok = TRUE;

    Assert(NULL != hPrefixMap);

    for (iType = 0; iType < cNumTypes; iType++) {
        // Find matching "from" ndx in mapping table.
        MappingKey.ndxFrom = (USHORT) (pTypes[iType] >> 16);

        pMapping = bsearch(&MappingKey,
                           &hPrefixMap->rgMapping[0],
                           hPrefixMap->cNumMappings,
                           sizeof(hPrefixMap->rgMapping[0]),
                           &CompareMappings);

        if (NULL != pMapping) {
            // Mapping found; convert the type.
            pTypes[iType] = (((ULONG) pMapping->ndxTo) << 16)
                            | (pTypes[iType] & 0xFFFF);
        } else if (pTypes[iType] <= LAST_MAPPED_ATT) {

            // The lack of a mapping is okay if the attid falls outside
            // the range of mapped attids. In that case, return success
            // and leave the attid unchanged. But if the attid falls
            // within the range of mapped attids and there is no mapping,
            // return failure.

            ok = FALSE;
            break;
        }
    }

    if (!ok) {
        DPRINT1(1, "Unable to map attribute 0x%x.\n", pTypes[iType]);
    }

    return ok;
}


BOOL
PrefixMapAttr(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTR *                    pAttr
    )
/*++

Routine Description:

    Convert ATTRTYPs embedded in an ATTR structure to or from their equivalents
    on a remote machine.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    pAttr (IN/OUT) - the ATTR to convert.

Return Values:

    TRUE - attribute type (and all of its values, if necessary) converted
        successfully.
    FALSE - conversion failed.

--*/
{
    THSTATE    *pTHS=hPrefixMap->pTHS;
    BOOL        ok = TRUE;
    ATTCACHE *  pAC;
    DWORD       iVal;
    ATTRTYP     typeFrom;
    ATTRTYP     typeLocal;

    Assert(NULL != hPrefixMap);

    // One of the "from" or "to" tables must be the local table.
    Assert(hPrefixMap->dwFlags & (SCHEMA_PREFIX_MAP_fFromLocal
                                  | SCHEMA_PREFIX_MAP_fToLocal));

    typeFrom = pAttr->attrTyp;

    if (PrefixMapTypes(hPrefixMap, 1, &pAttr->attrTyp)) {
        // Successfully mapped pAttr->attrTyp.
        typeLocal = (hPrefixMap->dwFlags & SCHEMA_PREFIX_MAP_fFromLocal)
                        ? typeFrom : pAttr->attrTyp;

        pAC = SCGetAttById(pTHS, typeLocal);

        if (NULL != pAC) {
            if (SYNTAX_OBJECT_ID_TYPE == pAC->syntax) {
                // Convert attribute's values.
                for (iVal = 0; ok && (iVal < pAttr->AttrVal.valCount); iVal++) {
                    ok = PrefixMapTypes(hPrefixMap, 1,
                                        (ATTRTYP *) pAttr->AttrVal.pAVal[iVal].pVal);
                }
            }
        }
        else if (typeFrom <= LAST_MAPPED_ATT) {
            // The lack of a mapping is okay if the attid falls outside
            // the range of mapped attids. In that case, return success
            // and leave the attid unchanged. But if the attid falls
            // within the range of mapped attids and there is no mapping,
            // return failure.

            // No ATTCACHE for this attribute.
            // and it is not one of the virtual attributes defined in objids.h.
            DPRINT1(0, "Unable to find ATTCACHE for local attribute %u.\n",
                    typeLocal);
            ok = FALSE;
        }
    }
    else {
        // Conversion of pAttr->attrTyp failed.
        ok = FALSE;
    }

    return ok;
}


BOOL
PrefixMapAttrBlock(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTRBLOCK *               pAttrBlock
    )
/*++

Routine Description:

    Map all ATTRTYPs embedded in an ATTRBLOCK structure.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    pAttrBlock (IN/OUT) - the ATTRBLOCK to convert.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    BOOL  ok = TRUE;
    DWORD iAttr;

    Assert(NULL != hPrefixMap);
    Assert(NULL != pAttrBlock);

    for (iAttr = 0; ok && iAttr < pAttrBlock->attrCount; iAttr++) {
        ok = PrefixMapAttr(hPrefixMap, &pAttrBlock->pAttr[iAttr]);
    }

    return ok;
}

BOOL
OIDcmp (OID_t const *string1,
        OID_t const *string2)
{
    unsigned i;
    
    if (string1->length != string2->length)
        return FALSE;
    
    // optimize for OIDs, which differ ususally at the end
    for(i=string1->length; i> 0; i--) {
        if ((string1->elements)[i-1] !=
            (string2->elements)[i-1]      ) {
            return FALSE;
        }
    }
    
    return TRUE;
}


#define CHARTONUM(chr) (isalpha(chr)?(tolower(chr)-'a')+10:chr-'0')


unsigned
StringToOID (
        char* Stroid,
        OID_t *Obj
        )
/*++
Routine Description:
    Converts a hex char string into an OID string

Arguments:
    IN  stroid - char string
    OUT Obj    - OID_t kind of string
Return Values
    0 on success, non-0 on failure
--*/
{
    UCHAR  tmp[2048];
    int   i;
    int len=strlen(Stroid);


    if (len/2 > sizeof(tmp))
    {
        return 1;
    }

    //
    // Skip leading '\x' in str
    //

    if (Stroid[0]!='\\' || tolower(Stroid[1]!='x'))
    {
        return 2;
    }

    for (i=2;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(Stroid[i])*16;
        UCHAR lo=CHARTONUM(Stroid[i+1]);
        tmp[(i-2)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        tmp[(i-2)/2]=CHARTONUM(Stroid[i]);
        i+=2;
    }

    Obj->length  =(i-2)/2;
    Obj->elements=(unsigned char *)calloc(1,Obj->length);

    if (Obj->elements)
    {
        CopyMemory
        (
            Obj->elements,
            tmp,
            Obj->length
        );
    }
    else
    {
        return 3;
    }

    return 0;
}


ULONG
OidStrToAttrType(THSTATE *pTHS,
                 BOOL fAddToTable,
                 char* StrOid,
                 ATTRTYP *attrtyp)
{
    unsigned err;
    OID_t OID;

    err = StringToOID(StrOid,&OID);

    if (err == 0)
    {
        err = OidToAttrType(pTHS, fAddToTable, &OID, attrtyp);
        free(OID.elements);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\phantom.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       phantom.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <dsjet.h>                      // for error codes
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
#include <drs.h>
#include <gcverify.h>
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers
#include "debug.h"                      // standard debugging header
#define DEBSUB "PHANTOM:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PHANTOM

// How many times will we go to the GC before we quit running this task and
// reschedule ourselves?  Don't make it too high, or we end up hogging the task
// queue thread.
#define MAX_GC_TRIPS 10

// How many phantom names do we gather at once before we head off to the GC to
// verify the data?
#define NAMES_PER_GC_TRIP       240

// The algorithm below works best if max_stale_phantoms is a multiple of
// NAMES_PER_GC_TRIP, and MAX_STALE_PHANTOMS must be small enough that we can
// write that many dnt values as an attribute on an object (i.e. small enough to
// avoid DBLayer limits on max attribute values per object).
#define MAX_STALE_PHANTOMS 720

// No matter what, don't schedule this to run more often than once every 15
// minutes.
#define PHANTOM_DAEMON_MIN_DELAY (15 * 60)

// No matter what, don't schedule this to run less often than once a day
#define PHANTOM_DAEMON_MAX_DELAY (24 * 60 * 60)

#define SECONDS_PER_DAY (24 * 60 * 60)

// How many days will we take to scan the whole DIT?
#define DEFAULT_PHANTOM_SCAN_RATE 2

// The following variable is set to TRUE when we think we are the phantom
// cleanup master AND we think we have managed to schedule the normal phantom
// cleanup task.
DWORD gfIsPhantomMaster = FALSE;

VOID
LogPhantomCleanupFailed(
    IN DWORD ErrCode,
    IN DWORD ExtError,
    IN DWORD DsId,
    IN DWORD Problem,
    IN DWORD ExtData
    )
{
    LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
              DS_EVENT_SEV_VERBOSE,
              DIRLOG_STALE_PHANTOM_CLEANUP_ADD_FAILED,
              szInsertUL(ErrCode),
              szInsertHex(ExtError),
              szInsertUL(DsId),
              szInsertUL(Problem),
              szInsertUL(ExtData),
              NULL, NULL, NULL);

} // LogPhantomCleanupFailed

VOID
spcAddCarrierObject (
        THSTATE *pTHS,
        DSNAME  *pInfrObjName,
        DWORD    count,
        PDSNAME *pFreshNames
        )
/*++
  Description:
      Given the name of an object and a list of dsnames, add a new object under
      the given object.  The RDN is a guid.  The new object is an
      INFRASTRUCTURE_UPDATE object, and the list of DNTs are added as values of
      the attribute DN_REFERENCE_UPDATE.  After successfully adding the object,
      it is deleted.  This leaves a tombstone that will replicate around,
      carrying the values of DN_REFERENCE_UPDATE, but that will dissappear after
      the tombstone lifetime.

      This is called by the phantom update daemon, below.

  Return values:
      None.  The object is added if it can be, otherwise an error is logged.
--*/
{
    REMOVEARG      RemoveArg;
    REMOVERES      RemoveRes;
    ADDARG         AddArg;
    ADDRES         AddRes;
    GUID           NewRDNGuid;
    WCHAR         *pNewRDN=NULL;
    DSNAME        *pNewName;
    ATTRTYP        InfrastructureObjClass=CLASS_INFRASTRUCTURE_UPDATE;
    ATTRVAL        classVal;
    ATTR          *pAttrs = NULL;
    DWORD          i;
    ATTRVAL       *pNewNamesAttr;
    DWORD          newNamesCount;
    ULONG          dwException, ulErrorCode, dsid;
    PVOID          dwEA;

    Assert(count);

    if (!gUpdatesEnabled) {
        // Can't add anything yet.
        LogPhantomCleanupFailed(0,
                                DIRERR_SCHEMA_NOT_LOADED,
                                DSID(FILENO, __LINE__),
                                0,
                                0);
        return;
    }

    if (eServiceShutdown) {
        return;
    }

    // Make the name of the new object.  It's the name of the domain
    // infrastructure object with an RDN based on a guid tacked on.

    pNewName = THAllocEx(pTHS, pInfrObjName->structLen + 128);

    DsUuidCreate(&NewRDNGuid);
    DsUuidToStringW(&NewRDNGuid, &pNewRDN);
    AppendRDN(pInfrObjName,
              pNewName,
              pInfrObjName->structLen + 128,
              pNewRDN,
              0,
              ATT_COMMON_NAME);
    RpcStringFreeW(&pNewRDN);

    // Now, the attrblock.  Start by building the attrval array for the new
    // names.
    pNewNamesAttr = THAllocEx(pTHS, count * sizeof(ATTRVAL));
    newNamesCount = 0;
    for(i=0;i<count;i++) {
        pNewNamesAttr[i].valLen = pFreshNames[i]->structLen;
        pNewNamesAttr[i].pVal = (PUCHAR)pFreshNames[i];
    }

    // pAttrs must be THAlloced, it is asserted by CheckAddSecurity which is
    // called via the DirAddEntry below.
    pAttrs = THAllocEx(pTHS, 2 * sizeof(ATTR));

    pAttrs[0].attrTyp = ATT_OBJECT_CLASS;
    pAttrs[0].AttrVal.valCount = 1;
    pAttrs[0].AttrVal.pAVal = &classVal;

    classVal.valLen = sizeof(ATTRTYP);
    classVal.pVal = (PUCHAR)&InfrastructureObjClass;

    pAttrs[1].attrTyp = ATT_DN_REFERENCE_UPDATE;
    pAttrs[1].AttrVal.valCount = count;
    pAttrs[1].AttrVal.pAVal = pNewNamesAttr;

    // Make the addarg
    memset(&AddArg, 0, sizeof(ADDARG));
    AddArg.pObject = pNewName;
    AddArg.AttrBlock.attrCount = 2;
    AddArg.AttrBlock.pAttr = pAttrs;
    InitCommarg(&AddArg.CommArg);
    AddArg.CommArg.Svccntl.dontUseCopy = TRUE;

    // Make the remarg
    memset(&RemoveArg, 0, sizeof(REMOVEARG));
    RemoveArg.pObject = pNewName;
    InitCommarg(&RemoveArg.CommArg);
    RemoveArg.CommArg.Svccntl.dontUseCopy = TRUE;

    __try {
        // GC verification intentially performed outside transaction scope.
        SYNC_TRANS_WRITE();       /* Set Sync point*/
	__try {

            if(DoNameRes(pTHS,
                         0,
                         pInfrObjName,
                         &AddArg.CommArg,
                         &AddRes.CommRes,
                         &AddArg.pResParent)) {
		// Name Res failed.  But, we were looking for the infrastructure
                // update object, so it should never fail.
                __leave;
            }
            else{
                // Ok, we're adding a normal object inside an NC
                // that we hold a master copy of.  Let'er rip
                if ( LocalAdd(pTHS, &AddArg, FALSE) ) {
                    __leave;
                }
            }

            // Now, the delete.
            // Perform name resolution to locate object.  If it fails,
            // just return an error, which may be a referral. Note that
            // we must demand a writable copy of the object.

	
            if(DoNameRes(pTHS,
                         0,
                         pNewName,
                         &RemoveArg.CommArg,
                         &RemoveRes.CommRes,
                         &RemoveArg.pResObj)) {
                // Name Res failed, but we just successfully added this thing,
                // so it should never fail.
                __leave;
            }
            else {
                LocalRemove(pTHS, &RemoveArg);
            }
        }
	__finally {
            DWORD dsid=0, extendedErr=0, extendedData=0, problem=0;

            Assert(pTHS->errCode != securityError);

            switch(pTHS->errCode) {
            case attributeError:
                dsid = pTHS->pErrInfo->AtrErr.FirstProblem.intprob.dsid;
                extendedErr =
                    pTHS->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr;
                extendedData =
                    pTHS->pErrInfo->AtrErr.FirstProblem.intprob.extendedData;
                problem =
                    pTHS->pErrInfo->AtrErr.FirstProblem.intprob.problem;
                break;

            case 0:
                // No error.
                if(AbnormalTermination()) {
                    dsid=DSID(FILENO, __LINE__);
                    extendedErr = ERROR_DS_UNKNOWN_ERROR;
                }
                break;

            default:
                // Just assume it was an update error, the rest of the
                // structures are all alike.
                dsid = pTHS->pErrInfo->UpdErr.dsid;
                extendedErr = pTHS->pErrInfo->UpdErr.extendedErr;
                extendedData = pTHS->pErrInfo->UpdErr.extendedData;
                problem = pTHS->pErrInfo->UpdErr.problem;
                break;
            }

            if (pTHS->errCode || AbnormalTermination()) {
                LogPhantomCleanupFailed(
                            pTHS->errCode,
                            extendedErr,
                            dsid,
                            problem,
                            extendedData);
            }

	    CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction
	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }



    THFreeEx(pTHS, pNewName);
    THFreeEx(pTHS, pNewNamesAttr);
    // Explicitly DON'T free pAttrs.  CheckAddSecurity() realloc'ed it in order
    // to add a security descriptor to the list.  Instead, free the realloc'ed
    // block, which was put back into the add arg.
    THFreeEx(pTHS, AddArg.AttrBlock.pAttr);

    return;
}

BOOL
GetBetterPhantomMaster(
        THSTATE *pTHS,
        DSNAME **ppDN
        )
/*++
  Description:
      See if we can find a DC that we think would be a better candidate for
      holding the phantom master fsmo. We're looking for a replica of our domain
      that is not a DC.


     Issue a search from the sites container.
     Filter is
       (& (objectCategory=NTDS-Settings)
          (HasMasterNCs=<MyNC>)
          (!(Options.bitOr.ISGC)))
     Size limit 1.
     Atts selected = NONE

     Any object found by this search would be a better server to hold the FSMO.
--*/
{
    DWORD                  Opts;
    FILTER                 Filter;
    FILTER                 FilterClauses[3];
    FILTER                 FilterNot;
    SEARCHARG              SearchArg;
    SEARCHRES             *pSearchRes;
    CLASSCACHE            *pCC;
    ENTINFSEL              eiSel;
    DSNAME                *pSitesContainer;


    // build search argument

    // Sites container is the parent of our site object.
    pSitesContainer = THAllocEx(pTHS, gAnchor.pSiteDN->structLen);
    TrimDSNameBy(gAnchor.pSiteDN, 1, pSitesContainer);

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = pSitesContainer;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pSelection = &eiSel;
    InitCommarg(&(SearchArg.CommArg));
    SearchArg.CommArg.ulSizeLimit = 1;
    SearchArg.CommArg.Svccntl.localScope = TRUE;

    // Get the class cache to get hold of the object category.
    pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA);
    Assert(pCC);

    // build filter
    memset (&Filter, 0, sizeof (Filter));
    Filter.pNextFilter = NULL;
    Filter.choice = FILTER_CHOICE_AND;
    Filter.FilterTypes.And.count = 3;
    Filter.FilterTypes.And.pFirstFilter = FilterClauses;

    memset (&FilterClauses, 0, sizeof (FilterClauses));
    FilterClauses[0].pNextFilter = &FilterClauses[1];
    FilterClauses[0].choice = FILTER_CHOICE_ITEM;
    FilterClauses[0].FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.Value.valLen =
        pCC->pDefaultObjCategory->structLen;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.Value.pVal =
        (PUCHAR) pCC->pDefaultObjCategory;

    FilterClauses[1].pNextFilter = &FilterClauses[2];
    FilterClauses[1].choice = FILTER_CHOICE_ITEM;
    FilterClauses[1].FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterClauses[1].FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS;
    FilterClauses[1].FilterTypes.Item.FilTypes.ava.Value.valLen =
        gAnchor.pDomainDN->structLen;
    FilterClauses[1].FilterTypes.Item.FilTypes.ava.Value.pVal =
        (PUCHAR) gAnchor.pDomainDN;

    FilterClauses[2].pNextFilter = NULL;
    FilterClauses[2].choice = FILTER_CHOICE_NOT;
    FilterClauses[2].FilterTypes.pNot = &FilterNot;

    memset (&FilterNot, 0, sizeof (FilterNot));
    FilterNot.pNextFilter = NULL;
    FilterNot.choice = FILTER_CHOICE_ITEM;
    FilterNot.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    FilterNot.FilterTypes.Item.FilTypes.ava.type = ATT_OPTIONS;
    FilterNot.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(Opts);
    FilterNot.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR) &Opts;
    Opts = NTDSDSA_OPT_IS_GC;

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    eiSel.AttrTypBlock.attrCount = 0;
    eiSel.AttrTypBlock.pAttr = NULL;


    // Search for all Address Book objects.
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes,0);

    THFreeEx(pTHS, pSitesContainer);

    if(!pSearchRes->count) {
        *ppDN = NULL;
    }
    else {
        *ppDN = pSearchRes->FirstEntInf.Entinf.pName;
    }

    THFreeEx(pTHS, pSearchRes);

    return ((BOOL)(*ppDN != NULL));
}

BOOL
InitPhantomCleanup (
        IN  THSTATE  *pTHS,
        OUT BOOL     *pIsPhantomMaster,
        OUT DSNAME  **ppInfrObjName
        )
/*++

  Description:
      Verifies that we shoudl be running the phantom cleanup task by
      1) Checking that we are the FSMO role holder.
      2) Checking that we are NOT a GC.
      3) Checking that the phantom index exists.
      4) Checking that we can successfully create the phantom index if it
      doesn't exist.

  Return Values:
      Returns TRUE if we passed all the checks.  In that case, the dsname of the
      infrastructure update object is also returned.

--*/
{
    BOOL    rtn = FALSE;
    BOOL    fCommit = FALSE;
    DWORD   i;
    DWORD   InBuffSize;
    DWORD   outSize;
    DSNAME *pTempDN = NULL;
    DWORD   err;

    if(!gAnchor.pInfraStructureDN) {
        // This machine isn't set up to do this.  We don't support stale
        // phantoms here.
        return FALSE;
    }

    Assert(!pTHS->pDB);
    DBOpen(&pTHS->pDB);
    __try {


        // First, find out if I'm really the phantom cleanup master
        if((DBFindDSName(pTHS->pDB, gAnchor.pInfraStructureDN))  ||
           (DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_FSMO_ROLE_OWNER,
                        DBGETATTVAL_fREALLOC | DBGETATTVAL_fSHORTNAME,
                        0,
                        &outSize,
                        (PUCHAR *)&pTempDN))) {
            // I couldn't verify who the phantom master is.
            __leave;
        }

        // OK, I know who the phantom master is.
        if(!NameMatched(pTempDN, gAnchor.pDSADN)) {
            // It's not me.
            *pIsPhantomMaster = FALSE;
            __leave;
        }

        THFreeEx(pTHS, pTempDN);

        // I am the FSMO role holder.
        *pIsPhantomMaster = TRUE;

        // Do we need to worry about any of this?
        if(gAnchor.uDomainsInForest <= 1) {
            // Only one domain exists.  That means two things
            // 1) We aren't going to find any phantoms to remove
            // 2) No one else is either.
            // So, return from this routine with the code saying to not bother
            // doing any phantom cleanup, but don't bother looking for anyone
            // else to hold the phantom cleanup role.
            __leave;
        }
          
        // OK, now find out if we are a GC (in which case we won't find any
        // phantoms, so we don't need to do any phantom cleanup.)
        if (gAnchor.fAmGC) {
            DSNAME *pDN = NULL;
            // Yes.  The stale phantom stuff doesn't do anything on a GC.
            if(GetBetterPhantomMaster(pTHS, &pDN)) {
                // Complain, and tell them to move the role to a non-GC.
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_STALE_PHANTOM_CLEANUP_MACHINE_IS_GC,
                         szInsertDN(pDN),
                         NULL,
                         NULL);

                THFreeEx(pTHS, pDN);
            }
            // ELSE
            //   No better machine exists to hold this role.  Just shut up.
            //
            __leave;
        }


        // Get a copy of the current string name of the infrastrucutre update
        // object while we are here.  We might need it later if we need to add a
        // child object.
        *ppInfrObjName = NULL;
        DBGetAttVal(pTHS->pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    0,0,&outSize, (PUCHAR *)ppInfrObjName);
        Assert(*ppInfrObjName);

        // Next, make sure the index we need is here
        if(DBSetCurrentIndex(pTHS->pDB, Idx_Phantom, NULL, FALSE)) {
            // Failed to just set to the index, so try to create it.
            if(err = DBCreatePhantomIndex(pTHS->pDB)) {
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_CANT_MAKE_INDEX,
                         szInsertHex(err),
                         NULL,
                         NULL);
                __leave;
            }
            // We seem to have created it, so try setting to it.
            if(err = DBSetCurrentIndex(pTHS->pDB, Idx_Phantom,
                                       NULL, FALSE)) {
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_CANT_USE_INDEX,
                         szInsertHex(err),
                         NULL,
                         NULL);
                __leave;
            }
        }
        rtn = TRUE;
        fCommit = TRUE;
    }
    __finally {
        DBClose(pTHS->pDB, fCommit);
    }

    return rtn;
}


void
PhantomCleanupLocal (
        OUT DWORD * pcSecsUntilNextIteration,
        OUT BOOL  * pIsPhantomMaster
        )
/*++
  Description:
       Routine to run the phantom cleanup task.  Looks through the
       DIT for phantoms, verifies their string names against a GC, and writes
       corrected string names into the DIT for any names which are incorrect.

   Parameter:
       pcSecsUntilNextIteration - Fills in the number of seconds in the future
            that we should reschedule in order to keep up with our stated rate
            goal. If Null is passed in, we ignore this and don't figure out when
            to reschedule.

       pIsPhantomMaster - on return is TRUE if we could verify that we are the
            phantom master, is FALSE is we could verify that we are NOT the
            phantom master, and is untouched if we could not verify either way.

   Return values:
       None.

--*/
{
    THSTATE *pTHS = pTHStls;
    BOOL     fCommit = FALSE;
    PDSNAME  objNames[NAMES_PER_GC_TRIP];
    PDSNAME  verifiedNames[NAMES_PER_GC_TRIP];
    PDSNAME  freshNames[MAX_STALE_PHANTOMS];
    DWORD    err;
    BOOL     fInited;
    DWORD    DNTStart = INVALIDDNT;
    DWORD    i, count = 0;
    DSNAME  *pInfrObjName=NULL;
    DWORD    freshCount = 0;
    BOOL     fGatheringStalePhantoms;
    DWORD    dwGCTrips = 0;
    DWORD    numPhantoms = 0;
    DWORD    numVisited = 0;
    DWORD    calculatedDelay = 0;

    pTHS->fDSA = TRUE;
    pTHS->fPhantomDaemon = TRUE;


    if(pcSecsUntilNextIteration) {
        *pcSecsUntilNextIteration = PHANTOM_DAEMON_MAX_DELAY;
    }

    Assert(!pTHS->pDB);
    // InitPhantomCleanup
    if(InitPhantomCleanup(pTHS, pIsPhantomMaster, &pInfrObjName)) {
        // OK, we're supposed to clean up stale phantoms.  Do so.

        // For now, we will continue to look for stale phantoms until
        // 0) We have made MAX_GC_TRIPS to the GC. OR
        // 1) We look at all the phantoms on the machine. OR
        // 2) We find between X stale phantom names (i.e. names we need to write
        //    to the carrier object in order to get the DB up to date).
        //    (MAX_STALE_PHANTOMS - NAMES_PER_GC_TRIP) <= X <=
        //                                         MAX_STALE_PHANTOMS.
        //
        //
        // Especially note: we don't have any way yet of throttling this from
        // looking at every phantom if nothing has changed.

        fGatheringStalePhantoms = TRUE;
        while(fGatheringStalePhantoms &&
              ((freshCount + NAMES_PER_GC_TRIP) <= MAX_STALE_PHANTOMS)) {
            // First, find a batch of names to be verified,
            Assert(!pTHS->pDB);
            DBOpen(&pTHS->pDB);
            __try {
                DBSetCurrentIndex(pTHS->pDB, Idx_Phantom, NULL, FALSE);
                count = 0;
                if(!(err = DBMove(pTHS->pDB, FALSE, DB_MoveFirst))) {
                    // Only do this the very first time we come through here.
                    if(DNTStart == INVALIDDNT) {
                        if(pcSecsUntilNextIteration) {
                            // We need to figure out when to reschedule.  That
                            // requires we know how big the index is.
                            DBGetIndexSize(pTHS->pDB, &numPhantoms);
                            // reposition to the beginning
                            DBMove(pTHS->pDB, FALSE, DB_MoveFirst);
                        }
                        // See what the DNT of the first object is so we can
                        // stop if we see it twice.
                        DNTStart = pTHS->pDB->DNT;
                    }
                    do {
                        objNames[count] = DBGetCurrentDSName(pTHS->pDB);
                        Assert(objNames[count]);
                        count++;
                        numVisited++;

                        // Now, update the USN changed of this object to
                        // indicate we are examining it for staleness (which
                        // moves it to the end  of the index)
                        DBUpdateUsnChanged(pTHS->pDB);
                        err = DBMove(pTHS->pDB, FALSE, 1);
                    } while(!err &&               // all is ok.
                            (pTHS->pDB->DNT != DNTStart) && // haven't wrapped
                            // the list
                            (count < NAMES_PER_GC_TRIP )); // we've not done too
                                                           // much work already
                    if(pTHS->pDB->DNT == DNTStart) {
                        // We wrapped completely through the list.
                        fGatheringStalePhantoms = FALSE;
                    }

                }
                fCommit = TRUE;
            }
            __finally {
                DBClose(pTHS->pDB, fCommit);
            }

            if(!fCommit) {
                // Failed to talk to the DIT for some reason.  Complain, but
                // continue in order to deal with the stalePhantoms we already
                // got (if any)

                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_LOCATE_PHANTOMS_FAILED,
                         NULL,
                         NULL,
                         NULL);

                fGatheringStalePhantoms = FALSE;
            }
            else if(count) {

                // All is going well, and we found some names we need to verify
                // against the GC.  Do so now.
                dwGCTrips++;
                if(dwGCTrips >= MAX_GC_TRIPS) {
                    // Each pass through here will only do so many trips to the
                    // GC (we don't want to tie up the task queue for too
                    // long), and we've hit that limit.
                    fGatheringStalePhantoms = FALSE;
                }
                if(!GCGetVerifiedNames(pTHS,
                                       count,
                                       objNames,
                                       verifiedNames)) {
                    // Got the verified names from the GC, find which ones are
                    // stale.
                    // We demand byte for byte equality of names here.
                    for(i=0;i<count;i++) {
                        if(verifiedNames[i] &&
                           ((verifiedNames[i]->structLen   !=
                             objNames[i]->structLen           ) ||
                            memcmp(verifiedNames[i],
                                   objNames[i],
                                   objNames[i]->structLen))) {
                            freshNames[freshCount] = verifiedNames[i];
                            freshCount++;
                        }

                        // Don't need these no more.
                        THFreeEx(pTHS, objNames[i]);
                        objNames[i] = NULL;
                        verifiedNames[i] = NULL;
                    }
                }
                else {
                    // Hmm.  failed to get to the GC for some reason. Complain,
                    // but continue in order to deal with the stalePhantoms we
                    // already got (if any)

                    LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_STALE_PHANTOM_CLEANUP_GC_COMM_FAILED,
                             NULL,
                             NULL,
                             NULL);

                    fGatheringStalePhantoms = FALSE;
                }
            }
            else {
                // No more phantoms found.  We're done.
                fGatheringStalePhantoms = FALSE;
            }
        }

        // Now, pass the array of stale phantom names
        if(freshCount) {
            spcAddCarrierObject(pTHS, pInfrObjName, freshCount, freshNames);
            for(i=0;i<freshCount;i++) {
                THFreeEx(pTHS, freshNames[i]);
            }
        }
    }

    THFreeEx(pTHS, pInfrObjName);

    // Figure out when to reschedule.

    if(pcSecsUntilNextIteration && !eServiceShutdown) {
        // We need to figure out when to reschedule

        // We must always have some positive rate that we wish to achieve.
        DWORD daysPerPhantomScan;

        if (GetConfigParam(PHANTOM_SCAN_RATE,
                           &daysPerPhantomScan,
                           sizeof(daysPerPhantomScan))) {
            daysPerPhantomScan = DEFAULT_PHANTOM_SCAN_RATE;
        }

        if(!numVisited) {
            // Didn't actually look at any this time.
            if(numPhantoms) {
                // but there were some
                calculatedDelay = PHANTOM_DAEMON_MIN_DELAY;
            }
            else {
                // but we don't think there are any.
                calculatedDelay = PHANTOM_DAEMON_MAX_DELAY;
            }
        }
        else {
            // there is a possibility that a new phantom is created while we 
            // are traversing the index
            Assert((numPhantoms + 10) > numVisited);

            //   Seconds   Days     Objects
            //   ------- * ----- * --------
            //    Day       Dit      Pass           Seconds
            // ------------------------------ =   -----------
            //           objects                     Pass
            //           --------
            //             Dit
            //
            // SECONDS_PER_DAY constant,
            // daysPerPhantomScan is a configurable value from the registry.
            // numVisited is the objects we visited on this pass.
            // numPhantoms is the number of phantom objects in this dit.
            //
            // So, the result of this calculation is how long we can wait before
            // we do a pass just like this one and still maintain the rate we
            // wish to maintain.
            //
            calculatedDelay=((SECONDS_PER_DAY *
                              daysPerPhantomScan *
                              numVisited) /
                             numPhantoms);


            if(calculatedDelay < PHANTOM_DAEMON_MIN_DELAY) {
                // At this pace, we need to be looking at the GC way to often.
                // Log to let the world know, and slow down a bit.  This means
                // we will fall behind, but at least we won't bring this DS to
                // its knees.
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_TOO_BUSY,
                         szInsertUL(calculatedDelay),
                         szInsertUL(PHANTOM_DAEMON_MIN_DELAY),
                         NULL);
                calculatedDelay = PHANTOM_DAEMON_MIN_DELAY;
            }
            else if(calculatedDelay > PHANTOM_DAEMON_MAX_DELAY) {
                // At this rate, we don't actually need to look for a long time,
                // but there is no sense in actually waiting that long.
                calculatedDelay = PHANTOM_DAEMON_MAX_DELAY;
            }
        }

        *pcSecsUntilNextIteration = calculatedDelay;

        if(*pIsPhantomMaster) {
            LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_AS_MASTER,
                      szInsertUL(numVisited),
                      szInsertUL(numPhantoms),
                      szInsertUL(freshCount),
                      szInsertUL(calculatedDelay),
                      NULL, NULL, NULL, NULL);
        }
        else {
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_NOT_AS_MASTER,
                     szInsertUL(calculatedDelay), NULL, NULL);
        }

    }

    return;

}



void
PhantomCleanupMain (
        void *  pv,
        void ** ppvNext,
        DWORD * pcSecsUntilNextIteration
        )
/*++
  Description:
      Task queue routine to run the phantom cleanup task.
      Can be invoked in two ways.  If PHANTOM_CHECK_FOR_FSMO, then we don't
      already think we are the FSMO role holder, and we're just looking to see
      if we have siezed the role.  If we notice we have siezed the role, we
      change our state to PHANTOM_IS_PHANTOM_MASTER, and schedule much more
      aggressively.  Also, if PHANTOM_CHECK_FOR_FSMO and we notice thet
      gfIsPhantomCleanupMaster is true, then we have been made the role holder
      via normal become_foo_master means, and while doing that, we scheduled
      another task wiht PHANTOM_IS_PHANTOM_MASTER, so in that case (to avoid
      multiple task queue items to deal with phantomness), simply don't
      reschedule ourselves.

      If PHANTOM_IS_PHANTOM_MASTER, then do normal cleanup. If we notice during
      that that we are no longer the phantom master, just drop the state back to
      PHANTOM_CHECK_FOR_FSMO.

      Normally, at boot, we put a CHECK_FOR_FSMO in the task queue.  If that
      first task notices it is the role holder, it reschedules itself and morphs
      its state to PHANTOM_IS_PHANTOM_MASTER.  If it notices it is not the
      phantom master, it reschedules itself and stays in the CHECK_FOR_FSMO
      state.  If this machine later siezes the role, then when we wake up and
      check check, we notice we are the role holder and so do the same state
      change and reschedule.

   Return values:
       None.
--*/
{
    DWORD secsUntilNextIteration = PHANTOM_DAEMON_MAX_DELAY;
    BOOL  fIsMaster;

    __try {
        switch(PtrToUlong(pv)) {
        case PHANTOM_CHECK_FOR_FSMO:
            // Last time I checked, I wasn't the fsmo role holder for phantom
            // cleanup.  See if I am now.
            if(gfIsPhantomMaster) {
                // But I think I am now. So, simply don't reschedule
                // myself, since the normal phantom cleanup task is already in
                // the queue.
                secsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
                return;
            }
            else {
                // No, I still don't think I am.  Try to cleanup anyway.
                fIsMaster = FALSE;
                PhantomCleanupLocal(&secsUntilNextIteration, &fIsMaster);
                if(fIsMaster) {
                    // hey, I just noticed that I am the phantom master.  Change
                    // my state to indicate this.
                    pv = (void *) PHANTOM_IS_PHANTOM_MASTER;
                }
            }
            break;

        case PHANTOM_IS_PHANTOM_MASTER:
            // I think I am the phantom master.
            fIsMaster = TRUE;
            PhantomCleanupLocal(&secsUntilNextIteration, &fIsMaster);
            if(!fIsMaster) {
                // Hey, I'm not the phantom master anymore.  Change my state to
                // reflect this.
                pv = (void *) PHANTOM_CHECK_FOR_FSMO;
            }
        }
    }
    __finally {
        *pcSecsUntilNextIteration = secsUntilNextIteration;
        *ppvNext = pv;
        if(PtrToUlong(pv) == PHANTOM_IS_PHANTOM_MASTER) {
            // We are about to reschedule based on the assumption that we are
            // the phantom master.
            gfIsPhantomMaster = TRUE;
        }
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\samcache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samcache.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains routines to support account and universal group
    caching.

Author:

    ColinBr     03-01-00

Environment:

    User Mode - Win32

Revision History:

    ColinBr     03-01-00
        Created

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <mappings.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <anchor.h>
#include <dsconfig.h>
#include <attids.h>
#include <fileno.h>
#include <taskq.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h> // for NetApiBufferFree
#include <esent.h>

#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <samsrvp.h>

#include <filtypes.h>

#include <schedule.h>
#include <ismapi.h>

#include <samlogon.h>

#define FILENO FILENO_SAMCACHE
#define DEBSUB "SAMCACHE:"


// Useful
#define NELEMENTS(x)  (sizeof(x)/sizeof((x)[0]))

// Reschedule in 5 minutes for resource error 
#define UNEXPECTED_ERROR_RESCHEDULE_SECS  (5*60)


// 500 users in one refresh cycle
#define GCLESS_DEFAULT_REFRESH_LIMIT 500

// 6 months
#define GCLESS_DEFAULT_SITE_STICKINESS_DAYS  180

// 1 week
#define GCLESS_DEFAULT_STALENESS_HOURS 168

// The number of entries to batch when going to a GC
#define GC_BATCH_LIMIT 10

#define ONE_SECOND_IN_FILETIME (10 * (1000*1000))

#define ENTRY_HAS_EXPIRED(entry, standard) \
    ((-1) == CompareFileTime((FILETIME*)&(entry),(FILETIME*)&(standard)))

LARGE_INTEGER ZeroTime = {0};
#define IS_ZERO_TIME(entry) \
    (!memcmp(&entry, &ZeroTime, sizeof(ZeroTime)))

// Eight hours
#define DEFAULT_REFRESH_INTERVAL_SECS  (8*60*60)


// When searching for the old cached membership, bail after
// this many accounts to avoid outlier situations where we end up
// walking all users in the database
#define NTDSA_SAM_CACHE_MAX_STALE_ACCOUNTS  100

// When performing cleanup, do only this many accounts at a time.
#define MAX_CLEANUP_LIMIT 64

//
// This is the format of the MSDS-Cached-Membership binary blob
//
#include <pshpack1.h>

typedef struct _GROUP_CACHE_V1 {

    //
    // SIDs are placed in SidStart in the following order
    //
    DWORD accountCount;
    DWORD accountSidHistoryCount;
    DWORD universalCount;
    DWORD universalSidHistoryCount;
    BYTE  SidStart[1];
    
}GROUP_CACHE_V1;

typedef struct {

    DWORD Version;
    union {
        GROUP_CACHE_V1 V1;
    };

}GROUP_CACHE_BLOB;

#include <poppack.h>


//
// A helpful macro to know if two strings are the same. 
// x and y must be NULL terminated.
//
#define EQUAL_STRING(x, y)                                           \
    (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,                 \
                                  DS_DEFAULT_LOCALE_COMPARE_FLAGS,   \
                                  (x), wcslen(x), (y), wcslen(y)))

//
// A structure to define elements of an array that have the sites we are
// connected to and whether a GC is present in the site.  This information is
// used to both determine which site to schedule ourselves from if there
// is no preferred site and also to determine if the GC we found is from
// a site with lowest cost.
//
typedef struct _CACHE_CONNECTED_SITES {
    LPWSTR siteName;
    ULONG  cost;
    BOOLEAN fHasGC;
} CACHE_CONNECTED_SITES;


// Exported from dra.lib::drainst.c
BOOL 
fIsBetweenTime(
    IN REPLTIMES *,
    IN DSTIME,
    IN DSTIME
    );

// Local prototypes
DWORD
cleanupOldEntries(
    IN  THSTATE *pTHS,
    IN ULONG *DNTList,
    IN ATTRVAL *Values OPTIONAL,
    IN ULONG  DNTCount
    );

DWORD
analyzeSitePreference(
    IN  ULONG defaultRefreshInterval,
    OUT ULONG* cConnectedSitesOutput, 
    OUT CACHE_CONNECTED_SITES **connectedSitesOutput,
    OUT LPWSTR* siteName,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    );

VOID
analyzeSchedule(
    IN  ULONG defaultRefreshInterval,
    IN  LPWSTR  siteName,
    IN  SCHEDULE *pSchedule,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    );

DWORD 
getGCFromSite(
    IN  THSTATE *pTHS,
    IN  LPWSTR siteName,
    IN  ULONG  cConnectedSites, OPTIONAL
    IN  CACHE_CONNECTED_SITES *connectedSites, OPTIONAL
    OUT LPWSTR *gcName,
    OUT LPWSTR *gcDomain
    );

BOOL 
convertScheduleToReplTimes(
    IN PSCHEDULE schedule,
    OUT REPLTIMES *replTimes
    );

DWORD
findScheduleForSite(
    IN  THSTATE   *pTHS,
    IN  LPWSTR     transportDN,
    IN  LPWSTR     localSiteName,
    IN  LPWSTR     targetSiteName,
    OUT PSCHEDULE *ppSchedule
    );

LPSTR
DbgPrintDsTime(
    DSTIME time,
    CHAR * buffer
    );


VOID
marshallCachedMembershipSids(
    IN  THSTATE *pTHS,
    IN  AUG_MEMBERSHIPS* Account,
    IN  AUG_MEMBERSHIPS* Universal,
    OUT PVOID *pBuf,
    OUT ULONG *cbBuf
    )
/*++

Routine Description:

    This routine converts an array of SID's into to continous binary blob
    of SIDs that it can be stored in the Cached-Membership attribute of
    a user object.
    
Parameters:

    pTHS -- thread state
    
    Account -- the account groups and sid history
    
    Universal -- the universal groups and sid history
    
    pBuf -- the buffer to write in the cached memberships attribute
    
    cbBuf -- the number of bytes in pBuf

Return Values

    None.

 --*/
{
    ULONG i;
    PBYTE pTemp;
    ULONG cbTemp;
    GROUP_CACHE_BLOB *pBlob;

    Assert(Account);
    Assert(Universal);

    // Calculate the length of the structure
    cbTemp = 0;
    for (i = 0; i < Account->MembershipCount; i++) {
        Assert(RtlValidSid(&Account->Memberships[i]->Sid));
        Assert(RtlLengthSid(&Account->Memberships[i]->Sid) ==
               Account->Memberships[i]->SidLen);
        cbTemp += Account->Memberships[i]->SidLen;
    }
    for (i = 0; i < Account->SidHistoryCount; i++) {
        Assert(RtlValidSid(Account->SidHistory[i]));
        cbTemp += RtlLengthSid(Account->SidHistory[i]);
    }
    for (i = 0; i < Universal->MembershipCount; i++) {
        Assert(RtlValidSid(&Universal->Memberships[i]->Sid));
        Assert(RtlLengthSid(&Universal->Memberships[i]->Sid) ==
               Universal->Memberships[i]->SidLen);
        cbTemp += Universal->Memberships[i]->SidLen;
    }
    for (i = 0; i < Universal->SidHistoryCount; i++) {
        Assert(RtlValidSid(Universal->SidHistory[i]));
        cbTemp += RtlLengthSid(Universal->SidHistory[i]);
    }

    cbTemp += sizeof(GROUP_CACHE_BLOB);
    pBlob = (GROUP_CACHE_BLOB*) THAllocEx(pTHS, cbTemp);

    // Current version
    pBlob->Version = 1;

    // Sid in the sids

    // Offset starts from SidStart
    pTemp = &(pBlob->V1.SidStart[0]);

    // First the account memberships
    pBlob->V1.accountCount = Account->MembershipCount;
    for (i = 0; i < Account->MembershipCount; i++) {
        ULONG size = Account->Memberships[i]->SidLen;
        memcpy(pTemp, &Account->Memberships[i]->Sid, size);
        pTemp += size;
    }

    // Now the account sid histories
    pBlob->V1.accountSidHistoryCount = Account->SidHistoryCount;
    for (i = 0; i < Account->SidHistoryCount; i++) {
        ULONG size = RtlLengthSid(Account->SidHistory[i]);
        memcpy(pTemp, Account->SidHistory[i], size);
        pTemp += size;
    }

    // Now the universal memberships
    pBlob->V1.universalCount = Universal->MembershipCount;
    for (i = 0; i < Universal->MembershipCount; i++) {
        ULONG size = Universal->Memberships[i]->SidLen;
        memcpy(pTemp, &Universal->Memberships[i]->Sid, size);
        pTemp += size;
    }

    // Finally the universal sid histories
    pBlob->V1.universalSidHistoryCount = Universal->SidHistoryCount;
    for (i = 0; i < Universal->SidHistoryCount; i++) {
        ULONG size = RtlLengthSid(Universal->SidHistory[i]);
        memcpy(pTemp, Universal->SidHistory[i], size);
        pTemp += size;
    }


    // Done
    *pBuf = pBlob;
    *cbBuf = cbTemp;

    return;
}


BOOL
unmarshallCachedMembershipSids(
    IN  THSTATE *pTHS,
    IN  PVOID pBuf,
    IN  ULONG cbBuf,
    OUT AUG_MEMBERSHIPS** Account,
    OUT AUG_MEMBERSHIPS** Universal
    )
/*++

Routine Description:

    This routine converts a binary blob of SID's to an array of SID's.  The
    binary blob is a value for the CachedMembership attribute of a user.

Parameters:

    pTHS -- thread state
    
    pBuf -- the buffer read from the cached memberships attribute
    
    cbBuf -- the number of bytes in pBuf
    
    Account -- the account groups and sid history
    
    Universal -- the universal groups and sid history


Return Values

    TRUE if properly decoded; FALSE otherwise

 --*/
{
    ULONG i, count;
    GROUP_CACHE_BLOB *pBlob = (GROUP_CACHE_BLOB*)pBuf;
    UCHAR *pTemp;
    PSID *sidArray;
    AUG_MEMBERSHIPS *pAccount;
    AUG_MEMBERSHIPS *pUniversal;
    ULONG sizeOfSidDsName = DSNameSizeFromLen(0);
    
    // Assert this is a version we understand
    Assert(pBlob->Version == 1);
    if (1 != pBlob->Version) {
        return FALSE;
    }

    // Alloc space for the returned structures
    pAccount = (AUG_MEMBERSHIPS*) THAllocEx(pTHS, sizeof(AUG_MEMBERSHIPS));
    pUniversal = (AUG_MEMBERSHIPS*) THAllocEx(pTHS, sizeof(AUG_MEMBERSHIPS));

    pTemp = (&pBlob->V1.SidStart[0]);

    // Extract the account memberships
    if (pBlob->V1.accountCount > 0) {
        pAccount->Memberships = THAllocEx(pTHS, pBlob->V1.accountCount * sizeof(DSNAME*));
        pAccount->MembershipCount = pBlob->V1.accountCount;
        for (i = 0; i < pAccount->MembershipCount; i++) {
    
            DSNAME *dsname = (DSNAME*) THAllocEx(pTHS, sizeOfSidDsName);
            ULONG  size = RtlLengthSid((PSID)pTemp);
    
            Assert(size > 0);
            dsname->structLen = sizeOfSidDsName;
            memcpy(&dsname->Sid, pTemp, size);
            dsname->SidLen = size;
            pAccount->Memberships[i] = dsname;
            pTemp += size;
        }
    }

    // Extract the account sid histories
    if (pBlob->V1.accountSidHistoryCount > 0) {
        pAccount->SidHistory = THAllocEx(pTHS, pBlob->V1.accountSidHistoryCount * sizeof(PSID));
        pAccount->SidHistoryCount = pBlob->V1.accountSidHistoryCount;
        for (i = 0; i < pAccount->SidHistoryCount; i++) {
    
            ULONG  size = RtlLengthSid((PSID)pTemp);
            PSID   sid = (PSID) THAllocEx(pTHS, size);
    
            Assert(RtlValidSid((PSID)pTemp));
            Assert(size > 0);
            memcpy(sid, pTemp, size);
            pAccount->SidHistory[i] = sid;
            pTemp += size;
        }
    }


    // Extract the universals
    if (pBlob->V1.universalCount > 0) {
        pUniversal->Memberships = THAllocEx(pTHS, pBlob->V1.universalCount * sizeof(DSNAME*));
        pUniversal->MembershipCount = pBlob->V1.universalCount;
        for (i = 0; i < pUniversal->MembershipCount; i++) {
    
            DSNAME *dsname = (DSNAME*) THAllocEx(pTHS, sizeOfSidDsName);
            ULONG  size = RtlLengthSid((PSID)pTemp);
    
            Assert(size > 0);
            dsname->structLen = sizeOfSidDsName;
            memcpy(&dsname->Sid, pTemp, size);
            dsname->SidLen = size;
            pUniversal->Memberships[i] = dsname;
            pTemp += size;
        }
    }

    // Extract the account sid histories
    if (pBlob->V1.universalSidHistoryCount) {
        pUniversal->SidHistory = THAllocEx(pTHS, pBlob->V1.universalSidHistoryCount * sizeof(PSID));
        pUniversal->SidHistoryCount = pBlob->V1.universalSidHistoryCount;
        for (i = 0; i < pUniversal->SidHistoryCount; i++) {
    
            ULONG  size = RtlLengthSid((PSID)pTemp);
            PSID   sid = (PSID) THAllocEx(pTHS, size);
    
            Assert(RtlValidSid((PSID)pTemp));
            Assert(size > 0);
            memcpy(sid, pTemp, size);
            pUniversal->SidHistory[i] = sid;
            pTemp += size;
        }
    }

    *Account = pAccount;
    *Universal = pUniversal;

    return TRUE;
}

NTSTATUS
GetMembershipsFromCache(
    IN  DSNAME* pDSName,
    OUT AUG_MEMBERSHIPS** Account,
    OUT AUG_MEMBERSHIPS** Universal
    )
/*++

Routine Description:

    This routine, exported from ntdsa.dll, retrieves a user's cached group
    membership.  The group membership is returned if and if only if the
    timestamp of the last update is within the staleness period and if the
    group membership attribute exists.

Parameters:

    pDSNAME -- the name of the user
    
    Account -- the account group memberships and sid histories
    
    Universal -- the universal group memberships and sid histories
    
Return Values
    
    STATUS_SUCCESS if the group membership was returned
    
    STATUS_DS_NO_ATTRIBUTE_OR_VALUE  if there is no cache or if the cache
                                     has expired.

 --*/
{
    THSTATE *pTHS = pTHStls;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG err;
    ULONG size;
    ULONG stalenessMinutes;

    LARGE_INTEGER timeTemp, timeBestAfter;

    BOOL fCommit = FALSE;

    Assert(pDSName);
    Assert(Account);
    Assert(Universal);

    // Determine staleness limit (measured in minutes)
    err = GetConfigParam(GCLESS_STALENESS,
                         &stalenessMinutes,
                         sizeof(stalenessMinutes));
    if (err) {
        stalenessMinutes = GCLESS_DEFAULT_STALENESS_HOURS*60;
        err = 0;
    }
    timeTemp.QuadPart = Int32x32To64(stalenessMinutes*60, ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    // The default status is that no cached membership could be found or
    // used
    ntStatus = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;

    // This routine assumes a transaction is open
    Assert(pTHS != NULL)
    Assert(pTHS->pDB != NULL);

    _try {

        LARGE_INTEGER lastRefreshTime;

        err = DBFindDSName(pTHS->pDB, pDSName);
        if (err) {
            // user not found?
            DPRINT(1,"User not found when retrieving membership cache\n");
            _leave;
        }

        err = DBGetSingleValue(pTHS->pDB,
                               ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP,
                               &lastRefreshTime,
                               sizeof(lastRefreshTime),
                               &size);

        if (!err) {
            // There is a value -- check to see if it is not stale
            if (!ENTRY_HAS_EXPIRED(lastRefreshTime, timeBestAfter)) {

                PVOID pBuf = NULL;
                ULONG cbBuf = 0;

                // This is not stale
                err = DBGetAttVal(pTHS->pDB,
                                  1, // first value
                                  ATT_MS_DS_CACHED_MEMBERSHIP,
                                  0,
                                  0,
                                  &cbBuf,
                                  (UCHAR**)&pBuf);

                if (!err) {

                    if ( unmarshallCachedMembershipSids(pTHS,
                                                   pBuf,
                                                   cbBuf,
                                                   Account,
                                                   Universal)) {
                        ntStatus = STATUS_SUCCESS;
                    } else {
                        DPRINT(0,"Unmarshalling group membership attribute failed!\n");
                    }


                } else {

                    DPRINT(0,"Group Membership Cache time stamp exists but no membership!\n");
                }
            }
        }
        fCommit = TRUE;
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (!NT_SUCCESS(ntStatus)) {
        *Account = NULL;
        *Universal = NULL;
    }

    // This routine assumes a transaction is open at the start
    // so we should end with one, too
    Assert(pTHS != NULL);
    Assert(pTHS->pDB != NULL);


    return ntStatus;
}


NTSTATUS
CacheMemberships(
    IN  DSNAME* pDSName,
    IN  AUG_MEMBERSHIPS* Account,
    IN  AUG_MEMBERSHIPS* Universal
    )
/*++

                                                            
Routine Description:

    This exported routine updates the cached membership for a user as well
    as the site affinity if requested to do so.
    
Parameters:

    pDSName -- the account to update
    
    Account -- the account group memberships and sid histories
    
    Universal -- the universal group memberships and sid histories
    
Return Values
    
    STATUS_SUCCESS, a resource error otherwise                          

 --*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    THSTATE *pTHS=pTHStls;
    PVOID pBuf = NULL;
    ULONG cbBuf = 0;
    ULONG i;
    ULONG err;
    BOOL fCommit = FALSE;
    GUID siteGuid;

    // Package SIDs into binary format
    marshallCachedMembershipSids( pTHS,
                                  Account,
                                  Universal,
                                 &pBuf,
                                 &cbBuf );

    _try
    {

        Assert(NULL == pTHS->pDB);
        // need a transaction
        DBOpen(&pTHS->pDB);

        _try
        {
            LARGE_INTEGER ts;
            ATTCACHE *pAC;
            ATTRVALBLOCK attrValBlock;
            ATTRVAL attrVal;
            BOOL fChanged;

            err = DBFindDSName(pTHS->pDB, pDSName);
            if (err) {
                // can't find the user
                ntStatus = STATUS_NO_SUCH_USER;
                _leave;
            }

            // Update the cached membership value
            pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP);
            Assert(NULL != pAC);
            memset(&attrValBlock, 0, sizeof(attrValBlock));
            attrValBlock.valCount = 1;
            attrValBlock.pAVal = &attrVal;
            memset(&attrVal, 0, sizeof(attrVal));
            attrVal.valLen = cbBuf;
            attrVal.pVal = (UCHAR*)pBuf;

            err = DBReplaceAtt_AC(pTHS->pDB,
                                  pAC,
                                  &attrValBlock,
                                  &fChanged);
            if (err) {
                // This is an unexpected error
                DPRINT1(0,"DBReplaceAtt_AC failed with 0x%d unexpectantly\n", 
                        err);
                _leave;
            }
    

            // Update the time stamp value
            pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
            Assert(NULL != pAC);
            GetSystemTimeAsFileTime((FILETIME*)&ts);
            memset(&attrValBlock, 0, sizeof(attrValBlock));
            attrValBlock.valCount = 1;
            attrValBlock.pAVal = &attrVal;
            memset(&attrVal, 0, sizeof(attrVal));
            attrVal.valLen = sizeof(ts);
            attrVal.pVal = (UCHAR*)&ts;

            err = DBReplaceAtt_AC(pTHS->pDB,
                                  pAC,
                                  &attrValBlock,
                                  &fChanged);
            if (err) {
                // This is an unexpected error
                DPRINT1(0,"DBReplaceAtt_AC failed with 0x%d unexpectantly\n", 
                        err);
                _leave;
            }
    
            if (!err) {
                err  = DBRepl(pTHS->pDB, 
                              FALSE,  // not DRA
                              0,
                              NULL,
                              0 );
                if (err) {
                    DPRINT1(0,"DBRepl failed with 0x%d unexpectantly\n", err);
                }
            }

            if (!err) {
                fCommit = TRUE;
            }
        }
        _finally
        {
            if (pTHS->pDB) {
                DBClose(pTHS->pDB, fCommit);
            }
        }
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (err && NT_SUCCESS(ntStatus)) {
        // An unexpected error occurred
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

DWORD 
getSchedulingInformation(
    IN  THSTATE *pTHS,
    OUT BOOL    *fRunNow,
    OUT DWORD   *pcSecsUntilNextIteration,
    OUT ULONG    *cConnectedSites,
    OUT CACHE_CONNECTED_SITES **connectedSites,
    OUT LPWSTR *siteName,
    OUT DWORD   *dsidExit
    )
/*++

Routine Description:

    This routine analyses site configuration information to determine if
    the refresh membership task should run now and when it should run again.
    
Parameters:

    pTHS -- thread state
    
    fRunNow -- should the task run now?
    
    pcSecsUntilNextIteration -- when the task should run again
    
    cConnectedSites -- the number of sites the local site has connectivety to
    
    connectedSites -- the sites the locate has connectivety to
    
    siteName -- the name of the site the task is scheduled to refresh from
    
    dsidExit -- the DSID of any fatal errors

Return Values

    0 on success, !0 otherwise

 --*/
{

    ULONG err = 0;
    ULONG defaultRefreshInterval;

    // Get the default refresh reschedule time
    err = GetConfigParam(GCLESS_REFRESH_INTERVAL,
                         &defaultRefreshInterval,
                         sizeof(defaultRefreshInterval));
    if (err) {
        defaultRefreshInterval = DEFAULT_REFRESH_INTERVAL_SECS;
        err = 0;
    } else {
        // value in registry is minutes -- we need seconds
        defaultRefreshInterval *= 60;
    }
    *pcSecsUntilNextIteration = defaultRefreshInterval;


    //
    // Find either the configured site, or if it is timely to run
    // now
    //
    // This routine logs whether a helper site was found.
    //
    err = analyzeSitePreference(defaultRefreshInterval,
                                cConnectedSites,
                                connectedSites,
                                siteName,
                                fRunNow,
                                pcSecsUntilNextIteration);
    if (err) {
        // unexpected
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    return err;


}

DWORD
getTargetGCInformation(
    IN  THSTATE *pTHS,
    IN  ULONG    cConnectedSites OPTIONAL,
    IN  CACHE_CONNECTED_SITES *connectedSites OPTIONAL,
    IN  LPWSTR   siteName,
    OUT LPWSTR  *gcName,
    OUT LPWSTR  *gcDomain,
    OUT DWORD   *pcSecsUntilNextIteration,
    OUT DWORD   *dsidExit
    )
/*++

Routine Description:

    This routine determines the name of GC from which the group memberships
    can be updated from.  
    
    siteName is the most relevant parameter to determine where the GC is from.
    connectedSites is for logging purposes only.
                                                          
Parameters:

    pTHS -- thread state
    
    cConnectedSites -- the number of sites the local site has connectivety to
    
    connectedSites -- the sites the locate has connectivety to

    siteName -- the site from which a GC should be currently available
        
    gcName -- the name of the GC to update memberships from
    
    gcDomain -- the domain name that the GC belongs to
    
    pcSecsUntilNextIteration -- when the task should run again
    
    dsidExit -- the DSID of any fatal errors

Return Values

    0 on success, !0 otherwise

 --*/
{

    DWORD err;
    //
    // We are going to run -- try to find a GC
    //
    // This routine logs whether a helper GC was found
    //
    err = getGCFromSite(pTHS,
                        siteName,
                        cConnectedSites,
                        connectedSites,
                        gcName,
                        gcDomain);
    if (err) {
        //
        // No GC -- don't run
        //
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    return err;

}

DWORD
getAccountsToRefresh(
    IN  THSTATE* pTHS,
    OUT DWORD *refreshCountOutput,
    OUT DSNAME ***refreshListOutput,
    OUT DWORD  *pcSecsUntilNextIteration,
    OUT ULONG  *dsidExit
    )
/*++

Routine Description:

    This routine walks the site affinity list for the local site either
    expiring the account or adding the account to the list of accounts whose
    memberships need refreshing.

Parameters:

    pTHS -- thread state
    
    refreshCountOutput -- the number of accounts that need refreshing
    
    refreshListOutput -- the accounts that need refreshing
    
    pcSecsUntilNextIteration -- seconds until next iteration (used for error
                                conditions).
                                
    dsidExit -- the location of a fatal error, if any                                

Return Values

    0 on success, !0 otherwise

 --*/
{

    ULONG err = 0;
    ULONG refreshMax;
    ULONG siteStickiness;
    DWORD refreshCount = 0;
    DSNAME **refreshList = NULL;

    ATTCACHE *pAC = NULL;
    INDEX_VALUE IV;
    GUID siteGuid;
    BOOL fCommit = FALSE;
    ULONG i;

    // Storage for accounts that have expired
    ULONG   oldEntries[MAX_CLEANUP_LIMIT];
    ATTRVAL oldValues[MAX_CLEANUP_LIMIT];
    ULONG   oldCount = 0;

    LARGE_INTEGER timeTemp, timeBestAfter;

    // There should not be a transaction
    Assert(NULL == pTHS->pDB);

    memset(oldEntries, 0, sizeof(oldEntries));
    memset(oldValues, 0, sizeof(oldValues));

    // Determine how many users to refresh
    err = GetConfigParam(GCLESS_REFRESH_LIMIT,
                         &refreshMax,
                         sizeof(refreshMax));
    if (err) {
        refreshMax = GCLESS_DEFAULT_REFRESH_LIMIT;
        err = 0;
    }

    // Init the list of users to be refreshed
    refreshList = (DSNAME**) THAllocEx(pTHS, sizeof(DSNAME*)*refreshMax);

    // Determine the BestAfter time.  If the site affinity timestamp is
    // greater than the BestAfter time, then the user's membership will
    // be refreshed; otherwise it will be purged from the list (ie the
    // value will be removed from the site affinity attribute
    err = GetConfigParam(GCLESS_SITE_STICKINESS,
                         &siteStickiness,
                         sizeof(siteStickiness));
    if (err) {
        // siteStickiness is in minutes
        siteStickiness = GCLESS_DEFAULT_SITE_STICKINESS_DAYS*24*60;
        err = 0;
    }
    timeTemp.QuadPart = Int32x32To64(siteStickiness*60, ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    // Get the list of users by walking site affinity index
    DBOpen(&pTHS->pDB);

    __try {

        BOOL fFoundOurSite = FALSE;

        // Set up our site guid as the index value
        Assert(!fNullUuid(&gAnchor.pSiteDN->Guid));
        memcpy(&siteGuid, &gAnchor.pSiteDN->Guid, sizeof(GUID));
        memset(&IV, 0, sizeof(IV));
        IV.pvData = &siteGuid;
        IV.cbData = sizeof(siteGuid);

        // Set the index to the site affinity
        pAC = SCGetAttById(pTHS, ATT_MS_DS_SITE_AFFINITY);
        Assert(NULL != pAC);
        err = DBSetCurrentIndex(pTHS->pDB, 
                               (eIndexId)0, 
                               pAC, 
                               FALSE);  // don't maintain currency
        Assert(0 == err);
        if (err) {
            LogUnhandledError(err);
            DPRINT(0,"DBSetCurrentIndex to SiteAffinity failed\n");
            _leave;
        }

        err = DBSeek(pTHS->pDB,
                    &IV,
                     1,
                     DB_SeekGE);

        while (!err) {

            ATTR *pAttr;
            ULONG attrCount;
            DSNAME *pDSName;

            BOOL fCurrentEntryIsInSite = FALSE;

            // get our name
            pDSName = DBGetCurrentDSName(pTHS->pDB);
            Assert(pDSName);

            // get all of our site affinities
            err = DBGetMultipleAtts(pTHS->pDB,
                                    1, // all attributes
                                    &pAC,
                                    NULL, // no range
                                    NULL,
                                    &attrCount,
                                    &pAttr,
                                    DBGETMULTIPLEATTS_fEXTERNAL,
                                    0);

            // If we found this entry via an index, an attribute
            // value should exist
            Assert(!err);
            if (err) {
                DPRINT(0,"DBGetMultipleAtts failed even though entry in index exists\n");
                LogUnhandledError(err);
                _leave;
            }

            Assert(attrCount < 2);
            if (attrCount > 0) {
                // There must be at least one value
                Assert(pAttr->AttrVal.valCount > 0);

                // Find our site values
                Assert(pAttr->attrTyp == ATT_MS_DS_SITE_AFFINITY);
                for (i=0; i<pAttr->AttrVal.valCount; i++) {

                    SAMP_SITE_AFFINITY *psa;
                    ATTRVAL AttrVal = pAttr->AttrVal.pAVal[i];

                    Assert(sizeof(SAMP_SITE_AFFINITY) <= AttrVal.valLen);
                    psa = (SAMP_SITE_AFFINITY*) AttrVal.pVal;

                    if (IsEqualGUID(&siteGuid,&psa->SiteGuid)) {


                        if (ENTRY_HAS_EXPIRED(psa->TimeStamp, timeBestAfter)
                         && !IS_ZERO_TIME(psa->TimeStamp)  ) {

                            DPRINT1(0,"Expiring %ws \n", pDSName->StringName);
                            if ( oldCount < NELEMENTS(oldEntries) ) {
                                oldEntries[oldCount] = pTHS->pDB->DNT;
                                oldValues[oldCount].pVal = AttrVal.pVal;
                                oldValues[oldCount].valLen = AttrVal.valLen;
                                oldCount++;
                            }

                        } else {

                            DPRINT1(0,"Adding %ws to the refresh list\n", pDSName->StringName);
                            Assert(refreshCount < refreshMax);
                            if (refreshCount < refreshMax) {
                                refreshList[refreshCount++] = pDSName;
                            }
                        }

                        fFoundOurSite = TRUE;
                        fCurrentEntryIsInSite = TRUE;

                        //
                        // Once we have found our site, leave.
                        //
                        // N.B. This is necessary since we want to ignored
                        // site affinities that in error occur more than
                        // once.
                        //
                        break;
                    }
                }
            }

            // Are we done processing our site or have as many as we can
            // take?
            if ( (fFoundOurSite
             && !fCurrentEntryIsInSite)
             || (refreshCount >= refreshMax)) {

                Assert(refreshCount <= refreshMax);
                break;
            }

            // Move to the next candidate
            err = DBMove(pTHS->pDB, FALSE, 1);

        }
        err = 0;
        fCommit = TRUE;
    }
    _finally {
        DBClose(pTHS->pDB, fCommit);
    }

    if (err) {

        // An unexpected error hit
        // Log an event, reschedule, and return
        LogUnhandledError(err);
        if (pcSecsUntilNextIteration) {
            *pcSecsUntilNextIteration = UNEXPECTED_ERROR_RESCHEDULE_SECS;
        }
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }


    err = cleanupOldEntries(pTHS,
                            oldEntries,
                            oldValues,
                            oldCount);
    if (err) {
        // This isn't fatal
        err = 0;
    }

    if (refreshCount == refreshMax) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GROUP_CACHING_MAX_USERS_REFRESHED,
                 szInsertUL(refreshMax),
                 NULL,
                 NULL);
       
    }

Cleanup:

    if (0 == err) {
        *refreshListOutput = refreshList;
        *refreshCountOutput = refreshCount;
    }

    return err;

}

DWORD
updateMemberships(
    IN THSTATE *pTHS,
    IN LPWSTR gcName,
    IN LPWSTR gcDomain,
    IN DWORD  refreshCount,
    IN DSNAME** refreshList
    )
/*++

Routine Description:

    This routine calls gcName to update the cached memberships of the accounts
    in refreshList.
    
Parameters:

    pTHS -- thread state
    
    gcName -- the name of the GC to update memberships from
    
    gcDomain -- the domain name that the GC belongs to
    
    refreshCount -- the number of accounts that need refreshing
    
    refreshList -- the accounts that need refreshing

Return Values

    0

 --*/
{
    ULONG err = 0;
    ULONG refreshIndex;

    //
    // Now get and update the membership cache
    //
    refreshIndex = 0;
    while (refreshIndex < refreshCount
       &&  !eServiceShutdown ) {

        NTSTATUS ntStatus = STATUS_SUCCESS;
        ULONG count;
        DSNAME*  users[GC_BATCH_LIMIT];

        memset(&users, 0, sizeof(users));

        count = 0;
        while ( (count < NELEMENTS(users))
             && (refreshIndex < refreshCount) ) {

                users[count] = refreshList[refreshIndex];
                count++;
                refreshIndex++;
        }
        // Get the list of users by walking site affinity index
        DBOpen(&pTHS->pDB);
    
        __try {

            ntStatus = GetAccountAndUniversalMemberships(pTHS,
                                                         0, // no flags -> universal
                                                         gcName,
                                                         gcDomain,
                                                         count,
                                                         users,
                                                         TRUE, // refresh task
                                                         NULL,
                                                         NULL);
    
            if (!NT_SUCCESS(ntStatus)) {
    
                //
                // Strange -- log error and continue
                //
                LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_GROUP_CACHING_GROUP_RETRIEVAL_FAILED,
                         szInsertWin32Msg(RtlNtStatusToDosError(ntStatus)),
                         NULL,
                         NULL);
            }
        }
        _finally
        {
            if (pTHS->pDB) {
                // Don't commit changes since this will only happen on
                // error
                DBClose(pTHS->pDB, FALSE);
            }
        }
    }

    // There should not be a transaction
    Assert(NULL == pTHS->pDB);
    
    return 0;
}

DWORD
checkIfFallingBehind(
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    This routine checks that time stamp of the oldest cached membership. If
    the time stamp indicates that cached membership is still stale (even
    after the refresh task has already run), then an event log message is
    posted.
    
Parameters:

    pTHS -- thread state
    
Return Values

    0

 --*/
{

    DWORD err = 0;
    ATTCACHE *pAC;
    ULONG   oldEntries[MAX_CLEANUP_LIMIT];
    ATTRVAL oldValues[MAX_CLEANUP_LIMIT];
    ULONG   oldCount = 0;
    DWORD i;
    BOOLEAN fCommit = FALSE;

    //
    // Now determine if we are falling behind
    //
    DBOpen(&pTHS->pDB);
    __try {

        ULONG count = 0;

        // Set the index to the cached membership time stamp.
        // Find the entry with the earliest time stamp to see if
        // that entry is stale
        BOOL fFoundEntry = FALSE;

        pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
        Assert(NULL != pAC);
        err = DBSetCurrentIndex(pTHS->pDB, 
                               (eIndexId)0, 
                               pAC, 
                               FALSE);  // don't maintain currency
        Assert(0 == err);
        if (err) {
            LogUnhandledError(err);
            DPRINT(0,"DBSetCurrentIndex to SiteAffinity failed\n");
            _leave;
        }

        // Prepare to get the site affinity.
        pAC = SCGetAttById(pTHS, ATT_MS_DS_SITE_AFFINITY);
        Assert(NULL != pAC);

        // reset the count of elements we want to cleanup
        oldCount = 0;
        err = DBMove(pTHS->pDB,
                     FALSE,  // don't use sort table
                     DB_MoveFirst);
        while (!err) {

            ATTR *pAttr;
            ULONG attrCount;

            count++;
            if (count > NTDSA_SAM_CACHE_MAX_STALE_ACCOUNTS) {
                //
                // This is an unusual configuration; we have visited
                // many user's that have cached membership but no
                // site affinity. Break to avoid walking a large number
                // The cleanup code will eventually remove these
                // entries
                //
                break;
            }

            // get all of our site affinities
            err = DBGetMultipleAtts(pTHS->pDB,
                                    1, // all attributes
                                    &pAC,
                                    NULL, // no range
                                    NULL,
                                    &attrCount,
                                    &pAttr,
                                    DBGETMULTIPLEATTS_fEXTERNAL,
                                    0);

            if (!err) {

                if (attrCount > 0) {
                    // There must be at least one value
                    Assert(pAttr->AttrVal.valCount > 0);
    
                    // Find our site values
                    Assert(pAttr->attrTyp == ATT_MS_DS_SITE_AFFINITY);
                    for (i=0; i<pAttr->AttrVal.valCount; i++) {
    
                        SAMP_SITE_AFFINITY *psa;
                        ATTRVAL AttrVal = pAttr->AttrVal.pAVal[i];
    
                        Assert(sizeof(SAMP_SITE_AFFINITY) <= AttrVal.valLen);
                        psa = (SAMP_SITE_AFFINITY*) AttrVal.pVal;
    
                        if (IsEqualGUID(&gAnchor.pSiteDN->Guid,&psa->SiteGuid)) {

                            fFoundEntry = TRUE;
                            break;
                        }
                    }
                } else {

                    // A cached membership value, but no site affinity? 
                    // Cleanup this entry since it will never updated 
                    if ( oldCount < NELEMENTS(oldEntries) ) {
                        oldEntries[oldCount] = pTHS->pDB->DNT;
                        oldCount++;
                    }
                }
            }
            err = 0;

            if (fFoundEntry) {
                break;
            }

            err = DBMove(pTHS->pDB,
                         FALSE,  // don't use sort table
                         DB_MoveNext);
        }

        if (fFoundEntry) {

            LARGE_INTEGER entryExpires;
            LARGE_INTEGER lastRefreshTime;
            LARGE_INTEGER now;
            LARGE_INTEGER timeTemp;

            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP,
                                   &entryExpires,
                                   sizeof(entryExpires),
                                   NULL);
            if (!err) {

                // When does the last entry expire (measured in minutes)
                ULONG siteStaleness;
                err = GetConfigParam(GCLESS_STALENESS,
                                     &siteStaleness,
                                     sizeof(siteStaleness));
                if (err) {
                    siteStaleness = GCLESS_DEFAULT_STALENESS_HOURS * 60;
                    err = 0;
                }
                timeTemp.QuadPart = Int32x32To64(siteStaleness*60, ONE_SECOND_IN_FILETIME);
                entryExpires.QuadPart += timeTemp.QuadPart;

                GetSystemTimeAsFileTime((FILETIME*)&now);

                if (entryExpires.QuadPart < now.QuadPart ) {

                    // We are falling behind

                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_FALLING_BEHIND,
                             NULL,
                             NULL,
                             NULL);

                }

            }
        }

        if (err == JET_errNoCurrentRecord) {
            //
            // This is the case where no object has the cached membership
            // time stamp.
            //
            err = 0;
        }
        fCommit = TRUE;
    }
    _finally {
        DBClose(pTHS->pDB, fCommit);
    }


    if (oldCount > 0 ) {

        // An error here isn't fatal and are logged in the function
        // itself
        (VOID) cleanupOldEntries(pTHS,
                                 oldEntries,
                                 NULL,
                                 oldCount);
    }

    return 0;

}

VOID
RefreshUserMembershipsMain (
    DWORD * pcSecsUntilNextIteration,
    BOOL    fClientRequest
    )
/*++

Routine Description:

    This routine is the main algorithm for refreshing the cached group
    memberships for sites configured as branch offices. See spec for
    theory.

Parameters:

    pcSecsUntilNextIteration -- when the task should be resheduled
    
    fClientRequest -- TRUE if this task is being initiatized by a client request
                      (via a write to the rootDSE object)

Return Values
    
    None.

 --*/
{
    THSTATE *pTHS = pTHStls;
    ATTCACHE *pAC = NULL;

    DWORD err = 0;
    ULONG i;

    BOOL fRunNow = FALSE;
    LPWSTR siteName = NULL;
    LPWSTR gcName;
    LPWSTR gcDomain;

    DWORD refreshCount;
    DSNAME **refreshList = NULL;

    ULONG   dsidExit = 0;

    ULONG   cConnectedSites = 0;
    CACHE_CONNECTED_SITES *connectedSites = NULL;

    DPRINT(1,"Group Membership Cache Refresh Task commencing.\n");

    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
             DS_EVENT_SEV_BASIC,
             DIRLOG_GROUP_CACHING_TASK_STARTING,
             NULL,
             NULL,
             NULL);


    //
    // Either the task is running by itself or the caller has already 
    // been access check'ed.  In either case it is now safe to
    // set fDSA to TRUE.  It is also necessary since searches will
    // be made (to determine site information).
    //
    pTHS->fDSA = TRUE;
    _try
    {
        // Shutdown? Exit
        if (eServiceShutdown) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        if (!isGroupCachingEnabled()) {
            // nothing to do
            DPRINT(1,"Group caching not enabled -- exiting .\n");
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
        

        //
        // Determine if the task can run and the next time the task
        // should run.
        //
        err = getSchedulingInformation(pTHS,
                                       &fRunNow,
                                       pcSecsUntilNextIteration,
                                       &cConnectedSites,
                                       &connectedSites,
                                       &siteName,
                                       &dsidExit
                                     );
        if (err) {
            if (dsidExit == 0) {
                dsidExit = DSID(FILENO, __LINE__);
            }
            goto LogReturn;
        }


        if (!fRunNow && !fClientRequest) {
        
            // Always run during a client request
            Assert(0 != *pcSecsUntilNextIteration);
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }

        //
        // Get scheduling information and a target DC
        //
        err = getTargetGCInformation(pTHS,
                                     cConnectedSites,
                                     connectedSites,
                                     siteName,
                                     &gcName,
                                     &gcDomain,
                                     pcSecsUntilNextIteration,
                                     &dsidExit
                                     );
        if (err) {
            if (dsidExit == 0) {
                dsidExit = DSID(FILENO, __LINE__);
            }
            goto LogReturn;
        }
    
        //
        // Get the list of accounts to refresh
        //
        err = getAccountsToRefresh(pTHS,
                                   &refreshCount,
                                   &refreshList,
                                   pcSecsUntilNextIteration,
                                   &dsidExit
                                   );
        if (err) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        //
        // Update the memberships
        //
        err = updateMemberships(pTHS,
                                gcName,
                                gcDomain,
                                refreshCount,
                                refreshList);

        if (err) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        // Shutdown? Exit
        if (eServiceShutdown) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        //
        // Log a message if there are users that haven't been updated
        //
        err = checkIfFallingBehind(pTHS);
        if (err) {
            // unexpected
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }

        //
        // We are done!
        //
        dsidExit = DSID(FILENO, __LINE__);
        goto LogReturn;
    
    LogReturn:

        if (connectedSites) {
            for (i = 0; i < cConnectedSites; i++) {
                if (connectedSites[i].siteName) {
                    THFreeEx(pTHS, connectedSites[i].siteName);
                }
            }
            THFreeEx(pTHS, connectedSites);
        }
    
        if (siteName) {
            THFreeEx(pTHS, siteName);
        }
    
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_TASK_ENDING,
                 szInsertUL(err),
                 szInsertHex(dsidExit),
                 NULL);

    }
    _finally
    { 
        pTHS->fDSA = FALSE;
    }

    return;
}


void
RefreshUserMemberships (
        void *  pv,
        void ** ppvNext,
        DWORD * pcSecsUntilNextIteration
        )
/*++

Description:

    This routine is a wrapper for RefreshUserMembershipsMain.  The purpose
    is to be callable from the ds task queue.

Parameters:

    pv      -- input parameter for this iteration
    ppvNext -- input parameter for next iteration
    pcSecsUntilNextIteration -- seconds until next iteration
    
Return values:

       None.
       
--*/
{
    DWORD secsUntilNextIteration = 0;

    *pcSecsUntilNextIteration = 0;

    __try {

        RefreshUserMembershipsMain( pcSecsUntilNextIteration, FALSE );
    }
    __finally {

        // Something fatal happened
        if ( 0 == *pcSecsUntilNextIteration ) {
            *pcSecsUntilNextIteration = DEFAULT_REFRESH_INTERVAL_SECS;
        }

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_TASK_RESCHEDULING,
                 szInsertUL((*pcSecsUntilNextIteration / 60)),
                 NULL,
                 NULL);

        *ppvNext = pv;
    }
    
    return;
}

BOOL
siteContainsGC(
    IN THSTATE* pTHS,
    IN LPWSTR siteName
    )
/*++

Description:

    This routine determines if siteName contains a GC by searching in the DS
    for a NTDSA object that has the GC bit set on its options attribute

Parameters:

    pTHS -- thread state
    
    siteName -- the DN of a site

Return values:

    TRUE if siteName contains a GC; FALSE otherwise
       
--*/
{

    SEARCHRES * pSearchRes;
    ULONG err;
    FILTER * pf;
    DSNAME * siteDN;
    SEARCHARG searchArg;
    BOOL fFoundGC = FALSE;
    ATTR attr;
    ENTINF *EntInf = NULL;
    ENTINFLIST *EntInfList = NULL;
    ULONG len, size;
    ULONG i, j;
    DWORD ZeroValue = 0;
    DSNAME *pdnDsaObjCat;

    Assert(NULL != siteName);

    // Search for ntdsa objects with an options field greater than 0

    // First, create the siteDN
    len = wcslen(siteName);
    size = DSNameSizeFromLen(len);
    siteDN = THAllocEx(pTHS, size);
    siteDN->structLen = size;
    siteDN->NameLen = len;
    wcscpy(&siteDN->StringName[0], siteName);

    //
    // BUGBUG -- Scalability -- should this be a paged search?
    //
    memset(&searchArg, 0, sizeof(searchArg));
    InitCommarg(&searchArg.CommArg);
    searchArg.pObject = siteDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = TRUE;
    searchArg.searchAliases = FALSE;


    // Ask for the options attribute
    searchArg.pSelectionRange = NULL;
    searchArg.pSelection = THAllocEx(pTHS, sizeof(ENTINFSEL));
    searchArg.pSelection->attSel = EN_ATTSET_LIST;
    searchArg.pSelection->infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection->AttrTypBlock.attrCount = 1;
    searchArg.pSelection->AttrTypBlock.pAttr = &attr;
    memset(&attr, 0, sizeof(attr));
    attr.attrTyp = ATT_OPTIONS;

    // Build a filter to find NTDS-DSA objects

    // initial choice object
    searchArg.pFilter = pf = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_AND;
    pf->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));

    // first predicate:  the right object class
    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_NTDS_DSA);
    Assert(pdnDsaObjCat);
    pf = pf->FilterTypes.And.pFirstFilter;
    pf->choice = FILTER_CHOICE_ITEM;
    pf->pNextFilter = NULL;
    pf->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR*)pdnDsaObjCat;
    searchArg.pFilter->FilterTypes.And.count = 1;

    // second predicate:  ignore objects with no options field, or 
    // options equal to zero
    pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf = pf->pNextFilter;
    pf->pNextFilter = NULL;
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_GREATER;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OPTIONS;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(DWORD);
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)&ZeroValue;
    searchArg.pFilter->FilterTypes.And.count = 2;

    pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));

    SearchBody(pTHS,
               &searchArg, 
               pSearchRes,
               0);
    

    EntInfList = &pSearchRes->FirstEntInf;
    for (i = 0; i < pSearchRes->count; i++) {

        Assert(EntInfList != NULL);
        EntInf = &EntInfList->Entinf;

        for (j = 0; j < EntInf->AttrBlock.attrCount; j++) {

            ATTR *pAttr = &EntInf->AttrBlock.pAttr[j];
            ULONG Options;

            Assert(pAttr->attrTyp == ATT_OPTIONS);
            Assert(pAttr->AttrVal.valCount == 1);
            Assert(pAttr->AttrVal.pAVal[0].valLen == sizeof(DWORD));

            Options = *((DWORD*)pAttr->AttrVal.pAVal[0].pVal);

            if (Options & NTDSDSA_OPT_IS_GC) {
                // We found one
                fFoundGC = TRUE;
                break;
            }
        }
        EntInfList = EntInfList->pNextEntInf;
    }

    THClearErrors();

    if (!fFoundGC) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_GROUP_CACHING_GROUP_NO_GC_SITE,
                 szInsertWC(siteName),
                 NULL,
                 NULL);
    }

    return fFoundGC;

}


int
__cdecl
compareConnectedSites(
    const void* elem1,
    const void* elem2
    )
{
    CACHE_CONNECTED_SITES *cs1 = (CACHE_CONNECTED_SITES *)elem1;
    CACHE_CONNECTED_SITES *cs2 = (CACHE_CONNECTED_SITES *)elem2;

    return (int)cs1->cost - (int)cs2->cost;

}


DWORD
analyzeSitePreference(
    IN  ULONG defaultRefreshInterval,
    OUT ULONG* cConnectedSitesOutput,
    OUT CACHE_CONNECTED_SITES **connectedSitesOutput,
    OUT LPWSTR* siteName,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    )
/*++

Description:

    This routine is used during the cached membership refresh task to determine
    which site to ask the locator to find a GC in. Also, it determines if
    there is (IP) connectivity to the site now and hence if the task should
    run.

Parameters:

    defaultRefreshInterval -- the default refresh interval in seconds

    cConnectedSitesOutput -- the number of sites in the array of connected sites
    
    connectedSitesOutput -- an array of connected sites, to be freed with THFree
                            along with any embedded siteName fields
    
    siteName -- set to the admin configured site if one exists
    
    pfRunNow -- set to TRUE if there is connectivity to an available site now
    
    secsTillNextIteration -- based on the schedule information, this variable
                             indicates the next time this task should be run.
                             
    
Return values:

    0 on success:
    !0 on fatal error: all interesting events will be logged
       
--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD err = 0;
    WCHAR transportName[] = L"CN=IP,CN=Inter-Site Transports,CN=Sites,";
    LPWSTR transportDN = NULL;
    LPWSTR preferredSite = NULL, localSite= NULL, workSite = NULL;
    SCHEDULE *workSchedule = NULL;
    SCHEDULE *pSchedule = NULL;
    ULONG size, count;
    ULONG i, j;
    ULONG ourSiteIndex;
    ISM_SCHEDULE *pIsmSchedule = NULL;
    ISM_CONNECTIVITY *pConnectivity = NULL;
    CACHE_CONNECTED_SITES *connectedSites = NULL;
    ULONG cheapestCost;
    LPWSTR workSiteFriendlyName = NULL;

    // Init the out parameters
    *cConnectedSitesOutput = 0;
    *connectedSitesOutput = NULL;
    *siteName = NULL;

    // Prepare our local site
    localSite = THAllocEx(pTHS, (gAnchor.pSiteDN->NameLen+1) * sizeof(WCHAR));
    wcsncpy(localSite, 
            gAnchor.pSiteDN->StringName, 
            gAnchor.pSiteDN->NameLen);

    // Prepare the transport DN
    size = ((gAnchor.pConfigDN->NameLen+1) * sizeof(WCHAR)) + sizeof(transportName);
    transportDN = THAllocEx(pTHS, size);
    wcscpy(transportDN, transportName);
    wcsncat(transportDN, gAnchor.pConfigDN->StringName, gAnchor.pConfigDN->NameLen);

    // Read the configured preferred site, if any
    DBOpen(&pTHS->pDB);
    _try
    {
        WCHAR SiteSettingsCN[] = L"Ntds Site Settings";
        DSNAME *pSiteSettingsDN = NULL;
        
        size = 0;
        size = AppendRDN(gAnchor.pSiteDN,
                         pSiteSettingsDN,
                         size,
                         SiteSettingsCN,
                         0,
                         ATT_COMMON_NAME
                         );

        pSiteSettingsDN = THAllocEx(pTHS,size);
        pSiteSettingsDN->structLen = size;
        AppendRDN(gAnchor.pSiteDN,
                  pSiteSettingsDN,
                  size,
                  SiteSettingsCN,
                  0,
                  ATT_COMMON_NAME
                  );

        err = DBFindDSName(pTHS->pDB, pSiteSettingsDN);
        THFreeEx(pTHS,pSiteSettingsDN);
        if (!err) {
            ULONG len = 0;
            DSNAME *pPrefSiteDN;

            err = DBGetAttVal(pTHS->pDB,
                               1,
                               ATT_MS_DS_PREFERRED_GC_SITE,
                               0,
                               0,
                               &len,
                               (UCHAR**)&pPrefSiteDN);
            if (!err) {
                preferredSite = THAllocEx(pTHS, 
                                          (pPrefSiteDN->NameLen+1)*sizeof(WCHAR));
                wcsncpy(preferredSite, 
                        pPrefSiteDN->StringName, 
                        pPrefSiteDN->NameLen);
            }
        }

        if (preferredSite) {
    
            // There is a configured site
            // Note that we manually find a schedule instead of calling the
            // ISM -- this is by design.

            err = findScheduleForSite(pTHS,
                                      transportDN,
                                      localSite,
                                      preferredSite,
                                      &workSchedule);
            if (!err) {
    
                DWORD parseErr;
                DWORD len, ccKey, ccVal;
                WCHAR *pKey, *pVal;

                // And a valid schedule exists -- we'll use
                // this site
                workSite = preferredSite;

                // Return the value to the caller in the friendly name format
                len = wcslen(preferredSite);
                parseErr = GetRDN(&preferredSite,
                                  &len,
                                  &pKey,
                                  &ccKey,
                                  &pVal,
                                  &ccVal);
                Assert(0 == parseErr && (ccVal > 0));

                *siteName = THAllocEx(pTHS, (ccVal+1)*sizeof(WCHAR));
                wcsncpy(*siteName, pVal, ccVal);
                workSiteFriendlyName = *siteName;

            } else {

                // Can't get a schedule to the preferred site?
                // Log a warning
                LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_PREFERRED_SITE,
                         szInsertWC(preferredSite),
                         NULL,
                         NULL);
            }
        }

        //
        // No preferred site could be found -- make the expensive call to the
        // ISM to find a cheap site to schedule ourselves around.
        //
    
        if (NULL == workSite) {

            err = I_ISMGetConnectivity(transportDN,
                                       &pConnectivity);
    
            if (!err) {

                DSNAME *dsnameLocalSite = NULL;
                DSNAME *dsnameTargetSite = NULL;
                ULONG  len;

                Assert(NULL != pConnectivity);

                //
                // Convert the names to DSNAME's so the proper
                // name comparison function can be used.
                //
                len = wcslen(localSite);
                size = DSNameSizeFromLen(len);
                dsnameLocalSite = THAllocEx(pTHS,size);
                dsnameLocalSite->structLen = size;
                wcscpy(&dsnameLocalSite->StringName[0], localSite);
                dsnameLocalSite->NameLen = len;
        
                // Find our site
                for (i = 0; i < pConnectivity->cNumSites; i++) {
        
                    len = wcslen(pConnectivity->ppSiteDNs[i]);
                    size = DSNameSizeFromLen(len);
                    // Note the THAllocEx -- don't alloca in a loop
                    dsnameTargetSite = THAllocEx(pTHS, size);
                    memset(dsnameTargetSite, 0, size);
                    dsnameTargetSite->structLen = size;
                    wcscpy(&dsnameTargetSite->StringName[0], pConnectivity->ppSiteDNs[i]);
                    dsnameTargetSite->NameLen = len;

                    if (NameMatchedStringNameOnly(dsnameLocalSite,
                                                  dsnameTargetSite)) {
                        // This is it;
                        THFreeEx(pTHS, dsnameTargetSite);
                        ourSiteIndex = i;
                        break;
                    }
                    THFreeEx(pTHS, dsnameTargetSite);
                }
                THFreeEx(pTHS,dsnameLocalSite);

                if (i == pConnectivity->cNumSites) {
                    //
                    // This is an unexpected occurrance; we couldn't find
                    // our site.
                    //
                    err = ERROR_NO_SUCH_SITE;
                    leave;
                }
        
        
                // Now find sites we are connected too
                //
                // N.B. We are considered connected to our own site, so if we
                // have a GC, then use our site.  This behavoir falls out
                // naturally from the algorithm below.
                //                

                connectedSites = (CACHE_CONNECTED_SITES*)THAllocEx(pTHS, 
                                           pConnectivity->cNumSites * sizeof(CACHE_CONNECTED_SITES));
                count = 0;
                for (j = 0; j < pConnectivity->cNumSites; j++) {
        
                    if (pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost != 0xFFFFFFFF) {
                        // There is connectivity

                        DPRINT3(1,"Connectivity found between %ls and %ls, cost %d\n", 
                                localSite,
                                pConnectivity->ppSiteDNs[j],
                                pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost);
                        connectedSites[count].siteName = pConnectivity->ppSiteDNs[j];
                        connectedSites[count].cost = pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost;
                        count++;
                    }
                }
        
                // sort the array in decreasing cost
                if (count > 0) {
        
                    qsort(connectedSites, 
                          count,
                          sizeof(*connectedSites),
                          compareConnectedSites);
                }
        
                // Find the cheapest sites with a GC in them and put the sites
                // into connectedSites.  Note that the siteName field
                // is changed from the the DN to the friendly name and
                // that no references to ISM allocated memory are returned
                // from this function.
                Assert( NULL == workSite );
                for (i = 0; i < count; i++) {

                    if (workSite 
                     && (connectedSites[i].cost > cheapestCost)) {

                        // We have found at least one site with a GC and are
                        // now on to more expensive sites.  We can exit.
                        break;
                    }

                    if (siteContainsGC(pTHS, connectedSites[i].siteName)) {

                        if (pIsmSchedule) {
                            I_ISMFree(pIsmSchedule);
                            pIsmSchedule = NULL;
                        }
        
                        // make sure there is a schedule
                        err = I_ISMGetConnectionSchedule(transportDN,
                                                         localSite,
                                                         connectedSites[i].siteName,
                                                         &pIsmSchedule);
                        if (!err) {

                            DWORD parseErr;
                            DWORD ccKey, ccVal;
                            WCHAR *pKey, *pVal;
                            LPWSTR friendlyName;

                            // And a valid schedule exists -- we'll use
                            // this site
                            connectedSites[i].fHasGC = TRUE;

                            //
                            // Replace the DN with a friendly name
                            //
                            len = wcslen(connectedSites[i].siteName);
                            parseErr = GetRDN(&connectedSites[i].siteName,
                                              &len,
                                              &pKey,
                                              &ccKey,
                                              &pVal,
                                              &ccVal);
                            Assert(0 == parseErr && (ccVal > 0));
            
                            friendlyName = THAllocEx(pTHS, (ccVal+1)*sizeof(WCHAR));
                            wcsncpy(friendlyName, pVal, ccVal);

                            if (NULL == workSite) {

                                //
                                // We'll use the first cheapest site to schedule
                                // ourselves on.
                                //

                                cheapestCost = connectedSites[i].cost;
                                workSite = connectedSites[i].siteName;
                                workSiteFriendlyName = friendlyName;

                                if (pIsmSchedule && pIsmSchedule->pbSchedule) {
                                    workSchedule = THAllocEx(pTHS, pIsmSchedule->cbSchedule);
                                    memcpy(workSchedule, pIsmSchedule->pbSchedule, pIsmSchedule->cbSchedule);
                                }
                            }

                            // Change over to the friendly name
                            connectedSites[i].siteName = friendlyName;

                        } else {

                            LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                                     DS_EVENT_SEV_BASIC,
                                     DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_SITE,
                                     szInsertWC(connectedSites[i].siteName),
                                     szInsertUL(err),
                                     NULL);

                            connectedSites[i].siteName = NULL;
                        }

                    } else {

                        connectedSites[i].siteName = NULL;
                    }


                }

                // Set the return values.  i is the number of sites that
                // were visited in the loop above.
                *cConnectedSitesOutput = i;
                *connectedSitesOutput = connectedSites;

            }
        }
    }
    _finally {
        DBClose(pTHS->pDB, TRUE);
    }

    if (workSite) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_SITE_FOUND,
                 szInsertWC(workSiteFriendlyName),
                 NULL,
                 NULL);

        analyzeSchedule(defaultRefreshInterval,
                        workSite,
                        workSchedule,
                        pfRunNow,
                        secsTillNextIteration);

    } else {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_NO_SITE_FOUND,
                 NULL,
                 NULL,
                 NULL);

        // Our best efforts failed. Rely on the locator
        // and use default scheduling
        *pfRunNow = TRUE;
        *secsTillNextIteration = defaultRefreshInterval;
    }

    if (connectedSites && (NULL == *connectedSitesOutput)) {
        THFreeEx(pTHS, connectedSites);
    }

    if (workSchedule) {
        THFreeEx(pTHS, workSchedule);
    }

    if (pConnectivity) {
        I_ISMFree(pConnectivity);
    }

    if (pIsmSchedule) {
        I_ISMFree(pIsmSchedule);
    }

    return err;

}


DWORD 
getGCFromSite(
    IN  THSTATE *pTHS,
    IN  LPWSTR siteName,
    IN  ULONG cConnectedSites OPTIONAL,
    IN  CACHE_CONNECTED_SITES *connectedSites OPTIONAL,
    OUT LPWSTR *gcName,
    OUT LPWSTR *gcDomain
    )
/*++

Description:

    This routine is used during the cached membership refresh task to determine
    which site to ask the locator to find a GC in. Also, it determines if
    there is (IP) connectivity to the site now and hence if the task should
    run.

Parameters:

    siteName -- the user specified site name; returned as NULL if the user
                hasn't configured one

    cConnectedSites -- the number of sites in the array of connected sites
    
    connectedSites -- an array of connected sites
                
    pfRunNow -- set to TRUE if there is connectivity to an available site now
    
    secsTillNextIteration -- based on the schedule information, this variable
                             indicates the next time this task should be run.
                             
    
Return values:

    0 on success:
    !0 on fatal error: all interesting events will be logged
       
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW  DomainControllerInfo = NULL;
    DWORD Flags;
    DWORD attempt = 0;
    LPWSTR requestedSiteName = siteName;

    *gcName = NULL;
    *gcDomain = NULL;

    // Necessary flags
    Flags = DS_GC_SERVER_REQUIRED | DS_RETURN_DNS_NAME;

    while (TRUE)  {

        //
        // GC discovery algorithm is as follows:
        //
        // Try to find GC in preferred site (if one is provided).
        // If that fails, try again for any site.
        //

        if (DomainControllerInfo) {
            NetApiBufferFree(DomainControllerInfo);
            DomainControllerInfo = NULL;
        }

        //
        // Call into DsGetDcName
        //
        WinError = DsGetDcNameW(NULL,  // call locally
                                NULL,  // domain doesn't matter
                                NULL,  // domain guid
                                requestedSiteName,  // site name
                                Flags,
                                &DomainControllerInfo);


        if ( (ERROR_SUCCESS != WinError)
         &&  (NULL != requestedSiteName) ) {
            //
            // Try again with no site name and turn off the force flag just
            // in case it was previously set
            //
            requestedSiteName = NULL;
            continue;
        }

        break;

    }

    if ( ERROR_SUCCESS == WinError ) {

        //
        // We found a GC
        //
        LPWSTR discoveredSiteName;
        DWORD len;
        BOOL  fRewind = FALSE;

        Assert(DomainControllerInfo != NULL);

        //
        // Copy the info to the out parameters
        //
        Assert(DomainControllerInfo->DomainControllerName);
        len = wcslen(DomainControllerInfo->DomainControllerName);
        (*gcName) = THAllocEx(pTHS, (len+1) * sizeof(WCHAR));
        wcscpy( (*gcName), DomainControllerInfo->DomainControllerName);

        Assert(DomainControllerInfo->DomainName);
        if (DomainControllerInfo->DomainName[0] == L'\\' ) {
            DomainControllerInfo->DomainName += 2;
        }
        len = wcslen(DomainControllerInfo->DomainName);
        (*gcDomain) = THAllocEx(pTHS, (len+1) * sizeof(WCHAR));
        wcscpy( (*gcDomain), DomainControllerInfo->DomainName);
        if (fRewind) {
            DomainControllerInfo->DomainName -= 2;
        }

        //
        // Perform some analysis to determine how good the GC is
        //
        discoveredSiteName = DomainControllerInfo->DcSiteName;
        if (discoveredSiteName) {

            //
            // First, if there was a preferred site and the destination DC is
            // not in the preferred site, log a warning
            //
            if (siteName) {
    
                if (!EQUAL_STRING(siteName, discoveredSiteName)) {
    
                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_CLOSER_GC_FOUND,
                             szInsertWC(siteName),
                             szInsertWC(discoveredSiteName),
                             NULL);
                }
            }

            //
            // Next, if we have a list of close sites as determined by the ISM
            // see if the GC that the locator found is in one of those sites
            //
            if (connectedSites) {
    
                BOOL fdiscoveredSiteIsCheap = FALSE;
                ULONG i;

                for (i = 0; i < cConnectedSites; i++) {
    
                    if ( connectedSites[i].fHasGC
                     &&  EQUAL_STRING(discoveredSiteName, connectedSites[i].siteName)) {

                         fdiscoveredSiteIsCheap = TRUE;
                         break;
                    }
                }

                if (!fdiscoveredSiteIsCheap) {

                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_CONFIGURED_SITE_NOT_CLOSEST,
                             szInsertWC(discoveredSiteName),
                             NULL,
                             NULL);

                }
            }
        }

       LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                DS_EVENT_SEV_BASIC,
                DIRLOG_GROUP_CACHING_GC_FOUND,
                szInsertWC(*gcName),
                szInsertWC(DomainControllerInfo->DcSiteName),
                szInsertWC(*gcDomain));
    }


    if ( ERROR_SUCCESS != WinError ) {

        //
        // Couldn't find a GC -- log an error message
        //
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_NO_GC_FOUND,
                 szInsertWin32Msg(WinError),
                 NULL,
                 NULL);

    }

    if (DomainControllerInfo) {
        NetApiBufferFree(DomainControllerInfo);
    }

    return WinError;
}

VOID
analyzeSchedule(
    IN  ULONG    defaultRefreshInterval,
    IN  LPWSTR   siteName,
    IN  SCHEDULE *pSchedule OPTIONAL,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    )
/*++

Description:

    This routine, given a schedule, determines if there is the current
    time falls under an open windows now.  Also it sets the next time
    for the fresh task to run.

Parameters:

    siteName  -- name of the site we are connecting with
                              
    pSchedule -- a schedule of 15 minutes slots
    
    defaultRefreshInterval -- default seconds 'till next iteration
    
    pfRunNow  -- is there a window open now
    
    secsTillNextIteration -- when the task should next run

Return values:

    None.
       
--*/
{
    REPLTIMES replTimes;
    ULONG i;
    DSTIME now, nextTime;
    BOOL fOn;
    ULONG count;
    UCHAR *pTemp;
    ULONG  randomFactor;
    DSTIME  proposedTime;
#if DBG
    // The date string won't be more than 40 characters
    CHAR    DsTimeBuffer[40];
#endif

    Assert(pfRunNow);
    Assert(secsTillNextIteration);

    if ( (pSchedule == NULL) 
      || (pSchedule->NumberOfSchedules == 0)
      || (!convertScheduleToReplTimes(pSchedule, &replTimes))) {
        DPRINT(1,"Running now since schedule is always on\n");
        fOn = TRUE;
        *pfRunNow = TRUE;
        *secsTillNextIteration = defaultRefreshInterval;

    } else {

        //
        // look through the schedule
        //
        now = DBTime();
        DPRINT1(1,"Current Time: %s\n", DbgPrintDsTime(now, DsTimeBuffer));

        (*pfRunNow) = fIsBetweenTime(&replTimes, now, now);
    
        // Now determine the next time to wake up
        nextTime = now;
        if ((*pfRunNow)) {
            DPRINT(1,"Can run right now\n");
            nextTime += defaultRefreshInterval;
        }
    
        // Find the next "on" time starting with nextTime
        count = 0;
        do {
            DPRINT1(1,"Next proposed time %s\n", DbgPrintDsTime(nextTime, DsTimeBuffer));
            fOn = fIsBetweenTime(&replTimes, nextTime, nextTime);
            if (fOn) {
                DPRINT1(1,"This last time (%s) works\n", DbgPrintDsTime(nextTime, DsTimeBuffer));
                break;
            } else {
                // 15 minutes
                #define FIFTEEN_MINUTES_IN_SECONDS 900
                nextTime +=  900;
            }
            count++;
            // There are 672 fifteen minute slots in a week
        } while (count < 672);

        if (fOn) {
            *secsTillNextIteration = (ULONG) (nextTime - now);
        } else {
            *secsTillNextIteration = defaultRefreshInterval;
        }
    }

    // Add a randomizing factor (0 and 14 minutes) so not all DC's go 
    // at the same time
    srand((unsigned int) time(NULL));
    randomFactor = (rand() % 15) * (60);

    // Add the factor if the result is still with in the window, otherwise
    // subtract.  If that doesn't work, leave as is.
    proposedTime = now + *secsTillNextIteration + randomFactor;
    if (fIsBetweenTime(&replTimes, proposedTime, proposedTime) ) {
        DPRINT2(1,"Proposed time of %s works (random factor of %d seconds added)\n", DbgPrintDsTime(proposedTime, DsTimeBuffer), randomFactor);
        *secsTillNextIteration += randomFactor;
    } else {
        proposedTime = now + *secsTillNextIteration - randomFactor;
        if (fIsBetweenTime(&replTimes, proposedTime, proposedTime) ) {
            DPRINT2(1,"Proposed time of %s works (random factor of %d subtracted)\n", DbgPrintDsTime(proposedTime, DsTimeBuffer), randomFactor);
            *secsTillNextIteration -= randomFactor;
        } else {
            DPRINT(1,"Random factor did not help -- leaving alone\n");
        }
    }
    Assert(fIsBetweenTime(&replTimes, now + *secsTillNextIteration, now + *secsTillNextIteration));

    if (!fOn) {

        ULONG nextIter = *secsTillNextIteration / (60 * 60);
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GROUP_CACHING_CANT_FIND_OPEN_SLOT,
                 szInsertWC(siteName),
                 szInsertUL(nextIter),
                 NULL);
    }

    return;
}



VOID
freeAUGMemberships(
    IN THSTATE *pTHS,
    IN AUG_MEMBERSHIPS*p
    )
//
// Frees the embedded members of an AUG_MEMBERSHIPS structure
//
{
    if (p) {
        ULONG i;

        for (i = 0; i < p->MembershipCount; i++) {
            THFreeEx(pTHS, p->Memberships[i]);
        }
        THFreeEx(pTHS, p->Memberships);

        for (i = 0; i < p->SidHistoryCount; i++) {
            THFreeEx(pTHS, p->SidHistory[i]);
        }
        THFreeEx(pTHS, p->SidHistory);

        if (p->Attributes) {
            THFreeEx(pTHS, p->Attributes);
        }
    }
    return;
}


BOOL
isGroupCachingEnabled(
    VOID
    )
/*++

Routine Description:

    This routine returns whether group caching is turned on for the local
    site.

Parameters:

    None.

Return Values:

    TRUE or FALSE

 --*/
{
    BOOL fEnabled = FALSE;
    NTSTATUS st;
    BOOLEAN fMixed;

    st  = SamIMixedDomain2(&gAnchor.pDomainDN->Sid, &fMixed);
    if (!NT_SUCCESS(st)) {
        fMixed = TRUE;
    }
    fEnabled =  (gAnchor.SiteOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED)
            && !SampAmIGC()
            && !fMixed;

    return fEnabled;
}


DWORD
cleanupOldEntries(
    IN THSTATE *pTHS,
    IN ULONG *DNTList,
    IN ATTRVAL *Values OPTIONAL,
    IN ULONG  DNTCount
    )
/*++

Description:

    This routine takes a list of objects whose no gc logon attributes
    are to be removed.
    
Parameters:

    pTHS -- thread state
    
    DNTList -- the list of objects, by DNT, that should be cleaned up
    
    Values -- the site affinity values, if any, that should be removed
    
    DNTCount -- the number of objects that need cleaning up                      

Return values:

    0
    
--*/
{

    ULONG err;
    ULONG i;
    BOOL fLazyCommit = pTHS->fLazyCommit;

    pTHS->fLazyCommit = TRUE;

    for (i = 0; i < DNTCount; i++) {

        BOOL fCommit = FALSE;

        DBOpen(&pTHS->pDB);
        _try
        {
            DBFindDNT(pTHS->pDB, DNTList[i]);

            if (ARGUMENT_PRESENT(Values)) {
                // remove the site affinity value
                err = DBRemAttVal(pTHS->pDB,
                                  ATT_MS_DS_SITE_AFFINITY,
                                  Values[i].valLen,
                                  Values[i].pVal);
                if (err) {
                    if (DB_ERR_VALUE_DOESNT_EXIST != err) {
                        DPRINT(0,"DBRemAttVal failed unexpectantly.\n");
                        LogUnhandledError(err);
                    }
                    // This is not fatal
                    err = 0;
                }
            }
        
            // remove the cached membership
            err = DBRemAtt(pTHS->pDB,
                           ATT_MS_DS_CACHED_MEMBERSHIP);
            if (err) {
                if (DB_ERR_ATTRIBUTE_DOESNT_EXIST != err) {
                    DPRINT(0,"DBRemAtt failed unexpectantly.\n");
                    LogUnhandledError(err);
                }
                // This is not fatal
                err = 0;
            }
        
            // remove the cached membership time stamp
            err = DBRemAtt(pTHS->pDB,
                           ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
        
            if (err) {
                if (DB_ERR_ATTRIBUTE_DOESNT_EXIST != err) {
                    DPRINT(0,"DBRemAtt failed unexpectantly.\n");
                    LogUnhandledError(err);
                }
                // This is not fatal
                err = 0;
            }
        
            if (!err) {
                err  = DBRepl(pTHS->pDB, 
                              FALSE,  // not DRA
                              0,
                              NULL,
                              0 );
                if (err) {
                    DPRINT1(0,"DBRepl failed with 0x%d unexpectantly\n", err);
                }
            }
            fCommit = TRUE;
        }
        _finally
        {

            DBClose(pTHS->pDB, fCommit);
        }
    }

    pTHS->fLazyCommit = fLazyCommit;

    return 0;

}


BOOL 
convertScheduleToReplTimes(
    IN PSCHEDULE schedule,
    OUT REPLTIMES *replTimes
    )
/*++

Description:

    This routine translates a schedule into a REPLTIMEs structure.
    
    This is useful so that repl routines to analyse a schedule can be 
    used.

    This routine was lifted from the routine KCC_CONNECTION::SetSchedule      
    
Parameters:

    schedule -- the scheduled (already filled in)
    
    replTimes -- repltimes to be filled in during this routine

Return values:

    TRUE if translation was successfull (schedule was something we could
    understand)
    
    FALSE otherwise.
       
--*/
{
    ULONG i, j;
    LONG  nInterval;

    if ((1 <= schedule->NumberOfSchedules) && (3 >= schedule->NumberOfSchedules)) {

       // locate the interval schedule in the struct and ignore bandwidth & priority
       nInterval = -1;
       for (j = 0; j < schedule->NumberOfSchedules; j++) {

           if (SCHEDULE_INTERVAL == schedule->Schedules[j].Type) {

               // located the INTERVAL schedule - if there are more than one INTERVAL schedules
               // in the blob, we will use only the first one.
               nInterval = j;
               break;
           }
       }

       if (nInterval >= 0) {

           // sanity check to see if all the interval schedule data is present
           if ((schedule->Schedules[nInterval].Offset + SCHEDULE_DATA_ENTRIES) <= schedule->Size) {

               // Everything in the blob is as expected and we found a valid INTERVAL schedule
               // - convert the 168 byte schedule data to the internal 84 byte format
               PBYTE pbSchedule = ((PBYTE) schedule) + schedule->Schedules[nInterval].Offset;
               for (i = 0, j = 0; j < SCHEDULE_DATA_ENTRIES; ++i, j += 2) {

                   replTimes->rgTimes[i] = (((pbSchedule[j] & 0x0F) << 4) | (pbSchedule[j+1] & 0x0F));
               }

               return TRUE;
           }
       }
    }

    return FALSE;
}


DWORD
findScheduleForSite(
    IN  THSTATE*   pTHS,
    IN  LPWSTR     transportDN,
    IN  LPWSTR     localSiteName,
    IN  LPWSTR     targetSiteName,
    OUT PSCHEDULE *ppSchedule
    )
/*++

Routine Description:

    This routine finds the cheapest schedule connecting localSiteName
    and targetSiteName.  It does this by querying site connections.                  
    
Parameters:


    pTHS -- thread state

    transportDN -- the DN of the transport under which to look for site links
    
    localSiteName -- the site hosted by this DS
    
    targetSiteName -- the destination site that no gc logon wants to talk to
    
    ppSchedule -- the schedule of the cheapest link, if one exists.


Return Values

    0 on success, ERROR_NOT_FOUND if no schedule can be found

 --*/
{
    ULONG err = 0;
    SEARCHRES * pSearchRes;
    FILTER * pf, *topLevelFilter;
    DSNAME * siteDN;
    SEARCHARG searchArg;
    ATTR attr, attrList[2];
    ENTINF *EntInf = NULL;
    ENTINFLIST *EntInfList = NULL;
    ULONG len, size;
    ULONG i, j;
    DSNAME *pdnDsaObjCat;
    DSNAME *pdnLocalSite;
    DSNAME *pdnTargetSite;
    DSNAME *pdnTransport;
    BOOL   fScheduleFound = FALSE;

    ULONG minimumCost;
    PSCHEDULE minimumSchedule;
    DSNAME * minimumName;

    Assert(transportDN);
    Assert(localSiteName);
    Assert(targetSiteName);
    Assert(ppSchedule);
    
    // Init the out parameter
    *ppSchedule = NULL;
    
    //
    // First, create the DSNAME's for the search
    //
    len = wcslen(localSiteName);
    size = DSNameSizeFromLen(len);
    pdnLocalSite = THAllocEx(pTHS, size);
    pdnLocalSite->structLen = size;
    pdnLocalSite->NameLen = len;
    wcscpy(pdnLocalSite->StringName, localSiteName);

    len = wcslen(targetSiteName);
    size = DSNameSizeFromLen(len);
    pdnTargetSite = THAllocEx(pTHS, size);
    pdnTargetSite->structLen = size;
    pdnTargetSite->NameLen = len;
    wcscpy(pdnTargetSite->StringName, targetSiteName);

    len = wcslen(transportDN);
    size = DSNameSizeFromLen(len);
    pdnTransport = THAllocEx(pTHS, size);
    pdnTransport->structLen = size;
    pdnTransport->NameLen = len;
    wcscpy(pdnTransport->StringName, transportDN);
    
    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_SITE_LINK);
    Assert(pdnDsaObjCat);
    
    if (!pdnDsaObjCat) {
        return ERROR_NOT_FOUND;
    }
    
    //
    // Create the filter: 
    //
    //      siteLink objects
    //  and siteobject attribute contains localSite
    //  and siteobject attribute contains targetSite
    //
    
    // initial choice object
    pf = topLevelFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_AND;
    pf->FilterTypes.And.count = 3;

    // first predicate:  siteList contains localsite
    pf = pf->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_SITE_LIST;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnLocalSite->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)pdnLocalSite;
    
    // second predicate:  siteList contains targetSite
    pf = pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_SITE_LIST;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnTargetSite->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)pdnTargetSite;

    // third predicate:  the right object class
    pf = pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR*)pdnDsaObjCat;
    
    
    // 
    // Setup the search arguments
    //
    memset(&searchArg, 0, sizeof(searchArg));
    
    InitCommarg(&searchArg.CommArg);
    
    searchArg.pObject = pdnTransport;
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.searchAliases = FALSE;
    searchArg.pFilter = topLevelFilter;
    
    // Ask for the cost and schedule attribute
    searchArg.pSelectionRange = NULL;
    searchArg.pSelection = THAllocEx(pTHS, sizeof(ENTINFSEL));
    searchArg.pSelection->attSel = EN_ATTSET_LIST;
    searchArg.pSelection->infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection->AttrTypBlock.attrCount = 2;
    searchArg.pSelection->AttrTypBlock.pAttr = attrList;
    memset(&attrList, 0, sizeof(attrList));
    attrList[0].attrTyp = ATT_COST;
    attrList[1].attrTyp = ATT_SCHEDULE;
    
    pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));

    //
    // Do the search
    //
    
    SearchBody(pTHS,
              &searchArg, 
               pSearchRes,
               0);
    

    THClearErrors();

    //
    // Find the cheapest link in the return set, if any
    //
    minimumCost = 0xFFFFFFFF;
    minimumSchedule = NULL;
    minimumName = NULL;

    if ( pSearchRes
     &&  pSearchRes->count > 0) {
    
        DPRINT1(0,"%d sites returned\n", pSearchRes->count);

        EntInfList = &pSearchRes->FirstEntInf;
        while (EntInfList) {
        
            ULONG cost = 0xFFFFFFFF;
            PSCHEDULE  schedule = NULL;

            EntInf = &EntInfList->Entinf;

            DPRINT1(0,"Site link %ws found \n", EntInf->pName->StringName);
    
            for (j = 0; j < EntInf->AttrBlock.attrCount; j++) {
        
                ATTR *pAttr = &EntInf->AttrBlock.pAttr[j];
                ULONG Options;
            
                switch (pAttr->attrTyp) {
                
                case ATT_SCHEDULE:
    
                    schedule = (PSCHEDULE)pAttr->AttrVal.pAVal[0].pVal;
                    Assert(schedule->Size == pAttr->AttrVal.pAVal[0].valLen);
                    break;
    
                case ATT_COST:
    
                    Assert(sizeof(DWORD) == pAttr->AttrVal.pAVal[0].valLen);
                    cost = *(ULONG*)pAttr->AttrVal.pAVal[0].pVal;
                    break;
    
                }
            }
    
            if ( (minimumName == NULL)
              || (cost < minimumCost)   ) {

                //
                // A new winner!
                //
                minimumCost = cost;
                minimumSchedule = schedule;
                minimumName = EntInf->pName;
    
            }

            EntInfList = EntInfList->pNextEntInf;
        }
        
    }

    if (minimumName == NULL) {

        err = ERROR_NOT_FOUND;

    } else {

        //
        // Success
        //

        *ppSchedule = minimumSchedule;

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_PREFERRED_SITE_LINK,
                 szInsertDN(minimumName),
                 NULL,
                 NULL);

        err = 0;

    }
    
    return err;
 }

#if DBG

LPSTR
GetDay(
    ULONG i
    )
{
    switch (i) {
    case 0:
        return "Sun";
    case 1:
        return "Mon";
    case 2:
        return "Tue";
    case 3:
        return "Wed";
    case 4:
        return "Th";
    case 5:
        return "Fri";
    case 6:
        return "Sat";
    default:
        return NULL;
    }
}

LPSTR
GetMonth(
    ULONG i
    )
{
    switch (i) {
    case 1:
        return "Jan";
    case 2:
        return "Feb";
    case 3:
        return "Mar";
    case 4:
        return "Apr";
    case 5:
        return "May";
    case 6:
        return "Jun";
    case 7:
        return "Jul";
    case 8:
        return "Aug";
    case 9:
        return "Sep";
    case 10:
        return "Oct";
    case 11:
        return "Nov";
    case 12:
        return "Dec";
    default:
        return NULL;
    }
}


LPSTR
DbgPrintDsTime(
    DSTIME time,
    CHAR * buffer
    )
{
    FILETIME ft;
    SYSTEMTIME st;
    DSTIME localTime;

    localTime = (10*1000*1000L) * time;

    ft.dwHighDateTime = (DWORD)(localTime >> 32);
    ft.dwLowDateTime =  (DWORD)(localTime);

    if (FileTimeToSystemTime(&ft, &st)) {

        sprintf(buffer, 
                "%s %s %d, %d  %d:%d:%d", 
                GetDay(st.wDayOfWeek),
                GetMonth(st.wMonth),
                st.wDay,
                st.wYear,
                st.wHour,
                st.wMinute,
                st.wSecond);

        return buffer;
    }

    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\permit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       permit.c
//
//--------------------------------------------------------------------------

/****************************************************************************
    PURPOSE:    Permission checking procedure to be called by the DSA

    FUNCTIONS:  CheckPermissions is the procedure that performs this task.

    COMMENTS:   This function must be called by a server within the context
        of impersonating a client. This can be done by calling
        RpcImpersonateClient() or ImpersonateNamedPipeClient(). This
        creates an impersonation token which is vital for AccessCheck
****************************************************************************/

#include <NTDSpch.h>
#pragma hdrstop

#define SECURITY_WIN32
#include <sspi.h>
#include <samisrv2.h>
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <rpcasync.h>

#include <ntdsa.h>
#include "scache.h"
#include "dbglobal.h"
#include <mdglobal.h>
#include "mdlocal.h"
#include <dsatools.h>
#include <objids.h>
#include <debug.h>

#define DEBSUB "PERMIT:"

#include "permit.h"
#include "anchor.h"

#include <dsevent.h>
#include <fileno.h>
#define FILENO FILENO_PERMIT

#include <checkacl.h>
#include <dsconfig.h>

extern PSID gpDomainAdminSid;


// Debug only hook to turn security off with a debugger
#if DBG == 1
DWORD dwSkipSecurity=FALSE;
#endif

VOID
DumpToken(HANDLE);

VOID
PrintPrivileges(TOKEN_PRIVILEGES *pTokenPrivileges);

DWORD
SetDomainAdminsAsDefaultOwner(
        IN  PSECURITY_DESCRIPTOR    CreatorSD,
        IN  ULONG                   cbCreatorSD,
        IN  HANDLE                  ClientToken,
        OUT PSECURITY_DESCRIPTOR    *NewCreatorSD,
        OUT PULONG                  NewCreatorSDLen
        );


#define AUDIT_OPERATION_TYPE_W L"Object Access"

DWORD
CheckPermissionsAnyClient(
    PSECURITY_DESCRIPTOR pSelfRelativeSD,
    PDSNAME pDN,
    ACCESS_MASK ulDesiredAccess,
    POBJECT_TYPE_LIST pObjList,
    DWORD cObjList,
    ACCESS_MASK *pGrantedAccess,
    DWORD *pAccessStatus,
    DWORD flags,
    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCtx
    )
//
// CheckPermissionsAnyClient is the 'any' flavor of CheckPermissions. It assumes
// the server is currently treating a non-NP client, and is currently in its
// own security context. If the Authz context is not found in the thread state,
// the client will be impersonated on behalf of the server and the context created.
// Optionally, an authz client context can be passed in in hAuthzCtx.
//
// Parameters:
//
//  pSelfRelativeSD   pointer to the valid self relative security descriptor
//                    against which access is checked. (read only).
//
//  pDN               DN of the object we are checking.  We only care about
//                    the GUID and SID.
//
//  DesiredAccess     access mask of requested permissions. If the generic
//                    bits are set they are mapped into specific and standard rights
//                    using DS_GENERIC_MAPPING. (read only)
//
//  pObjList          Array of OBJECT_TYPE_LIST objects describing the objects we are
//                    trying to check security against.
//
//  cObjList          the number of elements in pObjList
//
//  pGrantedAccess    pointer to an array of ACCESS_MASKs of the same number of
//                    elements as pObjList (i.e. cObjList).  Gets filled in with
//                    the actual access granted. If CheckPermissions was't successful
//                    this parameter's value is undefined. (write only)
//                    This parameter may be NULL if this info is not important
//
//  pAccessStatus     pointer to an array of DWORDs to be set to indicate
//                    whether the requested access was granted (0) or not (!0). If CheckPermissions
//                    wasn't successful this parameter's value is undefined. (write only)
//
//  flags             pass CHECK_PERMISSIONS_WITHOUT_AUDITING to disable audit generation
//
//  hAuthzCtx         (optional) -- pass Authz client context (this is used only in RPC callbacks,
//                    where there is no THSTATE). If hAuthzCtx is passed, then we will not cache
//                    hAuthzAuditInfo in the THSTATE either.
//
// Returns:
//
//   0 if successful. On failure the result of GetLastError() immediately
//   following the unsuccessful win32 api call.
//
{
    THSTATE        *pTHS = pTHStls;
    GENERIC_MAPPING GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK     DesiredAccess = (ACCESS_MASK) ulDesiredAccess;
    DWORD           ReturnStatus = 0;
    BOOL            bTemp=FALSE;
    WCHAR          *pStringW;
    RPC_STATUS      RpcStatus;
    PSID            pPrincipalSelfSid;
    WCHAR           GuidStringBuff[40]; // Long enough for a stringized guid
                                        // plus a prepended "%{", an
                                        // appended "}", and a final NULL.

    AUTHZ_CLIENT_CONTEXT_HANDLE authzClientContext;
    AUTHZ_ACCESS_REQUEST authzAccessRequest;
    AUTHZ_ACCESS_REPLY authzAccessReply;
    AUTHZ_AUDIT_EVENT_HANDLE hAuthzAuditInfo;
    DWORD dwError;
    BOOL bCreatedGrantedAccess = FALSE;

    // pTHS might be NULL when this is called from an RPC callback (VerifyRpcClientIsAuthenticated)
    // in this case we require that authz client context is passed in
    Assert(pAccessStatus && (pTHS || hAuthzCtx) && ghAuthzRM);
    Assert ( (flags | CHECK_PERMISSIONS_FLAG_MASK) == CHECK_PERMISSIONS_FLAG_MASK);

#ifdef DBG
    if( dwSkipSecurity ) {
        // NOTE:  THIS CODE IS HERE FOR DEBUGGING PURPOSES ONLY!!!
        // Set the top access status to 0, implying full access.
        *pAccessStatus=0;
        if (pGrantedAccess) {
            *pGrantedAccess = ulDesiredAccess;
        }

        return 0;
    }
#endif


    Assert(!fNullUuid(&pDN->Guid));

    //
    // Check self relative security descriptor validity
    //
    if (!IsValidSecurityDescriptor(pSelfRelativeSD)) {
        Assert (!"InValid Security Descriptor Passed. Possibly still in SD single instancing format.")
        return ERROR_INVALID_SECURITY_DESCR;
    }

    if(pDN->SidLen) {
        // we have a sid
        pPrincipalSelfSid = &pDN->Sid;
    }
    else {
        pPrincipalSelfSid = NULL;
    }

    // if auditing was requested, create an audit info struct
    if (flags & CHECK_PERMISSIONS_WITHOUT_AUDITING) {
        hAuthzAuditInfo = NULL; // no auditing
    }
    else {
        // Set up the stringized guid
        pStringW = NULL;
        RpcStatus = UuidToStringW( &pDN->Guid, &pStringW );

        if ( RpcStatus == RPC_S_OK ) {
            Assert(pStringW);
            // string guids are 36 characters, right?
            Assert(wcslen(pStringW) == 36);

            GuidStringBuff[0] = L'%';
            GuidStringBuff[1] = L'{';
            memcpy(&GuidStringBuff[2], pStringW, 36 * sizeof(WCHAR));
            GuidStringBuff[38] = L'}';
            GuidStringBuff[39] = 0;

            // Free the GUID
            RpcStringFreeW( &pStringW );
            pStringW = GuidStringBuff;
        }

        if(!pStringW) {
            pStringW = L"Invalid Guid";
        }

        // try to grab audit info handle from THSTATE
        if (pTHS && (hAuthzAuditInfo = pTHS->hAuthzAuditInfo)) {
            // there was one already! update it
            bTemp = AuthziModifyAuditEvent(
                AUTHZ_AUDIT_EVENT_OBJECT_NAME,
                hAuthzAuditInfo,                // audit info handle
                0,                              // no new flags
                NULL,                           // no new operation type
                NULL,                           // no new object type
                pStringW,                       // object name
                NULL                            // no new additional info
                );
            if (!bTemp) {
                ReturnStatus = GetLastError();
                DPRINT1(0, "AuthzModifyAuditInfo failed: err 0x%x\n", ReturnStatus);
                goto finished;
            }
        }
        else {
            // create the structure
            bTemp = AuthzInitializeObjectAccessAuditEvent(
                AUTHZ_DS_CATEGORY_FLAG |
                AUTHZ_NO_ALLOC_STRINGS,         // dwFlags
                NULL,                           // audit event type handle
                AUDIT_OPERATION_TYPE_W,         // operation type
                ACCESS_DS_OBJECT_TYPE_NAME_W,   // object type
                pStringW,                       // object name
                L"",                            // additional info
                &hAuthzAuditInfo,               // audit info handle returned
                0                               // mbz
                );

            if (!bTemp) {
                ReturnStatus = GetLastError();
                DPRINT1(0, "AuthzInitializeAuditInfo failed: err 0x%x\n", ReturnStatus);
                goto finished;
            }
            if (pTHS) {
                // cache it in the THSTATE for future reuse
                pTHS->hAuthzAuditInfo = hAuthzAuditInfo;
            }
        }
    }

    // if pGrantedAccess was not supplied, we need to allocate a temp one
    if (pGrantedAccess == NULL) {
        // if no THSTATE is available, we require that pGrantedAccess is passed in
        Assert(pTHS);
        pGrantedAccess = THAllocEx(pTHS, cObjList * sizeof(ACCESS_MASK));
        bCreatedGrantedAccess = TRUE;
    }

    MapGenericMask(&DesiredAccess, &GenericMapping);

    // set up request struct
    authzAccessRequest.DesiredAccess = DesiredAccess;
    authzAccessRequest.ObjectTypeList = pObjList;
    authzAccessRequest.ObjectTypeListLength = cObjList;
    authzAccessRequest.OptionalArguments = NULL;
    authzAccessRequest.PrincipalSelfSid = pPrincipalSelfSid;

    // set up reply struct
    authzAccessReply.Error = pAccessStatus;
    authzAccessReply.GrantedAccessMask = pGrantedAccess;
    authzAccessReply.ResultListLength = cObjList;
    authzAccessReply.SaclEvaluationResults = NULL;

    if (pTHS) {
        // grab the authz client context from THSTATE
        // if it was never obtained before, this will impersonate the client, grab the token,
        // unimpersonate the client, and then create a new authz client context
        ReturnStatus = GetAuthzContextHandle(pTHS, &authzClientContext);
        if (ReturnStatus != 0) {
            DPRINT1(0, "GetAuthzContextHandle failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }
    else {
        // authz client context was passed in (this is checked by an assert above)
        authzClientContext = hAuthzCtx;
    }

    Assert(authzClientContext != NULL);

    if (pTHS && pTHS->fDeletingTree) {
        // do an audit check only. Access (delete tree) was already granted
        DWORD i;
        for (i = 0; i < cObjList; i++) {
            pGrantedAccess[i] = DesiredAccess;
            pAccessStatus[i] = 0;
        }
        // No additional SDs are passed
        bTemp = AuthzOpenObjectAudit(
            0,                          // flags
            authzClientContext,         // client context handle
            &authzAccessRequest,        // request struct
            hAuthzAuditInfo,            // audit info
            pSelfRelativeSD,            // the SD
            NULL,                       // no additional SDs
            0,                          // zero count of additional SDs
            &authzAccessReply           // reply struct
            );
        if (!bTemp) {
            ReturnStatus = GetLastError();
            DPRINT1(0, "AuthzOpenObjectAudit failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }
    else {
        // Check access of the current process
        // No additional SDs are passed
        bTemp = AuthzAccessCheck(
            0,                          // flags
            authzClientContext,         // client context handle
            &authzAccessRequest,        // request struct
            hAuthzAuditInfo,            // audit info
            pSelfRelativeSD,            // the SD
            NULL,                       // no additional SDs
            0,                          // zero count of additional SDs
            &authzAccessReply,          // reply struct
            NULL                        // we are not using AuthZ handles for now
            );
        if (!bTemp) {
            ReturnStatus = GetLastError();
            DPRINT1(0, "AuthzAccessCheck failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }


finished:
    if (bCreatedGrantedAccess) {
        // note: pGrantedAccess is only created if pTHS is non-null
        THFreeEx(pTHS, pGrantedAccess);
    }
    if (pTHS == NULL && hAuthzAuditInfo) {
        // get rid of the audit info (since we could not cache it in THSTATE)
        AuthzFreeAuditEvent(hAuthzAuditInfo);
    }

    return ReturnStatus;
}

BOOL
SetPrivateObjectSecurityLocalEx (
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pOriginalSD,
        ULONG                cbOriginalSD,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        PSECURITY_DESCRIPTOR *ppNewSD,
        ULONG                AutoInheritFlags,
        PGENERIC_MAPPING     GenericMapping,
        HANDLE               Token)
{
    *ppNewSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbOriginalSD);
    if(!*ppNewSD) {
        return FALSE;
    }
    memcpy(*ppNewSD, pOriginalSD, cbOriginalSD);

    return SetPrivateObjectSecurityEx(
            SecurityInformation,
            ModificationDescriptor,
            ppNewSD,
            AutoInheritFlags,
            GenericMapping,
            Token);
}


DWORD
MergeSecurityDescriptorAnyClient(
        IN  PSECURITY_DESCRIPTOR pParentSD,
        IN  ULONG                cbParentSD,
        IN  PSECURITY_DESCRIPTOR pCreatorSD,
        IN  ULONG                cbCreatorSD,
        IN  SECURITY_INFORMATION SI,
        IN  DWORD                flags,
        IN  GUID                 **ppGuid,
        IN  ULONG                GuidCount,
        OUT PSECURITY_DESCRIPTOR *ppMergedSD,
        OUT ULONG                *cbMergedSD
        )
/*++

Routine Description
    Given two security descriptors, merge them to create a single security
    descriptor.

    Memory is RtlHeapAlloced in the RtlProcessHeap()
Arguments
    pParentSD  - SD of the Parent of the object the new SD applies to.

    pCreatorSD - Beginning SD of the new object.

    flags      - Flag whether pCreatorSD is a default SD or a specific SD
                 supplied by a client.
    ppMergedSD - Place to return the merged SD.

    cbMergedSD - Size of merged SD.

Return Values
    A win32 error code (0 on success, non-zero on fail).

--*/

{

    PSECURITY_DESCRIPTOR NewCreatorSD=NULL;
    DWORD                NewCreatorSDLen;
    PSECURITY_DESCRIPTOR pNewSD;
    ULONG                cbNewSD;
    GENERIC_MAPPING  GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK          DesiredAccess = 0;
    HANDLE               ClientToken=NULL;
    DWORD                ReturnStatus=0;
    ULONG                AutoInheritFlags = (SEF_SACL_AUTO_INHERIT |
                                             SEF_DACL_AUTO_INHERIT    );
    if(!pParentSD){
        if(!pCreatorSD) {
            // They didn't give us ANYTHING to merge.  Well, we can't build a
            // valid security descriptor out of that.
            return ERROR_INVALID_SECURITY_DESCR;
        }

        // We weren't given a parent, so just use the creatorSD.
        if(!IsValidSecurityDescriptor(pCreatorSD)) {
            // Except the creatorSD is mangled.
            return ERROR_INVALID_SECURITY_DESCR;
        }

        *cbMergedSD = cbCreatorSD;
        *ppMergedSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbCreatorSD);
        if(!*ppMergedSD) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy(*ppMergedSD,pCreatorSD,cbCreatorSD);

        if(!(flags & MERGE_OWNER)){
            return 0;
        }

        // NDNCs need to merge the owner and group into the SD, so continue
        // on.  If you continue on this code works correctly, without a
        // ParentSD.  What I believe this code is incorrectly assuming is that
        // if there is a provided CreatorSD and no ParentSD, then the
        // CreatorSD must be a non-domain relative SD.  Note:
        // IsValidSecurityDescriptor() returns TRUE even for a relative SD
        // with no set owner or group (SIDS are 0), this causes the SD to be
        // invalid for access checks later when read by DS.
    }

    //
    // Check self relative security descriptor validity
    //

    if(pCreatorSD &&
       !IsValidSecurityDescriptor(pCreatorSD)) {
        return ERROR_INVALID_SECURITY_DESCR;
    }

    if (pParentSD &&
        !IsValidSecurityDescriptor(pParentSD)){
        return ERROR_INVALID_SECURITY_DESCR;
    }

    if(flags & MERGE_DEFAULT_SD) {
        // It is nonsensical to specify the use of the default SD unless we are
        // doing a CreatePrivateObjectSecurityEx.
        Assert(flags & MERGE_CREATE);
        // We are going to call CreatePrivatObjectSecurityEx.  Set the flags
        // to avoid the privilege check about setting SACLS.  We used to
        // set the SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT flag here as well, but
        // our security architects decided in RAID 337518 that this was not
        // the right behavior, and that we should avoid that flag.  We leave
        // our flag (MERGE_DEFAULT_SD) in place but eliminate its effect in
        // case they later change their minds and ask us to put the flag back.
        AutoInheritFlags |= SEF_AVOID_PRIVILEGE_CHECK;
    }

    if(flags & MERGE_AS_DSA) {
        // We are the DSA, we can't impersonate.
        // Null token if we're doing this on behalf of the DSA.  Since we're
        // doing this on behalf of the DSA, don't check privilges or owners.
        ClientToken = NULL;
        AutoInheritFlags |= (SEF_AVOID_PRIVILEGE_CHECK |
                             SEF_AVOID_OWNER_CHECK      );
        if(flags & MERGE_DEFAULT_SD) {
            // Default SD and working as DSA?  In that case, we're using
            // a NULL ClientToken.  Thus, there is no default to use for the
            // owner and group.  Set the flags to use the parent SD as the
            // source for default Owner and Group.
            AutoInheritFlags |= (SEF_DEFAULT_OWNER_FROM_PARENT |
                                 SEF_DEFAULT_GROUP_FROM_PARENT   );
        }
    }
    else {
        // Only do this if we aren't the DSA.

        // First, impersonate the client.
        if(ReturnStatus = ImpersonateAnyClient()) {
            return ReturnStatus;
        }

        // Now, get the client token.
        if (!OpenThreadToken(
                GetCurrentThread(),         // current thread handle
                TOKEN_READ,                 // access required
                TRUE,                       // open as self
                &ClientToken)) {            // client token
            ReturnStatus = GetLastError();
        }

        // Always stop impersonating.
        UnImpersonateAnyClient();

        // Return if OpenThreadToken failed.
        if(ReturnStatus)
            return ReturnStatus;

        if((flags & MERGE_CREATE) || (SI & OWNER_SECURITY_INFORMATION)) {

            ReturnStatus = SetDomainAdminsAsDefaultOwner(
                    pCreatorSD,
                    cbCreatorSD,
                    ClientToken,
                    &NewCreatorSD,
                    &NewCreatorSDLen);

            if(ReturnStatus) {
                CloseHandle(ClientToken);
                return ReturnStatus;
            }

            if(NewCreatorSDLen) {
                // A new SD was returned from SetDOmainAdminsAsDefaultOwner.
                // Therefore, we MUST have replaced the owner.  In this case, we
                // need to avoid an owner check.
                Assert(NewCreatorSD);
                AutoInheritFlags |= SEF_AVOID_OWNER_CHECK;
                pCreatorSD = NewCreatorSD;
                cbCreatorSD = NewCreatorSDLen;
            }

        }

        // Remember to close the ClientToken.
    }

    if(flags & MERGE_CREATE) {
        // We're actually creating a new SD.  pParent is the SD of the parent
        // object, pCreatorSD is the SD we're trying to put on the object.  The
        // outcome is the new SD with all the inheritable ACEs from the parentSD

        UCHAR RMcontrol = 0;
        BOOL  useRMcontrol = FALSE;
        DWORD err;


        // Get Resource Manager (RM) control field
        err = GetSecurityDescriptorRMControl (pCreatorSD, &RMcontrol);

        if (err == ERROR_SUCCESS) {
            useRMcontrol = TRUE;

            // mask bits in the RM control field that might be garbage
            RMcontrol = RMcontrol & SECURITY_PRIVATE_OBJECT;
        }

        if(!CreatePrivateObjectSecurityWithMultipleInheritance(
                pParentSD,
                pCreatorSD,
                &pNewSD,
                ppGuid,
                GuidCount,
                TRUE,
                AutoInheritFlags,
                ClientToken,
                &GenericMapping)) {
            ReturnStatus = GetLastError();
        }

        // Set back Resource Manager (RM) control field

        if (useRMcontrol && !ReturnStatus) {
            err = SetSecurityDescriptorRMControl  (pNewSD, &RMcontrol);

            if (err != ERROR_SUCCESS) {
                ReturnStatus  = err;
            }

            Assert (err == ERROR_SUCCESS);
        }
#if INCLUDE_UNIT_TESTS
        if ( pParentSD ) {
            DWORD dw = 0;
            DWORD aclErr = 0;
            aclErr = CheckAclInheritance(pParentSD, pNewSD, ppGuid[0],
                                         DbgPrint, FALSE, FALSE, &dw);

            if (! ((AclErrorNone == aclErr) && (0 == dw)) ) {
                DPRINT3 (0, "aclErr:%d, dw:%d, ReturnStatus:%d\n",
                         aclErr, dw, ReturnStatus);
            }
            Assert((AclErrorNone == aclErr) && (0 == dw));
        }
#endif
    }
    else {
        // OK, a normal merge.  That is, pParentSD is the SD already on the
        // object and pCreatorSD is the SD we're trying to put on the object.
        // The result is the new SD combined with those ACEs in the original
        // which were inherited.

        if(!SetPrivateObjectSecurityLocalEx (
                SI,
                pParentSD,
                cbParentSD,
                pCreatorSD,
                &pNewSD,
                AutoInheritFlags,
                &GenericMapping,
                ClientToken)) {
            ReturnStatus = GetLastError();
            if(!ReturnStatus) {
                ReturnStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if(!(flags & MERGE_AS_DSA)) {
        // We opened the token, so clean up.
        CloseHandle(ClientToken);
    }


    if(!ReturnStatus) {
        *cbMergedSD = RtlLengthSecurityDescriptor(pNewSD);
        *ppMergedSD = pNewSD;
    }

    if(NewCreatorSD) {
        RtlFreeHeap(RtlProcessHeap(),0,NewCreatorSD);
    }

    return ReturnStatus;

}

BOOL
IAmWhoISayIAm (
        PSID pSid,
        DWORD cbSid
        )
{
    THSTATE              *pTHS = pTHStls;
    DWORD                ReturnStatus=0;
    HANDLE               ClientToken=NULL;
    PTOKEN_USER          TokenUserInfo = NULL;
    ULONG                TokenUserInfoSize;
    PSID                 UserSid;
    BOOL                 fSame = TRUE;

    //
    // Impersonate the client while we check him out.
    //
    if ( ImpersonateAnyClient() )
    {
        return FALSE;
    }

    //
    // Compare the username specified with that in
    // the impersonation token to ensure the caller isn't bogus.
    //
    // Do this by opening the token,
    //   querying the token user info,
    //   and ensuring the returned SID is for this user.
    //

    if (!OpenThreadToken(
            GetCurrentThread(),         // current thread handle
            TOKEN_QUERY,                 // access required
            TRUE,                       // open as self
            &ClientToken)) {            // client token
        // Yes, this assert has a side effect.  We just want to assert
        // that something should have failed, and try to compute the
        // error code so that we can debug the problem.
        Assert(ReturnStatus = GetLastError());
        fSame = FALSE;
        goto CleanUp;
    }

    //
    // Get the user's SID for the token.
    //

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            &TokenUserInfo,
            0,
            &TokenUserInfoSize);

    if(ReturnStatus != STATUS_BUFFER_TOO_SMALL) {
        // We expected to be told how big a buffer we needed and we weren't
        fSame = FALSE;
        goto CleanUp;
    }

    TokenUserInfo = THAlloc(TokenUserInfoSize);

    if(!TokenUserInfo) {
        // Couldn't get any memory to hold the tokenuserinfo.  Bail
        fSame = FALSE;
        goto CleanUp;
    }

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            TokenUserInfo,
            TokenUserInfoSize,
            &TokenUserInfoSize );
    if(NT_ERROR(ReturnStatus)) {
        fSame = FALSE;
        goto CleanUp;
    }

    UserSid = TokenUserInfo->User.Sid;

    // If the UserSid matches the sid passed in, we fine
    fSame = RtlEqualSid(UserSid, pSid);

    //
    // Done
    //
CleanUp:
    if (TokenUserInfo) {
        THFreeEx(pTHS,TokenUserInfo);
    }
    CloseHandle(ClientToken);
    UnImpersonateAnyClient();

    return fSame;
}


VOID
DumpToken(HANDLE hdlClientToken)
/*++

    This Routine Currently Dumps out the Group Membership
    Information in the Token to the Kernel Debugger. Useful
    if We Want to Debug Access Check related Problems.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE   ClientToken= INVALID_HANDLE_VALUE;
    ULONG    i;
    ULONG    RequiredLength=0;

    KdPrint(("----------- Start DumpToken() -----------\n"));

    //
    // Get the client token
    //

    ClientToken = hdlClientToken;

    if (ClientToken == INVALID_HANDLE_VALUE) {
        NtStatus = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,            //OpenAsSelf
                    &ClientToken
                    );

        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }


    //
    // Query the Client Token For the Token User
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenUser,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_USER    pTokenUser = NULL;
        UNICODE_STRING TmpString;


        //
        // Allocate enough memory
        //

        pTokenUser = THAlloc(RequiredLength);
        if (NULL==pTokenUser)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenUser,
                    pTokenUser,
                    RequiredLength,
                    &RequiredLength
                    );

        NtStatus = RtlConvertSidToUnicodeString(
                        &TmpString,
                        pTokenUser->User.Sid,
                        TRUE);

       if (NT_SUCCESS(NtStatus))
       {
           KdPrint(("\t\tTokenUser SID: %S\n",TmpString.Buffer));
           RtlFreeHeap(RtlProcessHeap(),0,TmpString.Buffer);
       }

    }

    //
    // Query the Client Token For the group membership list
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenGroups,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_GROUPS    TokenGroupInformation = NULL;

        //
        // Allocate enough memory
        //

        TokenGroupInformation = THAlloc(RequiredLength);
        if (NULL==TokenGroupInformation)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenGroups,
                    TokenGroupInformation,
                    RequiredLength,
                    &RequiredLength
                    );

       for (i=0;i<TokenGroupInformation->GroupCount;i++)
       {
           UNICODE_STRING TmpString;
           NtStatus = RtlConvertSidToUnicodeString(
                        &TmpString,
                        TokenGroupInformation->Groups[i].Sid,
                        TRUE);

           if (NT_SUCCESS(NtStatus))
           {
               KdPrint(("\t\t%S\n",TmpString.Buffer));
               RtlFreeHeap(RtlProcessHeap(),0,TmpString.Buffer);
           }
       }
    }


    //
    // Query the Client Token for the privileges in the token
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenPrivileges,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_PRIVILEGES    pTokenPrivileges = NULL;

        //
        // Allocate enough memory
        //

        pTokenPrivileges = THAlloc(RequiredLength);
        if (NULL==pTokenPrivileges)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenPrivileges,
                    pTokenPrivileges,
                    RequiredLength,
                    &RequiredLength
                    );

        //
        // Print the token privileges to the debugger
        //
        PrintPrivileges(pTokenPrivileges);
    }

Error:

    if (INVALID_HANDLE_VALUE!=ClientToken && hdlClientToken == INVALID_HANDLE_VALUE)
        NtClose(ClientToken);

    KdPrint(("----------- End   DumpToken() -----------\n"));

}

VOID
PrintPrivileges(TOKEN_PRIVILEGES *pTokenPrivileges)
{
    ULONG i = 0;

    KdPrint(("\t\tToken Privileges count: %d\n", pTokenPrivileges->PrivilegeCount));

    for (i = 0; i < pTokenPrivileges->PrivilegeCount; i++)
    {
        // print the privilege attribute
        char strTemp[100];
        BOOL fUnknownPrivilege = FALSE;

        strcpy(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) ? "+" : "-");
        strcat(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? " d" : "  ");
        strcat(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS) ? "u  " : "   ");

        fUnknownPrivilege = FALSE;
        if (pTokenPrivileges->Privileges[i].Luid.HighPart)
        {
            fUnknownPrivilege = TRUE;
        }
        else
        {
            switch (pTokenPrivileges->Privileges[i].Luid.LowPart)
            {
            case SE_CREATE_TOKEN_PRIVILEGE:
                strcat(strTemp, "SeCreateTokenPrivilege\n");
                break;

            case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
                strcat(strTemp, "SeAssignPrimaryTokenPrivilege\n");
                break;

            case SE_LOCK_MEMORY_PRIVILEGE:
                strcat(strTemp, "SeLockMemoryPrivilege\n");
                break;

            case SE_INCREASE_QUOTA_PRIVILEGE:
                strcat(strTemp, "SeIncreaseQuotaPrivilege\n");
                break;

            case SE_UNSOLICITED_INPUT_PRIVILEGE:
                strcat(strTemp, "SeUnsolicitedInputPrivilege\n");
                break;

            case SE_TCB_PRIVILEGE:
                strcat(strTemp, "SeTcbPrivilege\n");
                break;

            case SE_SECURITY_PRIVILEGE:
                strcat(strTemp, "SeSecurityPrivilege\n");
                break;

            case SE_TAKE_OWNERSHIP_PRIVILEGE:
                strcat(strTemp, "SeTakeOwnershipPrivilege\n");
                break;

            case SE_LOAD_DRIVER_PRIVILEGE:
                strcat(strTemp, "SeLoadDriverPrivilege\n");
                break;

            case SE_SYSTEM_PROFILE_PRIVILEGE:
                strcat(strTemp, "SeSystemProfilePrivilege\n");
                break;

            case SE_SYSTEMTIME_PRIVILEGE:
                strcat(strTemp, "SeSystemtimePrivilege\n");
                break;

            case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
                strcat(strTemp, "SeProfileSingleProcessPrivilege\n");
                break;

            case SE_INC_BASE_PRIORITY_PRIVILEGE:
                strcat(strTemp, "SeIncreaseBasePriorityPrivilege\n");
                break;

            case SE_CREATE_PAGEFILE_PRIVILEGE:
                strcat(strTemp, "SeCreatePagefilePrivilege\n");
                break;

            case SE_CREATE_PERMANENT_PRIVILEGE:
                strcat(strTemp, "SeCreatePermanentPrivilege\n");
                break;

            case SE_BACKUP_PRIVILEGE:
                strcat(strTemp, "SeBackupPrivilege\n");
                break;

            case SE_RESTORE_PRIVILEGE:
                strcat(strTemp, "SeRestorePrivilege\n");
                break;

            case SE_SHUTDOWN_PRIVILEGE:
                strcat(strTemp, "SeShutdownPrivilege\n");
                break;

            case SE_DEBUG_PRIVILEGE:
                strcat(strTemp, "SeDebugPrivilege\n");
                break;

            case SE_AUDIT_PRIVILEGE:
                strcat(strTemp, "SeAuditPrivilege\n");
                break;

            case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
                strcat(strTemp, "SeSystemEnvironmentPrivilege\n");
                break;

            case SE_CHANGE_NOTIFY_PRIVILEGE:
                strcat(strTemp, "SeChangeNotifyPrivilege\n");
                break;

            case SE_REMOTE_SHUTDOWN_PRIVILEGE:
                strcat(strTemp, "SeRemoteShutdownPrivilege\n");
                break;

            default:
                fUnknownPrivilege = TRUE;
                break;
            }

            if (fUnknownPrivilege)
            {
                KdPrint(("\t\t%s Unknown privilege 0x%08lx%08lx\n",
                        strTemp,
                        pTokenPrivileges->Privileges[i].Luid.HighPart,
                        pTokenPrivileges->Privileges[i].Luid.LowPart));
            }
            else
            {
                KdPrint(("\t\t%s", strTemp));
            }
        }
    }
}





DWORD
InitializeDomainAdminSid( )
//
// Function to initialize the DomainAdminsSid.
//
//
// Return Value:     0 on success
//                   Error on failure
//

{

    NTSTATUS                    Status;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
    PSID                        pDomainAdminSid = NULL;

    NTSTATUS    NtStatus, IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;
    PSID        pSid;

    //
    // it is already initialized, we don't have to do it anymore.
    //
    if(gpDomainAdminSid != NULL)
        return STATUS_SUCCESS;

    //
    // Get the Domain SID
    //

    if (gfRunningInsideLsa) {

        Status = LsaIQueryInformationPolicyTrusted(
                PolicyPrimaryDomainInformation,
                (PLSAPR_POLICY_INFORMATION *)&PrimaryDomainInfo
                );

        if(!NT_SUCCESS(Status)) {
            LogUnhandledError(Status);
            return Status;
        }

        pSid = PrimaryDomainInfo->Sid;

    }
    else {

        READARG     ReadArg;
        READRES     *pReadRes;
        ENTINFSEL   EntInf;
        ATTR        objectSid;
        DWORD       dwErr;

        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
        EntInf.AttrTypBlock.attrCount = 1;
        RtlZeroMemory(&objectSid,sizeof(ATTR));
        objectSid.attrTyp = ATT_OBJECT_SID;
        EntInf.AttrTypBlock.pAttr = &objectSid;

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        InitCommarg(&(ReadArg.CommArg));

        ReadArg.pObject = gAnchor.pRootDomainDN;
        ReadArg.pSel    = & EntInf;

        dwErr = DirRead(&ReadArg,&pReadRes);

        if (dwErr)
        {
            DPRINT1 (0, "Error reading objectSid from %ws\n", gAnchor.pRootDomainDN->StringName);
            Status = dwErr;
            goto End;
        }

        pSid = pReadRes->entry.AttrBlock.pAttr->AttrVal.pAVal->pVal;
    }

    //
    // Calculate the size of the new sid
    //

    AccountSubAuthorityCount =
        *RtlSubAuthorityCountSid(pSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //

    pDomainAdminSid = RtlAllocateHeap(RtlProcessHeap(), 0, AccountSidLength);

    if (!pDomainAdminSid) {
        LogUnhandledError(STATUS_INSUFFICIENT_RESOURCES);
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        //
        // Copy the domain sid into the first part of the account sid
        //

        Status = RtlCopySid(AccountSidLength, pDomainAdminSid,
                            pSid);

        if ( NT_SUCCESS(Status) ) {

            //
            // Increment the account sid sub-authority count
            //

            *RtlSubAuthorityCountSid(pDomainAdminSid) =
                                                AccountSubAuthorityCount;

            //
            // Add the rid as the final sub-authority
            //

            RidLocation = RtlSubAuthoritySid(pDomainAdminSid,
                                             AccountSubAuthorityCount-1);
            *RidLocation = DOMAIN_GROUP_RID_ADMINS;

            gpDomainAdminSid = pDomainAdminSid;
        }
    }

End:
    if (gfRunningInsideLsa) {
        LsaFreeMemory( PrimaryDomainInfo );
    }

    return Status;
}


//
//  CreatorSD and ClientToken must not be NULL
//  NewCreatorSD gets allocated here.
//

DWORD
SetDomainAdminsAsDefaultOwner(
        IN  PSECURITY_DESCRIPTOR    CreatorSD,
        IN  ULONG                   cbCreatorSD,
        IN  HANDLE                  ClientToken,
        OUT PSECURITY_DESCRIPTOR    *NewCreatorSD,
        OUT PULONG                  NewCreatorSDLen
        )
{
    PTOKEN_GROUPS   Groups = NULL;
    DWORD           ReturnedLength;
    DWORD           retCode = ERROR_NOT_ENOUGH_MEMORY;
    BOOL            Defaulted;
    DWORD           i;
    PSECURITY_DESCRIPTOR    AbsoluteSD = NULL;
    DWORD           AbsoluteSDLen = 0;
    PACL            Dacl = NULL;
    DWORD           DaclLen = 0;
    PACL            Sacl = NULL;
    DWORD           SaclLen = 0;
    DWORD           OwnerLen = 0;
    PSID            Group = NULL;
    DWORD           GroupLen = 0;
    BOOL            fReplaced;

    *NewCreatorSD = NULL;
    *NewCreatorSDLen = 0;


    // Find out how much memory to allocate.
    MakeAbsoluteSD(CreatorSD, AbsoluteSD, &AbsoluteSDLen,
                   Dacl, &DaclLen, Sacl, &SaclLen,
                   NULL, &OwnerLen, Group, &GroupLen
                   );

    if(OwnerLen || !gfRunningInsideLsa) {
        // The SD already has an owner, so we don't actually need to do any
        // magic here.  Or we're in dsamain.exe and wish to avoid calls
        // calls to LSA.  Return success with no new SD.
        return 0;
    }

    // OK, we are definitely going to be doing some replacement in the SD.

    __try {
        //
        // First I have to convert the self-relative SD to
        // absolute SD
        //

        AbsoluteSD = RtlAllocateHeap(RtlProcessHeap(), 0, AbsoluteSDLen);
        Dacl = RtlAllocateHeap(RtlProcessHeap(), 0, DaclLen);
        Sacl = RtlAllocateHeap(RtlProcessHeap(), 0, SaclLen);
        Group = RtlAllocateHeap(RtlProcessHeap(), 0, GroupLen);

        if(!AbsoluteSD ||  !Dacl || !Sacl || !Group) {
            // Memory allocation error, fail
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        if(!MakeAbsoluteSD(CreatorSD, AbsoluteSD, &AbsoluteSDLen,
                           Dacl, &DaclLen, Sacl, &SaclLen,
                           NULL, &OwnerLen, Group, &GroupLen)) {
            retCode = GetLastError();
            __leave;
        }

        Assert(!OwnerLen);


        //
        // Domain Admins can't be TokenUser so just get TokenGroups
        //
        GetTokenInformation(ClientToken, TokenGroups, Groups,
                            0,
                            &ReturnedLength
                            );

        //
        // Let's really get the groups, now :-)
        //
        Groups = RtlAllocateHeap(RtlProcessHeap(), 0, ReturnedLength);
        if(!Groups) {
            // Memory allocation error, fail;
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        if(!GetTokenInformation(ClientToken, TokenGroups, Groups,
                                ReturnedLength,
                                &ReturnedLength
                                )) {
            retCode = GetLastError();
            __leave;
        }

        fReplaced = FALSE;
        retCode = 0;
        for(i=0;i<Groups->GroupCount;i++) {
            if(EqualSid(Groups->Groups[i].Sid, gpDomainAdminSid)) {
                //
                // OK, we found it. Set it as the Owner in AbsoluteSD
                //
                fReplaced = TRUE;
                if(!SetSecurityDescriptorOwner(
                        AbsoluteSD,
                        gpDomainAdminSid,
                        TRUE
                        )) {
                    retCode = GetLastError();
                    __leave;
                }
                break;
            }
        }

        Assert(!retCode);

        if(!fReplaced) {
            // Hey, we didn't actually do any replacement.  Dont bother with
            // turning the AbsoluteSD back, since it would be a no-op.  By
            // leaving here, we return with a successful error code, and a null
            // pointer for the newSD, which is exactly the same thing we would
            // have done had the incoming SD had an owner in the first place.
            __leave;
        }

        //
        // Convert the AbsoluteSD back to SelfRelative and return that in the
        // NewCreatorSD.
        //

        MakeSelfRelativeSD(AbsoluteSD, *NewCreatorSD, NewCreatorSDLen);

        *NewCreatorSD = RtlAllocateHeap(RtlProcessHeap(), 0, *NewCreatorSDLen);

        if(!(*NewCreatorSD)) {
            // Memory allocation error, fail
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        if(!MakeSelfRelativeSD(AbsoluteSD, *NewCreatorSD, NewCreatorSDLen)) {
            retCode = GetLastError();
        }

    }
    __finally {
        if(AbsoluteSD) {
            RtlFreeHeap(RtlProcessHeap(), 0, AbsoluteSD);
        }
        if(Dacl) {
            RtlFreeHeap(RtlProcessHeap(), 0, Dacl);
        }
        if(Sacl) {
            RtlFreeHeap(RtlProcessHeap(), 0, Sacl);
        }
        if(Group) {
            RtlFreeHeap(RtlProcessHeap(), 0, Group);
        }
        if(Groups) {
            RtlFreeHeap(RtlProcessHeap(), 0,Groups);
        }
        if(retCode && (*NewCreatorSD)) {
            RtlFreeHeap(RtlProcessHeap(), 0,(*NewCreatorSD));
        }
    }

    return retCode;
}



//
// CheckPrivilegesAnyClient impersonates the client and then checks to see if
// the requested privilege is held.  It is assumed that a client is impersonable
// (i.e. not doing this strictly on behalf of an internal DSA thread)
//
DWORD
CheckPrivilegeAnyClient(
        IN DWORD privilege,
        OUT BOOL *pResult
        )
{
    DWORD    dwError=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls;
    AUTHZ_CLIENT_CONTEXT_HANDLE authzClientContext;
    DWORD dwBufSize;
    PTOKEN_PRIVILEGES pTokenPrivileges = NULL;
    BOOL bSuccess;
    DWORD i;

#ifdef DBG
    if( dwSkipSecurity ) {
        // NOTE:  THIS CODE IS HERE FOR DEBUGGING PURPOSES ONLY!!!
        // Set the top access status to 0, implying full access.
        *pResult=TRUE;
        return 0;
    }
#endif

    // assume privilege not granted
    *pResult = FALSE;

    // now, grab the authz client context
    // if it was never obtained before, this will impersonate the client, grab the token,
    // unimpersonate the client, and then create a new authz client context
    dwError = GetAuthzContextHandle(pTHS, &authzClientContext);
    if (dwError != 0) {
        goto finished;
    }

    // now we can check the privelege for the authz context
    // first, grab the buffer size...
    bSuccess = AuthzGetInformationFromContext(
        authzClientContext,             // context handle
        AuthzContextInfoPrivileges,     // requesting priveleges
        0,                              // no buffer yet
        &dwBufSize,                     // need to find buffer size
        NULL                            // buffer
        );
    // must return ERROR_INSUFFICIENT_BUFFER! if not, return error
    if (bSuccess) {
        DPRINT1(0, "AuthzGetInformationFromContext returned success, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
        DPRINT2(0, "AuthzGetInformationFromContext returned %d, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", dwError, ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    dwError = 0; // need to reset it to OK now

    // no buffer, nothing to do...
    if (dwBufSize == 0) {
        Assert(!"AuthzGetInformationFromContext says it needs zero-length buffer, weird... Let AuthZ people know. This assert is ignorable");
        goto finished;
    }

    // allocate memory
    pTokenPrivileges = THAllocEx(pTHS, dwBufSize);

    // now get the real privileges...
    bSuccess = AuthzGetInformationFromContext(
        authzClientContext,             // context handle
        AuthzContextInfoPrivileges,     // requesting priveleges
        dwBufSize,                      // and here is its size
        &dwBufSize,                     // just in case
        pTokenPrivileges                // now there is a buffer
        );
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0, "AuthzGetInformationFromContext failed, err=%d\n", dwError);
        goto finished;
    }

    // now, scan the privileges
    for (i = 0; i < pTokenPrivileges->PrivilegeCount; i++) {
        if (pTokenPrivileges->Privileges[i].Luid.HighPart == 0 &&
            pTokenPrivileges->Privileges[i].Luid.LowPart == privilege) {
            // found matching privilege!
            *pResult = (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) != 0;
            break;
        }
    }
finished:
    // release memory
    if (pTokenPrivileges) {
        THFreeEx(pTHS, pTokenPrivileges);
    }
    return dwError;
}

DWORD
GetPlaceholderNCSD(
    IN  THSTATE *               pTHS,
    OUT PSECURITY_DESCRIPTOR *  ppSD,
    OUT DWORD *                 pcbSD
    )
/*++

Routine Description:

    Return the default security descriptor for a placeholder NC.

Arguments:

    pTHS (IN)

    ppSD (OUT) - On successful return, holds a pointer to the thread-allocated
        SD.

    pcbSD (OUT) - On successful return, holds the size in bytes of the SD.

Return Values:

    0 or Win32 error.

--*/
{
    CLASSCACHE *            pCC;
    SECURITY_DESCRIPTOR *   pSDAbs = NULL;
    DWORD                   cbSDAbs = 0;
    ACL *                   pDACL = NULL;
    DWORD                   cbDACL = 0;
    ACL *                   pSACL = NULL;
    DWORD                   cbSACL = 0;
    SID *                   pOwner = NULL;
    DWORD                   cbOwner = 0;
    SID *                   pGroup = NULL;
    DWORD                   cbGroup = 0;
    SID *                   pDomAdmin;
    DWORD                   err;

    // Use the default SD for the domainDNS objectClass as a template.
    // Note that this SD has no owner or group.

    pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
    Assert(NULL != pCC);

    //
    // PREFIX: PREFIX complains that pCC returned by the call to SCGetClassById
    // is not checked for NULL.  This is not a bug as we pass a predefined constant
    // to SCGetClassById guaranteeing that it will not return NULL.
    //

    // Crack the self-relative SD into absolute format and set the owner
    // and group to (our) domain admins.

    MakeAbsoluteSD(pCC->pSD, NULL, &cbSDAbs, NULL, &cbDACL, NULL,
                   &cbSACL, NULL, &cbOwner, NULL, &cbGroup);

    if (cbSDAbs) pSDAbs = THAllocEx(pTHS, cbSDAbs);
    if (cbDACL ) pDACL  = THAllocEx(pTHS, cbDACL );
    if (cbSACL ) pSACL  = THAllocEx(pTHS, cbSACL );
    if (cbOwner) pOwner = THAllocEx(pTHS, cbOwner);
    if (cbGroup) pGroup = THAllocEx(pTHS, cbGroup);

    // PREFIX: dereferencing NULL pointer pOwner, pDACL, pSACL, pGroup
    //         these are not referenced when the corresponding cbOwner, cbDACL, cbSACL, cbGroup are 0

    if (!MakeAbsoluteSD(pCC->pSD, pSDAbs, &cbSDAbs, pDACL, &cbDACL, pSACL,
                        &cbSACL, pOwner, &cbOwner, pGroup, &cbGroup)
        || !SetSecurityDescriptorOwner(pSDAbs, gpDomainAdminSid, FALSE)
        || !SetSecurityDescriptorGroup(pSDAbs, gpDomainAdminSid, FALSE)) {
        err = GetLastError();
        DPRINT1(0, "Unable to crack/modify default SD, error %d.\n", err);
        return err;
    }

    // Convert back to a self-relative SD.
    *pcbSD = 0;
    MakeSelfRelativeSD(pSDAbs, NULL, pcbSD);
    if (*pcbSD) {
        *ppSD = THAllocEx(pTHS, *pcbSD);
    }

    if (!MakeSelfRelativeSD(pSDAbs, *ppSD, pcbSD)) {
        err = GetLastError();
        DPRINT1(0, "Unable to convert SD, error %d.\n", err);
        return err;
    }

    if (pSDAbs) THFreeEx(pTHS, pSDAbs);
    if (pDACL ) THFreeEx(pTHS, pDACL );
    if (pSACL ) THFreeEx(pTHS, pSACL );
    if (pOwner) THFreeEx(pTHS, pOwner);
    if (pGroup) THFreeEx(pTHS, pGroup);

    return 0;
}

LUID aLUID = {0, 0}; // a fake LUID to pass into AuthzInitializeContextFromToken
                     // maybe one day we will start using them...

DWORD
VerifyRpcClientIsAuthenticatedUser(
    VOID            *Context,
    GUID            *InterfaceUuid
    )
/*++

  Description:

    Verifies that an RPC client is an authenticated user and not, for
    example, NULL session.

  Arguments:

    Context - Caller context handle defined by RPC_IF_CALLBACK_FN.

    InterfaceUuid - RPC interface ID.  Access check routines typically need
        the GUID/SID of the object against which access is being checked.
        In this case, there is no real object being checked against.  But
        we need a GUID for auditing purposes.  Since the check is for RPC
        interface access, the convention is to provide the IID of the RPC
        interface.  Thus the audit log entries for failed interface access
        can be discriminated from other entries.

  Returns:

    0 on success, !0 otherwise

--*/
{
    // The correct functioning of this routine can be tested as follows.
    // We note that:
    //
    //  1) crack.exe allows specification of the SPN
    //  2) programs invoked by at.exe run as local system by default
    //  3) an invalid SPN in conjunction with weak domain security settings
    //     causes negotiation to drop down to NTLM
    //
    // Thus, all one needs to do is make a script which calls crack.exe with
    // an invalid SPN and invoke it via at.exe from a joined workstation.
    // Do not provide explicit credentials in the crack.exe arguments.

    extern PSECURITY_DESCRIPTOR pAuthUserSD;
    extern DWORD                cbAuthUserSD;
    DWORD                       dwErr;
    DSNAME                      dsName;
    ACCESS_MASK                 grantedAccess = 0;
    DWORD                       accessStatus = 0;
    OBJECT_TYPE_LIST            objTypeList;
    AUTHZ_CLIENT_CONTEXT_HANDLE authzCtx;

    // Caller must provide a valid Interface UIID.
    Assert(!fNullUuid(InterfaceUuid));

    Assert(RtlValidSecurityDescriptor(pAuthUserSD));

    if (ghAuthzRM == NULL) {
        // must be before we had a chance to startup or after it has already shut down.
        // just say not allowed...
        return ERROR_NOT_AUTHENTICATED;
    }

    // create authz client context from RPC security context
    if (dwErr = RpcGetAuthorizationContextForClient(
                    Context,        // binding context
                    FALSE,          // don't impersonate
                    NULL,           // expiration time
                    NULL,           // LUID
                    aLUID,          // reserved
                    0,              // another reserved
                    NULL,           // one more reserved
                    &authzCtx       // authz context goes here
                    )) {
        return dwErr;
    }

    __try {
        // For auditing, construct DSNAME whose GUID is the interface ID.
        memset(&dsName, 0, sizeof(dsName));
        memcpy(&dsName.Guid, InterfaceUuid, sizeof(GUID));
        dsName.structLen = DSNameSizeFromLen(0);

        // Create OBJECT_TYPE_LIST to test object access.  The GUID referenced
        // for object level checking is immaterial, so we use InterfaceUuid.
        memset(&objTypeList, 0, sizeof(objTypeList));
        objTypeList.Level = ACCESS_OBJECT_GUID;
        objTypeList.ObjectType = InterfaceUuid;

        // Check access against well known, constant SD which grants
        // read property access to authenticated users.
        dwErr =  CheckPermissionsAnyClient(
                    pAuthUserSD,
                    &dsName,
                    ACTRL_DS_READ_PROP,
                    &objTypeList,
                    1,
                    &grantedAccess,
                    &accessStatus,
                    0,
                    authzCtx);

        if ( dwErr ) {
            __leave;
        }

        if ( accessStatus || (ACTRL_DS_READ_PROP != grantedAccess) ) {
            dwErr = ERROR_NOT_AUTHENTICATED;
        }
    }
    __finally {
        RpcFreeAuthorizationContext(&authzCtx);
    }

    return(dwErr);
}

/*
 * AuthZ-related routines
 */

/*
 * global RM handle
 */
AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzRM = NULL;

DWORD
InitializeAuthzResourceManager()
/*++
  Description:

    Initialize AuthzRM handle

  Returns:

    0 on success, !0 on failure

--*/
{
    DWORD dwError;
    BOOL bSuccess;

    // create the RM handle
    // all callbacks are NULLs
    bSuccess = AuthzInitializeResourceManager(
                    0,                  // flags
                    NULL,               // access check fn
                    NULL,               // compute dynamic groups fn
                    NULL,               // free dynamic groups fn
                    ACCESS_DS_SOURCE_W, // RM name
                    &ghAuthzRM          // return value
                    );

    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0,"Error from AuthzInitializeResourceManager: %d\n", dwError);
        return dwError;
    }
    Assert(ghAuthzRM);

    // all is fine!
    return 0;
}

DWORD
ReleaseAuthzResourceManager()
/*++
  Description:

    Release Authz RM handles

  Returns:

    0 on success, !0 on failure

--*/
{
    DWORD dwError;
    BOOL bSuccess;

    if (ghAuthzRM == NULL) {
        return 0;
    }

    bSuccess = AuthzFreeResourceManager(ghAuthzRM);
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0,"Error from AuthzFreeResourceManager: %d\n", dwError);
        return dwError;
    }

    ghAuthzRM = NULL;
    return 0;
}

PAUTHZ_CLIENT_CONTEXT
NewAuthzClientContext()
/*++
  Description:

    create a new client context

  Returns:

    ptr to the new CLIENT_CONTEXT or NULL if an error occured
--*/
{
    PAUTHZ_CLIENT_CONTEXT result;
    // allocate a new structure
    result = (PAUTHZ_CLIENT_CONTEXT) malloc(sizeof(AUTHZ_CLIENT_CONTEXT));
    if (result) {
        result->lRefCount = 0;
        result->hAuthzContext = NULL;
    }
    return result;
}

VOID AssignAuthzClientContext(
    IN PAUTHZ_CLIENT_CONTEXT *var,
    IN PAUTHZ_CLIENT_CONTEXT value
    )
/*++
  Description:

    Does a refcounted assignment of a CLIENT_CONTEXT
    Will decrement the prev value (if any) and increment the new value (if any)
    If the prev value's refCount is zero, then it will get destroyed.

  Arguments:

    var -- variable to be assigned
    value -- value to be assigned to the variable

  Note:
    on refcounting in a multithreaded environment:

    THIS WILL ONLY WORK IF EVERYBODY IS USING AssignAuthzClientContext TO WORK WITH
    AUTHZ CLIENT CONTEXT INSTANCES!

    assuming nobody is cheating and every reference to the context is counted. Then if the
    refcount goes down to zero, we can be sure that no other thread holds a reference to
    the context that it can assign to a variable. Thus, we are sure that once the refcount
    goes down to zero, we can safely destroy the context. This is because nobody else
    holds a reference to the context, thus, nobody can use it.

--*/
{
    PAUTHZ_CLIENT_CONTEXT prevValue;

    Assert(var);

    prevValue = *var;
    if (prevValue == value) {
        return; // no change!
    }

    if (prevValue != NULL) {
        Assert(prevValue->lRefCount > 0);

        // need to decrement the prev value
        if (InterlockedDecrement(&prevValue->lRefCount) == 0) {
            // no more refs -- release the context!
            if (prevValue->hAuthzContext != NULL) {
                AuthzFreeContext(prevValue->hAuthzContext);
            }
            free(prevValue);
        }
    }

    // now, we can assign the new value to the variable (the value might be NULL!)
    *var = value;

    if (value != NULL) {
        // need to increment the refcount
        InterlockedIncrement(&value->lRefCount);
    }
}

DWORD
GetAuthzContextHandle(
    IN THSTATE *pTHS,
    OUT AUTHZ_CLIENT_CONTEXT_HANDLE *phAuthzContext
    )
/*++
  Description:

    gets AuthzContext from CLIENT_CONTEXT. If the context has not yet been allocated
    then the client will get impersonated, token grabbed and Authz context created.
    Then the client is unimpersonated again.

  Arguments:

    pTHS -- thread state
    phAuthzContext -- result, handle contained in pAuthzCC

  Returns:

    0 on success, !0 otherwise
--*/
{
    DWORD   dwError = 0;
    HANDLE  hClientToken = INVALID_HANDLE_VALUE;
    PAUTHZ_CLIENT_CONTEXT pLocalCC = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE newContext;
    BOOL bSuccess;

    Assert(pTHS && phAuthzContext && ghAuthzRM);

    // check that the thread state contains a client context. If not, create one
    if (pTHS->pAuthzCC == NULL) {
        AssignAuthzClientContext(&pTHS->pAuthzCC, NewAuthzClientContext());
        if (pTHS->pAuthzCC == NULL) {
            // what -- no context still??? must be out of memory...
            return ERROR_OUTOFMEMORY;
        }
    }

    // grab the authz handle that sits in the pCC struct
    if ((*phAuthzContext = pTHS->pAuthzCC->hAuthzContext) == NULL) {
        // authz context handle has not yet been created! get it.

        // NOTE: This code is NOT protected by a critical section.
        // in a (rare) case that two threads will come here and find an uninitialized AuthzContext,
        // they both will create it. However, they will not be able to write it into the struct
        // simultaneously since it is protected by an InterlockedCompareExchangePointer.
        // The thread that loses will destroy its context.

        // we need to hold on to the pAuthzCC ptr (refcount it!) because it will get
        // thrown away from the thread state by Impersonate/Unimpersonate
        AssignAuthzClientContext(&pLocalCC, pTHS->pAuthzCC);

        __try {
            // need to grab clientToken first
            if ((dwError = ImpersonateAnyClient()) != 0)
                __leave;

            // Now, get the client token.
            if (!OpenThreadToken(
                    GetCurrentThread(),        // current thread handle
                    TOKEN_READ,                // access required
                    TRUE,                      // open as self
                    &hClientToken)) {          // client token

                dwError =  GetLastError();                  // grab the error code

                DPRINT1 (0, "Failed to open thread token for current thread: 0x%x\n", dwError);
                Assert (!"Failed to open thread token for current thread");
            }

            UnImpersonateAnyClient();

            // now, put the pLocalCC back into the THSTATE (because it has been
            // removed from there by impersonate/unimpersonate calls)
            AssignAuthzClientContext(&pTHS->pAuthzCC, pLocalCC);

            if (dwError != 0)
                __leave;

            // Dump Token for Debugging
            if (TEST_ERROR_FLAG(NTDSERRFLAG_DUMP_TOKEN))
            {
                DPRINT(0, "GetAuthzContextHandle: got client token\n");
                DumpToken(hClientToken);
            }

            // now we can create the authz context from the token
            bSuccess = AuthzInitializeContextFromToken(
                            0,              // flags
                            hClientToken,   // client token
                            ghAuthzRM,      // global RM handle
                            NULL,           // expiration time (unsupported anyway)
                            aLUID,          // LUID for the context (not used)
                            NULL,           // dynamic groups
                            &newContext     // new context
                            );

            if (!bSuccess) {
                dwError = GetLastError();
                DPRINT1(0, "Error from AuthzInitializeContextFromToken: %d\n", dwError);
                __leave;
            }

            // now perform an InterlockedCompareExchangePointer to put the new
            // value into the context variable
            if (InterlockedCompareExchangePointer(
                    &pTHS->pAuthzCC->hAuthzContext,
                    newContext,
                    NULL
                    ) != NULL) {
                // this thread lost! assignment did not happen. Got to get rid of the context
                DPRINT(0, "This thread lost in InterlockedCompareExchange, releasing the duplicate context\n");
                AuthzFreeContext(newContext);
            }
            // assign the result to the out parameter
            *phAuthzContext = pTHS->pAuthzCC->hAuthzContext;
        }
        __finally {
            // we need to release the local ptr
            AssignAuthzClientContext(&pLocalCC, NULL);
            // and get rid of the token
            if (hClientToken != INVALID_HANDLE_VALUE) {
                CloseHandle(hClientToken);
            }
        }

    }
    return dwError;
}

DWORD
CheckGroupMembershipAnyClient(
    IN THSTATE *pTHS,
    IN PSID groupSid,
    OUT BOOL *bResult
    )
/*++

  Description:

    Verify if the caller is a member of a group

  Arguments:

    pTHS (IN) - Thread state

    groupSid  - group to check

    bResult   - boolean to recieve the result

  Return Value:

    0 on success, !0 on error

--*/

{
    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext;
    BOOL                        bSuccess;
    PTOKEN_GROUPS               pGroups = NULL;
    DWORD                       dwBufSize;
    DWORD                       i;
    DWORD                       dwError;

    Assert(pTHS && groupSid && bResult);

    dwError = 0;
    *bResult = FALSE;

    // grab the authz client context
    // if it was never obtained before, this will impersonate the client, grab the token,
    // unimpersonate the client, and then create a new authz client context from the token
    dwError = GetAuthzContextHandle(pTHS, &hAuthzClientContext);
    if (dwError != 0) {
        goto finished;
    }

    //
    // grab groups from the AuthzContext
    // But first get the size required
    //
    bSuccess = AuthzGetInformationFromContext(
        hAuthzClientContext,            // client context
        AuthzContextInfoGroupsSids,     // requested groups
        0,                              // no buffer yet
        &dwBufSize,                     // required size
        NULL                            // buffer
        );
    // must return ERROR_INSUFFICIENT_BUFFER! if not, return error
    if (bSuccess) {
        DPRINT1(0, "AuthzGetInformationFromContext returned success, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
        DPRINT2(0, "AuthzGetInformationFromContext returned %d, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", dwError, ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    dwError = 0; // need to reset it to OK now

    // no buffer, nothing to do...
    if (dwBufSize == 0) {
        Assert(!"AuthzGetInformationFromContext says it needs zero-length buffer, weird... Let AuthZ people know. This assert is ignorable");
        goto finished;
    }

    // allocate memory
    pGroups = THAllocEx(pTHS, dwBufSize);

    // now get the real groups...
    bSuccess = AuthzGetInformationFromContext(
        hAuthzClientContext,           // context handle
        AuthzContextInfoGroupsSids,    // requesting groups
        dwBufSize,                     // and here is its size
        &dwBufSize,                    // just in case
        pGroups                        // now there is a buffer
        );
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0, "AuthzGetInformationFromContext failed, err=%d\n", dwError);
        goto finished;
    }


    for (i = 0; i < pGroups->GroupCount; i++) {
        if (RtlEqualSid(groupSid, pGroups->Groups[i].Sid)) {
            *bResult = TRUE; // found group!
            break;
        }
    }

finished:
    //
    // clean up
    //
    if (pGroups) {
        THFreeEx(pTHS, pGroups);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\refcount.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       refcount.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <sddl.h>               // ConvertStringSecurityDescriptor...()

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <drs.h>
#include <filtypes.h>
#include <winsock2.h>
#include <lmaccess.h>                   // UF_* constants
#include <crypt.h>                      // password encryption routines
#include <cracknam.h>

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsconfig.h>
#include <gcverify.h>
#include <ntdskcc.h>

// SAM interoperability headers
#include <mappings.h>
#include <samsrvp.h>            // for SampAcquireWriteLock()
#include <lmaccess.h>           // UF_ACCOUNT_TYPE_MASK

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#define DEBSUB "REFCOUNT:"      // define the subsystem for debugging

// DRA headers.
#include <drameta.h>

#include <fileno.h>
#define  FILENO FILENO_LOOPBACK

#ifdef INCLUDE_UNIT_TESTS

// Exported from dbsubj.c.
extern GUID gLastGuidUsedToCoalescePhantoms;
extern GUID gLastGuidUsedToRenamePhantom;

// Note, these variables have the OPPOSITE name from what they really are.
// This is compensated for in Get/Remove/Add Property
ATTRTYP gLinkedAttrTyp = ATT_FSMO_ROLE_OWNER;
ATTRTYP gNonLinkedAttrTyp = ATT_MANAGER;

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Prototypes for routines from which to construct various tests.   //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
NewTest(
    CHAR            *TestName);

void
ReportTest(
    CHAR            *TestName);

typedef enum PropertyType {
    LinkedProperty,
    NonLinkedProperty
} PropertyType;

void
AddObject(
    DSNAME          *Name);

void
AddCrossRef(
    DSNAME  *pObject,
    DSNAME  *pNcName,
    LPWSTR   pszDnsRoot
    );

void
ModifyCrossRef(
    DSNAME  *pObject
    );

void
AddPropertyHost(
    DSNAME          *Name,
    PropertyType    type);

void
CommonAddObject(
    DSNAME  *pObject,
    ATTRTYP  ObjectClass);

void
AddProperty(
    DSNAME          *HostName, 
    DSNAME          *LinkedObjectName,
    PropertyType    type);

void
RemoveProperty(
    DSNAME          *HostName, 
    DSNAME          *LinkedObjectName,
    PropertyType    type);

DSNAME *
GetProperty(
    DSNAME *     pdnHost, 
    DWORD        iValue,
    PropertyType type);

DSNAME *
GetObjectName(
    DSNAME * pdn);

void
LogicallyDeleteObject(
    DSNAME          *Name);

void
PhysicallyDeleteObjectEx(
        DSNAME          *Name,
        DWORD           dwLine);

#define PhysicallyDeleteObject(a) PhysicallyDeleteObjectEx(a, __LINE__);

#define MakeObjectName(RDN) MakeObjectNameEx(RDN,TestRoot)
    
DSNAME *
MakeObjectNameEx(
    CHAR    *RDN,
    DSNAME  *pdnParent);

DSNAME *
MakeObjectNameEx2(
    CHAR    *RDN,
    DSNAME  *pdnParent);

DSNAME *
MakeObjectNameEx3(
    CHAR    *RDN
    );

void
FreeObjectName(
    DSNAME  *pDSName);

#define REAL_OBJECT         1
#define TOMBSTONE           2
#define PHANTOM             3
#define DOESNT_EXIST        4

void
VerifyStringNameEx(
        DSNAME *pObject,
        DWORD dwLine);

#define VerifyStringName(a) VerifyStringNameEx(a, __LINE__);

void
VerifyRefCountEx(
    DSNAME          *pObject, 
    DWORD           ObjectType, 
    DWORD           ExpectedRefCount,
    DWORD           dwLine);

#define VerifyRefCount(a,b,c) VerifyRefCountEx(a,b,c,__LINE__)

DWORD
GetTestRootRefCount();

void
_Fail(
    CHAR    *msg,
    DWORD   line);

#define Fail(msg) _Fail(msg, __LINE__);

#define DSNAME_SAME_STRING_NAME(a,b)                    \
    ((NULL != (a)) && (NULL != (b))                     \
     && !lstrcmpW((a)->StringName, (b)->StringName))

#define DSNAME_SAME_GUID_SID(a,b)                       \
    ((NULL != (a)) && (NULL != (b))                     \
     && !memcmp(&(a)->Guid, &(b)->Guid, sizeof(GUID))   \
     && ((a)->SidLen == (b)->SidLen)                    \
     && !memcmp(&(a)->Sid, &(b)->Sid, (a)->SidLen))

#define DSNAME_IDENTICAL(a,b) \
    (DSNAME_SAME_STRING_NAME(a,b) && DSNAME_SAME_GUID_SID(a,b))


//////////////////////////////////////////////////////////////////////
//                                                                  //
// Globals                                                          //
//                                                                  //
//////////////////////////////////////////////////////////////////////

#define TEST_ROOT_SIZE 2048
CHAR    TestRootBuffer[TEST_ROOT_SIZE];
DSNAME  *TestRoot = (DSNAME *) TestRootBuffer;
BOOL    fTestPassed;
BOOL    fVerbose = FALSE;

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Reference counting test routines.                                //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
ParentChildRefCountTest(void)
{
    DWORD   cRefsInitial;
    DSNAME *pdnObject = MakeObjectName("object");

    // This routine verifies that adding a child addref's the parent, 
    // and remocing the child deref's the parent.

    NewTest("ParentChildRefCountTest");

    cRefsInitial = GetTestRootRefCount();
    
    AddObject(pdnObject);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    if ( (cRefsInitial + 1) != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on AddObject");
    }

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // The logical deletion moved the object, so the refcount has dropped.
    if ( (cRefsInitial) != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on LogicallyDeleteObject");
    }

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    if ( cRefsInitial != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on PhysicallyDeleteObject");
    }

    FreeObjectName(pdnObject);

    ReportTest("ParentChildRefCountTest");
}

void
ObjectCleaningRefCountTest(void)
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *pdnObject = MakeObjectName("object");
    DWORD err;

    // This routine verifies that marking an object for cleaning addref's
    // the object, and that unmarking an object for cleaning deref's
    // the object.

    NewTest("ObjectCleaningRefCountTest");

    // Object has one reference for its own name
    AddObject(pdnObject);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);


    // Add a reference for the cleaning flag
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnObject);
        if (err) Fail("Can't find Object");

        DBSetObjectNeedsCleaning( pTHS->pDB, 1 );

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Object");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnObject, REAL_OBJECT, 2);


    // Remove a reference for the cleaning flag
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnObject);
        if (err) Fail("Can't find Object");

        DBSetObjectNeedsCleaning( pTHS->pDB, 0 );

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Object");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Delete the object
    // Ref count stays the same
    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnObject);

    ReportTest("ObjectCleaningRefCountTest");
}

void
AttributeTestForRealObject(
    PropertyType    type)
{
    THSTATE     *pTHS = pTHStls;
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForRealObject(LinkedProperty)");
    else
        NewTest("AttributeTestForRealObject(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);






    // Linked value replication specific part of test
    // Remove a value that does not exist
    // Replicator should be able to create a value in the absent state.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Remove a property that does not exist
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        RemoveProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Remove of non-existing property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to create value in absent state
        pTHS->fDRA = TRUE;
        RemoveProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Add "object" as the value of a property on "host".
    // For a linked value, this will have the effect of making the
    // absent value present, but the count will not change

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Remove "object" as the value of a property on "host".
        
    RemoveProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if (type == LinkedProperty) {
        if (pTHS->fLinkedValueReplication) {
            // When a linked value is "removed", it is made absent. It disappears
            // off the index, but is actually still present for ref-counting
            // purposes. The absent value still holds a reference to the object
            // to which it refers. The ref-count is actually decremented when
            // 1. The hosting object is deleted (forward link clean up)
            // 2. The target object is deleted (backward link clean up)
            // 3. Absent link value gargage collection, after a tombstone lifetime
            VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        } else {
            VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        }
    } else {
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    }

    // Linked value replication specific part of test
    // Remove a value that is already absent
    // Replicator should be able to touch a value,
    // changing only its metadata.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Remove a property that is already absent
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        RemoveProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Re-remove of existing absent property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to touch existing value
        pTHS->fDRA = TRUE;
        RemoveProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Re-Add "object" as the value of a property on "host".
    // For a linked attribute, the value already exists in absent form.
    // Test making it present without changing the count.

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Linked value replication specific part of test
    // Add a value that is alreay present
    // Replicator should be able to touch a value,
    // changing only its metadata.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Add a property that is already present
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        AddProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Re-add of existing present property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to touch existing value
        pTHS->fDRA = TRUE;
        AddProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Remove "object" as the value of a property on "host".
        
    RemoveProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if (type == LinkedProperty) {
        if (pTHS->fLinkedValueReplication) {
            // When a linked value is "removed", it is made absent. It disappears
            // off the index, but is actually still present for ref-counting
            // purposes. The absent value still holds a reference to the object
            // to which it refers. The ref-count is actually decremented when
            // 1. The hosting object is deleted (forward link clean up)
            // 2. The target object is deleted (backward link clean up)
            // 3. Absent link value gargage collection, after a tombstone lifetime
            VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        } else {
            VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        }
    } else {
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    }

    // Logically delete "object".
    // The following is true for non-linked attributes or linked attributes
    // when not running in linked value replication mode:
    // At this point in time, there
    // should be no relationship between "host" and "object".  So
    // the only effect is that "object" becomes a tombstone which
    // retains its refcount for itself.
    // For link value replication, host still holds an absent value
    // referring to object, and host has a ref-count on object. When
    // object is tombstoned, its forward and backward links are cleaned up
    // (see DBRemoveLinks), and the ref-count is removed.
    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // Physically delete "object".  Again, no effect on "host".

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Logically delete "host".

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Physically delete "host".

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);


    // For a non-linked attribute, verify that deleting a referent DOES NOT
    // reduce the reference count
    if (type == NonLinkedProperty) {
        VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Add "host" object which will host the property value.
        AddPropertyHost(pdnHost, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Add "object" object which will be the property value.
        AddObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        // Add "object" as the value of a property on "host".
        AddProperty(pdnHost, pdnObject, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        // Logically delete "object".
        LogicallyDeleteObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, TOMBSTONE, 2);
        // Remove "object" as the value of a property on "host".
        RemoveProperty(pdnHost, pdnObject, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
        // Physically delete "object".  Again, no effect on "host".
        PhysicallyDeleteObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Logically delete "host".
        LogicallyDeleteObject(pdnHost);
        VerifyRefCount(pdnHost, TOMBSTONE, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Physically delete "host".
        PhysicallyDeleteObject(pdnHost);
        VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    }


    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForRealObject(LinkedProperty)");
    else
        ReportTest("AttributeTestForRealObject(NonLinkedProperty)");
}

void
AttributeTestForDeletedObject(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForDeletedObject(LinkedProperty)");
    else
        NewTest("AttributeTestForDeletedObject(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Add "object" as the value of a property on "host".

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "object".  Logical deletion strips all linked
    // attributes.  So in the linked case, "object" will get deref'd.
    // In the non-linked case, the tombstone for "object" retains the ref
    // count representing the fact that is referenced by a property on "host".

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
    else
        VerifyRefCount(pdnObject, TOMBSTONE, 2);

    // Physically delete "object".  In the linked attribute case, 
    // "object" and "host" already have no relationship, thus "host" 
    // is unchanged and "object" can lose its refcount for itself.
    // In the non-linked case, "object" still has a reference back to
    // "host", thus it cannot really be deleted yet.  Instead, it
    // is morphed to a phantom, maintains the reference from "host", but
    // loses its refcount for itself.
    
    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 1);

    // Logically delete "host" such that it becomes a tombstone.  In 
    // both cases, "object" loses its reference to "host" as both
    // gLinkedAttrTyp and gNonLinkedAttrTyp are stripped on deletion.

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "host".  This derefs "object" since it still
    // refers to "host" which brings its refcount down to zero - but the
    // phantom still exists pending physical deletion.
    
    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "object", if it still exists.  "object" should
    // really disappear now since it has no refcount at all any more.

    if ( LinkedProperty != type )
        PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForDeletedObject(LinkedProperty)");
    else
        ReportTest("AttributeTestForDeletedObject(NonLinkedProperty)");
}

void
AttributeTestForDeletedHost(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForDeletedHost(LinkedProperty)");
    else
        NewTest("AttributeTestForDeletedHost(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Add "object" as the value of a property on "host".

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "host".  Logical deletion strips both gLinkedAttrTyp
    // and gNonLinkedAttrTyp.  Therefore "object" will get deref'd in both
    // the linked and non-linked case.

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    else
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Physically delete "host".  In the linked attribute case, 
    // "object" and "host" already have no relationship, , thus
    // "host" disappears and "object" stays as is.  In the non-linked
    // case, "object" holds a reference from "host" which is removed
    // when "host" is physically deleted.  Thus "object" is deref'd
    // by 1.

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Logically delete "object". "object" and "host" have no relationship
    // at this point in either the linked or non-linked case, thus "host"
    // stays the same and "object" becomes a tombstone.

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // Physically delete "object".  "object" and "host" have no relationship
    // thus "object" is removed for real.

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForDeletedHost(LinkedProperty)");
    else
        ReportTest("AttributeTestForDeletedHost(NonLinkedProperty)");
}

void
PhantomPromotionDemotionTest(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("PhantomPromotionDemotionTest(LinkedProperty)");
    else
        NewTest("PhantomPromotionDemotionTest(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.  We bypass
    // GC verification of a DSNAME'd attribute value thereby insuring
    // that "object" is created as a phantom. Since "object" is a phantom
    // it doesn't have a reference for itself, thus it always has a refcount
    // of 1.

    DsaSetIsInstalling();
    AddProperty(pdnHost, pdnObject, type);
    DsaSetIsRunning();
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, PHANTOM, 1);

    // Promote "object" from phantom to a real object.  Do this by adding
    // a real object with the same name.  "object" now gets a refcount for
    // itself as well.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "object".  This should result in a phantom whose
    // refcount reflects whether this was a linked attribute or not.

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
    else
        VerifyRefCount(pdnObject, TOMBSTONE, 2);

    // Physically delete "object".  In the linked attribute case, "object"
    // and "host" have no relationship at this point in time because linked
    // attributes were stripped during logical deletion.  Thus "object"
    // really goes away.  In the non-linked case, "object" still has a 
    // reference from "host", thus it turns into a phantom.
    
    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 1);

    // Logically delete "host".

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "host".  In neither the linked nor non-linked
    // case does "host" have a reference from "object", so it goes away
    // for real.  In the linked case, "object" has no reference from "host"
    // so it stays the same.  In the non-linked case, the physical
    // delete of "host" deref's all objects it references, thus
    // "object" is deref'd by 1.

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "object", if it still exists.  Neither "host" nor
    // "object" references the other at this point in time, so "object"
    // disappears for real.

    if ( LinkedProperty != type )
        PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("PhantomPromotionDemotionTest(LinkedProperty)");
    else
        ReportTest("PhantomPromotionDemotionTest(NonLinkedProperty)");
}

void
PhantomRenameOnPromotionTest(void)
/*++

Routine Description:

    Refcounting is based on GUID, if one is available, as is phantom promotion.
    Therefore, it's possible that between the time a phantom is created and
    if/when it's promoted to the corresponding real object that it has been
    renamed or moved.

    This test stresses this code path by first creating a phantom with string
    name S1 and GUID G, then instantiating the real object S2 with GUID G.
    The result should be that the DNT created for the phantom S1 is promoted to
    the real object and is simultaneously renamed to S2.

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnContainer;
    DSNAME *    pdnRef;
    DSNAME *    pdnRefUnderContainer;
    DSNAME *    pdnHost;
    DWORD       err;

    NewTest("PhantomRenameOnPromotionTest");

    pdnContainer = MakeObjectNameEx( "Container", TestRoot );
    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnRef = MakeObjectNameEx( "Ref", TestRoot );
    pdnRefUnderContainer = MakeObjectNameEx( "RefUnderContainer", pdnContainer);

    DsUuidCreate( &pdnRef->Guid );
    pdnRefUnderContainer->Guid = pdnRef->Guid;


    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = RefUnderContainer
    //  |
    //  |--Container
    //      |
    //      |--RefUnderContainer {Phantom}

    CommonAddObject( pdnContainer, CLASS_CONTAINER );
    AddPropertyHost( pdnHost, NonLinkedProperty );

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gLinkedAttrTyp,
                           pdnRefUnderContainer->structLen,
                           pdnRefUnderContainer );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnRefUnderContainer, PHANTOM, 1 );


    // Rename RefUnderContainer to Ref, and change its parent to TestRoot, all
    // in the context of promoting it from a phantom to a real object.  The
    // resulting structure should be the following:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = Ref
    //  |
    //  |--Container
    //  |
    //  |--Ref

    AddObject( pdnRef );

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 1 );

    memset( &pdnRef->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRef, REAL_OBJECT, 2 );

    memset( &pdnRefUnderContainer->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainer, DOESNT_EXIST, 0 );


    // Remove our test objects.

    LogicallyDeleteObject( pdnHost );
    LogicallyDeleteObject( pdnContainer );
    LogicallyDeleteObject( pdnRef );

    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnContainer );
    PhysicallyDeleteObject( pdnRef );


    FreeObjectName( pdnHost );
    FreeObjectName( pdnContainer );
    FreeObjectName( pdnRef );
    FreeObjectName( pdnRefUnderContainer);

    ReportTest("PhantomRenameOnPromotionTest");
}

void
PhantomRenameOnPhantomRDNConflict(void)
/*++

Routine Description:
    When we are trying to add a phantom A under parent B, 
    and there is an existing structural phantom C (no guid) under
    parent B with the same RDN as A but different RDNType,
    we should rename C (mangle) using a random guid.
    
    This unit test exersises this code path (in CheckNameForAdd).

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnContainer;
    DSNAME *    pdnRefUnderSubContainer;
    DSNAME *    pdnRefUnderContainer;
    DSNAME *    pdnRefUnderContainerOld;
    DSNAME *    pdnHost;
    DWORD       err;
    WCHAR       szMangledRefUnderContainer[MAX_RDN_SIZE] = L"RefUnderContainer";
    DWORD       cchMangledRefUnderContainer = wcslen(szMangledRefUnderContainer);
    DWORD       cb;

    NewTest("PhantomRenameOnPhantomRDNConflict");

    pdnContainer = MakeObjectNameEx2( "OU=Container", TestRoot );
    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnRefUnderContainerOld = MakeObjectNameEx( "RefUnderContainer", pdnContainer);
    pdnRefUnderSubContainer = MakeObjectNameEx2( "CN=RefUnderSubContainer,CN=RefUnderContainer", pdnContainer);
    pdnRefUnderContainer = MakeObjectNameEx2( "OU=RefUnderContainer", pdnContainer);

    DsUuidCreate( &pdnRefUnderContainer->Guid );
    DsUuidCreate( &pdnRefUnderSubContainer->Guid );

    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = CN=RefUnderSubContainer
    //  |
    //  |--OU=Container
    //      |
    //      |--CN=RefUnderContainer            {Phantom}
    //           |
    //           |--CN=RefUnderSubContainer {Phantom}

    CommonAddObject( pdnContainer, CLASS_ORGANIZATIONAL_UNIT );
    AddPropertyHost( pdnHost, NonLinkedProperty );

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gLinkedAttrTyp,
                           pdnRefUnderSubContainer->structLen,
                           pdnRefUnderSubContainer );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnRefUnderContainerOld, PHANTOM, 1 );
    VerifyRefCount( pdnRefUnderSubContainer, PHANTOM, 1 );

    // now add OU=RefUnderContainer 
    // the resulting structure should be the following:
    // 
    //  |--OU=Container
    //      |
    //      |--OU=RefUnderContainer
    //      |
    //      |--CN=RefUnderContainer#CNF:GUID       {Phantom}
    //           |
    //           |--CN=RefUnderSubContainer        {Phantom}

    CommonAddObject(pdnRefUnderContainer, CLASS_ORGANIZATIONAL_UNIT);

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );

    // this is the new object (OU)
    VerifyStringName( pdnRefUnderContainer );
    memset( &pdnRefUnderContainer->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainer, REAL_OBJECT, 1 );

    // this is the old object (was renamed)
    memset( &pdnRefUnderContainerOld->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainerOld, DOESNT_EXIST, 0 );
    
    // Reconstruct the munged name of pdnRefUnderContainerOld using the guid exported
    // from mdadd.c specifically for our test.
    // (This test hook exists only #ifdef INCLUDE_UNIT_TESTS on DBG builds.)
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &gLastGuidUsedToRenamePhantom, 
              szMangledRefUnderContainer, 
              &cchMangledRefUnderContainer);

    cb = pdnRefUnderContainerOld->structLen + 100;
    pdnRefUnderContainerOld = THReAllocEx(pTHStls, pdnRefUnderContainerOld, cb);
    AppendRDN(pdnContainer, 
              pdnRefUnderContainerOld, 
              cb, 
              szMangledRefUnderContainer, 
              cchMangledRefUnderContainer,
              ATT_COMMON_NAME);
    
    DPRINT1 (3, "Renamed object: %ws\n", pdnRefUnderContainerOld->StringName);

    VerifyRefCount( pdnRefUnderContainerOld, PHANTOM, 1 );


    // Remove our test objects. These operations are order dependent,
    // since some phantoms don't have a guid, 
    // so they have to be removed first

    PhysicallyDeleteObject( pdnRefUnderContainerOld );

    LogicallyDeleteObject( pdnHost );
    LogicallyDeleteObject( pdnRefUnderContainer );
    LogicallyDeleteObject( pdnContainer );

    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnRefUnderSubContainer );
    PhysicallyDeleteObject( pdnRefUnderContainer );
    PhysicallyDeleteObject( pdnContainer );

    FreeObjectName( pdnHost );
    FreeObjectName( pdnContainer );
    FreeObjectName( pdnRefUnderSubContainer );
    FreeObjectName( pdnRefUnderContainer );
    FreeObjectName( pdnRefUnderContainerOld );

    ReportTest("PhantomRenameOnPhantomRDNConflict");
}




void
NestedTransactionEscrowedUpdateTest(void)
{
#define NUM_NESTED_XACTS ( 6 )
    THSTATE *   pTHS = pTHStls;
    CHAR        szHost[] = "Host#";
    DSNAME *    rgpdnHost[ NUM_NESTED_XACTS ];
    DBPOS *     rgpDB[ NUM_NESTED_XACTS ] = { 0 };
    DSNAME *    pdnObject;
    DWORD       err;
    DWORD       cRef = 1;
    int         iXactLevel;
    BOOL        fCommit;

    NewTest( "NestedTransactionEscrowedUpdateTest" );

    // Create 8 HostN's.
    for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
    {
        szHost[ strlen( "Host" ) ] = (char)('0' + iXactLevel);

        rgpdnHost[ iXactLevel ] = MakeObjectNameEx( szHost, TestRoot );
        VerifyRefCount( rgpdnHost[ iXactLevel ], DOESNT_EXIST, 0 );

        AddPropertyHost( rgpdnHost[ iXactLevel ], NonLinkedProperty );
        VerifyRefCount( rgpdnHost[ iXactLevel ], REAL_OBJECT, 1 );
    }

    // Create Object.
    pdnObject = MakeObjectNameEx( "Object", TestRoot );
    VerifyRefCount( pdnObject, DOESNT_EXIST, 0 );

    AddObject( pdnObject );
    VerifyRefCount( pdnObject, REAL_OBJECT, 1 );

    srand((unsigned int) time(NULL));

    __try
    {
        SYNC_TRANS_WRITE();

        __try
        {
            // Open nested transactions, top to bottom.  In each transaction,
            // add a reference to Object.

            for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
            {
                if ( iXactLevel )
                {
                    DBOpen( &rgpDB[ iXactLevel ] );
                }
                else
                {
                    rgpDB[ iXactLevel ] = pTHS->pDB;
                }

                err = DBFindDSName( rgpDB[ iXactLevel ],
                                    rgpdnHost[ iXactLevel ] );
                if ( err ) Fail( "Can't find host" );

                err = DBAddAttVal( rgpDB[ iXactLevel ], gLinkedAttrTyp,
                                   pdnObject->structLen, pdnObject );
                if ( err ) Fail( "Can't add reference" );

                err = DBRepl( rgpDB[ iXactLevel ], FALSE, 0, NULL, META_STANDARD_PROCESSING );
                if ( err ) Fail( "Can't replace host" );
            }

            // Close the nested transactions, bottom to top, randomly committing
            // or aborting them.

            for ( iXactLevel = NUM_NESTED_XACTS - 1;
                  iXactLevel > -1;
                  iXactLevel--
                )
            {
                fCommit = rand() > RAND_MAX / 4;

                if ( iXactLevel )
                {
                    err = DBClose( rgpDB[ iXactLevel ], fCommit );

                    if ( err )
                    {
                        Fail( "DBClose() failed" );
                    }
                    else
                    {
                        rgpDB[ iXactLevel ] = NULL;
                    }
                }

                // If we abort, we abort all the transactions beneath us, too,
                // implying the refcount on Objectdrops back to 1 (the single
                // refcount for its own ATT_OBJ_DISTNAME).

                cRef = fCommit ? cRef+1 : 1;

                DPRINT3( 3, "%s level %d, cRef = %d.\n",
                         fCommit ? "Commit" : "Abort", iXactLevel,
                         cRef );
            }
        }
        __finally
        {
            CLEAN_BEFORE_RETURN( !fCommit );
            rgpDB[ 0 ] = NULL;
        }

        VerifyRefCount( pdnObject, REAL_OBJECT, cRef );
        for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
        {
            VerifyRefCount( rgpdnHost[ iXactLevel ], REAL_OBJECT, 1 );

            LogicallyDeleteObject( rgpdnHost[ iXactLevel ] );
            VerifyRefCount( rgpdnHost[ iXactLevel ], TOMBSTONE, 1 );

            PhysicallyDeleteObject( rgpdnHost[ iXactLevel ] );
            VerifyRefCount( rgpdnHost[ iXactLevel ], DOESNT_EXIST, 0 );

            FreeObjectName( rgpdnHost[ iXactLevel ] );
        }

        LogicallyDeleteObject( pdnObject );
        VerifyRefCount( pdnObject, TOMBSTONE, 1 );

        PhysicallyDeleteObject( pdnObject );
        VerifyRefCount( pdnObject, DOESNT_EXIST, 0 );

        FreeObjectName( pdnObject );
    }
    __finally
    {
        for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
        {
            if ( NULL != rgpDB[ iXactLevel ] )
            {
                DPRINT1( 0, "Forcing level %d pDB closed...\n", iXactLevel );

                DBClose( rgpDB[ iXactLevel ], FALSE );

                DPRINT1( 0, "...level %d pDB closed successfully.\n",
                         iXactLevel );
            }
        }
    }

    ReportTest( "NestedTransactionEscrowedUpdateTest" );
}

void NameCollisionTest(void)
/*++

Routine Description:

    This test exercises the name collision handling code.

    Name collisions occur when we're adding a reference to an object
    with a GUID, but when adding that reference we determine that there
    already exists an object or phantom with the same string name but a
    different GUID (hence referring to a different object).

    Unfortunately we're confined to guarantee uniqueness of string names,
    so at least one of the names must be changed to allow the reference to
    be added.

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnHost;
    DSNAME *    pdnCurrRef1;
    DSNAME *    pdnCurrRef2;
    DWORD       err;
    DWORD       iPassForRef1Object;
    DWORD       iPassToAddObject;
    DWORD       iPass;
    DSNAME *    pdnObj;
    DSNAME *    pdnPhantom;
    DSNAME *    pdnCurrObj;
    DSNAME *    pdnCurrPhantom;

    NewTest("NameCollisionTest");

    pdnHost = MakeObjectNameEx("Host", TestRoot);
    pdnRef1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRef2 = MakeObjectNameEx("Ref", TestRoot);

    // Ref1 and Ref2 have the same string name, but different GUIDs.
    DsUuidCreate(&pdnRef1->Guid);
    DsUuidCreate(&pdnRef2->Guid);

    // Create host object.
    AddPropertyHost(pdnHost, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add Ref1 and Ref2 references and make sure the last one added (i.e.,
    // Ref2) "wins" the string name.

    // Add reference to Ref1.
    AddProperty(pdnHost, pdnRef1, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add reference to Ref2.
    AddProperty(pdnHost, pdnRef2, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    pdnCurrRef1 = GetProperty(pdnHost, 1, NonLinkedProperty);
    pdnCurrRef2 = GetProperty(pdnHost, 2, NonLinkedProperty);

    if (DSNAME_SAME_STRING_NAME(pdnCurrRef1, pdnCurrRef2))
        Fail("String names identical!");
    if (!DSNAME_SAME_GUID_SID(pdnCurrRef1, pdnRef1))
        Fail("GUID/SID of ref 1 incorrect!");
    if (!DSNAME_IDENTICAL(pdnCurrRef2, pdnRef2))
        Fail("Ref 2 changed!");

    // Remove Ref1 reference.
    RemoveProperty(pdnHost, pdnRef1, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 0);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Remove Ref2 reference.
    RemoveProperty(pdnHost, pdnRef2, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 0);
    VerifyRefCount(pdnRef2, PHANTOM, 0);

    // Remove ref phantoms.
    PhysicallyDeleteObject(pdnRef1);
    PhysicallyDeleteObject(pdnRef2);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add object and phantom with same string name but different GUIDs and make
    // sure that the object always "wins" the string name.  Add Ref1 and Ref2
    // in different orders and each taking turns as to who is the phantom and
    // who is the object.

    for (iPassForRef1Object = 0; iPassForRef1Object < 2; iPassForRef1Object++) {
        if (iPassForRef1Object) {
            pdnObj = pdnRef2;
            pdnPhantom = pdnRef1;
        }
        else {
            pdnObj = pdnRef1;
            pdnPhantom = pdnRef2;
        }

        for (iPassToAddObject = 0; iPassToAddObject < 2; iPassToAddObject++) {
            for (iPass = 0; iPass < 2; iPass++) {
                if (iPass == iPassToAddObject) {
                    AddObject(pdnObj);
                }
                else {
                    AddProperty(pdnHost, pdnPhantom, NonLinkedProperty);
                }
            }

            pdnCurrPhantom = GetProperty(pdnHost, 1, NonLinkedProperty);
            pdnCurrObj = GetObjectName(pdnObj);

            if (!DSNAME_IDENTICAL(pdnCurrObj, pdnObj)) 
                Fail("Object name changed!");
            if (!DSNAME_SAME_GUID_SID(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom name has different GUID/SID!");
            if (DSNAME_SAME_STRING_NAME(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom string name not changed!");

            FreeObjectName(pdnCurrPhantom);
            FreeObjectName(pdnCurrObj);

            RemoveProperty(pdnHost, pdnPhantom, NonLinkedProperty);
            LogicallyDeleteObject(pdnObj);

            PhysicallyDeleteObject(pdnObj);
            PhysicallyDeleteObject(pdnPhantom);

            VerifyRefCount(pdnHost, REAL_OBJECT, 1);
            VerifyRefCount(pdnObj, DOESNT_EXIST, 0);
            VerifyRefCount(pdnPhantom, DOESNT_EXIST, 0);
        }
    }

    // Add Ref1 and Ref2 references (in both orders), then promote one to a real
    // object.  Make sure that the promoted phantom "wins" the string name.

    for (iPassForRef1Object = 0; iPassForRef1Object < 2; iPassForRef1Object++) {
        if (iPassForRef1Object) {
            pdnObj = pdnRef2;
            pdnPhantom = pdnRef1;
        }
        else {
            pdnObj = pdnRef1;
            pdnPhantom = pdnRef2;
        }

        for (iPassToAddObject = 0; iPassToAddObject < 2; iPassToAddObject++) {
            for (iPass = 0; iPass < 2; iPass++) {
                if (iPass == iPassToAddObject) {
                    AddProperty(pdnHost, pdnObj, NonLinkedProperty);
                }
                else {
                    AddProperty(pdnHost, pdnPhantom, NonLinkedProperty);
                }
            }

            AddObject(pdnObj);

            pdnCurrRef1 = GetProperty(pdnHost, 1, NonLinkedProperty);
            pdnCurrRef2 = GetProperty(pdnHost, 2, NonLinkedProperty);
            pdnCurrObj = GetObjectName(pdnObj);

            if (DSNAME_IDENTICAL(pdnCurrRef1, pdnObj))
                pdnCurrPhantom = pdnCurrRef2;
            else if (DSNAME_IDENTICAL(pdnCurrRef2, pdnObj))
                pdnCurrPhantom = pdnCurrRef1;
            else
                Fail("Object name changed!");

            if (!DSNAME_SAME_GUID_SID(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom name has different GUID/SID!");
            if (DSNAME_SAME_STRING_NAME(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom string name not changed!");

            FreeObjectName(pdnCurrPhantom);
            FreeObjectName(pdnCurrObj);

            RemoveProperty(pdnHost, pdnPhantom, NonLinkedProperty);
            RemoveProperty(pdnHost, pdnObj, NonLinkedProperty);
            LogicallyDeleteObject(pdnObj);

            PhysicallyDeleteObject(pdnObj);
            PhysicallyDeleteObject(pdnPhantom);

            VerifyRefCount(pdnHost, REAL_OBJECT, 1);
            VerifyRefCount(pdnObj, DOESNT_EXIST, 0);
            VerifyRefCount(pdnPhantom, DOESNT_EXIST, 0);
        }
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost);
    PhysicallyDeleteObject(pdnHost);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnRef1);
    FreeObjectName(pdnRef2);

    ReportTest("NameCollisionTest");
}

void RefPhantomSidUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing reference phantom (which by
    definition must have a GUID), the DS verifies that if the new reference to
    that phantom has a SID, that the reference phantom has the same SID.  If
    not, the reference phantom is update with the SID in the reference (i.e.,
    the inbound reference is asumed to be more recent).

    This test stresses this code path.

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xea, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xeb, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefSid1;
    DSNAME *    pdnRefSid2;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    DSNAME *    pdnCurrRef = NULL;
    DWORD       cbCurrRef = 0;
    DWORD       err;

    NewTest("RefPhantomSidUpdateTest");

    // pdnHost1 and pdnHost2 are seperate objects.
    pdnHost1 = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2 = MakeObjectNameEx("Host2", TestRoot);

    // pdnRefSid1 and pdnRefSid2 refer to the same object (same GUID and string
    // name), but have different SIDs.
    pdnRefSid1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRefSid2 = MakeObjectNameEx("Ref", TestRoot);

    DsUuidCreate(&pdnRefSid1->Guid);
    pdnRefSid2->Guid = pdnRefSid1->Guid;
    
    memcpy(&pdnRefSid1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRefSid1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRefSid2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRefSid2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Add reference on Host1 to Ref with first SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid1->structLen, pdnRefSid1);
        if (err) Fail("Can't add reference with first SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 1);
    VerifyRefCount(pdnRefSid2, PHANTOM, 1);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid1");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host2 to Ref with second SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid2->structLen, pdnRefSid2);
        if (err) Fail("Can't add reference with second SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host2");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 2);
    VerifyRefCount(pdnRefSid2, PHANTOM, 2);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid2->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid2, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid2");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host2");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid2->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid2, cbCurrRef))
            {
                Fail("Ref on Host2 is not pdnRefSid2");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);

    VerifyRefCount(pdnHost1, TOMBSTONE, 1);
    VerifyRefCount(pdnHost2, TOMBSTONE, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 0);
    VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    
    PhysicallyDeleteObject(pdnHost1);
    {
        VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
        VerifyRefCount(pdnHost2, TOMBSTONE, 1);
        VerifyRefCount(pdnRefSid1, PHANTOM, 0);
        VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    }
    PhysicallyDeleteObject(pdnHost2);
    {
        VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
        VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
        VerifyRefCount(pdnRefSid1, PHANTOM, 0);
        VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    }
    PhysicallyDeleteObject(pdnRefSid1);
    
    
    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);


    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRefSid1);
    FreeObjectName(pdnRefSid2);

    if (NULL != pdnCurrRef) THFree(pdnCurrRef);

    ReportTest("RefPhantomSidUpdateTest");
}

void StructPhantomGuidSidUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing structural phantom (which by
    definition lacks a GUID and SID), the DS adds the GUID/SID from the
    reference to the exisiting structural phantom.

    This test stresses this code path.

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xec, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xed, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    BYTE *      pb;
    DWORD       cb;
    GUID        guid;
    NT4SID      sid;
    DWORD       err;

    NewTest("StructPhantomGuidSidUpdateTest");

    // Host1 and Host2 are sibling objects.
    pdnHost1 = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2 = MakeObjectNameEx("Host2", TestRoot);

    // Ref2 is a child of Ref1.
    pdnRef1 = MakeObjectNameEx("Ref1", TestRoot);
    pdnRef2 = MakeObjectNameEx("Ref2", pdnRef1);

    DsUuidCreate(&pdnRef1->Guid);
    DsUuidCreate(&pdnRef2->Guid);
    
    memcpy(&pdnRef1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRef1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRef2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRef2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add reference on Host2 to Ref2.  This will implicitly create a structural
    // phantom for Ref1 as well, since it does not yet exist and is a parent of
    // Ref2.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRef2->structLen, pdnRef2);
        if (err) Fail("Can't add reference to Ref2");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host2");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Verify GUIDs/SIDs on Ref1 and Ref2.  Ref2 should have a GUID and SID;
    // Ref1 should have neither.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRef1);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref1");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err != DB_ERR_NO_VALUE) {
            Fail("Unexpected error reading GUID of Ref1");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err != DB_ERR_NO_VALUE) {
            Fail("Unexpected error reading SID of Ref1");
        }

        err = DBFindDSName(pTHS->pDB, pdnRef2);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref2");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref2");
        }
        else if (memcmp(&guid, &pdnRef2->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref2");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref2");
        }
        else if ((cb != pdnRef2->SidLen) || memcmp(&sid, &pdnRef2->Sid, cb)) {
            Fail("Wrong SID on Ref2");
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host1 to Ref1.  This should populate the GUID and SID on
    // Ref1.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRef1->structLen, pdnRef1);
        if (err) Fail("Can't add reference to Ref1");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 2);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Verify GUIDs/SIDs on Ref1 and Ref2.  Both should now have GUIDs and
    // SIDs.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRef1);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref1");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref1");
        }
        else if (memcmp(&guid, &pdnRef1->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref1");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref1");
        }
        else if ((cb != pdnRef1->SidLen) || memcmp(&sid, &pdnRef1->Sid, cb)) {
            Fail("Wrong SID on Ref1");
        }

        err = DBFindDSName(pTHS->pDB, pdnRef2);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref2");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref2");
        }
        else if (memcmp(&guid, &pdnRef2->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref2");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref2");
        }
        else if ((cb != pdnRef2->SidLen) || memcmp(&sid, &pdnRef2->Sid, cb)) {
            Fail("Wrong SID on Ref2");
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);

    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnRef2);
    PhysicallyDeleteObject(pdnRef1);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRef1);
    FreeObjectName(pdnRef2);

    ReportTest("StructPhantomGuidSidUpdateTest");
}

void ObjectSidNoUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing object, make sure that we *don't*
    update the SID if a reference to that object has a different SID than
    that already present (as opposed to what we'd do if it were a phantom).

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xee, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xef, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefSid1;
    DSNAME *    pdnRefSid2;
    DSNAME *    pdnHost;
    DSNAME *    pdnCurrRef = NULL;
    DWORD       cbCurrRef = 0;
    DWORD       err;

    NewTest("ObjectSidNoUpdateTest");

    pdnHost = MakeObjectNameEx("Host", TestRoot);

    // pdnRefSid1 and pdnRefSid2 refer to the same object (same GUID and string
    // name), but have different SIDs.
    pdnRefSid1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRefSid2 = MakeObjectNameEx("Ref", TestRoot);

    DsUuidCreate(&pdnRefSid1->Guid);
    pdnRefSid2->Guid = pdnRefSid1->Guid;
    
    memcpy(&pdnRefSid1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRefSid1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRefSid2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRefSid2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost, NonLinkedProperty);
    AddObject(pdnRefSid1);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid2, REAL_OBJECT, 1);

    // Add SID to Ref.
    SYNC_TRANS_WRITE();
    
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRefSid1);
        if (err) Fail("Can't find Ref");
    
        err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_SID,
                          pdnRefSid1->SidLen, &pdnRefSid1->Sid);
        if (err) {
            DPRINT1(0, "DBAddAttVal() failed with error %d.\n", err);
            Fail("Can't add SID to Ref");
        }
    
        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Ref");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host1 to Ref with different SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) Fail("Can't find Host");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid2->structLen, pdnRefSid2);
        if (err) Fail("Can't add reference with second SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, REAL_OBJECT, 2);
    VerifyRefCount(pdnRefSid2, REAL_OBJECT, 2);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid1");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnRefSid1);
        if (err) Fail("Can't find Ref");

        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read name of Ref");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref name is not pdnRefSid1");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnRefSid2);
        if (err) Fail("Can't find Ref");

        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read name of Ref");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref name is not pdnRefSid1");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost);
    LogicallyDeleteObject(pdnRefSid1);

    PhysicallyDeleteObject(pdnHost);
    PhysicallyDeleteObject(pdnRefSid1);

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);


    FreeObjectName(pdnHost);
    FreeObjectName(pdnRefSid1);
    FreeObjectName(pdnRefSid2);

    if (NULL != pdnCurrRef) THFree(pdnCurrRef);

    ReportTest("ObjectSidNoUpdateTest");
}


void UnmangleRDNTest(void)
/*++

Routine Description:

    This test exercises the name collision handling code, focusing on encoding
    and decoding GUIDs embedded in RDNs.  Following is the text of the bug that
    prompted this functionality:
    
    === Opened by jeffparh on 06/19/98; AssignedTo = JEFFPARH; Priority = 1 ===
    This problem bit ntwksta1, and is causing inbound replication to halt:
    
    We're trying to apply the inbound object 
    CN=CHILDDEV,CN=Partitions,CN=Configuration,DC=ntdev,DC=microsoft,DC=com,
    with an ncName attribute that references the domain:
    
        DSNAME
          total size: 138, name len: 40
          Guid: e15d7046-054e-11d2-a80f-bfbc8c2bf64e
          SID: S-1-5-21-49504375-1957592189-1205755695
          Name: DC=childdev,DC=ntdev,DC=microsoft,DC=com
    
    This domain has been reinstalled at least twice.  There are currently a few
    references in the database to objects that once had this string name:
    
       DNT   PDNT  NCDNT RefCnt V O IT Deletion Time     RdnTyp  CC  RDN                  GUID
     46584   1795      -      2 - 0  - 98-05-27 09:35.06 1376281 082 childdev#b7f63eb515f5d1118a04d68dc9e4b639 b53ef6b7-f515-11d1-8a04-d68dc9e4b639
     47093   1795      -      1 - 0  - 98-05-29 11:39.45 1376281 016 childdev             f622b2e9-f720-11d1-97a7-debcc966ba39
     51287   1795      -      1 - 0  - 98-06-18 16:41.11 1376281 082 childdev#e9b222f620f7d11197a7debcc966ba39 no guid
    
    (Note that # is actually BAD_NAME_CHAR -- a linefeed.)
    
    Of particular interest is the fact that the last 2 are aliases for the same
    object -- i.e., childdev#e9b222f620f7d11197a7debcc966ba39 is a name-munged
    version of a reference to childdev with guid
    f622b2e9-f720-11d1-97a7-debcc966ba39 = e9b222f620f7d11197a7debcc966ba39.
    
    The name-munged reference replicated in from another server as part of
    adding a reference to the object
    CN=IMRBS1,CN=Computers,DC=childdev#e9b222f620f7d11197a7debcc966ba39,
    DC=ntdev,DC=microsoft,DC=com -- undoubtedly by adding the server object for
    the newly-reinstalled IMRBS1.  The reference was name-munged on the source
    server to resolve a conflict there -- a conflict generated by adding a
    reference to this newest version of childdev (the one with guid
    e15d7046-054e-11d2-a80f-bfbc8c2bf64e).  The reference has a guid only for
    the leaf -- it doesn't carry the guid for the
    DC=childdev#e9b222f620f7d11197a7debcc966ba39 part -- so when we add the
    reference we don't realize that DC=childdev#e9b222f620f7d11197a7debcc966ba39
    with no guid should be the same record as DC=childdev with guid
    f622b2e9-f720-11d1-97a7-debcc966ba39.
    
    At any rate, having two phantoms that really correspond to the same object
    is the root of the problem.
    
    This causes the downstream effect we're seeing because when we go to add a
    reference to the latest version of childdev, we note the phantom conflict
    for the name childdev (DNT 47093 already owns that name), and decide to
    rename DNT 47093.  However, the new name we try to give it in order to
    eliminate the conflict is childdev#e9b222f620f7d11197a7debcc966ba39, which 
    is already owned by DNT 51287.
    
    The solution seems to be to parse out the guids of what would otherwise be
    structural phantoms when we replicate in references like
    CN=IMRBS1,CN=Computers,DC=childdev#e9b222f620f7d11197a7debcc966ba39,
    DC=ntdev,DC=microsoft,DC=com.  This would ensure that the record at DNT
    51287 was never created (the reference would include 47093 instead), and
    we'd avoid this symptom.
    ============================================================================    

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefWithGuid;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    WCHAR       szMangledRef[MAX_RDN_SIZE] = L"Ref";
    DWORD       cchMangledRef = wcslen(szMangledRef);
    DSNAME *    pdnMangledRef;
    DSNAME *    pdnRefChild;
    DSNAME *    pdnMangledRefChild;
    DSNAME *    pdnMangledRefChildWithGuid;
    DSNAME *    pdn;

    NewTest("UnmangleRDNTest");

    // Create a reference to CN=ref on host1.  Then create a reference to
    // CN=ref-child,CN=<munged ref> on host2.  The parent of ref-child
    // should be the pre-existing record CN=ref (not a new record with the
    // ref's munged name).
    
    // Derive DNs.
    pdnHost1       = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2       = MakeObjectNameEx("Host2", TestRoot);
    pdnRefWithGuid = MakeObjectNameEx("Ref", TestRoot);
    pdnRefChild    = MakeObjectNameEx("RefChild", pdnRefWithGuid);

    DsUuidCreate(&pdnRefWithGuid->Guid);
    
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &pdnRefWithGuid->Guid, szMangledRef, &cchMangledRef);
    DPRINT3(2, "Mangled ref RDN is \"%*.*ls\".\n", cchMangledRef, cchMangledRef,
            szMangledRef);
    pdnMangledRef = THAllocEx(pTHS, pdnRefWithGuid->structLen + 100);
    AppendRDN(TestRoot,
              pdnMangledRef,
              pdnRefWithGuid->structLen + 100,
              szMangledRef,
              cchMangledRef,
              ATT_COMMON_NAME);

    pdnMangledRefChild         = MakeObjectNameEx("RefChild", pdnMangledRef);
    pdnMangledRefChildWithGuid = MakeObjectNameEx("RefChild", pdnMangledRef);
    
    DsUuidCreate(&pdnMangledRefChildWithGuid->Guid);
    
    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);

    // Add reference to Ref.
    AddProperty(pdnHost1, pdnRefWithGuid, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, PHANTOM, 1);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);

    // Add reference to MangledRefChild.
    AddProperty(pdnHost2, pdnMangledRefChildWithGuid, NonLinkedProperty);

    // We just added a ref to CN=RefChild,CN=Ref%CNF:xyz,....
    // CN=REF%CNF:xyz should have been resolved to the CN=Ref record with guid
    // xyz, and CN=RefChild should have been added underneath it.
    // Therefore, CN=Ref should add a refcount and CN=RefChild should now be
    // present with a refcount of 1.

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, PHANTOM, 2);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, PHANTOM, 1);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, PHANTOM, 1);

    // Verify properties have right DNs/GUIDs.
    pdn = GetProperty(pdnHost1, 1, NonLinkedProperty);
    if (!DSNAME_IDENTICAL(pdn, pdnRefWithGuid))
        Fail("Wrong ref on Host1!");
    
    pdn = GetProperty(pdnHost2, 1, NonLinkedProperty);
    if (!DSNAME_SAME_GUID_SID(pdn, pdnMangledRefChildWithGuid))
        Fail("RefChild has wrong GUID/SID!");
    if (!DSNAME_SAME_STRING_NAME(pdn, pdnRefChild))
        Fail("RefChild has wrong string name!");

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnRefChild);
    PhysicallyDeleteObject(pdnRefWithGuid);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefWithGuid, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);
    
    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRefWithGuid);
    FreeObjectName(pdnMangledRef);
    FreeObjectName(pdnRefChild);
    FreeObjectName(pdnMangledRefChild);
    FreeObjectName(pdnMangledRefChildWithGuid);

    ReportTest("UnmangleRDNTest");
}


void
PhantomRenameOnPromotionWithStructuralCollision(
    IN  PropertyType    type
    )
/*++

Routine Description:

    Assume the existence of the following records:
    
    DNT 10 = phantom, CN=foo,DC=corp,DC=com, guid n/a
    DNT 11 = phantom, CN=bar,CN=foo,DC=corp,DC=com, guid 1
    DNT 20 = phantom, CN=baz,DC=corp,DC=com, guid 2
    
    Replication now attempts to apply the object CN=foo,DC=corp,DC=com with guid
    2.  I.e., the guid matches that of the reference phantom at DNT 20, and the
    string name matches that of the structural phantom at DNT 10.
    
    In this case we want to promote the record that has the proper guid (at DNT
    20) to be a real object and rename the record to have the correct string
    name, but another record (DNT 10) has already laid claim to that string
    name.  So, we will essentially collapse DNT 10 and DNT 20 into DNT 20 first
    by reparenting all of DNT 10's children to DNT 20 then name munging DNT 10
    to avoid the name collision induced by changing the string name of DNT 20
    to be that of the object we're trying to add.
    
    Note that since DNT 10 has no associated guid, when we munge its name we
    have to invent a guid to do it with.  This violates the normal rule that
    you should be able to unmunge a munged name to produce the corresponding
    object guid, but note that since (1) this DNT has no direct references,
    since it is a structural phantom only and (2) we have reparented all of its
    children, this DNT should have no remaining references, ergo the ability
    to unmunge its name is unnecessary.
    
Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefWithGuid;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    WCHAR       szMangledFoo[MAX_RDN_SIZE] = L"Foo";
    DWORD       cchMangledFoo = wcslen(szMangledFoo);
    DSNAME *    pdnStructuralFoo;
    DSNAME *    pdnBar;
    DSNAME *    pdnBaz;
    DSNAME *    pdnObjectFoo;
    DSNAME *    pdn;
    DWORD       cb;
    LPSTR       pszTestName = (NonLinkedProperty == type)
                                ? "PhantomRenameOnPromotionWithStructuralCollision(NonLinkedProperty)"
                                : "PhantomRenameOnPromotionWithStructuralCollision(LinkedProperty)";


    NewTest(pszTestName);

    // Derive DNs.
    pdnHost1         = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2         = MakeObjectNameEx("Host2", TestRoot);
    pdnStructuralFoo = MakeObjectNameEx("foo", TestRoot);
    pdnBar           = MakeObjectNameEx("bar", pdnStructuralFoo);
    pdnBaz           = MakeObjectNameEx("baz", TestRoot);
    pdnObjectFoo     = MakeObjectNameEx("foo", TestRoot);

    DsUuidCreate(&pdnBar->Guid);
    DsUuidCreate(&pdnBaz->Guid);
    pdnObjectFoo->Guid = pdnBaz->Guid;
    
    // Create host objects.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |
    //  |--Host2 (obj, ref=1)
    AddPropertyHost(pdnHost1, type);
    AddPropertyHost(pdnHost2, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBar, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, DOESNT_EXIST, 0);

    // Add reference to CN=Bar,CN=Foo,<TestRoot> on Host1.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |
    //  |--Foo (phantom, ref=1, no guid)
    //      |
    //      |--Bar (phantom, ref=1, guid X)
    AddProperty(pdnHost1, pdnBar, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 1);
    VerifyRefCount(pdnBar, PHANTOM, 1);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, PHANTOM, 1); // same name as pdnStructuralFoo

    // Add reference to CN=Baz,<TestRoot> on Host2.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Baz
    //  |
    //  |--Foo (phantom, ref=1, no guid)
    //  |   |
    //  |   |--Bar (phantom, ref=1, guid X)
    //  |
    //  |--Baz (phantom, ref=1, guid Y)
    AddProperty(pdnHost2, pdnBaz, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 1);
    VerifyRefCount(pdnBar, PHANTOM, 1);
    VerifyRefCount(pdnBaz, PHANTOM, 1);
    VerifyRefCount(pdnObjectFoo, PHANTOM, 1); // same guid as pdnBaz

    // Promote CN=Baz,<TestRoot> phantom to be real object CN=Foo,<TestRoot>,
    // requiring the DS to first rename the existing structural phantom
    // CN=Foo,<TestRoot>.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Foo
    //  |
    //  |--Foo#CNF:xxx (phantom, ref=0, no guid)
    //  |
    //  |--Foo (obj, ref=3, guid Y)
    //      |
    //      |--Bar (phantom, ref=1, guid X)
    AddPropertyHost(pdnObjectFoo, type);

    // Reconstruct the munged name of pdnStructuralFoo using the guid exported
    // from dbsubj.c specifically for our test.
    // (This test hook exists only #ifdef INCLUDE_UNIT_TESTS on DBG builds.)
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &gLastGuidUsedToCoalescePhantoms, szMangledFoo, &cchMangledFoo);
    cb = pdnStructuralFoo->structLen + 100;
    pdnStructuralFoo = THReAllocEx(pTHStls, pdnStructuralFoo, cb);
    AppendRDN(TestRoot, pdnStructuralFoo, cb, szMangledFoo, cchMangledFoo,
              ATT_COMMON_NAME);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 0);
    VerifyRefCount(pdnBar, PHANTOM, 1); // has been reparented, but same guid/name
    VerifyRefCount(pdnBaz, REAL_OBJECT, 3); // same guid as pdnObjectFoo
    VerifyRefCount(pdnObjectFoo, REAL_OBJECT, 3); // 1 ref by pdnHost1, 1 ref from self, 1 ref as parent of bar
    
    // Verify properties have right DNs/GUIDs.
    pdn = GetProperty(pdnHost1, 1, type);
    if (!DSNAME_IDENTICAL(pdn, pdnBar))
        Fail("Wrong ref on Host1!");
    
    pdn = GetProperty(pdnHost2, 1, type);
    if (!DSNAME_IDENTICAL(pdn, pdnObjectFoo))
        Fail("Wrong ref on Host2!");
    if (!DSNAME_SAME_GUID_SID(pdn, pdnBaz))
        Fail("pdnObjectFoo has different GUID/SID from pdnBaz!");

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);
    LogicallyDeleteObject(pdnObjectFoo);
    PhysicallyDeleteObject(pdnStructuralFoo);
    PhysicallyDeleteObject(pdnBar);
    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnObjectFoo);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnStructuralFoo, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBar, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, DOESNT_EXIST, 0);
    
    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnStructuralFoo);
    FreeObjectName(pdnBar);
    FreeObjectName(pdnBaz);
    FreeObjectName(pdnObjectFoo);

    ReportTest(pszTestName);
}


void
ConflictedNcNameFixupTest(
    BOOL fSubref
    )

/*++

Routine Description:

    Test whether conflicted nc name fixup works. This feature is that when a cross ref
    is deleted, if there is another cross ref with a mangled version of the same nc name,
    we will mangle the old user of the nc name, and unmangle the new user of the nc name.

Arguments:

    fSubref - Whether this is testing the case case of the nc name being a phantom
              or the nc name being a subref.

Return Value:

    None

--*/

{
    DSNAME *pdnNcName1, *pdnNcName2;
    DSNAME *pdnNewNcName1, *pdnNewNcName2;
    DSNAME *pdnCR1 = MakeObjectNameEx("refcounttestcr1", gAnchor.pPartitionsDN );
    DSNAME *pdnCR2 = MakeObjectNameEx("refcounttestcr2", gAnchor.pPartitionsDN );
    CROSS_REF_LIST * pCRL;
    BOOL fCR1Seen = FALSE, fCR2Seen = FALSE;

    NewTest("ConflictedNcNameFixupTest");

    // establish nc name references
    if (fSubref) {
        // Child nc under domain this dsa holds
        pdnNcName1 = MakeObjectNameEx2("dc=child", gAnchor.pDomainDN);
        pdnNcName2 = MakeObjectNameEx2("dc=child", gAnchor.pDomainDN);
    } else {
        // Phantom references to new tree
        pdnNcName1 = MakeObjectNameEx3("dc=tree,dc=external");
        pdnNcName2 = MakeObjectNameEx3("dc=tree,dc=external");
    }

    DsUuidCreate( &pdnCR1->Guid );
    DsUuidCreate( &pdnCR2->Guid );

    DsUuidCreate( &pdnNcName1->Guid );
    DsUuidCreate( &pdnNcName2->Guid );

    // Pre-existential state
    VerifyRefCount(pdnCR1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnCR2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnNcName1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnNcName2, DOESNT_EXIST, 0);

    // Create two cross-refs with conflicting nc name attributes

    AddCrossRef( pdnCR1, pdnNcName1, L"tree1.external" );

    AddCrossRef( pdnCR2, pdnNcName2, L"tree2.external" );

    // Force cross-ref cache to update so conflicted name appears
    ModifyCrossRef( pdnCR1 );
    ModifyCrossRef( pdnCR2 );

    // In the Cross-ref cache, we should now find two entries,
    // one with a conflicted name

    for( pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR ) {
        if (NameMatched(pCRL->CR.pObj, pdnCR1)) {
            Assert( NameMatched( pCRL->CR.pNC, pdnNcName1 ) );
            fCR1Seen = TRUE;
            pdnNewNcName1 = pCRL->CR.pNC;
        }
        if (NameMatched(pCRL->CR.pObj, pdnCR2)) {
            Assert( NameMatched( pCRL->CR.pNC, pdnNcName2 ) );
            fCR2Seen = TRUE;
            pdnNewNcName2 = pCRL->CR.pNC;
        }
    }
    if (!fCR1Seen || !fCR2Seen) {
        Fail("Crossref's not in initial state");
    }

    if (fSubref) {
        // In the subref case, name2 is mangled
        Assert( NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );
        Assert( !NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );
        DPRINT1( 0, "Subref Mangled name: %ws\n", pdnNewNcName2->StringName );
    } else {
        // In the phantom case, name1 is mangled
        Assert( !NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );
        DPRINT1( 0, "Phantom Mangled name: %ws\n", pdnNewNcName1->StringName );
        Assert( NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );
    }

    VerifyRefCount(pdnCR1, REAL_OBJECT, 1);
    if (fSubref) {
        VerifyRefCount(pdnNcName1, REAL_OBJECT, 3);
    } else {
        VerifyRefCount(pdnNcName1, PHANTOM, 1);
    }

    VerifyRefCount(pdnCR2, REAL_OBJECT, 1);
    if (fSubref) {
        VerifyRefCount(pdnNcName2, REAL_OBJECT, 3);
    } else {
        VerifyRefCount(pdnNcName2, PHANTOM, 1);
    }

    // Get rid of the cross-ref owning the good name
    // The act of deleting the cross ref will cause the name ownership
    // code to be executed, renaming the other reference

    if (fSubref) {
        // name 1 is the good one
        LogicallyDeleteObject(pdnCR1);
        VerifyRefCount(pdnCR1, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName1, TOMBSTONE, 2);
        // Force cross-ref cache to update so conflicted name disappears appears
        ModifyCrossRef( pdnCR2 );
    } else {
        // name 2 is the good one
        LogicallyDeleteObject(pdnCR2);
        VerifyRefCount(pdnCR2, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName2, PHANTOM, 1);
        // Force cross-ref cache to update so conflicted name disappears appears
        ModifyCrossRef( pdnCR1 );
    }

    // In the Cross-ref cache, we should now find one entry with
    // the right name
    fCR1Seen = FALSE; fCR2Seen = FALSE;
    pdnNewNcName1 = NULL; pdnNewNcName2 = NULL;
    for( pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR ) {
        if (NameMatched(pCRL->CR.pObj, pdnCR1)) {
            Assert( NameMatched( pCRL->CR.pNC, pdnNcName1 ) );
            fCR1Seen = TRUE;
            pdnNewNcName1 = pCRL->CR.pNC;
        }
        if (NameMatched(pCRL->CR.pObj, pdnCR2)) {
            Assert( NameMatched( pCRL->CR.pNC, pdnNcName2 ) );
            fCR2Seen = TRUE;
            pdnNewNcName2 = pCRL->CR.pNC;
        }
    }

    if (fSubref) {
        // subref: name 2 is left
        if ( !fCR2Seen ) {
            Fail("Crossref's not in final state");
        }
        Assert( NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );

        LogicallyDeleteObject(pdnCR2);
        VerifyRefCount(pdnCR2, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName2, TOMBSTONE, 2);
    } else {
        // phantom: name 1 is left
        if ( !fCR1Seen ) {
            Fail("Crossref's not in final state");
        }
        Assert( NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );

        LogicallyDeleteObject(pdnCR1);
        VerifyRefCount(pdnCR1, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName1, PHANTOM, 1);
    }

    ReportTest("ConflictedNcNameFixupTest");
} /* ConflictedNcNameFixupTest */

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Local helper routines.                                           //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
NewTest(
    CHAR    *TestName)
{
    fTestPassed = TRUE;

    DPRINT1( 0, "%s ...\n", TestName );
}

void
ReportTest(
    CHAR    *TestName)
{
    DPRINT2( 0, "%s - %s\n\n", TestName, (fTestPassed ? "PASS" : "FAIL") );
}

void
_Fail(
    CHAR    *msg,
    DWORD   line)
{
    fTestPassed = FALSE;
    DPRINT2( 0, "Refcount test error: %s - line(%d)\n", msg, line );
}

CHAR PrintGuidBuffer[100];

CHAR *
GuidToString(
    GUID    *Guid)
{
    DWORD   i;
    BYTE    *pb, low, high;

    if ( !Guid )
    {
        strcpy(PrintGuidBuffer, "NULL");
    }
    else
    {
        memset(PrintGuidBuffer, 0, sizeof(PrintGuidBuffer));

        pb = (BYTE *) Guid;

        for ( i = 0; i < sizeof(GUID); i++ )
        {
            low = pb[i] & 0xf;
            high = (pb[i] & 0xf0) >> 4;

            if ( low <= 0x9 )
            {
                PrintGuidBuffer[2*i] = '0' + low;
            }
            else
            {
                PrintGuidBuffer[2*i] = 'A' + low - 0x9;
            }

            if ( high <= 0x9 )
            {
                PrintGuidBuffer[(2*i)+1] = '0' + high;
            }
            else
            {
                PrintGuidBuffer[(2*i)+1] = 'A' + high - 0x9;
            }
        }
    }

    return(PrintGuidBuffer);
}

void
FreeObjectName(
    DSNAME  *pDSName)
{
    THFree(pDSName);
}

DSNAME *
MakeObjectNameEx(
    CHAR    *RDN,
    DSNAME  *pdnParent)
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen("CN=") +
          strlen(RDN) +
          strlen(",") +
          wcslen(pdnParent->StringName);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    wcscpy(pDSName->StringName, L"CN=");
    mbstowcs(&pDSName->StringName[3], RDN, strlen(RDN));
    wcscat(pDSName->StringName, L",");
    wcscat(pDSName->StringName, pdnParent->StringName);
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}
    
DSNAME *
MakeObjectNameEx2(
    CHAR    *RDN,
    DSNAME  *pdnParent)
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen(RDN) +
          strlen(",") +
          wcslen(pdnParent->StringName);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    mbstowcs(pDSName->StringName, RDN, strlen(RDN));
    wcscat(pDSName->StringName, L",");
    wcscat(pDSName->StringName, pdnParent->StringName);
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}

DSNAME *
MakeObjectNameEx3(
    CHAR    *RDN
    )
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen(RDN);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    mbstowcs(pDSName->StringName, RDN, strlen(RDN));
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}


void
VerifyRefCountHelper(
    DWORD   ExpectedRefCount,
    DWORD   dwLine)
{
    DWORD   cRefs;
    DWORD   cRead;

    if ( DBGetSingleValue(pTHStls->pDB,
                          FIXED_ATT_REFCOUNT,
                          &cRefs,
                          sizeof(cRefs),
                          &cRead) )
    {
        _Fail("Can't read ref count", dwLine);
        return;
    }

    Assert(sizeof(cRefs) == cRead);

    if ( cRefs != ExpectedRefCount )
    {
        _Fail("Reference count mismatch", dwLine);
        DPRINT2( 0, "ExpectedRefCount(%d) - ActualRefCount(%d)\n",
                 ExpectedRefCount, cRefs );
        return;
    }
}

BOOL
IsDeletedHelper(void)
{
    BOOL    fDeleted = FALSE;
    DWORD   cRead;

    if ( DBGetSingleValue(pTHStls->pDB,
                          ATT_IS_DELETED,
                          &fDeleted,
                          sizeof(fDeleted),
                          &cRead) )
    {
        return(FALSE);
    }
    
    Assert(sizeof(fDeleted) == cRead);

    DPRINT1( 3, "IsDeleted(%s)\n", (fDeleted ? "TRUE" : "FALSE") );

    return(fDeleted);
}

void
VerifyRefCountEx(
    DSNAME  *pObject, 
    DWORD   ObjectType, 
    DWORD   ExpectedRefCount,
    DWORD   dwLine)
{
    DWORD   dwErr;
    BOOL    fDeleted;
    DWORD   i;
    CHAR    *pszType;

    switch ( ObjectType )
    {
    case TOMBSTONE:

        // Tombstones can only be looked up by guid.
        Assert(!fNullUuid(&pObject->Guid));
        pszType = "TOMBSTONE";
        break;

    case DOESNT_EXIST:

        // Non-existence test can be by name and/or guid.
        pszType = "DOESNT_EXIST";
        break;

    case PHANTOM:

        // Phantoms can be looked up by name or guid.
        // Guid case is for when TOMBSTONE reverts to a PHANTOM
        // but name stays as te TOMBSTONE name which is based
        // on the guid.
        pszType = "PHANTOM";
        break;

    case REAL_OBJECT:

        // Real objects can only be looked up by name.
        pszType = "REAL_OBJECT";
        break;

    default:

        pszType = "UNKNOWN";
        break;
    }

    DPRINT3( 3, "VerifyRefCount(%ls, %s, %s)\n", 
             (pObject->NameLen ? pObject->StringName : L"NULL"),
             GuidToString(&pObject->Guid), pszType );
            
    SYNC_TRANS_READ();
    
    __try
    {
        switch ( ObjectType )
        {
        case REAL_OBJECT:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                _Fail("REAL_OBJECT not found", dwLine);
                leave;
            }

            if ( IsDeletedHelper() )
            {
                _Fail("REAL_OBJECT is deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case TOMBSTONE:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                _Fail("TOMBSTONE not found", dwLine);
                leave;
            }

            if ( !IsDeletedHelper() )
            {
                _Fail("TOMBSTONE is not deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case PHANTOM:

            dwErr = DIRERR_OBJ_NOT_FOUND;

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( DIRERR_NOT_AN_OBJECT != dwErr )
            {
                _Fail("PHANTOM not found", dwLine);
                leave;
            }

            if ( IsDeletedHelper() )
            {
                _Fail("PHANTOM is deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case DOESNT_EXIST:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( DIRERR_OBJ_NOT_FOUND != dwErr )
            {
                _Fail("DOESNT_EXIST exists", dwLine);
                leave;
            }

            leave;

        default:

            _Fail("Unsupported object type", dwLine);
            leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }
}

// stolen #defines etc. from ..\dblayer\dbintrnl.h
#define DBSYN_INQ       0
int
IntExtDist(DBPOS FAR *pDB, USHORT extTableOp,
           ULONG intLen, UCHAR *pIntVal,
           ULONG *pExtLen, UCHAR **ppExtVal,
           ULONG ulUpdateDnt, JET_TABLEID jTbl,
           ULONG flags);
void
VerifyStringNameEx(
    DSNAME  *pObject, 
    DWORD   dwLine)
{
    DWORD   dwErr;
    DWORD   cbName=0;
    CHAR    *pszType;
    DSNAME   GuidOnlyName, *pNewDN=NULL;
    THSTATE  *pTHS = pTHStls;

    memcpy(&GuidOnlyName, pObject, sizeof(DSNAME));

    GuidOnlyName.NameLen = 0;
    GuidOnlyName.structLen = DSNameSizeFromLen(0);
    Assert(GuidOnlyName.structLen <= sizeof(DSNAME));
    Assert(!fNullUuid(&GuidOnlyName.Guid));

    SYNC_TRANS_READ();
    
    __try
    {
        __try {
            dwErr = DBFindDSName(pTHS->pDB, &GuidOnlyName);
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }

        switch(dwErr) {
        case 0:
        case DIRERR_NOT_AN_OBJECT:
            // Normal object, or phantom.
            // Turn the DNT into the dsname (don't just read the name off
            // the object, phantoms don't have such a thing.
            
            if(IntExtDist(pTHS->pDB, DBSYN_INQ, sizeof(DWORD),
                          (PUCHAR)&pTHS->pDB->DNT,
                          &cbName, (PUCHAR *)&pNewDN, 0, pTHS->pDB->JetObjTbl,
                          0)) { 
                Fail("Can't read name for string name compare");                
            }
            else {
                if(!NameMatchedStringNameOnly(pObject, pNewDN)) {
                    _Fail("String Name didn't match", dwLine);
                }
            }
            break;
        default:
            _Fail("Obj not found for string name verify", dwLine);
            leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }
}

void
CommonAddObject(
    DSNAME  *pObject,
    ATTRTYP  ObjectClass)
{
    THSTATE *               pTHS = pTHStls;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    ATTRVAL                 ObjectClassVal = {sizeof(ObjectClass),
                                              (UCHAR *) &ObjectClass};
    ATTRVAL                 SDVal = { 0 };
    ATTR                    Attrs[2] =
                                { {ATT_OBJECT_CLASS, {1, &ObjectClassVal}},
                                  {ATT_NT_SECURITY_DESCRIPTOR, {1, &SDVal}}
                                };
    ATTRBLOCK               AttrBlock = { 2, Attrs };
    BOOL                    fDsaSave;
    DWORD                   winError;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    DPRINT1( 3, "CommonAddObject(%ls)\n", pObject->StringName );

    // Create a security descriptor.

    #define DEFAULT_SD \
        L"O:DAG:DAD:(A;CI;RPWPCCDCLCSWSD;;;DA)S:(AU;FA;RPWPCCDCLCSWSD;;;DA)"

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            DEFAULT_SD, SDDL_REVISION_1, &pSD, &SDVal.valLen)) {
        winError = GetLastError();
        Fail("SD conversion failed");
        DPRINT1(0, "SD conversion returned %u\n", winError);
    }

    SDVal.pVal = (BYTE *) pSD;
    Assert(SDVal.pVal && SDVal.valLen);

    // Perform as fDSA so we can predefine GUIDs if we like.

    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    __try
    {
        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = pObject;
        addArg.AttrBlock = AttrBlock;
        InitCommarg(&addArg.CommArg);

        // Core re-allocs the ATTR array - so we need to THAlloc it.

        addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(Attrs));
        memcpy(addArg.AttrBlock.pAttr, Attrs, sizeof(Attrs));

        // Do the add.

        if ( DirAddEntry(&addArg, &pAddRes) )
        {
            Fail("CommonAddObject");
        }
    }
    __finally
    {
        pTHS->fDSA = fDsaSave;

        if (pSD)
        {
            LocalFree(pSD);
        }
    }
}

void
AddCrossRef(
    DSNAME  *pObject,
    DSNAME  *pNcName,
    LPWSTR   pszDnsRoot
    )
/*
 We need to local cross-ref's on this machine. How hard can it be?
 */
{
    DWORD                   bEnabled = TRUE;
    DWORD                   ulSystemFlags = 0;  // External, fewer checks that way!
    ATTRTYP                 ObjectClass = CLASS_CROSS_REF;
    THSTATE *               pTHS = pTHStls;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    ATTRVAL                 ObjectClassVal = {sizeof(ObjectClass),
                                              (UCHAR *) &ObjectClass};
    ATTRVAL                 SDVal = { 0 };
    ATTRVAL                 NcNameVal = { pNcName->structLen, (UCHAR *) pNcName };
    ATTRVAL                 DnsRootVal = { wcslen( pszDnsRoot ) * sizeof(WCHAR),
                                               (UCHAR *) pszDnsRoot };
    ATTRVAL                 EnabledVal = {sizeof(bEnabled),
                                              (UCHAR *) &bEnabled};
    ATTRVAL                 SystemFlagsVal = {sizeof(ulSystemFlags),
                                              (UCHAR *) &ulSystemFlags};
    ATTR                    Attrs[6] = {
        {ATT_OBJECT_CLASS, {1, &ObjectClassVal}},
        {ATT_NT_SECURITY_DESCRIPTOR, {1, &SDVal}},
        {ATT_NC_NAME, {1, &NcNameVal}},
        {ATT_DNS_ROOT, {1, &DnsRootVal}},
        {ATT_ENABLED, {1, &EnabledVal }},
        {ATT_SYSTEM_FLAGS, {1, &SystemFlagsVal }}
    };
    ATTRBLOCK               AttrBlock = { 6, Attrs };
    DWORD                   winError, err;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    ADDCROSSREFINFO *   pCRInfo;
    COMMRES CommRes;
    ENTINF *pEI = NULL;

    DPRINT1( 3, "AddCrossRef(%ls)\n", pObject->StringName );

    // Create a security descriptor.

    #define DEFAULT_SD \
        L"O:DAG:DAD:(A;CI;RPWPCCDCLCSWSD;;;DA)S:(AU;FA;RPWPCCDCLCSWSD;;;DA)"

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            DEFAULT_SD, SDDL_REVISION_1, &pSD, &SDVal.valLen)) {
        winError = GetLastError();
        Fail("SD conversion failed");
        DPRINT1(0, "SD conversion returned %u\n", winError);
    }

    SDVal.pVal = (BYTE *) pSD;
    Assert(SDVal.pVal && SDVal.valLen);

#if 0
    // Taken from AddNewDomainCrossRef - do we need it?
    // Add NC-Name value to GC verify cache else VerifyDSNameAtts will
    // claim this DN doesn't correspond to an existing object.
    pEI = THAllocEx(pTHS, sizeof(ENTINF));
    pEI->pName = pNcName;
    GCVerifyCacheAdd(NULL,pEI);

    // Set up cross ref info needed for creation
    // This gets freed by VerifyNcName in LocalAdd...
    pCRInfo = THAllocEx(pTHS, sizeof(ADDCROSSREFINFO));
    pCRInfo->pdnNcName = pNcName;
    pCRInfo->bEnabled = bEnabled;
    pCRInfo->ulSysFlags = ulSystemFlags;

    PreTransVerifyNcName(pTHS, pCRInfo);
    if(pTHS->errCode){
        Fail("PreTransVerifyNcName");
        return;
    }
#endif

    // Perform as fDRA so we can skip checks
    pTHS->fDRA = TRUE;

    SYNC_TRANS_WRITE();

    __try
    {
        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = pObject;
        addArg.AttrBlock = AttrBlock;
//        addArg.pCRInfo = pCRInfo;
        InitCommarg(&addArg.CommArg);

        // Core re-allocs the ATTR array - so we need to THAlloc it.

        addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(Attrs));
        memcpy(addArg.AttrBlock.pAttr, Attrs, sizeof(Attrs));

        // Set up the parent
        err = DoNameRes(pTHS,
                        0,
                        gAnchor.pPartitionsDN,
                        &addArg.CommArg,
                        &CommRes,
                        &addArg.pResParent);
        if (err) {
            Fail("DoNameRes parent");
            __leave;
        }

        // Do the add.

        err = LocalAdd(pTHS, &addArg, FALSE);
        if (err) {
            Fail("AddCrossRef");
            __leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( err );

        pTHS->fDRA = FALSE;

        if (pSD)
        {
            LocalFree(pSD);
        }
    }
}


void
ModifyCrossRef(
    DSNAME *pObject
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD err;
    DWORD bEnabled = TRUE;
    MODIFYARG       modarg;
    THSTATE *               pTHS = pTHStls;

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pObject);
        if (err) Fail("Can't find Object");

        memset(&modarg, 0, sizeof(modarg));
        modarg.pObject = pObject;
        modarg.count = 1;
        InitCommarg(&modarg.CommArg);
        modarg.CommArg.Svccntl.fPermissiveModify = TRUE;
        modarg.pResObj = CreateResObj(pTHS->pDB, modarg.pObject);

        modarg.FirstMod.choice = AT_CHOICE_REMOVE_ATT;
        modarg.FirstMod.AttrInf.attrTyp = ATT_ENABLED;
        modarg.FirstMod.AttrInf.AttrVal.valCount = 0;
        modarg.FirstMod.pNextMod = NULL;

        err = LocalModify(pTHS, &modarg);
        if (err) {
            Fail("Modify Cross Ref");
            __leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( err );
    }
}


void
AddObject(
    DSNAME  *pObject)
{
    CommonAddObject(pObject, CLASS_CONTACT);
}

void
AddPropertyHost(
    DSNAME         *pObject,
    PropertyType    type)
{
    // CLASS_CONTACT can have both linked and non-linked DSNAME-valued
    // properties.  The linked property is gNonLinkedAttrTyp.  The non-linked
    // property is gLinkedAttrTyp.

    CommonAddObject(pObject, CLASS_CONTACT);
}

void
CommonAddProperty(
    DSNAME  *pHost, 
    DSNAME  *pObject,
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT3( 3, "CommonAddProperty(%ls, %ls, %s)\n",
             pHost->StringName, pObject->StringName,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBAddAttVal(pTHS->pDB, attrTyp, pObject->structLen, pObject);
            if (err) {
                Fail("Can't add value!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}


void
AddProperty(
    DSNAME          *pHost, 
    DSNAME          *pLinkedObject,
    PropertyType    type)
{
    if ( LinkedProperty == type )
        CommonAddProperty(pHost, pLinkedObject, gNonLinkedAttrTyp);
    else
        CommonAddProperty(pHost, pLinkedObject, gLinkedAttrTyp);
}

void
CommonRemoveProperty(
    DSNAME  *pHost, 
    DSNAME  *pObject,
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT3( 3, "CommonRemoveProperty(%ls, %ls, %s)\n", 
             pHost->StringName, pObject->StringName,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBRemAttVal(pTHS->pDB, attrTyp, pObject->structLen, pObject);
            if (err) {
                Fail("Can't remove value!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}

void
CommonRemoveAttribute(
    DSNAME  *pHost, 
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT1( 3, "CommonRemoveAttribute(%ls)\n", pHost->StringName );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBRemAtt(pTHS->pDB, attrTyp );
            if (err) {
                Fail("Can't remove attribute!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}

void
RemoveProperty(
    DSNAME          *pHost, 
    DSNAME          *pLinkedObject,
    PropertyType    type)
{
    if ( LinkedProperty == type )
        CommonRemoveProperty(pHost, pLinkedObject, gNonLinkedAttrTyp);
    else
        CommonRemoveProperty(pHost, pLinkedObject, gLinkedAttrTyp);
}

DSNAME *
CommonGetProperty(
    DSNAME * pdnHost, 
    DWORD    iValue,
    ATTRTYP  attrTyp
    )
{
    THSTATE * pTHS = pTHStls;
    DSNAME *  pdn = NULL;
    DWORD     cb;
    DWORD     err;

    DPRINT3( 3, "CommonGetProperty(%ls, %d, %s)\n", 
             pdnHost->StringName, iValue,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    if (!iValue) {
        Fail("iValue is 1-based, not 0-based!");
    }

    SYNC_TRANS_READ();
    __try {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBGetAttVal(pTHS->pDB, iValue, attrTyp, 0, 0, &cb,
                              (BYTE **) &pdn);
            if (err) {
                Fail("Can't read value!");
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(0);
    }

    return pdn;
}

DSNAME *
GetProperty(
    DSNAME *     pdnHost, 
    DWORD        iValue,
    PropertyType type
    )
{
    if (LinkedProperty == type)
        return CommonGetProperty(pdnHost, iValue, gNonLinkedAttrTyp);
    else
        return CommonGetProperty(pdnHost, iValue, gLinkedAttrTyp);
}

DSNAME *
GetObjectName(
    DSNAME * pdn 
    )
{
    return CommonGetProperty(pdn, 1, ATT_OBJ_DIST_NAME);
}

void
LogicallyDeleteObject(
    DSNAME  *pObject)
{
    REMOVEARG           removeArg;
    REMOVERES           *pRemoveRes = NULL;
    DWORD               dwErr;
    ULONG               cbGuid;
    GUID *              pGuid;

    DPRINT1( 3, "LogicallyDeleteObject(%ls)\n", pObject->StringName );

    if (fNullUuid(&pObject->Guid))
    {
        // First get the object's GUID.

        SYNC_TRANS_WRITE();

        __try
        {
            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                Fail("Can't find object to logically delete");
                leave;
            }

            pGuid = &pObject->Guid;

            dwErr = DBGetAttVal(pTHStls->pDB,
                                1,
                                ATT_OBJECT_GUID,
                                DBGETATTVAL_fCONSTANT,
                                sizeof(GUID),
                                &cbGuid,
                                (BYTE **) &pGuid);

            if ( dwErr )
            {
                Fail("Can't get object guid");
                leave;
            }

            if ( IsDeletedHelper() )
            {
                Fail("Object already logically deleted");
                leave;
            }

            Assert(sizeof(GUID) == cbGuid);
        }
        __finally
        {
            CLEAN_BEFORE_RETURN(0);
        }

        DPRINT1( 3, "\tGuid(%s)\n", GuidToString(&pObject->Guid) );
    }

    // Now delete the object.

    // Construct remove arguments.

    memset(&removeArg, 0, sizeof(REMOVEARG));
    removeArg.pObject = pObject;
    InitCommarg(&removeArg.CommArg);

    // Do the remove.

    if ( DirRemoveEntry(&removeArg, &pRemoveRes) )
    {
        Fail("LogicallyDeleteObject");
    }
}

void
PhysicallyDeleteObjectEx(
        DSNAME  *pObject,
        DWORD    dwLine)
{
    DWORD   dwErr = 0;
    DWORD   i;

    DPRINT1( 3, "PhysicallyDeleteObject(%s)\n", GuidToString(&pObject->Guid) );

    // NOTE: If the object is currently a tombstone, we must perform the
    // DBPhysDel() twice, in two distinct transacations.
    //
    // This is because part of physically deleting the object
    // is removing most of its remaining attributes, which, if this object is
    // currently a tombstone, includes ATT_OBJ_DIST_NAME.  ATT_OBJ_DIST_NAME
    // carries a refcount on the DNT we're trying to physically delete.
    // We physically delete the DNT only if its refcount is 0, so since we
    // don't apply escrowed updates until we're committing the transaction,
    // the refcount we read will still include the one for ATT_OBJ_DIST_NAME.
    // Thus, we must first commit the escrowed update, after which we can
    // physically delete the DNT on the next pass (assuming it has no other
    // references).

    for ( i = 0; (0 == dwErr) && (i < 2); i++ )
    {
        SYNC_TRANS_WRITE();
                                            
        __try
        {
            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            // Allow for deletion of REAL_OBJECTs and PHANTOMs.

            if ( (0 != dwErr) && (DIRERR_NOT_AN_OBJECT != dwErr) )
            {
                if (0 == i)
                {
                    _Fail("Can't find object to physically delete", dwLine);
                }

                leave;
            }

            if ( DBPhysDel(pTHStls->pDB, TRUE, NULL) )
            {
                _Fail("PhysicallyDeleteObject", dwLine);
                leave;
            }
        }
        __finally
        {
            CLEAN_BEFORE_RETURN(0);
        }
    }
}

void
RefCountTestSetup(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       cbDomainRoot = 0;
    DSNAME *    pdnDomainRoot = NULL;
    UUID        uuid;
    LPWSTR      pwszUuid;
    NTSTATUS    NtStatus;

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot);
    if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
        pdnDomainRoot = (DSNAME *)THAllocEx(pTHS, cbDomainRoot);
    } else {
        Fail("GetConfigurationName");
        return;
    }

    if (GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot))
    {
        THFree(pdnDomainRoot);
        Fail("GetConfigurationName");
        return;
    }

    DsUuidCreate( &uuid );
    UuidToStringW( &uuid, &pwszUuid );

    AppendRDN(
        pdnDomainRoot,
        TestRoot,
        TEST_ROOT_SIZE,
        pwszUuid,
        lstrlenW( pwszUuid ),
        ATT_COMMON_NAME
        );

    RpcStringFreeW( &pwszUuid );
    THFree(pdnDomainRoot);

    CommonAddObject( TestRoot, CLASS_CONTAINER );
}
    

// this test setup created an organizational Unit as the test container
// this allows us to create other OU's under this.
void
RefCountTestSetup2(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       cbDomainRoot = 0;
    DSNAME *    pdnDomainRoot = NULL;
    UUID        uuid;
    LPWSTR      pwszUuid;
    NTSTATUS    NtStatus;

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot);
    if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
        pdnDomainRoot = (DSNAME *)THAllocEx(pTHS, cbDomainRoot);
    } else {
        Fail("GetConfigurationName");
        return;
    }

    if (GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot))
    {
        THFree(pdnDomainRoot);
        Fail("GetConfigurationName");
        return;
    }

    DsUuidCreate( &uuid );
    UuidToStringW( &uuid, &pwszUuid );

    AppendRDN(
        pdnDomainRoot,
        TestRoot,
        TEST_ROOT_SIZE,
        pwszUuid,
        lstrlenW( pwszUuid ),
        ATT_ORGANIZATIONAL_UNIT_NAME
        );

    RpcStringFreeW( &pwszUuid );
    THFree(pdnDomainRoot);

    CommonAddObject( TestRoot, CLASS_ORGANIZATIONAL_UNIT );
}

void
RefCountTestCleanup(void)
{
    LogicallyDeleteObject( TestRoot );
    PhysicallyDeleteObject( TestRoot );
    VerifyRefCount( TestRoot, DOESNT_EXIST, 0 );
}
    
DWORD
GetTestRootRefCount()
{
    DWORD   cRefs = 0xffffffff;
    DWORD   cRead;
    DWORD   dwErr;

    SYNC_TRANS_READ();

    __try
    {
        __try
        {
            dwErr = DBFindDSName(pTHStls->pDB, TestRoot);
        }
        __except (HandleMostExceptions(GetExceptionCode()))
        {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }

        if ( dwErr )
        {
            Fail("Can't find test root");
            leave;
        }

        if ( DBGetSingleValue(pTHStls->pDB,
                              FIXED_ATT_REFCOUNT,
                              &cRefs,
                              sizeof(cRefs),
                              &cRead) )
        {
            Fail("Can't read ref count");
            leave;
        }

        Assert(sizeof(cRefs) == cRead);
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    return(cRefs);
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Phantom update refcount test
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
PhantomUpdateTest(void)
/*++

Routine Description:

    If we add a value to the ATT_DN_REFERENCE_UPDATE attribute, and the DN being
    added has a GUID and a string name in it, we will compare the string name in
    the DN to the string name of the real object in the DIT.  If it is
    different, we will update whatever changed: The RDN, the PDNT, and/or the
    SID.

    In the cases where we don't change the PDNT, the refcount should just go up
    by one on the phantom (since we are adding the DSNAME as a value.)  If we do
    change the PDNT, then we need to make sure the refcount of the old parent
    goes down by one and the refcount of the new parent goes up by one.  There
    are two interesting cases.  The new parent may already exist, or it may
    not.  If it doesn't we create a new structural phantom.

    This test stresses this code path by first creating a phantom with string
    name S1 and GUID G.  We then write a value of the ATT_DN_REFERENCE_UPDATE
    attribute with S2 (where S2 just has an RDN change) and check refcounts.
    Then, S3 (where S3 has a PDNT change to an existing object, but no RDN
    change).  Then S4 (where S4 has a PDNT change and an RDN change), then
    S5(where S5 changes PDNT to a non-existant object, and has no RDN change).
    Finally, to S6 (where S6 changes PDNT to a non-existant object and has an
    RDN change).

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err;
    DSNAME *    pdnContainer;
    DSNAME *    pdnFakeSubContainer1;
    DSNAME *    pdnFakeSubContainer2;
    DSNAME *    pdnHost;
    DSNAME *    pdnHost2;
    DSNAME *    pdnRealSubContainer;
    DSNAME *    pdnRefConflict;
    DSNAME *    pdnRefConflict2;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnRef3;
    DSNAME *    pdnRef4;
    DSNAME *    pdnRef5;
    DSNAME *    pdnRef6;
    DSNAME *    pdnRef7;
    DSNAME *    pdnRef1Conflict;
    DSNAME *    pdnUpdateObj;

    NewTest("PhantomUpdateTest");

    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnHost2 = MakeObjectNameEx( "Host2", TestRoot );
    pdnUpdateObj = MakeObjectNameEx( "UpdateObj", TestRoot );
    pdnContainer = MakeObjectNameEx2( "OU=Container", TestRoot );
    pdnRealSubContainer = MakeObjectNameEx( "RealSubContainer", pdnContainer );
    pdnFakeSubContainer1 =MakeObjectNameEx( "FakeSubContainer1", pdnContainer );
    pdnFakeSubContainer2 =MakeObjectNameEx( "FakeSubContainer2", pdnContainer );
    pdnRef1 = MakeObjectNameEx( "RefVer1", pdnContainer); // Original
    pdnRef2 = MakeObjectNameEx( "RefVer2", pdnContainer); // RDN change
    pdnRef3 = MakeObjectNameEx( "RefVer2", pdnRealSubContainer); // PDNT change
    pdnRef4 = MakeObjectNameEx( "RefVer3", pdnContainer); // PDNT, RDN
    pdnRef5 = MakeObjectNameEx( "RefVer3", pdnFakeSubContainer1);
    pdnRef6 = MakeObjectNameEx( "RefVer4", pdnFakeSubContainer2);
    pdnRef7 = MakeObjectNameEx2( "OU=RefVer1", pdnContainer); // RDN type change
    pdnRef1Conflict = MakeObjectNameEx( "RefConflict", pdnContainer);
    
    pdnRefConflict = MakeObjectNameEx( "RefConflict", pdnContainer);
    pdnRefConflict2 = MakeObjectNameEx( "RefVer1", pdnContainer);
    
    
    DsUuidCreate( &pdnRef1->Guid );
    pdnRef2->Guid = pdnRef1->Guid;
    pdnRef3->Guid = pdnRef1->Guid;
    pdnRef4->Guid = pdnRef1->Guid;
    pdnRef5->Guid = pdnRef1->Guid;
    pdnRef6->Guid = pdnRef1->Guid;
    pdnRef7->Guid = pdnRef1->Guid;
    pdnRef1Conflict->Guid = pdnRef1->Guid;
    
    DsUuidCreate( &pdnRefConflict->Guid );
    pdnRefConflict2->Guid = pdnRefConflict->Guid;

    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gNonLinkedAttrTyp = RefUnderContainer
    //  |
    //  |--Host2
    //  |   >> gNonLinkedAttrTyp = RefUnderContainer2
    //  |
    //  |--UpdateObj
    //  |
    //  |--OU=Container
    //      |
    //      |--RealSubContainer
    //      |
    //      |--RefUnderContainer {Phantom}
    //      |
    //      |--RefUnderContainer2 {Phantom}

    CommonAddObject( pdnContainer, CLASS_ORGANIZATIONAL_UNIT );
    CommonAddObject( pdnRealSubContainer, CLASS_CONTAINER );
    CommonAddObject( pdnUpdateObj, CLASS_CONTAINER );
    AddPropertyHost( pdnHost, NonLinkedProperty );
    AddPropertyHost( pdnHost2, NonLinkedProperty );

    // Write host 2 
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost2 );
        if ( err ) Fail( "Can't find host2" );

        err = DBAddAttVal( pTHS->pDB, gNonLinkedAttrTyp,
                           pdnRefConflict->structLen,
                           pdnRefConflict );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Write S1
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gNonLinkedAttrTyp,
                           pdnRef1->structLen,
                           pdnRef1 );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    
    // Write S2
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef2->structLen,
                          pdnRef2);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef2 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S3
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the PDNT.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef2->structLen,
                          pdnRef2);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef3->structLen,
                          pdnRef3);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    
    VerifyStringName( pdnRef3 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S4
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN and PDNT
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef3->structLen,
                          pdnRef3);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef4->structLen,
                          pdnRef4);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    
    VerifyStringName( pdnRef4 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S5
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the PDNT to a newly create
    // phantom. 
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef4->structLen,
                          pdnRef4);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef5->structLen,
                          pdnRef5);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyStringName( pdnRef5 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 1 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    // Rember that pdnContainer lost a direct phantom child, but gained a new
    // phantom child via the newly created phantom container.
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Write S6
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN and the PDNT to a newly
    // created phantom.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef5->structLen,
                          pdnRef5);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef6->structLen,
                          pdnRef6);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyStringName( pdnRef6 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 1 );
    // Rember that pdnContainer gained another new phantom child via the newly
    // created phantom container. 
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Now, move pdnRef1 back to being directly under the container
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef6->structLen,
                          pdnRef6);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Write S7
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN type.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef7->structLen,
                          pdnRef7);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef7 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef7, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Now, move pdnRef1 back to being directly under the container
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef7->structLen,
                          pdnRef7);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Now, swap string names between pdnRef1 and pdnRefConflict
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN and the PDNT to a newly
    // created phantom.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1Conflict->structLen,
                          pdnRef1Conflict);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRefConflict2->structLen,
                          pdnRefConflict2);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef1Conflict );
    VerifyStringName( pdnRefConflict2 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 2 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    
    // Remove our test objects.
    LogicallyDeleteObject( pdnHost2 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    LogicallyDeleteObject( pdnHost );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    LogicallyDeleteObject( pdnRealSubContainer );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 1 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    LogicallyDeleteObject( pdnUpdateObj );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 1 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, TOMBSTONE, 1 );

    PhysicallyDeleteObject( pdnUpdateObj );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );    
    
    PhysicallyDeleteObject( pdnRef1 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );

    PhysicallyDeleteObject( pdnRefConflict );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );
    
    PhysicallyDeleteObject( pdnFakeSubContainer1 );
    PhysicallyDeleteObject( pdnFakeSubContainer2 );
    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );

    
    LogicallyDeleteObject( pdnContainer );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );


    
    PhysicallyDeleteObject( pdnHost2 );
    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnRealSubContainer );
    PhysicallyDeleteObject( pdnContainer );

    VerifyRefCount( pdnHost2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnHost, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );    

    FreeObjectName( pdnContainer );
    FreeObjectName( pdnFakeSubContainer1 );
    FreeObjectName( pdnFakeSubContainer2 );
    FreeObjectName( pdnHost );
    FreeObjectName( pdnRealSubContainer );
    FreeObjectName( pdnRefConflict );
    FreeObjectName( pdnRefConflict2 );
    FreeObjectName( pdnRef1Conflict );
    FreeObjectName( pdnRef1 );
    FreeObjectName( pdnRef2 );
    FreeObjectName( pdnRef3 );
    FreeObjectName( pdnRef4 );
    FreeObjectName( pdnRef5 );
    FreeObjectName( pdnRef6 );
    FreeObjectName( pdnUpdateObj );


    ReportTest("PhantomUpdateTest");
}


//////////////////////////////////////////////////////////////////////
//                                                                  //
// Public entry point.                                              //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
TestReferenceCounts(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       dwException;
    ULONG       ulErrorCode;
    ULONG       dsid;
    PVOID       dwEA;
    ATTCACHE    *pAC;

    Assert(VALID_THSTATE(pTHS));

    // Validate our linked and non-linked DSNAME-valued properties.
    Assert((pAC = SCGetAttById(pTHS, gNonLinkedAttrTyp)) && pAC->ulLinkID);
    Assert((pAC = SCGetAttById(pTHS, gLinkedAttrTyp)) && !pAC->ulLinkID);

    if(!pTHS->phSecurityContext) {
        // No security context virtually guarantees all your Logical Deletes
        // will fail.
        DPRINT( 0, "RefCount tests should not be run without a binding.\n");
        return;
    }
    
    __try
    {
        RefCountTestSetup();

        PhantomRenameOnPromotionWithStructuralCollision(LinkedProperty);
        PhantomRenameOnPromotionWithStructuralCollision(NonLinkedProperty);

        UnmangleRDNTest();
        
        NestedTransactionEscrowedUpdateTest();

        ParentChildRefCountTest();
        ObjectCleaningRefCountTest();
        PhantomRenameOnPromotionTest();
        NameCollisionTest();
        RefPhantomSidUpdateTest();
        StructPhantomGuidSidUpdateTest();
        ObjectSidNoUpdateTest();
        ConflictedNcNameFixupTest( FALSE /*phantom*/ );
        ConflictedNcNameFixupTest( TRUE /*subref*/ );

        AttributeTestForRealObject(LinkedProperty);
        AttributeTestForDeletedObject(LinkedProperty);
        AttributeTestForDeletedHost(LinkedProperty);
        PhantomPromotionDemotionTest(LinkedProperty);

        AttributeTestForRealObject(NonLinkedProperty);
        AttributeTestForDeletedObject(NonLinkedProperty);
        AttributeTestForDeletedHost(NonLinkedProperty);
        PhantomPromotionDemotionTest(NonLinkedProperty);


        RefCountTestCleanup();

        // second test round
        // we create a different test hierarchy, since we
        // are very dependent on the type of class under 
        // which these the test objects are created
        // these three calls should be together
        // 
        RefCountTestSetup2();
        PhantomUpdateTest();
        PhantomRenameOnPhantomRDNConflict();
        RefCountTestCleanup();
    }
    __except(GetExceptionData(GetExceptionInformation(), 
                             &dwException,
                             &dwEA, 
                             &ulErrorCode, 
                             &dsid)) 
    {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\samdsply.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       samdsply.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains DS side services for  implementing the Display Information
    API from the DS.



Author:

    Murli Satagopan   (Murlis)  17 December 1996

Environment:

    User Mode - Win32

Revision History:



--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>
#include <mappings.h>
#include <objids.h>
#include <direrr.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <dbglobal.h>
#include <dbintrnl.h>

#include <fileno.h>
#define  FILENO FILENO_SAM

#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>


#define DEBSUB      "SAMDSPLY:"

#define MAX_INDEX_LENGTH 256

 //
 // Macro to guard against inconsistent returns by Jet, while querying fractional positions
 // This checks wether
 //    1. Denominator is 0
 //    2. Numerator is greater than Denominator
 //    3. Wether fractional position is monotonically increasing, from previous value
 //

#define GUARD_FRACTIONAL_POSITION(prevN,prevD,N,D)\
    {\
        if (D==0)\
        {\
            D=1;\
        }\
        if (N>D)\
        {\
            N=D;\
        }\
        if ((((double)(prevN))/((double)(prevD)))>(((double)(N))/((double)(D))))\
        {\
            D=prevD;\
            N=prevN;\
        }\
     }


NTSTATUS
SampGetDisplayEnumerationIndex(
      IN    DSNAME                    *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING        Prefix,
      OUT   PULONG                     Index,
      OUT   PRESTART                   *RestartToReturn
      )
/*++

Routine Description:

    This helps implement QueryDisplayEnumerationIndex. Since it is a hopeless
    task in Jet to give an accurate offset of the object in the data table.
    This routine does the following

    1. Returns a number that signifies the offset of the object, depending upon type
       in the table
    2. Generates a Restart structure which allows QueryDisplayInformation to restart
       the search beginning from the object. The caller of this routine manipulates
       the state in the domain context, such that QueryDisplayInformation can restart
       the search, if the client came back with the value of the index that was returned.

Parameters:

    DomainName - Domain object's Name

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.

    RestartToReturn -- Returns a pointer to a restart structure which can be used
    to reposition the search by QueryDisplayInformation.


Return Values:

    STATUS_SUCCESS - normal, successful completion.
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INTERNAL_ERROR
    STATUS_UNSUCCESSFUL

--*/
{

    ULONG SamAccountType;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PRESTART    pRestart;
    DWORD       dwError;

    *Index = 0;

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
    case DomainDisplayOemUser:
        SamAccountType = SAM_NORMAL_USER_ACCOUNT;
        break;

    case DomainDisplayMachine:
        SamAccountType = SAM_MACHINE_ACCOUNT;
        break;

    case DomainDisplayGroup:
    case DomainDisplayOemGroup:
        SamAccountType = SAM_GROUP_OBJECT;
        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // We should already be in a transaction by now
    //

    __try
    {
        if (SampExistsDsTransaction())
        {
            THSTATE     *pTHS = pTHStls;

            //
            // Position on the the domain object.
            //

            dwError=DBFindDSName(pTHS->pDB,DomainName);
            if (!dwError)
            {
                ULONG   NcDnt;
                INDEX_VALUE IV[3];
                BOOLEAN Match = FALSE;
                RESOBJ *pResObj;


                // Whilre we're still positioned on the search root, create
                // a RESOBJ for use in creating the restart
                pResObj = CreateResObj(pTHS->pDB,
                                       DomainName);

                //
                //  Get the NC value of the base object. For Display information,
                //  our base object is the domain object. Since the domain object
                //  is the head of a naming context, the DNT value itself is the NCDNT
                //  value
                //

                NcDnt = pTHS->pDB->DNT;

                //
                // Set the current Index such that we may search on the passed in prefix
                //
                dwError  = DBSetCurrentIndex(
                                pTHS->pDB,
                                Idx_NcAccTypeName,
                                NULL,
                                FALSE
                                );
                if (dwError)
                {
                    //
                    // We know we have this index
                    //

                    NtStatus = STATUS_INTERNAL_ERROR;
                    goto Error;
                }

                //
                //  Our index is in place . Now seek to a value greater than or equal to
                //  the value specified in the prefix
                //

                IV[0].pvData = &NcDnt;
                IV[0].cbData = sizeof(ULONG);
                IV[1].pvData = &SamAccountType;
                IV[1].cbData = sizeof(ULONG);
                IV[2].pvData = Prefix->Buffer;
                IV[2].cbData = Prefix->Length;

                //
                // Seek to the first object in the index that satisfies the prefix
                //

                dwError = DBSeek(
                            pTHS->pDB,
                            IV,
                            sizeof(IV)/sizeof(IV[0]),
                            DB_SeekGE
                            );

#if DBG
                if (0 == dwError)
                {
                    DWORD cbKey = 0;
                    //
                    // Just for grins, verify that this key wasn't too long
                    //
                    
                    DBGetKeyFromObjTable(pTHS->pDB, NULL, &cbKey);
                    Assert(cbKey <= DB_CB_MAX_KEY);
                }
#endif

                //
                // Now check the NC-Name and Account Type, both should
                // match our criteria.
                //

                if (0==dwError)
                {
                    //
                    // O.K. we have positioned ourselves on some record.
                    // Try to see if it satisfies the NC NAME
                    // 
                    if (NcDnt == pTHS->pDB->NCDNT)
                    {
                        ULONG  CurrentSamAccountType;

                        //
                        // if it satisfies the SAM_ACCOUNT_TYPE.
                        //
                        dwError = DBGetSingleValue(
                                    pTHS->pDB,
                                    ATT_SAM_ACCOUNT_TYPE,
                                    (PUCHAR) &CurrentSamAccountType,
                                    sizeof(ULONG),
                                    NULL
                                    );

                        if ((0==dwError) && (SamAccountType==CurrentSamAccountType))
                        {
                            //
                            // The object matches the SAM account type criteria
                            //
                            Match = TRUE;
                        }
                        else
                        {
                            //
                            // The object does not match the criteria (AccountType) 
                            //
                            Match = FALSE;
                        }
                    }
                    else
                    {
                        //
                        // The Object does not match the NC Name criteria
                        // 
                        Match = FALSE;
                    }
                }


                if ((Match) && (0==dwError))
                {
                    //
                    // Because DBCreateRestartForSAM() will position on the next entry.
                    // We need to manually move to the previous object at here, then
                    // create restart structure.  
                    //
                    dwError = DBMove(pTHS->pDB, FALSE, DB_MovePrevious); 
                    
                    if (dwError)
                    {
                        // 
                        // move out of bound
                        // 
                        *Index=0;
                        *RestartToReturn = 0;
                        NtStatus = STATUS_SUCCESS;
                        goto Error;
                    }

                    // set the Index to the current object DNT
                    // the current object is the last un-matched object
                    // Set the index to the one used by SampDsQueryDisplayInformation.
                    *Index = pTHS->pDB->DNT;


                    //
                    // Now we are on the last un-matched object, the very next object
                    // should match all criteria.
                    // Create a restart structure that can be used by SampDsQueryDisplayInformation
                    //

                    //
                    // Maintain Currency.
                    //

                    dwError  = DBSetCurrentIndex(
                                    pTHS->pDB,
                                    Idx_NcAccTypeName,
                                    NULL,
                                    TRUE
                                    );
                    if (dwError)
                    {
                        //
                        // We do know that we have this index
                        //
                        Assert(FALSE);
                        NtStatus = STATUS_INTERNAL_ERROR;
                        goto Error;
                    }



                    if(DBCreateRestartForSAM(pTHS->pDB,
                                             &pRestart,
                                             Idx_NcAccTypeName,
                                             pResObj,
                                             SamAccountType)) {
                       //
                       // Status internal error,as if we got this far, we must
                       // have the object asked by the Seek
                       //

                       Assert(FALSE);
                       NtStatus = STATUS_INTERNAL_ERROR;
                       goto Error;
                    }

                    // We only needed this for the restart.
                    THFreeEx(pTHS, pResObj);

                    //
                    // O.K. we have the restart structure now.
                    // 
                    *RestartToReturn = pRestart;

                }
                else if ((DB_ERR_RECORD_NOT_FOUND==dwError) || ((0==dwError) && (!Match)))
                {
                    //
                    // We counld not find a record, try to position the Index
                    // as the last unmatched DNT
                    // 
                    dwError = DBMove(pTHS->pDB, FALSE, DB_MovePrevious); 

                    if (0 == dwError)
                    {
                        *Index = pTHS->pDB->DNT;
                    }
                    else
                    {
                        *Index = 0;
                    }

                    *RestartToReturn = NULL;
                    NtStatus = STATUS_NO_MORE_ENTRIES;
                    goto Error;
                }
                else
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                }
            }
            else
            {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
        }
     }
  __except (HandleMostExceptions(GetExceptionCode()))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


Error:

    return NtStatus;

}



NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    )
/*++

  Routine Description

        This routine sets hints in pthsls for DBlayer to use, in order to speed up
        enumeration and display operations.

  Parameters

        IndexTypeToUse -- Specifies the index
        LowlimitLength -- The length of the low limit parameter
        LowLimit       -- The low limit paramter
        HighlimitLength-- The length of the high limit parameter
        HighLimit      -- The high limit parameter
        RootOfSearchIsNcHead -- Indicates that the root of search is an NC head. This
                          speeds up the whole subtree search, as we need not walk ancestors
--*/
{
    THSTATE     *pTHS=pTHStls;
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (NULL!=pTHS)
    {

        __try
        {
            SAMP_SEARCH_INFORMATION *pSamSearchInformation = NULL;

            pSamSearchInformation =
                THAllocEx(pTHS, sizeof(SAMP_SEARCH_INFORMATION));

            if (NULL!=pSamSearchInformation)
            {

                if ARGUMENT_PRESENT(HighLimit1)
                {
                    pSamSearchInformation->HighLimitLength1 = HighLimitLength1;
                    pSamSearchInformation->HighLimit1
                            = THAllocEx(pTHS, HighLimitLength1);
                    RtlCopyMemory(
                        pSamSearchInformation->HighLimit1,
                        HighLimit1,
                        HighLimitLength1
                        );
                }

                if ARGUMENT_PRESENT(HighLimit2)
                {
                    pSamSearchInformation->HighLimitLength2 = HighLimitLength2;
                    pSamSearchInformation->HighLimit2
                            = THAllocEx(pTHS, HighLimitLength2);
                    RtlCopyMemory(
                        pSamSearchInformation->HighLimit2,
                        HighLimit2,
                        HighLimitLength2
                        );
                }

                if (ARGUMENT_PRESENT(LowLimit1))
                {
                    pSamSearchInformation->LowLimitLength1 = LowLimitLength1;
                    pSamSearchInformation->LowLimit1
                            = THAllocEx(pTHS, LowLimitLength1);
                    RtlCopyMemory(
                        pSamSearchInformation->LowLimit1,
                        LowLimit1,
                        LowLimitLength1
                        );
                }

                if (ARGUMENT_PRESENT(LowLimit2))
                {
                    pSamSearchInformation->LowLimitLength2 = LowLimitLength2;
                    pSamSearchInformation->LowLimit2
                            = THAllocEx(pTHS, LowLimitLength2);
                    RtlCopyMemory(
                        pSamSearchInformation->LowLimit2,
                        LowLimit2,
                        LowLimitLength2
                        );
                }


                pSamSearchInformation->IndexType = IndexTypeToUse;
                pSamSearchInformation->bRootOfSearchIsNcHead = (RootOfSearchIsNcHead != 0);

                //
                // In place Swap the Sid
                //

                if (SAM_SEARCH_SID==IndexTypeToUse)
                {
                    // The first argument is the SID
                    InPlaceSwapSid(pSamSearchInformation->HighLimit1);
                    InPlaceSwapSid(pSamSearchInformation->LowLimit1);
                }
                else
                {
                    if ((SAM_SEARCH_NC_ACCTYPE_SID == IndexTypeToUse) ||
                        (SAM_SEARCH_NC_ACCTYPE_NAME == IndexTypeToUse) )
                    {
                        // The second argument is the SID if presented.
                        if (NULL!=pSamSearchInformation->HighLimit2)
                        {
                             InPlaceSwapSid(pSamSearchInformation->HighLimit2);
                        }

                        if (NULL!=pSamSearchInformation->LowLimit2)
                        {
                             InPlaceSwapSid(pSamSearchInformation->LowLimit2);
                        }
                    }
                }


            }

            pTHS->pSamSearchInformation = (PVOID) pSamSearchInformation;
        }
        __except (HandleMostExceptions(GetExceptionCode()))
        {
            //
            // Only way we will reach here is memory alloc failure
            //
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return NtStatus;
}

NTSTATUS
SampGetAccountCounts(
	DSNAME * DomainObjectName,
    BOOLEAN  GetApproximateCount, 
	int    * UserCount,
	int    * GroupCount,
	int    * AliasCount
	)
/*++

    Routine Description:

        This Routine Uses Jet Fractional Position to Retrieve SAM account count
        counts.

    Parameters:

        DomainObjectName -- DSNAME of the domain object
        GetApproximateCount -- Indicate we don't need the exact value, so don't
                               make the expensive DBGetIndexSize()
        UserCount        -- The Count of Users in returned in Here
        GroupCount       -- The Count of Groups is returned in Here
        AliasCount       -- The Count of Aliases is returned in Here.

    Return Values

        STATUS_SUCCESS
        STATUS_INTERNAL_ERROR
--*/
{
	NTSTATUS	NtStatus = STATUS_SUCCESS;
    ULONG       dwError=0;
	ULONG       SamAccountType;
    ULONG       GroupNum=0,
                GroupDen=1,
                AliasNum=0,
                AliasDen=1,
                UserNum = 0,
                UserDen =1;
    ULONG       NcDnt;
    INDEX_VALUE IV[2];
    THSTATE     *pTHS;
    ULONG       IndexSize;




    Assert(SampExistsDsTransaction());

    pTHS = pTHStls;

    //
    // Initialize Return Values
    //

    *UserCount= 0;
    *GroupCount= 0;
    *AliasCount=0;

    __try
    {
	    //
	    // Obtain the NC of the Domain Object
	    //

        dwError=DBFindDSName(pTHS->pDB,DomainObjectName);
        if (0!=dwError)
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            goto Error;
        }


        //
        // DB find DS Name gets the DNT and PDNT in pDB
        //

	    //
        //  Get the NC value of the domain object. Since the domain object
        //  is the head of a naming context, the DNT value itself is the NCDNT
        //  value
        //

        NcDnt = pTHS->pDB->DNT;


        //
        // Set the current Index such that we may search on the passed in prefix
        //
        dwError  = DBSetCurrentIndex(
                        pTHS->pDB,
                        Idx_NcAccTypeSid,
                        NULL,
                        FALSE
                        );
        if (dwError)
        {
            //
            // We know we have this index
            //

            NtStatus = STATUS_INTERNAL_ERROR;
            goto Error;
        }

        if (!GetApproximateCount)
        {
            //
            //  Our index is in place . Get the more accurate index size
            //

            DBGetIndexSize(pTHS->pDB,&IndexSize);
        }


        //
        // First Target the group Count
        //

	    SamAccountType = SAM_GROUP_OBJECT;
        IV[0].pvData = &NcDnt;
        IV[0].cbData = sizeof(ULONG);
        IV[1].pvData = &SamAccountType;
        IV[1].cbData = sizeof(ULONG);


        //
        // Seek to the first object in the index that has a sam account type
	    // value greater than a group
        //


        dwError = DBSeek(
                    pTHS->pDB,
                    IV,
                    sizeof(IV)/sizeof(IV[0]),
                    DB_SeekGT
                    );

	    if (0==dwError)
	    {
		    //
		    // Seek was successful, get fractional position at this point
		    //

		    DBGetFractionalPosition(pTHS->pDB,&GroupNum,&GroupDen);
            GUARD_FRACTIONAL_POSITION(0,1,GroupNum,GroupDen);

            //
            // Now Seek to the End of the Alias Range
            //

            SamAccountType = SAM_ALIAS_OBJECT;
            IV[0].pvData = &NcDnt;
            IV[0].cbData = sizeof(ULONG);
            IV[1].pvData = &SamAccountType;
            IV[1].cbData = sizeof(ULONG);

            dwError = DBSeek(
                        pTHS->pDB,
                        IV,
                        sizeof(IV)/sizeof(IV[0]),
                        DB_SeekGT
                        );
		    if (0==dwError)
            {
                //
                // Seek was successful, get fractional position at this point
                //

                DBGetFractionalPosition(pTHS->pDB,&AliasNum,&AliasDen);
                GUARD_FRACTIONAL_POSITION(GroupNum,GroupDen,AliasNum,AliasDen);

                //
                // Seek for the end of the user range
                //

                SamAccountType = SAM_ACCOUNT_TYPE_MAX;
                IV[0].pvData = &NcDnt;
                IV[0].cbData = sizeof(ULONG);
                IV[1].pvData = &SamAccountType;
                IV[1].cbData = sizeof(ULONG);

                dwError = DBSeek(
                            pTHS->pDB,
                            IV,
                            sizeof(IV)/sizeof(IV[0]),
                            DB_SeekGT
                            );
                if (0!=dwError)
                {
                    //
                    // Could not go past, end of SAM account type range. This is normal
                    // and expected in a DC hosting only a single domain
                    //

                    UserNum = 1;
                    UserDen = 1;
                }
                else
                {
                    DBGetFractionalPosition(pTHS->pDB,&UserNum,&UserDen);
                    GUARD_FRACTIONAL_POSITION(AliasNum,AliasDen,UserNum,UserDen);

                }

            }
            else
            {
                //
                // Well could not go past alias range. Means that there are no users at
                // this point
                //

                AliasNum=1;
                AliasDen=1;
            }
        }
        else
        {
            //
            // Well , could not go past group range. Means that there are no aliases and users at
            // this point
            //

            GroupNum=1;
            GroupDen=1;
        }

        if (GetApproximateCount)
        {
            //
            // use the avarage of three denominators as the IndexSize
            // 
            IndexSize = (GroupDen + AliasDen + UserDen) / 3;
        }

        //
        // Now based on the fractional positons and index sizes calculate the counts
        //

        *GroupCount = (int)((double) GroupNum/ (double)GroupDen * IndexSize);
        *AliasCount = (int)((double) AliasNum/ (double)AliasDen * IndexSize) - *GroupCount;
        *UserCount =  (int)((double) UserNum/ (double)UserDen * IndexSize) - *GroupCount - *AliasCount;

    }
     __except (HandleMostExceptions(GetExceptionCode()))
    {
        //
        // Only way we will reach here is memory alloc failure
        //
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
Error:

    return (NtStatus);

}




NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation, 
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    )
/*++
Routine Description:

    This routine creates a fake restart structure for 
    SampDsQueryDisplayInformation() according the the LastObjectDNT.
    
Parameters:

    DomainName -- DSName of the Domain
    
    DisplayInforamtion -- Information Lever

    LastObjectDNT -- DNT of the last object returned

    ppRestart -- point to the restart structure.

Return Values:

    Ntstatus
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PRESTART    pRestart = NULL;
    ULONG       SamAccountType;
    DWORD       dwError;

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
    case DomainDisplayOemUser:
        SamAccountType = SAM_NORMAL_USER_ACCOUNT;
        break;

    case DomainDisplayMachine:
        SamAccountType = SAM_MACHINE_ACCOUNT;
        break;

    case DomainDisplayGroup:
    case DomainDisplayOemGroup:
        SamAccountType = SAM_GROUP_OBJECT;
        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // We should already be in a transaction by now
    //

    __try
    {
        if (SampExistsDsTransaction())
        {
            THSTATE     *pTHS = pTHStls;
            RESOBJ      *pResObj;
            ULONG       CurrentSamAccountType;

            dwError = DBFindDSName(pTHS->pDB, DomainName);

            if (dwError)
            {
                // Failed to find the domain object
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;

            }

            //
            // for creating the restart structure
            // 

            pResObj = CreateResObj(pTHS->pDB,
                                   DomainName);

            //
            // locate the last returned object
            // 

            dwError = DBFindDNT(pTHS->pDB, LastObjectDNT);

            if (dwError)
            {
                DPRINT2(0,"Failed at DBFindDNT DNT: %d Error: %d\n", LastObjectDNT, dwError);
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Now, we are on the last returned object
            // Try to retrieve the SAM Account Type.
            // If this object doesn't have SAM account type (means it 
            // was deleted) We will try to get the account name, 
            // use the account name as Prefix to create a restart
            //  
            // otherwise if this object has account type.
            // then we will set the index, create the restart without
            // searching the prefix
            // 

            dwError = DBGetSingleValue(pTHS->pDB,
                                       ATT_SAM_ACCOUNT_TYPE,
                                       (PVOID) &CurrentSamAccountType,
                                       sizeof(ULONG),
                                       NULL
                                       );

            if (DB_ERR_NO_VALUE == dwError)
            {
                //
                // Don't have this value
                // 
                PUCHAR  CurrentAccountName = NULL;
                ULONG   CurrentAccountNameLen = 0;
                PWSTR   AccountNameBuffer = NULL; 
                ULONG   Index;
                RPC_UNICODE_STRING  Prefix;


                //
                // Get Account Name
                // 

                dwError = DBGetAttVal(pTHS->pDB,
                                      1,
                                      ATT_SAM_ACCOUNT_NAME,
                                      0,
                                      0,
                                      &CurrentAccountNameLen,
                                      &CurrentAccountName
                                      );

                if (dwError)
                {
                    //
                    // Failed to get the Account name, not much we can do 
                    // 
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }

                //
                // O.K. Now have the account name, create Prefix
                // 

                AccountNameBuffer = THAllocEx(pTHS, CurrentAccountNameLen);

                if (NULL == AccountNameBuffer)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    goto Error;
                }
                else
                {
                    memset(&Prefix, 0, sizeof(RPC_UNICODE_STRING));
                    memset(AccountNameBuffer, 0, CurrentAccountNameLen);
                    memcpy(AccountNameBuffer, CurrentAccountName, CurrentAccountNameLen);
                    RtlInitUnicodeString((PUNICODE_STRING)&Prefix,
                                         AccountNameBuffer);
                }

                NtStatus = SampGetDisplayEnumerationIndex(DomainName,
                                                          DisplayInformation,
                                                          &Prefix,
                                                          &Index,
                                                          ppRestart
                                                          );
            }
            else if (0 == dwError)
            {
                // 
                // Now, we know that the current object has correct Account 
                // Type. set index to NcAccTypeName and maintain currency
                // 

                dwError = DBSetCurrentIndex(pTHS->pDB, 
                                            Idx_NcAccTypeName,
                                            NULL,
                                            TRUE
                                            );

                if (dwError)
                {
                    // we do know that we have this index
                    Assert(FALSE && "Failed in DBSetCurrentIndex to NcAccTypeName")
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
                    
                //
                // create restart 
                // 
                if (DBCreateRestartForSAM(pTHS->pDB,
                                          &pRestart,
                                          Idx_NcAccTypeName,
                                          pResObj,
                                          SamAccountType
                                          ))
                {
                    DPRINT(0, "Failed at DBCreateRestartForSAM\n");
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }

                //
                // set the return value
                // 
                *ppRestart = pRestart;
                THFreeEx(pTHS, pResObj);
            }
            else
            {
                // failure to get account type for some other reason
                NtStatus = STATUS_UNSUCCESSFUL;
            }

        }//transaction

    }//__try
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    return( NtStatus );
}

NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    )
/*++
Routine Description:

    This routine will based on a Domain Handle and on the account name will
    tell if the account exists and return the user account control.
    
Parameters:

    DomainHandle - The domain where the account name can be found
    
    AccountName - The account name for which to find the useraccountcontrol
    
    AccountExists - This will tell the call if the account exists or not
    
    UserAccountControl - This will have the return of the useraccountcontrol

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    
--*/
{
    THSTATE         *pTHS = pTHStls;
    BOOL            fCommit = TRUE;
    BOOL            Found = TRUE;
    ULONG           isdel = 0;
    DWORD           samAccountType = 0;
    INDEX_VALUE     IV[1] = {0,0};
    ULONG           dbErr = 0;
    NTSTATUS        status = STATUS_SUCCESS;
    ATTCACHE*       ac = NULL;
    
    DBOpen2(TRUE, &pTHS->pDB);
    __try {

        ac = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME);
        if (ac==NULL) {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }
       
        dbErr = DBSetCurrentIndex(pTHS->pDB,
                                  (eIndexId)0,
                                  ac,
                                  FALSE
                                  );
        if (0 != dbErr) {
            status = STATUS_UNSUCCESSFUL;
            _leave;
        }
        
        IV[0].pvData = AccountName->Buffer;
        IV[0].cbData = AccountName->Length;

        dbErr = DBSeek(pTHS->pDB,
                       IV,
                       sizeof(IV)/sizeof(IV[0]),
                       DB_SeekEQ
                       );
        if (0 != dbErr) {
            Found = FALSE;
            _leave;
        }

        //It is possible to find a delete but is not a value result for
        //this search.
        dbErr = DBGetSingleValue(pTHS->pDB,
                                 ATT_IS_DELETED,
                                 &isdel,
                                 sizeof(isdel),
                                 NULL);
        if (dbErr) {
            if (DB_ERR_NO_VALUE == dbErr) {
                // Treat having no value the same as being false.
                isdel = 0;
                dbErr = 0;
            } else {

                status = STATUS_UNSUCCESSFUL;
                _leave;
            }

        }

        if ( (DomainHandle != pTHS->pDB->NCDNT) || isdel ) {
            dbErr = DBSetIndexRange(pTHS->pDB,
                                    IV,
                                    sizeof(IV)/sizeof(IV[0])
                                    );
            if (0 != dbErr) {
                status = STATUS_UNSUCCESSFUL;
                _leave;
            }
        }

        while ( (DomainHandle != pTHS->pDB->NCDNT) || isdel ) {

            dbErr = DBMove (pTHS->pDB,
                            FALSE,
                            DB_MoveNext
                            );
            if (0 != dbErr) {
                Found = FALSE;
                _leave;
            }

            //It is possible to find a delete but is not a value result for
            //this search.
            dbErr = DBGetSingleValue(pTHS->pDB,
                                     ATT_IS_DELETED,
                                     &isdel,
                                     sizeof(isdel),
                                     NULL);
            if (dbErr) {
                if (DB_ERR_NO_VALUE == dbErr) {
                    // Treat having no value the same as being false.
                    isdel = 0;
                    dbErr = 0;
                } else {
            
                    status = STATUS_UNSUCCESSFUL;
                    _leave;
            
                }
            }

        }

        dbErr = DBGetSingleValue(pTHS->pDB,
                                 ATT_SAM_ACCOUNT_TYPE,
                                 &samAccountType,
                                 sizeof(samAccountType),
                                 NULL);
        if (dbErr) {
            
            status = STATUS_UNSUCCESSFUL;
            _leave;

        }

        if (!( (SAM_NORMAL_USER_ACCOUNT == samAccountType) || 
               (SAM_MACHINE_ACCOUNT     == samAccountType) ||
               (SAM_TRUST_ACCOUNT       == samAccountType) ) )
        {
            Found = FALSE;
            _leave;    
        }

        dbErr = DBGetSingleValue(pTHS->pDB,
                                 ATT_USER_ACCOUNT_CONTROL,
                                 (PVOID)UserAccountControl,
                                 sizeof(ULONG),
                                 NULL);
        if (0 != dbErr) {
            status = STATUS_UNSUCCESSFUL;
            _leave;
        }
        
    }
    __finally {
        if (0 == dbErr && Found == TRUE) {
            *AccountExists = TRUE;
        } else {
            *AccountExists = FALSE;
        }
        DBClose(pTHS->pDB,fCommit);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\samlogon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samlogon.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the routines for implementing SampGetMemberships
    which performs recursive membership retrieval.  This is called by
    SAM when a security principal logs on. It also has routines for transitively
    expanding the membership list of a security prinicpal, same domain/cross  domain

Author:

    DaveStr     07-19-96

Environment:

    User Mode - Win32

Revision History:

    DaveStr     07-19-96
        Created

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

extern "C" {

#include <ntdsa.h>
#include <filtypes.h>
#include <mappings.h>
#include <objids.h>
#include <direrr.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <drsuapi.h>
#include <drserr.h>
#include <anchor.h>
#include <samsrvp.h>

#include <fileno.h>
#define  FILENO FILENO_SAMLOGON

#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <gcverify.h>
#include <samisrv.h>
#include <ntdsctr.h>
#include <dsconfig.h>
#include <samlogon.h>


#define DEBSUB "SAMLOGON:"


} // extern "C"

// Declare some local helper classes to manage sets of SIDs.  Implementing
// them as C++ classes makes them easier to replace in the future with
// better performing implementations.  Care is taken to allocate everything
// via thread heap instead of using the global 'new' operator in order to
// be consistent with the rest of the core DS code.  Likewise, all
// destructors are no-ops.

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CDSNameSet - Manages a set of Values.                                //
// In the original version this class managed a set of DSNames.         //
// During the course of development its utility was appreciated and     //
// this class was extended to manage value types of DSNAME DNT and SID  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


typedef enum _REVMEMB_VALUE_TYPE {
    RevMembDsName =1,
    RevMembDNT,
    RevMembSid
} REVMEMB_VALUE_TYPE;

class CDSNameSet {

private:

    ULONG   _cNames;               // count of Values in set ( DSNAMES, dnts, or SIDS)
    ULONG   _cMax;                 // count of allocated elements
    REVMEMB_VALUE_TYPE _valueType; // Indicates that the kind of values we are managing
    PVOID *_rpNames;               // array of  pointers, to either DSNAMES , dnts or SIDs

public:

    // Constructor.

    CDSNameSet();

    // Destructor.

    ~CDSNameSet() { NULL; }

    // Tell to manage internal or external names
    VOID SetValueType(REVMEMB_VALUE_TYPE ValueType) {_valueType = ValueType;}

    // Return the count of DSNAMEs currently in the set.

    ULONG Count() { return(_cNames); }

    // Retrieve a pointer to the Nth DSNAME in the set.

    PVOID Get(ULONG idx) { Assert(idx < _cNames); return(_rpNames[idx]); }

#define DSNAME_NOT_FOUND 0xFFFFFFFF

    // Determine whether a DSNAME is in the set and if so, its index.

    ULONG Find(PVOID pDSName);

    // Add a DSNAME to the set.

    VOID Add(PVOID pDSName);

    // Remove the DSNAME at a given index from the set.

    VOID Remove(ULONG idx);

    // Add if the DSNAME is not already present

    VOID CheckDuplicateAndAdd(PVOID pDSName);

    //  Returns the pointer to the array of DSName pointers
    //  that represents the set of DS Names
    PVOID * GetArray() { return _rpNames; }

    // Cleans up the DSNameSet, by free-ing the array and resetting
    // the _cNames and _cMax fields
    VOID Cleanup();
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CReverseMembership - Manages the DSNAMEs in a reverse membership.    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

class CReverseMembership {

private:

    CDSNameSet  _recursed;
    CDSNameSet  _unRecursed;

public:

    // Constructor.

    CReverseMembership(){
                          _recursed.SetValueType(RevMembDNT);
                          _unRecursed.SetValueType(RevMembDNT);
                        }

    // Destructor.

    ~CReverseMembership() { _recursed.Cleanup(); _unRecursed.Cleanup(); }

    // Add a DSNAME to the set.

    VOID Add(PVOID pDSName);

    // Retrieve the next DSNAME which has not yet been recursively processed.

    PVOID NextUnrecursed();

    // Retrieve the count of DSNAMEs in the reverse membership set.

    ULONG Count();

    // Retrieve the DSNAME at a given index from the set - does not remove it.

    PVOID Get(ULONG idx);



};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CDSNameSet - Implementation                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Define the factor by which we will grow the PDSNAME array in a CDSNameSet
// instance.  Make it small for debug builds so we test boundary conditions
// but big in a retail build for performance.

#if DBG == 1
#define PDSNAME_INCREMENT 1
#else
#define PDSNAME_INCREMENT 100
#endif

int _cdecl ComparePVOIDDNT(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two DNTs that are stored in PVOID pointers

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the value
        of a DNT array element.

    pv2 - Pointer provided by qsort or bsearch which is the value
        of a DNT array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PVOID p1 = * ((PVOID * ) pv1);
    PVOID p2 = * ((PVOID *)  pv2);
    ULONG u1 = PtrToUlong(p1);
    ULONG u2 = PtrToUlong(p2);
    ULONG   Result;

    if (u1==u2)
        return 0;

    if (u1>u2)
        return 1;

    return -1;
}

int _cdecl ComparePSID(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two SIDs.

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the address
        of a PSID array element.

    pv2 - Pointer provided by qsort or bsearch which is the address
        of a PSID array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PSID p1 = * ((PSID *) pv1);
    PSID p2 = * ((PSID *) pv2);
    ULONG   Result;



    if (RtlEqualSid(p1,p2))
    {
        return 0;
    }

    if (RtlLengthSid(p1)<RtlLengthSid(p2))
    {
        return -1;
    }
    else if (RtlLengthSid(p1) > RtlLengthSid(p2))
    {
        return 1;
    }
    else
    {
        Result = memcmp(p1,p2,RtlLengthSid(p1));
    }

    return Result;


}

int _cdecl ComparePDSNAME(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two DSNAMEs.

Arguments:

    pv1 - Pointer provided by qsort or bsearch which is the address
        of a PDSNAME array element.

    pv2 - Pointer provided by qsort or bsearch which is the address
        of a PDSNAME array element.

Return Value:

    Integer representing how much less than, equal or greater the
        first name is with respect to the second.

--*/

{
    PDSNAME p1 = * ((PDSNAME *) pv1);
    PDSNAME p2 = * ((PDSNAME *) pv2);
    ULONG   Result;



    //
    // if both have guids then compare guids
    //

    if (!fNullUuid(&p1->Guid) && !fNullUuid(&p2->Guid))
    {
        return(memcmp(&p1->Guid, &p2->Guid, sizeof(GUID)));
    }

    //
    // At least one of the two Ds Names has a SID
    //

    //
    // Assert that a SID only name cannot be a security principal
    // in the builltin domain
    //

    Assert(!fNullUuid(&p1->Guid)||(p1->SidLen==sizeof(NT4SID)));
    Assert(!fNullUuid(&p2->Guid)||(p2->SidLen==sizeof(NT4SID)));

    //
    // Compare by SID
    //

    if (RtlEqualSid(&p1->Sid,&p2->Sid))
    {
        return 0;
    }

    if (p1->SidLen<p2->SidLen)
    {
        return -1;
    }
    else if (p1->SidLen > p2->SidLen)
    {
        return 1;
    }
    else
    {
        Result = memcmp(&p1->Sid,&p2->Sid,p1->SidLen);
    }

    return Result;


}

CDSNameSet::CDSNameSet()
{
    _cNames = 0;
    _cMax = 0;
    _rpNames = NULL;
}

ULONG
CDSNameSet::Find(
    PVOID pDSName
    )
{
    PVOID *ppDSName = &pDSName;
    PVOID *pFoundName;
    ULONG   idx;
    int (__cdecl *CompareFunction)(const void *, const void *) = NULL;

    switch(_valueType)
    {
    case    RevMembDsName:
                CompareFunction=ComparePDSNAME;
                break;
    case    RevMembDNT:
                CompareFunction=ComparePVOIDDNT;
                break;

    case    RevMembSid:
                CompareFunction=ComparePSID;
                break;
    default:
                Assert(FALSE&&"InvalidValueType");

    }

    pFoundName = (PVOID *) bsearch(
                    ppDSName,
                    _rpNames,
                    _cNames,
                    sizeof(PVOID),
                    CompareFunction);

    if ( NULL == pFoundName )
    {
        return(DSNAME_NOT_FOUND);
    }

    // Convert pFoundName into an array index.

    idx = (ULONG)(pFoundName - _rpNames);

    Assert(idx < _cNames);

    return(idx);
}

VOID
CDSNameSet::Add(
    PVOID pDSName
    )
{
    THSTATE *pTHS=pTHStls;
    PVOID *ppDSName = &pDSName;
    int (__cdecl *CompareFunction)(const void *, const void *) = NULL;

    // Caller should not add duplicates - verify.

#if DBG == 1

    if ( DSNAME_NOT_FOUND != Find(pDSName) )
    {
        Assert(FALSE && "Duplicate CDSNameSet::Add");
    }

#endif

    // See if we need to (re)allocate the array of DSNAME pointers.

    if ( _cNames == _cMax )
    {
        _cMax += PDSNAME_INCREMENT;

        if ( NULL == _rpNames )
        {
            _rpNames = (PVOID *) THAllocEx(pTHS,
                                        _cMax * sizeof(PVOID));
        }
        else
        {
            _rpNames = (PVOID *) THReAllocEx(pTHS,
                                        _rpNames,
                                        _cMax * sizeof(PVOID));
        }
    }

    // Now add the new element and maintain a sorted array.

    _rpNames[_cNames++] = pDSName;

    switch(_valueType)
    {
    case    RevMembDsName:
                CompareFunction=ComparePDSNAME;
                break;
    case    RevMembDNT:
                CompareFunction=ComparePVOIDDNT;
                break;

    case    RevMembSid:
                CompareFunction=ComparePSID;
                break;

    default:
                Assert(FALSE&&"InvalidValueType");
    }

    qsort(
        _rpNames,
        _cNames,
        sizeof(PVOID),
        CompareFunction);
}

VOID
CDSNameSet::Remove(
    ULONG idx
    )
{
    Assert(idx < _cNames);

    for ( ULONG i = idx; i < (_cNames-1); i++ )
    {
        _rpNames[i] = _rpNames[i+1];
    }

    _cNames--;

    // Nothing to sort since shift-down didn't perturb sort order.
}


VOID
CDSNameSet::CheckDuplicateAndAdd(
    PVOID pDSName
    )
{
    if (DSNAME_NOT_FOUND==Find(pDSName))
    {
        Add(pDSName);
    }

    return;
}

VOID
CDSNameSet::Cleanup()
{
    if (NULL!=_rpNames)
        THFree(_rpNames);
    _rpNames = NULL;
    _cMax = NULL;
    _cNames = NULL;
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// CReverseMembership - Implementation                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
CReverseMembership::Add(
    PVOID pDSName
    )
{
    // Nothing to do if we already have this DSNAME in either the recursed
    // or !recursed set.

    if ( (DSNAME_NOT_FOUND != _unRecursed.Find(pDSName)) ||
         (DSNAME_NOT_FOUND != _recursed.Find(pDSName)) )
    {
        return;
    }

    // Add to !recursed set of DSNAMEs.

    _unRecursed.Add(pDSName);
}

PVOID
CReverseMembership::NextUnrecursed(
    void
    )
{
    ULONG   cNames;
    ULONG   idx;
    PVOID pDSName;

    cNames = _unRecursed.Count();

    if ( 0 == cNames )
    {
        return(NULL);
    }

    idx = --cNames;

    pDSName = _unRecursed.Get(idx);

    // Transfer DSNAME from !recursed to recursed set.

    _unRecursed.Remove(idx);
    _recursed.Add(pDSName);

    return(pDSName);
}

ULONG
CReverseMembership::Count(
    void
    )
{
    return(_recursed.Count() + _unRecursed.Count());
}

PVOID
CReverseMembership::Get(
    ULONG idx
    )
{
    Assert(idx < Count());

    if ( idx >= _recursed.Count() )
    {
        return(_unRecursed.Get(idx - _recursed.Count()));
    }

    return(_recursed.Get(idx));
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Helper functions                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


NTSTATUS
SampCheckGroupTypeAndDomainLocal (
        IN  THSTATE *pTHS,
        IN  ULONG    SidLen,
        IN  PSID     pSid,
        IN  DWORD    NCDNT,
        IN  DWORD    GroupType,
        IN  ATTRTYP  Class,
        IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
        IN  ULONG    LimitingNCDNT,
        IN  PSID     LimitingDomainSid,
        OUT BOOLEAN *pfMatch
        )
/*++

  Given a DNT, try to look it up in the group cache.  If we find it, do the
  check for recursive membership.

  Parameters:

  OperationType  -- The type of reverse membership operation specified
  LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                    scope to a domain
  LimitingDomanSid -- The limiting DomainSid where the operation restricts
                    the scope to a domain
  pfMatch          -- Out parameter TRUE indicates that the current object is
                    should enter the reverse membeship list and be followed
                    transitively

  Return values

  STATUS_SUCCESS
  Other error codes to indicate resource failures
--*/
{
    CLASSCACHE  *pClassCache;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       len;
    ULONG       objectRid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN     SecurityEnabled;
    ULONG       MostBasicClass;
    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    //
    // Perform the SID  Check
    //

    if (0==SidLen) {
        //
        // No Sid, then no no match
        //

        return STATUS_SUCCESS;
    }

    //
    // Sid is present and is a valid Sid
    //

    Assert(RtlValidSid((PSID) pSid));


    //
    // Filter out all builtin aliases, unless operation is
    // RevMembGetAliasMembership
    //

    objectRid = *RtlSubAuthoritySid(
            pSid,
            *RtlSubAuthorityCountSid(pSid)-1
            );

    if ((objectRid <= DOMAIN_ALIAS_RID_REPLICATOR)
        && (objectRid>=DOMAIN_ALIAS_RID_ADMINS)
        && (RevMembGetAliasMembership!=OperationType)) {
        return STATUS_SUCCESS;
    }

    // If a limiting domain SID was provided, filter SIDs
    // by domain. The limiting domain SID is important for
    // all operations except getting universal groups

    if (( NULL != LimitingDomainSid ) &&
        (OperationType!=RevMembGetUniversalGroups)) {

        NT4SID domainSid;

        SampSplitNT4SID((NT4SID *)pSid, &domainSid, &objectRid);

        if ( !RtlEqualSid(&domainSid, LimitingDomainSid) )  {
            return STATUS_SUCCESS;
        }
    }


    //
    // Perform the naming context test
    //
    if ((OperationType!=RevMembGetUniversalGroups)
        && (NCDNT!=LimitingNCDNT)) {
        //
        // Naming Context's do not match
        //

        return STATUS_SUCCESS;
    }

    //
    // Read the group type
    //
    if(!GroupType) {
        // No GroupType.
        // this means that the object is probaly
        // not a group, so does not enter token

        return(STATUS_SUCCESS);
    }


    //
    // And the actual class id.
    //

    if ( 0 == (pClassCache = SCGetClassById(pTHS, Class)) ) {
        return(STATUS_INTERNAL_ERROR);
    }

    //
    // Derive the most basic class
    //

    MostBasicClass = SampDeriveMostBasicDsClass(Class);

    //
    // Check the group type
    //

    if (SampGroupObjectType!=SampSamObjectTypeFromDsClass(MostBasicClass)) {
        //
        // The object is not a group, so does not enter the token
        //

        return STATUS_SUCCESS;
    }

    NtStatus = SampComputeGroupType(
            MostBasicClass,
            GroupType,
            &NT4GroupType,
            &NT5GroupType,
            &SecurityEnabled
            );

    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // If the group is not security enabled, bail
    //

    if (!SecurityEnabled) {
        return STATUS_SUCCESS;
    }

    //
    // Check wether the group type is correct for the specified
    // operation
    //

    switch(OperationType) {
    case RevMembGetGroupsForUser:
        if (NT4GlobalGroup!=NT4GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetAliasMembership:
        if (NT4LocalGroup!=NT4GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetAccountGroups:
        if (NT5AccountGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;
    case RevMembGetResourceGroups:
        if (NT5ResourceGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;

    case RevMembGetUniversalGroups:
        if (NT5UniversalGroup!=NT5GroupType)
            return STATUS_SUCCESS;
        break;
    }

    //
    // If we got upto here, it means that we passed the filter
    // test.
    //

    *pfMatch = TRUE;

    return STATUS_SUCCESS;

}

NTSTATUS
SampFindGroupByCache (
        IN  THSTATE *pTHS,
        IN  GUID    *pGuid,
        IN  DWORD   *pulDNT,
        IN  BOOL     fBaseObj,
        IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
        IN  ULONG    LimitingNCDNT,
        IN  PSID     LimitingDomainSid,
        IN  BOOL     bNeedSidHistory,
        OUT BOOLEAN *pfHasSidHistory,
        OUT BOOLEAN *pfMatch,
        OUT PDSNAME *ppDSName
        )
/*++

  Given a DNT, try to look it up in the group cache.  If we find it, do the
  check for recursive membership.

  Parameters:

  OperationType  -- The type of reverse membership operation specified
  LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                    scope to a domain
  LimitingDomanSid -- The limiting DomainSid where the operation restricts
                    the scope to a domain
  pfMatch          -- Out parameter TRUE indicates that the current object is
                    should enter the reverse membeship list and be followed
                    transitively

  Return values

  STATUS_SUCCESS
  Other error codes to indicate resource failures
--*/
{
    GROUPTYPECACHERECORD GroupCacheRecord;
    NTSTATUS         NtStatus = STATUS_SUCCESS;
    ULONG            len;
    DWORD            ulDNT=INVALIDDNT;

    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    if(!pulDNT) {
        pulDNT = &ulDNT;
    }

    // First, see if the object is in the cache
    if(!GetGroupTypeCacheElement(pGuid, pulDNT, &GroupCacheRecord)) {
        // failed to find the object in the cache, just return
        return STATUS_INTERNAL_ERROR;
    }

    // Get the shortdsname that's stored in the cache.
    *ppDSName = (PDSNAME)THAllocEx(pTHS, DSNameSizeFromLen(0));
    (*ppDSName)->structLen = DSNameSizeFromLen(0);
    (*ppDSName)->Guid = GroupCacheRecord.Guid;
    (*ppDSName)->Sid = GroupCacheRecord.Sid;
    (*ppDSName)->SidLen = GroupCacheRecord.SidLen;

    // Say that we have a sid history if we were asked for sid history and we
    // actually have one.  That is, if the caller didn't need the sid history
    // checked, tell him we don't have one.
    *pfHasSidHistory = (bNeedSidHistory &&
                        (GroupCacheRecord.flags & GTC_FLAGS_HAS_SID_HISTORY));

    if(!fBaseObj) {

        NtStatus = SampCheckGroupTypeAndDomainLocal (
                pTHS,
                (*ppDSName)->SidLen,
                &(*ppDSName)->Sid,
                GroupCacheRecord.NCDNT,
                GroupCacheRecord.GroupType,
                GroupCacheRecord.Class,
                OperationType,
                LimitingNCDNT,
                LimitingDomainSid,
                pfMatch);

        if(!NT_SUCCESS(NtStatus)) {
            *pfMatch = FALSE;
            return NtStatus;
        }

        if(!*pfMatch) {
            return STATUS_SUCCESS;
        }
    }

    if(!(*pfHasSidHistory)) {
        // Don't actually need to be current in the obj table since the caller
        // doesn't intend to check the SID history, or he does and the Group
        // Type Cache says that he will find no value. So just tweak the DNT in
        // the DBPOS so that we get to the correct place in the link table.

        // NOTE!!! This is highly dangerous!!! We are lying to the DBLayer,
        // telling it currency is set to a specific object in the object table.
        // We do this so that the code to read link values will pick the DNT out
        // of the DBPOS, and that code doesn't actually read from the object
        // table, just the link table.

        // We're doing this extra curicular tweaking in very controlled
        // circumstances, when we believe that no one will use the currency in
        // the object table before we re-set currency to somewhere else.  This
        // is a very likely source for bugs and unexplained behaviour later, but
        // doing it now will make us a LOT faster, and this code desperately
        // needs to be optimized.
        pTHS->pDB->DNT = *pulDNT;
    }
    else {
        DPRINT(3,"Found in the group cache, have to move anyway\n");
        //
        // If we got up to here, it means that we passed the filter
        // test.  Furthermore, the caller is going to check SID history, and the
        // cache says that one exists.  Since someone is going to read from the
        // object, we have to actually position on the object in the DIT.
        //

        // Try to find the DNT.
        if(DBTryToFindDNT(pTHS->pDB,*pulDNT)) {
            *pfMatch = FALSE;
            return STATUS_INTERNAL_ERROR;
        }

        Assert(DBCheckObj(pTHS->pDB));
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SampCheckGroupTypeAndDomain(
    IN  THSTATE *pTHS,
    IN  DSNAME  *pDSName,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN  ULONG   LimitingNCDNT,
    IN  PSID    LimitingDomainSid,
    OUT BOOLEAN *pfMatch
    )
/*++

    Given the Operation type, the limiting NCDNT and the LimitingDomainSid
    this routine determines wether the currently positioned object
    is of the right type and belongs to the correct domain, and indicate whether
    it can enter the reverse membership list and /or be followed transitively

    Parameters:

          OperationType  -- The type of reverse membership operation specified
          LimitingNCDNT  -- The limiting NCDNT where the operation restricts the
                            scope to a domain
          LimitingDomanSid -- The limiting DomainSid where the operation restricts
                              the scope to a domain
          pfMatch          -- Out parameter TRUE indicates that the current object is
                              should enter the reverse membeship list and be followed
                              transitively

    Return values

        STATUS_SUCCESS
        Other error codes to indicate resource failures
--*/
{
    ULONG       actualClass;
    ULONG       actualNCDNT;
    ULONG       actualGroupType;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    //
    // Initialize return values
    //

    *pfMatch = FALSE;

    // Get the data
    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            FIXED_ATT_NCDNT,
            &actualNCDNT,
            sizeof(actualNCDNT),
            NULL) ) {
        return(STATUS_INTERNAL_ERROR);
    }

    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            ATT_GROUP_TYPE,
            &actualGroupType,
            sizeof(actualGroupType),
            NULL) ) {

        // Cannot read the GroupType.
        // this means that the object is probaly
        // not a group, so does not enter token

        return(STATUS_SUCCESS);
    }

    if ( 0 != DBGetSingleValue(
            pTHS->pDB,
            ATT_OBJECT_CLASS,
            &actualClass,
            sizeof(actualClass),
            NULL) ) {
        // Failed to Read Object Class
        return STATUS_INTERNAL_ERROR;
    }

    NtStatus = SampCheckGroupTypeAndDomainLocal (
            pTHS,
            pDSName->SidLen,
            &pDSName->Sid,
            actualNCDNT,
            actualGroupType,
            actualClass,
            OperationType,
            LimitingNCDNT,
            LimitingDomainSid,
            pfMatch);

    if(!NT_SUCCESS(NtStatus)) {
        *pfMatch = FALSE;
        return NtStatus;
    }

    return STATUS_SUCCESS;
}

ULONG ulDNTDomainUsers=0;
ULONG ulDNTDomainComputers=0;
ULONG ulDNTDomainControllers=0;

NTSTATUS
SampGetPrimaryGroup(
    IN  THSTATE *pTHS,
    IN  DSNAME  * UserName OPTIONAL,
    OUT PULONG   pPrimaryGroupDNT)
/*++

    Routine Description

        This routine retrieves the primary group of an object.
        At input the database cursor is assumed to be positioned on
        the object. At successful return time the database cursor is
        positioned on the priamry group object

    Parameters

        UserName     - If the User's DS Name has been specified, then
                       grab the SID, from the user's DS Name as opposed
                       to reading the SID again

        PrimaryGroupDNT - DNT of the Primary Group is returned in here
                       If the object does not have a primary group then
                       the return code is SUCCESS and this parameter is
                       set to NULL
    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       PrimaryGroupIdVal;
    PULONG      PrimaryGroupId = &PrimaryGroupIdVal;
    ULONG       outLen;
    DWORD       err;
    ULONG       ulDNTToReturn=0;

    *pPrimaryGroupDNT = 0;

    //
    // At this point we are positioned on the object whose
    // primary group Id we want to retrieve. Issue a DBGetAttVal
    // to retrieve the value of Primary Group Id
    //

    err=DBGetAttVal(
                    pTHS->pDB,
                    1,
                    ATT_PRIMARY_GROUP_ID,
                    DBGETATTVAL_fCONSTANT,   // DB layer should alloc
                    sizeof(ULONG),                      // initial buffer size
                    &outLen,                // output buffer size
                    (UCHAR **) &PrimaryGroupId
                );

    if (0==err)
    {
        NT4SID  SidBuffer;
        PSID    Sid=&SidBuffer;
        NT4SID  DomainSid;
        ULONG   sidLen;
        DSNAME   PrimaryGroupDN;

        //
        // Found the Primary Group Id of the user object.
        //

        Assert(sizeof(ULONG)==outLen);

        //
        // check if primary group is one of the standard groups
        //


        switch(PrimaryGroupIdVal)
        {
        case DOMAIN_GROUP_RID_USERS:
             if (0!=ulDNTDomainUsers)
             {
                 ulDNTToReturn = ulDNTDomainUsers;
                 break;
             }

        case DOMAIN_GROUP_RID_COMPUTERS:
             if (0!=ulDNTDomainComputers)
             {
                 ulDNTToReturn = ulDNTDomainComputers;
                 break;
             }

        case DOMAIN_GROUP_RID_CONTROLLERS:
             if (0!=ulDNTDomainControllers)
             {
                 ulDNTToReturn = ulDNTDomainControllers;
                 break;
             }

        default:

            if (UserName->SidLen > 0)
            {
                //
                // Try making use of the SID in the User DN
                //

                RtlCopyMemory(Sid,&(UserName->Sid),sizeof(NT4SID));
                sidLen = RtlLengthSid(Sid);
            }
            else
            {
                //
                // Retrieve the User Object's SID
                //

                if (0!=DBGetAttVal(
                        pTHS->pDB,
                        1,
                        ATT_OBJECT_SID,
                        DBGETATTVAL_fCONSTANT,   // DB layer should alloc
                        sizeof(NT4SID),          // initial buffer size
                        &sidLen,                // output buffer size
                        (UCHAR **) &Sid
                        ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

            Assert(RtlValidSid(Sid));
            Assert(sidLen<=sizeof(NT4SID));

            //
            // Compose the Primary group object's Sid.
            // This makes the assumption the the primary group
            // and the user are in the same domain, so only their
            // Rids are affected, so munge the Rid field in the Sid
            //

            *RtlSubAuthoritySid(
                Sid,
                *RtlSubAuthorityCountSid(Sid)-1) = *PrimaryGroupId;

            //
            // Construct a Sid Only name. With full support for positioning
            // by SID we should be able to construct a Sid only name
            //

            RtlZeroMemory(&PrimaryGroupDN, sizeof(DSNAME));
            PrimaryGroupDN.SidLen = RtlLengthSid(Sid);
            RtlCopyMemory(&(PrimaryGroupDN.Sid), Sid, RtlLengthSid(Sid));
            PrimaryGroupDN.structLen = DSNameSizeFromLen(0);

            //
            // Position using the SID only Name
            //

            err = DBFindDSName(pTHS->pDB, &PrimaryGroupDN);

            if (0!=err)
            {
                //
                // Cannot find the Primary Group
                // object. This is again ok, as the group could
                // have been deleted, and since we maintain
                // no consistency wrt primary group, this can
                // happen
                //

                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            //
            // O.k We are now postioned on the primary group
            // object.Update the standard DNT's if required
            //

            ulDNTToReturn = pTHS->pDB->DNT;

            switch(ulDNTToReturn)
            {
            case DOMAIN_GROUP_RID_USERS:
                ulDNTDomainUsers = ulDNTToReturn;
                break;

            case DOMAIN_GROUP_RID_COMPUTERS:
                ulDNTDomainComputers = ulDNTToReturn;
                break;

            case DOMAIN_GROUP_RID_CONTROLLERS:
                ulDNTDomainControllers = ulDNTToReturn;
                break;
            }

        }
    }
    else if (DB_ERR_NO_VALUE==err)
    {
        //
        // We cannot give the Primary Group Id. THis is
        // ok as the object in question does not have a
        // valid primary group
        //

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        //
        // Else we must fail the call. Cannot ever give a wrong value for
        // someone's token
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    if (NT_SUCCESS(NtStatus))
    {
        *pPrimaryGroupDNT = ulDNTToReturn;
    }

    return NtStatus;

}

NTSTATUS
SampReadSidHistory(
    THSTATE    * pTHS,
    CDSNameSet * pSidHistory
    )
/*++

    Routine Description

        This Routine Reads the Sid History Off of the Currently Positioned
        object. This routine does not alter the cursor position.

    Parameters

        pSidHistory This is a pointer to a CDSNameSet Object. The SIDs
                 pertaining to SID history are added to this object. Using the
                 CDSNameSet class, allows for automatic memory allocation
                 management, plus also automatically filters out any duplicates.
                 This is actually a performance saver, because higher layers now
                 need not manually check for duplicates.

--*/
{
    ULONG   dwErr=0;
    ULONG   iTagSequence =0;
    ATTCACHE *pAC = NULL;
    ULONG    outLen;
    PSID     SidValue;
    // Get attribute cache entry for reverse membership.

    if (!(pAC = SCGetAttById(pTHS, ATT_SID_HISTORY))) {
        LogUnhandledError(ATT_SID_HISTORY);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read all the values in JET.
    // PERFHINT: at some point see if we can do everything in 1 retrieve
    // column
    //

    while (0==dwErr)
    {
        dwErr = DBGetAttVal_AC( 
                        pTHS->pDB,              // DBPos
                        ++iTagSequence,         // which value to get
                        pAC,                    // which attribute
                        DBGETATTVAL_fREALLOC,   // DB layer should alloc
                        0,                      // initial buffer size
                        &outLen,                // output buffer size
                        (UCHAR **) &SidValue);

        if (0==dwErr)
        {

            // We Successfully retrieved a Sid History value
            // Add it to the List. Construct a SID only DSNAME
            // for the SID history and add to the CReverseMembership

            Assert(RtlValidSid(SidValue));
            Assert(RtlLengthSid(SidValue)<=sizeof(NT4SID));
            pSidHistory->CheckDuplicateAndAdd(SidValue);

        }
        else if (DB_ERR_NO_VALUE==dwErr)
        {

            //
            // It's Ok to have no Sid History.
            //

            continue;
        }
        else
        {
            return STATUS_UNSUCCESSFUL;
        }

    }

    return STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SampGetMemberships - Implementation                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


extern "C" {

DWORD
SampFindObjectByGuid(
    IN THSTATE * pTHS,
    IN DSNAME  * ObjectName,
    IN REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN BOOLEAN  fBaseObject,
    IN BOOLEAN  fUserObject,
    IN ULONG    LimitingNCDNT,
    IN PSID     LimitingDomainSid,
    IN BOOLEAN  fSidHistoryRequired,
    OUT BOOLEAN * pfChecked,
    OUT BOOLEAN * pfMatch,
    OUT BOOLEAN * pfHasSidHistory,
    OUT BOOLEAN * pfMorePassesRequired
    )
/*++

    Routine Description

    This routine finds the object by GUID. It first checks the group type cache
    for a match. If the cache lookup did not succeed it positions on the object
    by GUID

    Parameters


    pTHS -- The current Thread State
    ObjectName -- The GUID based object Name
    OperationType -- The reverse membership operation type
    fUserObject   -- Indicates that the given DS name indicates a user object
    fBaseObject   -- The base object of the search
    LimitingNcDNT -- Specifies the NC where we want to lookup the object in
    LimitingDomainSid -- The SID of the domain ( builtin/account ) that we want
                         to lookup the object in
    pfChecked         -- Indicates that the group type check has been performed on this
                         object.

    pfMatch           -- If pfChecked is true means that the group type matched

    pfHasSidHistory   -- Wether or not a group has sid history is returned in there if the
                         above 2 are true

    Return Values

       0 On Success
       Other DB Layer error codes on failure


--*/
{
    DWORD   dwErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Initialize Return Values
    //

    *pfChecked = FALSE;
    *pfMatch   = TRUE;
    *pfHasSidHistory = TRUE;

    //
    // First try looking up by  guid in the group type cache
    // No Point trying to lookup user objects
    //



    if (!fUserObject)
    {
        NtStatus = SampFindGroupByCache(
                        pTHS,
                        &ObjectName->Guid,
                        NULL,
                        fBaseObject,
                        OperationType,
                        LimitingNCDNT,
                        LimitingDomainSid,
                        fSidHistoryRequired,
                        pfHasSidHistory,
                        pfMatch,
                        &ObjectName
                        );
    }

    if ((NT_SUCCESS(NtStatus)) && (!fUserObject))
    {
        // Found it in the cache

        //
        // If we are looking up by guid, this is typically the object passed
        // in as opposed to recursing up the tree. The object passed need not
        // match, any criterio plus also can be a phantom ( as in the case
        // of cross domain memberships ).
        //

        *pfChecked = TRUE;
    }
    else
    {
        //
        // Try to find the DS Name.
        //

        dwErr = DBFindDSName(pTHS->pDB, ObjectName);

        //
        // If we missed a group in the cache then
        // then try add that to the group type cache.
        //

        if ((!dwErr) && (!fUserObject))
        {
            GroupTypeCacheAddCacheRequest(pTHS->pDB->DNT);
        }
    }

    // We are finished with the current DS name
    *pfMorePassesRequired = FALSE;

    return(dwErr);
}

DWORD
SampFindObjectByDNT(
    IN THSTATE * pTHS,
    IN ULONG     ulDNT,
    IN REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType,
    IN ULONG    LimitingNCDNT,
    IN PSID     LimitingDomainSid,
    IN BOOLEAN  fSidHistoryRequired,
    OUT BOOLEAN * pfChecked,
    OUT BOOLEAN * pfMatch,
    OUT BOOLEAN * pfHasSidHistory,
    OUT BOOLEAN * pfMorePassesRequired,
    OUT DSNAME  ** ObjectName
    )
/*++

    Routine Description

    This routine finds the object by DNT. It first checks the group type cache
    for a match. If the cache lookup did not succeed it positions on the object
    by GUID

    Parameters


    pTHS              -- The current Thread State
    ulDNT             -- The DNT of the object
    OperationType     -- The reverse membership operation type
    LimitingNcDNT     -- Specifies the NC where we want to lookup the object in
    LimitingDomainSid -- The SID of the domain ( builtin/account ) that we want
                         to lookup the object in
    pfChecked         -- Indicates that the group type check has been performed on this
                         object.

    pfMatch           -- If pfChecked is true means that the group type matched

    pfHasSidHistory   -- Wether or not a group has sid history is returned in there if the
                         above 2 are true

    ObjectName        -- The GUID and SID of the object are returned in this valid DS Name
                         structure
    Return Values

       0 On Success
       Other DB Layer error codes on failure


--*/
{
    DWORD   dwErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    len = 0;


    //
    // Initialize Return Values
    //

    *pfChecked = FALSE;
    *pfMatch   = TRUE;
    *pfHasSidHistory = TRUE;

    //
    // Try the group type cache.
    //

    NtStatus = SampFindGroupByCache(
                    pTHS,
                    NULL,
                    &ulDNT,
                    FALSE, //fBaseObject
                    OperationType,
                    LimitingNCDNT,
                    LimitingDomainSid,
                    fSidHistoryRequired,
                    pfHasSidHistory,
                    pfMatch,
                    ObjectName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        // Found the object in the cache.


        // Since finding by DNT is used only for objects that
        // were returned as part of the reverse membership list
        // of someone, we should always find it, and it should not
        // be a phantom. Assert that that matched object that has
        // no sid history ( common case of cache hits ) is not a
        // phantom.

        Assert(!(*pfMatch )|| !(*pfHasSidHistory) || DBCheckObj(pTHS->pDB));

        *pfChecked = TRUE;
    }
    else
    {

         //
         // Try to find the DNT. by looking up the database
         //

        dwErr = DBTryToFindDNT(pTHS->pDB,ulDNT);

        // Since finding by DNT is used only for objects that
        // were returned as part of the reverse membership list
        // of someone, we should always find it, and it should not
        // be a phantom

        if (0==dwErr)
        {
            Assert(DBCheckObj(pTHS->pDB));

            //
            // Obtain the DS Name of the Currently Positioned Object
            //

            *ObjectName = (DSNAME *)THAllocEx(pTHS,sizeof(DSNAME));
            RtlZeroMemory(*ObjectName,sizeof(DSNAME));
            dwErr = DBFillGuidAndSid(
                        pTHS->pDB,
                        *ObjectName
                        );
            (*ObjectName)->NameLen = 0;
            (*ObjectName)->structLen = DSNameSizeFromLen(0);


        }
    }

    *pfMorePassesRequired = FALSE;

    return(dwErr);
}

NTSTATUS
SampFindAndAddPrimaryMembers(
    IN THSTATE * pTHS,
    IN DSNAME  * GroupName,
    OUT CDSNameSet * pMembership
    )
/*++

    Routine Description

        This routine finds and adds the set of members that are members by virtue of 
        the primary group id property to the set of memberships. This is done by walking
        the primary group id index.

    Parameters

        pTHS -- The current thread state
        GroupName  The DSNAME of the group
        pMembership --  The transitive membership is added to this set.

    
    Return Values

        STATUS_SUCCESS
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME          *pSearchRoot;
    FILTER          filter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;
    ATTRBLOCK       *pAttrBlock;
    ULONG           i=0;
    RESTART         *pRestart = NULL;
    ATTRBLOCK       RequiredAttrs;
    NT4SID          DomainSid;
    ULONG           Rid;
    ULONG           BuiltinDomainSid[] = {0x101,0x05000000,0x20};

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);



    RtlZeroMemory(&RequiredAttrs,sizeof(ATTRBLOCK));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    SampSplitNT4SID(&GroupName->Sid,&DomainSid,&Rid);

    //
    // If the SID is from the builtin Domain then return success.
    // Builtin domain contains only builtin local groups therefore
    //

    if (RtlEqualSid(&DomainSid,(PSID) &BuiltinDomainSid))
    {
        return STATUS_SUCCESS;
    }

    if (!FindNcForSid(&DomainSid,&pSearchRoot))
    {
        // This is a case of an FPO that is a member of some
        // group in the forest. The FPO by itself will not have
        // any members. So it is O.K to skip without returning
        // an error

        return STATUS_SUCCESS;
    }

    do 
    {
        attrValFilter.valLen = sizeof(ULONG);
        // Rid is pointer to last subauthority in SID
        attrValFilter.pVal = (PUCHAR )RtlSubAuthoritySid(
                                    &GroupName->Sid,
                                    *RtlSubAuthorityCountSid(&GroupName->Sid)-1);
        memset(&filter, 0, sizeof(filter));
        filter.choice = FILTER_CHOICE_ITEM;
        filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        filter.FilterTypes.Item.FilTypes.ava.type = ATT_PRIMARY_GROUP_ID;
        filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

        memset(&searchArg, 0, sizeof(SEARCHARG));
        InitCommarg(&searchArg.CommArg);
        // Search in multiples of 256
        searchArg.CommArg.ulSizeLimit = 256;


        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.AttrTypBlock = RequiredAttrs;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        searchArg.pObject = pSearchRoot;
        searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        // Do not Cross NC boundaries.
        searchArg.bOneNC = TRUE;
        searchArg.pFilter = &filter;
        searchArg.searchAliases = FALSE;
        searchArg.pSelection = &entInfSel;

        pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
        pSearchRes->CommRes.aliasDeref = FALSE;
        pSearchRes->PagedResult.pRestart = pRestart;

        SearchBody(pTHS, &searchArg, pSearchRes,0);

        if (pSearchRes->count>0)
        {
           ENTINFLIST * CurrentEntInf;

            for (CurrentEntInf = &(pSearchRes->FirstEntInf);
                    CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)

            {   
                pMembership->CheckDuplicateAndAdd(CurrentEntInf->Entinf.pName);
                
            }
        }

        pRestart = pSearchRes->PagedResult.pRestart;
    } while ((NULL!=pRestart) && (pSearchRes->count>0));
             
    return ( Status);

}



NTSTATUS
SampGetMembersTransitive(
    IN THSTATE * pTHS,
    IN DSNAME * GroupName,
    OUT CDSNameSet  *pMembership
    )
/*++

    Routine Description

        This is the worker routine to find the transitive membership list of a group by
        traversing the link table. This routine does not consider the membership
        by virtue of the primary group id property. This is O.K for transitive
        membership computation as only users have a primary group id property and
        users are by defintion "leaves" in a membership list

    Parameters

        pTHS -- The current thread state
        GroupName  The DSNAME of the group
        pMembership --  The transitive membership is added to this set.

    Return Values

        STATUS_SUCCESS
        STATUS_OBJECT_NAME_NOT_FOUND
        Other Error codes
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    CReverseMembership Membership;
    DWORD dwErr =0 ;
    ULONG    ulDNT=0;
    BOOLEAN  fBaseObject = TRUE;
    ATTCACHE * pAC;
    ULONG len;
    DSNAME * pDsName;
    BOOL    bFirst;


    __try
    {
        //
        // Get an attribute cache entry for membership
        //

        if (!(pAC = SCGetAttById(pTHS, ATT_MEMBER))) {
            LogUnhandledError(ATT_MEMBER);
            Status =STATUS_UNSUCCESSFUL;
            __leave;
        }

        while(fBaseObject || (0!=ulDNT))
        {

            //
            // Position on the object locally
            //

            if (!fBaseObject)
            {
                dwErr = DBTryToFindDNT(pTHS->pDB,ulDNT);
                if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }

                //
                // Get the DSNAME corresponding to this object
                //

                dwErr = DBGetAttVal(pTHS->pDB,
                            1,
                            ATT_OBJ_DIST_NAME,
                            DBGETATTVAL_fSHORTNAME,
                            0,
                            &len,
                            (PUCHAR *)&pDsName
                            );

                if (DB_ERR_NO_VALUE==dwErr)
                {
                    //
                    // This could be because the object we are
                    // positioned right now might be a phantom. In that
                    // case, we neither need to modify the object, nor need
                    // to follow it transitively. Therefore start again with
                    // the next object
                    //

                    dwErr = 0;
                    goto NextObject;
                }            
                else if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }


                //
                // Add it to the list being returned
                //

                pMembership->CheckDuplicateAndAdd(pDsName);

            }
            else
            {
                dwErr = DBFindDSName(pTHS->pDB,GroupName);
                
                if ((DIRERR_OBJ_NOT_FOUND==dwErr) || (DIRERR_NOT_AN_OBJECT==dwErr))
                {
                    //
                    // if the object was not found, or was a phantom, then return
                    // an NtStatus code that indicates that the object was not
                    // found
                    //

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    __leave;
                }
                else if (0!=dwErr)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    __leave;
                }

                pDsName = GroupName;
            }

            //
            // Recurse through all the objects in the membership
            // list of the group
            //

            bFirst = TRUE;
            while ( TRUE )  
            {
                PULONG  pNextDNT=NULL;
                ULONG   ulNextDNT;

                dwErr = DBGetNextLinkValForLogon(
                            pTHS->pDB,
                            bFirst,
                            pAC,
                            &ulNextDNT
                            );

                if ( DB_ERR_NO_VALUE == dwErr )  
                {
                    // No more values.
                    break;
                }
                else if ( 0 != dwErr )  
                {
                    Status =STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                bFirst = FALSE;

                //
                // We are casting a 32 bit unsigned integer to a pointer
                // The assumption here is that the pointer type is
                // always equal or bigger ( in terms of bits )
                //

                Membership.Add((PVOID)(ULONG_PTR)ulNextDNT);
            }

            //
            // Add the membership by virtue of the primary
            // group id property. No need to follow this
            // transitively
            //

            Status = SampFindAndAddPrimaryMembers(
                            pTHS,
                            pDsName,
                            pMembership
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }

NextObject:
            //
            // For Sundown the Assumption here is that DNT will always be
            // a 32 bit value and so truncating and losing the upper few
            // bits is O.K
            //

            ulDNT = PtrToUlong(Membership.NextUnrecursed());
            pDsName = NULL;
            fBaseObject = FALSE;

        } // while ( 0!=ulDNT )
   }
   __finally
   {

   
   }


   return Status;

}

NTSTATUS
SampGetMembershipsActual(
    IN  THSTATE         *pTHS,
    IN  DSNAME          *pObjName,
    IN  BOOLEAN         fUserObject,
    IN  OPTIONAL        DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    IN  OUT CDSNameSet  *pReverseMembership,
    IN  OUT CDSNameSet      *pSidHistory OPTIONAL
    )

/*++

Routine Description:

    Derives the transitive reverse membership of an object local
    to this machine. This is the worker routine for reverse membership
    derivation

Arguments:

    pObjName - pointer to DSNAME of the object whose reverse membership
        is desired.


    fUserObject     - Set to true if the object specified in pObjName is a user object.
                      This information is used to optimize lookups/fills in the group
                      type cache. Note Getting this flag wrong, only results in a small
                      performance penalty, does not cause any incorrect operation.

    pLimitingDomain - optional pointer to the DSNAME of a domain ( or builtin
                      domain to filter results on ie groups not from this domain
                      are neither returned nor followed transitively.

    OperationType  -- Indicates the type of group membership evaluation we need to
                      perform. Valid values are

                      RevMembGetGroupsForUsers    -- Gets the non transitive ( one level)
                                                   membership, of an object in groups
                                                   confined to the same domain ( specified
                                                   by pLimitingDomain. Will filter out
                                                   builtin groups.

                      RevMembGetAliasMembership   -- Gets the non transitive ( one level)
                                                   membership of an object in local groups
                                                   confined to the same domain ( specified
                                                   by limiting domain SID and limiting
                                                   naming context ).

                      RevMembGetUniversalGroups   -- Gets the transitive reverse membership
                                                  in all universal groups, without regard to
                                                  any restrictions. Will filter out builtin
                                                  groups. The pLimitingDomain Parameter
                                                  should not be specified

                      RevMembGetAccountGroups     -- Gets the transitive reverse membership
                                                  in all account groups, in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups.

                      RevMembGetResourceGroups    -- Gets the transitive reverse membership
                                                  in all resource groups in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups

                      GroupMembersTransitive    -- Gets the transitive membership list in 
                                                  the specified set of groups. SID history 
                                                  and attributes are not returned and are ignored
                                                  if this value is specified for the operation type


    pReverseMembership -- This is a pointer to a DS Name set to which the filtered membership
                          is added. Using DSName sets as parameters simplifies the implementation
                          of routines that get the membership of multiple security principals,
                          as this class has all the logic to filter duplicates.

    pSidHistory        -- This is a pointer to a DS Name set to which the SID history is added.



Return Value:

    STATUS_SUCCESS on success.
    STATUS_INSUFFICIENT_RESOURCES on a resource failure
    STATUS_TOO_MANY_CONTEXT_IDS if the number of groups is greater than what can be fit in
                                a token.

--*/

{
    ATTCACHE            *pAC;
    DWORD               dwErr;
    INT                 iErr;
    BOOLEAN             bFirst;
    PDSNAME             pDSName = pObjName;
    CReverseMembership  revMemb;
    NTSTATUS            status = STATUS_SUCCESS;
    BOOLEAN             fMatch;
    BOOLEAN             fHasSidHistory;
    ULONG               dwException,
                        ulErrorCode,
                        ul2;
    PVOID               dwEA;
    ULONG               i;
    ULONG               LimitingNCDNT;
    PSID                LimitingDomainSid;
    BOOLEAN             fBaseObject = TRUE;
    BOOLEAN             fTransitiveClosure;
    BOOLEAN             fChecked = FALSE;
    BOOLEAN             fFirstTimeUserObject = FALSE;

    ULONG               ulDNT=0;

    __try
    {
        //
        // pLimiting domain should be specified if and only if
        // op type is not RevMembGetUniversalGroups
        //

        Assert((OperationType==RevMembGetUniversalGroups)
                ||(OperationType==GroupMembersTransitive)
                ||(NULL!=pLimitingDomain));

            Assert((OperationType!=RevMembGetUniversalGroups)||(NULL==pLimitingDomain));

        //
            // Return data will be allocated off the thread heap, so insure
            // we're within the context of a DS transaction.

            Assert(SampExistsDsTransaction());

        //
        // Caller better specify pObjName
        //

        Assert(NULL!=pObjName);

        //
        // If the transitive membership list is specified then compute that and leave
        //

        if (GroupMembersTransitive==OperationType)
        {
            status =  SampGetMembersTransitive(
                            pTHS,
                            pObjName,
                            pReverseMembership
                            );

            goto ExitTry;
        }

        //
        // Compute whether we need transitive closure
        //

        fTransitiveClosure = ((OperationType!=RevMembGetGroupsForUser )
                                && (OperationType!=RevMembGetAliasMembership));

        if ( fTransitiveClosure )
        {
            INC( pcMemberEvalTransitive );

            //
            // Update counters for various transitive cases
            //

            switch ( OperationType )
            {
            case RevMembGetUniversalGroups:
                INC( pcMemberEvalUniversal );
                break;
            case RevMembGetAccountGroups:
                INC( pcMemberEvalAccount );
                break;
            case RevMembGetResourceGroups:
                INC( pcMemberEvalResource );
                break;
            }
        }
        else
        {
            INC( pcMemberEvalNonTransitive );
        }

        //
        // Get attribute cache entry for reverse membership.
        //

        if (!(pAC = SCGetAttById(pTHS, ATT_IS_MEMBER_OF_DL))) {
            LogUnhandledError(ATT_IS_MEMBER_OF_DL);
            status =STATUS_UNSUCCESSFUL;
            goto ExitTry;
        }

        //
        // If a Limiting Domain is specified, the limiting domain test is (theoretically)
        // applied in the following manner ( note limiting domain can be a builtin domain )
        //      1. Get an NCDNT value, such that a group with that NCDNT value will
        //         may fall within the domain and groups with different NCDNT value will
        //         definately fall outside that domain. If the domain object specfied
        //         is an NC head this corresponds to the case of a "normal" domain use
        //         the DNT of the domain as the NCDNT value. Otherwise assume it is a
        //         builtin domain.
        //
        //      2. Get the Domain SID from the specified DSNAME and throw away groups which
        //         do not have the domain prefix equal to the domain SID.
        //
        //    Product1 however does not have multiple hosted domain support. Therefore it is
        //    safe to assume that the limiting domain that is passed in always either the
        //    authoritative domain for the domain controller , or its corresponding builtin
        //    domain.

        if (ARGUMENT_PRESENT(pLimitingDomain))
        {


            Assert(pLimitingDomain->SidLen>0);
            LimitingDomainSid = &pLimitingDomain->Sid;
            Assert(RtlValidSid(LimitingDomainSid));

            Assert(NULL!=gAnchor.pDomainDN);
           // Assert((NameMatched(gAnchor.pDomainDN,pLimitingDomain))
           //             ||(IsBuiltinDomainSid(LimitingDomainSid)));

            LimitingNCDNT = gAnchor.ulDNTDomain;
        }
        else
        {
            LimitingDomainSid = NULL;
            LimitingNCDNT = 0;
        }
                

            //
        // Loop getting reverse memberships until we're done.
        //

            while (fBaseObject || (0!=ulDNT))
        {
            DWORD iObject=0;
            BOOLEAN fSearchBySid = FALSE;
            BOOLEAN fSearchByDNT = FALSE;
            BOOLEAN fMorePassesOverCurrentName = TRUE;


            fSearchBySid = (NULL!=pDSName)&&(fNullUuid( &pDSName->Guid ))&&(0==pDSName->NameLen)
                            &&(pDSName->SidLen>0)&&(RtlValidSid(&(pDSName->Sid)));

            fSearchByDNT = (NULL==pDSName);

            while(fMorePassesOverCurrentName)
            {

                //
                    // Position database to the name.
                //
                // SampGetMemberships accepts several types of Names
                //
                // 1. Standard DS Name , with either the GUID or Name Filled in. In this
                //    case SampGetMemberships uses DBFindDSName to position on the object.
                //    Only a single pass is made over the name
                //
                // 2. A Sid Only DSName, with no GUID and String name Filled in. In this case
                //    this routine Uses DBFindObjectWithSid to position on the object.
                //    Multiple passes are made , each type with a different sequence number
                //    to find all occurrences of Object's with the given SID. Note on a G.C
                //    several object's may co-exist with the same Sid, but on different
                //    naming context. A simple case is the builtin groups. A more complex case
                //    is (former)NT4 security prinicipals being members of DS groups. ( FPO's
                //    and regular objects for the same security principals ).
                //
                //
                // 3. It is possible that the DS name is that of a phantom
                //    object in the DIT. This happens during an AliasMembership expansion, or
                //    a resource group expansion, where a cross domain member's reverse membership
                //    is being expanded.
                //
                // 4. The name is simpy a DNT. This happens when recursing up, as for performance
                //    reasons it is more efficient to keep the identity of the object as a DNT.
                //
                // Also since DBFindDsName and DBFIndObjectWithSid can throw exceptions,
                // they are enclosed within a exception handler
                //

                // assume the object has not been checked in the group type cache
                fChecked = FALSE;
                // Assume object will match any limited group constraints
                fMatch = TRUE;
                // Assume a sid history
                fHasSidHistory = TRUE;
                __try {
                    if (fSearchByDNT) {

                        //
                        // Base object Cannot be a DNT
                        //
                        Assert(!fBaseObject);

                        //
                        // Lookup the object by DNT
                        //

                        dwErr = SampFindObjectByDNT(
                                    pTHS,
                                    ulDNT,
                                    OperationType,
                                    LimitingNCDNT,
                                    LimitingDomainSid,
                                    ARGUMENT_PRESENT(pSidHistory),
                                    &fChecked,
                                    &fMatch,
                                    &fHasSidHistory,
                                    &fMorePassesOverCurrentName,
                                    &pDSName
                                    );

                    }
                    else if (fSearchBySid)
                    {
                        dwErr = DBFindObjectWithSid(pTHS->pDB, pDSName,iObject++);
                        // We have not yet found all occurences of object's with the given
                        // Sid. Therefore do not as yet mark this ds Name as finished. Down
                        // below when we examing the error code, we will decide whether more
                        // passes are needed or not.

                    }
                    else
                    {
                        //
                        // Search By GUID
                        //

                        dwErr = SampFindObjectByGuid(
                                    pTHS,
                                    pDSName,
                                    OperationType,
                                    fBaseObject,
                                    (fBaseObject) && (fUserObject),
                                    LimitingNCDNT,
                                    LimitingDomainSid,
                                    ARGUMENT_PRESENT(pSidHistory),
                                    &fChecked,
                                    &fMatch,
                                    &fHasSidHistory,
                                    &fMorePassesOverCurrentName
                                    );

                    }

                    switch(dwErr)
                    {
                    case 0:

                        // Success
                        break;

                    case DIRERR_NOT_AN_OBJECT:

                        if (fBaseObject)
                        {
                            // Positioning on Phantom is OK for base Object
                            dwErr=0;
                        }
                        else
                        {
                            //
                            // While recursing up we should never position
                            // on a phantom. This is because
                            // Membership "travels" with the group, not the member.
                                    // Therefore the reverse membership property points only
                                    // to memberships in groups in naming contexts on this
                                    // machine.  Thus returned name is real, not a phantom.
                            //

                            Assert(FALSE && "Positioned on a Phantom while recursing up");
                            status = STATUS_INTERNAL_ERROR;
                            goto ExitTry;

                        }
                        break;

                    case DIRERR_OBJ_NOT_FOUND:

                        if (fSearchBySid)
                        {
                            // If we are Searching By Sid its Ok to not find the
                            // object. Skip the object and attempt processing the
                            // next object

                            dwErr=0;
                            // We are finished with the current DS name
                            // as all occurances of the object(s) with the given SID
                            // have been processed.
                            // We are not positioned on any object at this time. We must
                            // go get the next DS Name to process. So exit this loop.
                            fMorePassesOverCurrentName=FALSE;
                            continue;
                        }
                        else
                        {
                            status = STATUS_OBJECT_NAME_NOT_FOUND;
                            goto ExitTry;
                        }

                        break;

                    default:

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ExitTry;
                    }

                }
                __except (HandleMostExceptions(GetExceptionCode()))  {
                    // bail on exception. Most likely cause of an exception
                    // is a resource failure. So set error code as
                    // STATUS_INSUFFICINET_RESOURCES
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ExitTry;
                }
        
                //
                // If We are here we have a DSName for the current object
                //

                Assert(NULL!=pDSName);

                //
                // If the specified object is not the base object specified then
                // apply the filter test
                //

                if (!fBaseObject) {

                    //
                    // If the object registered a group type cache hit, then the lookup
                    // itself has done the filter test for the match. Therefore there is
                    // no need to perform a (slow) match test again. In thos cases the
                    // fChecked flag is set.
                    //

                    if(!fChecked)
                    {
                        //
                        // Now depending upon the operation requested evaluate
                        // the filter. We are positioned on the object right now
                        // and can get some properties on a demand basis. Further
                        // we know that the object is not the base object
                        //

                        status = SampCheckGroupTypeAndDomain(
                                pTHS,
                                pDSName,
                                OperationType,
                                LimitingNCDNT,
                                LimitingDomainSid,
                                &fMatch
                                );

                        if (!NT_SUCCESS(status)) {
                            goto ExitTry;
                        }
                    }

                    if (!fMatch)
                    {
                        //
                        // Our Filter Indicates that we need not consider this
                        // object for further reverse membership processing,
                        // (either adding to the list ) or following up transtively.
                        // Therefore move on to the next object
                        //

                        continue;
                    }

                    //
                    // Since this is not the base object add this to the reverse membership
                    // list to be returned
                    //

                    pReverseMembership->CheckDuplicateAndAdd(pDSName);
                }

                //
                // Read The Sid History If required.
                // The SID history is added in , in general only for objects that are retrieved as part of this
                // routine. The one exception to the rule is for the case of the user object that is passed in first
                // around for evaluation.
                //

                fFirstTimeUserObject = fBaseObject && 
                   ((OperationType == RevMembGetAccountGroups ) || (OperationType==RevMembGetGroupsForUser));

                if (ARGUMENT_PRESENT(pSidHistory) && fHasSidHistory && ( !fBaseObject || fFirstTimeUserObject))
                {
                    //
                    // Caller Wanted Sid History
                    //

                    status = SampReadSidHistory(pTHS, pSidHistory);
                    if (!NT_SUCCESS(status))
                        goto ExitTry;
                }



                // This object satisfies all filter criterions, therefore we should
                // follow the object. Call DBGetAttVal_AC multiple times to get all the values
                // in the reverse membership, and add it to the list to be
                // examined. We will always follow the object if transitive closure is specified
                // or if it is the base object, whose reverse membership we need to compute

                bFirst = TRUE;

                while ( fBaseObject || fTransitiveClosure )  {
                    PULONG  pNextDNT=NULL;
                    ULONG   ulNextDNT;

                    dwErr = DBGetNextLinkValForLogon(
                                pTHS->pDB,
                                bFirst,
                                pAC,
                                &ulNextDNT
                                );

                    if ( DB_ERR_NO_VALUE == dwErr )
                    {
                        // No more values.
                        break;
                    }
                    else if ( 0 != dwErr )
                    {
                        status =STATUS_INSUFFICIENT_RESOURCES;
                        goto ExitTry;
                    }

                    bFirst = FALSE;

                    //
                    // We are casting a 32 bit unsigned integer to a pointer
                    // The assumption here is that the pointer type is
                    // always equal or bigger ( in terms of bits )
                    //

                    revMemb.Add((PVOID)(ULONG_PTR)ulNextDNT);
                }


                //
                // The primary group for users is not stored explicity, but rather in
                // the primary group id property implicitly. Merge this into the reverse
                // memberships. Note further that SampGetPrimaryGroup will alter cursor
                // positioning. Therefore this should be the last element in the group
                //
                // Note: if fChecked is true at this point along with fBase object then
                // this means that the base object was also successfully looked up using
                // the GUID in the group type cache. Since groups have no notion of primary
                // group ID we should not need too call SampGetPrimaryGroup to get the primary
                // group of the object.
                //

                if ((fBaseObject) &&
                    (!fChecked)   &&
                    ((RevMembGetGroupsForUser==OperationType)
                   ||(RevMembGetAccountGroups==OperationType)))
                {
                    ULONG  PrimaryGroupDNT = 0;

                    status = SampGetPrimaryGroup(pTHS,
                                                 pDSName,
                                                 &PrimaryGroupDNT);
                    if (!NT_SUCCESS(status))
                        goto ExitTry;

                    if (0!=PrimaryGroupDNT)
                        revMemb.Add((PVOID)(ULONG_PTR)PrimaryGroupDNT);
                }
            }


            // Time to recurse.  Get the next unrecursed value from UnrecursedSet,
            // position at it in the database, and return to the top of the
            // loop.  Quit if there are no more unrecursed values.

            //
            // For Sundown the Assumption here is that DNT will always be
            // a 32 bit value and so truncating and losing the upper few
            // bits is O.K
            //

            ulDNT = PtrToUlong(revMemb.NextUnrecursed());
            pDSName = NULL;
            fBaseObject = FALSE;

        } // while ( NULL != pulDNT )

        
        status = STATUS_SUCCESS;

    ExitTry:
        ;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &ul2))
    {
            HandleDirExceptions(dwException, ulErrorCode, ul2);
            status = STATUS_UNSUCCESSFUL;
    }


    return(status);
}



        



NTSTATUS
SampGetMemberships(
    IN  PDSNAME         *rgObjNames,
    IN  ULONG           cObjNames,
    IN  OPTIONAL        DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG           *pcDsNames,
    IN  OUT PDSNAME     **prpDsNames,
    IN  OUT PULONG      *Attributes OPTIONAL,
    IN  OUT PULONG      pcSidHistory OPTIONAL,
    IN  OUT PSID        **rgSidHistory OPTIONAL
    )
/*++

Routine Description:

    Derives the transitive reverse membership of an object local
    to this machine. This is the main reverse membership derivation routine for SAM.
    This routine will call SampGetMembershipsActual to perform most of the operations

Arguments:

    rgObjNames        pointer to an array of DS Name pointers. Each DS Name represents
                      a security prinicipal whose reverse membership we desire

    cObjNames         Count, specifies the number of DS Names in rgObjNames


    pLimitingDomain - optional pointer to the DSNAME of a domain ( or builtin
                      domain to filter results on ie groups not from this domain
                      are neither returned nor followed transitively.

    OperationType  -- Indicates the type of group membership evaluation we need to
                      perform. Valid values are

                      RevMembGetGroupsForUsers    -- Gets the non transitive ( one level)
                                                   membership, of an object in groups
                                                   confined to the same domain ( specified
                                                   by pLimitingDomain. Will filter out
                                                   builtin groups.

                      RevMembGetAliasMembership   -- Gets the non transitive ( one level)
                                                   membership of an object in local groups
                                                   confined to the same domain ( specified
                                                   by limiting domain SID and limiting
                                                   naming context ).

                      RevMembGetUniversalGroups   -- Gets the transitive reverse membership
                                                  in all universal groups, without regard to
                                                  any restrictions. Will filter out builtin
                                                  groups. The pLimitingDomain Parameter
                                                  should not be specified

                      RevMembGetAccountGroups     -- Gets the transitive reverse membership
                                                  in all account groups, in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups.

                      RevMembGetResourceGroups    -- Gets the transitive reverse membership
                                                  in all resource groups in the domain
                                                  specified by pLimitingDomain. Will filter
                                                  out builtin groups

                      GetGroupMembersTransitive   -- Gets the transitive direct membership in 
                                                  the group based on the information in the direct
                                                  database. Information about the primary group
                                                  is also merged in. SID history values and attributes
                                                  are not returned as part of this call.



    pcSid - pointer to ULONG which contains SID count on return.

    prpDsNames - pointer to array of DSname pointers which is allocated and
        filled in on return. Note Security Code Requires Sids. DsNames structure
        contains the SID plus the full object Name. The Advantage of returning DS Names
        is that the second phase of the logon need not come back to resolve the Sids
        back into DS Names. Resolving them again may cause a potential trip to
        the G.C again. To avoid this it is best to return DS Names. If second phase
        needs to run, it can directly use the results fr

    Attributes - OPTIONAL parameter, which is used to query the Attributes corresponding
        to the group memberhip . In NT4 and NT5 SAM this is wired to
        SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED

    pcSidHistory OPTIONAL parameter, the count of returned Sids due to the
                 SID history property is returned in here,

    rgSidHistory Array of Sids in the Sid Historuy

Return Value:

    STATUS_SUCCESS on success.
    STATUS_INSUFFICIENT_RESOURCES on a resource failure
    STATUS_TOO_MANY_CONTEXT_IDS if the number of groups is greater than what can be fit in
                                a token.

--*/
{
    THSTATE             *pTHS=pTHStls;
    NTSTATUS            status = STATUS_SUCCESS;
    CDSNameSet          ReverseMembership;      // External format DSNames
    CDSNameSet          SidHistory;             // External format DSNames
    ULONG               dwException,
                        ulErrorCode,
                        ul2;
    PVOID               dwEA;
    ULONG               i;

    __try
    {
        
        //
        // Init return values.
        //

            *pcDsNames = 0;
            *prpDsNames = NULL;

        if (ARGUMENT_PRESENT(pcSidHistory))
            *pcSidHistory = 0;

        if (ARGUMENT_PRESENT(rgSidHistory))
            *rgSidHistory = NULL;

        //
        // Check for valid operation types
        //

        if ((OperationType!=RevMembGetGroupsForUser) &&
           (OperationType!=RevMembGetAliasMembership) &&
           (OperationType!=RevMembGetUniversalGroups) &&
           (OperationType!=RevMembGetAccountGroups) &&
           (OperationType!=RevMembGetResourceGroups) &&
           (OperationType!=GroupMembersTransitive))
        {
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Init the classes
        //

        ReverseMembership.SetValueType(RevMembDsName);
        SidHistory.SetValueType(RevMembSid);

        //
        // Iterate through each of the objects passed in
        //

        for (i=0;i<cObjNames;i++)
        {
            if (NULL==rgObjNames[i])
            {
                //
                // if a NULL was passed in, then simply ignore
                // This allows sam to simply call resolve Sids,
                // and pass the entire set of DS names down to
                // evaluate for reverse memberships
                //

                continue;
            }

            status = SampGetMembershipsActual(
                        pTHS,
                        rgObjNames[i],
                        (0==i)?TRUE:FALSE, // fUserObject. SAM has this contract with
                                           // the DS that in passing an array of DSNAMES
                                           // to evaluate the reverse membership of an object
                                           // at logon time the user object will be first object
                                           // in the list. At other times, notably ACL conversion
                                           // this need not be true, but then we can take a peformance
                                           // penalty.
                        pLimitingDomain,
                        OperationType,
                        &ReverseMembership,
                        ARGUMENT_PRESENT(rgSidHistory)?&SidHistory:NULL
                        );

            if (STATUS_OBJECT_NAME_NOT_FOUND==status)
            {

                if ((RevMembGetGroupsForUser!=OperationType)
                    && (RevMembGetAccountGroups!=OperationType))
                {
                    //
                    // If the object name was not found, its probaly O.K.
                    // just that the DS Name is not a member of anything
                    // and probably represents a security prinicipal in a
                    // different domain
                    //

                    status = STATUS_SUCCESS;
                    THClearErrors();
                    continue;
                }
                else
                {
                    //
                    // This is a fatal error in a get groups for user or
                    // get account group membership. This is because SAM
                    // in this case typically evaluating the reverse membership
                    // of a user or a group, that it has verified that it exists
                    //

                    break;
                }
            }
        }

        if (NT_SUCCESS(status))
        {
            //
            // Call Succeeded, transfer parameters in the form that caller
            // wants
            //

            *pcDsNames = ReverseMembership.Count();
            if (0!=*pcDsNames)
            {
                *prpDsNames = (PDSNAME *)ReverseMembership.GetArray();
            }

            if (ARGUMENT_PRESENT(rgSidHistory) &&
                    ARGUMENT_PRESENT(pcSidHistory))
            {
                *pcSidHistory = SidHistory.Count();
                if (0!=*pcSidHistory)
                {
                    *rgSidHistory = SidHistory.GetArray();
                }
            }
        }

            // We may have allocated and assigned to *prDsnames, but never filled
            // in any return data due to class filtering.  Null out the return
            // pointer in this case just to be safe.
        
            if ( 0 == *pcDsNames )
        {
                *prpDsNames = NULL;
            }

        //
        // If Attributes were asked for then
        //

        if (ARGUMENT_PRESENT(Attributes))
        {
            *Attributes = NULL;
            if (*pcDsNames>0)
            {
                *Attributes = (ULONG *)THAllocEx(pTHS, *pcDsNames * sizeof(ULONG));
                for (i=0;i<*pcDsNames;i++)
                {
                    (*Attributes)[i]=SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
                }
            }
        }
    }  __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &ul2))
    {
            HandleDirExceptions(dwException, ulErrorCode, ul2);
            status = STATUS_UNSUCCESSFUL;
    }


    return(status);
}

NTSTATUS
SampGetMembershipsFromGC(
    IN  PDSNAME  *rgObjNames,
    IN  ULONG    cObjNames,
    IN  OPTIONAL DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT PULONG   pcDsNames,
    OUT PDSNAME  **rpDsNames,
    OUT PULONG   *pAttributes OPTIONAL,
    OUT PULONG   pcSidHistory OPTIONAL,
    OUT PSID     **rgSidHistory OPTIONAL
    )
/*++

    Routine Description:

        This routine computes the reverse membership of an object at the
        G.C.

    Parameters:

          Same as SampGetMemberships  
          
    Return Values

        STATUS_SUCCESS Upon A Successful Evaluation
        STATUS_NO_SUCH_DOMAIN If a G.C did not exist or could not be contacted
        STATUS_UNSUCCESSFUL   Otherwise
 --*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    FIND_DC_INFO *pGCInfo = NULL;
    ULONG       dwErr=0;
    NTSTATUS    ActualNtStatus = STATUS_SUCCESS;
    THSTATE     *pTHS=pTHStls;
    BOOL        fFailedToTalkToGC = FALSE;
    DWORD       cNumAttempts = 0;

    Assert(NULL!=pTHS);
    Assert(!SampExistsDsTransaction());

    __try
    {
        do
        {
            fFailedToTalkToGC = FALSE;
            NtStatus = STATUS_SUCCESS;

            //
            // Locate a G.C
            //
            dwErr = FindGC(FIND_DC_USE_CACHED_FAILURES
                             | FIND_DC_USE_FORCE_ON_CACHE_FAIL, 
                           &pGCInfo);
            if (0!=dwErr)
            {
                //
                // Munge Any Errors to failures in locating
                // a GC for the Domain
                //
    
                NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
            }
    
            //
            // Make the Reverse Membership call on the G.C
            //
    
            if (NT_SUCCESS(NtStatus))
            {
                dwErr = I_DRSGetMemberships(
                            pTHS,
                            pGCInfo->addr,
                            FIND_DC_INFO_DOMAIN_NAME(pGCInfo),
                            ARGUMENT_PRESENT(pAttributes) ?
                                DRS_REVMEMB_FLAG_GET_ATTRIBUTES : 0,
                            rgObjNames,
                            cObjNames,
                            pLimitingDomain,
                            OperationType,
                            (DWORD *)&ActualNtStatus,
                            pcDsNames,
                            rpDsNames,
                            pAttributes,
                            pcSidHistory,
                            rgSidHistory
                            );
    
                if ((0!=dwErr) && (NT_SUCCESS(ActualNtStatus)))
                {
                    //
                    // The Failure is an RPC Failure
                    // set an appropriate error code
                    //
    
                    NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
                    InvalidateGC(pGCInfo, dwErr);
                    fFailedToTalkToGC = TRUE;
                }
                else
                {
                    NtStatus = ActualNtStatus;
                }
            }
        // If we failed against the cached GC, get a new GC from the locator
        // and try once (but only once) more.
        } while (fFailedToTalkToGC && (++cNumAttempts < 2));
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {

        //
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        //

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( pGCInfo ) {
        THFreeEx(pTHS, pGCInfo);
    }

    return NtStatus;
}

BOOL
SampAmIGC()
/*++
    Tells SAM wether we are a G.C

--*/
{
    return(gAnchor.fAmGC || gAnchor.fAmVirtualGC);
}






NTSTATUS
SampBuildAdministratorsSet(
    THSTATE * pTHS,
    DSNAME * AdministratorsDsName,
    DSNAME * EnterpriseAdminsDsName,
    DSNAME * SchemaAdminsDsName,
    DSNAME * DomainAdminsDsName,
    PULONG  pcCountOfMembers,
    PDSNAME **prpMembers
    )
/*++

    Routine Description

        This routine builds the set of members in the groups, administrators,
        domain admins, enterprise admins and schema admins.

    Parameters

        pcCountOfMembers -- The count of members is returned in here
        ppMembers        -- The list of members is returned in here

    Return Values

        STATUS_SUCCESS
        Other Error Codes

 --*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    

    PDSNAME     *pGcEvaluationList = NULL;
    PDSNAME     *pDomainAdminsList = NULL;
    PDSNAME     *pAdministratorsList = NULL;
    PDSNAME     *pLocalEvaluationList = NULL;
    PDSNAME     *pFinalLocalEvaluationList = NULL;
    ULONG       cDomainAdminsList = 0;
    ULONG       cAdministratorsList = 0;
    ULONG       cGcEvaluationList = 0;
    ULONG       cLocalEvaluationList =0;
    ULONG       cFinalLocalEvaluationList =0;
    CDSNameSet  FinalAdminList;
    ULONG       i=0;
   

    __try
    {
        //
        // Initialize return values
        //

        *pcCountOfMembers =0;
        *prpMembers = NULL;

        FinalAdminList.SetValueType(RevMembDsName);

        //
        // Begin a transaction
        //

        DBOpen(&pTHS->pDB);

        //
        // Evaluate the transitive membership in domain admins group locally
        //

        Status = SampGetMemberships(
                        &DomainAdminsDsName,
                        1,
                        NULL,
                        GroupMembersTransitive,
                        &cDomainAdminsList,
                        &pDomainAdminsList,
                        NULL,
                        NULL,
                        NULL
                        );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Evaluate the transitive membership in Administrators Locally
        //

    
        Status = SampGetMemberships(
                        &AdministratorsDsName,
                        1,
                        NULL,
                        GroupMembersTransitive,
                        &cAdministratorsList,
                        &pAdministratorsList,
                        NULL,
                        NULL,
                        NULL
                        );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Commit the transaction but keep the thread state as we prepare to go off machine
        //

        DBClose(pTHS->pDB,TRUE);

        //
        // Evaluate memberships of the administrators set plus that of enteprise admins and 
        // schema admins at the G.C
        //
    
        cGcEvaluationList = cAdministratorsList + 2;
        pGcEvaluationList = (PDSNAME *) THAllocEx( pTHStls,cGcEvaluationList * sizeof(PDSNAME));
    
        RtlCopyMemory(pGcEvaluationList,pAdministratorsList, cAdministratorsList * sizeof(PDSNAME));
        pGcEvaluationList[cAdministratorsList] = EnterpriseAdminsDsName;
        pGcEvaluationList[cAdministratorsList+1] = SchemaAdminsDsName;


        Status = SampGetMembershipsFromGC(
                        pGcEvaluationList,
                        cGcEvaluationList,
                        NULL,
                        GroupMembersTransitive,
                        &cLocalEvaluationList,
                        &pLocalEvaluationList,
                        NULL,
                        NULL,
                        NULL
                        );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Begin Transaction again to process locally
        //

        DBOpen(&pTHS->pDB);

        //
        // Evaluate the results of the above evaluation locally
        //
    
        Status = SampGetMemberships(
                     pLocalEvaluationList,
                     cLocalEvaluationList,
                     NULL,
                     GroupMembersTransitive,
                     &cFinalLocalEvaluationList,
                     &pFinalLocalEvaluationList,
                     NULL,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }

        //
        // Compose the final set, by utilizing the CDSNAMESET's check duplicate and add function.
        //

        //
        // Add the domain admins list
        //

        for (i=0;i<cDomainAdminsList;i++)
        {
            FinalAdminList.CheckDuplicateAndAdd(pDomainAdminsList[i]);
        }

        //
        // Add the administrators list
        //

        for (i=0;i<cAdministratorsList;i++)
        {
            FinalAdminList.CheckDuplicateAndAdd(pAdministratorsList[i]);
        }

        //
        // Add the set returned from the G.C
        //

        for (i=0;i<cLocalEvaluationList;i++)
        {
            FinalAdminList.CheckDuplicateAndAdd(pLocalEvaluationList[i]);
        }

        //
        // Add the locally evaluated set of the set returned from the G.C
        //

        for (i=0;i<cFinalLocalEvaluationList;i++)
        {
            FinalAdminList.CheckDuplicateAndAdd(pFinalLocalEvaluationList[i]);
        }


        // 
        // Add  Enterprise Admins / Schema Admins / Domain Admins  
        // 

        FinalAdminList.CheckDuplicateAndAdd(EnterpriseAdminsDsName);
        FinalAdminList.CheckDuplicateAndAdd(SchemaAdminsDsName);
        FinalAdminList.CheckDuplicateAndAdd(DomainAdminsDsName);

        //
        // Get the final list of members
        //

        *pcCountOfMembers = FinalAdminList.Count();
        if (0!=*pcCountOfMembers)
        {
            *prpMembers = (PDSNAME *)FinalAdminList.GetArray();
        }

    }
    __finally
    {
        //
        // Commit the transaction, but keep the thread state
        //

        if (NULL!=pTHS->pDB)
        {        
            DBClose(pTHS->pDB,TRUE);
        }
    }


    return (Status);
    
}

NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG    *pcSids,
    OUT PSID     **prpSids
   )
/*++

   Routine Description:

       This functions evaluates the full reverse membership,
       as in a logon. No Open Transactions Must Exist if GC membership
       query is desired. Depending upon circumstances this routine
       may begin a Read Transaction. Caller must be capable of handling
       this. If caller wants control of transaction type and does not
       want to go to the G.C then the caller can open appropriate transaction
       prior to calling this routine.

   Parameters:

       pObjName -- Security Principal Whose Reverse Membership is
                   desired.
       Flags    -- Control the operation of the Routine. Currently
                   defined flags are as follows

                     SAM_GET_MEMBERSHIPS_NO_GC -- If specified this routine
                     will not go to the G.C . All Operations are local.

                     SAM_GET_MEMBERSHIPS_TWO_PHASE -- Does both Phase 1 and Phase 2
                     of Reverse membership Evaluation , as in the construction
                     of a Logon Token for this DC.

       pcSids  -- The count of Sids Returned
       prpSids -- A pointer to an array of pointers to Sids is returned in here.

   Return Values

       STATUS_SUCCESS - On SuccessFul Completion
       STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY - If We could not contact G.C and evaluated locally instead
       STATUS_DS_GC_NOT_AVAILABLE - If we could not find a G.C and could not
                        evaluate locally.


--*/
{
    THSTATE *pTHS=pTHStls;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  fPartialMemberships=FALSE;
    DSNAME *BuiltinDomainObject=NULL;
    PDSNAME * Phase1DsNames=NULL,
            * Phase2DsNames=NULL,
            * Phase3DsNames=NULL,
            * Phase4DsNames=NULL,
            * TempDsNames0=NULL,
            * TempDsNames1=NULL,
            * TempDsNames2=NULL,
            * TempDsNames3=NULL,
            * ReturnedDsNames;
    ULONG    cPhase1DsNames=0,
             cPhase2DsNames=0,
             cPhase3DsNames=0,
             cPhase4DsNames=0,
             cTempDsNames0=0,
             cTempDsNames1=0,
             cTempDsNames2=0,
             cTempDsNames3=0,
             TotalDsNames=0;
    ULONG    cSidHistory1=0,cSidHistory2=0,cSidHistory3=0;
    PSID     *rgSidHistory1=NULL,*rgSidHistory2=NULL,*rgSidHistory3=NULL;
    ULONG    dsErr = 0;
    ULONG    i,j;
    BOOLEAN fMixedDomain = ((Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN)!=0);
    BOOL    fCommit = FALSE;
    ULONG   BuiltinDomainSid[] = {0x101,0x05000000,0x20};
    ULONG   Size;
    AUG_MEMBERSHIPS *pAccountMemberships = NULL;
    AUG_MEMBERSHIPS *pUniversalMemberships = NULL;

    //
    // This macro collects all names into a stack array, that is alloca'd
    // so that this can be passed onto SampGetMemberships for the next phase
    // of logon evaluation.
    //
    #define COLLECT_NAMES(p1,c1,p2,c2,pt,ct)\
    {\
        ct=0;\
        pt = (DSNAME**)THAlloc((c1+c2)*sizeof(PDSNAME));\
        if (pt)\
        {\
            RtlZeroMemory(pt, (c1+c2)*sizeof(PDSNAME));\
            if (c1)\
                RtlCopyMemory(pt+ct,p1,c1*sizeof(PDSNAME));\
            ct+=c1;\
            if (c2)\
                RtlCopyMemory(pt+ct,p2,c2*sizeof(PDSNAME));\
            ct+=c2;\
        }\
    }

    //
    // initialize return value first
    // 
    *prpSids = NULL;
    *pcSids = 0;

    _try
    {
        //
        // This routine assumes an open transaction
        //
        Assert(pTHS->pDB != NULL);
    
        NtStatus = GetAccountAndUniversalMemberships(pTHS,
                                                     Flags,
                                                     NULL,
                                                     NULL,
                                                     1,
                                                     &pObjName,
                                                     FALSE, // not the refresh task
                                                     &pAccountMemberships,
                                                     &pUniversalMemberships);

        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }

        // Account memberships should always be returned
        cPhase1DsNames = pAccountMemberships[0].MembershipCount;
        Phase1DsNames = pAccountMemberships[0].Memberships;

        cSidHistory1 = pAccountMemberships[0].SidHistoryCount;
        rgSidHistory1 = pAccountMemberships[0].SidHistory;

        cPhase2DsNames = pUniversalMemberships[0].MembershipCount;
        Phase2DsNames = pUniversalMemberships[0].Memberships;

        cSidHistory2 = pUniversalMemberships[0].SidHistoryCount;
        rgSidHistory2 = pUniversalMemberships[0].SidHistory;

        fPartialMemberships = (pUniversalMemberships[0].Flags & AUG_PARTIAL_MEMBERSHIP_ONLY) ? TRUE : FALSE;

        
        if (Flags & SAM_GET_MEMBERSHIPS_TWO_PHASE)
        {
        
        
            //
            // Two phase flag is specified only by callers within SAM,
            // like ACL conversion or check for sensitive groups, that
            // should not result in a call to the G.C. Therefore a DS
            // transaction should exist at this point in time
            //
            // There is one exception when core calls it to compute
            // the constructed att reverseMembershipConstructed,
            // which may result in a call to the GC, and hence, may
            // not have a transaction now. So open one if not present.
            // Note that the following call is a no-op if a correct
            // transaction exists

            if (NULL == pTHS->pDB) {
                DBOpen(&pTHS->pDB);
            }

            if (!NT_SUCCESS(NtStatus))
               goto Error;
        
            //
            // Again remember to merge in the base object itself
            // into this.
            //
        
            COLLECT_NAMES(&pObjName,1,Phase1DsNames,cPhase1DsNames,TempDsNames1,cTempDsNames1)
            if (NULL == TempDsNames1)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
            //
            // Combine the reverse memberships from the account and universal
            // group evaluation into one big buffer, containing both. Note the
            // big buffer will not have any duplicates, as one buffer is account
            // groups and the other contains universal groups.
            //
        
            COLLECT_NAMES(
                TempDsNames1,
                cTempDsNames1,
                Phase2DsNames,
                cPhase2DsNames,
                TempDsNames2,
                cTempDsNames2
                );
            if (NULL == TempDsNames2)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
        
            //
            // Get the resource group membership of all these groups.
            //
        
            NtStatus = SampGetMemberships(
                            TempDsNames2,
                            cTempDsNames2,
                            gAnchor.pDomainDN,
                            RevMembGetResourceGroups,
                            &cPhase3DsNames,
                            &Phase3DsNames,
                            NULL,
                            &cSidHistory3,
                            &rgSidHistory3 
                            );
        
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        
        
            //
            // Again collect all the names
            //
        
            COLLECT_NAMES(
                Phase3DsNames,
                cPhase3DsNames,
                TempDsNames2,
                cTempDsNames2,
                TempDsNames3,
                cTempDsNames3
                );
            if (NULL == TempDsNames3)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
        
            //
            // Get the reverse membership in the builtin domain for
            // all the objects that the object is a transitive reverse-
            // member of
            //
        
            Size = DSNameSizeFromLen(0);
            BuiltinDomainObject = (DSNAME*) THAllocEx(pTHS,Size);
            BuiltinDomainObject->structLen = Size;
            BuiltinDomainObject->SidLen = RtlLengthSid(BuiltinDomainSid);
            RtlCopySid(sizeof(BuiltinDomainObject->Sid),
                       (PSID)&BuiltinDomainObject->Sid, 
                       BuiltinDomainSid);
        
            NtStatus = SampGetMemberships(
                            TempDsNames3,
                            cTempDsNames3,
                            BuiltinDomainObject,
                            RevMembGetAliasMembership,
                            &cPhase4DsNames,
                            &Phase4DsNames,
                            NULL,
                            NULL,
                            NULL
                            );
            THFreeEx(pTHS,BuiltinDomainObject);
        
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        
            TotalDsNames = cPhase3DsNames;
            ReturnedDsNames = Phase3DsNames;
        }
        
        TotalDsNames = cPhase1DsNames+cPhase2DsNames+cPhase3DsNames+cPhase4DsNames;
        
        //
        // Alloc Memory for Returning the reverse membership. If TWO_PHASE
        // logon was requested then alloc Max token size amount of memory.
        //
        
        *prpSids = (VOID**)THAllocEx(pTHS,
                     (TotalDsNames + cSidHistory1 + cSidHistory2 + cSidHistory3)
                     * sizeof(PSID)
                     );
        if (NULL==*prpSids)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        
        //
        // Copy In the  SIDS for all the DS Names that we obtained.
        // Note we need not check for duplicates because
        //
        
        *pcSids=0;
        for (i=0;i<cPhase1DsNames;i++)
        {
           Assert(Phase1DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase1DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase1DsNames;
        for (i=0;i<cPhase2DsNames;i++)
        {
           Assert(Phase2DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase2DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase2DsNames;
        for (i=0;i<cPhase3DsNames;i++)
        {
           Assert(Phase3DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase3DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase3DsNames;
        for (i=0;i<cPhase4DsNames;i++)
        {
           Assert(Phase4DsNames[i]->SidLen > 0);
           (*prpSids)[i+*pcSids] = &(Phase4DsNames[i]->Sid);
        }
        
        *pcSids+=cPhase4DsNames;
        
        //
        // Merge In the Sid History
        //
    
        for (i=0;i<cSidHistory1;i++)
        {
           (*prpSids)[(*pcSids)++] = rgSidHistory1[i];
        
        }
    
        for (i=0;i<cSidHistory2;i++)
        {
            (*prpSids)[(*pcSids)++] = rgSidHistory2[i];
    
        }
        for (i=0;i<cSidHistory3;i++)
        {
            (*prpSids)[(*pcSids)++] = rgSidHistory3[i];
    
        }

    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The Transaction should be kept open, for further processing
    // by SAM
    //

Error:

    if (TempDsNames0)
    {
        THFreeEx(pTHS, TempDsNames0);
        TempDsNames0 = NULL;
    }
    if (TempDsNames1)
    {
        THFreeEx(pTHS, TempDsNames1);
        TempDsNames1 = NULL;
    }
    if (TempDsNames2)
    {
        THFreeEx(pTHS, TempDsNames2);
        TempDsNames2 = NULL;
    }
    if (TempDsNames3)
    {
        THFreeEx(pTHS, TempDsNames3);
        TempDsNames3 = NULL;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*prpSids)
        {
            THFreeEx(pTHS, *prpSids);
            *prpSids = NULL;
            *pcSids = 0;
        }
    }


    //
    // Return STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY, if we could not contact the G.C and
    // evaluated memberships locally
    //

    if (fPartialMemberships && (NT_SUCCESS(NtStatus)))
        NtStatus = STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY;

    return NtStatus;
}


NTSTATUS
GetAccountMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS* pAccountMemberships
    )
/*++

Routine Description:

    This routine obtains the account group memberships for Users.

Parameters:

    pTHS -- thread state
    
    Flags -- flags for SampGetGroupsForToken
    
    Count -- number of elements in Users
    
    Users -- an array of users in dsname format
    
    ppAccountMemberships -- the account memberships of Users

Return Values

    STATUS_SUCCESS, a resource error otherwise.
    
 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    BOOLEAN fMixedDomain = ((Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN)!=0);

    for (i = 0; (i < Count) && NT_SUCCESS(NtStatus); i++) {

        //
        // Call SampGetMemberships
        //
        NtStatus = SampGetMemberships(
                        &Users[i],
                        1,
                        gAnchor.pDomainDN,
                        fMixedDomain?RevMembGetGroupsForUser:RevMembGetAccountGroups,
                        &pAccountMemberships[i].MembershipCount,
                        &pAccountMemberships[i].Memberships,
                        NULL,
                        &pAccountMemberships[i].SidHistoryCount,
                        &pAccountMemberships[i].SidHistory
                        );


    }

    return NtStatus;
}

NTSTATUS
GetUniversalMembershipsBatching(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc,
    IN  LPWSTR  PreferredGcDomain,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  AUG_MEMBERSHIPS* AccountMemberships,
    OUT AUG_MEMBERSHIPS* UniversalMemberships
    )
/*++

Routine Description:

    This routine gets the universal group memberships for Users by
    calling I_DRSGetMemberships2, which allows for multiple users
    to passed in.

                         
    N.B.  This routine assumes that a GC is passed in.  Support for
    FindGC has not been added.                         

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err;
    DRS_MSG_GETMEMBERSHIPS2_REQ   Req;
    DRS_MSG_GETMEMBERSHIPS2_REPLY Reply;
    ULONG                         ReplyVersion;
    ULONG i;

    memset(&Req, 0, sizeof(Req));
    memset(&Reply, 0, sizeof(Reply));

    Assert(NULL != PreferredGc);
    Assert(NULL != PreferredGcDomain);

    err = I_DRSIsExtSupported(pTHS, PreferredGc, DRS_EXT_GETMEMBERSHIPS2);
    if (err) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Setup the request
    //
    Req.V1.Count = Count;
    Req.V1.Requests = (DRS_MSG_REVMEMB_REQ_V1*) THAllocEx(pTHS, Count * sizeof(*Req.V1.Requests));
    for ( i = 0; i < Count; i++ ) {

        COLLECT_NAMES(&Users[i], 
                      1,
                      AccountMemberships[i].Memberships,
                      AccountMemberships[i].MembershipCount,
                      Req.V1.Requests[i].ppDsNames, 
                      Req.V1.Requests[i].cDsNames)

        Req.V1.Requests[i].dwFlags = 0;
        Req.V1.Requests[i].OperationType = RevMembGetUniversalGroups;
        Req.V1.Requests[i].pLimitingDomain = NULL;

    }

    //
    // Make the call
    //
    err = I_DRSGetMemberships2(pTHS,
                               PreferredGc,
                               PreferredGcDomain,
                               1,
                               &Req,
                               &ReplyVersion,
                               &Reply);

    if (err) {
        // BUGBUG -- Reliability -- more error handling?
        goto Error;
    }
    Assert(ReplyVersion == 1);

    //
    // Unpackage the request
    //
    for ( i = 0; i < Count; i++ ) {
        if (ERROR_SUCCESS == Reply.V1.Replies[i].errCode ) {
            UniversalMemberships[i].MembershipCount = Reply.V1.Replies[i].cDsNames;
            UniversalMemberships[i].Memberships = Reply.V1.Replies[i].ppDsNames;
            UniversalMemberships[i].Attributes = Reply.V1.Replies[i].pAttributes;
            UniversalMemberships[i].SidHistoryCount  = Reply.V1.Replies[i].cSidHistory;
            UniversalMemberships[i].SidHistory = (PSID*)Reply.V1.Replies[i].ppSidHistory;
        } else {
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
    }

Error:

    if (err) {
        for ( i = 0; i < Count; i++) {
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
    }

    //
    // Free the request
    //
    if (Req.V1.Requests) {
        for (i = 0; i < Count; i++) {
            if (Req.V1.Requests[i].ppDsNames) {
                THFreeEx(pTHS, Req.V1.Requests[i].ppDsNames);
            }
        }
        THFreeEx(pTHS, Req.V1.Requests);
    }

    return NtStatus;
}
    
NTSTATUS
GetUniversalMembershipsSequential(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS* pAccountMemberships,
    OUT AUG_MEMBERSHIPS* pUniversalMemberships
    )
/*++

Routine Description:

    This routine gets the universal group memberships 'sequentially' by 
    calling I_DRSGetMemberships for each user individually.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/
 {
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    LPWSTR GCName = NULL;
    LPWSTR GCDomain;
    DWORD err;
    NTSTATUS ActualNtStatus = STATUS_SUCCESS;
    FIND_DC_INFO *pGCInfo = NULL;
    DSNAME **TempDsNames = NULL;
    ULONG   cTempDsNames = 0;


    //
    // If no preferred GC, call FindGCInfo later
    //
    if (NULL != PreferredGc) {
        Assert(NULL != PreferredGcDomain);
        GCName = PreferredGc;
        GCDomain = PreferredGcDomain;
    }

    for ( i = 0; i < Count; i++ ) {
    
        ULONG attempts = 0;
        BOOL  fRemoteFailure = FALSE;

        // Merge in the user name
        COLLECT_NAMES(&Users[i],
                      1,
                      pAccountMemberships->Memberships,
                      pAccountMemberships->MembershipCount,
                      TempDsNames,
                      cTempDsNames);
        
        do {

            if (GCName == NULL) {

                //
                // call info FindGCInfo
                //
                err = FindGC(FIND_DC_USE_CACHED_FAILURES
                                 | FIND_DC_USE_FORCE_ON_CACHE_FAIL,
                               &pGCInfo);
                if (err)
                {
                    //
                    // Munge Any Errors to failures in locating
                    // a GC for the Domain
                    //
        
                    NtStatus = STATUS_DS_GC_NOT_AVAILABLE;

                } else {

                    GCName = pGCInfo->addr;
                    GCDomain = FIND_DC_INFO_DOMAIN_NAME(pGCInfo);
                }
            }

            //
            // Make the Reverse Membership call on the G.C
            //

            if (NT_SUCCESS(NtStatus))
            {
                err = I_DRSGetMemberships(
                            pTHS,
                            GCName,
                            GCDomain,
                            0,  // don't get attributes for universal memberships
                            TempDsNames,
                            cTempDsNames,
                            NULL,  // no limiting domain
                            RevMembGetUniversalGroups,
                            (DWORD *)&ActualNtStatus,
                            &pUniversalMemberships[i].MembershipCount,
                            &pUniversalMemberships[i].Memberships,
                            &pUniversalMemberships[i].Attributes,
                            &pUniversalMemberships[i].SidHistoryCount,
                            &pUniversalMemberships[i].SidHistory
                            );

                if (err && (NT_SUCCESS(ActualNtStatus)))
                {
                    //
                    // The Failure is an RPC Failure
                    // set an appropriate error code
                    //

                    NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
                    if (pGCInfo) {
                        InvalidateGC(pGCInfo, err);
                        GCName = NULL;
                        GCDomain = NULL;
                        fRemoteFailure = TRUE;
                    }
                }
                else
                {
                    NtStatus = ActualNtStatus;
                }
            }
        
            //
            // If failure caused by lack of GC and !PreferredGC
            // then call FindGCInfo again and retry call
            //
            attempts++;
        
        } while ( (attempts < 2) && fRemoteFailure );
    
    }
 
    if (pGCInfo) {
        THFreeEx(pTHS, pGCInfo);
    }


    return NtStatus;

}

NTSTATUS
GetUniversalMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  AUG_MEMBERSHIPS* AccountMemberships,
    OUT AUG_MEMBERSHIPS* UniversalMemberships
    )
/*++

Routine Description:

    This routine obtains the universal group memberships for Users.  If the
    batching method is available (new for Whistler) then it will be used;
    otherwise the downlevel method of making a network per user is used.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    STATUS_DS_GC_NOT_AVAILABLE
    
    nt resource errors otherwise.

 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOL     fUseSequentialMethod = TRUE;
    ULONG    i;

    //
    // First check if we need to go off machine
    //
    if ((SampAmIGC())||(Flags & SAM_GET_MEMBERSHIPS_NO_GC)) {

        //
        // We are the GC ourselves or have been instructed to not go to the
        // GC. Therefore obtain reverse memberships locally
        //
        for (i = 0; (i < Count) && NT_SUCCESS(NtStatus); i++) {

            DSNAME **TempDsNames = NULL;
            ULONG   cTempDsNames = 0;
        
            // Merge in the user name
            COLLECT_NAMES(&Users[i],
                          1,
                          AccountMemberships->Memberships,
                          AccountMemberships->MembershipCount,
                          TempDsNames,
                          cTempDsNames);


            NtStatus = SampGetMemberships(TempDsNames,
                                          cTempDsNames,
                                          NULL,
                                          RevMembGetUniversalGroups,
                                          &UniversalMemberships[i].MembershipCount,
                                          &UniversalMemberships[i].Memberships,
                                          NULL,
                                          &UniversalMemberships[i].SidHistoryCount,
                                          &UniversalMemberships[i].SidHistory);

            THFreeEx(pTHS, TempDsNames);
        }

        // We are done
        goto Cleanup;
    }

    //
    // We are going off machine -- end the current transaction
    //
    DBClose(pTHS->pDB, TRUE);

    if (  PreferredGc
      && (Count > 1) ) {

        fUseSequentialMethod = FALSE;

        //
        // GetUniversalMembershipsBatching doesn't support FindGCInfo
        // currently
        //

        //
        // Call into GetUniversalMembershipsBatching
        //
        NtStatus = GetUniversalMembershipsBatching(pTHS,
                                                   Flags,
                                                   PreferredGc,
                                                   PreferredGcDomain,
                                                   Count,
                                                   Users,
                                                   AccountMemberships,
                                                   UniversalMemberships);
        if (STATUS_NOT_SUPPORTED == NtStatus) {
            fUseSequentialMethod = TRUE;
        }
    }

    if (fUseSequentialMethod) {

        //
        // Call into GetUniversalMembershipsSequential
        //
        NtStatus = GetUniversalMembershipsSequential(pTHS,
                                                     Flags,
                                                     PreferredGc,
                                                     PreferredGcDomain,
                                                     Count,
                                                     Users,
                                                     AccountMemberships,
                                                     UniversalMemberships);

    }

Cleanup:

    if ( STATUS_DS_GC_NOT_AVAILABLE == NtStatus ) {
        // Set the partial information
        for (i = 0; i < Count; i++) {
            freeAUGMemberships(pTHS, &UniversalMemberships[i]);
            memset(&UniversalMemberships[i], 0, sizeof(AUG_MEMBERSHIPS));
            UniversalMemberships[i].Flags |= AUG_PARTIAL_MEMBERSHIP_ONLY;
        }
        NtStatus = STATUS_SUCCESS;
    }

    return NtStatus;
}



NTSTATUS
GetAccountAndUniversalMembershipsWorker(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    OUT AUG_MEMBERSHIPS **ppAccountMemberships,
    OUT AUG_MEMBERSHIPS **ppUniversalMemberships
    )
/*++

Routine Description:

    This routine performs the work obtaining the group memberships from the
    local directory as well as remotely for the universal groups if
    necessary.

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    AccountMemberships -- the account memberships and sid histories obtained
                          for Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         


Return Values

    STATUS_SUCCESS, 
    
    nt resource errors otherwise.


 --*/    
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    AUG_MEMBERSHIPS *accountMemberships = NULL;
    AUG_MEMBERSHIPS *universalMemberships = NULL;


    // Allocate the space for the UniversalMemberships
    accountMemberships =   (AUG_MEMBERSHIPS*)THAllocEx(pTHS,
                                                       Count * sizeof(AUG_MEMBERSHIPS));

    universalMemberships = (AUG_MEMBERSHIPS*)THAllocEx(pTHS, 
                                                       Count * sizeof(AUG_MEMBERSHIPS));

    NtStatus = GetAccountMemberships(pTHS,
                                     Flags,
                                     Count,
                                     Users,
                                     accountMemberships);

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    if (Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN) {

        //
        // No universal memberships
        //
        Assert(Count == 1);
        universalMemberships[0].MembershipCount = 0;
        universalMemberships[0].SidHistoryCount = 0;

    } else {

        NtStatus = GetUniversalMemberships(pTHS,
                                           Flags,
                                           PreferredGc,
                                           PreferredGcDomain,
                                           Count,
                                           Users,
                                           accountMemberships,
                                           universalMemberships);

    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Return the OUT parameters
    //
    *ppAccountMemberships = accountMemberships;
    *ppUniversalMemberships = universalMemberships;
    accountMemberships = NULL;
    universalMemberships = NULL;

Cleanup:

    if (accountMemberships) {
        freeAUGMemberships(pTHS, accountMemberships);
        THFreeEx(pTHS, accountMemberships);
    }
    if (universalMemberships) {
        freeAUGMemberships(pTHS, universalMemberships);
        THFreeEx(pTHS, universalMemberships);
    }

    return NtStatus;
}


NTSTATUS
GetAccountAndUniversalMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  BOOL    fRefreshTask,
    OUT AUG_MEMBERSHIPS **ppAccountMemberships OPTIONAL,
    OUT AUG_MEMBERSHIPS **ppUniversalMemberships OPTIONAL
    )
/*++

Routine Description:

    This routine obtains the account and universal memberships of a
    set of users.  It may involve performing a network call to obtain
    the universal memberships, thus any open transaction will be closed.
    If caching is enabled, then values from the cache will be used.

Parameters:

    pTHS -- thread state
    
    Flags -- same as SamIGetUserLogonInformation
    
    PreferredGc -- string name of GC to contact, should be DNS form
    
    PreferredGcDomain -- the domain that PreferredGc is in. Needed for
                         SPN creation
                         
    Count -- the number of Users
    
    Users -- the users for whom to obtain the group memberhship
    
    RefreshTask -- TRUE if the caller is the group refresh task; FALSE otherwise
    
    AccountMemberships -- the account memberships and sid histories of Users
    
    UniversalMemberships -- the universal memberships and sid histories obtained
                            for Users                         

Return Values

    STATUS_SUCCESS, 
    
    nt resource errors otherwise.

 --*/    
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;
    AUG_MEMBERSHIPS *pUniversalMemberships = NULL;
    AUG_MEMBERSHIPS *pAccountMemberships = NULL;
    BOOL fDontUseCache;

    fDontUseCache =  (Flags & SAM_GET_MEMBERSHIPS_NO_GC)
                  || (Flags & SAM_GET_MEMBERSHIPS_MIXED_DOMAIN);


    //
    // Check cache
    //

    if (  !fDontUseCache
       && !fRefreshTask
       && isGroupCachingEnabled()
       && (1 == Count) ) {

        //
        // Currently don't support cases where some users have caches
        // and other's don't.
        //
        NtStatus = GetMembershipsFromCache(Users[0],
                                          &pAccountMemberships,
                                          &pUniversalMemberships);

        if (NT_SUCCESS(NtStatus)) {

            DPRINT1(3, "Cache successful for user %ws\n", Users[0]->StringName);
            // Done
            *ppAccountMemberships = pAccountMemberships;
            *ppUniversalMemberships = pUniversalMemberships;
            return NtStatus;
        } else {
            DPRINT1(3, "Cache failed for user %ws\n", Users[0]->StringName);
        }
        //
        // Else contine on to perform the work of getting the
        // memberships
        //

    }

    //
    // Perform a full group expansion
    //
    NtStatus = GetAccountAndUniversalMembershipsWorker(pTHS,
                                                       Flags,
                                                       PreferredGc,
                                                       PreferredGcDomain,
                                                       Count,
                                                       Users,
                                                       &pAccountMemberships,
                                                       &pUniversalMemberships);

    if ( !fDontUseCache
     &&  isGroupCachingEnabled()
     &&  NT_SUCCESS(NtStatus) ) {

        //
        // Cache the results
        //
        for ( i = 0; i < Count; i++) {

            if (!(pUniversalMemberships)[i].Flags & AUG_PARTIAL_MEMBERSHIP_ONLY) {

                NTSTATUS IgnoreStatus;

                IgnoreStatus = CacheMemberships(Users[i],
                                              &(pAccountMemberships)[i],
                                              &(pUniversalMemberships)[i]);

                if (NT_SUCCESS(IgnoreStatus)) {
                    DPRINT1(3, "Cache save successful for user %ws\n", Users[i]->StringName);
                } else {

                    DPRINT2(3, "Cache save failed for user %ws (0x%x)\n", Users[i]->StringName,
                            IgnoreStatus);
                }
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        if (ppAccountMemberships) {
            *ppAccountMemberships = pAccountMemberships;
            pAccountMemberships = NULL;
        }
        if (ppUniversalMemberships) {
            *ppUniversalMemberships = pUniversalMemberships;
            pUniversalMemberships = NULL;
        }
    }

    if (pAccountMemberships) {
        freeAUGMemberships(pTHS, pAccountMemberships);
        THFreeEx(pTHS, pAccountMemberships);
    }

    if (pUniversalMemberships) {
        freeAUGMemberships(pTHS, pUniversalMemberships);
        THFreeEx(pTHS, pUniversalMemberships);
    }

    return NtStatus;

}

} //extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\samwrite.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samwrite.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains all SAMP_SAM_WRITE_FUNCTION_PTR implementations
    as defined in mappings.h.  These routines write all mapped properties
    which are tagged as SamWriteRequired.

    Call arguments include the entire SAMP_CALL_MAPPING even though each
    routine writes only a single attribute (at present).  In the future
    we can optimize the write calls by scanning ahead and writing multiple
    SamWriteRequired attributes in a single Samr* call.  But for now,
    we take the simplistic approach and write attributes individually.

    Each routine has the same arguments so we document them once here.

    Routine Description:

        Writes the attribute and object type named by the routine.
        Each routine name has the form SampWrite<type><attribute> as
        in SampWriterUserSecurityDescriptor.  Where possible, the
        <attribute> component matches the field name in the
        corresponding information struct.

    Arguments:

        hObj - open SAMPR_HANDLE for the object to write.

        iAttr - index into rCallMap representing the attribute to write.

        pObject - pointer to DSNAME of object being written.  Only used
            for error reporting.

        cCallMap - number of elements in rCallMap.

        rCallMap - address of SAMP_CALL_MAPPING array representing all
            attributes being modified by the high level Dir* call.

    Return Value:

        0 on success, !0 otherwise.  Sets pTHStls->errCode on error.

Author:

    DaveStr     01-Aug-96

Environment:

    User Mode - Win32

Revision History:

    As we move all loopback functions to SAMSRV.DLL (sam\server\dsmodify.c)
    most of below routines are not going to used any longer. 
    
    Once the SAM Lockless loopback mechanism runs stable. 
    We should remove those no longer used APIs

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>

// SAM interoperability headers
#include <mappings.h>
#include <samwrite.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#define DEBSUB "SAMWRITE:"      // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_SAMWRITE

// SAM headers
#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <ridmgr.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Local helpers                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
SampInitRpcUnicodeStringFromAttrVal(
    RPC_UNICODE_STRING  *pUnicodeString,
    ATTRVAL             *pAttrVal)

/*++

Routine Description:

    Initializes a RPC_UNICODE_STRING from an ATTRVAL.

Arguments:

    pUnicodeString - pointer to RPC_UNICODE_STRING to initialize.

    pAttrVal - pointer to ATTRVAL providing initialization value.

Return Value:

    None.

--*/

{
    if ( 0 == pAttrVal->valLen )
    {
        pUnicodeString->Length = 0;
        pUnicodeString->MaximumLength = 0;
        pUnicodeString->Buffer = NULL;
    }
    else
    {
        pUnicodeString->Length = (USHORT) pAttrVal->valLen;
        pUnicodeString->MaximumLength = (USHORT) pAttrVal->valLen;
        pUnicodeString->Buffer = (PWSTR) pAttrVal->pVal;
    }
}

#if defined LOOPBACK_SECURITY

ULONG
SampWriteSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic security descriptor writing routine for all classes of SAM
    objects.

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    0 on success, !0 otherwise.

--*/
{
    NTSTATUS                        status;
    SAMPR_SR_SECURITY_DESCRIPTOR    sd;
    ATTR                            *pAttr = &rCallMap[iAttr].attr;

    // This attribute is a single-valued byte array and must exist, thus
    // only AT_CHOICE_REPLACE_ATT is allowed.

    if ( (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) ||
         (1 != pAttr->AttrVal.valCount) ||
         (0 == pAttr->AttrVal.pAVal[0].valLen) )
    {
        SetAttError(
                pObject,
                pAttr->attrTyp,
                PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                NULL,
                DIRERR_SINGLE_VALUE_CONSTRAINT);

        return(pTHStls->errCode);
    }

    sd.Length = pAttr->AttrVal.pAVal[0].valLen;
    sd.SecurityDescriptor = (PUCHAR) pAttr->AttrVal.pAVal[0].pVal;

    status = SamrSetSecurityObject(
                            hObj,
                            ( OWNER_SECURITY_INFORMATION |
                              GROUP_SECURITY_INFORMATION |
                              DACL_SECURITY_INFORMATION |
                              SACL_SECURITY_INFORMATION ),
                            &sd);

    if ( !NT_SUCCESS(status) )
    {
        if ( 0 == pTHStls->errCode )
        {
            SampMapSamLoopbackError(status);

           
        }

        return(pTHStls->errCode);
    }

    return(0);
}

#endif // LOOPBACK_SECURITY

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Default write function which sets an error.                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampWriteNotAllowed(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    // We should not get here in the typical case because
    // SampAddLoopbackRequired and SampModifyLoopbackRequired should
    // have returned an error back when we first detectd that the client
    // was trying to write a mapped attribute whose writeRule is SamReadOnly.
    // This function exists mostly to avoid dereferencing a NULL function
    // pointer in the mapping table.  The exception is the case of password
    // modification where SampModifyLoopbackRequired lets ATT_UNICODE_PWD
    // writes through so that we can detect the special change password
    // condition in SampWriteSamAttributes.  However, if the condition is
    // not met, we'll end up here at which time we should return an error.

    SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
    return(pTHStls->errCode);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Server object attribute write routines                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteServerSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Domain object attribute write routines                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteDomainSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Group object attribute write routines                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteGroupSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY



//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Alias object attribute write routines                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteAliasSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// User object attribute write routines                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if defined LOOPBACK_SECURITY

ULONG
SampWriteUserSecurityDescriptor(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    return(SampWriteSecurityDescriptor(
                                hObj,
                                iAttr,
                                pObject,
                                cCallMap,
                                rCallMap));
}

#endif // LOOPBACK_SECURITY





BOOLEAN
SampIsSecureLdapConnection(
    VOID
    )
/*++

Routine Description:

    Verify that this is a secure enough connection - one of the 
    requirements for accepting passwords sent over the wire.

Parameter:

    None:
    
Return Value:

    TRUE  - yes, it is a secure connection

    FALSE - no

--*/

{
    return( pTHStls->CipherStrength >= 128 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\secadmin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       
//
//--------------------------------------------------------------------------

/*++

Module Name:

    secadmin.c

Abstract:

    This module contains routines for implementing protection of administrative groups


Author:

    Murli Satagopan   (MURLIS)   6-Feb-99

Revision History:



--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <samsrvp.h>
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

// Filter and Attribute 
#include <filtypes.h>                   // header for filter type
#include <attids.h>                     // attribuet IDs 
#include <sddl.h>
#include <mappings.h>

#include <msaudite.h>


#include "debug.h"                      // standard debugging header
#define DEBSUB     "SECADMIN:"          // define the subsystem for debugging


#include <fileno.h>                     // used for THAlloEx, but I did not 
#define  FILENO FILENO_SECADMIN         // use it in this module





/*

    Theory of Operation



    NT4 and earlier releases of NT protected the users in Administrative groups by
    changing the ACL on the member as they were added to the group. NT5 cannot adopt
    this strategy as 

        1. NT5 supports nested groups ( NT4 did not have group nesting )
        2. NT5 supports universal groups which can have members in other domain domains
           and could themselves be members of groups in other domains.


    NT5 implements protection of administrative groups by a background daemon. This daemon
    first computes the set of memberships in transitive fashion of all administrative groups.
    It then walks the list of objects that it has and checks whether the security descriptor
    on them is a well known protected security descriptor. If the well known protected security
    descriptor is not set then this security descriptor is set on the object. This task is
    executed only on the PDC FSMO holder.

--*/

NTSTATUS
SampBuildAdministratorsSet(
    THSTATE * pTHS,
    DSNAME * AdministratorsDsName,
    DSNAME * EnterpriseAdminsDsName,
    DSNAME * SchemaAdminsDsName,
    DSNAME * DomainAdminsDsName,
    PULONG  pcCountOfMembers,
    PDSNAME **prpMembers
    );



NTSTATUS
SampReadAdminSecurityDescriptor(
    PVOID *ProtectedSecurityDescriptor,
    PULONG ProtectedSecurityDescriptorLength                
    )

/*++

    Routine Description

    This routine reads the security descriptor off of the AdminSD object
    in the system container

    Also updates the security descriptor if necessary 

    Paramters

        ProtectedSecurityDescriptor
        ProtectedSecurityDescriptorLength

    Return Values

        STATUS_SUCCESS
        Other Error codes
--*/
{
    THSTATE     *pTHS = pTHStls;
    NTSTATUS    Status = STATUS_SUCCESS;
    READARG     ReadArg;
    READRES     *pReadRes;
    ENTINFSEL   EntInf;
    ATTR        SecurityDescriptorAttr;
    LONG        ObjectLen =0;
    DSNAME      *pSystemContainerDN = NULL;
    DSNAME      *pAdminSDHolderDN= NULL;
    DWORD       dwErr=0;
    NTSTATUS    IgnoreStatus;
    BOOL        Result;
    PACL        Sacl = NULL;
    BOOL        SaclPresent;
    BOOL        SaclDefaulted;
   

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
    EntInf.AttrTypBlock.attrCount = 1;
    RtlZeroMemory(&SecurityDescriptorAttr,sizeof(ATTR));
    SecurityDescriptorAttr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    EntInf.AttrTypBlock.pAttr = &SecurityDescriptorAttr;

    //
    // Get the object name of the object that holds the security descriptor
    //

    ObjectLen = AppendRDN(
                    gAnchor.pDomainDN,
                    pSystemContainerDN,
                    0,
                    L"System",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(ObjectLen>0);


    pSystemContainerDN = THAlloc(ObjectLen);
    if (!pSystemContainerDN)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    dwErr        = AppendRDN(
                    gAnchor.pDomainDN,
                    pSystemContainerDN,
                    ObjectLen,
                    L"System",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(0==dwErr);
    if (0!=dwErr)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    ObjectLen    = AppendRDN(
                    pSystemContainerDN,
                    pAdminSDHolderDN,
                    0,
                    L"AdminSDHolder",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(ObjectLen>0);


    pAdminSDHolderDN = THAlloc(ObjectLen);
    
    if (!pAdminSDHolderDN)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    dwErr        = AppendRDN(
                    pSystemContainerDN,
                    pAdminSDHolderDN,
                    ObjectLen,
                    L"AdminSDHolder",
                    0,
                    ATT_COMMON_NAME
                    );

    Assert(0==dwErr);

    if (0!=dwErr)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // init ReadArg
    //

    RtlZeroMemory(&ReadArg, sizeof(READARG));


    //
    // Build the commarg structure
    //

    InitCommarg(&(ReadArg.CommArg));
    

    //
    // Setup the Read Arg Structure
    //

   

    ReadArg.pObject = pAdminSDHolderDN;
    ReadArg.pSel    = & EntInf;

    //
    // Read the security descriptor
    //

    dwErr = DirRead(&ReadArg,&pReadRes);

    if (0!=dwErr)
    {
        THClearErrors();
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    Assert(1==pReadRes->entry.AttrBlock.attrCount);
    Assert(ATT_NT_SECURITY_DESCRIPTOR == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);

    *ProtectedSecurityDescriptorLength = pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;
    *ProtectedSecurityDescriptor = pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;


    //
    // get SACL's address
    //

    Result = GetSecurityDescriptorSacl((PSECURITY_DESCRIPTOR)*ProtectedSecurityDescriptor,
                                       &SaclPresent,
                                       &Sacl,
                                       &SaclDefaulted);

    if ( !Result || 
         !SaclPresent ||
         (NULL == Sacl) )
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Set SACL's revision value to ACL_REVISION_DS (4) 
    // 
    // why is that? 
    //     1. Once SACL's revision value becomes to ACL_REVISION_DS, 
    //        currently, there is no way (manually or through any api) 
    //        to bring it back to ACL_REVISION (2). However, you can always
    //        set SACL's revision value from ACL_REVISION to ACL_REVISION_DS
    // 
    //     2. During dcpromo time, some objects (group 1) will get ACL_REVISION_DS, 
    //        while others (say group2 ) get ACL_REVISION.
    //
    //     Due to above 2 facts, protecting admin groups task will keep trying to 
    //     modify group1's security descriptor to set the SACL revision to
    //     ACL_REVISION, and always fails silently. Thus causes the Win2000 PDC to
    //     Windows NT4 BDC replication constantly.
    //
    // So the solution to this problem is to force every admin protected object
    // has ACL_REVISION_DS as the SACL revision. To filfull the job, simple modify
    // adminSDHolder should be enought.
    // 

    if (ACL_REVISION_DS == Sacl->AclRevision)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        MODIFYARG   ModifyArg;
        MODIFYRES   *pModifyRes = NULL;
        ATTRVAL     SecurityDescriptorVal;

        Sacl->AclRevision = ACL_REVISION_DS; 

        RtlZeroMemory(&ModifyArg, sizeof(MODIFYARG));
        ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
        ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SecurityDescriptorVal;
        SecurityDescriptorVal.valLen = *ProtectedSecurityDescriptorLength;
        SecurityDescriptorVal.pVal = *ProtectedSecurityDescriptor;
        ModifyArg.FirstMod.pNextMod = NULL;
        InitCommarg(&(ModifyArg.CommArg));
        ModifyArg.pObject = pAdminSDHolderDN;
        ModifyArg.count = 1;

        dwErr = DirModifyEntry(&ModifyArg, &pModifyRes); 

        if (0 != dwErr)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    

Error:
    if (pSystemContainerDN) {
        THFreeEx(pTHS,pSystemContainerDN);
    }
    if (pAdminSDHolderDN) {
        THFreeEx(pTHS,pAdminSDHolderDN);
    }

    return(Status);
        
}




VOID
SampBuildNT4FullSid(
    IN NT4SID * DomainSid,
    IN ULONG    Rid,
    IN NT4SID * AccountSid
    )
{
    RtlCopyMemory(AccountSid,DomainSid,RtlLengthSid((PSID) DomainSid));
    (*(RtlSubAuthorityCountSid((PSID) AccountSid)))++;
     *(RtlSubAuthoritySid(
            (PSID) AccountSid,
            *RtlSubAuthorityCountSid((PSID)AccountSid)-1
             )) = Rid;
}


VOID
SampCheckAuditing(
    OUT BOOLEAN *fAuditingEnabled
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;

    // 
    // init return value
    //
    *fAuditingEnabled = FALSE;

    NtStatus = LsaIQueryInformationPolicyTrusted(
                    PolicyAuditEventsInformation,
                    (PLSAPR_POLICY_INFORMATION *) &pPolicy
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        // Failed to query audit information, 
        // continue without auditing turned on.
        return;
    }

    if ( pPolicy->AuditingMode &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement] &
                    POLICY_AUDIT_EVENT_SUCCESS) 
       ) 
    {
        *fAuditingEnabled = TRUE;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAuditEventsInformation,
                                      (PLSAPR_POLICY_INFORMATION) pPolicy);
    
    return;
}




NTSTATUS
SampUpdateSecurityDescriptor(
    DSNAME * pObject,
    PVOID    ProtectedSecurityDescriptor,
    ULONG    ProtectedSecurityDescriptorLength, 
    PUNICODE_STRING pAccountName, 
    PBOOLEAN    fSecurityDescriptorChanged
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    MODIFYARG   ModifyArg;
    ATTRMODLIST NextMod;
    ATTRVAL     SecurityDescriptorVal;
    ATTRVAL     AdminCountVal;
    ULONG       AdminCount=1;
    MODIFYRES   *pModifyRes=NULL;
    DWORD       err=0;

    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    ENTINFSEL   EntInf;
    PVOID       OldSD = NULL;
    ULONG       OldSDLength = 0;
    ULONG       i = 0;
    ATTR        Attr[2];

    // init return value

    *fSecurityDescriptorChanged = FALSE;

    //
    // Inialize the ReadArg
    // 
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    RtlZeroMemory(Attr, sizeof(ATTR) * 2);
    Attr[0].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr[1].attrTyp = ATT_SAM_ACCOUNT_NAME;

    EntInf.AttrTypBlock.attrCount = 2;
    EntInf.AttrTypBlock.pAttr = Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = pObject;

    InitCommarg(&(ReadArg.CommArg));

    //
    // Read this object's security descriptor
    // 
    err = DirRead(&ReadArg, &pReadRes);

    if (0!=err)
    {
        THClearErrors();
        return( STATUS_UNSUCCESSFUL );
    }

    Assert(2 == pReadRes->entry.AttrBlock.attrCount);

    for (i = 0; i < pReadRes->entry.AttrBlock.attrCount; i++)
    {
        if (ATT_NT_SECURITY_DESCRIPTOR == pReadRes->entry.AttrBlock.pAttr[i].attrTyp)
        {
            OldSDLength = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
            OldSD = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
        }
        else if (ATT_SAM_ACCOUNT_NAME == pReadRes->entry.AttrBlock.pAttr[i].attrTyp)
        {
            pAccountName->Length = (USHORT) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
            pAccountName->Buffer = (PWSTR) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            pAccountName->MaximumLength = pAccountName->Length;
        }
        else
        {
            Assert(FALSE && "DirRead returns wrong Attribute\n");
        }
    }

    //
    // check whether the old security descriptor is the same value as
    // the one we are trying to set. If so, return success. 
    // By doing this optimization, we can reduce the Win2000 to NT4 
    // backup domain controller's replication overhead.
    // 

    if ((OldSDLength == ProtectedSecurityDescriptorLength) && 
        (RtlCompareMemory(OldSD, ProtectedSecurityDescriptor, OldSDLength) == 
         OldSDLength))
    {
        return( STATUS_SUCCESS );
    }
    
    //
    // Intialize the ModifyArg
    //
    
    RtlZeroMemory(&ModifyArg,sizeof(MODIFYARG));
    RtlZeroMemory(&NextMod,sizeof(ATTRMODLIST));
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SecurityDescriptorVal;
    SecurityDescriptorVal.valLen = ProtectedSecurityDescriptorLength;
    SecurityDescriptorVal.pVal = ProtectedSecurityDescriptor;
    AdminCountVal.valLen = sizeof(ULONG);
    AdminCountVal.pVal = (PUCHAR)&AdminCount;
    NextMod.choice =  AT_CHOICE_REPLACE_ATT;
    NextMod.AttrInf.attrTyp = ATT_ADMIN_COUNT;
    NextMod.AttrInf.AttrVal.valCount = 1;
    NextMod.AttrInf.AttrVal.pAVal = &AdminCountVal;
    ModifyArg.FirstMod.pNextMod = &NextMod;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.pObject = pObject;
    ModifyArg.count = 2;

    //
    // Write the new security descriptor and admin count. 
    //
    err = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (0!=err)
    {
        THClearErrors();
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        *fSecurityDescriptorChanged = TRUE;
    }

    return (Status);
}




NTSTATUS
SampProtectAdministratorsList()
/*++

    Routine Description

    This routine  is the main loop for a back ground task that
    protects the members in any of the 4 pre defined administrative
    groups.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AdministratorsSid[] = {0x201,0x05000000,0x20,0x220};
    DSNAME AdministratorsDsName;
    DSNAME DomainAdminsDsName;
    NT4SID  EnterpriseAdminsSid;
    NT4SID  SchemaAdminsSid;
    PSID    SidsToLookup[2];
    PDSNAME * EnterpriseAndSchemaAdminsDsNames = NULL;
    PDSNAME * rpMembers = NULL;
    ULONG   CountOfMembers;
    PVOID   ProtectedSecurityDescriptor = NULL;
    ULONG   ProtectedSecurityDescriptorLength = 0;
    ULONG   i;
    ULONG   err=0;
    THSTATE * pTHS= pTHStls;
    DOMAIN_SERVER_ROLE ServerRole;
    UNICODE_STRING  DomainName;
    UNICODE_STRING  AccountName;
    BOOLEAN AuditingEnabled = FALSE;
    BOOLEAN fAdministratorsSecurityDescriptorChanged = FALSE;
   

    __try
    {

        //
        // Are we the PDC ? ( Querying SAM is faster than
        // reading the DS as SAM keeps this cached in memory )
        //

        Status = SamIQueryServerRole2(
                    (PSID) &gAnchor.pDomainDN->Sid,
                    &ServerRole
                    );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        if (DomainServerRolePrimary!=ServerRole)
        {
            __leave;
        }

        //
        // Intialize
        //

        RtlZeroMemory(&AdministratorsDsName,sizeof(DSNAME));
        RtlZeroMemory(&DomainAdminsDsName,sizeof(DSNAME));
        RtlInitUnicodeString(&DomainName, gAnchor.pDomainDN->StringName);
       

        //
        // Set fDSA in the thread state
        //

        pTHS->fDSA = TRUE;

        //
        // Build the SIDs/DSNames for the 4 administrative groups 
        //

        //
        // 1. Administrators
        //

    
        RtlCopyMemory(&AdministratorsDsName.Sid,AdministratorsSid,sizeof(AdministratorsSid));
        AdministratorsDsName.structLen = DSNameSizeFromLen(0);
        AdministratorsDsName.SidLen = RtlLengthSid(AdministratorsSid);

        //
        // 2. Domain Admins
        //

        SampBuildNT4FullSid(
                    &gAnchor.pDomainDN->Sid,
                    DOMAIN_GROUP_RID_ADMINS,
                    &DomainAdminsDsName.Sid
                    );


        DomainAdminsDsName.structLen = DSNameSizeFromLen(0);
        DomainAdminsDsName.SidLen = RtlLengthSid(&DomainAdminsDsName.Sid);


        //
        // 3. Enterprise Admins
        //

        SampBuildNT4FullSid(
                    &gAnchor.pRootDomainDN->Sid,
                    DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    &EnterpriseAdminsSid
                    );

        //
        // 4. Schema Admins
        //

        SampBuildNT4FullSid(
                    &gAnchor.pRootDomainDN->Sid,
                    DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    &SchemaAdminsSid
                    );

        SidsToLookup[0] = &EnterpriseAdminsSid;
        SidsToLookup[1] = &SchemaAdminsSid;


        //
        // SID positioning in the core DS works only if the SID specified an object
        // in the same naming context as the domain that the DC is authoritative for.
        // This is not necessarily true for enterprise admins / schema admins. Therefore lookup the
        // GUID/ DSName on the G.C. A future performance optimization is do this lookup
        // just once after the boot and persist the guid.
        //

        err = SampVerifySids(
                    2,
                    (PSID *) SidsToLookup,
                    &EnterpriseAndSchemaAdminsDsNames
                    );

        if ((0 != err) || 
            (NULL == EnterpriseAndSchemaAdminsDsNames[0]) ||
            (NULL == EnterpriseAndSchemaAdminsDsNames[1]) )
        {
            __leave;
        }

      
        //
        // Get the list of DS Names, Directly or transitively a member
        // of this list
        //

        Status = SampBuildAdministratorsSet(
                    pTHS,
                    &AdministratorsDsName,
                    EnterpriseAndSchemaAdminsDsNames[0], // enterprise admins
                    EnterpriseAndSchemaAdminsDsNames[1], // schema admins
                    &DomainAdminsDsName,
                    &CountOfMembers,
                    &rpMembers
                    );

        if (!NT_SUCCESS(Status))
        {
            __leave;
        }


        //
        // Retrieve the security Descriptor that will be used for
        // protecting the admin accounts
        //
      

        Status = SampReadAdminSecurityDescriptor(
                    &ProtectedSecurityDescriptor,
                    &ProtectedSecurityDescriptorLength
                    );
        if (!NT_SUCCESS(Status))
        {
            __leave;
        }

        //
        // check whether Account Management Auditing is enabled or not.
        // 

        SampCheckAuditing(&AuditingEnabled);
                   
        //
        // The list is now ready, walk through and update the ACL
        //           

        for (i=0;i<CountOfMembers;i++)
        {
            
            NT4SID      DomainSid;
            ULONG       Rid;
            BOOLEAN     fSecurityDescriptorChanged = FALSE;

            //
            // We do not have to write anything if the member is not in the
            // same domain as this DC is authoritative for. If we are not
            // authoritative for this domain then skip.
            //

            if (0==rpMembers[i]->SidLen)
            {
                //
                // Do not need to touch non security principals
                //

                continue ;
            }

            SampSplitNT4SID(&rpMembers[i]->Sid,&DomainSid,&Rid);

            

            if (!RtlEqualSid((PSID) &DomainSid, &gAnchor.pDomainDN->Sid))
            {
                //
                // Not from our domain, skip and try the next entry
                //

                continue;
            }

            Status = SampUpdateSecurityDescriptor(
                        rpMembers[i],
                        ProtectedSecurityDescriptor,
                        ProtectedSecurityDescriptorLength,
                        &AccountName, 
                        &fSecurityDescriptorChanged
                        );

            if (NT_SUCCESS(Status) && !fSecurityDescriptorChanged)
            {
                //
                // this account's security descriptor has not been changed 
                // 
                continue;
            }

            //
            // EventLog the ACL reset
            // 

            if (AuditingEnabled)
            {
                LsaIAuditSamEvent(
                    Status,                         // Passed Status 
                    SE_AUDITID_SECURE_ADMIN_GROUP,  // Audit ID 
                    &DomainSid,                     // Domain SID 
                    NULL,                           // Aditional Info 
                    NULL,                           // Member Rid (not used) 
                    NULL,                           // Member Sid (not used) 
                    &AccountName,                   // Account Name 
                    &DomainName,                    // Domain Name 
                    &Rid,                           // Account Rid 
                    NULL
                    );
            }

            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_SUCCESS;
                continue;
            }     
          
        }

        //
        // Protect the administors group itself.
        //

        Status = SampUpdateSecurityDescriptor(
                    &AdministratorsDsName,
                    ProtectedSecurityDescriptor,
                    ProtectedSecurityDescriptorLength,
                    &AccountName, 
                    &fAdministratorsSecurityDescriptorChanged
                    );


    }
    __finally
    {

       
    }

    return(Status);
    
}

VOID
ProtectAdminGroups(
    VOID *  pV,
    VOID ** ppVNext,
    DWORD * pcSecsUntilNextIteration
    )
{

    __try {

        SampProtectAdministratorsList();

    } __finally {
        // Execute every hour
        *pcSecsUntilNextIteration = 3600;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\servinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servinfo.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <dsjet.h>		/* for error codes */
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
//#include "attids.h"
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers

#include <lmcons.h>                     // CNLEN
#include <lsarpc.h>                     // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>

#include <servinfo.h>

#include "debug.h"          // standard debugging header 
#define DEBSUB "SERVEINFO:"              // define the subsystem for debugging


// pause is currently 22 minutes.  Why?  Why not?
#define SERVER_INFO_WRITE_PAUSE (22 * 60)

#include <fileno.h>
#define  FILENO FILENO_SERVINFO

#define LDAPServiceType L"LDAP"
#define HostSpnType     L"HOST"
#define GCSpnType       L"GC"
#define ExchangeAbType  L"exchangeAB"
#define KadminSPNType   L"kadmin"
#define KadminInstanceType L"changepw"

PWCHAR  OurServiceClassVals[]={
    LDAPServiceType,
    HostSpnType,
    GCSpnType,
    DRS_IDL_UUID_W,
    ExchangeAbType
};
#define NUM_OURSERVICES (sizeof(OurServiceClassVals)/sizeof(WCHAR *))
ServiceClassArray OurServiceClasses = {
    NUM_OURSERVICES,
    OurServiceClassVals
};


// The HostSPNType isn't removed because that is used for non DC machine accounts
PWCHAR  OurServiceClassValsToRemove[]={
    LDAPServiceType,
    GCSpnType,
    DRS_IDL_UUID_W
};
#define NUM_OURSERVICESTOREMOVE (sizeof(OurServiceClassValsToRemove)/sizeof(WCHAR *))
ServiceClassArray ServicesToRemove = {
    NUM_OURSERVICESTOREMOVE,
    OurServiceClassValsToRemove
};

PWCHAR KerberosServiceClassVals[]={
    KadminSPNType
};
#define NUM_KERBEROSSERVICES (sizeof(KerberosServiceClassVals)/sizeof(WCHAR *))
ServiceClassArray KerberosServiceClasses = {
    NUM_KERBEROSSERVICES,
    KerberosServiceClassVals
};

gulKerberosAccountDNT = INVALIDDNT;


DWORD
FindKerbAccountDNT (
        THSTATE *pTHS
        );
BOOL
GetDnsRootAliasWorker( 
    THSTATE *pTHS,
    DBPOS *pDB,
    WCHAR * DnsRootAlias,
    WCHAR * RootDnsRootAlias )
/* This function will get the ATT_MS_DS_DNSROOTALIAS attributes from
   the current domain and the root domain crossref object.
   It expects DnsRootAlias and RootDnsRootAlias preallocated, and the
   size of each is DNS_MAX_NAME_BUFFER_LENGTH*/
{

    CROSS_REF *pDomainCF=NULL, *pRootDomainCF=NULL;
    COMMARG CommArg;
    DWORD cbBuff=sizeof(WCHAR)*DNS_MAX_NAME_BUFFER_LENGTH, cbActual=0;
    ATTCACHE *pAC;
    WCHAR *buff=THAllocEx(pTHS,sizeof(WCHAR)*DNS_MAX_NAME_BUFFER_LENGTH);
    BOOL rtn = FALSE;

    DnsRootAlias[0] = L'\0';
    RootDnsRootAlias[0] = L'\0';

    
    pAC=SCGetAttById(pTHS,ATT_MS_DS_DNSROOTALIAS);
    Assert(pAC);

    InitCommarg(&CommArg);
        
    //get the crossref objects

    pDomainCF = FindExactCrossRef(gAnchor.pDomainDN, &CommArg);
    Assert(pDomainCF);

    if (!pDomainCF) {
        goto cleanup;

    }

    pRootDomainCF = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
    Assert(pRootDomainCF);

    if (!pRootDomainCF) {
        goto cleanup;

    }
    
    if(DBFindDSName(pDB, pDomainCF->pObj)){
        goto cleanup;
    }
    
    if(!DBGetAttVal_AC( pDB,
                        1,
                        pAC,
                        DBGETATTVAL_fCONSTANT,
                        cbBuff,
                        &cbActual,
                        (PUCHAR *)&buff)){
        Assert(cbActual<=cbBuff);
        memcpy(DnsRootAlias,buff,cbActual);
        DnsRootAlias[cbActual/sizeof(WCHAR)]=0;
        
    }
    
    if(DBFindDSName(pDB, pRootDomainCF->pObj)){
        goto cleanup;
       
    }
    
    if(!DBGetAttVal_AC( pDB,
                        1,
                        pAC,
                        DBGETATTVAL_fCONSTANT,
                        cbBuff,
                        &cbActual,
                        (PUCHAR *)&buff)){
        Assert(cbActual<cbBuff);
        memcpy(RootDnsRootAlias,buff,cbActual);
        RootDnsRootAlias[cbActual/sizeof(WCHAR)]=0;

    }

    rtn = TRUE;
cleanup:
    THFreeEx(pTHS,buff);
    return rtn;

}


NTSTATUS
GetDnsRootAlias(
    WCHAR *pDnsRootAlias,
    WCHAR *pRootDnsRootAlias )
/* This function will get the ATT_MS_DS_DNSROOTALIAS attributes from
   the current domain and the root domain crossref object.
   It expects DnsRootAlias and RootDnsRootAlias preallocated, and the
   size of each is DNS_MAX_NAME_BUFFER_LENGTH.
   THSTATE will be allocated.  This function is exported to netlogon.*/
{
    THSTATE *pTHS=NULL;
    NTSTATUS ntstatus=STATUS_SUCCESS;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    
    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    if (NULL == pTHS) {
        ntstatus = STATUS_NO_MEMORY;
        return ntstatus;
    }
    pTHS->fDSA = TRUE;
    
    __try{
        DBOpen(&(pTHS->pDB));
        __try{
            ntstatus=GetDnsRootAliasWorker(pTHS,pTHS->pDB, pDnsRootAlias, pRootDnsRootAlias);
        }
        __finally{
             
            //End the transaction.  Faster to commit a read only
            // transaction than abort it - so set commit to TRUE.
            DBClose(pTHS->pDB,TRUE);
            pTHS->pDB = NULL;
        }
    }
    
    __except(GetExceptionData( GetExceptionInformation(),
                               &dwException,
                               &dwEA,
                               &ulErrorCode,
                               &dsid ) ){
        HandleDirExceptions(dwException, ulErrorCode, dsid );
        ntstatus = STATUS_UNSUCCESSFUL;
    }


    if (NULL != pTHS) {
        free_thread_state();
    }

    return ntstatus;
 
}


void
WriteSPNsHelp(
        THSTATE *pTHS,
        ATTCACHE *pAC_SPN,
        ATTRVALBLOCK *pAttrValBlock,
        ServiceClassArray *pClasses,
        BOOL *pfChanged
        )
{
    DWORD i, index;
    DWORD cbBuff = 0, cbActual = 0;
    WCHAR *pBuff = NULL;
    DWORD  cbServiceClass;
    WCHAR  ServiceClass[256];
    USHORT InstancePort;

    // Read the values that are already on the object and locate any that are
    // ours.  If they are ours and are in the list of new attributes to write,
    // remove the value from the list.  If they are ours and are not in the list
    // of new attributes to write, remove them from the object.  Finally, add
    // any remaining values in the list.

    index = 1;
    while(!DBGetAttVal_AC(
            pTHS->pDB,
            index,
            pAC_SPN,
            DBGETATTVAL_fREALLOC,
            cbBuff,
            &cbActual,
            (PUCHAR *)&pBuff)) {
        // Before we use this value, null terminate it in the buffer.
        if((cbActual + sizeof(WCHAR)) <= cbBuff) {
            // There is room to just add a NULL to the buffer
            pBuff[cbActual/sizeof(WCHAR)] = L'\0';
            // We aren't changing the size of the buffer, so cbBuff is already
            // correct. 
        }
        else {
            // Alloc up the buffer to have room for the NULL
            pBuff = THReAllocEx(pTHS, pBuff, cbActual + sizeof(WCHAR));
            pBuff[cbActual/sizeof(WCHAR)] = L'\0';

            // We have made the buffer large, so track the new size.
            cbBuff = cbActual + sizeof(WCHAR);
        }

        // Got an SPN.  Crack it apart.
        cbServiceClass = 256;
        DsCrackSpnW(pBuff,
                    &cbServiceClass, ServiceClass,
                    NULL, 0,
                    NULL, 0,
                    &InstancePort);
        if(cbServiceClass < 256) { // None of our service classes are longer
            BOOL fFound = FALSE;

            for(i=0;i<pClasses->count;i++) {
                if(2 == CompareStringW(
                        DS_DEFAULT_LOCALE,
                        DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                        ServiceClass,
                        cbServiceClass,
                        (WCHAR *)
                        pClasses->Vals[i],
                        wcslen(pClasses->Vals[i]))) {
                    fFound=TRUE;
                }
            }

            if(!fFound) {
                // Nope, not ours. Next value.
                index++;
                continue;
            }

            
            // Yep, it's ours.
            fFound = FALSE;
            
            //  See if it's in the list.
            for(i=0;i<pAttrValBlock->valCount;i++) {
                if(2 == CompareStringW(
                        DS_DEFAULT_LOCALE,
                        DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                        pBuff,
                        (cbActual / sizeof(WCHAR)),
                        (WCHAR *)pAttrValBlock->pAVal[i].pVal,
                        (pAttrValBlock->pAVal[i].valLen / sizeof(WCHAR)))) {
                    // Yep, remove it from the list
                    fFound = TRUE;
                    pAttrValBlock->valCount--;
                    // Next value.
                    index++;
                    if(i == pAttrValBlock->valCount) {
                        break;
                    }

                    // OK to use pAttrValBlock->valCount as opposed to
                    // (pAttrValBlock->valCount -1) because its already
                    // been decremented a moment ago.
                    
                    pAttrValBlock->pAVal[i].pVal =
                        pAttrValBlock->pAVal[pAttrValBlock->valCount].pVal;
                    pAttrValBlock->pAVal[i].valLen =
                        pAttrValBlock->pAVal[pAttrValBlock->valCount].valLen;
                    break;
                }
            }
            
            if(!fFound) {
                *pfChanged = TRUE;
                // Nope, remove it from the object.
                DBRemAttVal_AC(pTHS->pDB, pAC_SPN, cbActual, pBuff);
            }
        }
        else {
            // Not ours.  Next value.
            index++;
        }
    }

    if(pBuff) {
        THFreeEx(pTHS, pBuff);
    }
    
    for(i=0;i<pAttrValBlock->valCount;i++) {
        *pfChanged = TRUE;
        DBAddAttVal_AC(pTHS->pDB,
                       pAC_SPN,
                       pAttrValBlock->pAVal[i].valLen,
                       pAttrValBlock->pAVal[i].pVal); 
    }
}


DWORD
WrappedMakeSpnW(
        THSTATE *pTHS,
        WCHAR   *ServiceClass,
        WCHAR   *ServiceName,
        WCHAR   *InstanceName,
        USHORT  InstancePort,
        WCHAR   *Referrer,
        DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
        WCHAR  **ppszSpn
        )
{
    DWORD cSpnLength=128;
    WCHAR SpnBuff[128];
    DWORD err;

    cSpnLength = 128;
    err = DsMakeSpnW(ServiceClass,
                     ServiceName,
                     InstanceName,
                     InstancePort,
                     Referrer,
                     &cSpnLength,
                     SpnBuff);
    
    if(err && err != ERROR_BUFFER_OVERFLOW) {
        return err;
    }
    
    *ppszSpn = THAllocEx(pTHS, (cSpnLength * sizeof(WCHAR)));
    *pcbSpnLength = cSpnLength * sizeof(WCHAR);
    
    if(err == ERROR_BUFFER_OVERFLOW) {
        err = DsMakeSpnW(ServiceClass,
                         ServiceName,
                         InstanceName,
                         InstancePort,
                         Referrer,
                         &cSpnLength,
                         *ppszSpn);
        if(err) {
            return err;
        }
    }
    else {
        memcpy(*ppszSpn, SpnBuff, *pcbSpnLength);
    }
    Assert(*pcbSpnLength == (sizeof(WCHAR) * (1 + wcslen(*ppszSpn))));
    // Drop the null off.
    *pcbSpnLength -= sizeof(WCHAR);
    return 0;
}

BOOL
GetNetBIOSDomainName(
        THSTATE *pTHS,
        WCHAR **DomainName
        )
{
    CROSS_REF *pDomainCF = NULL;
    COMMARG CommArg;
    DWORD cbActual=0;
    DBPOS * pDBSave = pTHS->pDB;
    ATTCACHE *pAC;
    
    *DomainName = NULL;

    pTHS->pDB = NULL;
    pAC=SCGetAttById(pTHS,ATT_NETBIOS_NAME);
    Assert(pAC);

    DBOpen(&(pTHS->pDB));

    __try{
        InitCommarg(&CommArg);
        
        pDomainCF = FindExactCrossRef(gAnchor.pDomainDN, &CommArg);

        Assert(pDomainCF);

        if (!pDomainCF) {
            return FALSE;

        }
        
        if(DBFindDSName(pTHS->pDB, pDomainCF->pObj)){
            return FALSE;
           
        }
        
        if(DBGetAttVal_AC( pTHS->pDB,
                           1,
                           pAC,
                           DBGETATTVAL_fREALLOC,
                           0,
                           &cbActual,
                           (PUCHAR *)DomainName)){

            return FALSE;
        }else{
            (*DomainName) = THReAllocEx(pTHS,*DomainName,cbActual+sizeof(WCHAR));
        }
        
        
        
    } __finally
    {
        // End the transaction.  Faster to commit a read only
        // transaction than abort it - so set commit to TRUE.
        DBClose(pTHS->pDB,TRUE);
        pTHS->pDB = pDBSave;
        
    }

    return TRUE;
}
    
void
WriteServerInfo(
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
    )
/*++
Note: This routine is no longer called at GC promotion and demotion time to
re-write the SPNs that are GC-releated because there aren't any.  If there
are any GC related SPNs in the future, the code to enable is in
mdinidsa.c:UpdateGcAnchorFromDsaOptions().
--*/
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC_SPN, *pAC_DNSHostName, *pAC_ServerReference;
    ATTCACHE *pAC_osName, *pAC_osServicePack, *pAC_osVersionNumber;
    ATTCACHE *pACs[2];
    WCHAR *pwszOsName = L"Windows 2002 Server";

    WCHAR NetBIOSMachineName[CNLEN+1];
    DWORD cchNetBIOSMachineName = sizeof(NetBIOSMachineName)/sizeof(WCHAR);

    WCHAR   *NetBIOSDomainName;
    
    WCHAR   wComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   cchComputerName = sizeof(wComputerName)/sizeof(WCHAR);

    WCHAR   hostDnsName[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD   cchHostDnsName = sizeof(hostDnsName)/sizeof(WCHAR);

    WCHAR  *domainDnsName=NULL;

    WCHAR  domainDnsAlias[DNS_MAX_NAME_BUFFER_LENGTH+1];
    WCHAR  rootDomainDnsAlias[DNS_MAX_NAME_BUFFER_LENGTH+1];

    ATTR         *pCurrentAttr = NULL;
    DWORD         cCurrentOut;
    DWORD         i, j;
    ATTRVALBLOCK *pAdditionalDNSHostName = NULL;
    ATTRVALBLOCK *pAdditionalSamAccountName = NULL;

    WCHAR  *pszServerGuid = NULL;
    WCHAR  *pszDomainGuid = NULL;

    WCHAR  *pszGuidBasedDnsName = NULL;

    WCHAR  *pNameString[1];
    PDS_NAME_RESULTW servicename = NULL;
    DWORD   err;
    DWORD   dsid = 0;
   
    WCHAR  versionNumber[64];
    DWORD  cbVersionNumber;

    ATTRVALBLOCK AttrValBlock;
    ATTRVAL      *AttrVal;
    DWORD        AttrIndex;
    DWORD        cAllocated;
    
    ATTRVALBLOCK KerbAttrValBlock;
    ATTRVAL      KerbAttrVal[1];

    DWORD ulKerberosAccountDNT;
    
    BOOL   fSetVersionStuff = FALSE;
    DSNAME *pDN = NULL, *pTempDN=NULL;
    DWORD  len;
    BOOL   fCommit=FALSE,fChanged;
    OSVERSIONINFOW VersionInformationW;
    memset(&VersionInformationW, 0, sizeof(VersionInformationW));

    VersionInformationW.dwOSVersionInfoSize = sizeof(VersionInformationW);

    pTHS->fDSA = TRUE;
    
    __try {
        // Calcluate the SPNs

        pAC_SPN=SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
        pAC_DNSHostName=SCGetAttById(pTHS, ATT_DNS_HOST_NAME);
        pAC_ServerReference=SCGetAttById(pTHS, ATT_SERVER_REFERENCE);;
        pAC_osName=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM);
        pAC_osServicePack=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM_SERVICE_PACK);
        pAC_osVersionNumber=SCGetAttById(pTHS, ATT_OPERATING_SYSTEM_VERSION);
        
        pACs[0]=SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME);
        pACs[1]=SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME);

        if(!pAC_SPN || !pAC_DNSHostName || !pAC_ServerReference ||
           !pAC_osName || !pAC_osServicePack || !pAC_osVersionNumber ||
           !pACs[0] || !pACs[1] ) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // First, we need the raw data to form the SPNs out of.  We need:
        //
        // 1) DNS of the server (from GetComputerNameEx)
        // 2) DNS of the domain (from DsCrackNames)
        // 3) Name of the computer (from GetComputerNameW, we use it to actually
        //    find the object we're messing with).
        // 4) Guids for the server and domain objects


        if(!GetComputerNameW(&wComputerName[0], &cchComputerName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }
 
        // First DNS of the server
        if(!GetComputerNameExW(ComputerNameDnsFullyQualified,
                               hostDnsName,&cchHostDnsName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }

        // Strip trailing '.' if it exists so 1) we don't have to register
        // both dot, and dot-less versions, and 2) so we have a consistent
        // story for clients.  Its true that under official DNS rules, 
        // fully qualified DNS names have a '.' on the end, but in practice
        // few programmers adhere to this.  Various DNS-savvy persons have
        // agreed to this.

        if ( L'.' == hostDnsName[cchHostDnsName-1] )
        {
            hostDnsName[cchHostDnsName-1] = L'\0';
            cchHostDnsName--;
        }

        // Now DNS of the domain
        pNameString[0] = (WCHAR *)&(gAnchor.pDomainDN->StringName);

        err = DsCrackNamesW((HANDLE) -1,
                            (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                             DS_NAME_FLAG_SYNTACTICAL_ONLY),
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            pNameString,
                            &servicename);

        if ( err                                // error from the call
            || !(servicename->cItems)            // no items returned
            || (servicename->rItems[0].status)   // DS_NAME_ERROR returned
            || !(servicename->rItems[0].pName)   // No name returned
            ) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // This is just to improve readability.
        domainDnsName = servicename->rItems[0].pDomain;

        // Assert that we're not dot terminated.
        Assert(L'.' !=
               servicename->rItems[0].pName[wcslen(servicename->rItems[0].pName) - 2]);

        // Stringize some useful GUIDs
        err = UuidToStringW( &(gAnchor.pDSADN->Guid), &pszServerGuid );
        if (err) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        err = UuidToStringW( &(gAnchor.pDomainDN->Guid), &pszDomainGuid );
        if (err) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }


        // Now, the netbios machine name
        if(!GetComputerNameExW(ComputerNameNetBIOS,
                               NetBIOSMachineName,&cchNetBIOSMachineName)) {
            dsid = DSID(FILENO, __LINE__);
            err = GetLastError();
            __leave;
        }

        // THE netbios name of the domain
        if(!GetNetBIOSDomainName(pTHS, &NetBIOSDomainName)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }

        // Guid-based DNS name
        pszGuidBasedDnsName = TransportAddrFromMtxAddr( gAnchor.pmtxDSA );
        if (!pszGuidBasedDnsName) {
            __leave;
        }

        err = 0;

        DBOpen(&(pTHS->pDB));
        __try{
            
            // Domain DNS Alias and root domain DNS Alias
            if( !GetDnsRootAliasWorker(pTHS, 
                                       pTHS->pDB, 
                                       domainDnsAlias, 
                                       rootDomainDnsAlias )) {
                err = 1;
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
                
            
            // find the computer object of this DC;
            
            if(err = DBFindComputerObj(pTHS->pDB,
                                       cchComputerName,
                                       wComputerName)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            // Additional DNS Host Name
            // & Additional Sam Account Name
            if (err = DBGetMultipleAtts(pTHS->pDB,
                                        2,
                                        pACs,
                                        NULL,
                                        NULL,
                                        &cCurrentOut,
                                        &pCurrentAttr,
                                        DBGETMULTIPLEATTS_fEXTERNAL,
                                        0)) {

                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
        }__finally{
            //End the transaction.  Faster to commit a read only
            // transaction than abort it - so set commit to TRUE.
            DBClose(pTHS->pDB,TRUE);
            pTHS->pDB = NULL;
        }
        
        // error occurs in above __try block, bail
        if (err) {
            __leave;
        }

        // get the additionalDnsHostname and additionalSamAccountName

        for(i=0;i<cCurrentOut;i++) {
            switch(pCurrentAttr[i].attrTyp) {
            
            case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:
                // NOTE: not only null terminate, but trim any trailing '$'
                pAdditionalSamAccountName = &pCurrentAttr[i].AttrVal;
                for(j=0;j<pAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (pAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                    if(PWVAL[CCHVAL - 1] == L'$') {
                        PWVAL[CCHVAL - 1] = 0;
                        PAVAL.valLen -= sizeof(WCHAR);
                    }
                    else {
                        PWVAL = THReAllocEx(pTHS,
                                            PWVAL,
                                            PAVAL.valLen + sizeof(WCHAR));
                    }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
                }
                break;
            
            case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                pAdditionalDNSHostName = &pCurrentAttr[i].AttrVal;
                for(j=0;j<pAdditionalDNSHostName->valCount;j++) {
                    pAdditionalDNSHostName->pAVal[j].pVal =
                        THReAllocEx(pTHS,
                                    pAdditionalDNSHostName->pAVal[j].pVal,
                                    (pAdditionalDNSHostName->pAVal[j].valLen +
                                     sizeof(WCHAR)));
                }

                break;
            
            default:
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
        }

            
        // We've set up some raw data fields to work with.  The following
        // examples assume we're on the machine foo.baz.bar.com in the domain
        // baz.bar.com. There is a parent domain bar.com
        // domainDnsName = the dot delimited domain dns name.
        //                 baz.bar.com
        //
        // hostDnsName   = the dot delimited host dns name.
        //                 foo.baz.bar.com
        //
        // NetBIOSMachineName = the netBIOS name of this machine.
        //
        // NetBIOSDomainName = the netBIOS name of the domain.
        //
        // pszDomainGuid = stringized guid of the domain object, dc=bar,dc=com.
        //
        // pszServerGuid = stringized guid of the host object.
        //
        // pszGuidBasedDnsName = The guid-based name of this machine
        //
        
        // allocate cache for new SPNs
        cAllocated = 64;
        AttrVal = THAllocEx(pTHS,cAllocated*sizeof(ATTRVAL));
        AttrValBlock.pAVal = AttrVal;
        AttrIndex = 0;

#define INC_AttrIndex AttrIndex++;                                                      \
                  if (AttrIndex>=cAllocated) {                                          \
                      cAllocated+=16;                                                   \
                      AttrVal = THReAllocEx(pTHS, AttrVal, cAllocated*sizeof(ATTRVAL)); \
                  }                                                                     \

        
        // Make the first LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name/domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     LDAPServiceType,
                                     (0==i)?domainDnsName:domainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             LDAPServiceType,
                                             (0==i)?domainDnsName:domainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex
                }
            }
            // quit if domain DnsRootAlias is not present
            if (!domainDnsAlias[0]) {
                break;
            }
        }


        // Make the second LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 hostDnsName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalDNSHostName) {
             for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          LDAPServiceType,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                        __leave;
                  }
                  INC_AttrIndex
            }
        }


        // Make the third LDAP SPN
        // This is of the format
        //   LDAP/machinename
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 NetBIOSMachineName,
                                 NetBIOSMachineName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalSamAccountName) {
            for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          LDAPServiceType,
                                          (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex
            }
            
        }


        // Make the fourth LDAP SPN
        // This is of the format
        //   LDAP/host.dns.name/netbiosDoamainName
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 NetBIOSDomainName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex  

        if (pAdditionalDNSHostName) {
            for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                if(err = WrappedMakeSpnW(pTHS,
                                         LDAPServiceType,
                                         NetBIOSDomainName,
                                         (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                         0,
                                         NULL,
                                         &AttrVal[AttrIndex].valLen,
                                        (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex

            }
        }
        
        // Make the fifth LDAP SPN
        // This is of the format
        //   LDAP/guid-based-dns-name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 LDAPServiceType,
                                 pszGuidBasedDnsName,
                                 pszGuidBasedDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            __leave;
        }
        INC_AttrIndex


        // Make the DRS RPC SPN (for dc to dc replication)
        // This is of the format
        //   E3514235-4B06-11D1-AB04-00C04FC2DCD2/ntdsa-guid/
        //                      domain.dns.name@domain.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 DRS_IDL_UUID_W,
                                 domainDnsName,
                                 pszServerGuid,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (domainDnsAlias[0]) {
            if(err = WrappedMakeSpnW(pTHS,
                                     DRS_IDL_UUID_W,
                                     domainDnsAlias,
                                     pszServerGuid,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                     (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex
        }

        // Make the default host SPN
        // This is of the format
        //   HOST/host.dns.name/domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     HostSpnType,
                                     (0==i)?domainDnsName:domainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             HostSpnType,
                                             (0==i)?domainDnsName:domainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex

                }
            }
            if (!domainDnsAlias[0]) {
                break;
            }
        }


        // Make the second host SPN - hostDnsName-only HOST SPN
        // This is of the format
        //   HOST/host.dns.name
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 hostDnsName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalDNSHostName) {
             for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                          HostSpnType,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                          0,
                                          NULL,
                                          &AttrVal[AttrIndex].valLen,
                                          (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                        __leave;
                  }
                  INC_AttrIndex
            }
        }


        // Make the third host SPN - 
        // This is of the format
        //   HOST/machinename
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 NetBIOSMachineName,
                                 NetBIOSMachineName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                 (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex

        if (pAdditionalSamAccountName) {
            for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                 if(err = WrappedMakeSpnW(pTHS,
                                      HostSpnType,
                                      (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                      (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                      0,
                                      NULL,
                                      &AttrVal[AttrIndex].valLen,
                                      (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex
            }
            
        }


        // Make the fourth host SPN - 
        // This is of the format
        //   HOST/host.dns.name/netbiosDomainName
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 HostSpnType,
                                 NetBIOSDomainName,
                                 hostDnsName,
                                 0,
                                 NULL,
                                 &AttrVal[AttrIndex].valLen,
                                (WCHAR **)&AttrVal[AttrIndex].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        INC_AttrIndex  

        if (pAdditionalDNSHostName) {
            for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                if(err = WrappedMakeSpnW(pTHS,
                                         HostSpnType,
                                         NetBIOSDomainName,
                                         (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                         0,
                                         NULL,
                                         &AttrVal[AttrIndex].valLen,
                                        (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                INC_AttrIndex

            }
        }
        

        // Make the GC SPN. This is done on all systems, even non-GC.
        // See bug 339634. Jeffparh writes:
        // However, I would assert that always registering the GC SPN is equally secure.
        // I.e., there is no increased security to be had by registering the SPN only
        // if the DC is a GC.  The functional test of whether a machine is a GC is whether
        // it answers on the GC port.  There is nothing preventing an admin of any domain
        // in the forest making his favorite DC a GC (causing the registration of the GC
        // SPN as well as initialization of the GC port), ergo "do I trust this GC" is
        // equivalent to "do I trust this is a DC in my forest that is answering on the GC
        // port."

        // Providing hostDnsName for both ServiceName and InstanceName args
        // results in an SPN of HOST/dot.delimited.dns.host.name form.
        // This is of the format
        //   HOST/host.dns.name/root.domain.dns.name
        //
        for (i=0; i<=1; i++) {
            if(err = WrappedMakeSpnW(pTHS,
                                     GCSpnType,
                                     (0==i)?gAnchor.pwszRootDomainDnsName:rootDomainDnsAlias,
                                     hostDnsName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                    (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex       
            
            if (pAdditionalDNSHostName) {
                for (j=0; j<pAdditionalDNSHostName->valCount; j++) {
                    if(err = WrappedMakeSpnW(pTHS,
                                             GCSpnType,
                                             (0==i)?gAnchor.pwszRootDomainDnsName:rootDomainDnsAlias,
                                             (WCHAR*)pAdditionalDNSHostName->pAVal[j].pVal,
                                             0,
                                             NULL,
                                             &AttrVal[AttrIndex].valLen,
                                            (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                    INC_AttrIndex

                }
            }
            // quit if the DnsRootAlias attribute of root domain object is not present
            if (!rootDomainDnsAlias[0]) {
                break;
            }
        }

        // if this computer has Mapi service,
        // publish "exchangeAB/machinename"

        if (gbLoadMapi) {
            if(err = WrappedMakeSpnW(pTHS,
                                     ExchangeAbType,
                                     NetBIOSMachineName,
                                     NetBIOSMachineName,
                                     0,
                                     NULL,
                                     &AttrVal[AttrIndex].valLen,
                                     (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            INC_AttrIndex

            if (pAdditionalSamAccountName) {
                for (j=0; j<pAdditionalSamAccountName->valCount; j++) {
                     if(err = WrappedMakeSpnW(pTHS,
                                              ExchangeAbType,
                                              (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                              (WCHAR*)pAdditionalSamAccountName->pAVal[j].pVal,
                                              0,
                                              NULL,
                                              &AttrVal[AttrIndex].valLen,
                                              (WCHAR **)&AttrVal[AttrIndex].pVal)) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                     }
                     INC_AttrIndex
                }
            }
        }

#undef INC_AttrIndex

        AttrValBlock.valCount = AttrIndex;

        Assert(AttrIndex <= cAllocated);

        // Make the kerberos account SPNs
        KerbAttrValBlock.pAVal = KerbAttrVal;
        
        // Make the first kadmin SPN -
        // This is of the format
        //    kadmind/changepw
        //
        if(err = WrappedMakeSpnW(pTHS,
                                 KadminSPNType,
                                 KadminInstanceType,
                                 KadminInstanceType,
                                 0,
                                 NULL,
                                 &KerbAttrVal[0].valLen,
                                 (WCHAR **)&KerbAttrVal[0].pVal)) {
            dsid = DSID(FILENO, __LINE__);
            __leave;
        }
        KerbAttrValBlock.valCount = 1;
        
        // We also need the OS information to write on the Computer.
        if(GetVersionExW(&VersionInformationW)) {

            swprintf(versionNumber,L"%d.%d (%d)",
                     VersionInformationW.dwMajorVersion,
                     VersionInformationW.dwMinorVersion,
                     VersionInformationW.dwBuildNumber);
            cbVersionNumber = wcslen(versionNumber) * sizeof(wchar_t);
            fSetVersionStuff = TRUE;
        }

        // Now that we've created the data we need, find some objects and update
        // them
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            // Note: In general, we don't check the return code from the writes
            // we make here.  If some succeed but some fail for some reason, we
            // still want the ones that succeeded, and we will try everything
            // again in a few minutes anyway.
            // We DO check the various DBFind calls, since we can't update
            // anything if we cant find the objects.
            
            // Step 1 is to find the compupter object.
            if(DBFindComputerObj(pTHS->pDB,
                                 cchComputerName,
                                 wComputerName)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }

            // Get the DN of the object, we'll need to write it as an attribute
            // on another object in a minute.
            DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_OBJ_DIST_NAME,
                        0,
                        0,
                        &len,
                        (UCHAR **)&pDN);

            // Now, replace some values there.
            // First, replace the Service_Principal_Name
            fChanged = FALSE;
            WriteSPNsHelp(pTHS,
                          pAC_SPN,
                          &AttrValBlock,
                          &OurServiceClasses,
                          &fChanged);
            
            // Second, replace the OS name.  Reuse the AttrValBlock
            AttrValBlock.valCount = 1;
            AttrVal[0].pVal = (PUCHAR) pwszOsName;
            AttrVal[0].valLen = wcslen(pwszOsName) * sizeof(WCHAR);
            DBReplaceAtt_AC(pTHS->pDB, pAC_osName, &AttrValBlock,
                            (fChanged?NULL:&fChanged));
            
            if(fSetVersionStuff) {
                // Third, service pack info.  Reuse the AttrValBlock
                AttrVal[0].pVal = (PUCHAR)VersionInformationW.szCSDVersion;
                AttrVal[0].valLen = wcslen(VersionInformationW.szCSDVersion)
                    * sizeof(WCHAR);
                if(AttrVal[0].valLen) {
                    // Actually have a value to set.
                    DBReplaceAtt_AC(pTHS->pDB, pAC_osServicePack, &AttrValBlock,
                                    (fChanged?NULL:&fChanged));
                }
                else {
                    // No service pack info.  Make sure the value is empty in
                    // the DB.
                    // Assume that there is a value in the DB.
                    BOOL fHasValues = TRUE;
                    
                    if(!fChanged) {
                        // Nothing has changed yet.  We have to know if the
                        // DBRemAtt call is going to change things.
                        fHasValues =
                            fChanged =
                                DBHasValues_AC(pTHS->pDB, pAC_osServicePack);
                    }
                    if(fHasValues) {
                        // OK, force the attribute to be empty.  DBRemAtt_AC
                        // does nothing if no values are present.
                        DBRemAtt_AC(pTHS->pDB,pAC_osServicePack);
                    }
                }

                // Fourth, version number.  Reuse the AttrValBlock
                AttrVal[0].pVal = (PUCHAR)versionNumber;
                AttrVal[0].valLen = cbVersionNumber;
                DBReplaceAtt_AC(pTHS->pDB, pAC_osVersionNumber, &AttrValBlock,
                                (fChanged?NULL:&fChanged));
            }

            // Fifth, replace the DNSHostName.  Reuse the AttrValBlock
            AttrVal[0].pVal = (PUCHAR)hostDnsName;
            AttrVal[0].valLen = cchHostDnsName * sizeof(WCHAR);
            DBReplaceAtt_AC(pTHS->pDB, pAC_DNSHostName, &AttrValBlock,
                            (fChanged?NULL:&fChanged));

            if(fChanged ||!gfDsaWritable) {
                // OK, put these changes into the DB.  We check here for
                // gfDsaWritable so that if the DSA has become non-writable for
                // memory reasons, we will eventually try a write and perhaps
                // notice that the memory constraints have cleared up a little.
                // Thus, we can make ourselves writable again.  The attempted
                // write here is used as a trigger for that case.
                DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
            }
            else {
                // Nothing actually changed, don't write this to the DB
                DBCancelRec(pTHS->pDB);
            }

            // Next object to update is the server object.  We find it by doing
            // some surgery on a DN in the anchor.
            pTempDN = THAllocEx(pTHS,gAnchor.pDSADN->structLen);

            if(TrimDSNameBy(gAnchor.pDSADN, 1, pTempDN)) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }

            if(DBFindDSName(pTHS->pDB, pTempDN)) {
                // Huh?
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
                

            // Now, replace some values there.
            // First, replace the DNSHostName.  This is the same value we put on
            // the computer.
            fChanged = FALSE;
            DBReplaceAtt_AC(pTHS->pDB, pAC_DNSHostName, &AttrValBlock,
                            &fChanged);

            // Second, the server reference
            AttrVal[0].valLen = pDN->structLen;
            AttrVal[0].pVal = (PUCHAR)pDN;
            DBReplaceAtt_AC(pTHS->pDB, pAC_ServerReference, &AttrValBlock,
                            (fChanged?NULL:&fChanged));

            if(fChanged || !gfDsaWritable) {
                // OK, put these changes into the DB.  We check here for
                // gfDsaWritable so that if the DSA has become non-writable for
                // memory reasons, we will eventually try a write and perhaps
                // notice that the memory constraints have cleared up a little.
                // Thus, we can make ourselves writable again.  The attempted
                // write here is used as a trigger for that case.
                DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
            }
            else {
                // Nothing actually changed, don't write this to the DB
                DBCancelRec(pTHS->pDB);
            }

            // Final object to update is the kerberos account object.
            ulKerberosAccountDNT =  FindKerbAccountDNT(pTHS);
            if(ulKerberosAccountDNT != INVALIDDNT &&
               !DBTryToFindDNT(pTHS->pDB, gulKerberosAccountDNT)) {
                
                // Now, replace some values there.
                // First, replace the Service_Principal_Name
                fChanged = FALSE;
                WriteSPNsHelp(pTHS,
                              pAC_SPN,
                              &KerbAttrValBlock,
                              &KerberosServiceClasses,
                              &fChanged);
                
                if(fChanged ||!gfDsaWritable) {
                    // OK, put this change into the DB.  We check here for
                    // gfDsaWritable so that if the DSA has become non-writable
                    // for memory reasons, we will eventually try a write and
                    // perhaps notice that the memory constraints have cleared
                    // up a little. Thus, we can make ourselves writable again.
                    // The attempted write here is used as a trigger for that
                    //case. 
                    DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
                }
                else {
                    // Nothing actually changed, don't write this to the DB
                    DBCancelRec(pTHS->pDB);
                }
            }
            
            fCommit = TRUE;
        }
        __finally {
            DBClose(pTHS->pDB, fCommit);
        }

    }
    __finally {
        if (servicename) {
            DsFreeNameResultW(servicename);
        }
        if (pszServerGuid) {
            RpcStringFreeW( &pszServerGuid );
        }
        if (pszDomainGuid) {
            RpcStringFreeW( &pszDomainGuid );
        }
        if (pszGuidBasedDnsName) {
            THFreeEx(pTHS, pszGuidBasedDnsName );
        }
        if (pTempDN) {
            THFreeEx(pTHS,pTempDN);
        }

        // reschedule the next server info write
        *ppvNext = pv;
        switch(PtrToUlong(pv)) {
        case SERVINFO_RUN_ONCE:
            *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
            break;

        default:
            *pcSecsUntilNextIteration = SERVER_INFO_WRITE_PAUSE;
            break;
        }
    }

    if(!fCommit) {
        // We failed to write what we needed to.  Log an error.
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_SERVER_INFO_UPDATE_FAILED,
                 szInsertUL((SERVER_INFO_WRITE_PAUSE/60)),
                 szInsertHex(dsid),
                 szInsertUL(err));

    }

    return;
}



DWORD
FindKerbAccountDNT (
        THSTATE *pTHS)
// Find the DNT of the kerberos account for the default domain and put it in a
// global variable.  Obviously, don't look it up if we already have it.
// Return whatever the value of the global is after we're done.
{   FILTER                 Filter;
    FILTER                 FilterClause;
    SEARCHARG              SearchArg;
    SEARCHRES             *pSearchRes;
    ENTINFSEL              eiSel;

    if(gulKerberosAccountDNT != INVALIDDNT) {
        return gulKerberosAccountDNT;
    }
    
    // We haven't yet found the kerberos account.  Look for it.
    
    // Issue a search from the default domain.
    // Filter is
    //   (& (samaccountname=krbtgt))
    // Size limit 1.
    // Atts selected = NONE

    // build search argument
    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = gAnchor.pDomainDN;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pSelection = &eiSel;
    InitCommarg(&(SearchArg.CommArg));
    SearchArg.CommArg.ulSizeLimit = 1;
    SearchArg.CommArg.Svccntl.localScope = TRUE;
    
    // build filter
    memset (&Filter, 0, sizeof (Filter));
    Filter.pNextFilter = NULL;
    Filter.choice = FILTER_CHOICE_AND;
    Filter.FilterTypes.And.count = 1;
    Filter.FilterTypes.And.pFirstFilter = &FilterClause;
#define KERBEROS_ACCOUNTNAME L"krbtgt"
    memset (&FilterClause, 0, sizeof (Filter));
    FilterClause.pNextFilter = NULL;
    FilterClause.choice = FILTER_CHOICE_ITEM;
    FilterClause.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterClause.FilterTypes.Item.FilTypes.ava.type =
        ATT_SAM_ACCOUNT_NAME;
    FilterClause.FilterTypes.Item.FilTypes.ava.Value.valLen =
        sizeof(KERBEROS_ACCOUNTNAME) - sizeof(WCHAR);
    FilterClause.FilterTypes.Item.FilTypes.ava.Value.pVal =
        (PUCHAR) KERBEROS_ACCOUNTNAME;
    
    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    eiSel.AttrTypBlock.attrCount = 0;
    eiSel.AttrTypBlock.pAttr = NULL;
    
    
    // Search for the kerberos account;
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes,0);
    
    
    if(pSearchRes->count) {
        DBFindDSName(pTHS->pDB,pSearchRes->FirstEntInf.Entinf.pName);
        gulKerberosAccountDNT = pTHS->pDB->DNT;
        
    }
    
    THFreeEx(pTHS, pSearchRes);
        
    return gulKerberosAccountDNT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\scchk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scchk.c
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------
//
// Abstract:
//
//   Contains the routines for validating Schema Updates
//
//
// Author:
//
//    Rajivendra Nath (RajNath) 4/7/1997
//
// Revision History:
//
//-----------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <prefix.h>         
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>           // HandleMostExceptions

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>

#include <filtypes.h>           // For FILTER_CHOICE_??? and
                                // FI_CHOICE_???
#include <dsconfig.h>
#include "permit.h"

#include <dsutil.h>

#include "debug.h"              // standard debugging header
#define DEBSUB "SCCHK:"                // define the subsystem for debugging

// DRA headers
#include "drautil.h"
#include "drameta.h"

#include <samsrvp.h>

#include "drserr.h"


#include <fileno.h>
#define  FILENO FILENO_SCCHK

#include <schash.c>  // for hash function definitions


// Known syntax-om_syntax pairs from schema.ini

Syntax_Pair KnownSyntaxPair[] =
{
 {SYNTAX_DISTNAME_TYPE,               OM_S_OBJECT},
 {SYNTAX_OBJECT_ID_TYPE,              OM_S_OBJECT_IDENTIFIER_STRING},
 {SYNTAX_CASE_STRING_TYPE,            OM_S_GENERAL_STRING},
 {SYNTAX_NOCASE_STRING_TYPE,          OM_S_TELETEX_STRING},
 {SYNTAX_PRINT_CASE_STRING_TYPE,      OM_S_IA5_STRING},
 {SYNTAX_PRINT_CASE_STRING_TYPE,      OM_S_PRINTABLE_STRING},
 {SYNTAX_NUMERIC_STRING_TYPE,         OM_S_NUMERIC_STRING},
 {SYNTAX_DISTNAME_BINARY_TYPE,        OM_S_OBJECT},
 {SYNTAX_BOOLEAN_TYPE,                OM_S_BOOLEAN},
 {SYNTAX_INTEGER_TYPE,                OM_S_INTEGER},
 {SYNTAX_INTEGER_TYPE,                OM_S_ENUMERATION},
 {SYNTAX_OCTET_STRING_TYPE,           OM_S_OBJECT},
 {SYNTAX_OCTET_STRING_TYPE,           OM_S_OCTET_STRING},
 {SYNTAX_TIME_TYPE,                   OM_S_UTC_TIME_STRING},
 {SYNTAX_TIME_TYPE,                   OM_S_GENERALISED_TIME_STRING},
 {SYNTAX_UNICODE_TYPE,                OM_S_UNICODE_STRING},
 {SYNTAX_ADDRESS_TYPE,                OM_S_OBJECT},
 {SYNTAX_DISTNAME_STRING_TYPE,        OM_S_OBJECT},
 {SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, OM_S_OBJECT_SECURITY_DESCRIPTOR},
 {SYNTAX_I8_TYPE,                     OM_S_I8},
 {SYNTAX_SID_TYPE,                    OM_S_OCTET_STRING},
};

ULONG SyntaxPairTableLength = sizeof(KnownSyntaxPair)/sizeof(KnownSyntaxPair[0]);

// Helper function from mdupdate.c
extern  BOOL IsMember(ATTRTYP aType, 
                      int arrayCount, 
                      ATTRTYP *pAttArray);

// class closing function from scache.c
extern  int scCloseClass(THSTATE *pTHS,
                         CLASSCACHE *pCC);


// Logging functions in case a schema conflict is detected between
// an exisiting object and a replicated-in schema object

#define CURRENT_VERSION 1

// defines to distinguish if a classcache or an attcache is passed to common
// conflict handling routines

#define PTR_TYPE_ATTCACHE   0
#define PTR_TYPE_CLASSCACHE 1

VOID
LogConflict(
    THSTATE *pTHS,
    VOID *pConflictingCache,
    char *pConflictingWith,
    MessageId midEvent,
    ULONG version,
    DWORD WinErr
);

int
ValidateSchemaAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac        
);

int
AutoLinkId
(
    THSTATE *pTHS,
    ATTCACHE* ac,
    ULONG acDnt
);


int
ValidateSchemaCls
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

int
DRAValidateSchemaAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac        
);


int
DRAValidateSchemaCls
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

int
ValidAttAddOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


int
ValidAttModOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


int
ValidAttDelOp
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
InvalidClsOrAttLdapDisplayName
(
    UCHAR *name,
    ULONG nameLen
);

BOOL
DupAttRdn
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
DupAttOid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
DupAttMapiid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
DupAttLinkid
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
InvalidBackLinkAtt
(
    THSTATE *pTHS,
    ATTCACHE* ac
);   

BOOL
InvalidLinkAttSyntax
(
    THSTATE *pTHS,
    ATTCACHE* ac
);

BOOL
DupAttLdapDisplayName
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
DupAttSchemaGuidId
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);


BOOL
SemanticAttTest
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
SyntaxMatchTest
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
OmObjClassTest
(
    ATTCACHE* ac 
);

BOOL
SearchFlagTest
(
    ATTCACHE* ac
);

BOOL
GCReplicationTest
(
    ATTCACHE* ac
);

BOOL
AttInMustHave
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);

BOOL
AttInRdnAttId(
    IN THSTATE  *pTHS,
    IN ATTCACHE *pAC
);

BOOL
AttInMayHave
(
    THSTATE *pTHS,
    ATTCACHE* ac 
);



int
ValidClsAddOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


int
ValidClsModOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


int
ValidClsDelOp
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
DupClsRdn
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
DupClsOid
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
DupClsLdapDisplayName
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
DupClsSchemaGuidId
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsMayHaveExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsMustHaveExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsAuxClassExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsPossSupExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsSubClassExistenceTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
ClsMayMustPossSafeModifyTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc
);

BOOL
RdnAttIdSyntaxTest
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);

BOOL
IsRdnSyntaxTest(
    THSTATE *pTHS,
    ATTCACHE* ac
);

BOOL
ClsInPossSuperior
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsInSubClassOf
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);


BOOL
ClsInAuxClass
(
    THSTATE *pTHS,
    CLASSCACHE* cc 
);



//-----------------------------------------------------------------------
//
// Function Name:            ValidSchemaUpdate
//
// Routine Description:
//
//    Checks to see if the Schema Update is Valid 
//
// Author: RajNath  
// Date  : [4/7/1997]
// 
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidSchemaUpdate()
{
    THSTATE *pTHS=pTHStls;
    int err;
    SCHEMAPTR* oldptr=pTHS->CurrSchemaPtr;

    if ( DsaIsInstalling() ) {
      // installing
      return (0);
    }

#ifdef INCLUDE_UNIT_TESTS
{
    extern DWORD dwUnitTestSchema;
    if (dwUnitTestSchema == 1) {
        SCFreeClasscache((CLASSCACHE **)&pTHS->pClassPtr);
        return 0;
    }
}
#endif INCLUDE_UNIT_TESTS
    
    _try
    {
    
        switch (pTHS->SchemaUpdate)
        {
            case eSchemaClsAdd:
            case eSchemaClsMod:
            case eSchemaClsDel:
            {
                CLASSCACHE* cc = NULL;

                err = SCBuildCCEntry ( NULL,&cc); //creates a new ClassCache
                if (err)
                {
                    DPRINT1(0,"NTDS ValidSchemaUpdate: Failed. Error%d\n",err);
                    // THSTATE error code is already set in SCBuildCCEntry
                    __leave;
                }

                // Since there is no error, must have a classcache.
                // (Even in the delete case, since it is positioned on 
                // the deleted object)
                Assert(cc);

                if (pTHS->fDRA) {
                    // Do a limited set of checks against the existing schema cache
                    // to see that this will not cause any inconsistencies
                    err = DRAValidateSchemaCls(pTHS, cc);
                    if (err) {
                       DPRINT1(0,"NTDS DRAValidateSchemaClass: Failed. Error %d\n",err);

                       // Already logged
                       // Set special error code and thread state flag
                       pTHS->fSchemaConflict = TRUE;
                       err = ERROR_DS_DRA_SCHEMA_CONFLICT;
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     err, err);
                    }
                    else {
                       // Even if there is no error, fail if the thread state
                       // indicates a conflict happened for this packet 
                       // earlier, so that we don't commit change
                       if (pTHS->fSchemaConflict) {
                           err = ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT;
                           SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                         err, err);
                        }
                    }
 
                    SCFreeClasscache(&cc);
                    __leave;
                }
                // Otherwise (originating write), build validation cache and test
                err = RecalcSchema(pTHS);
                if (err)
                {
                    SCFreeClasscache(&cc);
                    DPRINT1(0,"RecalcSchema() Error %08x\n", err);
                    // Use the pTHS->pErrInfo returned by RecalcSchema 
                    // because it may be more informative than "unwilling
                    // to perform" (couldn't be worse!). Unfortunately, the
                    // functions called by RecalSchema don't always return
                    // pErrInfo and so we are stuck with "unwilling to
                    // perform" in some cases.
                    if (err != (int)pTHS->errCode || !pTHS->pErrInfo) {
                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_RECALCSCHEMA_FAILED,err); 
                    }
                    __leave;
                }

                err = ValidateSchemaCls(pTHS, cc);
                if (err)
                {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_SCHEMA_VALIDATION_FAILED, 
                            szInsertSz(cc->name),szInsertInt(err), 0);
                    
                    SCFreeClasscache(&cc);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    DPRINT1(0,"NTDS ValidateSchemaClass: Failed. Error %d\n",err);

                    // err is a dir-error

                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  err, err);
                    __leave;
                }
    
                SCFreeClasscache(&cc);
                SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
    
            }
            break;

    
            case eSchemaAttAdd:
            case eSchemaAttMod:
            case eSchemaAttDel:
            {
    
                ATTCACHE* ac = NULL;
                ULONG acDnt = pTHS->pDB->DNT; // for AutoLinkId


                err = SCBuildACEntry ( NULL,&ac); //creates a new AttrCache
                if (err)
                {
                    DPRINT1(0, "NTDS ValidSchemaUpdate: Failed. Error %d\n",err);
                    __leave;
                }
                // Since there is no error, must have an attcache
                // (Even in the delete case, since it is positioned on 
                // the deleted object)
                Assert(ac);
    
                if (pTHS->fDRA) {
                    // Do a limited set of checks against the existing schema cache
                    // to see that this will not cause any inconsistencies
                    err = DRAValidateSchemaAtt(pTHS, ac);
                    if (err) {
                       DPRINT1(0,"NTDS DRAValidateSchemaAtt: Failed. Error %d\n",err);

                       // Already logged
                       // Set special error code and thread state flag
                       pTHS->fSchemaConflict = TRUE;
                       err = ERROR_DS_DRA_SCHEMA_CONFLICT;
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     err, err);
                    }
                    else {
                       // Even if there is no error, fail if the thread state
                       // indicates a conflict happened for this packet
                       // earlier, so that we don't commit change
                       if (pTHS->fSchemaConflict) {
                           err = ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT;
                           SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                         err, err);
                        }
                    }
                    SCFreeAttcache(&ac);
                    __leave;
                }
                // Otherwise (originating write), build validation cache and test
                err = RecalcSchema(pTHS);
                if (err)
                {
                    SCFreeAttcache(&ac);
                    DPRINT1(0,"RecalcSchema() Error %08x\n", err);
                    // Use the pTHS->pErrInfo returned by RecalcSchema 
                    // because it may be more informative than "unwilling
                    // to perform" (couldn't be worse!). Unfortunately, the
                    // functions called by RecalSchema don't always return
                    // pErrInfo and so we are stuck with "unwilling to
                    // perform" in some cases.
                    if (err != (int)pTHS->errCode || !pTHS->pErrInfo) {
                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_RECALCSCHEMA_FAILED, err);
                    }
                    __leave;
                }

                // If needed, automatically generate a linkid
                err = AutoLinkId(pTHS, ac, acDnt);
                if (err) {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_AUTO_LINK_ID_FAILED,
                            szInsertSz(ac->name),szInsertInt(err), 0);
                    DPRINT2(0,"NTDS AutoLinkId(%s): Error %08x\n", ac->name, err);
                    SCFreeAttcache(&ac);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    // AutoLinkId called SetSvcErrorEx
                    __leave;
                }
                err = ValidateSchemaAtt(pTHS, ac);
                if (err)
                {
                    LogEvent(DS_EVENT_CAT_SCHEMA,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_SCHEMA_VALIDATION_FAILED,
                            szInsertSz(ac->name),szInsertInt(err), 0);

                    SCFreeAttcache(&ac);
                    SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
                    DPRINT1(0,"NTDS ValidateSchemaAtt: Failed. Error %d\n",err);

                    // err is a dir-error
                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  err, err); 
                    __leave;
                }
    
               
                SCFreeAttcache(&ac);
                SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);
            }
            break;
    
        }
    }__finally
    {
        pTHS->CurrSchemaPtr=oldptr;

        // free pTHS->pClassPtr if there. This is malloc'ed memory
        SCFreeClasscache((CLASSCACHE **)&pTHS->pClassPtr);
    }

    return err;

} // End ValidSchemaUpdate

int
ValidateSchemaAtt(
    THSTATE *pTHS,
    ATTCACHE* ac    
    )
/*++

Routine Description:

    Verify that the altered schema attribute, ac, is valid and consistent
    with respect to the current schema in the database.
    
Arguments:

    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for ac.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database
           or by reading the contents prior to an uncommitted delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    int err=0;
    ATTCACHE* pac;

    //
    // Get the attribute in the private Schema Cache... (from RecalcSchema)
    //
    pac = SCGetAttById(pTHS, ac->id);

    switch (pTHS->SchemaUpdate)
    {
        case eSchemaAttAdd:
        {
            if (pac) {
                return ValidAttAddOp(pTHS, pac);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaAttMod:
        {
            if (pac) {
                return ValidAttModOp(pTHS, pac);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaAttDel:
        {
            // pac will be NULL because we just deleted the attrib.
            return ValidAttDelOp(pTHS, ac);
        }
        break;

    }


    return err;
} // End ValidateSchemaAtt

int
AutoLinkId(
    THSTATE     *pTHS,
    ATTCACHE    *ac,
    ULONG       acDnt
    )
/*++
Routine Description:
    Caveats: Runs in the current transaction.
             Resets currency.

    Automatically generate a linkid when the user specifies a special,
    reserved linkid value.  The only interoperability issue with existing
    schemas is that a user cannot define a backlink for an existing
    forward link whose id is RESERVED_AUTO_LINK_ID. Considered not a problem
    because 1) microsoft has not allocated linkid -2 to anyone and
    2) practically and by convention, forward links and back links
    are created at the same time. If a user did generate this unsupported
    config, then the user must create a new link/backlink pair and fix
    up the affected objects.

    The ldap head cooperates in this venture by translating the ldapDisplayName
    or OID for a LinkId attribute into the corresponding schema cache entry
    and:
         1) If the schema cache entry is for ATT_LINK_ID, then the caller's
         linkid is set to RESERVED_AUTO_LINK_ID. Later, underlying code
         automatically generates a linkid in the range
         MIN_RESERVED_AUTO_LINK_ID to MAX_RESERVED_AUTO_LINK_ID.

         2) If the schema cache entry is for a for an existing forward link,
         then the caller's linkid is set to the corresponding backlink value.

         3) Otherwise, the caller's linkid is set to RESERVED_AUTO_NO_LINK_ID
         and later, underlying code generates a ERROR_DS_BACKLINK_WITHOUT_LINK
         error.

    An error ERROR_DS_RESERVED_LINK_ID is returned if the user specifies
    linkid in the reserved range MIN... to MAX... The range reserves 1G-2
    linkids. Should be enough. At whistler, less than 200 linkids are in use.
    Existing schemas, or schemas modified on W2K DCs, may use linkids in
    this range without affecting the functionality except as noted above.
    
Arguments:
    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for ac.

    ac   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database
           or by reading the contents prior to an uncommitted delete.

    acDnt - DNT from pTHS->pDB that was used to create ac

Return Values:
    0 on success.
    !0 otherwise.
--*/
{
    DWORD               dwErr, i;
    ATTCACHE            *pAC, *pACSearch;
    ULONG               ulLinkId, ulRange, ulBase;
    extern SCHEMAPTR    *CurrSchemaPtr;
    LONG                ATTCOUNT = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ATTCOUNT;
    HASHCACHE           *ahcLink = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcLink;

    // Replication should not be using this code path! Automatically
    // generating link ids is designed for originating adds. If this
    // has changed, then the design of AutoLinkIds should be reviewed.
    //
    // This function is expected to be called from ValidSchemaUpdate().
    // When replicating in schema changes, ValidSchemaUpdate() should be
    // using the code path that calls DRAValidateSchemaAtt() and not 
    // the code path that calls ValidateSchemaAtt().
    Assert(!pTHS->fDRA);

    // must be using a private schema cache (RecalcSchema)
    Assert(pTHS->CurrSchemaPtr != CurrSchemaPtr)

    // not a link or else not a forward link
    if (!FIsLink(ac->ulLinkID)) {
        return 0;
    }

    // Don't assign a linkid when deleting or modifying because we don't
    // want to alter an existing linkid even if the linkid is the special
    // RESERVED_AUTO_LINK_ID. It may exist in poorly behaved enterprises
    // because the value, RESERVED_AUTO_LINK_ID, was not reserved until
    // whistler.
    if (   pTHS->SchemaUpdate == eSchemaAttDel
        || pTHS->SchemaUpdate == eSchemaAttMod)  {
        return 0;
    }

    // Check if the caller is trying to add a linkid that is within the
    // reserved range of automatically generated linkids (excluding
    // the special values RESERVED_AUTO_LINK_ID and RESERVED_AUTO_NO_LINK_ID
    // which are handled later).
    if (ac->ulLinkID >= MIN_RESERVED_AUTO_LINK_ID 
        && ac->ulLinkID <= MAX_RESERVED_AUTO_LINK_ID) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             ERROR_DS_RESERVED_LINK_ID, ERROR_DS_RESERVED_LINK_ID); 
    }
    
    // Don't assign a linkid because the linkid is not the special
    // "assign a linkid" value (RESERVED_AUTO_LINK_ID).
    if (ac->ulLinkID != RESERVED_AUTO_LINK_ID) {
        return 0;
    }

    // Locate the next available linkid in the reserved range.
    // Begin searching at a random linkid in the range to avoid scaling
    // problems when sequentially searching the range. Starting at the
    // currently allocated maximum linkid is not an option because
    // poorly behaved enterprises may have already created linkid
    // MAX_RESERVED_AUTO_LINK_ID, creating the illusion that all linkids
    // have been used.
    srand(GetTickCount());
    ulRange = MakeLinkBase(MAX_RESERVED_AUTO_LINK_ID - MIN_RESERVED_AUTO_LINK_ID);
    ulBase = MakeLinkBase((((rand() << 16) ^ rand()) % ulRange));
    for (i = 0; i < ulRange; ++i, ulBase = ++ulBase % ulRange) {
        pACSearch = SCGetAttByLinkId(pTHS, 
                                     MIN_RESERVED_AUTO_LINK_ID + MakeLinkId(ulBase));
        if (!pACSearch) {
            break;
        }
    }

    // no available linkids (all 1 billion - 3 are taken!)
    if (pACSearch) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, 
                             ERROR_DS_LINK_ID_NOT_AVAILABLE, 
                             ERROR_DS_LINK_ID_NOT_AVAILABLE);
    }
    // Found an unused linkid. Adjust the cache's linkid hash.
    // Careful, there may be duplicate entries for RESERVED_AUTO_LINK_ID.
    ulLinkId = MIN_RESERVED_AUTO_LINK_ID + MakeLinkId(ulBase);
    pAC = SCGetAttById(pTHS, ac->id);
    Assert(pAC);
    for (i = SChash(RESERVED_AUTO_LINK_ID, ATTCOUNT);
         (ahcLink[i].pVal 
          && (ahcLink[i].pVal != FREE_ENTRY)
          && (ahcLink[i].hKey != RESERVED_AUTO_LINK_ID) 
          && (ahcLink[i].pVal != pAC));
         i = (i + 1) % ATTCOUNT);
    Assert(ahcLink[i].pVal == pAC);
    ahcLink[i].pVal = FREE_ENTRY;
    ahcLink[i].hKey = 0;
    i = SChash(ulLinkId, ATTCOUNT);
    Assert(!ahcLink[i].hKey);
    ahcLink[i].pVal = pAC;
    ahcLink[i].hKey = ulLinkId;

    // Update the private cache, the free-floating entry, and the database.
    pAC->ulLinkID = ulLinkId;
    ac->ulLinkID = ulLinkId;
    DBFindDNT(pTHS->pDB, acDnt);
    if (DBRemAtt(pTHS->pDB, ATT_LINK_ID) == DB_ERR_SYSERROR) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY,
                             ERROR_DS_DATABASE_ERROR, DB_ERR_SYSERROR);
    }
    if (   (dwErr = DBAddAtt(pTHS->pDB, ATT_LINK_ID, SYNTAX_INTEGER_TYPE))
        || (dwErr = DBAddAttVal(pTHS->pDB, ATT_LINK_ID,
                                sizeof(SYNTAX_INTEGER), &ulLinkId))) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR, dwErr);
    }
    DBUpdateRec(pTHS->pDB);

    return 0;
} // AutoLinkId

int
DRAValidateSchemaAtt(
    THSTATE *pTHS,
    ATTCACHE* ac    
    )
/*++

Routine Description:

    Verify that the altered, newly replicated-in schema attribute, ac, is
    valid and consistent with respect to the current schema cache. Only
    called if pTHS->fDRA is true.
    
Arguments:

    pTHS - thread state that addresses the current schema cache.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the attribute from the database.
           NULL if schema update is a delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    int err=0;
    ATTCACHE *pTempAC;
    CLASSCACHE *pTempCC;


    // No true deletes are allowed, but just in case some internal dumbo did 
    // this on replicated enterprise, check for it
    if ( !ac ) {
       // possible only for true deletes
       Assert(pTHS->SchemaUpdate==eSchemaAttDel);
       return 0;
    }
    
    // For any change, add/modify/defunct, following test should pass
    if (pTempCC = SCGetClassById(pTHS, ac->id)) {
        // exists a class with same IntId
        LogConflict(pTHS, pTempCC, ac->name, DIRLOG_SCHEMA_CLASS_CONFLICT,
                    CURRENT_VERSION, ERROR_DS_DUP_OID);
        return ERROR_DS_DUP_OID;
    }

    // Now switch on change type
    switch (pTHS->SchemaUpdate) {
        case eSchemaAttAdd:

            if (pTempAC = SCGetAttById(pTHS, ac->id)) {
                // exists an att with same internal id (msDS-IntId)
                err = ERROR_DS_DUP_OID;
                break;
            }
            if (pTempAC = SCGetAttByLinkId(pTHS, ac->ulLinkID)) {
                // exists an att with same linkID
                err = ERROR_DS_DUP_LINK_ID;
                break;
            }
            // Duplicate LDNs and MapiIDs are handled by defuncting
            // the colliding attributes during the schema cache
            // load. A user can choose a winner by setting the
            // loser's isDefunct to TRUE.
            break;
       case eSchemaAttMod:
            // Duplicate LDNs and MapiIDs are handled by defuncting
            // the colliding attributes during the schema cache
            // load. A user can choose a winner by setting the
            // loser's isDefunct to TRUE.
            break;
       case eSchemaAttDel:
            // This is currently making defunct. Nothing to check here
            break;
    } /* switch */                

    if (err) {
        // some error, doesn't matter what, there is a conflict
        Assert(pTempAC);
        LogConflict(pTHS, pTempAC, ac->name, DIRLOG_SCHEMA_ATT_CONFLICT,
                    CURRENT_VERSION, err);
        return err;
    }

    return 0;
} // End DRAValidateSchemaAtt

int
ValidateSchemaCls(
    THSTATE *pTHS,
    CLASSCACHE* cc
    )
/*++

Routine Description:

    Verify that the altered schema class, cc, is valid and consistent
    with respect to the current schema in the database.
    
Arguments:

    pTHS - thread state that addresses a private schema cache built
           by RecalcSchema. The private schema cache includes the
           uncommitted changes (add/mod/del) for cc.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the class from the database
           or by reading the contents prior to an uncommitted delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    DECLARESCHEMAPTR
    int err=0;
    DWORD i;
    CLASSCACHE* pcc;

    //
    // Locate the class in the private Schema Cache... (from RecalcSchema)
    //
    // Be careful because the ClassId is no longer unique! Locate the
    // class by objectGuid.
    for (i=SChash(cc->ClassId,CLSCOUNT); pcc = ahcClassAll[i].pVal; i=(i+1)%CLSCOUNT) {
        if (pcc == FREE_ENTRY) {
            continue;
        }
        if (!memcmp(&pcc->objectGuid, &cc->objectGuid, sizeof(cc->objectGuid))) {
            break;
        }
    }

    // Note that pcc is not closed, since we don't close the recalc cache
    // We will close pcc only if we need to use the inherited atts, currently
    // only in one place (ClsMayMustPossSafeModifyTest) during class modify

    switch (pTHS->SchemaUpdate)
    {
        case eSchemaClsAdd:
        {
            if (pcc) {
                return ValidClsAddOp(pTHS, pcc);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaClsMod:
        {
            if (pcc) {
                return ValidClsModOp(pTHS, pcc);
            } else {
                err = ERROR_DS_OBJ_NOT_FOUND;
            }
        }
        break;

        case eSchemaClsDel:
        {
            // pcc will be null since we have deleted it...
            return ValidClsDelOp(pTHS, cc);
        }
        break;

    }


    return err;
} // End ValidateSchemaCls

int
DRAValidateSchemaCls(
    THSTATE *pTHS,
    CLASSCACHE* cc
    )
/*++

Routine Description:

    Verify that the altered, newly replicated-in schema class, cc, is valid
    and consistent with respect to the current schema cache. Only called
    if pTHS->fDRA is true.
    
Arguments:

    pTHS - thread state that addresses the current schema cache.

    cc   - is a free-floating cache entry that was generated by reading
           the uncommitted add/mod for the class from the database.
           NULL if schema update is a delete.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    ATTCACHE *pTempAC;

    // No true deletes are allowed, but just in case some internal dumbo did
    // this on replicated enterprise, check for it
    if ( !cc ) {
       // possible only for true deletes
       Assert(pTHS->SchemaUpdate==eSchemaClsDel);
       return 0;
    }

    // For any change, add/modify/defunct, following test should pass

    if (pTempAC = SCGetAttById(pTHS, cc->ClassId)) {
        // exists an att with same internal id (msDS-IntId) as the governsId
        LogConflict(pTHS, pTempAC, cc->name, DIRLOG_SCHEMA_ATT_CONFLICT,
                    CURRENT_VERSION, ERROR_DS_DUP_OID);
        return ERROR_DS_DUP_OID;
    }

    // Duplicate governsIds and ldapDisplayNames are handled by
    // defuncting the colliding classes and attributes during the
    // schema cache load. A user can choose a winner by setting
    // the loser's isDefunct to TRUE. Nothing else to check.

    return 0;
}

//-----------------------------------------------------------------------
//
// Function Name:            ValidAttAddOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttAddOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    if (DupAttRdn(pTHS, ac))
    {
        return ERROR_DS_DUP_RDN;
    } 
    
    if (DupAttOid(pTHS, ac))
    {
        return ERROR_DS_DUP_OID;
    } 
    
    if (DupAttMapiid(pTHS, ac))
    {
        return ERROR_DS_DUP_MAPI_ID;
    } 

    if (DupAttLinkid(pTHS, ac))
    {
        return DS_ERR_DUP_LINK_ID;
    } 

    if (InvalidBackLinkAtt(pTHS, ac))
    {
        return ERROR_DS_BACKLINK_WITHOUT_LINK;
    } 

    if (InvalidLinkAttSyntax(pTHS, ac))
    {
        return ERROR_DS_WRONG_LINKED_ATT_SYNTAX;
    } 

    if (DupAttSchemaGuidId(pTHS, ac))
    {
        return ERROR_DS_DUP_SCHEMA_ID_GUID;
    } 

    if (InvalidClsOrAttLdapDisplayName(ac->name, ac->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    if (DupAttLdapDisplayName(pTHS, ac))
    {
        return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
    } 

    if (SemanticAttTest(pTHS, ac))
    {
        return ERROR_DS_SEMANTIC_ATT_TEST;
    } 

    if (SyntaxMatchTest(pTHS, ac))
    {
        return ERROR_DS_SYNTAX_MISMATCH;
    }

    if (OmObjClassTest(ac))
    {
        return ERROR_DS_WRONG_OM_OBJ_CLASS;
    }

    if (SearchFlagTest(ac))
    {
        return ERROR_DS_INVALID_SEARCH_FLAG;
    }

    if (IsRdnSyntaxTest(pTHS, ac))
    {
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }

    return 0;

} // End ValidAttAddOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidAttModOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttModOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // No mods of constructed atts are allowed unless the special
    // registry flag is set
    if (ac->bIsConstructed && !gAnchor.fSchemaUpgradeInProgress) {
        return ERROR_DS_CONSTRUCTED_ATT_MOD;
    }


    if (InvalidClsOrAttLdapDisplayName(ac->name, ac->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }
    
    // Check modifications to defunct atts at resurrection,
    // not during modification. Use old protocol if pre-schema-reuse
    // forest
    if (!ac->bDefunct || !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        if (DupAttLdapDisplayName(pTHS, ac))
        {
            return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
        } 
    }

    if (SemanticAttTest(pTHS, ac))
    {
        return ERROR_DS_SEMANTIC_ATT_TEST;
    } 

    if (SearchFlagTest(ac))
    {
        return ERROR_DS_INVALID_SEARCH_FLAG;
    }

    if (GCReplicationTest(ac))
    {
        return ERROR_DS_CANT_ADD_TO_GC;
    }

    if (IsRdnSyntaxTest(pTHS, ac))
    {
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }


    return 0;
}


//-----------------------------------------------------------------------
//
// Function Name:            ValidAttDelOp
//
// Routine Description:
//
//    Validates Whether the Operation on Att Schema Object is Valid or Not
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac               
//                 
//
// Return Value:
//
//    int              0 On Succeess
//
//-----------------------------------------------------------------------
int
ValidAttDelOp(
    THSTATE *pTHS,
    ATTCACHE* ac 
)

{
    if (AttInMustHave(pTHS, ac))
    {
        return ERROR_DS_EXISTS_IN_MUST_HAVE;
    } 


    if (AttInMayHave(pTHS, ac))
    {
        return ERROR_DS_EXISTS_IN_MAY_HAVE;
    } 

    // Disallow defuncting attributes used as rdnattids in live classes
    // Note this case must be handled in schema reload because the
    // attribute may have been defuncted prior to whistler beta3.
    // But thats okay because attributes used as rdnattid are
    // resurrected during the reload so marking them defunct just
    // means they may be purged later. They can't be reused.
    if (ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)
        && AttInRdnAttId(pTHS, ac)) {
        return ERROR_DS_EXISTS_IN_RDNATTID;
    }

    return 0;

}
//-----------------------------------------------------------------------
//
// Function Name:            ValidClsAddOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsAddOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{

    if (DupClsRdn(pTHS, cc))
    {
        return ERROR_DS_DUP_RDN;
    } 
    
    if (DupClsOid(pTHS, cc))
    {
        return ERROR_DS_DUP_OID;
    } 
    
    if (DupClsSchemaGuidId(pTHS, cc))
    {
        return ERROR_DS_DUP_SCHEMA_ID_GUID;
    } 

    if (InvalidClsOrAttLdapDisplayName(cc->name, cc->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    if (DupClsLdapDisplayName(pTHS, cc))
    {
        return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
    } 

    if (ClsMayHaveExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_MAY_HAVE; 
    }
    
    if (ClsMustHaveExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_MUST_HAVE; 
    }
    
    if (ClsAuxClassExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_AUX_CLS_TEST_FAIL; 
    }
    
    if (ClsPossSupExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_NONEXISTENT_POSS_SUP; 
    }
    
    if (ClsSubClassExistenceTest(pTHS, cc))
    {    
        return ERROR_DS_SUB_CLS_TEST_FAIL; 
    }

    if (RdnAttIdSyntaxTest(pTHS, cc))
    {    
        return ERROR_DS_BAD_RDN_ATT_ID_SYNTAX; 
    }

    return 0;
} // End ValidClsAddOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidClsModOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsModOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    if (InvalidClsOrAttLdapDisplayName(cc->name, cc->nameLen))
    {
        return ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
    }

    // Check modifications to defunct classes at resurrection,
    // not during modification on schema-reuse forests.
    if (!cc->bDefunct || !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        if (DupClsLdapDisplayName(pTHS, cc))
        {
            return ERROR_DS_DUP_LDAP_DISPLAY_NAME;
        } 

        if (ClsMayHaveExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_MAY_HAVE; 
        }
        
        if (ClsMustHaveExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_MUST_HAVE; 
        }
        
        if (ClsAuxClassExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_AUX_CLS_TEST_FAIL; 
        }
        
        if (ClsPossSupExistenceTest(pTHS, cc))
        {    
            return ERROR_DS_NONEXISTENT_POSS_SUP;
        }

        if (ClsMayMustPossSafeModifyTest(pTHS, cc))
        {
            return ERROR_DS_NONSAFE_SCHEMA_CHANGE;
        }    
    }

    return 0;
} // End ValidClsModOp


//-----------------------------------------------------------------------
//
// Function Name:            ValidClsDelOp
//
// Routine Description:
//
//    Validates whether the Operation on Schema Object is Valid or not
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
ValidClsDelOp(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    if (ClsInAuxClass(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_AUX_CLS;
    }

    if (ClsInSubClassOf(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_SUB_CLS;
    }

    if (ClsInPossSuperior(pTHS, cc))
    {
        return ERROR_DS_EXISTS_IN_POSS_SUP;
    }


    return 0;
} // End ValidClsDelOp

//-----------------------------------------------------------------------
//
// Function Name:            DupAttRdn
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttRdn(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Already been performed... This is a NOOP
    return 0;
} // End DupAttRdn



//-----------------------------------------------------------------------
//
// Function Name:            DupAttOid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttOid(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupOID;
} // End DupAttOid


//-----------------------------------------------------------------------
//
// Function Name:            DupAttMapiid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttMapiid(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupMapiID;
} // End DupAttMapiid



//-----------------------------------------------------------------------
//
// Function Name:            DupAttLinkid
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Link Id
//
// Author: RajNath
// Date  : [4/8/1997]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttLinkid(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    DECLARESCHEMAPTR
    ULONG i;

    if (ac->ulLinkID==0)
    {
        return FALSE;
    }

    for (i=0;i<ATTCOUNT;i++)
    {
        ATTCACHE* nc;

        //
        // Nothing in this slot
        //
        if (ahcId[i].pVal==NULL || ahcId[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (ATTCACHE*)ahcId[i].pVal;


        //
        // Its the same cache structure being examined
        //
        if (nc==ac)
        {
            continue;
        }

        if (nc->ulLinkID == ac->ulLinkID)
        {
            return TRUE;
        }

    }

    return FALSE;
} // End DupAttLinkid

//-----------------------------------------------------------------------
//
// Function Name:            InvalidBackLinkAtt
//
// Routine Description:
//
//    Checks the Att Schema to see if it is a backlink with no forward link
//
// Author: ArobindG
// Date  : [7/28/1998]
//
// Arguments:
//
//    THSTATE* pTHS
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
InvalidBackLinkAtt(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    // backlinks must have a corresponding forward link.
    // backlink cannot be the reserved linkid, RESERVED_AUTO_NO_LINK_ID.
    // See AutoLinkId for more info about automatically assigned linkids
    // and interoperability issues with RESERVED_AUTO_NO_LINK_ID.
    if (   FIsBacklink(ac->ulLinkID)
        && (   !SCGetAttByLinkId(pTHS, MakeLinkId(MakeLinkBase(ac->ulLinkID)))
            || ac->ulLinkID == RESERVED_AUTO_NO_LINK_ID) ) {
        return TRUE;
    }

     return FALSE;
}


//-----------------------------------------------------------------------
//
// Function Name:            InvalidLinkAttSyntax
//
// Routine Description:
//
//    If it is a linked att, check that it has correct syntax
//
// Author: ArobindG
// Date  : [2/16/1998]
//
// Arguments:
//
//    THSTATE* pTHS
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
InvalidLinkAttSyntax(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
     
     if (ac->ulLinkID) {
         if (FIsBacklink(ac->ulLinkID)) {
            // backlinks must be of syntax SYNTAX_DISTNAME_TYPE
            if (ac->syntax != SYNTAX_DISTNAME_TYPE) {
               return TRUE;
            }
         }
         else {
            // forward link. Can be one of the following
            if ( (ac->syntax != SYNTAX_DISTNAME_TYPE) &&
                   (ac->syntax != SYNTAX_DISTNAME_BINARY_TYPE) &&
                     (ac->syntax != SYNTAX_DISTNAME_STRING_TYPE) ) {
                return TRUE;
            }
         }
     }

     return FALSE;
}





//-----------------------------------------------------------------------
//
// Function Name:            DupAttSchemaGuidId
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Schema ID Guid
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttSchemaGuidId(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupPropGuid;
} // End DupAttSchemaGuidId


//-----------------------------------------------------------------------
//
// Function Name:            InvalidClsOrAttLdapDisplayName
//
// Routine Description:
//
//    Checks the given name for invalid ldap display name
//
// Author: ArobindG
// Date  : [7/15/1998]
//
// Arguments:
//
//    name - pointer to null-terminated UTF-8 name
//    nameLen - no. of bytes in the name (not including the null)
//
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//------------------------------------------------------------------

BOOL
InvalidClsOrAttLdapDisplayName(
    UCHAR *name,
    ULONG nameLen
)
{
    ULONG i;
    int c;

    // Must have a ldapDisplayName and, by RFC 2251 s4.1.4, must begin
    // with a letter and must only contain ASCII letters, digit characters
    // and hyphens.

    if (nameLen == 0) {
       return TRUE;
    }

    // non-zero length, so name must be non-null

    Assert(name);

    // Check for hardcoded codes since the C runtime one is locale dependent
    // and behaves strangely for some codes with value > 127
    // NOTE: The name passed in is UTF-8, so can be more than one byte per 
    // actual character. However, it is sufficient to check each byte directly
    // against the ascii code since UTF-8 guarantees that (1) the ascii
    // codes 0x00 to 0x7f are encoded in one byte with the same value, and
    // (2) no other encoding has a byte between 0x00 and 0x7f (all have highest
    // bit set (see rfc 2279)

    // first character must be a letter
    c = (int) name[0];
    if (  ! ( (c >= 'A' && c <= 'Z')
               || (c >= 'a' && c <= 'z') 
            ) 
       ) {
        return TRUE;
    }


    // Other characters must be alphanumeric or -
    for (i = 1; i < nameLen; i++) {
       c = (int) name[i];
       if ( ! ( (c >= 'A' && c <= 'Z')
                  || (c >= 'a' && c <= 'z')
                  || (c >= '0' && c <= '9')
                  || (c == '-') 
              )
          ) {
           return TRUE;
       }
    }

    // ok, all valid characters
   
    return FALSE;
}

    
//-----------------------------------------------------------------------
//
// Function Name:            DupAttLdapDisplayName
//
// Routine Description:
//
//    Checks the Att Schema for Duplicate Ldap-Display-Name
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupAttLdapDisplayName(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    // Detected during the validation cache load
    return ac->bDupLDN;
} // End DupAttLdapDisplayName



//-----------------------------------------------------------------------
//
// Function Name:            SemanticAttTest
//
// Routine Description:
//
//    Checks the Att Schema for Semantic Correctness
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    ATTCACHE* ac            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------

BOOL
SemanticAttTest(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    int i;
    int ret;
    
    if (ac->rangeLowerPresent && ac->rangeUpperPresent)
    {
        switch (ac->syntax)  {
           case SYNTAX_INTEGER_TYPE:
              // compare signed
              if ( ((SYNTAX_INTEGER) ac->rangeLower) >
                       ((SYNTAX_INTEGER) ac->rangeUpper) ) {
                   return TRUE;
              }
              break;
           default:
               // all other cases, compare unsigned
             
               if (ac->rangeLower>ac->rangeUpper)
               {
                   return TRUE;
               }
         }
    }


    return FALSE;
} // End SemanticAttTest

//-----------------------------------------------------------------------
//
// Function Name:           SyntaxMatchTest
//
// Routine Description:
//
//    Tests if the attribute syntax and the om syntax match
//
// Author: Arobindg
// Date  : [6/9/1997]
//
// Arguments:
//
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
SyntaxMatchTest(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    ULONG i;


    for (i = 0; i < SyntaxPairTableLength; i++) {
       if ( (KnownSyntaxPair[i].attSyntax == ac->syntax)
               && (KnownSyntaxPair[i].omSyntax == (OM_syntax) ac->OMsyntax)) {

          // syntaxes match

          break;
        }
    }
    if (i == SyntaxPairTableLength) {
        // syntaxes did not match with any pair
        return TRUE;
    }

    return FALSE;
         
} // End SyntaxMatchTest


//-----------------------------------------------------------------------
//
// Function Name:           OmObjClassTest
//
// Routine Description:
//
//    Tests if the OM-object-class is correct for a object-syntaxed att
//
// Author: Arobindg
// Date  : [5/19/1998]
//
// Arguments:
//
//    ATTCACHE *ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------

BOOL
OmObjClassTest(
    ATTCACHE* ac
)
{
    ULONG valLen = 0, valLenBackup = 0;
    PVOID pTemp = NULL, pBackup = NULL;

    if (ac->OMsyntax != OM_S_OBJECT) {
       // not an object-syntaxed attribute, nothing to do
       // if the attribute-syntax says it is an object but om-syntax
       // is wrong, it will be caught by the SyntaxMatchTest

       return FALSE;
    }

    // ok, we have an object-syntaxed attribute
    // Find what its correct om-object-class should be based on
    // attribute syntax

    switch(ac->syntax) {
        case SYNTAX_DISTNAME_TYPE :
             // DS-DN
             valLen = _om_obj_cls_ds_dn_len;
             pTemp  = _om_obj_cls_ds_dn;
             break;
        case SYNTAX_ADDRESS_TYPE :
             // Presentation-Address
             valLen = _om_obj_cls_presentation_addr_len;
             pTemp  = _om_obj_cls_presentation_addr;
             break;
        case SYNTAX_OCTET_STRING_TYPE :
             // Replica-Link
             valLen = _om_obj_cls_replica_link_len;
             pTemp  = _om_obj_cls_replica_link;
             break;
        case SYNTAX_DISTNAME_STRING_TYPE :
             // Access-Point or DN-String. 
             // We will first check the more common Access-Point
             valLen = _om_obj_cls_access_point_len;
             pTemp  = _om_obj_cls_access_point;
             valLenBackup = _om_obj_cls_dn_string_len;
             pBackup = _om_obj_cls_dn_string;
             break;
        case SYNTAX_DISTNAME_BINARY_TYPE :
             // OR-Name or DN-Binary. 
             // We will first check the more common OR-Name
             valLen = _om_obj_cls_or_name_len;
             pTemp  = _om_obj_cls_or_name;
             valLenBackup = _om_obj_cls_dn_binary_len;
             pBackup = _om_obj_cls_dn_binary;
             break;
        default :
             // Attribute-syntax and OM-syntax do not match,
             // since the above are the only matching attribute
             // syntaxes corresponding to OM_S_OBJECT om-syntax.
             // This should have been already detected by the
             // SyntaxMatchTest which is called before this,
             // but fail this anyway.
             return TRUE;
     }

      // check that the given om-object-class is correct
      // Note that if no om-object-class is specified, 
      // ac->OMObjClass is all 0

      if ( (valLen != ac->OMObjClass.length) ||
             (memcmp(ac->OMObjClass.elements, pTemp, valLen) != 0) ) {

          // om-object-classes do not match

          // Check if the syntax is dn-binary or dn-string
          // if so, there is one more possibility
          if ( (ac->syntax == SYNTAX_DISTNAME_BINARY_TYPE)
               || (ac->syntax == SYNTAX_DISTNAME_STRING_TYPE) ) {
              // check against the backup

              if ( (valLenBackup == ac->OMObjClass.length) &&
                    (memcmp(ac->OMObjClass.elements, pBackup, valLenBackup) == 0) ) {
                 // matched
                 return FALSE;
               }
           }

          return TRUE;
      }

      return FALSE;

}  // End OmObjClassTest


//-----------------------------------------------------------------------
//
// Function Name:           SearchFlagTest
//
// Routine Description:
//
//    Tests if the ANR bit is set, the syntax is either unicode or teletex
//
// Author: Arobindg
// Date  : [10/20/1998]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
SearchFlagTest(
    ATTCACHE* ac
)
{

    if ( ac->fSearchFlags & fANR ) {

       // ANR is set. Check the syntax

       switch (ac->syntax) {
          case SYNTAX_UNICODE_TYPE:
          case SYNTAX_CASE_STRING_TYPE:
          case SYNTAX_NOCASE_STRING_TYPE:
          case SYNTAX_PRINT_CASE_STRING_TYPE:
              // these are allowed
              break;
          default:
              // bad syntax
              return TRUE;
        }
    }
    if ((ac->fSearchFlags & fTUPLEINDEX) && (SYNTAX_UNICODE_TYPE != ac->syntax)) {
        return TRUE;
    }

    return FALSE;

} // End SearchFlagTest

//-----------------------------------------------------------------------
//
// Function Name:          GCReplicationTest 
//
// Routine Description:
//
//    Some attributes, like password etc. are protected from being
//    replicated to GCs for security reasons
//
// Author: Arobindg
// Date  : [05/27/1999]
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
GCReplicationTest(
    ATTCACHE* ac
)
{
    if (DBIsSecretData(ac->id)) {
        // protected att, fail if member of partial att set (none of these
        // are replicated to GCs in the base schema)

        if (ac->bMemberOfPartialSet) {
           return TRUE;
        }
    }

    return FALSE;

} // End GCReplicationTest

             

//-----------------------------------------------------------------------
//
// Function Name:            DupClsRdn
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Arguments:
//
//    CLASSCACHE cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsRdn(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i, FoundRdn, FoundFlagRdn;
    ATTCACHE *pAC;

    // There may be one active attr and several defunct ones that
    // claim the same OID. If so, don't allow them to be used as
    // an rdnattid unless FLAG_ATTR_IS_RDN is set to TRUE in one
    // of the attributes.

    // Count the matching attrs
    for (i = FoundRdn = FoundFlagRdn = 0; i < ATTCOUNT; ++i) {
        pAC = ahcId[i].pVal;
        if (!pAC || pAC == FREE_ENTRY) {
            continue;
        }
        if (pAC->Extid == cc->RdnExtId) {
            ++FoundRdn;
            if (pAC->bFlagIsRdn) {
                ++FoundFlagRdn;
            }
        }
    }

    // No attrs for RdnExtId were found. So no dups.
    if (!FoundRdn) {
        return FALSE;
    }

    // Only one attr claims the RdnExtId. That's okay.
    if (FoundRdn == 1) {
        return FALSE;
    }

    // Only one attr claiming RdnExtId has FLAG_ATTR_IS_RDN set. That's okay.
    if (FoundFlagRdn == 1) {
        return FALSE;
    }

    // Too many attrs claim RdnExtId. Error.
    return TRUE;

} // End DupClsRdn



//-----------------------------------------------------------------------
//
// Function Name:            DupClsOid
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsOid(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupOID;
} // End DupClsOid


//-----------------------------------------------------------------------
//
// Function Name:            DupClsSchemaGuidId
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate RDN
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsSchemaGuidId(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupPropGuid;
} // End DupClsSchemaGuidId



//-----------------------------------------------------------------------
//
// Function Name:            DupClsLdapDisplayName
//
// Routine Description:
//
//    Checks the Cls Schema for Duplicate Ldap-Display-Name
//
// Author: RajNath  
// Date  : [4/8/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc            
//                 
//
// Return Value:
//
//    BOOL            TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
DupClsLdapDisplayName(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    // Detected during the validation cache load
    return cc->bDupLDN;
} // End DupClsLdapDisplayName



//-----------------------------------------------------------------------
//
// Function Name:            ClsMayHaveExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMayHaveExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyMayAtts;
    ULONG  count=cc->MyMayCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        ATTCACHE* ac;
        if (!(ac = SCGetAttById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Ok, the attribute is there. Check that it is not a
        // a deleted attribute
        if (ac->bDefunct) {
           return TRUE;
        }

    }


    return FALSE;
} // End ClsMayHaveExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsMustHaveExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMustHaveExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyMustAtts;
    ULONG  count=cc->MyMustCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        ATTCACHE* ac;
        if (!(ac = SCGetAttById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Ok, the attribute is there. Check that it is not a
        // a deleted attribute. Also, no constucted 
        // attributes should be part of must have

        if (ac->bDefunct || ac->bIsConstructed ) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsMustHaveExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsAuxClassExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks if an aux class has the correct obj class category
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsAuxClassExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pAuxClass;
    ULONG  count=cc->AuxClassCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // Check that the class is not already deleted
        if (pcc->bDefunct) {
           return TRUE;
        }

        // Check that we are not trying to add the same class as 
        // its aux class
        if (cc->ClassId == pcc->ClassId)
        {
            return TRUE;
        }
        // Check that the class category is correct
        if ( (pcc->ClassCategory != DS_AUXILIARY_CLASS) &&
                (pcc->ClassCategory != DS_88_CLASS) ) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsAuxClassExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsPossSupExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks if the class category of a poss sup is correct
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsPossSupExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pMyPossSup;
    ULONG  count=cc->MyPossSupCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // See if class is already deleted
        if (pcc->bDefunct) {
           return TRUE;
        }
    }


    return FALSE;
} // End ClsPossSupExistenceTest


//-----------------------------------------------------------------------
//
// Function Name:            ClsSubClassExistenceTest
//
// Routine Description:
//
//    Tests for Referential Existance of refered to Schema Objects
//    Also checks for various other restrictions depending on object
//    class category
//
// Author: RajNath  
// Date  : [4/14/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//                 
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsSubClassExistenceTest(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    ULONG* list =cc->pSubClassOf;
    ULONG  count=cc->SubClassCount;
    ULONG  i;

    for (i=0;i<count;i++)
    {
        CLASSCACHE* pcc;
        if (!(pcc = SCGetClassById(pTHS, list[i])))
        {
            return TRUE;
        }

        // See if the class is already deleted
        if (pcc->bDefunct) {
          return TRUE;
        }

        // Check that we are not trying to add the same class as
        // its own sub class
        if (cc->ClassId == pcc->ClassId)
        {
            return TRUE;
        }

        // Abstract class can only inherit from abstract
        if ( (cc->ClassCategory == DS_ABSTRACT_CLASS) &&
                (pcc->ClassCategory != DS_ABSTRACT_CLASS) ) {
            return TRUE;
        }
        // Aux class cannot be a subclass of structural class
        // or vice-versa
        if ( ((cc->ClassCategory == DS_AUXILIARY_CLASS) &&
                (pcc->ClassCategory == DS_STRUCTURAL_CLASS))  ||
                  ((cc->ClassCategory == DS_STRUCTURAL_CLASS) && 
                     (pcc->ClassCategory == DS_AUXILIARY_CLASS)) ) {
            return TRUE;
        }
    }


    return FALSE;
} // End ClsSubClassExistenceTest

//-----------------------------------------------------------------------
//
// Function Name:            ClsMayMustPossSafeModifyTest
//
// Routine Description:
//
//    Tests if the change attempted during a class
//    modify will result in adding a new must-contain or 
//    deleting a may-contain, must-contain, or Poss-sup from the 
//    class, either directly or through inheritance
//
// Author: ArobindG
// Date  : [10/7/1998]
//
// Arguments:
//
//    THSTTAE*    pTHS
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsMayMustPossSafeModifyTest(
    THSTATE *pTHS,
    CLASSCACHE* cc
)
{
    ULONG i;
    CLASSCACHE *pccOld;
    ATTCACHE *pAC;

    if (pTHS->pClassPtr == NULL) {
       // no old copy to check with.
       return FALSE;
    }

    // some change is there
    pccOld = (CLASSCACHE *) pTHS->pClassPtr;

    // pccOld is already closed by SCBuildCCEntry. It may have been closed
    // with a slightly older cache (the cache when the modify thread started),
    // but that doesn't matter for the checks below, since we know that
    // the next schema change since then must have passed these tests, and 
    // so even if it is missing from the cache, it doesn't affect testing
    // of the next one and so on. Note that this argument wouldn't have
    // held if we have tried to stop deletions only, since you could have added
    // a mayContain and deleted it and not noticed it if the cache pccOld
    // was closed with didn't have the addition itself. For mustContains, we 
    // stop both addition/deletion, so whatever the set you start with
    // is the set you alwys have. For mayContains/PossSups, we allow
    // both additons and deletions, so we don't care to check anything.
    // for Top, we allow only addition of backlinks, but we also allow
    // deletion of mayContains, so it is again not a problem.

    // If later we disallow deletion again (but still allow addition), 
    // be very careful about closing pccOld. Basically, you want to close 
    // pccOld with all the previous changes minus the current one. But 
    // RecalcSchema already has the current change also. So you cannot 
    // close against it since the current changes may filter into pccOld 
    // through inheritance in some cases, and not give you a true comparison. 
    // So you will somehow need to get to info on what is being changed in 
    // this call and use that.

    // Close the passed-in class cc. It is not closed since we
    // don't call scCloseClass on the recalc cache. This is the only
    // place we need inherited atts, so close it here rather than
    // do it for every  thing. 

    Assert(cc->bClosed == 0);
    cc->bClosed = 0;
    if (scCloseClass(pTHS, cc)) {
       DPRINT1(0, "ClsAuxClassSafeModfyTest: Error closing class %s\n", cc->name);
       return TRUE;
    }


    // Now check to see that cc doesn't have any new must-contains
    // or isn't missing any must-contain when compared to pcc

    // First, all must-contains in the new class defn. must be there
    // in the old one too
    for (i=0; i<cc->MustCount; i++) {
       if (!IsMember(cc->pMustAtts[i], pccOld->MustCount, pccOld->pMustAtts)) {
           return TRUE;
       }
    }

    // ok, so all must-contains that are there now were there before
    // Check that nothing got deleted. A simple check of the count will do this now
    if (cc->MustCount != pccOld->MustCount) {
        return TRUE;
    }

    // For TOP, make sure that no new mayContains that are not backlinks got 
    // added. Rest are all blocked in mdmod.c anyway

    if (cc->ClassId == CLASS_TOP) {
        for (i=0; i<cc->MayCount; i++) {
           if (!IsMember(cc->pMayAtts[i], pccOld->MayCount, pccOld->pMayAtts)) {
               // new att. Make sure it is backlink
               pAC = SCGetAttById(pTHS, cc->pMayAtts[i]);
               if (!pAC || !FIsBacklink(pAC->ulLinkID)) {
                  // can't get the attcache, or not a backlink.
                  return TRUE;
               }
           }
        }
        // nothing else to do for TOP
        return FALSE;
     }

    return FALSE;
}

//-----------------------------------------------------------------------
//
// Function Name:           RdnAttIdSyntaxTest
//
// Routine Description:
//
//    Tests if the RDN-Att-Id of the class is there, and if it is,
//    if it has the proper syntax
//
// Author: Arobindg
// Date  : [6/9/1997]
//
// Arguments:
//
//    CLASSCACHE* cc
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
RdnAttIdSyntaxTest(
    THSTATE *pTHS,
    CLASSCACHE* cc
)
{
    ATTCACHE *pac, *pRDN;

    if ( !(cc->RDNAttIdPresent) ) {
      // No RDN Att Id to check
      return FALSE;
    }

    // Get the attcache for the RDN-Att-Id attribute
    if (!(pac = SCGetAttByExtId(pTHS, cc->RdnExtId))) {
        return TRUE;
    }

    // Check if the RDN-Att-Id is not deleted
    if (pac->bDefunct) {
       return TRUE;
    }


    // Get the attcache for RDN
    if (!(pRDN = SCGetAttById(pTHS, ATT_RDN))) {
        return TRUE;
    }
    
    // Check that the syntaxes match
    if (pac->syntax != pRDN->syntax) {
        return TRUE;
    }
   
    return FALSE;
} // End RdnAttIdSyntaxTest

//-----------------------------------------------------------------------
//
// Function Name:           IsRdnSyntaxTest
//
// Routine Description:
//
//    Tests if the attr has the correct syntax to be an rdn if the
//    systemFlag, FLAG_ATTR_IS_RDN, is set, or the attribute is used
//    as the rdnattid of any class, live or defunct.
//
// Arguments:
//
//    ATTCACHE* ac
//
//
// Return Value:
//
//    BOOL             TRUE Test Failed
//
//-----------------------------------------------------------------------
BOOL
IsRdnSyntaxTest(
    THSTATE *pTHS,
    ATTCACHE* ac
)
{
    ATTCACHE *pRDN;

    // Not used as an rdn; no problem
    if (!ac->bIsRdn) {
        return FALSE;
    }

    // Get the attcache for RDN
    if (!(pRDN = SCGetAttById(pTHS, ATT_RDN))) {
        return TRUE;
    }
    
    // Check that the syntaxes match
    if (ac->syntax != pRDN->syntax) {
        return TRUE;
    }
   
    return FALSE;
} // End IsRdnSyntaxTest

//-----------------------------------------------------------------------
//
// Function Name:            ClsInAuxClass
//
// Routine Description:
//
//    Tests if the Supplied class appears as an Aux. Class of some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInAuxClass(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pAuxClass;
        cnt =nc->AuxClassCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInAuxClass


//-----------------------------------------------------------------------
//
// Function Name:            ClsInSubClassOf
//
// Routine Description:
//
//    Tests if the Supplied class appears as an ClsInSubClassOf Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInSubClassOf(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pSubClassOf;
        cnt =nc->SubClassCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInAuxClass



//-----------------------------------------------------------------------
//
// Function Name:            ClsInPossSuperior
//
// Routine Description:
//
//    Tests if the Supplied class appears as an PossSuperior Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
ClsInPossSuperior(
    THSTATE *pTHS,
    CLASSCACHE* cc 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=cc->ClassId;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        //
        // Its the same cache structure being examined
        // 
        if (nc==cc)
        {
            continue;
        }

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyPossSup;
        cnt =nc->MyPossSupCount;

        for (j=0;j<cnt;j++)
        {
            if (list[j]==id)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End ClsInPossSuperior



//-----------------------------------------------------------------------
//
// Function Name:            AttInMayHave
//
// Routine Description:
//
//    Tests if the Supplied Attr appears as a MayHave Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
AttInMayHave(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=ac->id;
    ULONG Extid=ac->Extid;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        // if it is a deleted class, no need to check it

        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyMayAtts;
        cnt =nc->MyMayCount;

        for (j=0;j<cnt;j++)
        {
            // test both ids
            if (list[j]==id || list[j]==Extid)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End AttInMayHave


//-----------------------------------------------------------------------
//
// Function Name:            AttInMustHave
//
// Routine Description:
//
//    Tests if the Supplied Attr appears as a MustHave Class of 
//    some other Class
//
// Author: RajNath  
// Date  : [4/17/1997]
// 
// Arguments:
//
//    CLASSCACHE* cc               
//
// Return Value:
//
//    BOOL             True   On Test Failed
//
//-----------------------------------------------------------------------
BOOL
AttInMustHave(
    THSTATE *pTHS,
    ATTCACHE* ac 
)
{
    DECLARESCHEMAPTR
    ULONG i;
    ULONG id=ac->id;
    ULONG Extid=ac->Extid;

    for (i=0;i<CLSCOUNT;i++)
    {
        CLASSCACHE* nc;
        ULONG*      list;
        ULONG       cnt;
        ULONG j;

        //
        // Nothing in this slot
        // 
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY)
        {
            continue;
        }

        nc= (CLASSCACHE*)ahcClass[i].pVal;

        // if it is a deleted class, no need to check it
        if (nc->bDefunct) {
           continue;
        }

        list=nc->pMyMustAtts;
        cnt =nc->MyMustCount;

        for (j=0;j<cnt;j++)
        {
            // test both ids
            if (list[j]==id || list[j]==Extid)
            {
                return TRUE;
            }
        }

    }

    return FALSE;
} // End AttInMustHave

BOOL
AttInRdnAttId(
    IN THSTATE  *pTHS,
    IN ATTCACHE *pAC
)
/*++
Routine Description
    Tests if the Supplied Attr appears as a RdnAttId of an active Class

Paramters
    pTHS
    pAC

Return
    BOOL True   On Test Failed
--*/
{
    DECLARESCHEMAPTR
    ULONG       i, Extid=pAC->Extid;
    CLASSCACHE  *pCC;

    for (i=0; i<CLSCOUNT; i++) {
        // An attribute used as an rdnattid of defunct classes can
        // be defuncted (but not reused). Check that every active
        // class claiming this attribute as an rdnattid is defunct.
        if (ahcClass[i].pVal==NULL || ahcClass[i].pVal == FREE_ENTRY) {
            continue;
        }

        pCC = (CLASSCACHE *)ahcClass[i].pVal;
        if (pCC->bDefunct) {
            continue;
        }
        if (pCC->RDNAttIdPresent && (pCC->RdnExtId == Extid)) {
            return TRUE;
        }
    }

    return FALSE;
} // End AttInRdnAttId

//////////////////////////////////////////////////////////////////
// Routine Description:
//     Free all allocated memory in a schema cache
//
// Arguments: Schema Pointer pointer to the schema cache
//
// Return Value: None
/////////////////////////////////////////////////////////////////
// Frees an attcache structure

void SCFreeAttcache(ATTCACHE **ppac)
{
    ATTCACHE *pac = *ppac;

    if (!pac) {
        return;
    }

    SCFree(&pac->name);
    SCFree(&pac->pszIndex);
    SCFree(&pac->pszPdntIndex);
    SCFree(&pac->pszTupleIndex);
    SCFree(&pac->pidxPdntIndex);
    SCFree(&pac->pidxIndex);
    SCFree(&pac->pidxTupleIndex);
    SCFree(&pac->OMObjClass.elements);
    SCFree(ppac);
}

// Frees a classcache structure

void SCFreeClasscache(CLASSCACHE **ppcc)
{
    CLASSCACHE *pcc = *ppcc;

    if (!pcc) {
        return;
    }

    SCFree(&pcc->name);
    SCFree(&pcc->pSD);
    SCFree(&pcc->pStrSD);
    SCFree(&pcc->pSubClassOf);
    SCFree(&pcc->pAuxClass);
    SCFree(&pcc->pMyMustAtts);
    SCFree(&pcc->pMustAtts);
    SCFree(&pcc->pMyMayAtts);
    SCFree(&pcc->pMayAtts);
    SCFree(&pcc->pMyPossSup);
    SCFree(&pcc->pPossSup);
    SCFree(&pcc->pDefaultObjCategory);
    SCFree((VOID **)&pcc->ppAllAtts);
    SCFree(&pcc->pAttTypeCounts);
    SCFree(ppcc);
}

// Frees the prefix table

void SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT)
{
    ULONG i;

    if (*ppPrefixTable) for (i=0; i<PREFIXCOUNT; i++) {
        SCFree(&(*ppPrefixTable)[i].prefix.elements);
    }
    SCFree(ppPrefixTable);
}

void SCFreeSchemaPtr(
    IN SCHEMAPTR    **ppSch
)
{
    ULONG            i;
    SCHEMAPTR       *pSch;
    ULONG            ATTCOUNT;
    ULONG            CLSCOUNT;
    HASHCACHE*       ahcId;
    HASHCACHE*       ahcExtId;
    HASHCACHE*       ahcCol;
    HASHCACHE*       ahcMapi;
    HASHCACHE*       ahcLink;
    HASHCACHESTRING* ahcName;
    HASHCACHE*       ahcClass;
    HASHCACHESTRING* ahcClassName;
    HASHCACHE*       ahcClassAll;
    ATTCACHE**       ahcAttSchemaGuid;
    CLASSCACHE**     ahcClsSchemaGuid;
    ULONG            PREFIXCOUNT;
    PrefixTableEntry* PrefixTable;
    extern SCHEMAPTR *CurrSchemaPtr;

    if (NULL == (pSch = *ppSch)) {
        return;
    }

    ATTCOUNT     = pSch->ATTCOUNT;
    CLSCOUNT     = pSch->CLSCOUNT;
    ahcId        = pSch->ahcId;
    ahcExtId     = pSch->ahcExtId;
    ahcCol       = pSch->ahcCol;
    ahcMapi      = pSch->ahcMapi;
    ahcLink      = pSch->ahcLink;
    ahcName      = pSch->ahcName;
    ahcClass     = pSch->ahcClass;
    ahcClassName = pSch->ahcClassName;
    ahcClassAll  = pSch->ahcClassAll;
    ahcAttSchemaGuid = pSch->ahcAttSchemaGuid;
    ahcClsSchemaGuid = pSch->ahcClsSchemaGuid;
    PREFIXCOUNT  = pSch->PREFIXCOUNT; 
    PrefixTable = pSch->PrefixTable.pPrefixEntry;

    if (ahcId) for (i=0; i< ATTCOUNT; i++) {
       if(ahcId[i].pVal && (ahcId[i].pVal!=FREE_ENTRY)) {
            SCFreeAttcache((ATTCACHE **)&ahcId[i].pVal);
       };
    }

    if (ahcClassAll) for (i=0; i< CLSCOUNT; i++) {
       if(ahcClassAll[i].pVal && (ahcClassAll[i].pVal!=FREE_ENTRY)) {
           SCFreeClasscache((CLASSCACHE **)&ahcClassAll[i].pVal);
       };
    }

    SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

    // Free the partial attribute vector
    SCFree(&pSch->pPartialAttrVec);

    // Free the ANRids
    SCFree(&pSch->pANRids);

    // free the ditContentRules
    if (pSch->pDitContentRules) {
        ATTRVALBLOCK *pAttrVal = pSch->pDitContentRules;

        if (pAttrVal->pAVal) {
            for (i=0; i<pAttrVal->valCount; i++) {
                SCFree(&pAttrVal->pAVal[i].pVal);
            }
            SCFree(&pAttrVal->pAVal);
        }
        SCFree(&pSch->pDitContentRules);
    }

    // Free the Cache tables themselves

    SCFree(&ahcId);
    SCFree(&ahcExtId);
    SCFree(&ahcName);
    SCFree(&ahcCol);
    SCFree(&ahcMapi);
    SCFree(&ahcLink);
    SCFree(&ahcClass);
    SCFree(&ahcClassName);
    SCFree(&ahcClassAll);

    // The following two are allocated only on validation cache
    // building, so check before you free (they are null if not
    // alloc'ed)
    SCFree((VOID **)&ahcAttSchemaGuid);
    SCFree((VOID **)&ahcClsSchemaGuid);

    // Finally, free the schema pointer itself
    SCFree(&pSch);

    // Must be a failure during boot or install. At any rate,
    // keep the global schema cache pointer correct.
    if (*ppSch == CurrSchemaPtr) {
        CurrSchemaPtr = NULL;
    }
    *ppSch = NULL;
}

// Defintions and helper function to get the object-guid of
// an attribute/class schema object given its attributeId/governsId
// respectively

ATTR SelList[] = {
    { ATT_OBJECT_GUID, {0, NULL}},
    { ATT_OBJ_DIST_NAME, {0, NULL}},
    { ATT_WHEN_CHANGED, {0, NULL}}
};
#define NUMATT sizeof(SelList)/sizeof(ATTR)


int
SearchForConflictingObj(
    IN THSTATE *pTHS,
    IN ATTRTYP attId,
    IN ULONG value,
    IN OUT GUID *pGuid,
    IN OUT DSTIME *pChangeTime,
    OUT DSNAME **ppDN
)
/*++
    Routine Description:
        Get the DN, object-guid, and the value of the whenChanged attribute
        on an attribute-schema/class-schema object,
        to put in the conflict log. Since schema conflicts will be very
        rare, the extra search cost during logging is acceptable

    Arguments:
        pTHS - thread state
        attId - ATT_ATTRIBUTE_ID or ATT_GOVERNS_ID
        value - attributeId/governsId of the attribute/class
        pGuid - pre-allocated space to return guid in
        pChangeTime - Value of whenChanged on the object
        ppDN - Return allocated DN. Free with THFreeEx.

    Return value:
        0 on success, non-0 on error
--*/
{
    SEARCHARG SearchArg;
    SEARCHRES *pSearchRes;
    COMMARG  *pCommArg;
    FILTER Filter;
    ENTINFSEL eiSel;
    ENTINFLIST *pEIL;
    ENTINF *pEI;
    ATTRVAL *pAVal;
    ULONG i, j;
    DSTIME TempTime[2];
    GUID  TempGuid[2]; 
    DSNAME *pTempDN[2];

    // Initalize return param
    *ppDN = NULL;

    // will hold the dns
    pTempDN[0] = NULL;
    pTempDN[1] = NULL;

    // allocate space for search res
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    if (pSearchRes == NULL) {
       MemoryPanic(sizeof(SEARCHRES));
       return 1;
    }
    memset(pSearchRes, 0, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;   //Initialize to Default

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    eiSel.AttrTypBlock.attrCount = NUMATT;
    eiSel.AttrTypBlock.pAttr = SelList;

    // build filter
    memset(&Filter, 0, sizeof(FILTER));
    Filter.pNextFilter = (FILTER FAR *)NULL;
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = attId;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (unsigned char *) &value;

    // build search argument
    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = gAnchor.pDMD;
    SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &eiSel;

    // Build Commarg
    InitCommarg(&(SearchArg.CommArg));

    // Search for all attSchema objects
    SearchBody(pTHS, &SearchArg, pSearchRes,0);
    if (pTHS->errCode) {
       DPRINT1(0,"Search for Guid failed %d\n", pTHS->errCode);
       return 2;
    }

    // ok, search succeded. If we have just one object, take the guid.
    // If we have more, which is possible if the object being added created
    // a duplicate OID (won't be there finally because this transaction
    // will fail, but since we are in the middle of it, we still see it),
    // take the one with the lower when-changed value. In any case cannot
    // be more than two, and must b at least 1

    Assert( (pSearchRes->count == 1) || (pSearchRes->count == 2) );

    if ((pSearchRes->count == 0) || (pSearchRes->count > 2)) {
       return 3;
    }

    pEIL = &(pSearchRes->FirstEntInf);        
    Assert(pEIL);
    for (i=0; i<pSearchRes->count; i++) {
        pEI = &pEIL->Entinf;
        Assert(pEI);
        for(j=0;j<pEI->AttrBlock.attrCount;j++) {  
            pAVal = pEI->AttrBlock.pAttr[j].AttrVal.pAVal;
            Assert(pAVal);
            switch(pEI->AttrBlock.pAttr[j].attrTyp) {
              case ATT_OBJECT_GUID:
                memcpy(&(TempGuid[i]), pAVal->pVal, sizeof(GUID));
                break;
              case ATT_WHEN_CHANGED:
                memcpy(&(TempTime[i]), pAVal->pVal, sizeof(DSTIME));
                break;
              case ATT_OBJ_DIST_NAME:
                pTempDN[i] = (DSNAME *)THAllocEx(pTHS, pAVal->valLen);
                memcpy(pTempDN[i], pAVal->pVal, pAVal->valLen);
                break;
            }
        }
        // should have found all three atts
        Assert(j == 3);
        pEIL = pEIL->pNextEntInf;
    }

    if ( (pSearchRes->count == 1) || (TempTime[0] < TempTime[1])) {
        // either only one object found, or the first one is the one we want
        memcpy(pGuid, &(TempGuid[0]), sizeof(GUID));
        (*pChangeTime) = TempTime[0];
        *ppDN = pTempDN[0];
        pTempDN[0] = NULL;
    }
    else {
        memcpy(pGuid, &(TempGuid[1]), sizeof(GUID));
        (*pChangeTime) = TempTime[1];
        *ppDN = pTempDN[1];
        pTempDN[1] = NULL;
    }

    // Free up potentially allocated memory. THFreeEx is okay w/freeing NULL.
    THFreeEx(pTHS, pTempDN[0]);
    THFreeEx(pTHS, pTempDN[1]);

    return 0;
}
   

VOID 
LogConflict(
    THSTATE *pTHS,
    VOID *pConflictingCache,
    char *pConflictingWith,
    MessageId midEvent,
    ULONG version,
    DWORD WinErr
)
/*++
    Routine Description:
        Function to log schema conflicts between replicated-in schema objects
        and exisiting schema objects. Such conflicts can happen only in the
        case of bad FSMO whacking

    Arguments:
        pTHS - thread state
        pConflictingCache - Attcache/Classcache of the conflicting att/class
                            in this DC
        pConflictingWith - name of the conflicting replicated-in schema object
        midEvent - Att conflict or Class conflict
        version - Currently 1, kept for future expansions
        WinErr - A winerror code for type of conflict

    Return value:
        None
--*/
{
    VOID *pvData;
    ULONG cbData;
    ATTCACHE *pAC;
    CLASSCACHE *pCC;
    ATT_CONFLICT_DATA *pAttData;
    CLS_CONFLICT_DATA *pClsData;
    DSTIME changeTime = 0;
    char szTime[SZDSTIME_LEN], *pszTime;
    DSNAME *pDN = NULL;
    int err;


    switch (midEvent) {
       case DIRLOG_SCHEMA_ATT_CONFLICT: 
           cbData = sizeof(ATT_CONFLICT_DATA);
           pvData = THAllocEx(pTHS,cbData);
           pAC = (ATTCACHE *) pConflictingCache;
           Assert(pAC);
           pAttData = (ATT_CONFLICT_DATA *) pvData;
           pAttData->Version = version;
           pAttData->AttID = pAC->id;
           pAttData->AttSyntax = pAC->syntax;
           err = SearchForConflictingObj(pTHS, ATT_ATTRIBUTE_ID, pAC->id, &(pAttData->Guid), &changeTime, &pDN);
           if (err) {
              DPRINT1(0,"Cannot retrive dn/object-guid/time for conflicting schema object, %d\n", err);
           }
           break;
       case DIRLOG_SCHEMA_CLASS_CONFLICT: 
           cbData = sizeof(CLS_CONFLICT_DATA);
           pvData = THAllocEx(pTHS,cbData);
           pCC = (CLASSCACHE *) pConflictingCache;
           Assert(pCC);
           pClsData = (CLS_CONFLICT_DATA *) pvData;
           pClsData->Version = version;
           pClsData->ClsID = pCC->ClassId;
           err = SearchForConflictingObj(pTHS, ATT_GOVERNS_ID, pCC->ClassId, &(pClsData->Guid), &changeTime, &pDN);
           if (err) {
              DPRINT1(0,"Cannot retrive dn/object-guid/time for conflicting schema object, %d\n", err);
           }
           break;
       default:
           // unknown type
           return;
    } /* switch */

    // change changeTime to local time string
    pszTime = DSTimeToDisplayString(changeTime, szTime);

    Assert(pszTime);

    // duplicate ldapdisplaynames are logged differently

    LogEvent8WithData(DS_EVENT_CAT_SCHEMA,
                      DS_EVENT_SEV_ALWAYS,
                      midEvent,
                      szInsertSz(pConflictingWith),
                      szInsertDN(pDN),
                      szInsertWin32Msg(WinErr),
                      szInsertSz(pszTime),
                      NULL, NULL, NULL, NULL, 
                      cbData, pvData);

    THFreeEx(pTHS,pvData);
    THFreeEx(pTHS, pDN);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\src\scache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       scache.c
//
//  Abstract:
//
//   Contains Schema Cache and Schema Access Check Functions
//
//----------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <prefix.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>           // HandleMostExceptions

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>

#include <filtypes.h>           // For FILTER_CHOICE_??? and
                                // FI_CHOICE_???
#include <dsconfig.h>
#include "permit.h"

#include "debug.h"          // standard debugging header
#define DEBSUB "SCACHE:"                // define the subsystem for debugging

// DRA headers
#include "drautil.h"

#include <samsrvp.h>

#include "drserr.h"
#include "drasch.h"

#include <sddlp.h>  // for SD conversion

#include <mbstring.h>  // multibyte string comparison in unit test

#include <fileno.h>
#define  FILENO FILENO_SCACHE

// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt.
#include <schash.c>   // for hash function definitions


extern BOOL gfRunningAsExe;

VOID
scTreatDupsAsDefunct(
    IN THSTATE *pTHS
    );

ATTCACHE*   scAddAtt(THSTATE *pTHS,
                     ENTINF *pEI);
CLASSCACHE* scAddClass(THSTATE *pTHS,
                       ENTINF *pEI);
int
scCloseClass(THSTATE *pTHS,
             CLASSCACHE *pCC);

// Hammer the default SD on cached classes when running as
// dsamain.exe w/security disabled
#if DBG && INCLUDE_UNIT_TESTS
VOID
scDefaultSdForExe(
    IN THSTATE      *pTHS,
    IN CLASSCACHE   *pCC
    );
#define DEFAULT_SD_FOR_EXE(_pTHS_, _pCC_) scDefaultSdForExe(_pTHS_, _pCC_);
#else DBG && INCLUDE_UNIT_TESTS
#define DEFAULT_SD_FOR_EXE(_pTHS_, _pCC_)
#endif DBG && INCLUDE_UNIT_TESTS


int iSCstage;

// Global schema cache pointer
SCHEMAPTR *CurrSchemaPtr=0;
CRITICAL_SECTION csSchemaPtrUpdate;
DSTIME lastSchemaUpdateTime;

// for when updating the dirContentRules in the SCHEMAPTR
CRITICAL_SECTION csDitContentRulesUpdate;

// Global from dsamain.c to indicate if this is the first cache load after boot.
// We skip certain things in that case in order to boot faster
extern BOOL gFirstCacheLoadAfterBoot;

// To serialize blocking and async cache updates
CRITICAL_SECTION csSchemaCacheUpdate;

// Global to store thread handle for async schema cache update thread
// Used to dynamically boost its priority during blocking updates, and
// to close the handle when the thread terminates

HANDLE hAsyncSchemaUpdateThread = NULL;

// Global to ignore bad default SDs during schema cache load.
// Set through Heuristics reg key to allow the system to at least boot
// so that any corrupted default SDs can be corrected

ULONG gulIgnoreBadDefaultSD = 0;


// To prevent jet columns from being updated in the middle of a
// JetGetColumnInfo
CRITICAL_SECTION csJetColumnUpdate;

// To access the global gNoOfSchChangeSinceBoot that is loaded
// in the schema cache to keep track of how uptodate the schema cache is
DWORD gNoOfSchChangeSinceBoot = 0;
CRITICAL_SECTION csNoOfSchChangeUpdate;

DWORD gdwRecalcDelayMs = (5*60*1000);  // 5 minutes of milliseconds
DWORD gdwDelayedMemFreeSec = (10*60);   // 10 minutes of seconds

// Maximum no. of retry's on async schema cache update failure
ULONG maxRetry = 4;

// To ensure two threads don't try to build the colId-sorted att list
// for a class. Not catastrophic, but inefficient and causes memory leak
CRITICAL_SECTION csOrderClassCacheAtts;

// Simple helper function used by qsort to sort a list of attcache pointers
// by attrtyp.  Implemented in mdread.c
extern int __cdecl CmpACByAttType(const void * keyval, const void * datum) ;


// Maximum Number of Jet Tables as stored in the registry
DWORD gulMaxTables = 0;


//
// Events fpr signaling Schema Updates
//
HANDLE evSchema;  // Lazy reload
HANDLE evUpdNow;  // reload now
HANDLE evUpdRepl; // synchronize reload and replication threads (SCReplReloadCache())

// define increment attr count for the partial set allocation
#define DEFAULT_PARTIAL_ATTR_COUNT  (10)
#define PARTIAL_ATTR_COUNT_INC      (10)

// Crude stats for debug and perf analysis
SCHEMASTATS_DECLARE;

#if DBG
struct _schemahashstat {
    int idLookups;
    int idTries;
    int colLookups;
    int colTries;
    int mapiLookups;
    int mapiTries;
    int linkLookups;
    int linkTries;
    int classLookups;
    int classTries;
    int nameLookups;
    int nameTries;
    int PropLookups;
    int PropTries;
    int classNameLookups;
    int classNameTries;
    int classPropLookups;
    int classPropTries;
} hashstat;
#endif

DWORD scFillInSchemaInfo(THSTATE *pTHS);

int
ComputeCacheClassTransitiveClosure(BOOL fForce);


//-----------------------------------------------------------------------
//
// Function Name:            scInitWellKnownAttids
//
// Routine Description:
//
//     Not all attribute and class ids (attids and clsids) can be added
//     as #defines in attids.h because the ids are different on every DC
//     they replicate into. So, whenever the schema is loaded, these
//     variable ids for well known attributes and classes are stored in
//     the SCHEMAPTR.
//
// Arguments:
//    None.
//
// Return Value:
//     None.
//
//-----------------------------------------------------------------------
VOID
scInitWellKnownAttids()
{
    THSTATE *pTHS = pTHStls;
    int err = 0;

    // Entry-TTL
    if (err = OidStrToAttrType(pTHS,
                               FALSE,
                               "\\x2B060104018B3A657703",
                               &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId)) {
          DPRINT1(0, "OidStrToAttrType(EntryTTL) Failed in scInitWellKnownAttids %d\n", err);
          ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId = 0;
     }

     // Dynamic-Object
     if (err = OidStrToAttrType(pTHS,
                                FALSE,
                                "\\x2B060104018B3A657702",
                                &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId)) {
           DPRINT1(0, "OidStrToAttrType(DynamicObject) Failed in scInitWellKnownAttids %d\n", err);
           ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId = 0;
      }

     // InetOrgPerson
     if (err = OidStrToAttrType(pTHS,
                                FALSE,
                                "\\x6086480186F842030202",
                                &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->InetOrgPersonId)) {
           DPRINT1(0, "OidStrToAttrType(InetOrgPersonId) Failed in scInitWellKnownAttids %d\n", err);
           ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->InetOrgPersonId = 0;
      }


}

ATTCACHE * __fastcall
SCGetAttByPropGuid(
        THSTATE *pTHS,
        ATTCACHE *ac
        )
/*++

Routine Description:

    Find an attcache that matches the provided attcache's PropGuid

Arguments:
    pTHS   - pointer to current thread state
    ac - supplies PropGuid

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
    register ATTCACHE *nc;
#if DBG
    hashstat.PropLookups++;
#endif
    if (ahcAttSchemaGuid) {
        for (i=SCGuidHash(ac->propGuid, ATTCOUNT);
                  ahcAttSchemaGuid[i]; i=(i+1)%ATTCOUNT)
        {
#if DBG
            hashstat.PropTries++;
#endif
            nc = (ATTCACHE*)ahcAttSchemaGuid[i];
            if (nc != FREE_ENTRY
                && (0 == memcmp(&nc->propGuid,&ac->propGuid,sizeof(GUID)))) {
                return nc;
            }
        }
    }

    return NULL;
}


ATTCACHE * __fastcall
SCGetAttById(
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*++

Routine Description:

    Find an attcache given its attribute id.

Arguments:
    pTHS   - pointer to current thread state
    attrid - the attribute id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.idLookups++;
    hashstat.idTries++;
#endif


    for (i=SChash(attrid,ATTCOUNT);
         (ahcId[i].pVal
          && (ahcId[i].pVal == FREE_ENTRY
              || ahcId[i].hKey != attrid)); i=(i+1)%ATTCOUNT){
#if DBG
    hashstat.idTries++;
#endif
    }

    // if we didn't find it in the global cache, look in the local thread cache
    //
    if ((ahcId[i].pVal == NULL) && pTHS->pExtSchemaPtr) {
        ATTCACHE **ppACs = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->ppACs;
        DWORD count = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->cUsed;
        
        for (i=0; i<count; i++) {
            if (ppACs[i]->id == attrid) {
                return ppACs[i];
            }
        }
        return NULL;
    }

    return (ATTCACHE*)ahcId[i].pVal;
}


ATTCACHE * __fastcall
SCGetAttByExtId(
        THSTATE *pTHS,
        ATTRTYP attrid
        )
/*++

Routine Description:

    Find an attcache given its attribute id.

Arguments:
    pTHS   - pointer to current thread state
    attrid - the attribute id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.idLookups++;
    hashstat.idTries++;
#endif


    for (i=SChash(attrid,ATTCOUNT);
         (ahcExtId[i].pVal
          && (ahcExtId[i].pVal == FREE_ENTRY
              || ahcExtId[i].hKey != attrid)); i=(i+1)%ATTCOUNT){
#if DBG
    hashstat.idTries++;
#endif
    }
    return (ATTCACHE*)ahcExtId[i].pVal;
}


ATTRTYP __fastcall
SCAttIntIdToExtId(
        THSTATE *pTHS,
        ATTRTYP IntId
        )
/*++

Routine Description:

    convert internal id into an external id

Arguments:
    pTHS   - pointer to current thread state
    IntId - the internal id to be translated

Return Value:
    tokenized OID if IntId is in the hash. Otherwise, IntId

--*/
{
    ATTCACHE *pAC;
    if (pAC = SCGetAttById(pTHS, IntId)) {
        return pAC->Extid;
    }
    return IntId;
}


ATTRTYP __fastcall
SCAttExtIdToIntId(
        THSTATE *pTHS,
        ATTRTYP ExtId
        )
/*++

Routine Description:

    convert external id into an internal id

Arguments:
    pTHS   - pointer to current thread state
    ExtId - the external id to be translated

Return Value:
    ATTRTYP
    Internal Id if ExtId is in the hash. Otherwise, ExtId

--*/
{
    ATTCACHE *pAC;
    if (pAC = SCGetAttByExtId(pTHS, ExtId)) {
        return pAC->id;
    }
    return ExtId;
}

ATTCACHE * __fastcall
SCGetAttByCol(
        THSTATE *pTHS,
        JET_COLUMNID jcol
        )
/*++

Routine Description:

    Find an attcache given its JET column id.

Arguments:
    pTHS   - pointer to current thread state
    jcol - the jet column id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.colLookups++;
    hashstat.colTries++;
#endif
    for (i=SChash(jcol,ATTCOUNT);
         (ahcCol[i].pVal
          && (ahcCol[i].pVal == FREE_ENTRY
              || ahcCol[i].hKey != jcol)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.colTries++;
#endif
    }

    // if we have extended the schema, take a look there too
    // if found it will overide the global schema
    if (pTHS->pExtSchemaPtr) {
        ATTCACHE **ppACs = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->ppACs;
        DWORD count = ((SCHEMAEXT *)(pTHS->pExtSchemaPtr))->cUsed;
        register ULONG j;
        
        for (j=0; j<count; j++) {
            if (ppACs[j]->jColid == jcol) {
                return ppACs[j];
            }
        }
    }

    return (ATTCACHE*)ahcCol[i].pVal;
}

ATTCACHE * __fastcall
SCGetAttByMapiId(
        THSTATE *pTHS,
        ULONG ulPropID
        )
/*++

Routine Description:

    Find an attcache given its MAPI property id.

Arguments:
    pTHS   - pointer to current thread state
    ulPropID - the jet column id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.mapiLookups++;
    hashstat.mapiTries++;
#endif
    for (i=SChash(ulPropID,ATTCOUNT);
         (ahcMapi[i].pVal
           && (ahcMapi[i].pVal == FREE_ENTRY
               || ahcMapi[i].hKey != ulPropID)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.mapiTries++;
#endif
    }
    return (ATTCACHE*)ahcMapi[i].pVal;
}

ATTCACHE * __fastcall
SCGetAttByLinkId(
        THSTATE *pTHS,
        ULONG ulLinkID
        )
/*++

Routine Description:

    Find an attcache given its Link ID.

Arguments:
    pTHS   - pointer to current thread state
    ulLinkID - the link id to look up.

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.linkLookups++;
    hashstat.linkTries++;
#endif
    for (i=SChash(ulLinkID,ATTCOUNT);
         (ahcLink[i].pVal
          && (ahcLink[i].pVal == FREE_ENTRY
              || ahcLink[i].hKey != ulLinkID)); i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.linkTries++;
#endif
    }
    return (ATTCACHE*)ahcLink[i].pVal;
}
ATTCACHE * __fastcall
SCGetAttByName(
        THSTATE *pTHS,
        ULONG ulSize,
        PUCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    pTHS   - pointer to current thread state
    ulSize - the num of chars in the name.
    pVal - the chars in the name

Return Value:
    Pointer to ATTCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;

#if DBG
    hashstat.nameLookups++;
    hashstat.nameTries++;
#endif
    // NOTE: memicmp is OK here since ahcName is UTF8, and restricted to ASCII.
    for (i=SCNameHash(ulSize,pVal,ATTCOUNT);
         (ahcName[i].pVal  // this hash spot refers to an object,
          && (ahcName[i].pVal == FREE_ENTRY  // but its a free slot
              || ahcName[i].length != ulSize // or the size is wrong
              || _memicmp(ahcName[i].value,pVal,ulSize))); // or the value is wrong
         i=(i+1)%ATTCOUNT){
#if DBG
        hashstat.nameTries++;
#endif
    }

    return (ATTCACHE*)ahcName[i].pVal;
}

void
scFreeHashCacheEntry (
        VOID        *pVal,
        ULONG       hKey,
        ULONG       nahc,
        HASHCACHE   *ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a HASHCACHE table

Arguments:
    pVal    - val to match
    hKey    - key to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SChash(hKey, nahc); ahc[i].pVal; i=(i+1)%nahc) {
        if (ahc[i].pVal == pVal && ahc[i].hKey == hKey) {
            ahc[i].pVal = FREE_ENTRY;
            ahc[i].hKey = 0;
            return;
        }
    }
}


void
scFreeHashGuidEntry (
        VOID    *pVal,
        GUID    hKey,
        ULONG   nahc,
        VOID    **ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a ATTCACHE** hash table

Arguments:
    pVal    - val to match
    hKey    - GUID to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SCGuidHash(hKey, nahc); ahc[i]; i=(i+1)%nahc) {
        if (ahc[i] == pVal) {
            ahc[i] = FREE_ENTRY;
            return;
        }
    }
}

void
scFreeHashCacheStringEntry (
        VOID            *pVal,
        ULONG           length,
        PUCHAR          value,
        ULONG           nahc,
        HASHCACHESTRING *ahc
        )
/*++

Routine Description:

    Remove the first matching entry from a HASHCACHESTRING table.

Arguments:
    pVal    - val to match
    length  - length to match
    value   - string to match
    nahc    - size of hash table
    ahc     - hash table

Return Value:
    none.

--*/
{
    DWORD i;

    for (i=SCNameHash(length, value, nahc); ahc[i].pVal; i=(i+1)%nahc) {
         // NOTE: memicmp is OK here since ahcName is UTF8, and is
         //       restricted to ASCII
         if (   ahc[i].pVal == pVal
             && ahc[i].value
             && ahc[i].length == length
             && (0 == _memicmp(ahc[i].value, value, length))) {

            ahc[i].pVal = FREE_ENTRY;
            ahc[i].value = NULL;
            ahc[i].length = 0;
            return;
         }
    }
}


#define SC_UNHASH_ALL           0
#define SC_UNHASH_LOST_OID      1
#define SC_UNHASH_LOST_LDN      2
#define SC_UNHASH_LOST_MAPIID   3
#define SC_UNHASH_DEFUNCT       4
void
scUnhashAtt(
        THSTATE     *pTHS,
        ATTCACHE    *pAC,
        DWORD       UnhashType
        )
/*++

Routine Description:

    Remove an attcache from specified hash tables

Arguments:
    pTHS - thread state
    pAC - attribute to be unhased
    UnhashType - Identifies groups of tables

Return Value:
    none.

--*/
{
    DECLARESCHEMAPTR

    // All
    if (UnhashType == SC_UNHASH_ALL) {
        // internal id, column, and linkid
        scFreeHashCacheEntry(pAC, pAC->id, ATTCOUNT, ahcId);
        if (pAC->jColid) {
            scFreeHashCacheEntry(pAC, pAC->jColid, ATTCOUNT, ahcCol);
        }
        if (pAC->ulLinkID) {
            scFreeHashCacheEntry(pAC, pAC->ulLinkID, ATTCOUNT, ahcLink);
        }
    }

    // All or Defunct
    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT) {
        if (ahcAttSchemaGuid) {
            scFreeHashGuidEntry(pAC, pAC->propGuid, ATTCOUNT, ahcAttSchemaGuid);
        }
    }

    // All or Defunct or lost mapiID
    // defunct attrs don't own their OID, mapiId, LDN, or schemaIdGuid
    // A colliding RDN attribute may lose one or more of OID, mapiID, or LDN

    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_MAPIID) {
        if (pAC->ulMapiID) {
            scFreeHashCacheEntry(pAC, pAC->ulMapiID, ATTCOUNT, ahcMapi);
        }
    }

    // All or Defunct or lost LDN
    if (UnhashType == SC_UNHASH_ALL
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_LDN) {
        if (pAC->name) {
            scFreeHashCacheStringEntry(pAC, pAC->nameLen, pAC->name, ATTCOUNT, ahcName);
        }
    }

    // All or Defunct or lost OID
    if (UnhashType == SC_UNHASH_ALL 
        || UnhashType == SC_UNHASH_DEFUNCT
        || UnhashType == SC_UNHASH_LOST_OID) {
        scFreeHashCacheEntry(pAC, pAC->Extid, ATTCOUNT, ahcExtId);
    }
}


void
scUnhashCls(
        IN THSTATE     *pTHS,
        IN CLASSCACHE  *pCC,
        IN DWORD        UnhashType
        )
/*++

Routine Description:

    Remove a classcache from specified hash tables

Arguments:
    pTHS - thread state
    pAC - attribute to be unhased
    UnhashType - Identifies groups of tables

Return Value:
    none.

--*/
{
    DECLARESCHEMAPTR

    // Remove from hash of all classes
    if (UnhashType == SC_UNHASH_ALL) {
        scFreeHashCacheEntry(pCC, pCC->ClassId, CLSCOUNT, ahcClassAll);
    }

    // A defunct or duplicate classcache loses its name and guid
    // but not its OID. Some class must hold the OID so that
    // replication, rename, and delete work.
    if (UnhashType == SC_UNHASH_ALL || UnhashType == SC_UNHASH_DEFUNCT) {
        if (pCC->name) {
            scFreeHashCacheStringEntry(pCC, pCC->nameLen, pCC->name, CLSCOUNT, ahcClassName);
        }
        if (ahcClsSchemaGuid) {
            scFreeHashGuidEntry(pCC, pCC->propGuid, CLSCOUNT, ahcClsSchemaGuid);
        }
    }

    // Lost the OID. Remove from active hash. Some class must claim
    // the oid even if the "winner" is defunct so that replication,
    // rename, and delete work.
    if (UnhashType == SC_UNHASH_ALL || UnhashType == SC_UNHASH_LOST_OID) {
        scFreeHashCacheEntry(pCC, pCC->ClassId, CLSCOUNT, ahcClass);
    }
}

CLASSCACHE * __fastcall
SCGetClassByPropGuid(
        THSTATE *pTHS,
        CLASSCACHE *cc
        )
/*++

Routine Description:

    Find a classcache that matches the provided classcache's PropGuid

Arguments:
    pTHS   - pointer to current thread state
    cc - supplies PropGuid

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
    register CLASSCACHE *nc;
#if DBG
    hashstat.classPropLookups++;
#endif
    if (ahcClsSchemaGuid) {
        for (i=SCGuidHash(cc->propGuid, CLSCOUNT);
                  ahcClsSchemaGuid[i]; i=(i+1)%CLSCOUNT)
        {
#if DBG
            hashstat.classPropTries++;
#endif
            nc = (CLASSCACHE*)ahcClsSchemaGuid[i];
            if (nc != FREE_ENTRY
                && (memcmp(&nc->propGuid,&cc->propGuid,sizeof(GUID))==0)) {
                return nc;
            }
        }
    }

    return NULL;
}

CLASSCACHE * __fastcall
SCGetClassById(
        THSTATE *pTHS,
        ATTRTYP classid
        )
/*++

Routine Description:

    Find a classcache given its class id (governsId).

Arguments:
    pTHS   - pointer to current thread state
    classid - the class id to look up.

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.classLookups++;
    hashstat.classTries++;
#endif
    for (i=SChash(classid,CLSCOUNT);
         (ahcClass[i].pVal
          && (ahcClass[i].pVal == FREE_ENTRY
              || ahcClass[i].hKey != classid)); i=(i+1)%CLSCOUNT){
#if DBG
        hashstat.classTries++;
#endif
    }
    return (CLASSCACHE*)ahcClass[i].pVal;
}

CLASSCACHE * __fastcall
SCGetClassByName(
        THSTATE *pTHS,
        ULONG ulSize,
        PUCHAR pVal
        )
/*++

Routine Description:

    Find a classcache given its name.

Arguments:
    pTHS   - pointer to current thread state
    ulSize - the num of chars in the name.
    pVal - the chars in the name

Return Value:
    Pointer to CLASSCACHE if found, otherwise NULL

--*/
{
    DECLARESCHEMAPTR
    register ULONG i;
#if DBG
    hashstat.classNameLookups++;
    hashstat.classNameTries++;
#endif

    // NOTE: memicmp is OK here since ahcClassName is UTF8, and is restricted to
    //       ASCII
    for (i=SCNameHash(ulSize,pVal,CLSCOUNT);
         (ahcClassName[i].pVal          // this hash spot refers to an object,
          && (ahcClassName[i].pVal == FREE_ENTRY
              || ahcClassName[i].length != ulSize    // but the size is wrong
              || _memicmp(ahcClassName[i].value,pVal,ulSize))); // or value is wrong
         i=(i+1)%CLSCOUNT){
#if DBG
        hashstat.classNameTries++;
#endif
    }


    return (CLASSCACHE*)ahcClassName[i].pVal;
}

void scMemoryPanic(
      ULONG size
      )
/*++
     Wrapper around MemoryPanic (which is a macro wrapping around DoLogEvent,
     but does allocate some locals), so as to not bloat the stack size
     of scCloseClass, which is recursive
--*/
{
    MemoryPanic(size);
}

// Not for general use. Set to 0 in all builds.
//
// Set to 1 for quick and dirty check to make sure schema
// loads aren't leaking memory. Doesn't take into account memory
// freed/alloced outside of scchk.c, scache.c, and oidconv.c.
// Don't enable except in privates. Not stable.
#define _DEBUG_SCHEMA_ALLOC_ 0

#if !INCLUDE_UNIT_TESTS || !_DEBUG_SCHEMA_ALLOC_

//
// The real, shipped versions of the allocation routines.
//
VOID
SCFree(
    IN OUT VOID **ppMem
    )
/*++

Routine Description:

    Free memory allocated with SCCalloc or SCRealloc.

Arguments:
    ppMem - address of address of memory to free

Return Value:

    *ppMem is set to NULL;

--*/
{
    if (*ppMem) {
        free(*ppMem);
        *ppMem = NULL;
    }
}

int
SCReallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with SCFree(). On error, log an event but leave
    *ppMem unaltered.

Arguments:

    ppMem - Address of address of memory to realloc
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and log an event

--*/
{
    PVOID mem;

    if (NULL == (mem = realloc(*ppMem, nBytes))) {
        // log an event
        scMemoryPanic(nBytes);
        return 1;
    }
    *ppMem = mem;
    return 0;
}

int
SCCallocWrn(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with SCFree(). On error, log an event
    and clear *ppMem.

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and log an event

--*/
{
    if (NULL == (*ppMem = calloc(nItems, nBytes))) {
        // log an event
        scMemoryPanic(nBytes);
        return 1;
    }
    return 0;
}
#endif !INCLUDE_UNIT_TESTS || !_DEBUG_SCHEMA_ALLOC_

int
SCCalloc(
    IN OUT VOID **ppMem,
    IN DWORD    nItems,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    malloc and clear memory. Free with SCFree(). On error, set svc 
    error in thread state and clear *ppMem.

Arguments:

    ppMem - address of address to return memory pointer
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of malloced, cleared memory. Free with SCFree().
    !0 - clear *ppMem and set svc error in thread state

--*/
{
    if (SCCallocWrn(ppMem, nItems, nBytes)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_SCHEMA_ALLOC_FAILED);
    }
    return 0;
}

int
SCRealloc(
    IN OUT VOID **ppMem,
    IN DWORD    nBytes
    )
/*++

Routine Description:

    realloc memory. Free with SCFree(). On error, set svc 
    error in thread state but leave *ppMem unaltered.

Arguments:

    ppMem - Address of address of memory to realloc
    nBytes - bytes to allocate

Return Value:

    0 - *ppMem set to address of realloced memory. Free with SCFree().
    !0 - do not alter *ppMem and set svc error in thread state

--*/
{
    if (SCReallocWrn(ppMem, nBytes)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_SCHEMA_ALLOC_FAILED);
    }
    return 0;
}

#if 0
// Some primes to make the hash function work better
//
// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.
//
// If you change schash.c, you must touch scchk.c and scache.c
// so that they get rebuilt.
DWORD scPrimes[] = 
{      1031,      1543,      2053,      2579,      3079,      3593,
       4099,      4621,      5147,      5669,      6247,      6883,
       7177,      8209,      9221,     10243,     11273,     12401,
      13649,     15017,     16519,     18181,     20011,     22013,
      24223,     26647,     29327,     32261,     35491,     39041,
      42953,     47251,     51977,     57179,     62897,     69191,
      76123,     83737,     92111,    101323,    111467,    122651,
     134917,    148411,    163259,    179591,    197551,    217307,
     239053,    262981,    289283,    318229,    350087,    385109,
     423649,    466019,    512621,    563887,    620297,    682327,
     750571,    825637,    908213,    999043,   1098953,   1208849,
    1329761,   1462739,   1609021,   1769927,   1946921,   2141617,
    2355799,   2591389,   2850541,   3135607,   3449179,   3794101,
    4173523,   4590877,   5049977,   5554993,   6110501,   6721553,
    7393733,   8133107,   8946449,   9841099,  10825211,  11907733,
   13098511,  14408363,  15849221,  17434169,  19177589,  21095357,
   23204911,  25525403,  28077947,  30885749,  33974351,  37371821,
   41109041,  45219991,  49741997,  54716197,  60187879,  66206689,
   72827383,  80110139,  88121197,  96933349, 106626721, 117289433,
  129018403, 141920257, 156112291, 171723523, 188895881, 207785489,
  228564079, 251420539, 276562597, 304218881, 334640771, 368104871,
  404915393, 445406947, 489947659, 538942477, 592836773, 652120481,
  717332587, 789065857, 867972481, 954769757,
  0
};
#endif 0

ULONG
scRecommendedHashSize(
    IN ULONG    nExpectedEntries,
    IN ULONG    nSlots
    // IN ULONG    nExtra
    )
/*++

Routine Description:

    Return the number of hash slots to allocate based on the number
    of entries expected.

Arguments:

    nExpectedEntries - Number of total entries the hash table will hold

    nSlots - number of entries the hash table can currently hold

    nExtra - number of extra entries to add to the hash table size
    to prevent excessive hash table resizing when experimenting
    with prime hash table sizes

Return Value:

    Number of slots the hash table needs to effectively handle
    nExptectedEntries plus nExtra.

--*/
{
    DWORD i;

    DWORD PowerOf2;

    // Hash table size is ok if it can hold twice the expected entries
    //
    // Must be < and not <= because nSlots and nExpectedEntries
    // are 0 for the first allocation (or will be if you enable
    // nExtra for prime.
    nExpectedEntries *= 2;
    if (nExpectedEntries < nSlots) {
        return nSlots;
    }

    // Select a power of 2 large enough to hold twice the number of entries
    for (PowerOf2 = 256; PowerOf2 && PowerOf2 < nExpectedEntries; PowerOf2 <<= 1);
    return PowerOf2;

#if 0
// The hash tables must be a power of 2 in length because the hash
// functions use (x & (n - 1)), not (x % n).
//
// A table of prime numbers and some code in scRecommendedHashSize
// has been left in place for later experimentation but has been
// ifdef'ed out to save CD space.
//
// Using a prime number of slots reduces the size of the tables
// and decreases the miss rate but increases the cycles needed to
// compute the hash index by a factor of 10x to 20x.

    // Reduce the frequency of hash table resizing by allocating
    // a few extra slots. This means the hash table will be resized
    // every nExtra/2 entries. A prime number close to this value
    // is then chosen. A prime number is used to improve hash
    // lookup performance

    nSlots = nExpectedEntries + nExtra;
    for (i = 0; scPrimes[i]; ++i) {
        if (scPrimes[i] > nSlots) {
            return scPrimes[i];
        }
    }

    // Wow, that's a lot of schema objects! Simply round the
    // nSlots up to a nExtra boundary and forget the prime number.
    DPRINT1(0, "nSlots == %d; exceeds prime number table!\n", nSlots);
    return (((nSlots + (nExtra - 1)) / nExtra) * nExtra);
#endif 0
}


int
SCResizeAttHash(
    IN THSTATE  *pTHS,
    IN ULONG    nNewEntries
    )
/*++

Routine Description:

    Resize the hash tables for attributes in the schema cache for
    pTHS. If present, the old entries are copied into the newly
    allocated tables before freeing the old tables.

    pTHS->CurrSchemaPtr is assumed to have been recently allocated by
    SCCacheSchemaInit and should NOT be the current global CurrSchemaPtr
    (unless running single-threaded during boot or install).

    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.

Arguments:

    pTHS - thread state pointing at the schema cache to realloc
    nNewEntries - Number of new entries the resized hashes will hold

Return Value:

    0 on success, !0 otherwise.
    The caller should refresh the local pointers, especially those
    declared by DECLARESCHEMAPTR.

--*/
{
    int             err = 0;
    ULONG           nHE, i;
    ULONG           ATTCOUNT;
    ATTCACHE        *pAC; 
    SCHEMAPTR       *pSch = pTHS->CurrSchemaPtr;
    // old (current) hash tables
    ULONG           OldATTCOUNT;
    HASHCACHE       *OldahcId;
    HASHCACHE       *OldahcExtId;
    HASHCACHE       *OldahcCol;
    HASHCACHE       *OldahcMapi;
    HASHCACHE       *OldahcLink;
    HASHCACHESTRING *OldahcName;
    ATTCACHE        **OldahcAttSchemaGuid;
    // new hash tables
    HASHCACHE       *ahcId;
    HASHCACHE       *ahcExtId;
    HASHCACHE       *ahcCol;
    HASHCACHE       *ahcMapi;
    HASHCACHE       *ahcLink;
    HASHCACHESTRING *ahcName;
    ATTCACHE        **ahcAttSchemaGuid;

    // Recommended hash size
    OldATTCOUNT = pSch->ATTCOUNT;
    ATTCOUNT = scRecommendedHashSize(nNewEntries + pSch->nAttInDB, 
                                     OldATTCOUNT);
                                     // START_ATTCOUNT);

    // No resizing needed; return immediately and avoid cleanup
    if (ATTCOUNT <= OldATTCOUNT) {
        return 0;
    }

    DPRINT5(1, "Resize attr hash from %d (%d in DB) to %d (%d New entries) for %s\n",
            pSch->ATTCOUNT, pSch->nAttInDB, ATTCOUNT, nNewEntries,
            (pTHS->UpdateDITStructure) ? "normal cache load" : "validation cache");

    //
    // ALLOCATE NEW TABLES
    //

    OldahcId = pSch->ahcId;
    OldahcExtId = pSch->ahcExtId;
    OldahcCol = pSch->ahcCol;
    OldahcMapi = pSch->ahcMapi;
    OldahcLink = pSch->ahcLink;
    OldahcName = pSch->ahcName;
    OldahcAttSchemaGuid = pSch->ahcAttSchemaGuid;

    ahcId = NULL;
    ahcExtId = NULL;
    ahcCol = NULL;
    ahcMapi = NULL;
    ahcLink = NULL;
    ahcName = NULL;
    ahcAttSchemaGuid = NULL;


    // Must be running single threaded (Eg, install or boot)
    // or must *not* be using the global, shared schema cache.
    Assert (!DsaIsRunning() || pSch != CurrSchemaPtr || pSch->RefCount == 1);

    // Must have mandatory hash tables
    Assert((OldATTCOUNT == 0)
           || (OldahcId && OldahcExtId && OldahcCol && OldahcMapi && OldahcLink && OldahcName));

    // Allocate new hash tables (including optional table for validation cache)
    if (   SCCalloc(&ahcId, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcExtId, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcCol, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcMapi, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcLink, ATTCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcName, ATTCOUNT, sizeof(HASHCACHESTRING))
        || (!pTHS->UpdateDITStructure 
            && SCCalloc((VOID **)&ahcAttSchemaGuid, ATTCOUNT, sizeof(ATTCACHE **)))) {
        err = ERROR_DS_CANT_CACHE_ATT;
        goto cleanup;
    }

    //
    // MOVE EXSTING HASH ENTRIES INTO THE NEW TABLES
    //

    // Just to be safe, take the perf hit and move each of the
    // entries in each of the hash tables instead of moving
    // just the entries pointed to by ahcId.
    for (nHE = 0; nHE < OldATTCOUNT; ++nHE) {

        // id
        pAC = OldahcId[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->id, ATTCOUNT);
                 ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcId[i].hKey = pAC->id;
            ahcId[i].pVal = pAC;
        }

        // Extid
        pAC = OldahcExtId[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->Extid, ATTCOUNT);
                 ahcExtId[i].pVal && (ahcExtId[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcExtId[i].hKey = pAC->Extid;
            ahcExtId[i].pVal = pAC;
        }

        // jcolid
        pAC = OldahcCol[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            for (i=SChash(pAC->jColid,ATTCOUNT);
                 ahcCol[i].pVal && (ahcCol[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcCol[i].hKey = pAC->jColid;
            ahcCol[i].pVal = pAC;
        }

        // MapiID
        pAC = OldahcMapi[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->ulMapiID);
            for (i=SChash(pAC->ulMapiID, ATTCOUNT);
                 ahcMapi[i].pVal && (ahcMapi[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcMapi[i].hKey = pAC->ulMapiID;
            ahcMapi[i].pVal = pAC;
        }

        // Name
        pAC = OldahcName[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->name);
            for (i=SCNameHash(pAC->nameLen, pAC->name, ATTCOUNT);
                        ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcName[i].length = pAC->nameLen;
            ahcName[i].value = pAC->name;
            ahcName[i].pVal = pAC;
        }

        // LinkID
        pAC = OldahcLink[nHE].pVal;
        if (pAC && pAC != FREE_ENTRY) {
            Assert(pAC->ulLinkID);
            for (i=SChash(pAC->ulLinkID, ATTCOUNT);
                    ahcLink[i].pVal && (ahcLink[i].pVal != FREE_ENTRY); i=(i+1)%ATTCOUNT) {
            }
            ahcLink[i].hKey = pAC->ulLinkID;
            ahcLink[i].pVal = pAC;
        }

        // schema guid (optional)
        if (!pTHS->UpdateDITStructure) {
            pAC = OldahcAttSchemaGuid[nHE];
            if (pAC && pAC != FREE_ENTRY) {
                for (i=SCNameHash(sizeof(GUID), (PUCHAR)&pAC->propGuid, ATTCOUNT);
                    ahcAttSchemaGuid[i]; i=(i+1)%ATTCOUNT) {
                }
                ahcAttSchemaGuid[i] = pAC;
            }
        }
    }

cleanup:
    if (err) {
        // Error: Retain old hash tables; free new hash tables
        SCFree(&ahcId);
        SCFree(&ahcExtId);
        SCFree(&ahcCol);
        SCFree(&ahcMapi);
        SCFree(&ahcLink);
        SCFree(&ahcName);
        SCFree((VOID **)&ahcAttSchemaGuid);
    } else {
        // Assign new hash tables
        pSch->ATTCOUNT          = ATTCOUNT;
        pSch->ahcId             = ahcId;
        pSch->ahcExtId          = ahcExtId;
        pSch->ahcCol            = ahcCol;
        pSch->ahcMapi           = ahcMapi;
        pSch->ahcLink           = ahcLink;
        pSch->ahcName           = ahcName;
        pSch->ahcAttSchemaGuid  = ahcAttSchemaGuid;

        // free old hash tables
        SCFree(&OldahcId);
        SCFree(&OldahcExtId);
        SCFree(&OldahcCol);
        SCFree(&OldahcMapi);
        SCFree(&OldahcLink);
        SCFree(&OldahcName);
        SCFree((VOID **)&OldahcAttSchemaGuid);
    }

    return(err);
}


int
SCResizeClsHash(
    IN THSTATE  *pTHS,
    IN ULONG    nNewEntries
    )
/*++

Routine Description:

    Resize the hash tables for classes in the schema cache for
    pTHS. If present, the old entries are copied into the newly
    allocated tables before freeing the old tables.

    pTHS->CurrSchemaPtr is assumed to have been recently allocated by
    SCCacheSchemaInit and should NOT be the current global CurrSchemaPtr
    (unless running single-threaded during boot or install).

    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.

Arguments:

    pTHS - thread state pointing at the schema cache to realloc
    nNewEntries - Number of new entries the resized hashes will hold

Return Value:

    0 on success, !0 otherwise.
    The caller must refresh its local pointers, especially those
    declared by DECLARESCHEMAPTR.
--*/
{
    int             err = 0;
    ULONG           nHE, i;
    ULONG           CLSCOUNT;
    CLASSCACHE      *pCC; 
    SCHEMAPTR       *pSch = pTHS->CurrSchemaPtr;
    // old (current) hash tables
    ULONG           OldCLSCOUNT;
    HASHCACHE       *OldahcClass;
    HASHCACHE       *OldahcClassAll;
    HASHCACHESTRING *OldahcClassName;
    CLASSCACHE      **OldahcClsSchemaGuid;
    // new hash tables
    HASHCACHE       *ahcClass;
    HASHCACHE       *ahcClassAll;
    HASHCACHESTRING *ahcClassName;
    CLASSCACHE      **ahcClsSchemaGuid;

    // Recommended hash size
    OldCLSCOUNT = pSch->CLSCOUNT;
    CLSCOUNT = scRecommendedHashSize(nNewEntries + pSch->nClsInDB, 
                                     OldCLSCOUNT);
                                     // START_CLSCOUNT);

    // No resizing needed; return immediately and avoid cleanup
    if (CLSCOUNT <= OldCLSCOUNT) {
        return 0;
    }

    //
    // ALLOCATE THE NEW TABLES
    //
    DPRINT5(1, "Resize class hash from %d (%d in DB) to %d (%d New entries) for %s\n",
            pSch->CLSCOUNT, pSch->nClsInDB, CLSCOUNT, nNewEntries,
            (pTHS->UpdateDITStructure) ? "normal cache load" : "validation cache");

    OldahcClass = pSch->ahcClass;
    OldahcClassAll = pSch->ahcClassAll;
    OldahcClassName = pSch->ahcClassName;
    OldahcClsSchemaGuid = pSch->ahcClsSchemaGuid;

    ahcClass = NULL;
    ahcClassAll = NULL;
    ahcClassName = NULL;
    ahcClsSchemaGuid = NULL;

    // Must be running single threaded (Eg, install or boot)
    // or must *not* be using the global, shared schema cache.
    Assert (!DsaIsRunning() || pSch != CurrSchemaPtr || pSch->RefCount == 1);

    // Must have mandatory hash tables
    Assert((OldCLSCOUNT == 0)
           || (OldahcClass && OldahcClassName && OldahcClassAll));

    // Allocate new hash tables (including optional table for validation cache)
    if (   SCCalloc(&ahcClass, CLSCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcClassAll, CLSCOUNT, sizeof(HASHCACHE))
        || SCCalloc(&ahcClassName, CLSCOUNT, sizeof(HASHCACHESTRING))
        || (!pTHS->UpdateDITStructure
            && SCCalloc((VOID **)&ahcClsSchemaGuid, CLSCOUNT, sizeof(CLASSCACHE **)))) {
        err = ERROR_DS_CANT_CACHE_CLASS;
        goto cleanup;
    }

    //
    // MOVE EXSTING HASH ENTRIES INTO THE NEW TABLES
    //

    // Just to be safe, take the perf hit and move each of the
    // entries in each of the hash tables instead of moving
    // just the entries pointed to by ahcClassAll.
    for (nHE = 0; nHE < OldCLSCOUNT; ++nHE) {

        // Class
        pCC = OldahcClass[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            for (i=SChash(pCC->ClassId, CLSCOUNT);
                 ahcClass[i].pVal && (ahcClass[i].pVal != FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClass[i].hKey = pCC->ClassId;
            ahcClass[i].pVal = pCC;
        }

        // ClassAll
        pCC = OldahcClassAll[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            for (i=SChash(pCC->ClassId, CLSCOUNT);
                 ahcClassAll[i].pVal && (ahcClassAll[i].pVal != FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClassAll[i].hKey = pCC->ClassId;
            ahcClassAll[i].pVal = pCC;
        }

        // Name
        pCC = OldahcClassName[nHE].pVal;
        if (pCC && pCC != FREE_ENTRY) {
            Assert(pCC->name);
            for (i=SCNameHash(pCC->nameLen, pCC->name, CLSCOUNT);
                 ahcClassName[i].pVal && (ahcClassName[i].pVal!= FREE_ENTRY); i=(i+1)%CLSCOUNT) {
            }
            ahcClassName[i].length = pCC->nameLen;
            ahcClassName[i].value = pCC->name;
            ahcClassName[i].pVal = pCC;
        }

        // schema guid (optional)
        if (!pTHS->UpdateDITStructure) {
            pCC = OldahcClsSchemaGuid[nHE];
            if (pCC && pCC != FREE_ENTRY) {
                for (i=SCNameHash(sizeof(GUID), (PCHAR)&pCC->propGuid, CLSCOUNT);
                     ahcClsSchemaGuid[i]; i=(i+1)%CLSCOUNT) {
                }
                ahcClsSchemaGuid[i] = pCC;
            }
        }
    }

cleanup:
    if (err) {
        // Error: Retain old hash tables; free new hash tables
        SCFree(&ahcClass);
        SCFree(&ahcClassAll);
        SCFree(&ahcClassName);
        SCFree((VOID **)&ahcClsSchemaGuid);
    } else {
        // Assign new hash tables
        pSch->CLSCOUNT          = CLSCOUNT;
        pSch->ahcClass          = ahcClass;
        pSch->ahcClassAll       = ahcClassAll;
        pSch->ahcClassName      = ahcClassName;
        pSch->ahcClsSchemaGuid  = ahcClsSchemaGuid;

        // free old hash tables
        SCFree(&OldahcClass);
        SCFree(&OldahcClassAll);
        SCFree(&OldahcClassName);
        SCFree((VOID **)&OldahcClsSchemaGuid);
    }

    return(err);
}


int
SCCacheSchemaInit (
    VOID
    )
/*++

Routine Description:

    Scan the jet columns and pre-load the attribute hash tables with
    just enough info to allow searching the schemaNC (aka DMD).

    The ATTCACHE entries in the attribute hash tables are only
    partially filled in (id, syntax, and colid) and are in just
    the id and col hash tables. But this is enough info to allow
    searching the schemaNC. SCCacheSchema2 is responsible for
    searching the schemaNC and filling in the rest of the info
    in the ATTCACHE entries.
    
    If this isn't the first schema cache load at boot, then
    SCCacheSchema3 will delete the indexes and columns for attributes
    that don't have corresponding entries in the schemaNC and will
    add missing indexes and columns for attributes in the schemaNC.
    The expensive index creation is delayed until the second
    cache load after boot (approximately 5 minutes after boot)
    so that the AD comes online more quickly and isn't delayed
    for what could be hours.

    Sideeffects:
    1) A new schemaptr is allocated and assigned to pTHS->CurrSchemaPtr.

    2) During the first cache load the global schema pointer,
    CurrSchemaPtr, is set. This code assumes that during boot the
    DSA runs single threaded. Hence CurrSchemaPtr has only some
    info filled in until after the call to SCCacheSchema2. But
    its enough to search the schemaNC.

    3) All of the hash tables and the prefix table are allocated.
    The prefix table is initialized with the hardcoded prefixs
    in MSPrefixTable.

    Suggested Enhancements
    1) DECLARESCHEMAPTR consumes more stack than is needed in most functions.
       Just declare by hand. Fix declaration so casting not needed for
       pTHS->currSchemaPtr.

    2) Write SCMalloc to avoid memset when alloc followed by memcpy.

Arguments:

    None.

Return Value:

    !0 - failed; caller is responsible for freeing pTHS->CurrSchemaPtr
    with SCFreeSchemaPtr(&pTHS->CurrSchemaPtr);

    0 - Okay

--*/
{
    THSTATE *pTHS=pTHStls;
    JET_ERR je;
    JET_SESID jsid;
    JET_DBID jdbid;
    JET_TABLEID jtid;
    JET_COLUMNLIST jcl;
    JET_RETRIEVECOLUMN ajrc[2];
    char achColName[50];
    JET_COLUMNID jci;
    ATTCACHE *pac;
    ATTRTYP aid;
    ULONG i, times;
    ULONG err;
    ULONG colCount;
    HASHCACHE *ahcId;
    HASHCACHE *ahcCol;
    SCHEMAPTR *pSch;
    ULONG CLSCOUNT;
    ULONG ATTCOUNT;
    ULONG PREFIXCOUNT;
    extern BOOL gfRunningAsMkdit;

    // New schema struct for this thread

    if (SCCalloc(&pTHS->CurrSchemaPtr, 1, sizeof(SCHEMAPTR))) {
        return ERROR_DS_CANT_CACHE_ATT;
    }
    pSch = pTHS->CurrSchemaPtr;

    // Initial hash table sizes
    if (CurrSchemaPtr) {
        // Use values from previous cache load as a starting point
        ATTCOUNT = CurrSchemaPtr->nAttInDB;
        CLSCOUNT = CurrSchemaPtr->nClsInDB;
        PREFIXCOUNT = START_PREFIXCOUNT;
        while ( (2*(CurrSchemaPtr->PrefixTable.PrefixCount + 25)) > PREFIXCOUNT) {
            PREFIXCOUNT += START_PREFIXCOUNT;
        }
    } else {
        // First time through, use the defaults
        ATTCOUNT    = START_ATTCOUNT;
        CLSCOUNT    = START_CLSCOUNT;
        PREFIXCOUNT = START_PREFIXCOUNT;

        CurrSchemaPtr = pSch;

        // Adjust RefCount, since when this thread was created
        // CurrSchemaPtr was null, so InitTHSTATE didn't increase
        // any refcounts (but free_thread_state will decrement it,
        // since now the schema ptr is non-null)

        InterlockedIncrement(&(pSch->RefCount));
    }

    pSch->PREFIXCOUNT  = PREFIXCOUNT;
    pSch->sysTime = DBTime();

    // Allocate the prefix table and hash tables
    if (SCCalloc(&pSch->PrefixTable.pPrefixEntry, pSch->PREFIXCOUNT, sizeof(PrefixTableEntry))
        || InitPrefixTable(pSch->PrefixTable.pPrefixEntry, pSch->PREFIXCOUNT)
        || SCCalloc(&pSch->pPartialAttrVec, 1, PartialAttrVecV1SizeFromLen(DEFAULT_PARTIAL_ATTR_COUNT))
        || SCResizeAttHash(pTHS, ATTCOUNT)
        || SCResizeClsHash(pTHS, CLSCOUNT)) {
        return ERROR_DS_CANT_CACHE_ATT;
    }

    // Finish initializing the PAS table
    pSch->cPartialAttrVec = DEFAULT_PARTIAL_ATTR_COUNT;
    pSch->pPartialAttrVec->dwVersion = VERSION_V1;

    // Pick up the newly allocated hash tables and actual sizes (may
    // differ from the amounts requested)
    ATTCOUNT    = pSch->ATTCOUNT;
    CLSCOUNT    = pSch->CLSCOUNT;
    ahcId       = pSch->ahcId;
    ahcCol      = pSch->ahcCol;

    //
    // Scan the columns and extract the attribute's attid from
    // the column name. Use this info to fill in skeleton cache
    // entries in the hash tables for attributes. The skeletons
    // are needed to query the schemaNC for the actual classSchema
    // and attributeSchema objects used to fill in the rest
    // of the schema cache.
    //

    // Quiz JET to find a table that describes the columns
    jsid = pTHS->JetCache.sesid;
    jdbid = pTHS->JetCache.dbid;

    // Do this in a critical section to avoid getting the columns
    // when columns are being added/deleted by SCUpdate
    EnterCriticalSection(&csJetColumnUpdate);
    __try {
      je = JetGetColumnInfo(jsid, jdbid, SZDATATABLE, 0, &jcl,
                            sizeof(jcl), JET_ColInfoList);
    }
    __finally {
      LeaveCriticalSection(&csJetColumnUpdate);
    }
    if (je) {
        return(je);
    }

    // Ok, now walk the table and extract info for each column.  Whenever
    // we find a column that looks like an attribute (name starts with ATT)
    // allocate an attcache structure and fill in the jet col and the att
    // id (computed from the column name).
    memset(ajrc, 0, sizeof(ajrc));
    ajrc[0].columnid = jcl.columnidcolumnid;
    ajrc[0].pvData = &jci;
    ajrc[0].cbData = sizeof(jci);
    ajrc[0].itagSequence = 1;
    ajrc[1].columnid = jcl.columnidcolumnname;
    ajrc[1].pvData = achColName;
 