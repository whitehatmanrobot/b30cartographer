HUNKED_SZ, CHUNKED_LEN))
        {

            SetHaveChunkEncoding(TRUE);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("server is sending Chunked Transfer Encoding\n"
                        ));

            //
            // if both "transfer-encoding: chunked" and "content-length:"
            // were received then the chunking takes precedence
            //

            INET_ASSERT(!(IsChunkEncoding() && IsContentLength()));

            if (IsContentLength()) {
                SetHaveContentLength(FALSE);
            }

        }
    }

    SetBadNSServer(FALSE);

    if (IsResponseHttp1_1())
    {

        //
        // For IIS 4.0 Servers, and all other normal servers, if we make
        //  a HEAD request, we should ignore the Content-Length.
        //
        // IIS 3.0 servers send an illegal body, and this is a bug in the server.
        //  since they're not HTTP 1.1 we should be ok here.
        //

        if ( (GetMethodType() == HTTP_METHOD_TYPE_HEAD) &&
             (_ContentLength > 0) &&
             IsWantKeepAlive()
             )
        {

            //
            // set length to 0
            //

            _ContentLength = 0;

        }

        if ( IsRequestHttp1_1() )
        {


            //
            // check for NS servers that don't return correct HTTP/1.1 responses
            //

            LPSTR buffer;
            DWORD buflen;
            DWORD status = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                                   (LPVOID*)&buffer,
                                                   &buflen,
                                                   0
                                                   );

    #define NSEP    "Netscape-Enterprise/3"
    #define NSEPLEN (sizeof(NSEP) - 1)
    #define NSFT    "Netscape-FastTrack/3"
    #define NSFTLEN (sizeof(NSFT) - 1)
    #define NSCS    "Netscape-Commerce/3"
    #define NSCSLEN (sizeof(NSCS) - 1)

            if (status == ERROR_SUCCESS) {

                BOOL fIsBadServer = ((buflen > NSEPLEN) && !strnicmp(buffer, NSEP, NSEPLEN))
                                 || ((buflen > NSFTLEN) && !strnicmp(buffer, NSFT, NSFTLEN))
                                 || ((buflen > NSCSLEN) && !strnicmp(buffer, NSCS, NSCSLEN));

                if ( fIsBadServer )
                {
                    CServerInfo * pServerInfo = GetServerInfo();

                    SetBadNSServer(fIsBadServer);

                    if (pServerInfo != NULL)
                    {
                        //
                        // Note this Bad Server info in the server info obj,
                        //   as we they fail to do keep-alive with SSL properly
                        //

                        pServerInfo->SetBadNSServer();
                    }


                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("IsBadNSServer() == %B\n",
                                IsBadNSServer()
                                ));
                }
            }
        }

        //
        // BUGBUG - content-type: multipart/byteranges means we
        //          also have data
        //

        DWORD statusCode = GetStatusCode();

        if (!IsBadNSServer()
            && !IsContentLength()
            && !IsChunkEncoding()
            && (((statusCode >= HTTP_STATUS_CONTINUE)               // 100
                && (statusCode < HTTP_STATUS_OK))                   // 200
                || (statusCode == HTTP_STATUS_NO_CONTENT)           // 204
                || (statusCode == HTTP_STATUS_MOVED)                // 301
                || (statusCode == HTTP_STATUS_REDIRECT)             // 302
                || (statusCode == HTTP_STATUS_REDIRECT_METHOD)      // 303
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)         // 304
                || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB))  // 307
            || (GetMethodType() == HTTP_METHOD_TYPE_HEAD)) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("header-only HTTP/1.1 response\n"
                        ));

            SetData(FALSE);
        }
    }

    DEBUG_LEAVE(0);
}


//
// this array has the same order as the HTTP_METHOD_TYPE enum
//

#define MAKE_REQUEST_METHOD_TYPE(Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## Type

//
// darrenmi - need a new macro because *_M-POST isn't a valid enum member.
// we need a seperate enum type and string value.
//
// map HTTP_METHOD_TYPE_MPOST <=> "M-POST"
//

#define MAKE_REQUEST_METHOD_TYPE2(EnumType,Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## EnumType

static const struct _REQUEST_METHOD {
    int Length;
    LPSTR Name;
    HTTP_METHOD_TYPE MethodType;
} MethodNames[] = {
    MAKE_REQUEST_METHOD_TYPE(GET),
    MAKE_REQUEST_METHOD_TYPE(HEAD),
    MAKE_REQUEST_METHOD_TYPE(POST),
    MAKE_REQUEST_METHOD_TYPE(PUT),
    MAKE_REQUEST_METHOD_TYPE(PROPFIND),
    MAKE_REQUEST_METHOD_TYPE(PROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(LOCK),
    MAKE_REQUEST_METHOD_TYPE(UNLOCK),
    MAKE_REQUEST_METHOD_TYPE(COPY),
    MAKE_REQUEST_METHOD_TYPE(MOVE),
    MAKE_REQUEST_METHOD_TYPE(MKCOL),
    MAKE_REQUEST_METHOD_TYPE(CONNECT),
    MAKE_REQUEST_METHOD_TYPE(DELETE),
    MAKE_REQUEST_METHOD_TYPE(LINK),
    MAKE_REQUEST_METHOD_TYPE(UNLINK),
    MAKE_REQUEST_METHOD_TYPE(BMOVE),
    MAKE_REQUEST_METHOD_TYPE(BCOPY),
    MAKE_REQUEST_METHOD_TYPE(BPROPFIND),
    MAKE_REQUEST_METHOD_TYPE(BPROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(BDELETE),
    MAKE_REQUEST_METHOD_TYPE(SUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(UNSUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(NOTIFY),
    MAKE_REQUEST_METHOD_TYPE(POLL), 
    MAKE_REQUEST_METHOD_TYPE(CHECKIN),
    MAKE_REQUEST_METHOD_TYPE(CHECKOUT),
    MAKE_REQUEST_METHOD_TYPE(INVOKE),
    MAKE_REQUEST_METHOD_TYPE(SEARCH),
    MAKE_REQUEST_METHOD_TYPE(PIN),
    MAKE_REQUEST_METHOD_TYPE2(MPOST,M-POST)
};


HTTP_METHOD_TYPE
MapHttpRequestMethod(
    IN LPCSTR lpszVerb
    )

/*++

Routine Description:

    Maps request method string to type. Method names *are* case-sensitive

Arguments:

    lpszVerb    - method (verb) string

Return Value:

    HTTP_METHOD_TYPE

--*/

{
    int verbLen = strlen(lpszVerb);

    for (int i = 0; i < ARRAY_ELEMENTS(MethodNames); ++i) {
        if ((MethodNames[i].Length == verbLen)
        && (memcmp(lpszVerb, MethodNames[i].Name, verbLen) == 0)) {
            return MethodNames[i].MethodType;
        }
    }

    //
    // we now hande HTTP_METHOD_TYPE_UNKNOWN
    //

    return HTTP_METHOD_TYPE_UNKNOWN;
}


DWORD
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod,
    OUT LPCSTR * lplpcszName
    )

/*++

Routine Description:

    Map a method type to the corresponding name and length

Arguments:

    tMethod     - to map

    lplpcszName - pointer to pointer to returned name

Return Value:

    DWORD
        Success - length of method name

        Failure - (DWORD)-1

--*/

{
    DWORD length;

    if ((tMethod >= HTTP_METHOD_TYPE_FIRST) && (tMethod <= HTTP_METHOD_TYPE_LAST)) {
        *lplpcszName = MethodNames[tMethod].Name;
        length = MethodNames[tMethod].Length;
    } else {
        length = (DWORD)-1;
    }
    return length;
}

#if INET_DEBUG

LPSTR
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod
    )
{
    return (tMethod == HTTP_METHOD_TYPE_UNKNOWN)
        ? "Unknown"
        : MethodNames[tMethod].Name;
}

#endif

//
//DWORD
//CreateEscapedUrlPath(
//    IN LPSTR lpszUrlPath,
//    OUT LPSTR * lplpszEncodedUrlPath
//    )
//
///*++
//
//Routine Description:
//
//    Given an URL-path, encodes it into a new buffer
//
//Arguments:
//
//    lpszUrlPath             - URL-path to encode
//
//    lplpszEncodedUrlPath    - pointer to returned allocated buffer containing
//                              escaped URL-path
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    LPSTR lpszEncodedUrlPath = NULL;
//    DWORD urlPathLength;
//    DWORD encodedUrlPathLength;
//    DWORD error;
//
//    //
//    // we need to encode the URL-path into a separate buffer (it may grow)
//    //
//
//    urlPathLength = strlen(lpszUrlPath);
//    encodedUrlPathLength = INTERNET_MAX_PATH_LENGTH;
//
//    do {
//
//        //
//        // we allow ourselves to fail due to insufficient buffer (at least once)
//        //
//
//        lpszEncodedUrlPath = (LPSTR)ResizeBuffer(lpszEncodedUrlPath,
//                                                 encodedUrlPathLength,
//                                                 FALSE
//                                                 );
//        if (lpszEncodedUrlPath != NULL) {
//
//            DWORD previousLength = encodedUrlPathLength;
//
//            error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
//
//                                  //
//                                  // BUGBUG - assuming HTTP
//                                  //
//
//                                  SCHEME_HTTP,
//                                  lpszUrlPath,
//                                  urlPathLength,
//                                  lpszEncodedUrlPath,
//                                  &encodedUrlPathLength
//                                  );
//
//            if ((error == ERROR_INSUFFICIENT_BUFFER)
//            && (previousLength >= encodedUrlPathLength)) {
//
//                //
//                // this should never happen, but we will avoid a loop if it does
//                //
//
//                INET_ASSERT(FALSE);
//
//                error = ERROR_INTERNET_INTERNAL_ERROR;
//            }
//        } else {
//
//            //
//            // failed to (re)alloc
//            //
//
//            error = ERROR_NOT_ENOUGH_MEMORY;
//        }
//    } while (error == ERROR_INSUFFICIENT_BUFFER);
//
//    *lplpszEncodedUrlPath = lpszEncodedUrlPath;
//
//    return error;
//}

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    )
{
    DWORD i;
    for (i=0; i < cListLen; ++i) {
       if (!lpHeader->Strnicmp(lpBase, lplpList[i], strlen(lplpList[i]))) {
          return (TRUE);
       }
    }
    return(FALSE);
}

#ifdef COMPRESSED_HEADERS
DWORD
LookupHeadermap(
    LPSTR   lpszHeader
)
{
    DWORD   top, mid, bottom, ret = 0;
    int cmp;
    LPSTR lpszColon;

    lpszColon = strchr(lpszHeader, ':');

    if (!lpszColon || (lpszColon == lpszHeader)) {
        return(ret);
    }

    // yuk
    *lpszColon = 0;

    top = 1;

    bottom = sizeof(rgsHeaderMap)/sizeof(HEADER_MAP);

    INET_ASSERT(bottom >= top);

    do {

        mid = (bottom+top)/2;
        if (!(cmp = stricmp(   rgsHeaderMap[mid].lpszLongHeader,
                                lpszHeader
                                ))) {
            // we found a matching header,
            ret = mid;
            break;
        }

        if (cmp > 0) {
            // the mid header is larger than the passed in header
            // so we must check at the upper end of the sorted array of headers
            bottom = mid-1;
        }
        else {
            // the mid header is smaller than the passed in header
            // so we must check at the lower end of the sorted array of headers
            top = mid+1;
        }
    } while (bottom >= top);

    *lpszColon = ':';
    return (ret);
}
#endif //COMPRESSED_HEADERS


//
// HTTP_HEADER_PARSER implementation
//

HTTP_HEADER_PARSER::HTTP_HEADER_PARSER(
    IN LPSTR szHeaders,
    IN DWORD cbHeaders
    ) : HTTP_HEADERS()

/*++

Routine Description:

    Constructor for the HTTP_HEADER_PARSER object.  Calls ParseHeaders to
      build a parsed version of the header string passed in.

Arguments:

    szHeaders      - pointer to the headers to parse

    cbHeaders      - length of the headers

Return Value:

    None.

--*/

{
    DWORD dwBytesScaned = 0;
    BOOL fFoundCompleteLine;
    BOOL fFoundEndOfHeaders;
    DWORD error;

    error = ParseHeaders(
        szHeaders,
        cbHeaders,
        TRUE, // Eof
        &dwBytesScaned,
        &fFoundCompleteLine,
        &fFoundEndOfHeaders
        );

    INET_ASSERT(error == ERROR_SUCCESS);
    INET_ASSERT(fFoundCompleteLine);
    INET_ASSERT(fFoundEndOfHeaders);
}


/*  //  some test cases which can be used to test ParseStatusLine()
char bad1[] = "HTTP1.1 200 Description yeah yeah\r\n";
char bad2[] = "HTTP/1234.1 200 Description yeah yeah\r\n";
char bad3[] = "HTTP/1.1234 200 Description yeah yeah\r\n";
char bad4[] = "HTTP/1.1 1234 Description yeah yeah\r\n";
char bad5[] = "HTTP/    1.1 200 Description yeah yeah\r\n";
char bad6[] = "HTTP/1.1    200 Description yeah yeah\r\n";
char bad7[] = "HTTP/1.1 200Description yeah yeah\r\n";
char bad8[3000] = "HTTP/1.1 200 Description yeah yeah";
char bad9[] = "HTTP/1 1.1 200 Description yeah yeah\r\n";
char good1[] = "HTTP/   123.123   200 Description yeah yeah\r\n";
*/


DWORD
HTTP_HEADER_PARSER::ParseStatusLine(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT BOOL *lpfNeedMoreBuffer,
    OUT DWORD *lpdwStatusCode,
    OUT DWORD *lpdwMajorVersion,
    OUT DWORD *lpdwMinorVersion
    )

/*++

Routine Description:

    Parses the Status line of an HTTP server response.  Takes care of adding the status
     line to HTTP header array.

    From HTTP v1.1. spec:
    {
      Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
      HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
      Status-Code = 1*DIGIT
      Reason-Phrase = *<TEXT, excluding CR LF>
      (1*DIGIT means at least one digit, maybe more)
    }

    WinHTTP strictly enforces the status line spec.  The only exception is that up to 3
    spaces are allowed before the Status-Code and major version number.

    To prevent malicious servers from hogging the channel, the integers are limited to
    3 digits and the Reason-Phrase is limited to GlobalMaxSizeStatusLineResultText characters.

    "HTTP" could be other things like "S-HTTP", this is checked by UpdateFromHeaders()
    before ParseStatusLine() is called.  The existence of the first '/' is verified before
    ParseStatusLine is called.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    BOOL  - TRUE if line was successively parsed and processed, FALSE otherwise

--*/

{

#define BEFORE_VERSION_NUMBERS 0
#define MAJOR_VERSION_NUMBER   1
#define MINOR_VERSION_NUMBER   2
#define STATUS_CODE_NUMBER     3
#define AFTER_STATUS_CODE      4
#define MAX_STATUS_INTS        4

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    DWORD dwStatusLineLength = 0;
    LPSTR lpszStatusLine = NULL;
    int ver_state = BEFORE_VERSION_NUMBERS;
    BOOL afStatusIntsFound[MAX_STATUS_INTS] = {0};
    DWORD adwStatusInts[MAX_STATUS_INTS] = {0};
    DWORD dwStatusPieceLength = 0;
    BOOL error = ERROR_INTERNET_INTERNAL_ERROR;

    lpszStatusLine = response;

    //
    // While walking the Status Line looking for terminating \r\n,
    //   we extract the Major.Minor Versions and Status Code in that order.
    //   text and spaces will lie between/before/after the three numbers
    //   but the idea is to remeber which number we're calculating based on a numeric state
    //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
    //

    while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
    {
        switch (ver_state)
        {
            case BEFORE_VERSION_NUMBERS:
                //
                //  We've already matched the status line with something
                //of the form "****/" in UpdateFromHeaders(), we can ignore everything
                //through the first '/'.
                //
                if (*response == '/')
                {
                    INET_ASSERT(ver_state == BEFORE_VERSION_NUMBERS);
                    ver_state++; // = MAJOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int
                }

                break;

            case MAJOR_VERSION_NUMBER:

                if (*response == '.' && ver_state == MAJOR_VERSION_NUMBER)
                {
                    ver_state++; // = MINOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is an int
                    break;
                }
                // fall through

            case MINOR_VERSION_NUMBER:

                if (*response == ' ' && ver_state == MINOR_VERSION_NUMBER)
                {
                    ver_state++; // = STATUS_CODE_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int.
                    break;
                }
                // fall through

            case STATUS_CODE_NUMBER:

                if (isdigit(*response))
                {
                    if (!afStatusIntsFound[ver_state])
                    {
                        //  transitioning from counting spaces
                        //to counting integers
                        dwStatusPieceLength = 0;
                    }

                    //  Allow up to 3 digits per integer.
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                    
                    int val = *response - '0';
                    afStatusIntsFound[ver_state] = TRUE;
                    adwStatusInts[ver_state] = adwStatusInts[ver_state] * 10 + val;
                }
                else if ( adwStatusInts[STATUS_CODE_NUMBER] > 0 )
                {
                    INET_ASSERT(ver_state == STATUS_CODE_NUMBER);
                    if (*response != ' ')
                        goto doneInvalidStatusLine;
                    ver_state++; // = AFTER_STATUS_CODE
                    dwStatusPieceLength = 0;  // next piece is the status line
                    break;
                }
                else if (*response == ' ' && !afStatusIntsFound[ver_state])
                {
                    //
                    //  Before processing MAJOR_VERSION_NUMBER or STATUS_CODE_NUMBER,
                    //allow up to 3 spaces.
                    //
                    //  Multiple spaces are being allowed here because it is
                    //legacy behavior and may therefore be necessary, and being non-strict
                    //about it doesn't put anything at risk.
                    //
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                }
                else
                {
                    //  We fail if anything outside the spec is found, except
                    //for allowing multiple spaces before the status code.
                    goto doneInvalidStatusLine;
                }

                break;

            case AFTER_STATUS_CODE:
                //
                //  This will advance to the next CR or LF..
                //
                //  We limit Reason-Phrase length to protect against malicious socket hogging
                //

                if (++dwStatusPieceLength > GlobalMaxSizeStatusLineResultText)
                {
                    goto doneInvalidStatusLine;
                }
                break;

        }

        ++response;
        ++dwBytesScanned;
    }

    //
    //  Verify there is enough reponse left to check for a CRLF..
    //
    if (response == lpszEnd
        || response + 1 == lpszEnd)
    {
        //
        //
        //  If we're at the end of the connection then the server sent us an
        //incorrectly formatted response, Invalid status line.
        //
        //  If more data may come, indicate to retry it.
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response in status line\n"
                    ));

        if (fEof)
            goto doneInvalidStatusLine;
        else
            goto doneNeedMoreData;
    }

    dwStatusLineLength = dwBytesScanned;

    //
    //  And to finish, verify the CRLF...
    //

    //CR
    // some servers may not send the CR so give them a pass for compatibility
    if ( *response == '\r')
    {
        ++response;  //  we know its safe to step since we checked if (respone == lpszEnd) above.
        ++dwBytesScanned;
    }

    //LF
    if ( *response != '\n')
        goto doneInvalidStatusLine;
    ++response;  //  we know its safe to step again since we checked if (respone+1 == lpszEnd) above.
    ++dwBytesScanned;

    //
    //  Some validation checking
    //
    //  All three status ints must have been found.
    //  I found some code that assumes that if the Status Code == 0, then
    //the status line hasn't been parsed yet.  To be sure this assumption
    //remains true, explicitly reject status lines with a 0 status code.
    //
    if (afStatusIntsFound[MAJOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[MINOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[STATUS_CODE_NUMBER] != TRUE
        || adwStatusInts[STATUS_CODE_NUMBER] == 0)
    {
        goto doneInvalidStatusLine;
    }

    //
    // Now we have our parsed header to add to the array
    //

    HEADER_STRING * freeHeader;
    DWORD iSlot;

    freeHeader = FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        goto doneFailError;
    } else {
        INET_ASSERT(iSlot == 0); // status line should always be first
        freeHeader->CreateOffsetString((DWORD)(lpszStatusLine - lpHeaderBase), dwStatusLineLength);
        freeHeader->SetHash(0); // status line has no hash value.
    }

    //
    //  Success..  fill in the output params appropriately.
    //
    
    *lpfNeedMoreBuffer = FALSE;
    *lpdwStatusCode    = adwStatusInts[STATUS_CODE_NUMBER];
    *lpdwMajorVersion  = adwStatusInts[MAJOR_VERSION_NUMBER];
    *lpdwMinorVersion  = adwStatusInts[MINOR_VERSION_NUMBER];

    *lpdwBufferLengthScanned += dwBytesScanned;

    error = ERROR_SUCCESS;
    goto exitFinalReturn;

doneNeedMoreData:
    error = ERROR_SUCCESS;
    *lpfNeedMoreBuffer = TRUE;
    goto exitFinalReturn;

doneInvalidStatusLine:
    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

doneFailError:
    error = ERROR_INTERNET_INTERNAL_ERROR;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

exitFinalReturn:
    return error;
}

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Loads headers into HTTP_HEADERS member for subsequent parsing.

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.

    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

    do
    {
        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;

        //
        // Remove leading whitespace from header
        //

        while ( (response < lpszEnd) && ((*response == ' ') || (*response == '\t')) )
        {
            ++response;
            ++dwBytesScanned;
        }

        //
        // Scan for HeaderName:
        //

        lpszHeaderName = response;
        dwPreviousAmountOfBytesScanned = dwBytesScanned;

        while ((response < lpszEnd) && (*response != ':') && (*response != '\r') && (*response != '\n'))
        {
            //
            // This code incapsulates CalculateHashNoCase as an optimization,
            //   we attempt to calculate the Hash value as we parse the header.
            //

            CHAR ch = *response;

            if ((ch >= 'A') && (ch <= 'Z')) {
                ch = MAKE_LOWER(ch);
            }
            dwHash += (DWORD)(dwHash << 5) + ch;

            ++response;
            ++dwBytesScanned;
        }

        dwHeaderNameLength = (DWORD) (response - lpszHeaderName);

        //
        // catch bogus responses: if we find what looks like one of a (very)
        // small set of HTML tags, then assume the previous header was the
        // last
        //

        if ((dwHeaderNameLength >= sizeof("<HTML>") - 1)
            && (*lpszHeaderName == '<')
            && (!strnicmp(lpszHeaderName, "<HTML>", sizeof("<HTML>") - 1)
                || !strnicmp(lpszHeaderName, "<HEAD>", sizeof("<HEAD>") - 1))) {
            *pfFoundEndOfHeaders  = TRUE;
            break;
        }

        //
        // Keep scanning till end of the line.
        //

        while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
        {
            ++response;
            ++dwBytesScanned;
        }

        dwHeaderLineLength = (DWORD) (response - lpszHeaderName); // note: this headerLINElength

        if (response == lpszEnd) {

            //
            // response now points one past the end of the buffer. We may be looking
            // over the edge...
            //
            // if we're at the end of the connection then the server sent us an
            // incorrectly formatted response. Probably an error.
            //
            // Otherwise its a partial response. We need more
            //


            DEBUG_PRINT(HTTP,
                        INFO,
                        ("found end of short response\n"
                        ));

            success = fEof ? TRUE : FALSE;

            //
            // if we really hit the end of the response then update the amount of
            // headers scanned
            //

            if (!success) {
                dwBytesScanned = dwPreviousAmountOfBytesScanned;
            }

            break;

        }
        else
        {

            //
            // we reached a CR or LF. This is the end of this current header. Find
            // the start of the next one
            //

            //
            // first, strip off any trailing spaces from the current header. We do
            // this by simply reducing the string length. We only look for space
            // and tab characters. Only do this if we have a non-zero length header
            //

            if (dwHeaderLineLength != 0) {
                for (int i = -1; response[i] == ' ' || response[i] == '\t'; --i) {
                    --dwHeaderLineLength;
                }
            }

            INET_ASSERT((int)dwHeaderLineLength >= 0);

            //
            // some servers respond with "\r\r\n". Lame
            // A new twist: "\r \r\n". Lamer
            //

            while ((response < lpszEnd)
            && ((*response == '\r') || (*response == ' '))) {
                ++response;
                ++dwBytesScanned;
            }
            if (response == lpszEnd) {

                //
                // hit end of buffer without finding LF
                //

                success = FALSE;

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("hit end of buffer without finding LF\n"
                            ));

                //
                // get more data, reparse this line
                //

                dwBytesScanned = dwPreviousAmountOfBytesScanned;
                break;
            } else if (*response == '\n') {
                ++response;
                ++dwBytesScanned;

                //
                // if we found the empty line then we are done
                //

                if (dwHeaderLineLength == 0) {
                    *pfFoundEndOfHeaders  = TRUE;
                    break;
                }

                success = TRUE;
            }
        }

        //
        // Now we have our parsed header to add to the array
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;

        } else {
            freeHeader->CreateOffsetString((DWORD) (lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
            freeHeader->SetHash(dwHash);
        }


        //CHAR szTemp[256];
        //
        //memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
        //lpszHeaderName[dwHeaderLineLength] = '\0';

        //DEBUG_PRINT(HTTP,
        //    INFO,
        //    ("ParseHeaders: adding=%q\n", lpszHeaderName
        //    ));


        //
        // Now see if this is a known header we are adding, if so then we note that fact
        //

        DWORD dwKnownQueryIndex;

        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
        }
    } while (TRUE);

quit:

    *lpdwBufferLengthScanned += dwBytesScanned;
    *pfFoundCompleteLine = success;

    return error;
}

#if 0
//
// Slower version of the function above used for performance work!!! Keep around
//   until we're sure it will never be used.
//

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.


    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

#define HTTP_HEADER_PARSE_LEADING_SPACE 0
#define HTTP_HEADER_PARSE_NAME 1
#define HTTP_HEADER_PARSE_VALUE 2
#define HTTP_HEADER_PARSE_CR 3
#define HTTP_HEADER_PARSE_LF 4


    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;
    DWORD state = HTTP_HEADER_PARSE_LEADING_SPACE;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;
        DWORD dwWhiteSpace = 0;


        while ( (response < lpszEnd) )
        {
            switch (state)
            {

                case HTTP_HEADER_PARSE_LEADING_SPACE:

                    //
                    // Remove leading whitespace from header
                    //

                    if ( *response == ' ' ||
                         *response == '\t' )
                    {
                        break;
                    }

                    //
                    // Scan for HeaderName:
                    //

                    state = HTTP_HEADER_PARSE_NAME;
                    lpszHeaderName = response;
                    dwPreviousAmountOfBytesScanned = dwBytesScanned;

                    // fall through

                case HTTP_HEADER_PARSE_NAME:

                    switch (*response)
                    {
                        case ':':
                            //
                            // Now parse the Header Value
                            //

                            state = HTTP_HEADER_PARSE_VALUE;
                            dwHeaderNameLength = (DWORD) (response - lpszHeaderName);
                            break;


                        case '\r':
                            state = HTTP_HEADER_PARSE_CR;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName);
                            break;

                        case '\n':

                            state = HTTP_HEADER_PARSE_LF;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName);
                            goto Got_LF;
                            //break;

                        default:
                        {
                            CHAR ch = *response;

                            if ((ch >= 'A') && (ch <= 'Z')) {
                                ch = MAKE_LOWER(ch);
                            }
                            dwHash += (DWORD)(dwHash << 5) + ch;

                            break;
                        }
                    }

                    break;

                case HTTP_HEADER_PARSE_VALUE:

                    switch ( *response )
                    {
                        case '\r':
                            state = HTTP_HEADER_PARSE_CR;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName) - dwWhiteSpace;
                            break;

                        case '\n':

                            state = HTTP_HEADER_PARSE_LF;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName) - dwWhiteSpace;
                            goto Got_LF;

                        case ' ':
                        case '\t':
                            // count whitespace at end of the line
                            dwWhiteSpace++;
                            break;

                        default:
                            dwWhiteSpace = 0;
                            break;
                    }

                    break;

                case HTTP_HEADER_PARSE_CR:

                    if (*response == ' ' ||
                        *response == '\r' )
                    {
                        break;
                    }

                    state = HTTP_HEADER_PARSE_LF;
                    // fall through

                case HTTP_HEADER_PARSE_LF:

Got_LF:

                    //
                    // if we found the empty line then we are done
                    //

                    success = TRUE;

                    if (dwHeaderLineLength == 0) {
                        ++dwBytesScanned;
                        ++response;
                        *pfFoundEndOfHeaders  = TRUE;
                        goto quit;
                    }


                    {
                        //
                        // Now we have our parsed header to add to the array
                        //

                        HEADER_STRING * freeHeader;
                        DWORD iSlot;

                        freeHeader = FindFreeSlot(&iSlot);
                        if (freeHeader == NULL) {
                            error = GetError();

                            INET_ASSERT(error != ERROR_SUCCESS);
                            goto quit;

                        } else {
                            freeHeader->CreateOffsetString((lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
                            freeHeader->SetHash(dwHash);
                        }

                        CHAR szTemp[256];

                        memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
                        szTemp[dwHeaderLineLength] = '\0';

                        DEBUG_PRINT(HTTP,
                            INFO,
                            ("ParseHeaders: adding=%q\n", lpszHeaderName
                            ));


                        //
                        // Now see if this is a known header we are adding, if so then we note that fact
                        //

                        DWORD dwKnownQueryIndex;

                        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
                        {
                            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
                        }
                    }

                    //
                    // Move on to our next header.
                    //

                    dwHash = HEADER_HASH_SEED;
                    dwHeaderNameLength = 0;
                    dwHeaderLineLength = 0;
                    dwPreviousAmountOfBytesScanned = dwBytesScanned;
                    dwWhiteSpace = 0;

                    state = HTTP_HEADER_PARSE_LEADING_SPACE;

                    break;

            } // switch (state)

            ++response;
            ++dwBytesScanned;

        } // while (response < lpszEnd)


        //
        // response now points one past the end of the buffer. We may be looking
        // over the edge...
        //
        // if we're at the end of the connection then the server sent us an
        // incorrectly formatted response. Probably an error.
        //
        // Otherwise its a partial response. We need more
        //


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response\n"
                    ));

        success = fEof ? TRUE : FALSE;

        //
        // if we really hit the end of the response then update the amount of
        // headers scanned
        //

        if (!success) {
            dwBytesScanned = dwPreviousAmountOfBytesScanned;
        }

quit:

  *lpdwBufferLengthScanned += dwBytesScanned;
  *pfFoundCompleteLine    = success;

  return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\headers.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    headers.h

Abstract:

    This file contains the well-known HTTP/MIME request/response headers.
    For each header, two manifests are defined. HTTP_*_SZ contains the header
    name, immediatly followed by a colon. HTTP_*_LEN is the strlen of the
    corresponding HTTP_*_SZ, which does not include the terminating '\0'.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#define CSTRLEN(str)  (sizeof(str)-1)

#ifndef _HEADERS_H_
#define _HEADERS_H_

struct KnownHeaderType {
    LPSTR Text;
    INT Length;
    DWORD Flags;
    DWORD HashVal;
};

#define MAX_HEADER_HASH_SIZE 153
#define HEADER_HASH_SEED 1291949


extern const BYTE GlobalHeaderHashs[];
extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
FASTCALL
CalculateHashNoCase(
    IN LPSTR lpszString,
    IN DWORD dwStringLength
    );


//
// Various other header defines for different HTTP headers.
//

#define HTTP_ACCEPT_RANGES_SZ           "Accept-Ranges:"
#define HTTP_ACCEPT_RANGES_LEN          CSTRLEN(HTTP_ACCEPT_RANGES_SZ)

#define HTTP_DATE_SZ                    "Date:"
#define HTTP_DATE_LEN                   (sizeof(HTTP_DATE_SZ) - 1)

#define HTTP_EXPIRES_SZ                 "Expires:"
#define HTTP_EXPIRES_LEN                (sizeof(HTTP_EXPIRES_SZ) - 1)


#define HTTP_CONTENT_DISPOSITION_SZ     "Content-Disposition:"
#define HTTP_CONTENT_DISPOSITION_LEN     (sizeof(HTTP_CONTENT_DISPOSITION_SZ) - 1)

#define HTTP_LAST_MODIFIED_SZ           "Last-Modified:"
#define HTTP_LAST_MODIFIED_LEN          (sizeof(HTTP_LAST_MODIFIED_SZ) - 1)

// nuke?
#define HTTP_UNLESS_MODIFIED_SINCE_SZ   "Unless-Modified-Since:"
#define HTTP_UNLESS_MODIFIED_SINCE_LEN  CSTRLEN(HTTP_UNLESS_MODIFIED_SINCE_SZ)

#define HTTP_SERVER_SZ                  "Server:"
#define HTTP_SERVER_LEN                 (sizeof(HTTP_SERVER_SZ) - 1)

#define HTTP_CONNECTION_SZ              "Connection:"
#define HTTP_CONNECTION_LEN             (sizeof(HTTP_CONNECTION_SZ) - 1)

#define HTTP_PROXY_CONNECTION_SZ        "Proxy-Connection:"
#define HTTP_PROXY_CONNECTION_LEN       (sizeof(HTTP_PROXY_CONNECTION_SZ) - 1)

#define HTTP_SET_COOKIE_SZ              "Set-Cookie:"
#define HTTP_SET_COOKIE_LEN             (sizeof(HTTP_SET_COOKIE_SZ)-1)

//
//  Miscellaneous header goodies.
//

#define CHUNKED_SZ                      "chunked"
#define CHUNKED_LEN                     (sizeof(CHUNKED_SZ) - 1)

#define KEEP_ALIVE_SZ                   "Keep-Alive"
#define KEEP_ALIVE_LEN                  (sizeof(KEEP_ALIVE_SZ) - 1)

#define CLOSE_SZ                        "Close"
#define CLOSE_LEN                       (sizeof(CLOSE_SZ) - 1)

#define BYTES_SZ                        "bytes"
#define BYTES_LEN                       CSTRLEN(BYTES_SZ)

#define HTTP_VIA_SZ                     "Via:"
#define HTTP_VIA_LEN                    (sizeof(HTTP_VIA_SZ) - 1)

#define HTTP_DATE_SIZE  40

// Cache control defines:

#define HTTP_CACHE_CONTROL_SZ           "Cache-Control:"
#define HTTP_CACHE_CONTROL_LEN          CSTRLEN(HTTP_CACHE_CONTROL_SZ)

#define HTTP_AGE_SZ                     "Age:"
#define HTTP_AGE_LEN                    (sizeof(HTTP_AGE_SZ)-1)

#define HTTP_VARY_SZ                    "Vary:"
#define HTTP_VARY_LEN                   (sizeof(HTTP_VARY_SZ)-1)

#define NO_CACHE_SZ                     "no-cache"
#define NO_CACHE_LEN                    (sizeof(NO_CACHE_SZ) -1)

#define NO_STORE_SZ                     "no-store"
#define NO_STORE_LEN                    (sizeof(NO_STORE_SZ) -1)

#define MUST_REVALIDATE_SZ              "must-revalidate"
#define MUST_REVALIDATE_LEN             (sizeof(MUST_REVALIDATE_SZ) -1)

#define MAX_AGE_SZ                      "max-age"
#define MAX_AGE_LEN                     (sizeof(MAX_AGE_SZ) -1)

#define PRIVATE_SZ                      "private"
#define PRIVATE_LEN                     (sizeof(PRIVATE_SZ) - 1)

#define POSTCHECK_SZ                    "post-check"
#define POSTCHECK_LEN                   (sizeof(POSTCHECK_SZ) -1)

#define PRECHECK_SZ                     "pre-check"
#define PRECHECK_LEN                    (sizeof(PRECHECK_SZ) -1)

#define FILENAME_SZ                     "filename"
#define FILENAME_LEN                    (sizeof(FILENAME_SZ) - 1)

#define USER_AGENT_SZ                   "user-agent"
#define USER_AGENT_LEN                  (sizeof(USER_AGENT_SZ) - 1)

#endif  // _HEADERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\hhead.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hhead.cxx

Abstract:

    This file contains autogenerated table values of a perfect hash function
    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp
    Contents:
      GlobalKnownHeaders
      GlobalHeaderHashs

Author:

   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]

Revision History:

--*/


#include <wininetp.h>
#include "httpp.h"

#ifdef HEADER_HASH_SEED
#if (HEADER_HASH_SEED != 1291949)
#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header
#endif
#else
#define HEADER_HASH_SEED 1291949
#endif

#ifdef MAX_HEADER_HASH_SIZE
#if (MAX_HEADER_HASH_SIZE != 153)
#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header
#endif
#else
#define MAX_HEADER_HASH_SIZE 153
#endif

#ifdef HTTP_QUERY_MAX
#if (HTTP_QUERY_MAX != 78)
#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp
#endif
#endif

//
// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.
// This array must be used with the same hash function used to generate it.
// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.
//   0-ed entries indicate error values
//

const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {
      0,   0,   0,  71,   0,   0, 
     53,   0,   0,   0,   0,   0, 
     40,  60,  72,   0,   0,   0, 
     64,  61,   0,  28,   4,   0, 
     76,  57,   0,  30,   0,   8, 
      0,  15,   0,   0,   0,   0, 
     24,   0,  66,  29,   0,   0, 
      0,   0,   0,   0,  13,  14, 
     16,  33,   0,   0,   0,  68, 
     41,   0,   7,   0,   0,   0, 
      0,   0,  32,  17,  51,  48, 
     67,  11,   0,   0,   5,   0, 
     65,   2,   0,   0,  35,   6, 
      0,   0,  31,  50,   0,   0, 
      0,  49,  78,  26,   0,   0, 
     42,   0,   0,  43,   0,  27, 
     69,   9,   1,   0,   0,  18, 
     10,  79,   0,   3,  47,  55, 
      0,  44,   0,  56,   0,  70, 
     54,  52,   0,   0,   0,   0, 
      0,   0,  36,  62,   0,   0, 
     45,   0,   0,  12,   0,  73, 
     77,   0,  63,   0,  59,   0, 
      0,   0,   0,  58,  38,   0, 
      0,   0,  39,  25,   0,  37, 
      0,  34,   0, 
   };

//
// GlobalKnownHeaders - array of HTTP request and response headers that we understand.
// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H
//

#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal

const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {
    HEADER_ENTRY("Mime-Version",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x179ED708),
    HEADER_ENTRY("Content-Type",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A50E357),
    HEADER_ENTRY("Content-Transfer-Encoding",  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x562B730E),
    HEADER_ENTRY("Content-Id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xE7ADCA82),
    HEADER_ENTRY("Content-Description",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9D4EB3D9),
    HEADER_ENTRY("Content-Length",             (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER), 0x4E02E517),
    HEADER_ENTRY("Content-Language",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA6681019),
    HEADER_ENTRY("Allow",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x297A46CC),
    HEADER_ENTRY("Public",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C5DD44C),
    HEADER_ENTRY("Date",                       (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xBB71C70B),
    HEADER_ENTRY("Expires",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC153144D),
    HEADER_ENTRY("Last-Modified",              (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x23617A4F),
    HEADER_ENTRY("Message-id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC9AE6FAC),
    HEADER_ENTRY("Uri",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D45D),
    HEADER_ENTRY("Derived-From",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x6AAF4091),
    HEADER_ENTRY("Cost",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB717626),
    HEADER_ENTRY("Link",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB764B5B),
    HEADER_ENTRY("Pragma",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C26E9A5),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_NUMBER, 0x0),
    HEADER_ENTRY("",                           0, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Connection",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x190A507D),
    HEADER_ENTRY("Accept",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x581B295D),
    HEADER_ENTRY("Accept-Charset",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC87564B4),
    HEADER_ENTRY("Accept-Encoding",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x81EEF031),
    HEADER_ENTRY("Accept-Language",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2827D6EE),
    HEADER_ENTRY("Authorization",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xEC768B9E),
    HEADER_ENTRY("Content-Encoding",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2F295C),
    HEADER_ENTRY("Forwarded",                  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x420550EB),
    HEADER_ENTRY("From",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB732781),
    HEADER_ENTRY("If-Modified-Since",          (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x88B69529),
    HEADER_ENTRY("Location",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8DD3A2C6),
    HEADER_ENTRY("Orig-Uri",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x47CCA2FB),
    HEADER_ENTRY("Referer",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7CFEFF98),
    HEADER_ENTRY("Retry-After",                (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xD2881822),
    HEADER_ENTRY("Server",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8244B644),
    HEADER_ENTRY("Title",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AD094CF),
    HEADER_ENTRY("User-Agent",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x968679A8),
    HEADER_ENTRY("WWW-Authenticate",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x21BED5E),
    HEADER_ENTRY("Proxy-Authenticate",         HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBE0F117B),
    HEADER_ENTRY("Accept-Ranges",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC3BF828A),
    HEADER_ENTRY("Set-Cookie",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC704A760),
    HEADER_ENTRY("Cookie",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x5DA54DC7),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Refresh",                    0, 0x7D05EAFC),
    HEADER_ENTRY("Content-Disposition",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDCB6FC4A),
    HEADER_ENTRY("Age",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF607DDA),
    HEADER_ENTRY("Cache-Control",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBBD3B86F),
    HEADER_ENTRY("Content-Base",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A469ED0),
    HEADER_ENTRY("Content-Location",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC201A76E),
    HEADER_ENTRY("Content-Md5",                HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDD672BFB),
    HEADER_ENTRY("Content-Range",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD43BEC42),
    HEADER_ENTRY("Etag",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB72A1CE),
    HEADER_ENTRY("Host",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB74340B),
    HEADER_ENTRY("If-Match",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x971A5776),
    HEADER_ENTRY("If-None-Match",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF6E9D3),
    HEADER_ENTRY("If-Range",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9774B8F6),
    HEADER_ENTRY("If-Unmodified-Since",        (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC946042C),
    HEADER_ENTRY("Max-Forwards",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x3C693EC8),
    HEADER_ENTRY("Proxy-Authorization",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x96A221ED),
    HEADER_ENTRY("Range",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AA7E69A),
    HEADER_ENTRY("Transfer-Encoding",          HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBD09B166),
    HEADER_ENTRY("Upgrade",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7DAF65B5),
    HEADER_ENTRY("Vary",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB7BA5AF),
    HEADER_ENTRY("Via",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D76D),
    HEADER_ENTRY("Warning",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xF56B7D23),
    HEADER_ENTRY("Expect",                     (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x62F2EDB6),
    HEADER_ENTRY("Proxy-Connection",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD79F12C),
    HEADER_ENTRY("Unless-Modified-Since",      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8E53B934),
    HEADER_ENTRY("Ms-Echo-Request",            0, 0xBB7AF4AF),
    HEADER_ENTRY("Ms-Echo-Reply",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA5326612),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Proxy-Support",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C4F7F99),
    HEADER_ENTRY("Authentication-Info",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xB03F47E6),
    HEADER_ENTRY("PassportURLs",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF7C676F),
    HEADER_ENTRY("PassportConfig",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7601C9BF),
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\httptime.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    httptime.cxx

Abstract:

    This file contains routines to get various timestamps from an http response
    header.

    We handle only the three standards-mandated date forms, since these are used by
    the vast majority of sites out there on the WWW. Handling additional date forms
    adds to the overhead of these functions, so unless a new form makes headway, we
    will keep these functions simple.

    Contents:
        FGetHttpExpiryTime
        FGetHttpLastModifiedTime
        FParseHttpDate
        FHttpDateTimeToFiletime
        FFileTimetoHttpDateTime
        HttpDateToSystemTime
        HttpTimeFromSystemTime
        (FInternalParseHttpDate)
        (MapDayMonthToDword)

Author:

    Shishir Pardikar (shishirp) 06-Jan-1996

Revision History:

    06-Jan-1996 rfirth
        Created this header

    12-Dec-1997 arthurbi
        Rewrote the date parser to reduce allocs, and other bad stuff.

--*/

#include <wininetp.h>
#include "httpp.h"
#include "httptime.h"

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/


/******************************** Local Functions ***************************/

BOOL
FHttpDateTimeToFiletime(
    LPCSTR pcszStr,      // input datetime string
    LPCSTR *rgszWkDay,   // day of week strings
    LPCSTR *rgszMon,     // month strings
    LPCSTR pcszSep,      // seperators
    UINT dateId,         // date format
    FILETIME *lpft       // output filetime in GMT
    );


BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    );


/****************************************************************************/






//+---------------------------------------------------------------------------
//
//  Function: FGetHttpExpiryTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpExpiryTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

//+---------------------------------------------------------------------------
//
//  Function: FGetHttpLastModifiedTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpLastModifiedTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_LAST_MODIFIED, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

DWORD
inline
MapDayMonthToDword(
    LPCSTR lpszDay
    )
/*++

Routine Description:

    Looks at the first three bytes of string to determine if we're looking
        at a Day of the Week, or Month, or "GMT" string.  Is inlined so that
        the compiler can optimize this code into the caller FInternalParseHttpDate.

Arguments:

    lpszDay - a string ptr to the first byte of the string in question.

Return Value:

    DWORD
    Success - The Correct date token, 0-6 for day of the week, 1-14 for month, etc

    Failure - DATE_TOKEN_ERROR

--*/

{
    switch ( MAKE_UPPER(*lpszDay) ) // make uppercase
    {
        case 'A':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'P':
                    return DATE_TOKEN_APRIL;
                case 'U':
                    return DATE_TOKEN_AUGUST;

            }
            return DATE_TOKEN_ERROR;

        case 'D':
            return DATE_TOKEN_DECEMBER;

        case 'F':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'R':
                    return DATE_TOKEN_FRIDAY;
                case 'E':
                    return DATE_TOKEN_FEBRUARY;
            }

            return DATE_TOKEN_ERROR;

        case 'G':
            return DATE_TOKEN_GMT;

        case 'M':

            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'O':
                    return DATE_TOKEN_MONDAY;
                case 'A':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'R':
                            return DATE_TOKEN_MARCH;
                        case 'Y':
                            return DATE_TOKEN_MAY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;            

        case 'N':
            return DATE_TOKEN_NOVEMBER;

        case 'J':

            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_JANUARY;

                case 'U':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'N':
                            return DATE_TOKEN_JUNE;
                        case 'L':
                            return DATE_TOKEN_JULY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;

        case 'O':
            return DATE_TOKEN_OCTOBER;

        case 'S':
            
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_SATURDAY;
                case 'U':
                    return DATE_TOKEN_SUNDAY;
                case 'E':
                    return DATE_TOKEN_SEPTEMBER;
            }

            return DATE_TOKEN_ERROR;


        case 'T':
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {    
                case 'U':
                    return DATE_TOKEN_TUESDAY;
                case 'H':
                    return DATE_TOKEN_THURSDAY;
            }

            return DATE_TOKEN_ERROR;

        case 'U':
            return DATE_TOKEN_GMT;
            
        case 'W':
            return DATE_TOKEN_WEDNESDAY;

    }

    return DATE_TOKEN_ERROR;
}

BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    )
/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME/SYSTEMTIME time format.  

    Important this a time-critical function and should only be changed 
     with the intention of optimizing or a critical need work item.

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.
            Must be NULL if not intended to be used !!!

    lpSysTime - Ptr to SYSTEMTIME struture. Used to return Systime if needed.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    int i = 0, iLastLettered = -1;
    BOOL fIsANSIDateFormat = FALSE;
    DWORD rgdwDateParseResults[MAX_DATE_ENTRIES];
    SYSTEMTIME  sSysTime;
    FILETIME    ftTime;
    BOOL fRet = TRUE;

    DEBUG_ENTER((DBG_HTTP,
                Bool,
                "FInternalParseHttpDate",
                "%x %.10q",
                lpft,
                lpInputBuffer
                ));

    //
    // Date Parsing v2 (1 more to go), and here is how it works... 
    //  We take a date string and churn through it once, converting
    //  integers to integers, Month,Day, and GMT strings into integers,
    //  and all is then placed IN order in a temp array. 
    //
    // At the completetion of the parse stage, we simple look at 
    //  the data, and then map the results into the correct 
    //  places in the SYSTIME structure.  Simple, No allocations, and
    //  No dirting the data.   
    //
    // The end of the function does something munging and pretting
    //  up of the results to handle the year 2000, and TZ offsets
    //  Note: do we need to fully handle TZs anymore?
    //

    memset(rgdwDateParseResults, 0, sizeof(rgdwDateParseResults));

    while ( *lpInputBuffer && i < MAX_DATE_ENTRIES)
    {
        if ( *lpInputBuffer >= '0' && *lpInputBuffer <= '9' )
        {
            //
            // we have a numerical entry, scan through it and convent to DWORD
            //

            rgdwDateParseResults[i] = 0;

            do {
                rgdwDateParseResults[i] *= BASE_DEC;
                rgdwDateParseResults[i] += (DWORD) (*lpInputBuffer - '0');
                lpInputBuffer++;
            } while ( *lpInputBuffer && *lpInputBuffer >= '0' && *lpInputBuffer <= '9' );

            i++; // next token
        }
        else if ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
             (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') )
        {
            //
            // we have a string, should be a day, month, or GMT
            //   lets skim to the end of the string
            //
            
            rgdwDateParseResults[i] = 
                MapDayMonthToDword(lpInputBuffer);

            iLastLettered = i;

            // We want to ignore the possibility of a time zone such as PST or EST in a non-standard
            // date format such as "Thu Dec 17 16:01:28 PST 1998" (Notice that the year is _after_ the time zone
            if ((rgdwDateParseResults[i] == DATE_TOKEN_ERROR) 
                && 
                !(fIsANSIDateFormat && (i==DATE_ANSI_INDEX_YEAR)))
            {
                fRet = FALSE;
#ifdef DEBUG
                dprintf("FInternalParseHttpDate: Invalid Date Format, could not parse %s\n", lpInputBuffer);
#endif
                
                goto quit;
            }

            //
            // At this point if we have a vaild string
            //  at this index, we know for sure that we're
            //  looking at a ANSI type DATE format.
            //

            if ( i == DATE_ANSI_INDEX_MONTH )
            {
                fIsANSIDateFormat = TRUE;
            }

            //
            // Read past the end of the current set of alpha characters,
            //  as MapDayMonthToDword only peeks at a few characters
            //

            do {
                lpInputBuffer++;
            } while ( *lpInputBuffer && 
                        ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
                          (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') ) );

            i++; // next token
        }
        else
        {
            //
            // For the generic case its either a space, comma, semi-colon, etc.
            //  the point is we really don't care, nor do we need to waste time
            //  worring about it (the orginal code did).   The point is we 
            //  care about the actual date information, So we just advance to the 
            //  next lexume.
            //

            lpInputBuffer++;        
        }
    }

    //
    // We're finished parsing the string, now take the parsed tokens
    //  and turn them to the actual structured information we care about.
    //  So we build lpSysTime from the Array, using a local if none is passed in.
    //

    if ( lpSysTime == NULL )
    {
        lpSysTime = &sSysTime;
    }

    lpSysTime->wDayOfWeek    = (WORD)rgdwDateParseResults[DATE_INDEX_DAY_OF_WEEK];
    lpSysTime->wMilliseconds =  0;

    if ( fIsANSIDateFormat )
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MONTH];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_SECS];
        if (iLastLettered != DATE_ANSI_INDEX_YEAR)
        {
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_YEAR];
        }
        else
        {
            // Warning! This is a hack to get around the toString/toGMTstring fiasco (where the timezone is
            // appended at the end. (See above)
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_INDEX_TZ];
         }
    }
    else
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_1123_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MONTH];
        lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_YEAR];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_1123_INDEX_SECS];
    }

    //
    // Normalize the year, 90 == 1990, handle the year 2000, 02 == 2002
    //  This is Year 2000 handling folks!!!  We get this wrong and 
    //  we all look bad. 
    //

    if (lpSysTime->wYear < 100) {
        lpSysTime->wYear += ((lpSysTime->wYear < 80) ? 2000 : 1900);
    }

    //
    // if we got misformed time, then plug in the current time
    // !lpszHrs || !lpszMins || !lpszSec
    //

    if ( i < 4) 
    {
        SYSTEMTIME  sCurSysTime;

        // this is a bad date; logging.
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));

        GetSystemTime(&sCurSysTime);

        if ( i < 2 )
        {
            //
            // If we really messed up the parsing, then
            //  just use the current time. 
            //

            *lpSysTime = sCurSysTime;
        }
        else
        {
            lpSysTime->wHour = sCurSysTime.wHour;
            lpSysTime->wMinute = sCurSysTime.wMinute;
            lpSysTime->wSecond = sCurSysTime.wSecond;
        }
    }


    if ((lpSysTime->wDay > 31)
    || (lpSysTime->wHour > 23)
    || (lpSysTime->wMinute > 59)
    || (lpSysTime->wSecond > 59)) 
    {
        fRet = FALSE;
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
        goto quit;
    }

    // Hack: we want the system time to be accurate. This is _suhlow_
    // The time passed in is in the local time zone; we have to convert this into GMT.
    
    if (iLastLettered==DATE_ANSI_INDEX_YEAR)
    {
        i--;
        
        FILETIME ft1, ft2;

        fRet = 
            SystemTimeToFileTime(lpSysTime, &ft1);

        if (fRet)
        {
            fRet = LocalFileTimeToFileTime(&ft1, &ft2);
            if (fRet)
            {
                fRet = FileTimeToSystemTime(&ft2, lpSysTime);
            }

        }
        
        if (!fRet)
        {
            DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
            goto quit;
        }
    }


    //
    // If FILETIME Ptr passed in/or we have an Offset to another Time Zone
    //   then convert to FILETIME for necessity/convenience
    //

    if ( lpft ||
         (i > DATE_INDEX_TZ &&
          rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT))
    {

        if ( lpft == NULL )
        {
            lpft = &ftTime;
        }

        fRet = 
            SystemTimeToFileTime(lpSysTime, lpft);

        if ( ! fRet )
        {
           DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
           goto quit;
        }

        if (i > DATE_INDEX_TZ &&
            rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT) 
        {
            // time zones are a very expensive operation, I want to know if this is a common case.
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*** Received a time zone: %d\n", (int) rgdwDateParseResults[DATE_INDEX_TZ]
                        ));

            //
            // if we received +/-nnnn as offset (hhmm), modify the output FILETIME
            //

            LONGLONG delta;
            BOOL negative;
            int offset;

            offset = (int) rgdwDateParseResults[DATE_INDEX_TZ];

            //
            // BUGBUG - some sites return +0000 instead of GMT. Presumably, this is
            //          an offset from GMT (== 0). What are the units? What are the
            //          boundaries (-12 hours to +12 hours? In seconds? (43200
            //          seconds in 12 hours, so can't be this)
            //

            //
            // BUGBUG - must handle negatives...and (-1 == GMT)
            //

            if (offset < 0) {
                negative = TRUE;
                offset = -offset;
            } else {
                negative = FALSE;
            }

            //
            // hours and minutes as 100nSec intervals
            //

            delta = (((offset / 100) * 60)
                    + (offset % 100)) * 60 * 10000000;
            if (negative) {
                delta = -delta;
            }
            AddLongLongToFT(lpft,delta);

            //
            // Chk to see if we Need to turn the offseted 
            //   FILETIME back into SYSTEMTIME.
            //

            if ( lpSysTime == &sSysTime )
            {
                fRet = FileTimeToSystemTime(lpft, lpSysTime);
            }
        }
    }

quit:

    DEBUG_LEAVE(fRet);

    return fRet;
}

PUBLIC 
BOOL 
FParseHttpDate(
    OUT FILETIME *lpft,
    IN  LPCSTR lpInputBuffer
    )

/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME time format.  

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    return FInternalParseHttpDate(
                lpft,                
                NULL, // SYSTEMTIME
                lpInputBuffer
                );
}



//+---------------------------------------------------------------------------
//
//  Function: FFileTimetoHttpDateTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    )
{
    SYSTEMTIME  sSysTime;

    INET_ASSERT (*lpdwSize >= HTTP_DATE_SIZE);

    if (FileTimeToSystemTime(lpft, &sSysTime)) {
        *lpdwSize = wsprintf(lpszBuff, cszHttpDateFmt
                , rgszWkDay[sSysTime.wDayOfWeek]
                , sSysTime.wDay
                , rgszMon[sSysTime.wMonth-1]
                , sSysTime.wYear
                , sSysTime.wHour
                , sSysTime.wMinute
                , sSysTime.wSecond);
        return (TRUE);
    }
    return (FALSE);
}


BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    Takes a HTTP time/date string of the format "Sat, 6 Jan 1996 21:22:04 GMT"
    and converts it to a SYSTEMTIME structure

Arguments:

    lpszHttpDate    - pointer to time string to convert

    lpSystemTime    - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string

--*/

{
    return FInternalParseHttpDate(
                NULL, // FILETIME               
                lpSystemTime, 
                (LPCSTR)lpszHttpDate
                );
}


INTERNETAPI_(BOOL) InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr;
    BOOL fResult = FALSE;
    FILETIME ft;
    
    if (   dwRFC != INTERNET_RFC1123_FORMAT
        || IsBadReadPtr (pst, sizeof(*pst))
        || IsBadWritePtr (lpszTime, cbTime)
        || !SystemTimeToFileTime(pst, &ft)
       )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    } 
    else if (cbTime < INTERNET_RFC1123_BUFSIZE)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        SYSTEMTIME st;
        
        if ((pst->wDay < 0)
            || (pst->wDay > 6))
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            FileTimeToSystemTime(&ft, &st);
            pst = &st;
        }

        wsprintf (lpszTime, cszHttpDateFmt,
            rgszWkDay[pst->wDayOfWeek],
            pst->wDay,
            rgszMon[pst->wMonth-1],
            pst->wYear,
            pst->wHour,
            pst->wMinute,
            pst->wSecond);
        fResult = TRUE;
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%q, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));
    BOOL fRet = FALSE;;
    DWORD dwErr;

    if (IsBadWritePtr (lpSysTime, sizeof(*lpSysTime)) ||
        IsBadStringPtr(lpcszTimeString, 0xffff))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fRet = FInternalParseHttpDate(NULL, lpSysTime, (LPCSTR)lpcszTimeString);
        if (!fRet)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    if (!fRet)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fRet);
    return (fRet);
}

INTERNETAPI_(BOOL) InternetTimeFromSystemTimeW(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPWSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer in bytes

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeW",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;
    DWORD ccSize;
    
    if (!(cbTime >= INTERNET_RFC1123_BUFSIZE*sizeof(WCHAR)))
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    if (!lpszTime)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpTime.psStr = (LPSTR)ALLOC_BYTES(cbTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpTime.dwAlloc = cbTime;
    
    fResult = InternetTimeFromSystemTimeA(pst, dwRFC, mpTime.psStr, cbTime);

    if (fResult)
    {
        ccSize = MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, NULL, 0);
        if (cbTime<=ccSize*sizeof(WCHAR))
        {
            fResult = FALSE;
            dwErr = ERROR_INSUFFICIENT_BUFFER;;
        }
        else
        {
            MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, lpszTime, cbTime/sizeof(WCHAR));
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetTimeToSystemTimeW(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeW",
                     "%wq, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;

    if (!lpcszTimeString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpcszTimeString, 0, mpTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpcszTimeString, mpTime);
    fResult = InternetTimeToSystemTimeA(mpTime.psStr, lpSysTime, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\proc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This file contains global procedure declarations for the HTTP API
    project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>

DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    );

BOOL FParseHttpDate(
    FILETIME *lpFt,
    LPCSTR lpcszDateStr
    );

BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    );

#if defined(__cplusplus)
}
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\prefetch.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    prefetch.cxx

Abstract:

    Functions and methods to support http random read access.

    Contents:
        AttemptReadFromFile
        SetStreamPointer
        SetLengthFromCache
        ReadLoop_Fsm
        WriteResponseBufferToCache
        WriteQueryBufferToCache
Author:

    Rajeev Dujari (rajeevd) March 1996

Revision History:

    Ahsan Kabir (akabir) November 1997
--*/

#include <wininetp.h>


#define READLOOP_BUFSIZE 2048



BOOL
HTTP_REQUEST_HANDLE_OBJECT::AttemptReadFromFile(

    LPVOID lpBuf,
    DWORD cbToRead,
    DWORD* pcbRead
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "INTERNET_CONNECT_HANDLE_OBJECT::AttemptReadFromFile",
                 "%#x, %d, %#x",
                 lpBuf,
                 cbToRead,
                 pcbRead
                 ));

    BOOL fSuccess;
    DWORD dwBytesToCopy = 0;

    if (!cbToRead)
    {
        *pcbRead = 0;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    if (IsCacheReadInProgress())
    {
        INET_ASSERT(_VirtualCacheFileSize == _RealCacheFileSize);

        // Entire read should be satisfied from cache.
        *pcbRead = cbToRead;
        if (ReadUrlCacheEntryStream
            (_hCacheStream, _dwCurrentStreamPosition, lpBuf, pcbRead, 0))
        {
            AdvanceReadPosition (*pcbRead);
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        else
        {
            *pcbRead = 0;
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    else if (IsCacheWriteInProgress())
    {

        // See if the read is completely within the file.
        if (!IsEndOfFile() && _dwCurrentStreamPosition + cbToRead > _VirtualCacheFileSize)
        {

            DEBUG_PRINT(HTTP, ERROR, ("AttemptRead Failed streampos=%d cbToRead=%d, _VitrualCacheFileSize=%d\n",
                            _dwCurrentStreamPosition, cbToRead, _VirtualCacheFileSize));

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        HANDLE hfRead;
        hfRead = GetDownloadFileReadHandle();
        if (hfRead == INVALID_HANDLE_VALUE) 
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        // Read the data from the file.
        SetFilePointer (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
        fSuccess = ReadFile (hfRead, lpBuf, cbToRead, pcbRead, NULL);
        if (!fSuccess)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        AdvanceReadPosition (*pcbRead);
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    else
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
}


// Called from InternetSetFilePointer
DWORD
HTTP_REQUEST_HANDLE_OBJECT::SetStreamPointer(
    LONG lDistanceToMove,
    DWORD dwMoveMethod
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    // Fail if data is not from cache or going to cache.
    if (!IsCacheReadInProgress() && !IsCacheWriteInProgress())
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto done;
    }

    // BUGBUG: we don't handle chunked transfer, new with http 1.1
    if (IsChunkEncoding())
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto done;
    }

    switch (dwMoveMethod)
    {

        case FILE_BEGIN:
            _dwCurrentStreamPosition = (DWORD) lDistanceToMove;
            break;

        case FILE_CURRENT:
            if (lDistanceToMove < 0
                && ((DWORD) -lDistanceToMove) > _dwCurrentStreamPosition)
            {
                dwErr = ERROR_NEGATIVE_SEEK;
            }
            else
            {
                _dwCurrentStreamPosition += lDistanceToMove;
            }
            break;

        case FILE_END:
            if (!IsContentLength())
                 dwErr = ERROR_INTERNET_INVALID_OPERATION;
            else if (lDistanceToMove < 0 && ((DWORD) -lDistanceToMove) > _ContentLength)
                dwErr = ERROR_NEGATIVE_SEEK;
            else
                _dwCurrentStreamPosition = _ContentLength + lDistanceToMove;
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
    }


done:

    if (dwErr == ERROR_SUCCESS)
    {
        if (IsKeepAlive() && IsContentLength())
            _BytesRemaining = _ContentLength - _dwCurrentStreamPosition;

        if (_VirtualCacheFileSize > _dwCurrentStreamPosition)
            SetAvailableDataLength (_VirtualCacheFileSize - _dwCurrentStreamPosition);
        else
            SetAvailableDataLength (0);

        return _dwCurrentStreamPosition;
    }
    else
    {
        SetLastError (dwErr);
        return (DWORD) -1L;
    }
}

DWORD
CFsm_ReadLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadLoop * stateMachine = (CFsm_ReadLoop *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
        case FSM_STATE_INIT:
        case FSM_STATE_CONTINUE:
            error = pRequest->ReadLoop_Fsm(stateMachine);
            break;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;
            Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);
            INET_ASSERT(FALSE);
            break;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadLoop_Fsm(
    IN CFsm_ReadLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadLoop & fsm = *Fsm;
    DWORD dwErr = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_CONTINUE)
    {
        goto receive_continue;
    }

    // Set the goal for reading from the socket.
    fsm.m_dwReadEnd = _dwCurrentStreamPosition +
        ((fsm.m_dwSocketFlags & SF_NO_WAIT)? 1 : fsm.m_cbReadIn);

    // If app is trying to read beyond eof, limit it.
    if (fsm.m_dwReadEnd > _ContentLength)
    {
        fsm.m_dwReadEnd = _ContentLength;
        fsm.m_cbReadIn = fsm.m_dwReadEnd - _dwCurrentStreamPosition;
    }
    
    // Flush any data in response buffer to download file.
    dwErr = WriteResponseBufferToCache();
    if (dwErr != ERROR_SUCCESS)
        goto done;

    // Flush any data in query buffer to download file.
    dwErr = WriteQueryBufferToCache();
    if (dwErr != ERROR_SUCCESS)
        goto done;

    // BUGBUG: what if HaveReadFileExData?

    // Allocate receive buffer.  We could optimize this to use
    // the client buffer or query buffer when available to avoid
    // reading from the file data that was just written.

    fsm.m_cbBuf = READLOOP_BUFSIZE;
    if (!(fsm.m_pBuf = (PVOID) new BYTE [fsm.m_cbBuf]))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    HANDLE hfRead;
    hfRead = GetDownloadFileReadHandle();
    if (hfRead == INVALID_HANDLE_VALUE) 
    {
        dwErr = GetLastError();
        DEBUG_PRINT(CACHE, ERROR, ("Cache: createfile failed error=%ld\n", dwErr));
        goto done;
    }
    
    while (1)
    {
        // Calculate amount of data available for next read.
        if (_VirtualCacheFileSize > _dwCurrentStreamPosition)
            SetAvailableDataLength  (_VirtualCacheFileSize - _dwCurrentStreamPosition);
        else
            SetAvailableDataLength (0);

        // Check if pending request can be satisfied from file.
        if (_EndOfFile || _VirtualCacheFileSize >= fsm.m_dwReadEnd)
        {
            INET_ASSERT (AvailableDataLength());

            if (fsm.m_pRead)
            {
                // The client wants us to fill the buffer.
                if (fsm.m_dwSocketFlags & SF_NO_WAIT)
                {
                    // If the app is greedy, give it all we've got.
                    if (fsm.m_cbReadIn > AvailableDataLength())
                        fsm.m_cbReadIn = AvailableDataLength();
                }
                else
                {
                    INET_ASSERT (fsm.m_cbReadIn <= AvailableDataLength());
                }
            }

            // Read the data from the file.
            LONG lRet;
            lRet = SetFilePointer
                (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
            INET_ASSERT ((DWORD) lRet == _dwCurrentStreamPosition);
            if (lRet == -1)
            {
                dwErr = GetLastError();
                goto done;
            }

            BOOL fRet;
            fRet = ReadFile
                (hfRead, fsm.m_pRead, fsm.m_cbReadIn, fsm.m_pcbReadOut, NULL);
            if (!fRet)
            {
                dwErr = GetLastError();
                goto done;
            }

            AdvanceReadPosition (*fsm.m_pcbReadOut);
            INET_ASSERT (dwErr == ERROR_SUCCESS);
            goto done;
        }

        INET_ASSERT (!_EndOfFile);
        INET_ASSERT (_Socket);

        fsm.m_cbRead = fsm.m_cbBuf;
        if (IsKeepAlive() && fsm.m_cbRead > _BytesInSocket)
            fsm.m_cbRead = _BytesInSocket;
        fsm.m_cbRecv = 0;

        // Get some more data from the socket.

        dwErr = _Socket->Receive
        (
            &fsm.m_pBuf,     // IN OUT LPVOID* lplpBuffer,
            &fsm.m_cbBuf,    // IN OUT LPDWORD lpdwBufferLength,
            &fsm.m_cbRead,   // IN OUT LPDWORD lpdwBufferRemaining,
            &fsm.m_cbRecv,   // IN OUT LPDWORD lpdwBytesReceived,
            0,               // IN DWORD dwExtraSpace,
            fsm.m_dwSocketFlags,     // IN DWORD dwFlags,
            &_EndOfFile  // OUT LPBOOL lpbEof
        );

        if (dwErr == ERROR_IO_PENDING)
        {
            if (fsm.m_dwSocketFlags & SF_NO_WAIT)
            {
                // InternetReadFileEx can set IRF_NO_WAIT.  If we must go async
                // in this case, morph the request into a QueryDataAvailable
                // and app will call again to get the data after notification.

                fsm.m_pRead = NULL;
                fsm.m_cbReadIn = 1;
                fsm.m_pcbReadOut = NULL;
            }
            goto done;
        }

receive_continue:

        if (dwErr != ERROR_SUCCESS)
        {
            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("error %d on socket %#x\n",
                        dwErr,
                        _Socket->GetSocket()));

            goto done;
        }

        // Append data to download file.
        dwErr = WriteCache ((PBYTE) fsm.m_pBuf, fsm.m_cbRecv);
        if (dwErr != ERROR_SUCCESS)
            goto done;

        // If content length is known, check for EOF.
        if (IsKeepAlive())
        {
            _BytesInSocket -= fsm.m_cbRecv;
            if (!_BytesInSocket)
                _EndOfFile = TRUE;
        }

        if (_EndOfFile)
        {
            // Set handle state.
            SetState(HttpRequestStateReopen);
            if (!IsKeepAlive())
                CloseConnection(FALSE);
            SetData(FALSE);
        }

    } // end while (1)

done:

    if (dwErr != ERROR_IO_PENDING)
    {
        delete [] fsm.m_pBuf;
        fsm.SetDone();

        if (dwErr != ERROR_SUCCESS)
        {
            DEBUG_PRINT(HTTP, ERROR, ("Readloop: Error = %d\n", dwErr));

            SetState(HttpRequestStateError);
            LocalEndCacheWrite(FALSE);
        }
    }

    DEBUG_LEAVE(dwErr);

    return dwErr;
}


// Called from ReadLoop to write data in response buffer to download file.
DWORD HTTP_REQUEST_HANDLE_OBJECT::WriteResponseBufferToCache (VOID)
{
    DWORD cbData = _BytesReceived - _DataOffset;
    if (!cbData)
        return ERROR_SUCCESS;
    DWORD dwErr = WriteCache
        (((LPBYTE) _ResponseBuffer) + _DataOffset, cbData);
    _DataOffset += cbData;

    DEBUG_PRINT(HTTP, ERROR, ("WriteResponseBufferToCache: Error = %d", dwErr));

    return dwErr;
}

// Called from ReadLoop to write data in query buffer to download file.
DWORD HTTP_REQUEST_HANDLE_OBJECT::WriteQueryBufferToCache (VOID)
{
    if (!_QueryBytesAvailable)
        return ERROR_SUCCESS;
    DWORD dwErr = WriteCache
        (((LPBYTE) _QueryBuffer) + _QueryOffset, _QueryBytesAvailable);
    _QueryOffset += _QueryBytesAvailable;
    _QueryBytesAvailable = 0;

    DEBUG_PRINT(HTTP, ERROR, ("WriteQueryBufferToCache: Error = %d", dwErr));

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\makeconn.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    makeconn.cxx

Abstract:

    This file contains the MakeConnection method

    Contents:
        CFsm_MakeConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_MakeConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_MakeConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_MakeConnection * stateMachine = (CFsm_MakeConnection *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->MakeConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm(
    IN CFsm_MakeConnection * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(MakeConnection_Fsm);

    CFsm_MakeConnection & fsm = *Fsm;
    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    if (state == FSM_STATE_INIT) {
        if (GetAuthState() == AUTHSTATE_NEEDTUNNEL) {
            state = FSM_STATE_1;
        } else if (IsTalkingToSecureServerViaProxy()) {
            state = FSM_STATE_3;
        } else {
            state = FSM_STATE_6;
        }
    } else {
        state = fsm.GetFunctionState();
    }
    switch (state) {
    case FSM_STATE_1:

        //
        // If we're attempting to do NTLM authentication using Proxy tunnelling
        // and we don't have a keep-alive socket to use, then create one
        //

        if (!(IsWantKeepAlive() && (_Socket != NULL) && _Socket->IsOpen())) {

            DEBUG_PRINT(
                HTTP,
                INFO,
                ("opening proxy tunnel for authentication on socket %#x", _Socket->GetSocket())
                );

            fsm.SetFunctionState(FSM_STATE_2);
            error = OpenProxyTunnel();
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
                goto quit;
            }
        } else {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_2:
        if ((error != ERROR_SUCCESS)
        || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        if (_Socket->IsSecure()) {
            /* SCLE ref */
            error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // Undo the proxy-ified info found in this Request Object, make it seem like
        //  we're doing a connect connection, since we're about to do something like it
        //  ( a tunnelled connection through the firewall )
        //

        error = SetServerInfo(INTERNET_SCHEME_HTTP, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LPSTR urlPath;
        DWORD urlPathLength;

        //
        // get URL-path again if it was changed during tunnel creation
        //

        error = CrackUrl(GetURL(),
                     lstrlen(GetURL()),
                     FALSE, // don't escape URL-path
                     NULL,  // don't care about scheme type
                     NULL,  // or scheme name
                     NULL,  // or scheme name length
                     NULL,  // or host name
                     NULL,  // or host name length
                     NULL,  // or port
                     NULL,  // or user name
                     NULL,  // or user name length
                     NULL,  // or password
                     NULL,  // or password length
                     &urlPath,
                     &urlPathLength,
                     NULL,  // don't care about extra
                     NULL,  // or extra length
                     NULL
                     );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LockHeaders();

        ModifyRequest(HTTP_METHOD_TYPE_GET,
                      urlPath,
                      urlPathLength,
                      NULL,
                      0
                      );

        UnlockHeaders();

        //SetProxyNTLMTunnelling(FALSE);
        SetRequestUsingProxy(FALSE);             // don't generate proxy stuff.
        break;

    case FSM_STATE_3:

        //
        // Hack for SSL2 Client Hello bug in IIS Servers.
        //  Need to ReOpen connection after failure with
        //  a Client Hello Message.
        //

        if (_Socket != NULL) {
            ((ICSecureSocket *)_Socket)->SetProviderIndex(0);
        }

attempt_ssl_connect:

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_4);
        error = OpenProxyTunnel();
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_4:
        if ((error != ERROR_SUCCESS) || (GetStatusCode() != HTTP_STATUS_OK)) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if the app wants a secure channel (PCT/SSL) then we must negotiate
        // the security here
        //

        //
        // dwProviderIndex will be managed by SecureHandshakeWithServer,
        // And will be set to 0 when we can't try anymore.
        //

        DWORD asyncFlags;

        //
        // find out if we're async. N.B. see Assumes
        //

        asyncFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;

        //
        // If we're Posting or sending data, make sure
        //  the SSL connection knows about it, for the
        //  purposes of generating errors.
        //

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
        || (GetMethodType() == HTTP_METHOD_TYPE_PUT)) {
            asyncFlags |= SF_SENDING_DATA;
        }

        fsm.SetFunctionState(FSM_STATE_5);
        error = ((ICSecureSocket *)_Socket)->SecureHandshakeWithServer(
                                                (asyncFlags | SF_ENCRYPT),
                                                &fsm.m_bAttemptReconnect);
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_5:
        if (error != ERROR_SUCCESS) {

            if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED)
            {
                if (_Socket->IsSecure())
                {
                    if(m_pSecurityInfo)
                    {
                        /* SCLE ref */
                        m_pSecurityInfo->Release();
                    }
                    /* SCLE ref */
                    m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                }
            }

            //
            // we disconnected the socket and we won't attempt to reconnect. We
            // need to release the connection to balance the connection limiter
            //

            if (!fsm.m_bAttemptReconnect) {
                ReleaseConnection(TRUE,     // bClose
                                  FALSE,    // bIndicate
                                  TRUE      // bDispose
                                  );
            }
            else
            {
                _Socket->SetLinger(FALSE, 0);
                _Socket->Disconnect(); // close socket.
            }
        }

        //
        // SSL2 hack for old IIS servers.
        //  We re-open the socket, and call again.
        //

        if (fsm.m_bAttemptReconnect) {
            goto attempt_ssl_connect;
        }
        break;

    case FSM_STATE_6:
        fsm.SetFunctionState(FSM_STATE_7);
        error = OpenConnection(FALSE, FALSE);
        if (error == ERROR_IO_PENDING) {
            break;
        }

    case FSM_STATE_7:
//dprintf("HTTP connect took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        //hack
        if (error == ERROR_SUCCESS &&
            _Socket &&
            _Socket->IsSecure() &&
            m_pSecurityInfo == NULL
            )
        {
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
        }
        break;

    default:

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
//        PERF_LEAVE(MakeConnection_Fsm);

    }
        PERF_LEAVE(MakeConnection_Fsm);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\open.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    open.cxx

Abstract:

    This file contains the implementation of the HttpOpenRequestA API.

    The following functions are exported by this module:

        HttpOpenRequestA
        HttpOpenRequestW
        ParseHttpUrl
        ParseHttpUrl_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpOpenRequestA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


BOOL IsInappropriateHTTPPort (INTERNET_PORT port)
/*++
Routine Description:
The following outgoing ports should be blocked for HTTP:
21 - FTP,25 - SMTP,110 - POP3,119 - NNTP,143 - IMAP
Arguments: Port number
Return Value: TRUE- Need to be blocked
			  FALSE-Not to be blocked
--*/
{
    if (port > INTERNET_MAX_WELL_KNOWN_PORT)
        return FALSE;
    switch (port) {
        case INTERNET_INVALID_PORT_NUMBER:
        case INTERNET_DEFAULT_FTP_PORT:
        case INTERNET_DEFAULT_SMTP_PORT:
        case INTERNET_DEFAULT_POP3_PORT:
        case INTERNET_DEFAULT_NNTP_PORT:
        case INTERNET_DEFAULT_IMAP_PORT:
            return TRUE;
        default:
            return FALSE;
    }
}



INTERNETAPI_(HINTERNET) HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hConnect            - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request. May be NULL in which
                          case "GET" will be used

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier. May be NULL in which case the empty
                          string will be used

    lpszVersion         - The version string for the request. May be NULL in
                          which case "HTTP/1.0" will be used

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    HINTERNET

        Success - non-NULL (open) handle to an HTTP request

        Failure - NULL. Error status is available by calling GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestA",
                     "%#x, %.80q, %.80q, %.80q, %.80q, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD error;
    HINTERNET hConnectMapped = NULL;
    BOOL fRequestUsingProxy;
    HINTERNET hRequest = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // find path from internet handle and validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters. Allow lpszVerb to default to "GET" if a NULL pointer
    // is supplied
    //

    if (!ARGUMENT_PRESENT(lpszVerb) || (*lpszVerb == '\0')) {
        lpszVerb = DEFAULT_HTTP_REQUEST_VERB;
    }

    //
    // if a NULL pointer or empty string is supplied for the object name, then
    // convert to the default object name (root object)
    //

    if (!ARGUMENT_PRESENT(lpszObjectName) || (*lpszObjectName == '\0')) {
        lpszObjectName = "/";
    }

    //
    // check the rest of the parameters
    //


    if (dwFlags & ~INTERNET_FLAGS_MASK) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // default to the current supported version
    //

    char versionBuffer[sizeof("HTTP/4294967295.4294967295")];
    DWORD verMajor;
    DWORD verMinor;

    if (!ARGUMENT_PRESENT(lpszVersion) || (*lpszVersion == '\0')) {
        wsprintf(versionBuffer,
                 "HTTP/%d.%d",
                 HttpVersionInfo.dwMajorVersion,
                 HttpVersionInfo.dwMinorVersion
                 );
        lpszVersion = versionBuffer;
        verMajor = HttpVersionInfo.dwMajorVersion;
        verMinor = HttpVersionInfo.dwMinorVersion;
    } else if (strnicmp(lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR p = (LPSTR)lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&p, 0, (LPINT)&verMajor);
        while (!isdigit(*p) && (*p != '\0')) {
            ++p;
        }
        ExtractInt(&p, 0, (LPINT)&verMinor);
    } else {
        verMajor = 1;
        verMinor = 0;
    }

    //
    // if we have HTTP 1.1 enabled in the registry and the version is < 1.1
    // then convert
    //

    if (GlobalEnableHttp1_1
    && (((verMajor == 1) && (verMinor == 0)) || (verMajor < 1))) {
        lpszVersion = "HTTP/1.1";
    }

    //
    // allow empty strings to be equivalent to NULL pointer
    //

    if (ARGUMENT_PRESENT(lpszReferrer) && (*lpszReferrer == '\0')) {
        lpszReferrer = NULL;
    }

    //
    // if the caller has specified CERN proxy access then we convert the
    // object request to the URL that the CERN proxy will use
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    INTERNET_HANDLE_OBJECT * pInternet;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;
    BOOL isProxy;
    INTERNET_SCHEME schemeType;
    BOOL bSchemeChanged;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;
    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    hostName = pConnect->GetHostName(&hostNameLength);
    hostPort = pConnect->GetHostPort();
    isProxy = pConnect->GetServerInfo()->IsCernProxy();
    schemeType = pConnect->GetSchemeType();

    // WinSe Bug 21109- Security: Block http access to ports: 21, 25, 110, 119 and 143
    if(schemeType == INTERNET_SCHEME_HTTP && IsInappropriateHTTPPort(hostPort))
    {
        error = ERROR_INTERNET_INVALID_URL;
        goto quit;
    }

    //
    // set the per-thread info: parent handle object and context value
    //

    _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // make local HTTP request handle object before we can add headers to it
    //

    error = RMakeHttpReqObjectHandle(hConnectMapped,
                                     &hRequest,
                                     NULL,  // (CLOSE_HANDLE_FUNC)wHttpCloseRequest
                                     dwFlags,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the scheme type changed and we are going via proxy, get the SERVER_INFO
    // for the new proxy (if we changed it). N.B. We ONLY change the proxy for
    // this request object, NOT for the connect object
    //

    //if (isProxy && bSchemeChanged) {
    //    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetServerInfo(schemeType);
    //}

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    //
    // add the request line
    //

    INET_ASSERT((lpszVerb != NULL) && (*lpszVerb != '\0'));
    INET_ASSERT((lpszObjectName != NULL) && (*lpszObjectName != '\0'));
    INET_ASSERT((lpszVersion != NULL) && (*lpszVersion != '\0'));

    pRequest->LockHeaders();

    //
    // encode the URL-path
    //

    error = pRequest->AddRequest((LPSTR)lpszVerb,
                                 (LPSTR)lpszObjectName,
                                 (LPSTR)lpszVersion
                                 );
    if (error != ERROR_SUCCESS) {
        pRequest->UnlockHeaders();
        goto quit;
    }

    //
    // set the method type from the verb
    //

    pRequest->SetMethodType(lpszVerb);

    //
    // add the headers
    //

    if (lpszReferrer != NULL) {
        error = pRequest->AddRequestHeader(HTTP_QUERY_REFERER,
                                           (LPSTR)lpszReferrer,
                                           lstrlen(lpszReferrer),
                                           0,
                                           CLEAN_HEADER
                                           );
        if (error != ERROR_SUCCESS) {
            pRequest->UnlockHeaders();
            goto quit;
        }
    }

    if (lplpszAcceptTypes != NULL) {
        while (*lplpszAcceptTypes) {
            error = pRequest->AddRequestHeader(HTTP_QUERY_ACCEPT,
                                               (LPSTR)*lplpszAcceptTypes,
                                               lstrlen(*(LPSTR*)lplpszAcceptTypes),
                                               0,
                                               CLEAN_HEADER | COALESCE_HEADER_WITH_COMMA
                                               );
            if (error != ERROR_SUCCESS) {
                pRequest->UnlockHeaders();
                goto quit;
            }
            ++lplpszAcceptTypes;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    pRequest->UnlockHeaders();

    //
    // change the object state to opened
    //

    pRequest->SetState(HttpRequestStateOpen);
    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetRequestUsingProxy(
                                                    FALSE
                                                    );

    switch (pRequest->GetMethodType()) {
    case HTTP_METHOD_TYPE_GET:
    case HTTP_METHOD_TYPE_POST:
        break;

    default:
        dwFlags |= (INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE);
        break;
    }

    switch (GlobalCacheMode)
    {
        case CACHEMODE_REFRESH:
            dwFlags |= INTERNET_FLAG_RESYNCHRONIZE;
            break;

        case CACHEMODE_BYPASS:
            dwFlags |= INTERNET_FLAG_RELOAD;
            break;
            
        case CACHEMODE_NORMAL:
        default:
            break;
    }

    pRequest->SetCacheFlags(dwFlags);

    //
    // if the object name is not set then all cache methods fail
    //

    URLGEN_FUNC fn;

    fn = (URLGEN_FUNC)pHttpGetUrlString;

    //
    // BUGBUG - change prototype to take LPCSTR
    //

    error = pRequest->SetObjectName((LPSTR)lpszObjectName,
                                    NULL,
                                    &fn
                                    );

    //
    // Record whether the original object was empty ("") or slash ("/")
    //

    if (lpszObjectName[0] == '/' &&
        lpszObjectName[1] == 0x00 ) {
        pRequest->SetObjectRoot();
    }

quit:

    _InternetDecNestingCount(1);

done:

    if (error != ERROR_SUCCESS) {
        if (hRequest != NULL) {
            InternetCloseHandle(((HANDLE_OBJECT *)hRequest)->GetPseudoHandle());
        }

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        hRequest = NULL;
    } else {

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hRequest = ((HANDLE_OBJECT *)hRequest)->GetPseudoHandle();
    }

    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(hRequest);

    return hRequest;
}


INTERNETAPI_(HINTERNET) HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hHttpSession        - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier

    lpszVersion         - The version string for the request

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    !NULL - An open handle to an HTTP request.

    NULL - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestW",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpVerb, mpObjectName, mpVersion, mpReferrer;
    MEMORYPACKETTABLE mptAcceptTypes;

    if (lpszVerb)
    {
        ALLOC_MB(lpszVerb,0,mpVerb);
        if (!mpVerb.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVerb,mpVerb);
    }
    if (lpszObjectName)
    {
        ALLOC_MB(lpszObjectName,0,mpObjectName);
        if (!mpObjectName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszObjectName,mpObjectName);
    }
    if (lpszVersion)
    {
        ALLOC_MB(lpszVersion,0,mpVersion);
        if (!mpVersion.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVersion,mpVersion);
    }
    if (lpszReferrer)
    {
        ALLOC_MB(lpszReferrer,0,mpReferrer);
        if (!mpReferrer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszReferrer,mpReferrer);
    }

    // Create a table of ansi strings
    if (lplpszAcceptTypes)
    {
        WORD csTmp=0;
        for (;lplpszAcceptTypes[csTmp];csTmp++);
        mptAcceptTypes.SetUpFor(csTmp);
        for (WORD ce=0; ce < csTmp; ce++)
        {
            mptAcceptTypes.pdwAlloc[ce] = (lstrlenW(lplpszAcceptTypes[ce]) + 1)*sizeof(WCHAR);
            mptAcceptTypes.ppsStr[ce] = (LPSTR)ALLOC_BYTES(mptAcceptTypes.pdwAlloc[ce]*sizeof(CHAR));
            if (!mptAcceptTypes.ppsStr[ce])
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            mptAcceptTypes.pdwSize[ce] = WideCharToMultiByte(CP_ACP,
                                                                0,
                                                                lplpszAcceptTypes[ce],
                                                                mptAcceptTypes.pdwAlloc[ce]/sizeof(WCHAR),
                                                                mptAcceptTypes.ppsStr[ce],
                                                                mptAcceptTypes.pdwAlloc[ce],NULL,NULL);
        }
    }

    hInternet = HttpOpenRequestA(hConnect, mpVerb.psStr, mpObjectName.psStr, mpVersion.psStr,
                               mpReferrer.psStr, (LPCSTR*)mptAcceptTypes.ppsStr,
                               dwFlags, dwContext);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET phInternet,
    IN LPSTR lpszUrl,
    IN DWORD dwSchemeLength,
    IN LPSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    URL parser for HTTP URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls HTTP APIs to
    do the work

Arguments:

    phInternet      - IN: InternetOpen() handle
                      OUT: if successful HttpOpenRequest(), else undefined

    lpszUrl         - pointer to string containing HTTP URL to open

    dwSchemeLength  - length of the URL scheme, exluding "://"

    lpszHeaders     - additional HTTP headers

    dwHeadersLength - length of Headers

    dwFlags         - optional flags for opening a file (cache/no-cache, etc.)

    dwContext       - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ParseHttpUrl",
                 "%#x [%#x], %q, %d, %.80q, %d, %08x, %08x",
                 phInternet,
                 *phInternet,
                 lpszUrl,
                 dwSchemeLength,
                 lpszHeaders,
                 dwHeadersLength,
                 dwFlags,
                 dwContext
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error = DoFsm(new CFsm_ParseHttpUrl(phInternet,
                                              lpszUrl,
                                              dwSchemeLength,
                                              lpszHeaders,
                                              dwHeadersLength,
                                              dwFlags,
                                              dwContext
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ParseHttpUrl_Fsm(
    IN CFsm_ParseHttpUrl * Fsm
    )

/*++

Routine Description:

    Run next ParseHttpUrl state. Note this FSM has no RunSM(). Since there is
    no object to instantiate, we don't need one

Arguments:

    Fsm - pointer to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ParseHttpUrl_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseHttpUrl & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL success;

    if (fsm.IsInvalid()) {
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto parse_continue;
    }

    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    DWORD urlLength;
    INTERNET_PORT port;
    LPSTR schemeName;

    //
    // new scheme - we now pass in the entire URL, so find the start of the
    // address info again. Keep a pointer to the scheme (may be different than
    // http:// if going via proxy); we already know the scheme length from the
    // parameters
    //

    schemeName = fsm.m_lpszUrl;
    fsm.m_lpszUrl += fsm.m_dwSchemeLength + sizeof("://") - 1;

    //
    // extract the address information - no user name or password
    //

    error = GetUrlAddress(&fsm.m_lpszUrl,
                          &urlLength,
                          &userName,
                          &userNameLength,
                          &password,
                          &passwordLength,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we got user name & password, convert them to zero-terminated strings.
    // The URL is a copy, so we can write into it, and the characters that
    // terminate user name & password (@ & : resp) are not significant
    //

    if (userName != NULL) {
        userName[userNameLength] = '\0';
    }
    if (password != NULL) {
        password[passwordLength] = '\0';
    }

    //
    // get the HTTP object path - decode any escape sequences
    //

    //if (*Url != '\0') {
    //
    //    INET_ASSERT((int)urlLength > 0);
    //
    //    error = DecodeUrlStringInSitu(Url, &urlLength);
    //    if (error != ERROR_SUCCESS) {
    //        goto quit;
    //    }
    //}

    //
    // convert the host name pointer and length to an ASCIIZ string
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    DWORD len;

    len = (DWORD)min(hostNameLength, sizeof(hostName) - 1);
    memcpy(hostName, pHostName, len);
    hostName[len] = '\0';

    //
    // make the GET request
    //

    HINTERNET hConnect;
    HINTERNET hRequest;

    fsm.m_hConnect = NULL;
    fsm.m_hRequest = NULL;

    //
    // if there is no port specified and we're sending an FTP or gopher request
    // then we have to map the port, or else we will try to use the HTTP port
    // (80)
    //

    INTERNET_SCHEME scheme;

    scheme = MapUrlSchemeName(schemeName, fsm.m_dwSchemeLength);
    if (port == INTERNET_INVALID_PORT_NUMBER) {
        switch (scheme) {
        case INTERNET_SCHEME_FTP:
            port = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SCHEME_GOPHER:
            port = INTERNET_DEFAULT_GOPHER_PORT;
            break;
        }
    }

    fsm.m_hConnect = InternetConnect(*fsm.m_phInternet,
                                     hostName,
                                     port,
                                     userName,
                                     password,
                                     INTERNET_SERVICE_HTTP,

                                     //
                                     // we can ignore EXISTING_CONNECT for HTTP
                                     // connect handle objects
                                     //

                                     fsm.m_dwFlags & ~INTERNET_FLAG_EXISTING_CONNECT,

                                     //
                                     // we are creating a "hidden" handle - don't
                                     // tell the app about it
                                     //

                                     INTERNET_NO_CALLBACK
                                     );
    if (fsm.m_hConnect != NULL) {

        //
        // set the real scheme type. e.g. we may be performing a CERN proxy
        // request for an FTP site, in which case the real scheme type is FTP
        //

        HINTERNET hConnectMapped;

        error = MapHandleToAddress(fsm.m_hConnect, (LPVOID *)&hConnectMapped, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->SetSchemeType(scheme);

        DereferenceObject((LPVOID)hConnectMapped);

        //
        // create the request object. Both proxy and non-proxy paths submit only
        // the URL-path
        //

        //
        // BUGBUG - this should be fixed in java download code!
        //
        // java downloads (synchronous) are requesting INTERNET_FLAG_EXISTING_CONNECT
        // when they really want INTERNET_FLAG_KEEP_CONNECTION
        //

        if (fsm.m_dwFlags & INTERNET_FLAG_EXISTING_CONNECT) {
            fsm.m_dwFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                         NULL,    // default verb is GET
                                         fsm.m_lpszUrl,
                                         NULL,    // default version is HTTP/1.0
                                         NULL,    // default referrer
                                         NULL,    // default accept encodings
                                         fsm.m_dwFlags,
                                         fsm.m_dwContext
                                         );
        if (fsm.m_hRequest != NULL) {
            success = HttpSendRequest(fsm.m_hRequest,
                                      fsm.m_lpszHeaders,
                                      fsm.m_dwHeadersLength,
                                      NULL,
                                      0
                                      );
            if (!success) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    goto quit;

parse_continue:

                    //
                    // in the async case, the result from HttpSendRequest() is
                    // returned as a DWORD error. Convert it back to a BOOL
                    //

                    success = (BOOL)(error == ERROR_SUCCESS);
                }
            }
        }
    } else {
        error = GetLastError();
    }
    if (success) {

        //
        // associate the connect handle with the request handle, so that when
        // we close the request handle, the connect handle is also closed
        //

        HINTERNET hConnectMapped = NULL;
        HINTERNET hRequestMapped = NULL;

        error = MapHandleToAddress(fsm.m_hConnect, (LPVOID *)&hConnectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            error = MapHandleToAddress(fsm.m_hRequest, (LPVOID *)&hRequestMapped, FALSE);
            if (error == ERROR_SUCCESS) {
                RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);

                //
                // return the request handle
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("returning handle %#x\n",
                            fsm.m_hRequest
                            ));

                *fsm.m_phInternet = fsm.m_hRequest;
            }
        }

        //
        // dereference the handles referenced by MapHandleToAddress()
        //

        if (hRequestMapped != NULL) {
            DereferenceObject((LPVOID)hRequestMapped);
        }
        if (hConnectMapped != NULL) {
            DereferenceObject((LPVOID)hConnectMapped);
        }
    }

quit:

    if ((error != ERROR_SUCCESS) && (error != ERROR_IO_PENDING)) {
        if (fsm.m_hRequest != NULL) {
            InternetCloseHandle(fsm.m_hRequest);
        }
        if (fsm.m_hConnect != NULL) {
            InternetCloseHandle(fsm.m_hConnect);
        }
    }
    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\query.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    query.cxx

Abstract:

    This file contains the implementation of the HttpQueryInfoA API.

    Contents:
        HttpQueryInfoA
        HttpQueryInfoW
        HTTP_REQUEST_HANDLE_OBJECT::QueryInfo

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpQueryInfoA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private prototypes
//

//
// private data
//

#define NUM_HEADERS ARRAY_ELEMENTS(GlobalKnownHeaders)

//
// functions
//


INTERNETAPI_(BOOL) HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries a request or response header from the HTTP request handle

Arguments:

    hRequest            - an open HTTP request handle returned by
                          HttpOpenRequest()

    dwInfoLevel         - one of the HTTP_QUERY_* values indicating the
                          attribute to query. In addition, the following flags
                          can be set:

                            HTTP_QUERY_FLAG_REQUEST_HEADERS
                                - Causes the request headers to be queried. The
                                  default is to check the response headers

                            HTTP_QUERY_FLAG_SYSTEMTIME
                                - Causes headers that contain date & time
                                  information to be returned as SYSTEMTIME
                                  structures

                            HTTP_QUERY_FLAG_NUMBER
                                - Causes header value to be returned as a number.
                                  Useful for when the app knows it is expecting
                                  a numeric value, e.g. status code

                            HTTP_QUERY_FLAG_COALESCE
                                - Combine several headers of the same name into
                                  one output buffer

    lpBuffer            - pointer to the buffer to receive the information.
                          If dwInfoLevel is HTTP_QUERY_CUSTOM then buffer
                          contains the header to query.

                          If NULL then we just return the required buffer length
                          to hold the header specified by dwInfoLevel

    lpdwBufferLength    - IN: contains the length (in BYTEs) of lpBuffer
                          OUT: size of data written to lpBuffer, or required
                               buffer length if ERROR_INSUFFICIENT_BUFFER
                               returned

    lpdwIndex           - IN: 0-based header index
                          OUT: next index to query, if success returned

Return Value:

    TRUE    - The query succeeded. lpBuffer contains the query information, and
              *lpdwBufferLength contains the size (in BYTEs) of the information

    FALSE   - The operation failed. Error status is available by calling
              GetLastError().

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpQueryInfoA",
                     "%#x, %s (%#x), %#x [%q], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : "",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD defaultIndex = 0;
    DWORD error;
    HINTERNET hRequestMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // find path from Internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    DWORD queryModifiers;
    DWORD infoLevel;

    queryModifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    infoLevel = dwInfoLevel & HTTP_QUERY_HEADER_MASK;

    if (((infoLevel > HTTP_QUERY_MAX) && (infoLevel != HTTP_QUERY_CUSTOM))
    || (lpdwBufferLength == NULL)

    //
    // nip in the bud apps that want SYSTEMTIME AND NUMBER for same header(!)
    //

#define EXCLUSIVE_MODIFIERS (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

    || ((dwInfoLevel & EXCLUSIVE_MODIFIERS) == EXCLUSIVE_MODIFIERS)) {

        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the app passed in a NULL lpdwIndex then it is asking for index 0
    //

    if (!ARGUMENT_PRESENT(lpdwIndex)) {
        lpdwIndex = &defaultIndex;
    }

    //
    // if the app is asking for one of the special query items - status code,
    // status text, HTTP version, or one of the raw header variants, then make
    // sure the index is 0. These pseudo-header types cannot be enumerated
    //

    if ((*lpdwIndex != 0)
    && ((infoLevel == HTTP_QUERY_VERSION)
        || (infoLevel == HTTP_QUERY_STATUS_CODE)
        || (infoLevel == HTTP_QUERY_STATUS_TEXT)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS_CRLF))) {

        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    //
    // ensure that we can use any flags passed in
    //

    if (infoLevel == HTTP_QUERY_CUSTOM) {

        //
        // lpBuffer MUST be present if we were asked to find a custom header
        //

        if (!ARGUMENT_PRESENT(lpBuffer)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // the app has given us a string to locate. We only accept strings in
        // the following format:
        //
        //  <header-to-find>[:][CR][LF]<EOS>
        //
        // The header cannot contain any spaces
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        __try {

            LPSTR lpszBuffer = (LPSTR)lpBuffer;
            int queryLength = 0;
            int headerLength = 0;

            for (; lpszBuffer[queryLength] != '\0'; ++queryLength) {
                if ((lpszBuffer[queryLength] == ':')
                || (lpszBuffer[queryLength] == '\r')
                || (lpszBuffer[queryLength] == '\n')) {
                    break;
                }
                if (iscntrl(lpszBuffer[queryLength])
                || isspace(lpszBuffer[queryLength])) {
                    error = ERROR_INVALID_PARAMETER;
                    break;
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else if ((queryModifiers & ~GlobalKnownHeaders[infoLevel].Flags) != 0) {
        error = ERROR_HTTP_INVALID_QUERY_REQUEST;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if NULL buffer pointer then app wants length of option: set buffer length
    // to zero
    //

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    } else {

        //
        // ensure app buffer is writeable
        //

        error = ProbeWriteBuffer(lpBuffer, *lpdwBufferLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;
    if (dwInfoLevel & HTTP_QUERY_FLAG_REQUEST_HEADERS) {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_REQUEST, TRUE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        }
    } else {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_RESPONSE, TRUE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        }
    }
    if (error == ERROR_SUCCESS) {
        error = pRequest->QueryInfo(dwInfoLevel,
                                    lpBuffer,
                                    lpdwBufferLength,
                                    lpdwIndex
                                    );
    }

quit:

    _InternetDecNestingCount(1);

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        success = FALSE;
    } else {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        DEBUG_DUMP_API(DUMP_API_DATA,
                       "Query data:\n",
                       lpBuffer,
                       *lpdwBufferLength
                       );

        success = TRUE;
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries information from the HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    dwInfoLevel - One of the HTTP_QUERY_* values indicating the attribute
        to query.

    lpBuffer - Pointer to the buffer to receive the information.

    dwBufferLength - On entry, contains the length (in BYTEs) of the data
        buffer. On exit, contains the size (in BYTEs) of the data written
        to lpBuffer.

Return Value:

    TRUE - The query succeeded. lpBuffer contains the query information,
        and lpBufferLength contains the size (in BYTEs) of the information.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,   
                     Bool,
                     "HttpQueryInfoW",
                     "%#x, %s (%#x), %#x [%wq], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : L"",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult=FALSE;
    INET_ASSERT(hRequest);
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && IsBadWritePtr(lpBuffer, *lpdwBufferLength))
        || (lpdwIndex && IsBadWritePtr(lpdwIndex, sizeof(*lpdwIndex))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpBuffer)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
        if (dwInfoLevel==HTTP_QUERY_CUSTOM)
        {
            DWORD dwTemp = WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpBuffer,-1,NULL,0,NULL,NULL);
            if (dwTemp>mpBuffer.dwAlloc)
            {
                mpBuffer.dwAlloc = dwTemp;
            }
        }
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (dwInfoLevel==HTTP_QUERY_CUSTOM)
    {
        if (!lpBuffer)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpBuffer,-1,mpBuffer.psStr,mpBuffer.dwAlloc,NULL,NULL);
    }

    fResult = HttpQueryInfoA(hRequest,dwInfoLevel,(LPVOID)mpBuffer.psStr,&mpBuffer.dwSize,lpdwIndex);

    if (!((dwInfoLevel & HTTP_QUERY_FLAG_NUMBER) ||
        (dwInfoLevel & HTTP_QUERY_FLAG_SYSTEMTIME)))
    {
        // This is the default, we've been handed back a string.
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            *lpdwBufferLength *= sizeof(WCHAR);
            if (*lpdwBufferLength<=mpBuffer.dwAlloc)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, mpBuffer.dwAlloc/sizeof(WCHAR));
                *lpdwBufferLength -= sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
    }
    else
    {
        if (fResult)
        {
            memcpy(lpBuffer, (LPVOID)mpBuffer.psStr, mpBuffer.dwSize);
        }
        *lpdwBufferLength = mpBuffer.dwSize;
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

//
// object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryInfo(
    IN DWORD dwInfoLevel,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Header query method for HTTP_REQUEST_HANDLE_OBJECT class

Arguments:

    dwInfoLevel         - level of info (header) to get

    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

    lpdwIndex           - IN: 0-based index of named header to return
                          OUT: index of next header if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_DOWNLEVEL_SERVER
                    Response came from a down-level (<= HTTP 0.9) server. There
                    are no headers to query

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

                  ERROR_HTTP_INVALID_QUERY_REQUEST
                    The caller asked for e.g. the Accept: header to be returned
                    as a SYSTEMTIME structure, or for e.g. a request header that
                    only exists for response headers (status code, for example)

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/

{
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT(lpdwIndex != NULL);

    DWORD error;
    LPSTR headerName;
    DWORD headerNameLength;
    DWORD modifiers;

    modifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    dwInfoLevel &= HTTP_QUERY_HEADER_MASK;

    if (dwInfoLevel == HTTP_QUERY_CUSTOM) {
        headerName = (LPSTR)lpBuffer;
        for (headerNameLength = 0; ; ++headerNameLength) {
            if ((headerName[headerNameLength] == '\0')
            || (headerName[headerNameLength] == ':')
            || (headerName[headerNameLength] == '\r')
            || (headerName[headerNameLength] == '\n')) {
                break;
            }
        }
    } else if (dwInfoLevel == HTTP_QUERY_REQUEST_METHOD) {

        LPSTR lpszVerb;
        DWORD dwVerbLength;

        lpszVerb = _RequestHeaders.GetVerb(&dwVerbLength);
        if ((lpszVerb != NULL) && (dwVerbLength != 0)) {

            //
            // the verb is (usually) space terminated
            //

            while ((dwVerbLength > 0) && (lpszVerb[dwVerbLength - 1] == ' ')) {
                --dwVerbLength;
            }

            //
            // *lpdwBufferLength will be 0 if lpBuffer is NULL
            //

            if (*lpdwBufferLength > dwVerbLength) {
                memcpy(lpBuffer, lpszVerb, dwVerbLength);
                ((LPBYTE)lpBuffer)[dwVerbLength] = '\0';
                error = ERROR_SUCCESS;
            } else {
                ++dwVerbLength;
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            *lpdwBufferLength = dwVerbLength;
        } else {
            error = ERROR_HTTP_HEADER_NOT_FOUND;
        }
        goto quit;
    } else {
        headerName = GlobalKnownHeaders[dwInfoLevel].Text;
        headerNameLength = GlobalKnownHeaders[dwInfoLevel].Length;
    }

    if (modifiers & HTTP_QUERY_FLAG_REQUEST_HEADERS) {

        //
        // we can always query request headers, even if the server is down
        // level
        //

        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            
            error = _RequestHeaders.QueryRequestVersion(
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;
        case HTTP_QUERY_STATUS_CODE:
        case HTTP_QUERY_STATUS_TEXT:

            //
            // can't query these sub-header values from the request headers
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _RequestHeaders.QueryRawHeaders(
                        NULL,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = QueryRequestHeadersWithEcho(
                        dwInfoLevel == HTTP_QUERY_ECHO_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_CUSTOM:

            _RequestHeaders.LockHeaders();

            error = QueryRequestHeader(headerName,
                                       headerNameLength,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       modifiers,
                                       lpdwIndex
                                       );

            _RequestHeaders.UnlockHeaders();

            break;

        default:

            _RequestHeaders.LockHeaders();

            error = QueryRequestHeader( dwInfoLevel,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _RequestHeaders.UnlockHeaders();

            break;

        }
    } else if (!IsDownLevel()) {
        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            error = QueryResponseVersion(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_STATUS_CODE:
            error = QueryStatusCode(lpBuffer, lpdwBufferLength, modifiers);
            break;

        case HTTP_QUERY_STATUS_TEXT:
            error = QueryStatusText(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _ResponseHeaders.QueryRawHeaders(
                        (LPSTR)_ResponseBuffer,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_CUSTOM:

            _ResponseHeaders.LockHeaders();

            error = QueryResponseHeader(
                                        headerName,
                                        headerNameLength,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _ResponseHeaders.UnlockHeaders();

            break;

        default:

            _ResponseHeaders.LockHeaders();

            error = QueryResponseHeader(
                                        dwInfoLevel,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _ResponseHeaders.UnlockHeaders();

            break;
        }
    } else {

        //
        // there are no response headers from down-level servers
        //

        error = ERROR_HTTP_DOWNLEVEL_SERVER;
    }

quit:

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeadersWithEcho(
    IN BOOL bCrlfTerminated,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Header query for request headers with echo headers added if any..

Arguments:

    bCrlfTerminated     - should the headers be seperated by CRLF's
    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/
{
    INET_ASSERT(lpdwBufferLength != NULL);

    DWORD error;
    LPSTR lpszEchoHeaderIn = NULL ;
    LPSTR lpszEchoHeaderOut = NULL;
    DWORD cbHeaderIn = 0;
    DWORD cbHeaderOut = 0;
    BOOL bEchoPresent = FALSE;

    // List of headers to filter out of the Request headers

    LPSTR rglpFilter [ ] =
    {
        GlobalKnownHeaders[HTTP_QUERY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
        GlobalKnownHeaders[HTTP_QUERY_COOKIE].Text,
        GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text,
        GlobalKnownHeaders[HTTP_QUERY_HOST].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_NONE_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_UNMODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_UNLESS_MODIFIED_SINCE].Text,
    };

    _ResponseHeaders.LockHeaders();

    error = FastQueryResponseHeader(HTTP_QUERY_ECHO_REQUEST,
                                    (LPVOID *)&lpszEchoHeaderIn,
                                    &cbHeaderIn,
                                    0);

    if (error == ERROR_SUCCESS)
    {
        DWORD cbEchoRequest = GlobalKnownHeaders[HTTP_QUERY_ECHO_REQUEST].Length;
        DWORD cbEchoReply   = GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Length;

        bEchoPresent = TRUE;

        // Add echo-reply: to the begining of the header.
        cbHeaderOut = cbEchoReply  + 1                      // For echo-reply:
                        + cbHeaderIn                        // Send back the stuff from the header.
                        + (bCrlfTerminated ? 2 : 1)         // 2 for CRLF
                        + 1;                                // 1 for NULL terminator

        lpszEchoHeaderOut = (LPSTR) _alloca(cbHeaderOut); // Add 1 for null terminator.

        if ( lpszEchoHeaderOut == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        LPSTR lpsz = lpszEchoHeaderOut;

        memcpy(lpszEchoHeaderOut, GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text, cbEchoReply);
        lpsz += cbEchoReply;

        lpsz[0] = ':';
        lpsz++;


        memcpy(lpsz, lpszEchoHeaderIn, cbHeaderIn );
        lpsz += cbHeaderIn;


        if ( bCrlfTerminated)
        {
            lpsz[0] = '\r';
            lpsz[1] = '\n';
            lpsz += 2;
        }
        else
        {
            lpsz[0] = '\0';
            lpsz++;
        }

        *lpsz = '\0';
    }

    DWORD dwBufferLength;
    dwBufferLength = *lpdwBufferLength;


    error = _RequestHeaders.QueryFilteredRawHeaders(
                NULL,
                rglpFilter,
                sizeof(rglpFilter)/sizeof(rglpFilter[0]),
                TRUE,
                TRUE,
                bCrlfTerminated,
                lpBuffer,
                lpdwBufferLength
                );

    if ( !bEchoPresent )
    {
        // Nothing more to do in this case.
    }
    else if ( error == ERROR_SUCCESS )
    {
        DWORD dwBufferReqd = *lpdwBufferLength + cbHeaderOut;
        // Check if we have space to add extra headers.
        if (dwBufferReqd <= dwBufferLength)
        {
            memcpy((LPSTR)lpBuffer + *lpdwBufferLength, lpszEchoHeaderOut, cbHeaderOut);
            *lpdwBufferLength += cbHeaderOut - 1; // -1 to exclude terminating '\0'
        }
        else
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            // There is a NULL termination count included both in cbHeaderOut and *lpdwBufferLength
            // hence the -1.
            *lpdwBufferLength += cbHeaderOut - 1 ;
        }
    }
    else if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        *lpdwBufferLength += cbHeaderOut - 1 ;
    }
    else
    {
        // For other errors just return the original error from QueryRawHeaders.
    }

done:
    _ResponseHeaders.UnlockHeaders();

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\redirect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    Contains HTTP_REQUEST_HANDLE_OBJECT method for handle redirection

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::Redirect

Author:

    Richard L Firth (rfirth) 18-Feb-1996

Environment:

    Win32 user-level

Revision History:

    18-Feb-1996 rfirth
        Created
	
--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// manifests
//

#define DEFAULT_COOKIE_BUFFER_LENGTH    (1 K)

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect(
    IN HTTP_METHOD_TYPE tMethod,
    IN BOOL fRedirectToProxy
    )

/*++

Routine Description:

    Called after a successful SendData() in which we discover that the requested
    object has been moved.

    We need to change the HTTP_REQUEST_HANDLE_OBJECT so that we can resubmit the
    request and retrieve the redirected object.

    To do this we have to:

        get the new URI
        crack the new URI
        if callbacks are enabled or the server is the same and we are using keep-alive
            drain the current response into the response buffer
        if we are not using keep-alive
            kill the connection
        if callbacks are enabled
            indicate redirection to the app
        create a new request header
        if the server or port has changed
            update the local server & port information

Arguments:

    tMethod - new request method type (e.g. if POST => GET), or POST => POST ( for HTTP 1.1)

    fRedirectToProxy  - TRUE if we're actually redirected to use a proxy instead of another site


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "Redirect",
                "%s, %x",
                MapHttpMethodType(tMethod),
                fRedirectToProxy
                ));

    DWORD error = DoFsm(new CFsm_Redirect(tMethod, fRedirectToProxy, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_Redirect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_Redirect::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_Redirect * stateMachine = (CFsm_Redirect *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->Redirect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm(
    IN CFsm_Redirect * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm",
                 "%#x",
                 Fsm
                 ));

    DWORD index;
    LPSTR uriBuffer = NULL;
    DWORD uriLength = INTERNET_MAX_PATH_LENGTH;
    CFsm_Redirect & fsm = *Fsm;
    DWORD error = fsm.GetError();
    char *buffer = NULL;

    AUTHCTX* pAuthCtx = GetAuthCtx();
    AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
    if (pAuthCtx != NULL)
    {
        eAuthScheme = pAuthCtx->GetSchemeType();
    }

    // For redirects, this should be reset ( if it ever was set. )
    _fSendUTF8ServerNameToProxy = FALSE;
    
    _ResponseHeaders.LockHeaders();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (GlobalAlwaysDrainOnRedirect || !IsKeepAlive() || IsContentLength() || IsChunkEncoding()) {
            error = DrainResponse(&fsm.m_bDrained);
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }
    }

    if (eAuthScheme == AUTHCTX::SCHEME_PASSPORT)
    {
        PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)pAuthCtx;
        if (pPPCtx->m_lpszRetUrl)
        {
        ReplaceResponseHeader(HTTP_QUERY_LOCATION, 
                              pPPCtx->m_lpszRetUrl, 
                              strlen(pPPCtx->m_lpszRetUrl), 
                              0, 
                              HTTP_ADDREQ_FLAG_REPLACE);

        delete [] pPPCtx->m_lpszRetUrl;
        pPPCtx->m_lpszRetUrl = NULL;
        }
    }

    //
    // get the "Location:" header
    //
    // BUGBUG - we also need to get & parse the "URI:" header(s)
    //

    do {

        //
        // we allow ourselves to fail due to insufficient buffer (at least once)
        //

        uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength, FALSE);
        if (uriBuffer != NULL) {

            DWORD previousLength = uriLength;

            index = 0;

            error = QueryResponseHeader(HTTP_QUERY_LOCATION,
                                        uriBuffer,
                                        &uriLength,
                                        0,      // no modifiers
                                        &index  // should only be one
                                        );
            if (error == ERROR_SUCCESS) {

                //
                // we probably allocated too much buffer - shrink it
                //

                uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength + 1, FALSE);

                //
                // check for NULL below
                //

            } else if ((error == ERROR_INSUFFICIENT_BUFFER)
            && (previousLength >= uriLength)) {

                //
                // this should never happen, but we will avoid a loop if it does
                //

                INET_ASSERT(FALSE);

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        }
        if (uriBuffer == NULL) {

            //
            // failed to (re)alloc or shrink
            //

            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } while (error == ERROR_INSUFFICIENT_BUFFER);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    ////
    //// strip all cookie request headers
    ////
    //
    //RemoveAllRequestHeadersByName("Cookie");
    //
    ////
    //// and add any we received
    ////
    //
    //DWORD headerLength;
    //DWORD bufferLength;
    //LPVOID lpHeader;
    //
    //bufferLength = DEFAULT_COOKIE_BUFFER_LENGTH;
    //lpHeader = (LPVOID)ResizeBuffer(NULL, bufferLength, FALSE);
    //if (lpHeader == NULL) {
    //    error = ERROR_NOT_ENOUGH_MEMORY;
    //    goto quit;
    //}
    //
    //index = 0;
    //
    //do {
    //    headerLength = bufferLength;
    //    error = QueryResponseHeader("Set-Cookie",
    //                                sizeof("Set-Cookie") - 1,
    //                                lpHeader,
    //                                &headerLength,
    //                                0,
    //                                &index
    //                                );
    //    if (error == ERROR_INSUFFICIENT_BUFFER) {
    //        error = ERROR_SUCCESS;
    //        bufferLength = headerLength;
    //        lpHeader = (LPVOID)ResizeBuffer((HLOCAL)lpHeader,
    //                                        bufferLength,
    //                                        FALSE
    //                                        );
    //        if (lpHeader == NULL) {
    //            error = ERROR_NOT_ENOUGH_MEMORY;
    //            goto quit;
    //        }
    //    } else if (error == ERROR_SUCCESS) {
    //        error = AddRequestHeader("Cookie",
    //                                 sizeof("Cookie") - 1,
    //                                 (LPSTR)lpHeader,
    //                                 headerLength,
    //                                 0,
    //                                 0
    //                                 );
    //    }
    //} while (error == ERROR_SUCCESS);
    //
    //INET_ASSERT(error == ERROR_HTTP_HEADER_NOT_FOUND);

    //
    // we may have been given a partial URL. Combine it with the current base
    // URL. If both are base URLs then we just get back the new one
    //

    DWORD newUrlLength;
    buffer = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH + 1);

    if (buffer == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    newUrlLength = INTERNET_MAX_URL_LENGTH;

    INET_ASSERT(GetURL() != NULL);

    if (!InternetCombineUrl(GetURL(),
                            uriBuffer,
                            buffer,
                            &newUrlLength,
                            ICU_ENCODE_SPACES_ONLY)) {
        error = GetLastError();
        if (error == ERROR_INSUFFICIENT_BUFFER) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        }

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // we are done with uriBuffer
    //

    uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

    INET_ASSERT(uriBuffer == NULL);

    //
    // if we ended up with exactly the same URL then we're done. Note that the
    // URLs may be the same, even if they're lexicographically different - host
    // name vs. IP address e.g., encoded vs. unencoded, case sensitive? In the
    // encoded case, the URLs should be in canonical form. We may have an issue
    // with host vs IP address which will lead to an additional transaction
    //

    if (!fsm.m_fRedirectToProxy &&
        (eAuthScheme != AUTHCTX::SCHEME_PASSPORT) &&
        !strcmp(GetURL(), buffer))   
        // Passport1.4 auth need redirect to same site works
    {
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("URLs match: %q, %q\n",
                    GetURL(),
                    buffer
                    ));

        error = ERROR_HTTP_NOT_REDIRECTED;
        goto quit;
    }

    //
    // crack the new URL
    //

    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extra;
    DWORD extraLength;

    error = CrackUrl(buffer,
                     newUrlLength,
                     FALSE, // don't escape URL-path
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &port,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     &urlPath,
                     &urlPathLength,
                     &extra,
                     &extraLength,
                     NULL
                     );
    if ((error != ERROR_SUCCESS) || (hostNameLength == 0)) {

        //
        // if this is an URL for which we don't understand the protocol then
        // defer redirection to the caller
        //

        if (error == ERROR_INTERNET_UNRECOGNIZED_SCHEME) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        } else if (hostNameLength == 0) {
            error = ERROR_HTTP_NOT_REDIRECTED;
        }
        goto quit;
    }

    //
    // if the scheme is not HTTP or HTTPS then we can't automatically handle it.
    // We have to return it to the caller. For example, we cannot transmogrify
    // a HTTP handle to an FTP directory handle, and there's no way we can
    // handle a file:// URL (we don't understand file://)
    //

    if ((schemeType != INTERNET_SCHEME_HTTP)
    && (schemeType != INTERNET_SCHEME_HTTPS)) {
        error = ERROR_HTTP_REDIRECT_FAILED;
        goto quit;
    }

    //
    // BUGBUG - we may get back an IP address (IPX?) in which case we need to
    //          resolve it again
    //

    //
    // map port
    //

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    //
    // if the server & port remain the same and we are using keep-alive OR
    // we think the app may want to read any data associated with the redirect
    // header (i.e. callbacks are enabled) then drain the response
    //

    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_SCHEME currentSchemeType;

    currentHostPort = GetHostPort();
    currentHostName = GetHostName(&currentHostNameLength);
    currentSchemeType = ((INTERNET_FLAG_SECURE & GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    //
    // close the connection
    //

    //
    // BUGBUG - if we are redirecting to the same site and we have a keep-alive
    //          connection, then we don't have to do this. Worst case is that
    //          we go to get the keep-alive connection and some other bounder
    //          has taken it
    //

    //
    // if we didn't actually drain the socket because of the server type or
    // because there was no or incorrect data indication then force the
    // connection closed (if keep-alive)
    //

    CloseConnection(fsm.m_bDrained ? FALSE : TRUE);

    //
    // inform the app of the redirection. At this point, we have received all
    // the headers and data associated with the original request. We have not
    // modified the object with information for the new request. This is so
    // the application can query information about the original request - e.g.
    // the original URL - before we make the new request for the redirected item
    //

    InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, buffer);

    //
    // BUGBUG - app may have closed the request handle
    //

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            newUrlLength -= extraLength;
        } else {
            urlPathLength += extraLength;
        }
    }

    //
    // create the new request line. If we're going via proxy, add the entire URI
    // else just the URL-path
    //

    //
    // BUGBUG - do we need to perform any URL-path escaping here?
    //

    //
    // BUGBUG - always modifying POST to GET
    //

    //
    // BUGBUG - [arthurbi]
    //   this breaks For HTTPS sent over  HTTP to
    //   a proxy which turns it into HTTPS.
    //

    //INET_ASSERT(fsm.m_tMethod == HTTP_METHOD_TYPE_GET);

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    INTERNET_HANDLE_OBJECT * pInternet;

    pInternet = (INTERNET_HANDLE_OBJECT * )pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Set Url in the request object. Authentication, and Cookies
    //  depend on checking the new URL not the previous one.
    //

    BYTE bTemp;

    bTemp = buffer[newUrlLength];
    buffer[newUrlLength] = 0;

    BOOL fSuccess;

    if ( !fsm.m_fRedirectToProxy )
    {
        UrlCacheUnlock();
        fSuccess = SetURL(buffer);
        buffer[newUrlLength] = bTemp;

        if (!fSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        // Force revalidation of the security zone
        GetSecurityZone(TRUE);

        //
        // update the method, server and port, if they changed
        //

        SetMethodType(fsm.m_tMethod);
        SetPWC(NULL);

        if (port != currentHostPort) {
            SetHostPort(port);
        }
        if ((hostNameLength != currentHostNameLength)
        || (strnicmp(hostName, currentHostName, hostNameLength) != 0)) {

            char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
            LPSTR hostValueStr;
            DWORD hostValueSize; 

            CHAR chBkChar = hostName[hostNameLength]; // save off char

            hostName[hostNameLength] = '\0';
            SetHostName(hostName);

            hostValueSize = hostNameLength;
            hostValueStr = hostName;            

            if ((port != INTERNET_DEFAULT_HTTP_PORT)
            &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
                if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
                {
                    hostName[hostNameLength] = chBkChar; // put back char
                    error = ERROR_INVALID_PARAMETER;
                    goto quit;
                }
                hostValueSize = wsprintf(hostValue, "%s:%d", hostName, (port & 0xffff));
                hostValueStr = hostValue;
            }

            hostName[hostNameLength] = chBkChar; // put back char
    
            //
            // replace the "Host:" header
            //

            ReplaceRequestHeader(HTTP_QUERY_HOST,
                                 hostValueStr,
                                 hostValueSize,
                                 0, // dwIndex
                                 ADD_HEADER
                                 );

            //
            // and get the corresponding server info, resolving the name if
            // required
            //

            SetServerInfo(FALSE);

            //
            // Since we are redirecting to a different host, force an update of the origin
            // server.  Otherwise, we will still pick up the proxy info of the first server.
            //
            SetOriginServer(TRUE);
        }

        //
        // if the new method is GET then remove any content-length headers (there
        // *should* only be 1!) - we won't be sending any data on the redirected
        // request. Remove any content-type (again should only be 1) also
        //

        if (fsm.m_tMethod == HTTP_METHOD_TYPE_GET) {
            RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_LENGTH);
            RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_TYPE);
        }

        //
        // Catch Redirections from HTTPS to HTTP (and) HTTP to HTTPS
        //

        if ( currentSchemeType != schemeType )
        {
            DWORD OpenFlags;

            OpenFlags = GetOpenFlags();

            //
            // Switched From HTTPS to HTTP
            //

            if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
            {
                INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

                OpenFlags &= ~(INTERNET_FLAG_SECURE);

                //
                // Allow the Global to shut off this behavior.
                //

                if ( !(OpenFlags & INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP))
                {
                    if ( OpenFlags & INTERNET_FLAG_FORMS_SUBMIT ||
                         fsm.m_tMethod == HTTP_METHOD_TYPE_POST )
                    {
                        error  = ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR;
                    }
                    else if (GlobalWarnOnZoneCrossing)
                    {
                        error = ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR;
                    }
                }
            }

            //
            // Switched From HTTP to HTTPS
            //

            else if ( schemeType == INTERNET_SCHEME_HTTPS )
            {
                INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

                OpenFlags |= (INTERNET_FLAG_SECURE);

                // Make sure SSL is loaded now
                error = LoadSecurity();

                //
                // Allow the Global to shut off this behavior.
                //
                if ( ERROR_SUCCESS == error &&
                     !(OpenFlags & INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS) &&
                      GlobalWarnOnZoneCrossing )
                {
                    error = ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR;
                }
            }


            SetOpenFlags(OpenFlags);
            SetSchemeType(schemeType);

        }

        //
        // remember the "Refresh" header if it exists. If we received the header and
        // get redirected to a site that doesn't return "Refresh" then we need to
        // use the original version
        //

        DWORD err;
        DWORD length;

        length = newUrlLength - (sizeof("Refresh: ") - 1);
        index = 0;
        err = QueryResponseHeader(HTTP_QUERY_REFRESH,
                                  &buffer[sizeof("Refresh: ") - 1],
                                  &length,
                                  0,  // dwModifiers
                                  &index
                                  );
        if (err == ERROR_SUCCESS) {

            DWORD len;

            memcpy(buffer, "Refresh: ", sizeof("Refresh: ") - 1);
            SetRefreshHeader(buffer, length + (sizeof("Refresh: ") - 1));
        }
    }
    else
    {
        LPSTR proxyHostName;

        //
        // We're Redirected to a use a new proxy, set the
        //  new proxy atttributes
        //

        proxyHostName = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, hostNameLength+1);

        if ( proxyHostName == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        memcpy(proxyHostName, hostName, hostNameLength);
        proxyHostName[hostNameLength] = '\0';

        SetProxyName(proxyHostName, hostNameLength, port);

        SetOverrideProxyMode(TRUE);
    }

quit:

    if (buffer != NULL)
    {
        FREE_MEMORY(buffer);
    }

    if (uriBuffer != NULL)
    {
        uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

        INET_ASSERT(uriBuffer == NULL);
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    _ResponseHeaders.UnlockHeaders();

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\read.cxx ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name:

    read.cxx

Abstract:

    This file contains the implementation of the HttpReadData API.

    Contents:
        HttpReadData
        CFsm_HttpReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::ReadData
        CFsm_ReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable
        CFsm_HttpQueryAvailable::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse
        CFsm_DrainResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpReadData remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwLen
    );

//
// functions
//


DWORD
HttpReadData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Reads a block of data from an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetReadFile() which
        globally validates parameters for all Internet data read
        functions

         2. We will never get a request for 0 bytes at this level. This
        request will have been handled in InternetReadFile()

Arguments:

    hRequest                - mapped HTTP request handle

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToRead   - number of bytes to read into lpBuffer

    lpdwNumberOfBytesRead   - number of bytes read into lpBuffer

    dwSocketFlags           - controlling socket operation

Return Value:

    TRUE - The data was read successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpReadData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 dwSocketFlags
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) hRequest;

    if (pRequest->IsReadRequest()) {

        //
        // Invoke ReadLoop fsm only if the read and write positions
        // are different, otherwise older code is more efficient.
        //

        error = DoFsm (new CFsm_ReadLoop (pRequest, dwSocketFlags,
            (PBYTE) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead));

    } else {

        error = DoFsm(new CFsm_HttpReadData(lpBuffer,
                                            dwNumberOfBytesToRead,
                                            lpdwNumberOfBytesRead,
                                            dwSocketFlags,
                                            pRequest
                                           ));
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpReadData * stateMachine = (CFsm_HttpReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->HttpReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm(
    IN CFsm_HttpReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpReadData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!IsValidHttpState(READ)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
            goto quit;
        }
        error = ReadData(fsm.m_lpBuffer,
                         fsm.m_dwNumberOfBytesToRead,
                         fsm.m_lpdwNumberOfBytesRead,
                         FALSE, // BUGBUG RFirthRemove on chkin
                         fsm.m_dwSocketFlags
                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }
    if (IsCacheWriteInProgress()) {
        if (*fsm.m_lpdwNumberOfBytesRead == 0) {

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Cache write complete\r\n"
                        ));

            LocalEndCacheWrite((error == ERROR_SUCCESS)
                               && (GetBytesInSocket() == 0));
        } else if (!HaveReadFileExData()) {

            INET_ASSERT(!IsCacheReadInProgress());

            if (WriteCache((LPBYTE)fsm.m_lpBuffer,
                           *fsm.m_lpdwNumberOfBytesRead) != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                LocalEndCacheWrite(FALSE);
            }
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    PERF_LOG(PE_TRACE, 0x1002);

    DEBUG_LEAVE(error);

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN BOOL fNoAsync, // BUGBUG RFirthRemove on DrainSocket checkin
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT ReadData method

    Reads data into users buffer. Reads from header buffer if data exists
    there, or reads from the socket

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToRead   - size of buffer/number of bytes to read

    lpdwNumberOfBytesRead   - pointer to returned number of bytes read

    fNoAsync                - TRUE if we want to override defaults and have
                              no Async Read.

    dwSocketFlags           - controlling socket operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData",
                 "%#x, %d, %#x, %B, %#x",
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 fNoAsync,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(new CFsm_ReadData(lpBuffer,
                                          dwNumberOfBytesToRead,
                                          lpdwNumberOfBytesRead,
                                          fNoAsync,
                                          dwSocketFlags,
                                          this
                                          ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadData * stateMachine = (CFsm_ReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm(
    IN CFsm_ReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_LOG(PE_TRACE, 0x6001);

    CFsm_ReadData & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {

        PERF_LOG(PE_TRACE, 0x6101);

        error = fsm.GetError();
        goto receive_continue;
    }

    fsm.m_dwBytesRead = 0;
    fsm.m_dwBufferLeft = fsm.m_dwNumberOfBytesToRead;
    fsm.m_nBytesCopied = 0;

    //
    // if there's no data then we're done
    //

    if (!IsData()) {

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("!IsData()\n"
                    ));

        SetState(HttpRequestStateReopen);

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //
    // If using keep-alive, reduce output buffer so we don't over-read.
    //

    if (IsKeepAlive() && IsContentLength()) {
        if (_BytesRemaining == 0) {

            INET_ASSERT(error == ERROR_SUCCESS);

            PERF_LOG(PE_TRACE, 0x6102);

            goto done;
        }

        PERF_LOG(PE_TRACE, 0x6103);

        fsm.m_dwBufferLeft = min(fsm.m_dwBufferLeft, _BytesRemaining);
    }

    //
    // if there's data left in the response buffer then copy it
    //

    fsm.m_bEof = FALSE;

    if (IsBufferedData()) {

        DWORD amountToCopy = min(fsm.m_dwNumberOfBytesToRead, BufferDataAvailToRead());

        if (amountToCopy != 0) {

            PERF_LOG(PE_TRACE, 0x6104);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Copying %d (%#x) bytes from header buffer @ %#x - %d left\n",
                        amountToCopy,
                        amountToCopy,
                        BufferedDataStart(),
                        BufferDataAvailToRead() - amountToCopy
                        ));

            memcpy(fsm.m_lpBuffer, BufferedDataStart(), amountToCopy);
            ReduceDataAvailToRead(amountToCopy);
            fsm.m_dwBytesRead += amountToCopy;
            fsm.m_dwBufferLeft -= amountToCopy;
            fsm.m_nBytesCopied += amountToCopy;

            //
            // we don't update lpBuffer here. Receive() takes the address of
            // the start of the buffer
            //

        }

        //
        // if we exhausted all the buffer space, then we're done
        //

        if (fsm.m_dwBufferLeft == 0) {

            PERF_LOG(PE_TRACE, 0x6105);

            goto done;
        }
    }

    //
    // find out if we're async. Even though the handle was created for async I/O
    // the request may be satisfied immediately
    //

    DWORD asyncFlags;

    if ( fsm.m_fNoAsync )   // BUGBUG RFirthRemove on Checkin of DrainSocket
        asyncFlags = 0;
    else
        asyncFlags = (IsAsyncHandle()
                        && (fsm.m_dwBufferLeft > AvailableDataLength()))
                   ? SF_NON_BLOCKING
                   : 0
                   ;

    //
    // if we have data already received in the query buffer, then return that
    //

    if (HaveQueryData()) {

        PERF_LOG(PE_TRACE, 0x6106);

        DWORD nCopied;

        nCopied = CopyQueriedData((LPVOID)((LPBYTE)fsm.m_lpBuffer + fsm.m_dwBytesRead),
                                  fsm.m_dwBufferLeft
                                  );

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied %d (%#x) bytes from query buffer @ %#x - %d left\n",
                    nCopied,
                    nCopied,
                    (LPBYTE)_QueryBuffer - _QueryOffset,
                    _QueryBytesAvailable
                    ));

        fsm.m_dwBytesRead += nCopied;
        fsm.m_dwBufferLeft -= nCopied;
        fsm.m_nBytesCopied += nCopied;
        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    //if ( IsChunkEncoding() && IsChunkedEncodingFinished() )
    //{
    //    fsm.m_bEof = TRUE;
    //    goto done;
    //}


    if (HaveReadFileExData()) {
        PERF_LOG(PE_TRACE, 0x6107);
        *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
        --fsm.m_dwNumberOfBytesToRead;
        --fsm.m_dwBufferLeft;
        ++fsm.m_dwBytesRead;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied 1 byte (%#x) from ReadFileEx buffer %#x\n",
                    (BYTE)_ReadFileExData & 0xff,
                    &_ReadFileExData
                    ));

        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    if ( IsChunkEncoding() && IsChunkedEncodingFinished() )
    {
        PERF_LOG(PE_TRACE, 0x6108);
        fsm.m_bEof = TRUE;
        goto done;
    }

    //
    // we're about to check the socket. Make sure its valid to do so
    //

    //INET_ASSERT(_Socket != NULL);

    if ((_Socket == NULL) || !_Socket->IsOpen()) {

        //
        // socket was closed - no more data
        //

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6109);
        goto quit;
    }

read_again:

    fsm.m_nBytes = fsm.m_dwBytesRead;

    //
    // if we had a content-length and we don't think there is any data left to
    // read then we're done
    //

    if (IsContentLength() && (_BytesInSocket == 0)) {
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6110);
        goto done;
    }

    //
    // receive data into user's buffer. Because we don't own the buffer, we
    // cannot resize it
    //

    LPVOID lpBuffer;
    DWORD dwBytesToRead;
    DWORD dwBufferLeft;
    DWORD dwBytesRead;

    lpBuffer = fsm.m_lpBuffer;
    dwBytesToRead = fsm.m_dwNumberOfBytesToRead;
    dwBufferLeft = fsm.m_dwBufferLeft;
    dwBytesRead = fsm.m_dwBytesRead;

    //INET_ASSERT(!(fsm.m_dwSocketFlags & SF_NO_WAIT)
    //            ? (fsm.m_dwBufferLeft <= _BytesRemaining)
    //            : TRUE);

    PERF_LOG(PE_TRACE, 0x6111);

    if (IsBadNSServer() && !IsConnCloseResponse()) {
        SetBadNSReceiveTimeout();
    }

    error = _Socket->Receive(&fsm.m_lpBuffer,
                             &fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBufferLeft,
                             &fsm.m_dwBytesRead,
                             0,
                             SF_INDICATE
                             | ((fsm.m_dwSocketFlags & SF_NO_WAIT)
                                ? SF_NO_WAIT
                                : (IsChunkEncoding() ? 0 : SF_RECEIVE_ALL)),
                             &fsm.m_bEof
                             );

    //
    // only if we performed an asynchronous no-wait receive and there was no
    // data available in the socket will we get WSAEWOULDBLOCK. Make another
    // receive request, this time without no-wait. It will complete
    // asynchronously and the app must make another no-wait request
    //

    if (error == WSAEWOULDBLOCK) {

        PERF_LOG(PE_TRACE, 0x6112);

        INET_ASSERT(fsm.m_dwSocketFlags & SF_NO_WAIT);
        INET_ASSERT(!fsm.m_bEof);

        //
        // BUGBUG - IsAsyncHandle() || IsAsyncRequest()
        //

        if ((fsm.m_dwBytesRead == 0) && IsAsyncHandle()) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Initiating wait-for-data (1-byte read)\n"
                        ));

            fsm.m_lpBuffer = (LPVOID)&_ReadFileExData;
            fsm.m_dwNumberOfBytesToRead = 1;
            fsm.m_dwBufferLeft = 1;
            fsm.m_dwSocketFlags &= ~SF_NO_WAIT;

            INET_ASSERT(!_HaveReadFileExData);

            SetReadFileExData();

            _ReadFileExData = 0;

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            PERF_LOG(PE_TRACE, 0x6113);

            if (IsBadNSServer() && !IsConnCloseResponse()) {
                SetBadNSReceiveTimeout();
            }

            error = _Socket->Receive(&fsm.m_lpBuffer,
                                     &fsm.m_dwNumberOfBytesToRead,
                                     &fsm.m_dwBufferLeft,
                                     &fsm.m_dwBytesRead,
                                     0,
                                     fsm.m_dwSocketFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_SUCCESS) {

                PERF_LOG(PE_TRACE, 0x6114);

                BOOL fReadNothing = (fsm.m_dwBytesRead == 0 ? TRUE : FALSE);

                //
                // we have successfully read a single byte from the socket.
                //

                //INET_ASSERT(FALSE);

                fsm.m_lpBuffer = lpBuffer;
                fsm.m_dwNumberOfBytesToRead = dwBytesToRead;
                fsm.m_dwBufferLeft = dwBufferLeft;
                fsm.m_dwBytesRead = dwBytesRead;
                if (fReadNothing) {
                    // Don't copy if nothing was actually read.
                    ResetReadFileExData();
                }
                else {
                    *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
                    --fsm.m_dwBufferLeft;
                    ++fsm.m_dwBytesRead;
                }

                //
                // BUGBUG - if socket unblocked already, should go round & read
                //          again, not just return 1 byte
                //

            }

            PERF_LOG(PE_TRACE, 0x6115);

        } else {

            PERF_LOG(PE_TRACE, 0x6116);

            DEBUG_PRINT(HTTP,
                        WARNING,
                        ("Not initiating wait-for-data: bytesRead = %d, asyncHandle = %B\n",
                        fsm.m_dwBytesRead,
                        IsAsyncHandle()
                        ));

            //
            // read data from buffers but nothing available from socket
            //

            error = ERROR_SUCCESS;
        }
    }

    if (error == ERROR_IO_PENDING) {
        PERF_LOG(PE_TRACE, 0x6117);
        goto quit_pending;
    }

receive_continue:

    PERF_LOG(PE_TRACE, 0x6118);

    //
    // if we timed-out while talking to 'bad' NS server (returns HTTP/1.1 but
    // content-length or chunked encoding info) then close the connection and
    // reset any RFX status. We return SUCCESS in this case
    //

    if ((error == ERROR_INTERNET_TIMEOUT) && IsBadNSServer()) {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Bad NS server: Closing connection %#x/%d on timeout\n",
                    _Socket ? _Socket->GetSocket() : -1,
                    _Socket ? _Socket->GetSourcePort() : -1
                    ));

        CloseConnection(TRUE);
        ResetReadFileExData();
        SetData(FALSE);
        _dwCurrentStreamPosition += fsm.m_dwBytesRead;
        fsm.m_bEof = TRUE;
        error = ERROR_SUCCESS;
        goto quit;
    }
    if (error == ERROR_SUCCESS) {
        if (IsContentLength()) {

            INET_ASSERT(fsm.m_dwBytesRead >= fsm.m_nBytes);

            _BytesInSocket -= fsm.m_dwBytesRead - fsm.m_nBytes;

            INET_ASSERT((int)_BytesInSocket >= 0);

            if ((int)_BytesInSocket < 0) {
                _BytesInSocket = 0;
            }
        }

        if ( IsChunkEncoding() && !(HaveReadFileExData()))
        {

            PERF_LOG(PE_TRACE, 0x6119);

            LPSTR lpszNewBuffer;
            DWORD dwNewBufferLength;
            DWORD dwBytesJustRead = (fsm.m_dwBytesRead - fsm.m_nBytes);

            error = _ctChunkInfo.ParseChunkInput(
                (((LPSTR) fsm.m_lpBuffer) + fsm.m_nBytesCopied),
                (fsm.m_dwBytesRead - fsm.m_nBytesCopied),
                &lpszNewBuffer,
                &dwNewBufferLength
                );

            //
            // hack - wait for more data
            //

            if ((error == ERROR_SUCCESS)
            && (dwNewBufferLength == 0)
            && !IsChunkedEncodingFinished()
            && (fsm.m_nBytesCopied == 0)) {

                PERF_LOG(PE_TRACE, 0x6120);

                fsm.m_dwBufferLeft += fsm.m_dwBytesRead;
                fsm.m_dwBytesRead = 0;

                struct fd_set read_fds;
                struct fd_set write_fds;
                struct fd_set except_fds;

                FD_ZERO(&read_fds);
                FD_ZERO(&write_fds);
                FD_ZERO(&except_fds);

                FD_SET(_Socket->GetSocket(), &read_fds);

                struct timeval to;

                to.tv_sec = 30;
                to.tv_usec = 0;
                int n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
                goto read_again;
            }

            fsm.m_dwBufferLeft += (fsm.m_dwBytesRead - fsm.m_nBytesCopied);
            fsm.m_dwBytesRead  -= (fsm.m_dwBytesRead - fsm.m_nBytesCopied);

            fsm.m_dwBufferLeft -= dwNewBufferLength;
            fsm.m_dwBytesRead  += dwNewBufferLength;
            fsm.m_nBytesCopied += dwNewBufferLength;

            INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.

            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            if ( IsChunkedEncodingFinished() )
            {
                fsm.m_bEof = TRUE;
            }
        }
    } else {

        PERF_LOG(PE_TRACE, 0x6121);

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("error %d on socket %#x\n",
                    error,
                    _Socket->GetSocket()
                    ));

        //
        // socket error
        //

        SetState(HttpRequestStateError);

        //
        // cause connection to be closed/released
        //

        fsm.m_bEof = TRUE;
    }

done:

    //
    // only update bytes remaining, EOF and the current stream position values
    // if we're returning data. If we just completed reading ReadFileEx data
    // then don't update. The 1 byte of ReadFileEx data will be read on the next
    // read proper
    //

    if (HaveReadFileExData()) {
        goto quit;
    }

    //
    // whether the data came from the response buffer or the socket, if we have
    // a content-length, update the amount of data left to retrieve
    //

    if (IsChunkEncoding()
        && IsChunkedEncodingFinished()
        && (_QueryBytesAvailable == 0)
        && (BufferDataAvailToRead() == 0)) {
        fsm.m_bEof = TRUE;
    } else if (IsKeepAlive() && IsContentLength()) {
        _BytesRemaining -= fsm.m_dwBytesRead;

        INET_ASSERT((int)_BytesRemaining >= 0);
        //
        // if we have read all the entity-body then we can release the keep-alive
        // connection, or close the socket
        //

        if (_BytesRemaining<=0 && ((int)_BytesRemaining>=-2)) {
            // We might overshoot by 1 or 2 because of server misinformation.
            fsm.m_bEof = TRUE;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("read %d bytes\n",
                fsm.m_dwBytesRead
                ));

    _dwCurrentStreamPosition += fsm.m_dwBytesRead;

    //
    // if we reached the end of the connection - either the end of the server
    // connection for real, or we received all indicated data on a keep-alive
    // connection - then close the connection
    //

    if (fsm.m_bEof) {

        PERF_LOG(PE_TRACE, 0x6122);

        //
        // if we don't need to keep hold of the connection, release it. In the
        // case of multi-part authentication (NTLM) over keep-alive connection
        // we need to keep the connection. With Kerberos, we don't need to keep
        // the connection.
        //

        if (GetAuthState() != AUTHSTATE_CHALLENGE) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("end of data - freeing connection %#x (Auth State = %s)\n",
                        _Socket ? _Socket->GetSocket() : 0,
                        InternetMapAuthState(GetAuthState())
                        ));
            if (!((GetStatusCode() == 407) && IsKeepAlive()))
                CloseConnection(FALSE);

        } else {

            // AUTHSTATE_CHALLENGE - check if request is through proxy or is kerberos.

            // When IsRequestUsingProxy returns TRUE, there are three types of connections possible:
            // 1) http request forwarded by the proxy to the server
            // 2) connect request to proxy to establish https tunnel
            // 3) using https tunnel through proxy to the server

            // I believe the various methods return:
            // http conn. tunnel
            // IsRequestUsingProxy                          1 1 1
            // IsViaProxy                       1 1 0
            // IsTunnel 0   1 0
            // IsTalkingToSecureServerViaProxy 0 0 1

            INET_ASSERT(_pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_NEGOTIATE);

            if (GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - kerberos and auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }                
            else if (IsRequestUsingProxy()
                && !(IsTunnel() || IsTalkingToSecureServerViaProxy())
                && (_pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED)
                && !_pAuthCtx->_fIsProxy)
            {
                // Ordinarily, if the auth state is AUTHSTATE_CHALLENGE we wish to keep
                // the current connection open (keep alive) so that the response will go
                // out on the same socket. NTLM, which requires keep-alive, does not
                // work when going through a proxy. DPA on the other hand can work through
                // a proxy. In the case that the proxy does not return keep-alive with the
                // challenge (Catapult appears to be the only proxy that does) we want to
                // close the socket to ensure that it is not subsequently used for the response.

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }
            else
            {
                //  Keep alive required - don't close socket.
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("not freeing connection - auth state challenge\n"
                            ));
            }

        }

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

quit:

    //
    // update the amount of data returned then we're outta here
    //

    *fsm.m_lpdwNumberOfBytesRead = fsm.m_dwBytesRead;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

quit_pending:

    PERF_LOG(PE_TRACE, 0x6002);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines how much data is available to be read by the caller

    BUGBUG - need cache case

Arguments:

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_INTERNET_INCORRECT_HANDLE_STATE

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable",
                 "%#x",
                 lpdwNumberOfBytesAvailable
                 ));

    DWORD error = DoFsm(new CFsm_HttpQueryAvailable(lpdwNumberOfBytesAvailable,
                                                    this
                                                    ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpQueryAvailable::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpQueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpQueryAvailable * stateMachine = (CFsm_HttpQueryAvailable *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm(
    IN CFsm_HttpQueryAvailable * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpQueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD bytesAvailable = 0;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto fsm_continue;
    }

    INET_ASSERT(fsm.GetState() == FSM_STATE_INIT);

    if (IsReadRequest()) {
        *fsm.m_lpdwNumberOfBytesAvailable = 0;
        if (_Socket != NULL) {

            //
            // Invoked ReadLoop fsm only if the read and write positions
            // are different, otherwise older code is more efficient.
            //
            error = DoFsm (new CFsm_ReadLoop (this, 0, NULL, 1, NULL));

            if (error == ERROR_SUCCESS) {
                *fsm.m_lpdwNumberOfBytesAvailable = AvailableDataLength();
            }
        } else {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
        goto done;
    }

    //
    // the handle must be readable
    //

    if (!IsValidHttpState(READ)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    fsm.m_bEof = FALSE;

    //
    // error must be ERROR_SUCCESS - we just read it out of FSM & didn't jump
    // anywhere
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // first check if there is data to receive at all
    //

    if (IsData()) {

        //
        // if there's buffered data still available from receiving the headers,
        // then return that length, else query the information from the socket
        //

        if (IsBufferedData()) {
            bytesAvailable = BufferDataAvailToRead();

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("%d bytes available in buffer\n",
                        bytesAvailable
                        ));

        } else if (_Socket != NULL) {

            //
            // the rest of the data must be read from the socket
            //

            BOOL checkSocket;

            if (IsKeepAlive() && IsContentLength()) {
                checkSocket = ((int)_BytesInSocket > 0) ? TRUE : FALSE;
            } else if (IsChunkEncoding()) {
                checkSocket = !IsChunkedEncodingFinished();
            } else {
                checkSocket = TRUE;
            }
            if (checkSocket) {
                if (_QueryBuffer != NULL) {
                    bytesAvailable = _QueryBytesAvailable;
                    checkSocket = (bytesAvailable == 0) ? TRUE : FALSE;
                } else {
                    error = _Socket->AllocateQueryBuffer(&_QueryBuffer,
                                                         &_QueryBufferLength
                                                         );
                    if (error != ERROR_SUCCESS) {
                        checkSocket = FALSE;
                    }
                }
            } else if (IsKeepAlive() && IsContentLength() && (_BytesRemaining == 0)) {
                fsm.m_bEof = TRUE;
            } else if (IsChunkEncoding() && IsChunkedEncodingFinished()) {
                fsm.m_bEof = TRUE;
            }
            if (checkSocket) {

                INET_ASSERT(_Socket->IsValid());
                INET_ASSERT(_QueryBytesAvailable == 0);

                //
                // reset the query buffer offset
                //

                _QueryOffset = 0;

                //
                // don't create another FSM just for the DataAvailable2 wrapper.
                // If it ever becomes more than a call to Receive() then create
                // an FSM
                //

read_again:

                fsm.m_lpBuffer = _QueryBuffer;
                fsm.m_dwBufferLength = (IsKeepAlive() && IsContentLength())
                                     ? min(_BytesRemaining, _QueryBufferLength)
                                     : _QueryBufferLength;
                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;

                //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

                if (IsBadNSServer() && !IsConnCloseResponse()) {
                    SetBadNSReceiveTimeout();
                }

                error = _Socket->Receive(&fsm.m_lpBuffer,
                                         &fsm.m_dwBufferLength,
                                         &fsm.m_dwBufferLeft, // don't care about this
                                         &_QueryBytesAvailable,
                                         0,
                                         0,
                                         &fsm.m_bEof
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

fsm_continue:

                if ((error == ERROR_INTERNET_TIMEOUT) && IsBadNSServer()) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("Bad NS server: Closing connection %#x/%d on timeout\n",
                                _Socket ? _Socket->GetSocket() : -1,
                                _Socket ? _Socket->GetSourcePort() : -1
                                ));

                    CloseConnection(TRUE);
                    _QueryBytesAvailable = 0;
                    error = ERROR_SUCCESS;
                }
                if (error == ERROR_SUCCESS) {


                    //if ( IsChunkEncoding() )
                    if ( IsChunkEncoding() && (_QueryBytesAvailable != 0))
                    {
                        LPSTR lpszNewBuffer;
                        DWORD dwNewBufferLength = 0;

                        error = _ctChunkInfo.ParseChunkInput(
                            (LPSTR) _QueryBuffer,
                            _QueryBytesAvailable,
                            &lpszNewBuffer,
                            &dwNewBufferLength
                            );

                        _QueryBytesAvailable = dwNewBufferLength;

                        INET_ASSERT(error == ERROR_SUCCESS); // I want to see this.

                        if ( error != ERROR_SUCCESS )
                        {
                            goto quit;
                        }

                        //
                        // hack - wait for more data
                        //

                        if ((dwNewBufferLength == 0) && !IsChunkedEncodingFinished()) {

                            struct fd_set read_fds;
                            struct fd_set write_fds;
                            struct fd_set except_fds;

                            FD_ZERO(&read_fds);
                            FD_ZERO(&write_fds);
                            FD_ZERO(&except_fds);

                            FD_SET(_Socket->GetSocket(), &read_fds);

                            struct timeval to;

                            to.tv_sec = 30;
                            to.tv_usec = 0;
                            int n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
                            if (n > 0) {
                                goto read_again;
                            }
                        }
                    }


                    bytesAvailable = _QueryBytesAvailable;

                    //
                    // note the amount of data that is available immediately.
                    // This allows e.g. async InternetReadFile() to complete
                    // synchronously if the next request is for <= bytesAvailable
                    //

                    //SetAvailableDataLength(bytesAvailable);

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("%d bytes available in socket %#x\n",
                                bytesAvailable,
                                (_Socket ? _Socket->GetSocket() : 0)
                                ));

                    if ((bytesAvailable == 0)
                    && (IsChunkEncoding() ? IsChunkedEncodingFinished() : TRUE)) {
                        fsm.m_bEof = TRUE;
                    }
                    if (IsKeepAlive() && IsContentLength()) {
                        _BytesInSocket -= bytesAvailable;

                        INET_ASSERT((int)_BytesInSocket >= 0);

                        if ((int)_BytesInSocket < 0) {
                            _BytesInSocket = 0;
                        }
                    }
                }
            }
        } else {

            //
            // all data read from socket & socket released
            //

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(bytesAvailable == 0);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
    } else {

        INET_ASSERT(error == ERROR_SUCCESS);

        //
        // we may have already removed all the data from the socket
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("all data has been read\n"
                    ));

        fsm.m_bEof = TRUE;
    }

quit:

    if ((error == ERROR_SUCCESS) && (bytesAvailable == 0)) {
        if (IsCacheWriteInProgress()) {
            LocalEndCacheWrite(TRUE);
        }
    }

    *fsm.m_lpdwNumberOfBytesAvailable = bytesAvailable;

    //
    // if we have reached the end of the data then we can release the connection
    //

    /*
    if (fsm.m_bEof || (bytesAvailable >= _BytesRemaining)) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }
    */
    if (fsm.m_bEof) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse(
    OUT LPBOOL lpbDrained
    )

/*++

Routine Description:

    Receives any remaining response data into the buffer we allocated for the
    headers. Used in redirection: if the server returns some HTML page (e.g.)
    with the redirection response, we give the app a chance to read it. This
    way, we allow the app to retrieve the data immediately during the status
    callback in which we indicate that the request has been redirected

Arguments:

    lpbDrained  - TRUE if we really drained the socket else FALSE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to ERROR_INTERNET_XXX

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse",
                 "%#x",
                 lpbDrained
                 ));

    DWORD error = DoFsm(new CFsm_DrainResponse(lpbDrained, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_DrainResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_DrainResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_DrainResponse * stateMachine = (CFsm_DrainResponse *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->DrainResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm(
    IN CFsm_DrainResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_DrainResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL drainIt = FALSE;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        drainIt = TRUE;
        goto fsm_continue;
    }

    PERF_LOG(PE_TRACE, 0x8001);

    drainIt = TRUE;

    //
    // if the socket is already closed, we can't drain it
    //

    if ((_Socket == NULL) || !_Socket->IsValid()) {
        drainIt = FALSE;
    } else if (IsWantKeepAlive()) {

        //
        // IIS 1.0 has a bug where it can return a failure indication to a
        // request that was made using a keep-alive connection. The response
        // doesn't contain a keep-alive header but the server has left open the
        // connection AND it has returned us fewer bytes than was claimed in
        // the content-length header. If we try to drain the response buffer at
        // this point, we will wait a long time waiting for the server to send
        // us the non-existent additional bytes. Therefore, if we are talking
        // to an IIS 1.0 server, we don't drain the response buffer
        //

        LPSTR lpszServerBuf;
        DWORD serverBufferLength;

        _ResponseHeaders.LockHeaders();

        error = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                        (LPVOID *)&lpszServerBuf,
                                        &serverBufferLength,
                                        0
                                        );
        if (error == ERROR_SUCCESS) {

#define IIS         "Microsoft-IIS/"
#define IIS_LEN     (sizeof(IIS) - 1)

#define PWS         "Microsoft-PWS/"
#define PWS_LEN     (sizeof(PWS) - 1)

#define PWS95       "Microsoft-PWS-95/"
#define PWS95_LEN   (sizeof(PWS95) - 1)

#define IIS10       "Microsoft-Internet-Information-Server/"
#define IIS10_LEN   (sizeof(IIS10) - 1)

            if ((serverBufferLength > IIS_LEN)
                && !strnicmp(lpszServerBuf, IIS, IIS_LEN)) {

                int major_num = 0;

                for (DWORD i = IIS_LEN; i < serverBufferLength; ++i) {

                    char ch = lpszServerBuf[i];

                    if (isdigit(ch)) {
                        major_num = major_num * 10 + (int)(ch - '0');
                    } else {
                        break;
                    }
                }
                if (major_num < 4) {
                    drainIt = FALSE;
                }
            } else if (IsBadNSServer()) {
                drainIt = FALSE;
            } else if (((serverBufferLength > IIS10_LEN)
                        && !strncmp(lpszServerBuf, IIS10, IIS10_LEN))
                       || ((serverBufferLength > PWS_LEN)
                           && !strncmp(lpszServerBuf, PWS, PWS_LEN))
                       || ((serverBufferLength > PWS95_LEN)
                           && !strncmp(lpszServerBuf, PWS95, PWS95_LEN))) {
                drainIt = FALSE;
            }
        }
        _ResponseHeaders.UnlockHeaders();
    }

    error = ERROR_SUCCESS;

    if (drainIt) {

        fsm.m_dwAsyncFlags = IsAsyncHandle() ? SF_WAIT : 0;
        fsm.m_dwAmountToRead = IsContentLength() ? _BytesInSocket : (DWORD)-1;
        //DWORD bufferLeft = _ResponseBufferLength - _BytesReceived;
        fsm.m_dwBufferLeft = min(fsm.m_dwAmountToRead, _ResponseBufferLength - _BytesReceived);

        if (IsChunkEncoding() && IsChunkedEncodingFinished()) {
            fsm.m_dwAmountToRead = 0;
            fsm.m_bEof = TRUE;

            INET_ASSERT(fsm.m_dwBytesReceived == 0);

        }

        //
        // either receive the amount specified in the "Content-Length" header, or
        // receive until we hit the end of the connection. We may have already
        // received the entire response
        //

        while ((fsm.m_dwAmountToRead != 0) && !fsm.m_bEof && (error == ERROR_SUCCESS)) {

            fsm.m_dwPreviousBytesReceived = _BytesReceived;

            //
            // receive the rest of the data. We are assuming here that it is a
            // couple of K at the most. Notice that we don't care to make status
            // callbacks to the app while we are doing this
            //

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                     &_ResponseBufferLength,
                                     &fsm.m_dwBufferLeft,
                                     &_BytesReceived,
                                     0,   // dwExtraSpace
                                     SF_EXPAND
                                     | SF_COMPRESS
                                     | fsm.m_dwAsyncFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

fsm_continue:

            if (error == ERROR_SUCCESS) {

                DWORD nRead = _BytesReceived - fsm.m_dwPreviousBytesReceived;

                if (IsContentLength()) {
                    fsm.m_dwAmountToRead -= nRead;

                    INET_ASSERT((int)fsm.m_dwAmountToRead >= 0);

                    _BytesInSocket -= nRead;

                    INET_ASSERT((int)_BytesInSocket >= 0);

                    if (IsKeepAlive()) {
                        _BytesRemaining -= nRead;

                        INET_ASSERT((int)_BytesRemaining >= 0);

                        //
                        // if we have read all the entity-body then we can
                        // release the keep-alive connection, or close the
                        // socket
                        //

                        //
                        // BUGBUG - put back post-ie30a
                        //

                        //if (_BytesRemaining == 0) {
                        //    fsm.m_bEof = TRUE;
                        //}
                    }
                }

                if ( IsChunkEncoding() )
                {
                    LPSTR lpszNewBuffer;
                    DWORD dwNewBufferLength;

                    INET_ASSERT(!IsContentLength());

                    error = _ctChunkInfo.ParseChunkInput(
                        (LPSTR) (_ResponseBuffer + fsm.m_dwPreviousBytesReceived),
                        nRead,
                        &lpszNewBuffer,
                        &dwNewBufferLength
                        );

                    nRead = dwNewBufferLength;
                    _BytesReceived = nRead + fsm.m_dwPreviousBytesReceived;

                    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                    if ( error != ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( IsChunkedEncodingFinished() )
                    {
                        fsm.m_bEof = TRUE;
                        break;
                    }
                }

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwPreviousBytesReceived = _BytesReceived;
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // update the amount of data immediately available to the caller
        //

        IncreaseAvailableDataLength(fsm.m_dwBytesReceived);

        //
        // and set the end-of-file indication in the top level handle object
        //

        SetEndOfFile();

        //
        // there is no more data to be received on this HTTP object
        //

        //SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

    //
    // return indication that we drained the socket
    //

    DEBUG_PRINT(HTTP,
                INFO,
                ("returning *lpbDrained = %B\n",
                drainIt
                ));

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        *fsm.m_lpbDrained = drainIt;
    }

    PERF_LOG(PE_TRACE, 0x8002);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout(
    VOID
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout",
                 NULL
                 ));

    if ((_Socket != NULL)
        && !IsContentLength()
        && !IsChunkEncoding()) {

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo) {

            DWORD timeout = max(5000, 5 * pServerInfo->GetRTT());

            _Socket->SetTimeout(RECEIVE_TIMEOUT, timeout);
            SetTimeout(INTERNET_OPTION_RECEIVE_TIMEOUT, timeout);
        }
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\request.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Contains HTTP utility functions

    Contents:
        pHttpGetUrlLen
        pHttpGetUrlString
        pHttpBuildUrl

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine finds the length of an HTTP URL from targethostname
    port and the object and returns the length

Arguments:

    SchemeType      - type of scheme for URL

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port (if not default)

    lpdwUrlLen      - returned URL length

Return Value:

    DWORD

--*/

{
    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {
        return ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

    int portLen;

    *lpdwUrlLen = 0;

    if (dwPort) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);
        
        portLen = lstrlen(TcpipPortString);
    } else {
        portLen = 0;
    }

    *lpdwUrlLen = schemeLength
                + sizeof("://")
                + portLen
                + lstrlen(lpszTargetName)
                + lstrlen(lpszObjectName)
                ;

    return ERROR_SUCCESS;
}

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an HTTP URL constructed
    from the TargetHost, the ObjectName and the port. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      -
    lpszTargetName  -
    lpszCWD         -
    lpszObjectName  -
    lpszExtension   -
    dwPort          -
    lplpUrlName     -
    lpdwUrlLen      -

Return Value:

    DWORD

--*/

{
    DWORD dwError, dwSav, i;
    URL_COMPONENTS sUrlComp;
    char *pBuff = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH);

    if (pBuff == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpszCWD == NULL);

    *lplpUrlName = NULL;

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = SchemeType;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = lpszObjectName;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = INTERNET_MAX_URL_LENGTH;

    if(!InternetCreateUrl(&sUrlComp, 0, pBuff, &dwSav)){
        dwError = GetLastError();
        goto Cleanup;
    }

    // BUGBUG, this is because InternetCreateUrl is not returning
    // the correct size

    dwSav = strlen(pBuff)+5;

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(pBuff, *lplpUrlName, &dwSav, ICU_ENCODE_SPACES_ONLY)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (pBuff) {
        FREE_MEMORY(pBuff);
    }

    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    )

/*++

Routine Description:

    This routine builds an HTTP URL in the buffer passed. If the size is not
    enough it returns ERROR_INSUFFICIENT_BUFFER.

Arguments:

    SchemeType      - type of scheme - http, gopher, etc.

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port number (if not default)

    lpszUrl         - place to write URL

    lpdwBuffSize    - IN: size of lpszUrl buffer
                      OUT: size of URL written to lpszUrl

Return Value:

    DWORD

--*/

{
    DWORD dwBuffLen;
    DWORD error;

    error = pHttpGetUrlLen(SchemeType,
                           lpszTargetName,
                           lpszObjectName,
                           dwPort,
                           &dwBuffLen
                           );
    if (error != ERROR_SUCCESS) {
        return error;
    }
    if (dwBuffLen > *lpdwBuffSize) {
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {

        //
        // should never happen
        //

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

    LPSTR p = lpszUrl;
    int len;
    int urlLength;

    memcpy((LPVOID)p, (LPVOID)schemeName, schemeLength);
    p += schemeLength;
    urlLength = schemeLength;

    memcpy((LPVOID)p, (LPVOID)"://", sizeof("://") - 1);
    p += sizeof("://") - 1;
    urlLength += sizeof("://") - 1;

    len = lstrlen(lpszTargetName);
    memcpy((LPVOID)p, (LPVOID)lpszTargetName, len);
    p += len;
    urlLength += len;

    if (dwPort && (dwPort != INTERNET_DEFAULT_HTTP_PORT)) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);

        INET_ASSERT(TcpipPortString[0] != '\0');

        *p++ = ':';
        len = lstrlen(TcpipPortString);
        memcpy((LPVOID)p, (LPVOID)TcpipPortString, len);
        p += len;
        urlLength += len + 1;
    }

    len = lstrlen(lpszObjectName);
    memcpy((LPVOID)p, (LPVOID)lpszObjectName, len);
    urlLength += len;

    *lpdwBuffSize = urlLength;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\response.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    This file contains the HTTP Request Handle Object ReceiveResponse method

    Contents:
        CFsm_ReceiveResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (1 K)

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_ReceiveResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReceiveResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReceiveResponse * stateMachine = (CFsm_ReceiveResponse *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReceiveResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm(
    IN CFsm_ReceiveResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
#if INET_DEBUG
//#define RLF_TEST_CODE
#ifdef RLF_TEST_CODE

//
// single 100 response
//

#define TEST_HEADER_0   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n"

//
// single 100 header
//

#define TEST_HEADER_1   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// continue header with moderate amount of data
//

#define TEST_HEADER_2   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Content-Length: 128\r\n" \
                        "Content-Type: octet/shmoctet\r\n" \
                        "\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef"

//
// continue header seen from apache server
//

#define TEST_HEADER_3   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n" \
                        "\n\n\n\n\n"

//
// multiple continue headers, no data
//

#define TEST_HEADER_4   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// single 100 response, preceeded by preamble and containing a chunked response
//

#define TEST_HEADER_5   "!!!! this is a pre-amble, should be ignored even though it includes HTTP !!!!" \
                        "     " \
                        "HTTP/1.1 100 Go ahead punk, make my day\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0010 this is the first chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "  10; this is the second chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "00F3\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "012" \
                        "\r\n" \
                        "0000; the final chunk\r\n" \
                        "\r\n" \
                        "Entity-Header: this is the chunk footer\r\n" \
                        "\r\n"

//
// enpty chunk encoded response with empty footer
//

#define TEST_HEADER_6   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0\r\n" \
                        "\r\n" \
                        "\r\n"

    const struct {LPSTR ptr; DWORD len;} test_cases[] = {
        TEST_HEADER_0, sizeof(TEST_HEADER_0) - 1,
        TEST_HEADER_1, sizeof(TEST_HEADER_1) - 1,
        TEST_HEADER_2, sizeof(TEST_HEADER_2) - 1,
        TEST_HEADER_3, sizeof(TEST_HEADER_3) - 1,
        TEST_HEADER_4, sizeof(TEST_HEADER_4) - 1,
        TEST_HEADER_5, sizeof(TEST_HEADER_5) - 1,
        TEST_HEADER_6, sizeof(TEST_HEADER_6) - 1
    };
    DWORD test_index = 99;

#endif // def RLF_TEST_CODE
#endif // INET_DEBUG

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(ReceiveResponse_Fsm);

    CFsm_ReceiveResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();

    if (error != ERROR_SUCCESS) {

        if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED) {

            if ((_Socket != NULL) && _Socket->IsSecure())
            {
                if(m_pSecurityInfo)
                {
                    /* SCLE ref */
                    m_pSecurityInfo->Release();
                }
                /* SCLE ref */
                m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            }

            SetState(HttpRequestStateOpen);
            CloseConnection(TRUE);
            fsm.SetDone();
            goto quit2;
        }

        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    do {
        switch (state) {
        case FSM_STATE_INIT:
            if (_ResponseBuffer == NULL) {
                _ResponseBufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
                _ResponseBuffer = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED,
                                                          _ResponseBufferLength);
                if (_ResponseBuffer == NULL) {
                    _ResponseBufferLength = 0;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            INET_ASSERT(_BytesReceived == 0);

            fsm.m_dwResponseLeft = _ResponseBufferLength;
            state = FSM_STATE_2;

            //
            // fall through
            //

#ifdef RLF_TEST_CODE

            InternetGetDebugVariable("WininetTestIndex", &test_index);
            if (test_index < ARRAY_ELEMENTS(test_cases)) {
                _BytesReceived = test_cases[test_index].len;
                memcpy(_ResponseBuffer, test_cases[test_index].ptr, _BytesReceived);
                fsm.m_dwResponseLeft = _ResponseBufferLength - _BytesReceived;
            }

#endif // def RLF_TEST_CODE

        case FSM_STATE_2:

            //
            // we will allow Receive() to expand the buffer (and therefore initially
            // allocate it), and to compress the buffer if we receive the end of the
            // connection. It is up to UpdateResponseHeaders() to figure out when
            // enough data has been read to indicate end of the headers
            //

            fsm.SetFunctionState(FSM_STATE_3);

            INET_ASSERT(_Socket != NULL);

            if (_Socket != NULL) {
                error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                         &_ResponseBufferLength,
                                         &fsm.m_dwResponseLeft,
                                         &_BytesReceived,
                                         0,
                                         SF_EXPAND
                                         | SF_COMPRESS
                                         | SF_INDICATE,
                                         &fsm.m_bEofResponseHeaders
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto quit;
                }
            } else {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }

            //
            // fall through
            //

        case FSM_STATE_3:

            //
            // if we are using a keep-alive connection that was previously timed-out
            // by the server, we may not find out about it until now
            //
            // Note: it seems we can get a zero length response at this point also,
            // which I take to mean that the server-side socket has been closed
            //

            INET_ASSERT(_BytesReceived <= _ResponseBufferLength);

            if ((error != ERROR_SUCCESS)
            || ((_BytesReceived == 0) && IsKeepAlive())) {

                //
                // We need to reset the state if we got a
                // certificate request.
                //

                if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED) {

                    if ((_Socket != NULL) && _Socket->IsSecure())
                    {
                        if(m_pSecurityInfo)
                        {
                            /* SCLE ref */
                            m_pSecurityInfo->Release();
                        }
                        /* SCLE ref */
                        m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                    }

                    SetState(HttpRequestStateOpen);
                }
                CloseConnection(TRUE);
                goto quit;
            }

            //
            // if we received no data then the server has closed the connection
            // already
            //

            if (_BytesReceived != 0) {

                BOOL bHaveFinalResponse;

                do {
                    bHaveFinalResponse = TRUE;
                    error = UpdateResponseHeaders(&fsm.m_bEofResponseHeaders);
//if (!(rand() % 7)) {
//    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
//}
                    if (error != ERROR_SUCCESS) {
//dprintf("UpdateResponseHeaders() returns %d\n", error);
                        break;
                    }

                    DWORD statusCode;

                    statusCode = GetStatusCode();

                    //
                    // receive next packet if we didn't get a status code yet
                    //

                    if (statusCode == 0) {
                        break;
                    }

                    //
                    // discard any 1xx responses and get the headers again
                    //

                    if (fsm.m_bEofResponseHeaders
                    && (statusCode >= HTTP_STATUS_CONTINUE)
                    && (statusCode < HTTP_STATUS_OK)) {
                        bHaveFinalResponse = FALSE;
                        fsm.SetFunctionState(FSM_STATE_4);

                        //
                        // get any data that came with the header
                        //

                        fsm.m_bDrained = FALSE;
                        if (IsContentLength() && (_BytesInSocket != 0)) {
                            error = DrainResponse(&fsm.m_bDrained);
                            if (error != ERROR_SUCCESS) {
                                goto quit;
                            }
                        }

                        //
                        // fall through
                        //

        case FSM_STATE_4:

                        //
                        // now that we have drained the socket, we can indicate
                        // the response to the app. This gives apps chance to
                        // perform progress reporting for each 100 response
                        // received, e.g.
                        //

                        InternetIndicateStatus(INTERNET_STATUS_INTERMEDIATE_RESPONSE,
                                               &statusCode,
                                               sizeof(statusCode)
                                               );

                        //
                        // if there is no more data left in the buffer then we
                        // can receive the next response at the start of the
                        // buffer, else continue from where the previous one
                        // ended
                        //

                        if (fsm.m_bDrained || !IsBufferedData()) {
                            fsm.m_dwResponseLeft = _ResponseBufferLength;
                            _BytesReceived = 0;
                            _DataOffset = 0;
                            _ResponseScanned = 0;
                        } else {
                            _ResponseScanned = _DataOffset;
                            if (IsContentLength()) {
                                _ResponseScanned += _ContentLength;
                            }
                            //if (IsChunkEncoding()) {
                            //
                            //    LPSTR lpszNewBuffer;
                            //    DWORD dwNewBufferLength;
                            //
                            //    error = _ctChunkInfo.ParseChunkInput(
                            //        (LPSTR) BufferedDataStart(),
                            //        BufferedDataLength(),
                            //        &lpszNewBuffer,
                            //        &dwNewBufferLength
                            //        );
                            //
                            //    _ResponseBufferDataReadyToRead = dwNewBufferLength;
                            //
                            //    INET_ASSERT(error == ERROR_SUCCESS);
                            //    if ( error != ERROR_SUCCESS )
                            //    {
                            //        goto quit;
                            //    }
                            //}
                            //if (IsChunkEncoding()) {
                            //
                            //    LPSTR lpszNewBuffer;
                            //    DWORD dwNewBufferLength;
                            //    DWORD nRead = 0;
                            //
                            //    INET_ASSERT(!IsContentLength());
                            //
                            //    error = _ctChunkInfo.ParseChunkInput(
                            //        (LPSTR) (_ResponseBuffer + _DataOffset),
                            //        nRead,
                            //        &lpszNewBuffer,
                            //        &dwNewBufferLength
                            //        );
                            //
                            //    nRead = dwNewBufferLength;
                            //    _BytesReceived = nRead + _DataOffset;
                            //
                            //    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                            //    if ( error != ERROR_SUCCESS )
                            //    {
                            //        break;
                            //    }
                            //
                            //    if ( IsChunkedEncodingFinished() )
                            //    {
                            //        break;
                            //    }
                            //}
                        }
                        _ResponseHeaders.FreeHeaders();
                        _ResponseHeaders.Initialize();
                        ZapFlags();
                        _ContentLength = 0;
                        _BytesRemaining = 0;
                        _BytesInSocket = 0;
                        fsm.m_bEofResponseHeaders = FALSE;
                        if (_DataOffset == 0) {

                            //
                            // need to read next response - nothing left in
                            // buffer
                            //

                            break;
                        }
                    }

                    // If we have a server authentication context
                    // and the response is anything but 401, mark
                    // the socket as authenticated.
                    AUTHCTX *pAuthCtx;
                    pAuthCtx = GetAuthCtx();
                    if (pAuthCtx && !pAuthCtx->_fIsProxy
                        && (statusCode != HTTP_STATUS_DENIED))
                    {

#define MICROSOFT_IIS_SERVER_SZ "Microsoft-IIS/"
#define MICROSOFT_PWS_SERVER_SZ "Microsoft-PWS/"

#define MICROSOFT_IIS_SERVER_LEN (sizeof(MICROSOFT_IIS_SERVER_SZ) - 1)
#define MICROSOFT_PWS_SERVER_LEN (sizeof(MICROSOFT_PWS_SERVER_SZ) - 1)

                        LPSTR pszBuf;
                        DWORD cbBuf;
                        cbBuf = MAX_PATH;
                        if (FastQueryResponseHeader(HTTP_QUERY_SERVER, 
                            (LPVOID*) &pszBuf, &cbBuf, 0) == ERROR_SUCCESS)
                        {
                            if (cbBuf >= MICROSOFT_IIS_SERVER_LEN 
                                && (!strncmp(pszBuf, MICROSOFT_IIS_SERVER_SZ, MICROSOFT_IIS_SERVER_LEN)
                                    || !strncmp(pszBuf, MICROSOFT_PWS_SERVER_SZ, MICROSOFT_PWS_SERVER_LEN)))

                            {                            
                                // Found an IIS header. Mark socket as authenticated if 
                                // IIS 1, 2 or 3. Lengths of both strings are same.
                                CHAR *pVer = pszBuf + MICROSOFT_IIS_SERVER_LEN;
                                if (*pVer == '1'
                                    || *pVer == '2'
                                    || *pVer == '3'
                                    )
                                {
                                    // IIS 1, 2 or 3  - mark dirty.
                                    _Socket->SetAuthenticated();
                                }
                            }                                
                        }
                        else
                        {
                            // Unknown server; may be IIS 1,2 or 3.
                            _Socket->SetAuthenticated();
                        }
                    }

                } while (!bHaveFinalResponse);
            } else {
                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            }

            //
            // set state to perform next receive
            //

            state = FSM_STATE_2;
        }
    } while ((error == ERROR_SUCCESS) && !fsm.m_bEofResponseHeaders);

    //
    // we should update the RTT as soon as we get received data from
    // the socket, but then we'd have to store the RTT in the socket
    // object or access this one, etc. Just keep it here for now -
    // its a reasonable approximation in the normal IE case: not too
    // much time spent in callbacks etc.
    //

    UpdateRTT();
//dprintf("RTT for %s = %d\n", GetURL(), GetRTT());
//dprintf("OS = %s, PS = %s\n", ((GetOriginServer() != NULL) ? GetOriginServer()->GetHostName() : "none"),
//    ((GetServerInfo() != NULL) ? GetServerInfo()->GetHostName() : "none"));

    //
    // we have received the headers and possibly some (or all) of the data. The
    // app can now query the headers and receive the data
    //

    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    if ( IsChunkEncoding() )
    {
        LPSTR lpszNewBuffer;
        DWORD dwNewBufferLength;

        error = _ctChunkInfo.ParseChunkInput(
            (LPSTR) BufferedDataStart(),
            BufferedDataLength(),
            &lpszNewBuffer,
            &dwNewBufferLength
            );

        _ResponseBufferDataReadyToRead = dwNewBufferLength;

        INET_ASSERT(error == ERROR_SUCCESS);
        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    SetAvailableDataLength(BufferDataAvailToRead());

    //
    // IIS caches authentication credentials on keep-alive sockets.
    //

    if (_Socket) {

        if (IsAuthorized()) {
            _Socket->SetAuthorized();
        }

        if (IsPerUserItem()) {
            _Socket->SetPerUser();
        } else if (_Socket->IsPerUser()) {
            SetPerUserItem(TRUE);
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // if we got the socket from the keep-alive pool, but found no keep-
        // alive header then we no longer have a keep-alive connection
        //

        if (_bKeepAliveConnection && !IsKeepAlive()) {
//dprintf("*** %s - NO LONGER K-A socket %#x\n", GetURL(), _Socket->GetSocket());
            SetNoLongerKeepAlive();
        }

        //
        // don't maintain the connection if there's no more data to read. UNLESS
        // we are in the middle of establishing an authenticated connection
        // (implies using keep-alive connection, e.g. NTLM)
        // IsData() returns FALSE if there's no data at all, otherwise we
        // check to see if we have read all the data already (i.e. with the
        // response headers)
        //

        if ((error != ERROR_SUCCESS)
            || (

                //
                // data-less response (ignoring keep-alive & content-length)
                //

                (!IsData()

                 //
                 // all data body in header buffer
                 //

                 || (IsKeepAlive()
                     && IsContentLength()
                     && (BufferedDataLength() == GetContentLength())
                     )
                 )

                //
                // but only if not in the middle of auth negotiation and if the
                // connection hasn't been dropped by the server
                //

                && ((GetAuthState() != AUTHSTATE_NEGOTIATE)
                    || IsNoLongerKeepAlive())

                && (!((GetStatusCode() == 407) && IsKeepAlive()))
                )
            ) {

//dprintf("socket %#x [%#x/%d] error=%d, IsData()=%B, K-A=%B, C-L=%d, BDL=%d, AS=%d\n",
//        _Socket,
//        _Socket ? _Socket->GetSocket() : 0,
//        _Socket ? _Socket->GetSourcePort() : 0,
//        error,
//        IsData(),
//        IsKeepAlive(),
//        GetContentLength(),
//        BufferedDataLength(),
//        GetAuthState()
//        );

            //
            // BUGBUG - if this is a new keep-alive connection?
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("closing: error = %d, IsData() = %B, K-A = %B, IsC-L = %B, BDL = %d, C-L = %d AS=%d [%s]\n",
                        error,
                        IsData(),
                        IsKeepAlive(),
                        IsContentLength(),
                        BufferedDataLength(),
                        GetContentLength(),
                        GetAuthState(),
                        InternetMapAuthState(GetAuthState())
                        ));

            if(GlobalAlwaysDrainOnRedirect || 
                GetStatusCode() != HTTP_STATUS_REDIRECT || 
                (HTTP_METHOD_TYPE_HEAD == GetMethodType()))
            {
                CloseConnection((error != ERROR_SUCCESS) ? TRUE : FALSE);
            }
            else
                DEBUG_PRINT(HTTP, INFO, ("Not closing socket, Status code = %d \n", GetStatusCode()));

            //
            // set the relevant state
            //

            if (error != ERROR_SUCCESS &&
                error != ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED &&
                error != ERROR_INTERNET_INVALID_CA &&
                error != ERROR_INTERNET_SEC_CERT_DATE_INVALID &&
                error != ERROR_INTERNET_SEC_CERT_CN_INVALID )
            {
                SetState(HttpRequestStateError);
            }
        }

        PERF_LEAVE(ReceiveResponse_Fsm);
    }

quit2:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\send.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the HTTP Request Handle Object SendRequest method

    Contents:
        CFsm_SendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_SendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_SendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_SendRequest * stateMachine = (CFsm_SendRequest *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->SendRequest_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm(
    IN CFsm_SendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(SendRequest_Fsm);

    CFsm_SendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPSTR requestBuffer = fsm.m_pRequestBuffer;
    DWORD requestLength = fsm.m_dwRequestLength;
    LPVOID lpOptional = fsm.m_lpOptional;
    DWORD dwOptionalLength = fsm.m_dwOptionalLength;
    BOOL bExtraCrLf = fsm.m_bExtraCrLf;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    switch (state) {

    case FSM_STATE_INIT:

    fsm.SetFunctionState(FSM_STATE_1);
    error = DoFsm(new CFsm_MakeConnection(this));


    case FSM_STATE_1:

        if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        DEBUG_PRINT(
            HTTP,
            INFO,
            ("authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
            );

        // # 62953
        // If initiating MSN or NTLM authentication, don't submit request data since
        // we're expecting to get a challenge and resubmit the request anyway.
        if (GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            if (!((PLUG_CTX*)(GetAuthCtx()))->_fNTLMProxyAuth
                && !(GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
            {
                // We are in the negotiate phase during a POST
                // and do not have an authenticated socket. 
                // In both monolithic upload InternetWriteFile
                // cases, we wish to omit any post data, and reflect
                // this in the content length.
                if (!((GetMethodType() == HTTP_METHOD_TYPE_GET) && !IsMethodBody()))
                {
                    ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                         "0",
                                         1,
                                         0,   // dwIndex
                                         ADD_HEADER
                                         );
                }

                // Monolithic upload: If we have optional data to send,
                // save off in handle and flag that the data has been saved.
                if (fsm.m_lpOptional && fsm.m_dwOptionalLength)
                {
                    DEBUG_PRINT(
                        HTTP,
                        INFO,
                        ("omitting request data due to authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
                        );

                    _lpOptionalSaved = fsm.m_lpOptional;
                    _dwOptionalSaved = fsm.m_dwOptionalLength;
                    fsm.m_lpOptional = lpOptional = NULL;
                    fsm.m_dwOptionalLength = dwOptionalLength = 0;
                    _fOptionalSaved = TRUE;
                }            
            }        
        }
        else
        {
            // Check if optional data has been saved in handle during a previous
            // negotiate stage. If so, restore it and content length and clear flag.
            if (_fOptionalSaved)
            {
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("restoring request data due to authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
                    );

                // Reset the fsm optional values and content length.
                
                lpOptional = fsm.m_lpOptional = _lpOptionalSaved;
                dwOptionalLength = fsm.m_dwOptionalLength = _dwOptionalSaved;
                _dwOptionalSaved = 0;
                _lpOptionalSaved = NULL;
                _fOptionalSaved = FALSE;

                DWORD cbNumber;
                CHAR szNumber[sizeof("4294967295")];
                cbNumber = wsprintf(szNumber, "%d", fsm.m_dwOptionalLength);

                ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                    (LPSTR)szNumber,
                                    cbNumber,
                                    0,   // dwIndex
                                    ADD_HEADER
                                    ); 
            }

        }


        bExtraCrLf = (!(GetOpenFlags() & INTERNET_FLAG_SECURE)
                      && (dwOptionalLength != 0)
                      && ((GetServerInfo() != NULL)
                        ? GetServerInfo()->IsHttp1_0()
                        : IsRequestHttp1_0())
                      && GlobalSendExtraCRLF);

        //
        // collect request headers into blob
        //

        BOOL bCombinedData;

        requestBuffer = CreateRequestBuffer(&requestLength,
                                            lpOptional,
                                            dwOptionalLength,
                                            bExtraCrLf,
                                            GlobalTransportPacketLength,
                                            &bCombinedData
                                            );
        if (requestBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        DEBUG_PRINT(HTTP, INFO, ("SendRequest_FSM: lpOptional=0x%x dwOptionalLength=%d\n", 
                                fsm.m_lpOptional, fsm.m_dwOptionalLength));

        if (bCombinedData) {

            //
            // everything copied to one buffer. No need to send separate
            // optional data and CR-LF termination
            //

            fsm.m_lpOptional = lpOptional = NULL;
            fsm.m_dwOptionalLength = dwOptionalLength = 0;
            bExtraCrLf = FALSE;
        }
        fsm.m_pRequestBuffer = requestBuffer;
        fsm.m_dwRequestLength = requestLength;
        fsm.m_bExtraCrLf = bExtraCrLf;
        DEBUG_PRINT(HTTP, INFO, ("fsm.m_pRequestBuffer=0x%x\r\n", fsm.m_pRequestBuffer));
        StartRTT();

        //
        // send the request. If we are using a keep-alive connection, this may
        // fail because the server timed it out since we last used it. We must
        // be prepared to re-establish
        //

        fsm.SetFunctionState(FSM_STATE_3);
        error = _Socket->Send(requestBuffer, requestLength, SF_INDICATE);

        //
        // fall through
        //

    case FSM_STATE_3:
        if (error != ERROR_SUCCESS) {
            if (error != ERROR_IO_PENDING) {
                CloseConnection(TRUE);
            }
            goto quit;
        }

        //
        // send any optional data (that we didn't send in the request buffer).
        // If this fails then we don't retry. We assume that if the first send
        // succeedeed, but the second failed, then this is a non-recoverable
        // error
        //

        //fsm.m_bExtraCrLf = bExtraCrLf = TRUE;
        if (dwOptionalLength != 0) {

            LPSTR buffer = (LPSTR)lpOptional;
            DWORD length = dwOptionalLength;

            if (bExtraCrLf) {
                length += sizeof(gszCRLF) - 1;
                if (requestLength >= length) {
                    buffer = requestBuffer;
                } else if (length <= GlobalTransportPacketLength) {
                    requestBuffer = (LPSTR)ResizeBuffer(requestBuffer,
                                                        length,
                                                        FALSE
                                                        );
                    buffer = requestBuffer;
                    fsm.m_pRequestBuffer = requestBuffer;
                } else {
                    length -= sizeof(gszCRLF) - 1;
                }
                if (buffer == requestBuffer) {
                    memcpy(buffer, lpOptional, dwOptionalLength);
                    buffer[dwOptionalLength] = '\r';
                    buffer[dwOptionalLength + 1] = '\n';
                    fsm.m_bExtraCrLf = bExtraCrLf = FALSE;
                }
            }
            fsm.SetFunctionState(FSM_STATE_4);
            error = _Socket->Send(buffer, length, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_4:

        //
        // Here we also add an extra CR-LF if the app is sending data (even if
        // the amount of data supplied is zero) unless we are using a keep-alive
        // connection, in which case we're not dealing with old servers which
        // require CR-LF at the end of post data.
        //
        // But only do this for non-HTTP 1.1 servers and proxies ( ie when
        //  the user puts us in HTTP 1.0 mode)
        //

        if ((error == ERROR_SUCCESS) && bExtraCrLf) {
            fsm.SetFunctionState(FSM_STATE_5);
            error = _Socket->Send(gszCRLF, 2, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_5:

        //
        // we are now in receiving state
        //

        if (error == ERROR_SUCCESS) {
            SetState(HttpRequestStateResponse);
        }
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
//dprintf("HTTP connect-send took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        fsm.SetDone();

        PERF_LEAVE(SendRequest_Fsm);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HttpSendRequestA
        HttpSendRequestW
        HttpSendRequestExA
        HttpSendRequestExW
        HttpEndRequestA
        HttpEndRequestW
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest
    );

//
// functions
//


INTERNETAPI_(BOOL) HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST
                );


    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestW",
                "%#x, %.80wq, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    if (lpszHeaders)
    {
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, 0, AR_HTTP_SEND_REQUEST);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) HttpSendRequestExA(
        IN HINTERNET hRequest,
        IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
        OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
        IN DWORD dwFlags,
        IN DWORD_PTR dwContext
        )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersIn     -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    WINAPI

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpSendRequestExA",
                     "%#x, %#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersIn,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD error = ERROR_SUCCESS;
    LPCSTR lpszHeaders = NULL;
    DWORD dwHeadersLength = 0;
    LPVOID lpOptional = NULL;
    DWORD dwOptionalLength = 0;
    DWORD dwOptionalLengthTotal = 0;
    BOOL fRet = FALSE;

    if ( lpBuffersOut )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if ( lpBuffersIn )
    {
        if ( IsBadReadPtr(lpBuffersIn, sizeof(INTERNET_BUFFERSA)) ||
             lpBuffersIn->dwStructSize != sizeof(INTERNET_BUFFERSA) )
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        lpszHeaders           = lpBuffersIn->lpcszHeader;
        dwHeadersLength       = lpBuffersIn->dwHeadersLength;
        lpOptional            = lpBuffersIn->lpvBuffer;
        dwOptionalLength      = lpBuffersIn->dwBufferLength;
                dwOptionalLengthTotal = lpBuffersIn->dwBufferTotal;
    }

    fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwOptionalLengthTotal,
                AR_HTTP_BEGIN_SEND_REQUEST
                );

quit:

    if ( error != ERROR_SUCCESS )
    {
        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        fRet = FALSE;
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpSendRequestExW(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSW lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersIn     -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpSendRequestExW",
                     "%#x, %#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersIn,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;
    LPVOID pOptional = NULL;
    DWORD dwOptionalLength = 0;
    DWORD dwOptionalLengthTotal = 0;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        if ( lpBuffersIn )
        {
            if (IsBadReadPtr(lpBuffersIn, sizeof(INTERNET_BUFFERS))
                ||
                (lpBuffersIn->dwStructSize != sizeof(INTERNET_BUFFERSW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            if (lpBuffersIn->lpcszHeader)
            {
                ALLOC_MB(lpBuffersIn->lpcszHeader, lpBuffersIn->dwHeadersLength, mpHeaders);
                if (!mpHeaders.psStr)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
                UNICODE_TO_ANSI(lpBuffersIn->lpcszHeader, mpHeaders);
            }
            pOptional            = lpBuffersIn->lpvBuffer;
            dwOptionalLength      = lpBuffersIn->dwBufferLength;
            dwOptionalLengthTotal = lpBuffersIn->dwBufferTotal;
        }

        fResult = HttpWrapSendRequest(
                hRequest,
                mpHeaders.psStr,
                mpHeaders.dwSize,
                pOptional,
                dwOptionalLength,
                dwOptionalLengthTotal,
                AR_HTTP_BEGIN_SEND_REQUEST
                );
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) HttpEndRequestA(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    WINAPI

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpEndRequestA",
                     "%#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD error = ERROR_SUCCESS;
    IN LPCSTR lpszHeaders = NULL;
    IN DWORD dwHeadersLength = 0;
    IN LPVOID lpOptional = NULL;
    IN DWORD dwOptionalLength = 0;
    BOOL fRet = FALSE;

    if ( lpBuffersOut )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    fRet= HttpWrapSendRequest(
                hRequest,
                NULL,
                0,
                NULL,
                0,
                0,
                AR_HTTP_END_SEND_REQUEST
                );

quit:

    if ( error != ERROR_SUCCESS )
    {
        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        fRet = FALSE;
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpEndRequestW(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpEndRequestW",
                     "%#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables
    //


    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hRequestMapped)->GetContext()
                        );
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        BOOL fGoneOffline = FALSE;


        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal,
                                       &fGoneOffline
                                       );

        if ( error != ERROR_SUCCESS || fGoneOffline )
        {
            if ( error == ERROR_INTERNET_CACHE_SUCCESS )
            {
                error = ERROR_SUCCESS;
            }

            goto quit;
        }
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(new CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = new CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL) {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread) {
            error = pFsm->QueueWorkItem();
        } else {
            error = DoFsm(pFsm);
        }
        if (error == ERROR_IO_PENDING) {
            bDeref = FALSE;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) {

        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\sendreq.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest
        HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders
        CFsm_HttpSendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish
        HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo
        HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"
#include "autodial.h"

//
// HTTP Request Handle Object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest(
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID *lplpOptional,
    IN LPDWORD lpdwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    OUT LPBOOL pfGoneOffline
    )

/*++

Routine Description:

    Performs Initiatization of the HTTP Request by setting up the necessary
     headers and preparing the POST data.

Arguments:

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total Length for File Upload.

    pfGoneOffline           - Pointer to BOOL that is set to TRUE if durning the course
                            of this call, the connection was forced offline

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - One of the Win32 Error values.

  Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest",
                 "%#x, %d, %d, %#x",
                 lplpOptional ? *lplpOptional : NULL,
                 lpdwOptionalLength ? *lpdwOptionalLength : NULL,
                 dwOptionalLengthTotal,
                 pfGoneOffline
                 ));

    DWORD error = ERROR_SUCCESS;
    LPVOID lpOptional       = *lplpOptional;
    DWORD dwOptionalLength  = *lpdwOptionalLength;

    INET_ASSERT(pfGoneOffline);

    *pfGoneOffline = FALSE;

    //
    // validate parameters
    //

    if ((lpOptional == NULL) || (dwOptionalLength == 0)) {
        lpOptional = NULL;
        dwOptionalLength = 0;
    }

    //
    // the headers lengths can be -1 meaning that we should calculate the
    // string lengths. We must do this before calling MakeAsyncRequest()
    // which is expecting the parameters to be correct
    //

    __try {
        if (dwHeadersLength == -1) {
            dwHeadersLength = lstrlen((LPCSTR)lpszHeaders);
        } else {

            //
            // probe headers
            //

            for (DWORD i = 0; i < dwHeadersLength; ++i) {

                volatile char ch = lpszHeaders[i];

            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the caller specified some additional headers, then add them before
    // we make the request asynchronously
    //

    if (ARGUMENT_PRESENT(lpszHeaders) && (*lpszHeaders != '\0')) {

        //
        // we use the API here because the headers came from the app, and
        // we don't trust it
        //

        if (!HttpAddRequestHeaders(GetPseudoHandle(),
                                   lpszHeaders,
                                   dwHeadersLength,

                                   //
                                   // if the object is being re-used then
                                   // replace the headers to avoid
                                   // duplicating original headers
                                   //

                                   IS_VALID_HTTP_STATE(this, REUSE, TRUE)
                                    ? ( HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD ): 0
                                    //? HTTP_ADDREQ_FLAG_REPLACE : 0
                                   )) {
            error = GetLastError();
            goto quit;
        }
    }

    if (lpOptional && !GetSecondaryCacheKey()) {

        //
        // IE3 compat: set expiration on cache entry, if any, for this URL.
        //

        ExpireUrl();
    }

    //
    // if we are in offline mode or we have transitioned to offline mode
    // AND the caller didn't request RELOAD then allow only non-data GET
    // requests
    //

    BOOL bDisconnected;

    bDisconnected = IsOffline();

    BOOL bOfflineMode;

    bOfflineMode = (((GetInternetOpenFlags() | GetCacheFlags())
                        & INTERNET_FLAG_OFFLINE)
                    || (bDisconnected));

    if( bOfflineMode && _fIgnoreOffline )
        bOfflineMode = FALSE;

    if (  bOfflineMode  )
    {
        *pfGoneOffline = TRUE;

        if ( !GetSecondaryCacheKey()
        && (   (lpOptional != NULL)
            || (GetMethodType() != HTTP_METHOD_TYPE_GET))) {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
    }

    CheckClientRequestHeaders();

    //
    // if there's no data to send then if we're offline then we attempt to
    // retrieve the file from cache
    //

    if ((lpOptional == NULL && dwOptionalLengthTotal == 0) || GetSecondaryCacheKey()) {
        if (bOfflineMode) {
            error = FHttpBeginCacheRetrieval(FALSE, TRUE);
            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_CACHE_SUCCESS;
                goto quit;
            }
            else{
                goto quit;
            }
        } else {
            error = GetFromCachePreNetIO();

            //
            // if we succeeded in getting the file from the cache or we're
            // disconnected then we're done
            //

            if ((error == ERROR_SUCCESS) || bDisconnected)
            {
                if ( error == ERROR_SUCCESS )
                {
                    error = ERROR_INTERNET_CACHE_SUCCESS;
                }
                goto quit;
            }
            else if (error == ERROR_INTERNET_INSERT_CDROM)
            {
                // Check if it's ok to return this error. We do this if the
                // client has indicated it allows ERROR_INTERNET_INSERT_CDROM
                // via InternetSetOption and an insert cdrom dialog is not active.
                if (GetErrorMask() & INTERNET_ERROR_MASK_INSERT_CDROM)
                {
                    if (!(BOOL) InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) TRUE))
                        goto quit;
                }
            }
        }
    }

    //
    // If we fall through then we are connected and a) either the thing
    // is not in the cache or we did a conditional get or c) there was
    // some cache error
    //

    error = ERROR_SUCCESS;

    //
    // if the app supplied a user-agent string to InternetOpen() AND hasn't
    // added a "User-Agent:" header, then add it
    //

    LPSTR userAgent;
    DWORD userAgentLength;

    userAgent = GetUserAgent(&userAgentLength);
    if (userAgent != NULL) {
        ReplaceRequestHeader(HTTP_QUERY_USER_AGENT,
                             userAgent,
                             userAgentLength,
                             0, // dwIndex,
                             ADD_HEADER_IF_NEW
                             );
    }

    //
    // do the same thing with the "Host:" header. The header-value is the host
    // name supplied to InternetConnect() (or the name of the redirected host)
    //

    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;

    hostName = GetHostName(&hostNameLength);
    hostPort = GetHostPort();

    INET_ASSERT((hostName != NULL) && (hostNameLength > 0));

    char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];

    if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
    && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) {
        if (lstrlen(hostName) > INTERNET_MAX_HOST_NAME_LENGTH)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        hostNameLength = wsprintf(hostValue, "%s:%d", hostName, (hostPort & 0xffff));
        hostName = hostValue;
    }
    ReplaceRequestHeader(HTTP_QUERY_HOST,
                         hostName,
                         hostNameLength,
                         0, // dwIndex,
                         ADD_HEADER_IF_NEW
                         );

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    //if (pRequest->GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION) {
    //    pRequest->SetWantKeepAlive(TRUE);
    //}

    //
    // add the content-length header IF we are sending data OR this is a POST,
    // AND ONLY if the app has not already added the header
    //

    if (dwOptionalLength || dwOptionalLengthTotal)
        SetMethodBody();
        
    if (((dwOptionalLength != 0) || (dwOptionalLengthTotal != 0))

    //
    // BUGBUG - just comparing against a method type is insufficient. We need
    //          a test of whether the method implies sending data (PUT, etc).
    //          We make the same test in other places
    //

    || (GetMethodType() != HTTP_METHOD_TYPE_GET)) {

        DWORD dwContentLength;

        char number[sizeof("4294967295")];

        //
        // For File Upload we need to add the Content-Length
        //   header off of the Total Length, Not the current
        //   data size.  Since we get more data via InternetWriteFile
        //

        if ( dwOptionalLengthTotal != 0 )
        {
            dwContentLength = dwOptionalLengthTotal;
        }
        else
        {
            dwContentLength = dwOptionalLength;
        }

        // _itoa(dwOptionalLength, number, 10);
        wsprintf(number, "%d", dwContentLength);

        DWORD numberLength = lstrlen(number);

        /*----------------------------------------------------------------------

        #62953 NOTE --  Authstate can never be in the AUTHSTATE_NEGOTIATE
        state here. It is not necessary to zero out the content length
        header here when omitting post data on NTLM negotiate since this
        will be done later in the request. The commented-out code is not
        necessary.

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
            && (GetAuthState() == AUTHSTATE_NEGOTIATE))
        {

            ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                "0",
                                1,
                                0,   // dwIndex
                                ADD_HEADER
                                );
        }

        ---------------------------------------------------------------------*/

        // Normally we don't over-write the content-length
        // header if one already exists.
        DWORD dwAddHeader;
        dwAddHeader = ADD_HEADER_IF_NEW;

        // But if we're posting data and have an auth ctx
        // over-write the content-length header which will
        // have been reset to 0 to omit post data on the
        // negotiate phase.
        AUTHCTX *pAuthCtx;
        pAuthCtx = GetAuthCtx();
        if (pAuthCtx)
        {
            dwAddHeader = ADD_HEADER;
        }


        ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                            (LPSTR)number,
                            numberLength,
                            0,   // dwIndex
                             dwAddHeader
                            );

    }

quit:

    *lplpOptional       = lpOptional;
    *lpdwOptionalLength = dwOptionalLength;

    DEBUG_LEAVE(error);

    return error;
}


void
HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (IsFirstSendProcessed())
    {
        return; // been there, done that
    }

    SetFirstSendProcessed();

    //
    // record the initial URL for offline mapping in case of redirects
    //

    SetOriginalUrl(GetCacheKey());


    //
    // Disabling cache if OFFLINE flag not set and RELOAD flag set.
    //

    if (    !((GetInternetOpenFlags() | GetCacheFlags()) & INTERNET_FLAG_OFFLINE)
        &&  GetCacheFlags() & INTERNET_FLAG_RELOAD
       )
    {
        SetCacheReadDisabled();
        return;
    }

    //
    // See if the client added any headers that imply caching disabled.
    //

    _RequestHeaders.LockHeaders();
   DWORD Headers[] =
    {
        HTTP_QUERY_IF_MODIFIED_SINCE,
        HTTP_QUERY_IF_NONE_MATCH,
        HTTP_QUERY_RANGE
    };

    DWORD i;
    for (i=0; i<ARRAY_ELEMENTS(Headers); i++)
    {
        if (IsRequestHeaderPresent(Headers[i]))
        {
            SetCacheReadDisabled();
            break;
        }
    }

    _RequestHeaders.UnlockHeaders();
}


DWORD
CFsm_HttpSendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpSendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_HttpSendRequest * stateMachine = (CFsm_HttpSendRequest *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        //
        // Make sure appropriate connection and proxy is in place
        //
        FixProxySettingsForCurrentConnection(FALSE);

        //
        // fall through to FSM_STATE_CONTINUE
        //

    case FSM_STATE_CONTINUE:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Start(stateMachine);
        break;

    case FSM_STATE_FINISH:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Finish(stateMachine);
        break;

    case FSM_STATE_ERROR:

        //CHECK_FSM_OWNED(Fsm);

        error = Fsm->GetError();

        //
        // If we block to call GetProxyInfo async, then
        //  we may get unblocked during a cancel.  We need to
        //   handle it by freeing the object in our destructor.
        //

        INET_ASSERT( (!stateMachine->m_fOwnsProxyInfoQueryObj) ?
                        ( error == ERROR_INTERNET_OPERATION_CANCELLED ||
                          error == ERROR_INTERNET_TIMEOUT )  :
                        TRUE );

        Fsm->SetDone();
        break;

    default:

        //CHECK_FSM_OWNED(Fsm);

        stateMachine->m_fOwnsProxyInfoQueryObj = TRUE;
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    Calls SendData() method in a loop, handling redirects (& authentications?)
    until we have successfully started to retrieve what was originally requested

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Operation completed successfully

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_INTERNET_INCORRECT_HANDLE_STATE
                    The HTTP request handle is in the wrong state for this
                    request

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Start);

    //CHECK_FSM_OWNED(Fsm);

    CFsm_HttpSendRequest & fsm = *Fsm;

    //
    // we must loop here while the server redirects us or while we authenticate
    // the user
    //

    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    //
    // We set m_fOwnsProxyInfoObj TRUE, because by virtue of being here
    //   we have know that we now own the pointer in our fsm, pointed to by
    //   fsm.m_pProxyInfoQuery.
    //
    // This boolean is used to know when we are allowed to FREE and ACCESS
    //   this pointer.  If FALSE, we CANNOT touch this pointer because
    //   the auto-proxy thread may be accessing it.   The auto-proxy thread
    //   will unblock us, this releasing its "un-offical" lock on this pointer.
    //

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if (state == FSM_STATE_INIT)
    {        
        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
        {
            state = FSM_STATE_5;
            fsm.SetFunctionState(FSM_STATE_5);
        }
    }
    else
    {
        state = fsm.GetFunctionState();
    }

retry_send_request:

    do {
        switch (state) {
        case FSM_STATE_INIT:
        case FSM_STATE_1:

            //CHECK_FSM_OWNED(Fsm);
            if (IsHttp1_1())
            {
                fsm.m_iRetries = (GlobalMaxConnectionsPerServer + 1);
            }
            else
            {
                fsm.m_iRetries = (GlobalMaxConnectionsPer1_0Server + 1);
            }

            fsm.m_bAuthNotFinished = FALSE;
            fsm.m_dwCookieIndex = 0;

            //
            // Terrible bug that afflicts NS servers while doing SSL,
            //  they lie (those buggers), and claim they do keep-alive,
            //  but when we attempt to reuse their Keep-Alive sockets,
            //  they all fail, so we therefore must increase the retry count
            //  so we can empty all the bad keep-alive sockets out of the pool
            //
              
            if ( (GetOpenFlags() & INTERNET_FLAG_SECURE) )
            {
                CServerInfo * pServerInfo = GetServerInfo();
    
                if ( pServerInfo && pServerInfo->IsBadNSServer() )
                {
                    fsm.m_iRetries = 5;
                }

                // Also, purge all keep-alives and cached client auth cert chains
                // if the user flushed the SSL state via inetcpl, including the
                // one for the request object...if being reused.
                if (RefreshSslState())
                    SetCertContextArray(NULL);
            }

            //
            // if we're not in the right state to send, drain the socket
            //

            if (!IsValidHttpState(SEND)) {

#define DRAIN_SOCKET_BUFFER_LENGTH  (1 K)

                if (fsm.m_pBuffer == NULL) {
                    fsm.m_pBuffer = (LPVOID)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        DRAIN_SOCKET_BUFFER_LENGTH);
                    if (fsm.m_pBuffer == NULL) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }
                }
                do {
                    if (!fsm.m_bSink) {
                        fsm.m_bSink = TRUE;
                        fsm.SetFunctionState(FSM_STATE_2);
                        error = ReadData(fsm.m_pBuffer,
                                         DRAIN_SOCKET_BUFFER_LENGTH,
                                         &fsm.m_dwBytesDrained,
                                         TRUE,
                                         0);
                        if (error == ERROR_IO_PENDING) {
                            goto quit;
                        }
                    }

                    //
                    // fall through to state 2
                    //

        case FSM_STATE_2:

                    fsm.m_bSink = FALSE;
                } while ((error == ERROR_SUCCESS) && (fsm.m_dwBytesDrained != 0));
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
                if (fsm.m_pBuffer != NULL) {
                    fsm.m_pBuffer = (LPVOID)FREE_MEMORY(fsm.m_pBuffer);

                    INET_ASSERT(fsm.m_pBuffer == NULL);

                }

                ReuseObject();

                INET_ASSERT(!IsData());
                INET_ASSERT(IS_VALID_HTTP_STATE(this, SEND, TRUE));

                //
                // BUGBUG - if we're not in the right state?
                //

            }

            //
            // generate the correct request headers based
            //  on what types, or whether we're using
            //  proxies
            //


            fsm.SetFunctionState(FSM_STATE_3);
            error = UpdateProxyInfo(Fsm, FALSE);

            if (error == ERROR_IO_PENDING) {
                goto done;
            }

            //
            // set function state to not-FSM_STATE_3 to differentiate interrupted
            // path in FSM_STATE_3
            //

            fsm.SetFunctionState(FSM_STATE_BAD);

            //
            // fall through
            //

        case FSM_STATE_3:

            if (error != ERROR_SUCCESS)
            {
                fsm.m_bCancelRedoOfProxy = TRUE;
                goto quit;
            }
            else if (fsm.GetFunctionState() == FSM_STATE_3) 
            {
                BOOL fChangedFsmVariable = TRUE;
                if (! fsm.m_bCancelRedoOfProxy)
                {
                    fsm.m_bCancelRedoOfProxy = TRUE;
                    fChangedFsmVariable = TRUE;
                }
                
                error = UpdateProxyInfo(Fsm, TRUE);

                if (error != ERROR_SUCCESS)
                {
                    goto quit;
                }
                else if (fChangedFsmVariable)
                {
                    fsm.m_bCancelRedoOfProxy = FALSE;
                }
            }

            fsm.SetFunctionState(FSM_STATE_4);

        case FSM_STATE_4:

            //
            // get any cookies required for this site, but only if app didn't
            // tell us it will handle cookies
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES) ) {
                fsm.SetBlocking(TRUE);

                int cCookie = 0;
                
                error = CreateCookieHeaderIfNeeded(&cCookie);
                if (cCookie) {
                    SetPerUserItem(TRUE);
                }
                fsm.SetBlocking(FALSE);

                if(error != ERROR_SUCCESS) {
                    goto quit;
                }
            }

            //
            // if this URL requires authentication then add its header here, but
            // only if the app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_AUTH)) 
            {
                SetPPAbort(FALSE); // let's assume Passport is not going to abort the send.
                
                error = AuthOnRequest(this);
                if (error != ERROR_SUCCESS) 
                {
                    goto quit;
                }

                if (PPAbort())
                {
                    // Passport needed to abort the send cuz the DA wanted to redirect
                    // the App to an different site *AND* the app wanted to handle the 
                    // redirect itself.
                    error = ERROR_INTERNET_LOGIN_FAILURE;
                    goto quit;
                }

                error = HttpFiltOnRequest(this);
            }
try_again:
            fsm.SetFunctionState(FSM_STATE_5);
            DEBUG_PRINT(HTTP, INFO, ("State_4_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));
            error = DoFsm(new CFsm_SendRequest(fsm.m_lpOptional,
                                               fsm.m_dwOptionalLength,
                                               this
                                               ));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_5:
            DEBUG_PRINT(HTTP, INFO, ("State_5_start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            if (error == ERROR_INTERNET_OFFLINE) {
                goto offline_check;
            } else if (((GetOpenFlags() & INTERNET_FLAG_CACHE_IF_NET_FAIL)
                        && ((error == ERROR_INTERNET_CANNOT_CONNECT)
                            || (error == ERROR_INTERNET_CONNECTION_RESET)))
                       || ((error == ERROR_INTERNET_TIMEOUT)
                           && IsFromCacheTimeoutSet()
                           && CanRetrieveFromCache(FALSE))) {

                //CHECK_FSM_OWNED(Fsm);

//if (IsFromCacheTimeoutSet() && IsInCache()) {
//    dprintf("%q timed out on connect/send - getting from cache\n", GetURL());
//}
                error = GetFromCachePostNetIO(HTTP_STATUS_NOT_MODIFIED, TRUE);
                if (error == ERROR_SUCCESS) {
                    SetNetFailed();
                }
                goto quit;
            }

            //CHECK_FSM_OWNED(Fsm);

            //
            // This adds CR-LF for the File Upload case
            //

            //if (_RequestMethod == HTTP_METHOD_TYPE_POST && _AddCRLFToPOST && fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST)
            //{
            //    error = _Socket->Send(gszCRLF, 2, 0);
            //    if (error != ERROR_SUCCESS) {
            //        goto quit;
            //    }
            //}
            fsm.m_bWasKeepAlive = (_bKeepAliveConnection || IsKeepAlive());
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {

                //
                // must be doing proxy tunnelling request if status code set
                //

                INET_ASSERT(((GetStatusCode() != HTTP_STATUS_OK)
                            && (GetStatusCode() != 0))
                            ? IsTalkingToSecureServerViaProxy()
                            : TRUE
                            );

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_INTERNET_CONNECTION_RESET)
                || (error == ERROR_INTERNET_CONNECTION_ABORTED))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after send. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after send\n");
                    CloseConnection(TRUE);
                    goto try_again;
                }
                goto quit;
            }
            if (fsm.m_arRequest == AR_HTTP_BEGIN_SEND_REQUEST) {
                goto quit;
            }
            fsm.SetFunctionState(FSM_STATE_6);
            error = DoFsm(new CFsm_ReceiveResponse(this));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_6:

            DEBUG_PRINT(HTTP, INFO, ("State_6_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (error != ERROR_SUCCESS) {
//dprintf("*** post-receive: error=%d, retries=%d\n", error, fsm.m_iRetries);

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_INTERNET_CONNECTION_RESET)
                || (error == ERROR_INTERNET_CONNECTION_ABORTED)
                || (error == ERROR_HTTP_INVALID_SERVER_RESPONSE))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after receive. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after receive\n");
                    CloseConnection(TRUE);
                    _ResponseHeaders.FreeHeaders();
                    ResetResponseVariables();
                    _ResponseHeaders.Initialize();
                    _dwCurrentStreamPosition = 0;
                    goto try_again;
                }

                //
                // if we reached this far and discover that the state is offline
                // then we have either transitioned to this state by losing the
                // net connection, or by being put into user-offline state. In
                // either case, we attempt to retrieve the item from the cache
                //

offline_check:
                if (IsOffline()) {
                    // if we already have it retrived, don't do it again
                    if (!_hCacheStream && !_pCacheEntryInfo )
                        error = FHttpBeginCacheRetrieval(TRUE, TRUE, FALSE);
                    else
                        error = FHttpBeginCacheRetrieval(TRUE, TRUE, TRUE);
        
                } else if (((GetOpenFlags() & INTERNET_FLAG_CACHE_IF_NET_FAIL)
                           && ((error == ERROR_INTERNET_CANNOT_CONNECT)
                               || (error == ERROR_INTERNET_CONNECTION_RESET)))
                           || ((error == ERROR_INTERNET_TIMEOUT)
                               && IsFromCacheTimeoutSet()
                               && CanRetrieveFromCache(FALSE))) {

//if (IsFromCacheTimeoutSet() && IsInCache()) {
//    dprintf("%q timed out on response - getting from cache\n", GetURL());
//}
                    error = GetFromCachePostNetIO(HTTP_STATUS_NOT_MODIFIED, TRUE);
                    if (error == ERROR_SUCCESS) {
                        SetNetFailed();
                    }
                }
                goto quit;
            }

            fsm.SetFunctionState(FSM_STATE_7);


        case FSM_STATE_7:
            DEBUG_PRINT(HTTP, INFO, ("State_7_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //
            // put any received cookie headers in the cookie jar, but only if the
            // app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
                /* && IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE) */ )
            {
                DWORD dwError;
                fsm.SetBlocking(TRUE);
                dwError = ExtractSetCookieHeaders(&fsm.m_dwCookieIndex);
                fsm.SetBlocking(FALSE);

                if ( dwError == ERROR_SUCCESS ) {
                    SetPerUserItem(TRUE);
                } else if ( dwError == ERROR_IO_PENDING ) {
                    error = ERROR_IO_PENDING;
                    goto quit;
                }
            }

            //
            // we need to handle various intermediary return codes:
            //
            //  30x - redirection
            //  40x - authentication
            //
            // BUT ONLY if the app didn't tell us it wanted to handle these itself
            //

            DWORD statusCode;
            BOOL bNoAuth;

            statusCode = GetStatusCode();
            bNoAuth = (GetOpenFlags() & INTERNET_FLAG_NO_AUTH) ? TRUE : FALSE;

            //
            // if the status is 200 (most frequently return header == success)
            // and we are not authenticating all responses then we're done
            //

            if ((statusCode == HTTP_STATUS_OK) && bNoAuth) {
                goto quit;
            }

            //
            // handle authentication before checking the cache
            //

            if (!bNoAuth) {

                //
                // call filter for cis rpa
                //

                if (!HttpFiltOnResponse(this)) {
                    switch (error = GetLastError()) {
                    case ERROR_INTERNET_FORCE_RETRY:

                        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
                        {
                            goto quit;
                        }

                        fsm.m_bFinished = FALSE;
                        fsm.m_bAuthNotFinished = TRUE;
                        error = ERROR_SUCCESS;
                        break;

                    case ERROR_INTERNET_NEED_UI:
                        error = ERROR_SUCCESS;
                        break;
                    }
                }

                //
                // call packages for basic, ntlm, msn, dpa etc.
                //

                error = AuthOnResponse(this);
                // passport1.4 auth could change the status code from 302 to 401 here
                statusCode = GetStatusCode();

                if (error == ERROR_INTERNET_FORCE_RETRY) {

                    if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
                    {
                        goto quit;
                    }

                    //
                    // the object has been updated with new info - try again
                    //

                    fsm.m_bFinished = FALSE;
                    fsm.m_bAuthNotFinished = TRUE;
                    error = ERROR_SUCCESS;

                    //
                    // Reset auto-proxy info so we can retry the connection
                    //

                    if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                    {
                        delete fsm.m_pProxyInfoQuery;
                        fsm.m_pProxyInfoQuery = NULL;
                    }


                } else if (error == ERROR_INTERNET_INCORRECT_PASSWORD) {

                    //
                    // just return success to the app which will have to check the
                    // headers and make the request again, with the right password
                    //

                    error = ERROR_SUCCESS;
                    goto quit;
                } else if (error == ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY) {

                    // If app allows this error code return it. Otherwise return ERROR_INTERNET_LOGIN_FAILURE
                    if (!(GetErrorMask() & INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY))
                    {
                        error = ERROR_INTERNET_LOGIN_FAILURE;
                    }
                    else
                    {
                        goto quit;
                    }
                }
        
            }

            //
            // if we can read from the cache then let us try
            //

            if ((statusCode == HTTP_STATUS_OK)
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)
                || (statusCode == HTTP_STATUS_PRECOND_FAILED)
                || (statusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (statusCode == 0)) {

                if (GetFromCachePostNetIO(statusCode) == ERROR_SUCCESS) {
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            }

            BOOL fMustRedirect;
            
            fMustRedirect = FALSE;

            if (_pAuthCtx)
            {
                if (_pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)_pAuthCtx;
                    if (pPPCtx->m_lpszRetUrl)
                    {
                        fMustRedirect = TRUE;
                    }
                }
            }

            //
            // handle redirection
            //

            BOOL fDoProxyRedirect;

            fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_UNKNOWN;
            fDoProxyRedirect = FALSE;
            fsm.m_fNeedUserApproval = FALSE;

            fsm.m_bRedirected = FALSE;

            if (((statusCode == HTTP_STATUS_AMBIGUOUS)              // 300
                 || (statusCode == HTTP_STATUS_MOVED)               // 301
                 || (statusCode == HTTP_STATUS_REDIRECT)            // 302
                 || (statusCode == HTTP_STATUS_REDIRECT_METHOD)     // 303
//                 || (statusCode == HTTP_STATUS_USE_PROXY)           // 305
                 || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB)) // 307
                && (fMustRedirect || !(GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT))) {

                //
                // Clean out expired PROXY_STATE
                //

                error = ERROR_SUCCESS;
                if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                {
                    delete fsm.m_pProxyInfoQuery;
                    fsm.m_pProxyInfoQuery = NULL;
                }
                //fsm.m_pProxyState = NULL;
                SetProxyName(NULL, 0, 0);

                //
                // if we've already had the max allowable redirects then quit
                //

                if (fsm.m_dwRedirectCount == 0) {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                    fsm.m_bRedirectCountedOut = TRUE;
                    goto quit;
                }

                //
                // we got 300 (ambiguous), 301 (permanent move), 302 (temporary
                // move), or 303 (redirection using new method)
                //

                switch (statusCode) {
                case HTTP_STATUS_AMBIGUOUS:

                    //
                    // 300 - multiple choice
                    //

                    //
                    // If there is a Location header, we do an "automatic" redirect
                    //

                    _ResponseHeaders.LockHeaders();

                    if (! IsResponseHeaderPresent(HTTP_QUERY_LOCATION)) {
                        _ResponseHeaders.UnlockHeaders();
                        fsm.m_bFinished = TRUE;
                        break;
                    }

                    _ResponseHeaders.UnlockHeaders();

                    //
                    // fall through
                    //

                case HTTP_STATUS_MOVED:

                    // Table View:
                    //Method            301             302             303             307
                    //  *               *               *           GET         *
                    //POST                  GET         GET             GET             POST
                    //
                    //Put another way:
                    //301 & 302  - All methods are redirected to the same method but POST. POST is
                    //  redirected to a GET.
                    //303 - All methods are redirected to GET
                    //307 - All methods are redirected to the same method.

                    //
                    // 301 - permanently moved
                    //

                    //
                    // fall through
                    //

                case HTTP_STATUS_REDIRECT:

                    //
                    // 302 - temporarily moved (POST => GET, everything stays the same)
                    //
                    fsm.m_tMethodRedirect = GetMethodType();
                    if (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST)
                    //
                    // A POST change method to a GET
                    //
                    {
                        fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                        // force no optional data on second and subsequent sends
                        fsm.m_dwOptionalLength = 0;

                        // Don't decorate URL for a GET.
                        FreeSecondaryCacheKey();
                    }

                    // Other than GET and HEAD methods, we always want to
                    // error out to the client with ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION
                    
                    if ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                        (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD))
                    {
                        AUTHCTX* pAuthCtx = GetAuthCtx();
                        AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
                        if (pAuthCtx != NULL)
                        {
                           eAuthScheme = pAuthCtx->GetSchemeType();
                        }

                        // If Passport1.4 authentication is underway, we relax the user approval requirement
                        // to make app's life easier

                        if (eAuthScheme != AUTHCTX::SCHEME_PASSPORT)
                        {
                            fsm.m_fNeedUserApproval = TRUE;
                        }
                    }

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;

                    break;
                case HTTP_STATUS_REDIRECT_METHOD:

                    //
                    // 303 - see other (POST => GET)
                    //

                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // force no optional data on second and subsequent sends
                    //

                    fsm.m_dwOptionalLength = 0;

                    //
                    // Don't decorate URL for a GET.
                    //

                    FreeSecondaryCacheKey();

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                case HTTP_STATUS_REDIRECT_KEEP_VERB:

                    //
                    // 307 - see other (POST => POST)
                    //

                    //if (IsHttp1_1()) {
                    fsm.m_tMethodRedirect = GetMethodType();

                    if ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                        (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD))
                    {
                        fsm.m_fNeedUserApproval = TRUE;
                    }


                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    //} else {
                    //    fsm.m_dwOptionalLength = 0;
                    //    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;
                    //}
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

#if 0 // The http-wg will probably decide that 305 is only for proxies.

                case HTTP_STATUS_USE_PROXY:

                    //
                    // 305 - use proxy, force a re-request but now use a the specifed proxy
                    //

                    if ( IsResponseHttp1_1() )
                    {
                        fsm.m_tMethodRedirect = GetMethodType();
                        fDoProxyRedirect = TRUE;

                        fsm.m_bRedirected = TRUE;
                        --fsm.m_dwRedirectCount;

                        break;
                    }

                    //
                    // fall through
                    //
#endif

                default:
                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // BUGBUG - force no optional data on second and subsequent
                    //          sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;
                }

                //
                // Only allow redirect to continue if we are successful.
                //

                if (fsm.m_bRedirected
                && ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_UNKNOWN)
                    || (fsm.m_tMethodRedirect == GetMethodType()))) {
                    fsm.SetFunctionState(FSM_STATE_8);
                    // Remember if it was a forms submit.
                    fsm.m_bFormsSubmit = ((GetOpenFlags() & INTERNET_FLAG_FORMS_SUBMIT) ||
                                          (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST));
                    error = Redirect(fsm.m_tMethodRedirect, fDoProxyRedirect);
                    if (error != ERROR_SUCCESS) {
                        goto quit;
                    }
                }
            } else {

                //
                // not a status that we handle. We're done
                //   BUT WAIT, we're only finshed if also
                //   finished retrying HTTP authentication.
                //
                // if the app told us not to handle authentication auth_not_finished
                // will be FALSE
                //

                if (!fsm.m_bAuthNotFinished) {
                    fsm.m_bFinished = TRUE;
                }
            }

            //
            // fall through
            //

        case FSM_STATE_8:
            DEBUG_PRINT(HTTP, INFO, ("State_8_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (fsm.m_bRedirected) {
                BOOL bFormsSubmit = fsm.m_bFormsSubmit;
                fsm.m_bFormsSubmit = FALSE;
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                //if ( IsResponseHttp1_1() &&
                //     fsm.m_fNeedUserApproval &&
                //     GetMethodType() != HTTP_METHOD_TYPE_GET &&
                //     GetMethodType() != HTTP_METHOD_TYPE_HEAD )
                if (fsm.m_fNeedUserApproval)
                {

                    INET_ASSERT((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                                (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD));
                    //
                    // If servers force us to redirect back
                    //   to another POST, PUT, etc. then we must notify the user.
                    //

                    error = ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION;
                    DEBUG_PRINT(HTTP, INFO, ("User approval needed. returning 0x%x\r\n", error));
                    goto quit;
                }

                // If we are redirecting a forms submit always urlmon a chance
                // to ask the user because the submit might be going to a
                // restricted zone now.
                if ( bFormsSubmit )
                {
                    error = ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION;
                    DEBUG_PRINT(HTTP, INFO, ("Redirected form needs user approval. returning 0x%x\r\n", error));
                    goto quit;
                }

                INET_ASSERT(error == ERROR_SUCCESS);
                INET_ASSERT(!IsCacheReadInProgress());

                //
                // cleanup response headers from redirection
                //

                ReuseObject();
                if (GetFromCachePreNetIO() == ERROR_SUCCESS) {
                    error = ERROR_SUCCESS;
                    goto quit;
                }

                //
                // Allow Redirects to exit out and force the HttpEndRequestA
                //  caller to notice.
                //

                if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD
                     )
                {
                    error = ERROR_INTERNET_FORCE_RETRY;
                }
            }
        }
        state = FSM_STATE_INIT;
    } while (!fsm.m_bFinished && (error == ERROR_SUCCESS));

quit:
        DEBUG_PRINT(HTTP, INFO, ("Quit1: error = 0x%x\r\n", error));

    if (error == ERROR_IO_PENDING) {
        goto done;
    }

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if (!fsm.m_bCancelRedoOfProxy && 
            //(GetStatusCode() != HTTP_STATUS_DENIED) &&
            ((eAuthScheme != AUTHCTX::SCHEME_PASSPORT) || (GetStatusCode() != HTTP_STATUS_DENIED)) && // this is safer
            fsm.m_pInternet->RedoSendRequest(&error, fsm.m_pProxyInfoQuery, GetOriginServer(), GetServerInfo())) 
        {
            fsm.m_bFinished = FALSE;
            fsm.m_bRedirectCountedOut = FALSE;
            fsm.m_dwRedirectCount = GlobalMaxHttpRedirects;
            fsm.SetState(FSM_STATE_INIT);
            state = FSM_STATE_INIT;
            DEBUG_PRINT(HTTP, INFO, ("Quit2: error = 0x%x\r\n", error));
            goto retry_send_request;
        } 
        else 
        {
            //SetProxyName(NULL, 0, 0);
            DEBUG_PRINT(HTTP, INFO, ("Quit3: error = 0x%x\r\n", error));
        }
    }

    //
    // if ERROR_HTTP_REDIRECT_FAILED then we tried to redirect, but found that
    // we couldn't do it (e.g. http:// to ftp:// or file://, etc.) We need to
    // defer this to the caller to clean up & make the new request. They will
    // have all the header info (plus we probably already indicated the new
    // URL during the redirect callback). Just return ERROR_SUCCESS
    //
    // Only do this if we failed because we couldn't change to the new URL, not
    // because we counted out the redirects
    //
    // We also change the error code to ERROR_SUCCESS if we didn't redirect
    // because we were redirected to the same site
    //

    if (((error == ERROR_HTTP_REDIRECT_FAILED)
    || (error == ERROR_HTTP_NOT_REDIRECTED))
    && !fsm.m_bRedirectCountedOut) {
        error = ERROR_SUCCESS;
    }

    //
    // if we received a Refresh header along the way, but no longer have it (we
    // were redirected) then restore it
    //

    if ((error == ERROR_SUCCESS) && IsRefresh()) {

        DWORD err;

        _ResponseHeaders.LockHeaders();

        if (!IsResponseHeaderPresent(HTTP_QUERY_REFRESH))
        {

            DWORD len;
            HEADER_STRING & refreshHeader = GetRefreshHeader();

            if (refreshHeader.HaveString()) {
                err = AddInternalResponseHeader(HTTP_QUERY_REFRESH,
                                                refreshHeader.StringAddress(),
                                                refreshHeader.StringLength()
                                                );

                INET_ASSERT(err == ERROR_SUCCESS);

            }
        }

        _ResponseHeaders.UnlockHeaders();
    }

    fsm.SetNextState(FSM_STATE_FINISH);

done:

    PERF_LEAVE(HttpSendRequest_Start);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Finish);

    CFsm_HttpSendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;


    if ((error == ERROR_SUCCESS)
    && !IsCacheReadInProgress()
    && !IsCacheWriteInProgress()
    && (fsm.m_arRequest != AR_HTTP_BEGIN_SEND_REQUEST)) {

        INET_ASSERT(!IsCacheReadInProgress());

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //
        // (only need to do this for 200/206 response code)
        //

        if( _StatusCode == HTTP_STATUS_OK || 
            _StatusCode == HTTP_STATUS_PARTIAL_CONTENT)  
        {
            if (FCanWriteToCache() ) 
            {

                DEBUG_PRINT(CACHE,
                        INFO,
                        ("Starting cache write\n"
                        ));

                FHttpBeginCacheWrite();
            } else {

                //
                // If the WININET client must have caching,
                //  Notify him that we are unable to cache his files,
                //  by erroring out.
                //

                if (GetCacheFlags() & INTERNET_FLAG_NEED_FILE) {
                    error = ERROR_INTERNET_UNABLE_TO_CACHE_FILE;
                }
            }
        }
    }

    INET_ASSERT(fsm.m_hRequestMapped != NULL);

    //if (!IsAsyncHandle() && (fsm.m_hRequestMapped != NULL)) {
    //    DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    //}

    //
    // we will return FALSE even if this is an async operation and the error is
    // ERROR_IO_PENDING
    //

    fsm.SetDone(error);
    //fsm.SetApiResult(error == ERROR_SUCCESS);

    PERF_LEAVE(HttpSendRequest_Finish);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::BuildProxyMessage(
    IN CFsm_HttpSendRequest * Fsm,
    AUTO_PROXY_ASYNC_MSG * pProxyMsg,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Calls CrackUrl to parses request URL, and 
      transfers the information to the AUTO_PROXY_ASYNC_MSG

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR currentUrl;
    DWORD currentUrlLength;

    //
    // Gather the URL off the handle
    //

    currentUrl = GetURL();

    if (currentUrl) {
        currentUrlLength = lstrlen(currentUrl);

        //
        // BUGBUG [arthurbi] the following can be a slow call,
        //   but its too risky to change the complete behavior where
        //   we cache it
        //

        //
        // crack the current URL
        //

        memset(pUrlComponents, 0, sizeof(URL_COMPONENTS));
        pUrlComponents->dwStructSize = sizeof(URL_COMPONENTS);

        error = CrackUrl(currentUrl,
                         currentUrlLength,
                         FALSE, // don't escape URL-path
                         &(pUrlComponents->nScheme),
                         NULL,  // don't care about Scheme Name
                         NULL,
                         &(pUrlComponents->lpszHostName),
                         &(pUrlComponents->dwHostNameLength),
                         &(pUrlComponents->nPort),
                         NULL,  // don't care about user name
                         NULL,
                         NULL,  // or password
                         NULL,
                         &(pUrlComponents->lpszUrlPath),
                         &(pUrlComponents->dwUrlPathLength),
                         NULL,  // no extra
                         NULL,
                         NULL
                         );

        pProxyMsg->SetProxyMsg(
            pUrlComponents->nScheme,
            currentUrl,
            currentUrlLength,
            pUrlComponents->lpszHostName,
            pUrlComponents->dwHostNameLength,
            pUrlComponents->nPort
            );
    } else {
        INET_ASSERT(FALSE);
        error = ERROR_INTERNET_INVALID_URL;
    }
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    INTERNET_HANDLE_OBJECT * pInternet,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Wrapper over GetProxyInfo call to determine proxy
        settings on our given object

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings",
                 "%#x, %#x, %#x",
                 Fsm, pInternet, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    INET_ASSERT(fsm.m_pProxyInfoQuery);
    INET_ASSERT(pInternet);

    if (!IsAutoProxyChecked())
    {
        // Never do this more than once per request.
        // QFE 353 involves supporting authentication, and
        // this check prevents multiple dialogs from appearing
        // due to invalid credentials.    
        SetAutoProxyChecked(TRUE);
        
        error = pInternet->CheckAutoProxyDownloaded();
    }

    // don't touch fsm state.
    if ( error == ERROR_IO_PENDING )
    {
        goto quit;
    }

    SetProxyName(NULL, 0, 0);

    fsm.m_fOwnsProxyInfoQueryObj = FALSE;

    error = pInternet->GetProxyInfo(
                            &fsm.m_pProxyInfoQuery
                            );

    //
    //  If GetProxyInfo returns pending, then we no longer have
    //   access to the pointer that we've passed.
    //

    if ( error == ERROR_IO_PENDING )
    {
        //
        // Bail out, DO NOT TOUCH any OBJECTS or FSMs 
        //

        goto quit;
    }

    // then regardless we own it unless GetProxyInfo went pending with the FSM
    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    INET_ASSERT( error == ERROR_SUCCESS );

    if ( ! ((fsm.m_pProxyInfoQuery)->IsUseProxy()) )
    {
        if ( pUrlComponents->nScheme == INTERNET_SCHEME_FTP ||
             pUrlComponents->nScheme == INTERNET_SCHEME_GOPHER )
        {
            //
            // we cannot go direct on these
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }

        SetIsTalkingToSecureServerViaProxy(FALSE);        
    }

quit:

    DEBUG_LEAVE(error);
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckForCachedProxySettings(
    IN AUTO_PROXY_ASYNC_MSG *pProxyMsg,
    OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Attempts to determine and then resolve if there are cached
     proxy settings saved away in the CServerInfo object,
     which is found in our HTTP_REQUEST_ object.  This can
     be very useful since calling off to an auto-proxy thread
     can be quite expensive in terms of performance.

Arguments:

    pProxyMsg - the object containing our current proxy message
      information, that we use to scripple our proxy state for
      a given request

    ppProxyServerInfo - on return, may contain the resultant
      cached ServerInfo object.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    CServerInfo * pOriginServer = GetOriginServer();
    CServerInfo * pProxyServer;

    INET_ASSERT(pProxyMsg);

    *ppProxyServerInfo = NULL;

    if (pOriginServer)
    {
        BOOL fCachedEntry;

        pProxyServer = 
            pOriginServer->GetCachedProxyServerInfo(            
                pProxyMsg->_tUrlProtocol,
                pProxyMsg->_nUrlPort,
                &fCachedEntry
                );

        if (fCachedEntry)
        {
            if ( pProxyServer )
            {
                if (pProxyServer->CopyCachedProxyInfoToProxyMsg(pProxyMsg))
                {
                    SetOriginServer();
                    *ppProxyServerInfo = pProxyServer;
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            
                // nuke extra ref, sideeffect of GetCachedProxy... call            
                ::ReleaseServerInfo(pProxyServer);
            }  
            else
            {
                // DIRECT, no-proxy cached.
                pProxyMsg->SetUseProxy(FALSE);
                pProxyMsg->_lpszProxyHostName = NULL;
                error = ERROR_SUCCESS;
                goto quit;
            }
        }
    }

    pProxyMsg->SetVersion();

quit:
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    IN INTERNET_CONNECT_HANDLE_OBJECT * pConnect,
    IN OUT URL_COMPONENTS * pUrlComponents,
    OUT LPSTR * lplpszRequestObject,
    OUT DWORD * lpdwRequestObjectSize
    )
/*++

Routine Description:

    Armed with the results of the proxy query, this method takes care of 
    assembling the various variables and states to deal with various 
    types of proxies.

    More specifally, this handles HTTP Cern Proxies, SOCKS proxies, 
    SSL-CONNECT/HTTP proxies, and special cases such as FTP URLs
    with passwords through an HTTP Cern Proxy.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings",
                 "%#x, %#x, %#x",
                 Fsm, pConnect, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    LPSTR lpszUrlObject = NULL;
    LPSTR lpszObject = pUrlComponents->lpszUrlPath;
    DWORD dwcbObject = pUrlComponents->dwUrlPathLength;

    if ((fsm.m_pProxyInfoQuery)->GetProxyScheme() == INTERNET_SCHEME_SOCKS)
    {
        if ( pUrlComponents->nScheme == INTERNET_SCHEME_FTP ||
             pUrlComponents->nScheme == INTERNET_SCHEME_GOPHER )
        {
            //
            // we cannot go direct on these,
            //  this would for example an HTTP request over SOCKS,
            //  redirected to an FTP/GOPHER URL
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }


        SetSocksProxyName((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                          (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                          (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                          );

        (fsm.m_pProxyInfoQuery)->_lpszProxyHostName = NULL;
        (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength = 0;
    }
    else if (pUrlComponents->nScheme == INTERNET_SCHEME_HTTPS)
    {
        SetIsTalkingToSecureServerViaProxy(TRUE);
    }
    else
    {
        SetIsTalkingToSecureServerViaProxy(FALSE); // default value.

        //
        // if this request is going via proxy then we send the entire URL as the
        // request
        //

        DWORD urlLength;

        //
        // in secure proxy tunnelling case we are going to send the request
        // "CONNECT <host>:<port>"
        //

        LPSTR lpszMBCSHostName;
        DWORD dwMBCSHostNameLength;
        BOOL fUsedUTF8 = FALSE;
        LPSTR lpszUTF8HostName;
        DWORD dwUTF8StrLen;

        if (ShouldSendUTF8ServerNameToProxy())
        {
            INET_ASSERT (GlobalSendUTF8ServerToProxy);
            if (lpszUTF8HostName = ConvertMBCSToUTF8(pUrlComponents->lpszHostName, 
                                                    pUrlComponents->dwHostNameLength, 
                                                    GetCodePage(),
                                                    &dwUTF8StrLen))
            {
                lpszMBCSHostName = pUrlComponents->lpszHostName;
                dwMBCSHostNameLength = pUrlComponents->dwHostNameLength;
                pUrlComponents->lpszHostName = lpszUTF8HostName;
                pUrlComponents->dwHostNameLength = dwUTF8StrLen;
                fUsedUTF8 = TRUE;
            }
        }            
                    

        if (IsTunnel()) {
            urlLength = pUrlComponents->dwHostNameLength + sizeof(":65535");
        } else {
            urlLength = INTERNET_MAX_URL_LENGTH;
        }

        lpszUrlObject = (LPSTR)ResizeBuffer(NULL, urlLength, FALSE);
        if (lpszUrlObject == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto local_quit;
        }

        if (IsTunnel())
        {
            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                INET_ASSERT (pUrlComponents->nScheme == INTERNET_SCHEME_HTTP);
                pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            memcpy (lpszUrlObject, pUrlComponents->lpszHostName, pUrlComponents->dwHostNameLength);
            wsprintf (lpszUrlObject + pUrlComponents->dwHostNameLength, ":%d", pUrlComponents->nPort);
        }
        else
        {
            //
            // there may be a user name & password (only if FTP)
            //

            LPSTR userName;
            DWORD userNameLength;
            LPSTR password;
            DWORD passwordLength;

            if (pUrlComponents->nScheme == INTERNET_SCHEME_FTP) {
                userName = pConnect->GetUserOrPass(IS_USER, IS_SERVER);
                userNameLength = userName ? lstrlen(userName)  : 0;
                password = pConnect->GetUserOrPass(IS_PASS, IS_SERVER);
                passwordLength = password ? lstrlen(password)  : 0;
            } else {
                userName = NULL;
                userNameLength = 0;
                password = NULL;
                passwordLength = 0;
            }

            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                switch (pUrlComponents->nScheme)
                {
                    case INTERNET_SCHEME_FTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_FTP_PORT;
                        break;

                    case INTERNET_SCHEME_GOPHER:
                        pUrlComponents->nPort = INTERNET_DEFAULT_GOPHER_PORT;
                        break;

                    case INTERNET_SCHEME_HTTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
                        break;

                    case INTERNET_SCHEME_HTTPS:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTPS_PORT;
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        break;
                }
            }

            pUrlComponents->lpszUserName = userName;
            pUrlComponents->dwUserNameLength = userNameLength;
            pUrlComponents->lpszPassword = password;
            pUrlComponents->dwPasswordLength = passwordLength;

            if (!InternetCreateUrl(pUrlComponents, 0, lpszUrlObject, &urlLength))
            {
                error = GetLastError();
                goto local_quit;
            }

            //
            // shrink the buffer to fit
            //

            lpszUrlObject = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                (urlLength + 1) * sizeof(TCHAR),
                                                FALSE
                                                );

            INET_ASSERT(lpszUrlObject != NULL);

            if (lpszUrlObject == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto local_quit;
            }
        }

        SetRequestUsingProxy(TRUE);

        lpszObject = lpszUrlObject;
        dwcbObject = lstrlen(lpszUrlObject);

local_quit:
        if (fUsedUTF8)
        {
            pUrlComponents->lpszHostName = lpszMBCSHostName;
            pUrlComponents->dwHostNameLength = dwMBCSHostNameLength;

            LPSTR hostName = lpszUTF8HostName;
            DWORD hostNameLength = dwUTF8StrLen;
            INTERNET_PORT hostPort = GetHostPort();
            LPSTR pAllocHostName = NULL;

            if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
                && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) 
            {
                pAllocHostName = new CHAR[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")+1];

                if (pAllocHostName)
                {
                    hostNameLength = wsprintf(pAllocHostName, "%s:%d", hostName, (hostPort & 0xffff));
                    hostName = pAllocHostName;
                }
                else
                {
                    hostName = NULL;
                }
            }

            if (hostName)
            {
                ReplaceRequestHeader(HTTP_QUERY_HOST,
                                     hostName,
                                     hostNameLength,
                                     0, // dwIndex,
                                     ADD_HEADER
                                     );
            }

            if (pAllocHostName)
            {
                delete [] pAllocHostName;
            }
            
            delete [] lpszUTF8HostName;
        }
    }

quit:

    *lplpszRequestObject   = lpszObject;
    *lpdwRequestObjectSize = dwcbObject;

    DEBUG_LEAVE(error);
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN LPSTR lpszObject,
    IN DWORD dwcbObject,
    IN OUT URL_COMPONENTS * pUrlComponents,
    IN OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Based on object and URL information, for a given HTTP request, 
    this function assembles the "special cases" and modifes the 
    request headers in prepartion of making the actual request.

    The "special cases" includes the handling of HTTP versioning, 
    HTTP 1.0/1.1 keep-alives, and Pragma headers.

    This function also deals with the update the ServerInfo object
    that contains the host resolution information.


Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo",
                 "%#x, %.100q, %d, %#x",
                 Fsm, lpszObject, dwcbObject, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszVersion = NULL;
    DWORD dwVersionLen = 0;

    CFsm_HttpSendRequest & fsm = *Fsm;

    if ( lpszObject == NULL) 
    {
        lpszObject = pUrlComponents->lpszUrlPath;
        dwcbObject = pUrlComponents->dwUrlPathLength;
    }
        
    INET_ASSERT(dwcbObject > 0 );

    _RequestHeaders.LockHeaders();

    //
    // if we are going via proxy and HTTP 1.1 through proxy is disabled
    // then modify the request version to HTTP/1.0
    //

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() &&        
        ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) &&
        (!GlobalEnableProxyHttp1_1 || GetMethodType() == HTTP_METHOD_TYPE_CONNECT)) {
        lpszVersion = "HTTP/1.0";
        dwVersionLen = sizeof("HTTP/1.0") - 1;
        RemoveGzipDeflateEncHeader();
    }

    ModifyRequest(GetMethodType(),
                  lpszObject,
                  dwcbObject,
                  lpszVersion,
                  dwVersionLen
                  );

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() )        
    {
        SetProxyName( (fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                      (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                      );

        if ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) {

            if (_ServerInfo != NULL)
            {
                _ServerInfo->SetProxyByPassed(FALSE);
            }

            //
            // changing server info from origin server to proxy server. Keep
            // pointer to origin server so that we can update connect and
            // round-trip times
            //

            SetOriginServer();

            if (*ppProxyServerInfo) {
                // cached server info
                SetServerInfo(*ppProxyServerInfo);
                *ppProxyServerInfo = NULL;
            }
            else
            {            
                error = SetServerInfo((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength
                                      );
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
            }
        }
    }
    else
    {
        if (_ServerInfo != NULL)
        {
            _ServerInfo->SetProxyByPassed(TRUE);

            if ( pUrlComponents->lpszHostName )
            {
                error = SetServerInfo(pUrlComponents->lpszHostName,
                                      pUrlComponents->dwHostNameLength
                                      );

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
            }

        }
    }

    //
    // determine whether we use persistent connections and ensure the correct
    // type and number of keep-alive headers are present
    //

    //
    // BUGBUG - we need to check for "Connection: keep-alive". There may be
    //          other types of "Connection" header, and the keep-alive header
    //          may contain additional information
    //

    DWORD bufferLength;
    DWORD index;
    DWORD dwHeaderNameIndex;

    if (IsRequestUsingProxy()) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_PROXY_CONNECTION;
    } else {
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_CONNECTION;
    }

    if (IsRequestHeaderPresent(dwHeaderNameIndex)) {
        SetWantKeepAlive(TRUE);
        SetOpenFlags(
            GetOpenFlags() | INTERNET_FLAG_KEEP_CONNECTION);
    }

    error = ERROR_SUCCESS;

    //
    // if the global keep-alive switch
    // is off then we don't want any keep-alive headers
    //

    if (GlobalDisableKeepAlive)
    {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);

        if (IsRequestHttp1_1())
        {
            //
            // Add "Connection: Close" header because we're not doing
            //  keep-alive on this Request, needed for HTTP 1.1
            //

            (void)ReplaceRequestHeader(HTTP_QUERY_CONNECTION,
                                       CLOSE_SZ,
                                       CLOSE_LEN,
                                       0,
                                       REPLACE_HEADER
                                       );
        }

        SetOpenFlags(
            GetOpenFlags() & ~INTERNET_FLAG_KEEP_CONNECTION);
    }

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    if (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION)
    {
        SetWantKeepAlive(TRUE);
        (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                   KEEP_ALIVE_SZ,
                                   KEEP_ALIVE_LEN,
                                   0,
                                   ADD_HEADER_IF_NEW
                                   );
    }

    //
    // if app added "connection: close" then we don't want keep-alive
    //

    if (IsRequestHttp1_1()) {

        BOOL bClose = FindConnCloseRequestHeader(dwHeaderNameIndex);
        BOOL bWantKeepAlive;
        DWORD dwOpenFlags = GetOpenFlags();

        if (bClose || (IsTunnel() && GetAuthState() != AUTHSTATE_CHALLENGE)) {
            RemoveAllRequestHeadersByName(dwHeaderNameIndex);

            //
            // For a Tunnel to a proxy we want to make sure that
            //  keep-alive is off since is does not make sense
            //  to do keep-alive with in a HTTP CONNECT request
            //
            // Note: we do not add the Connection: close header
            //  because of its amphorus definition in this case.
            //

            if (!IsTunnel()) {
                (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                           CLOSE_SZ,
                                           CLOSE_LEN,
                                           0,
                                           REPLACE_HEADER
                                           );
            }
            bWantKeepAlive= FALSE;
            dwOpenFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
        } else {
            bWantKeepAlive = TRUE;
            dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        SetWantKeepAlive(bWantKeepAlive);
        SetOpenFlags(dwOpenFlags);
    }

    DWORD dwFlags;
    dwFlags = GetCacheFlags();

    if (GetMethodType() == HTTP_METHOD_TYPE_POST && !GetSecondaryCacheKey())
    {
        //
        // IE30 compat: force reload on post
        //

        dwFlags |= INTERNET_FLAG_RELOAD;
    }

    if (dwFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_PRAGMA_NOCACHE))
    {
        //
        // add "Pragma: No-Cache" header for HTTP 1.0  or
        // add "Cache-Control: No-Cache" header for HTTP 1.1
        // if not already present and if forced with CTRL+F5
        // add "Pragma: No-Cache" header if through proxy.
        //
        BOOL fUseProxy = FALSE;
        fUseProxy = IsRequestUsingProxy();

        if ( fUseProxy || !(dwFlags & INTERNET_FLAG_RESYNCHRONIZE) )
        {
            if ((!fUseProxy && GlobalEnableHttp1_1))
            {
            ReplaceRequestHeader(HTTP_QUERY_CACHE_CONTROL,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
            }
            else
            {
            ReplaceRequestHeader(HTTP_QUERY_PRAGMA,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
            }
        }
    }

quit:

    _RequestHeaders.UnlockHeaders();

    DEBUG_LEAVE(error);
    return error;

}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN BOOL fCallback
    )

/*++

Routine Description:

    Queries Proxy Information, and based on the proxy info it assembles the appropriate
     HTTP request.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo",
                 "%#x, %B",
                 Fsm,
                 fCallback
                 ));

    PERF_ENTER(UpdateProxyInfo);

    DWORD error = ERROR_SUCCESS;

    CFsm_HttpSendRequest & fsm = *Fsm;

    CServerInfo *pProxyServer = NULL;

    INTERNET_HANDLE_OBJECT * pInternet;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    URL_COMPONENTS urlComponents;

    LPSTR lpszObject = NULL;
    DWORD dwcbObject = 0;


    // once we're woken up, we own the obj stored in our FSM.
    INET_ASSERT(fsm.m_fOwnsProxyInfoQueryObj); 

    //
    // Get the Obj Pointers we care about
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Clear our handle state in regards to proxy settings
    //

    SetSocksProxyName(NULL, NULL, NULL);
    SetRequestUsingProxy(FALSE);

    //
    // Parse URL, I have to do this every time,
    //  and even worse we need to do this before our caching code
    //  gets hit, but we can't move it because the quit code
    //  depends on the parsed URL.  In the future we should cache this!!
    //

    error = BuildProxyMessage(
                Fsm,
                &proxyInfoQuery,
                &urlComponents
                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // No proxy installed on this object, bail out
    //

    if ( ! pInternet->IsProxy() && ! IsOverrideProxyMode() )
    {
        INET_ASSERT(fsm.m_pProxyInfoQuery == NULL);
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        goto quit;
    }

    //
    // If we're in the callback, just retrieve the results,
    //  from the orginal blocking call to proxy code
    //

    if ( fsm.m_pProxyInfoQuery )
    {            
        fCallback = TRUE;

        if ( ! (fsm.m_pProxyInfoQuery)->IsBackroundDetectionPending()) {
            (fsm.m_pProxyInfoQuery)->SetQueryOnCallback(TRUE);
        }

        error = QueryProxySettings(Fsm, pInternet, &urlComponents);
        if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy())              
        {
            goto quit;
        }
    }
    else if ((fsm.m_pProxyInfoQuery = &proxyInfoQuery) &&  // !!! put our local in the FSM
              CheckForCachedProxySettings(fsm.m_pProxyInfoQuery, &pProxyServer) 
                != ERROR_SUCCESS )
    {
        //
        // If there is nothing cached, then we'll need
        //  to do the actual proxy request to the proxy code
        // 

        //fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
        proxyInfoQuery.SetShowIndication(TRUE);        

        if (!IsTunnel() && !IsOverrideProxyMode())
        {
            error = QueryProxySettings(Fsm, pInternet, &urlComponents);
            if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy()) {
                goto quit;
            }
        }
        else // fall-back
        {
            //
            // Get the current proxy information,
            //   if we're in an nested SSL tunnell
            //

            GetProxyName(&(fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                         &(fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                         &(fsm.m_pProxyInfoQuery)->_nProxyHostPort
                         );

            (fsm.m_pProxyInfoQuery)->_tProxyScheme = INTERNET_SCHEME_DEFAULT;
            (fsm.m_pProxyInfoQuery)->SetUseProxy(TRUE);
        }
    }

    //
    // Need to figure out whether we're actually talking
    //  to a Server via proxy.  In this case we need to
    //  special case some logic in the Send so we create
    //  a sub-request to the proxy-server, and then do this
    //  request to the main SSL server.
    //

    if ( (fsm.m_pProxyInfoQuery)->IsUseProxy() ) 
    {
        error = ProcessProxySettings(
                    Fsm,
                    pConnect,
                    &urlComponents,
                    &lpszObject,
                    &dwcbObject
                    );    
    }
    else
    {
        // Ensure this is false in case of very slim chance of
        // redirect from internet https to intranet http
        SetIsTalkingToSecureServerViaProxy(FALSE);
    }

quit:

    //
    // If we didn't fail with pending,
    //  go ahead and process the request headers
    //
   
    if ( error != ERROR_IO_PENDING)
    {
        if ( error == ERROR_SUCCESS ) {
            error = UpdateRequestInfo(Fsm, lpszObject, dwcbObject, &urlComponents, &pProxyServer);
        }

        //
        // Now, Unlink the proxyinfomsg struc from the fsm,
        //   if its our stack based variable that we used as a temp
        //

        if ( fsm.m_fOwnsProxyInfoQueryObj &&
             fsm.m_pProxyInfoQuery &&
             ! (fsm.m_pProxyInfoQuery)->IsAlloced() )
        {
            fsm.m_pProxyInfoQuery = NULL;
        }

    }

    //
    // Don't leak objects, Give a hoot, don't pollute !!
    //

    if ( pProxyServer != NULL )
    {
        ::ReleaseServerInfo(pProxyServer);
    }

    if ( lpszObject != NULL &&
         lpszObject != urlComponents.lpszUrlPath)
    {
        FREE_MEMORY(lpszObject);
    }

    PERF_LEAVE(UpdateProxyInfo);

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Determine if Connection: Close added to request headers

Arguments:

    dwIndex - id of Connection header to search for (Connection or
              Proxy-Connection)

Return Value:

    BOOL
        TRUE    - header found

        FALSE   - header not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader",
                 "%d [%s]",
                 dwIndex,
                 InternetMapHttpOption(dwIndex)
                 ));

    BOOL bFound = FALSE;

    if (CheckedConnCloseRequest()) {
        bFound = IsConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION);
    } else {

        LPSTR ptr;
        DWORD len;
        DWORD index = 0;

        while (FastQueryRequestHeader(dwIndex,
                                      (LPVOID *)&ptr,
                                      &len,
                                      index) == ERROR_SUCCESS) {
            if ((len == CLOSE_LEN) && (strnicmp(ptr, CLOSE_SZ, len) == 0)) {
                bFound = TRUE;
                break;
            }
            index++;
        }
        SetCheckedConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION, bFound);
    }

    DEBUG_LEAVE(bFound);

    return bFound;
}

#define ACCEPT_ENCODING_URLMON_STRING "gzip, deflate"
#define ACCEPT_ENCODING_URLMON_STRLEN (sizeof(ACCEPT_ENCODING_URLMON_STRING)-1)

VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveGzipDeflateEncHeader(
    VOID
    )

/*++

Routine Description:
    Removes gzip, deflate encoding headers passed in from urlmon, if we finally 
    use Http 1.0 for the request.
Arguments:
    None
Return Value:
    None

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::RemoveGzipDeflateEncHeader",
                 NULL
                 ));

    LPSTR ptr;
    DWORD len;
    DWORD index = 0;

    while (FastQueryRequestHeader((DWORD)HTTP_QUERY_ACCEPT_ENCODING,
                                  (LPVOID *)&ptr,
                                  &len,
                                  index) == ERROR_SUCCESS) {
        if ((len == ACCEPT_ENCODING_URLMON_STRLEN) &&
            (strnicmp(ptr, ACCEPT_ENCODING_URLMON_STRING, len) == 0)) {
            ReplaceRequestHeader((DWORD)HTTP_QUERY_ACCEPT_ENCODING, NULL, 0,index,0);
        }
        index++;
    }

    DEBUG_LEAVE(0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\constant.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    constant.h

Abstract:

    Contains all internal constant values used in INTERNET.DLL

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// manifests
//

#define K       * 1024
#define M       * 1048576
#define _1K     (1 K)
#define _2K     (2 K)
#define _4K     (4 K)
#define _8K     (8 K)
#define _16K    (16 K)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\apdetect.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apdetect.h

Abstract:

    Some extra stuff to allow registry configuration for
    detect type modes..
    
Author:

    Josh Cohen (joshco)		10-Oct-1998

Environment:

    User Mode - Win32

Revision History:

    Josh Cohen (joshco)		07-Oct-1998
       Created

these are defines for autodetection flags
this allows an admin or tester to easily verify
correct operation of the detection system.
You can control which detection methods are used,
wether or not to force netbios name resolution,
or wether or not to cache the flag.

The default is DNS_A, DHCP, cacheable

--*/


#ifndef PROXY_AUTO_DETECT_TYPE_SAFETY_H
	#define PROXY_AUTO_DETECT_TYPE_SAFETY_H

	#define PROXY_AUTO_DETECT_TYPE_DEFAULT 	67
	// do dns_a, dhcp and cache this flag.
	
	#define PROXY_AUTO_DETECT_TYPE_DHCP 	1
	#define PROXY_AUTO_DETECT_TYPE_DNS_A    2
	#define PROXY_AUTO_DETECT_TYPE_DNS_SRV	4
	#define PROXY_AUTO_DETECT_TYPE_DNS_TXT  8
	#define PROXY_AUTO_DETECT_TYPE_SLP		16

// assume no real domain, netbios
	#define PROXY_AUTO_DETECT_TYPE_NO_DOMAIN 32

// just read this once for performance..
	#define PROXY_AUTO_DETECT_CACHE_ME		64
	
/* this is the default path that we append when
	creating a CURL from a DNS resolve.
	http://wpad/wpad
*/

	#define PROXY_AUTO_DETECT_PATH "wpad.dat"
	
	DWORD
	WINAPI
  		GetProxyDetectType( VOID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\autodial.h ===
#ifndef _AUTODIAL_H_
#define _AUTODIAL_H_

#include <regstr.h>
#include <inetreg.h>
#include <windowsx.h>
#include <rasdlg.h>

// initialization for autodial
void InitAutodialModule(BOOL fGlobalDataNeeded);
void ExitAutodialModule(void);
void ResetAutodialModule(void);
void SetAutodialEnable(BOOL);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// connection mutex name
#define CONNECTION_MUTEX TEXT("WininetConnectionMutex")
// proxy registry mutex name, used to serialze access to proxy settings
#define PROXY_REG_MUTEX TEXT("WininetProxyRegistryMutex")

// typedefs for function pointers for Internet wizard functions
typedef VOID    (WINAPI * INETPERFORMSECURITYCHECK) (HWND,LPBOOL);

#define SMALLBUFLEN     48 // convenient size for small buffers

// callback prototype
extern "C"
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    );

// opcode ordinals for dwOpCode parameter in hook
#define WINSOCK_CALLBACK_CONNECT        1
#define WINSOCK_CALLBACK_GETHOSTBYADDR  2
#define WINSOCK_CALLBACK_GETHOSTBYNAME  3
#define WINSOCK_CALLBACK_LISTEN         4
#define WINSOCK_CALLBACK_RECVFROM       5
#define WINSOCK_CALLBACK_SENDTO         6

// maximum length of local host name
#define MAX_LOCAL_HOST          255

// max length of exported autodial handler function
#define MAX_AUTODIAL_FCNNAME    48

INT_PTR CALLBACK OnlineDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam);
BOOL EnsureRasLoaded(void);
INT_PTR CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConnectDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern const CHAR szRegPathRemoteAccess[];
extern const CHAR szRegPathInternetSettings[];
extern const CHAR szRegValEnableAutodial[];
extern const CHAR szRegValInternetEntry[];

extern HANDLE g_hAutodialMutex;
extern HANDLE g_hProxyRegMutex;

extern BOOL g_fGetHostByNameNULLFails;

//
// Formerly dialmsg.h
//

#define WM_DIALMON_FIRST        (WM_USER + 100)

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY     (WM_DIALMON_FIRST + 0)

// message sent to dial monitor app window when user changes timeout through
// UI, indicating that timeout value or status has changed
#define WM_REFRESH_SETTINGS     (WM_DIALMON_FIRST + 1)

// message sent to dial monitor app window to set the name of the connectoid
// to monitor and eventually disconnect.  lParam should be an LPSTR that
// points to the name of the connectoid.
#define WM_SET_CONNECTOID_NAME  (WM_DIALMON_FIRST + 2)

// message sent to dial monitor app window when app exits
#define WM_IEXPLORER_EXITING    (WM_DIALMON_FIRST + 3)

// yanked from ras.h becuase we include it as ver4.0 and this is ver4.1.
#include <pshpack4.h>
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};
#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define RASCM_UserName          0x00000001
#define RASCM_Password          0x00000002
#define RASCM_Domain            0x00000004

#include <poppack.h>

// Types for ras functions
typedef DWORD (WINAPI* _RASHANGUP) (HRASCONN);

typedef DWORD (WINAPI* _RASDIALA) (LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA,  DWORD, LPVOID, LPHRASCONN);
typedef DWORD (WINAPI* _RASENUMENTRIESA) (LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYDIALPARAMSA) (LPCSTR, LPRASDIALPARAMSA, LPBOOL);
typedef DWORD (WINAPI* _RASSETENTRYDIALPARAMSA) (LPCSTR, LPRASDIALPARAMSA, BOOL);
typedef DWORD (WINAPI* _RASEDITPHONEBOOKENTRYA) (HWND, LPSTR, LPSTR);
typedef DWORD (WINAPI* _RASCREATEPHONEBOOKENTRYA) (HWND, LPSTR);
typedef DWORD (WINAPI* _RASGETERRORSTRINGA) (UINT, LPSTR, DWORD);
typedef DWORD (WINAPI* _RASGETCONNECTSTATUSA) (HRASCONN, LPRASCONNSTATUSA);
typedef DWORD (WINAPI* _RASENUMCONNECTIONSA) (LPRASCONNA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYPROPERTIESA) ( LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD (WINAPI* _RASDIALDLGA) (LPSTR, LPSTR, LPSTR, LPRASDIALDLG);

typedef DWORD (WINAPI* _RASDIALW) (LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW,  DWORD, LPVOID, LPHRASCONN);
typedef DWORD (WINAPI* _RASENUMENTRIESW) (LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYDIALPARAMSW) (LPCWSTR, LPRASDIALPARAMSW, LPBOOL);
typedef DWORD (WINAPI* _RASSETENTRYDIALPARAMSW) (LPCWSTR, LPRASDIALPARAMSW, BOOL);
typedef DWORD (WINAPI* _RASEDITPHONEBOOKENTRYW) (HWND, LPWSTR, LPWSTR);
typedef DWORD (WINAPI* _RASCREATEPHONEBOOKENTRYW) (HWND, LPWSTR);
typedef DWORD (WINAPI* _RASGETERRORSTRINGW) (UINT, LPWSTR, DWORD);
typedef DWORD (WINAPI* _RASGETCONNECTSTATUSW) (HRASCONN, LPRASCONNSTATUSW);
typedef DWORD (WINAPI* _RASENUMCONNECTIONSW) (LPRASCONNW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYPROPERTIESW) ( LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD (WINAPI* _RASDIALDLGW) (LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);
typedef DWORD (WINAPI* _RASGETAUTODIALADDRESSA) (LPCSTR, LPDWORD, LPRASAUTODIALENTRYA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASSETAUTODIALADDRESSA) (LPCSTR, DWORD, LPRASAUTODIALENTRYA, DWORD, DWORD);
typedef DWORD (WINAPI* _RASGETCREDENTIALSW) (LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
typedef DWORD (WINAPI* _RASSETCREDENTIALSW) (LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);

typedef DWORD (WINAPI* _RASINTERNETDIAL) (HWND, LPSTR, DWORD, DWORD_PTR *, DWORD);
typedef DWORD (WINAPI* _RASINTERNETHANGUP) (DWORD_PTR, DWORD);
typedef DWORD (WINAPI* _RASINTERNETAUTODIAL) (DWORD, HWND);
typedef DWORD (WINAPI* _RASINTERNETAUTODIALHANG) (DWORD);
typedef DWORD (WINAPI* _RASINTERNETCONNSTATE) (LPDWORD, LPSTR, DWORD, DWORD);
typedef DWORD (WINAPI* _RNAGETDEFAULTAUTODIAL) (LPSTR, DWORD, LPDWORD);
typedef DWORD (WINAPI* _RNASETDEFAULTAUTODIAL) (LPSTR, DWORD);

// Ras ansi prototypes
DWORD _RasDialA(LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA,  DWORD, LPVOID, LPHRASCONN);
DWORD _RasEnumEntriesA(LPTSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
DWORD _RasGetEntryDialParamsA(LPCSTR, LPRASDIALPARAMSA, LPBOOL);
DWORD _RasSetEntryDialParamsA(LPCSTR, LPRASDIALPARAMSA, BOOL);
DWORD _RasEditPhonebookEntryA(HWND, LPSTR, LPSTR);
DWORD _RasCreatePhonebookEntryA(HWND, LPSTR);
DWORD _RasGetErrorStringA(UINT, LPSTR, DWORD);
DWORD _RasGetConnectStatusA(HRASCONN, LPRASCONNSTATUSA);
DWORD _RasEnumConnectionsA(LPRASCONNA, LPDWORD, LPDWORD);
DWORD _RasGetEntryPropertiesA(LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

// Ras wide prototypes
DWORD _RasDialW(LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW,  DWORD, LPVOID, LPHRASCONN);
DWORD _RasEnumEntriesW(LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
DWORD _RasGetEntryDialParamsW(LPCWSTR, LPRASDIALPARAMSW, LPBOOL);
DWORD _RasSetEntryDialParamsW(LPCWSTR, LPRASDIALPARAMSW, BOOL);
DWORD _RasEditPhonebookEntryW(HWND, LPWSTR, LPWSTR);
DWORD _RasCreatePhonebookEntryW(HWND, LPWSTR);
DWORD _RasGetErrorStringW(UINT, LPWSTR, DWORD);
DWORD _RasGetConnectStatusW(HRASCONN, LPRASCONNSTATUSW);
DWORD _RasEnumConnectionsW(LPRASCONNW, LPDWORD, LPDWORD);
DWORD _RasGetEntryPropertiesW(LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
DWORD _RasGetCredentialsW(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
DWORD _RasSetCredentialsW(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);

DWORD _RasHangUp(HRASCONN);


// how many ras connections do we care about?
#define MAX_CONNECTION          4

#define CI_SAVE_PASSWORD        0x01
#define CI_DIAL_UNATTENDED      0x02
#define CI_AUTO_CONNECT         0x04
#define CI_SHOW_OFFLINE         0x08
#define CI_SHOW_DETAILS         0x10

// Types of network coverage settable from the ui
#define CO_INTERNET             1
#define CO_INTRANET             2

// definition to call RestartDialog in shell32
typedef int (* _RESTARTDIALOG) (HWND, LPCTSTR, DWORD);

// dialstate - passed to DialAndShowProgress
typedef struct _dialstate {
    DWORD       dwResult;       // final result
    DWORD       dwTry;          // number of dial attempts
    DWORD       dwTryCurrent;   // current attempt
    DWORD       dwWait;         // time to wait between them
    DWORD       dwWaitCurrent;  // current time
    HRASCONN    hConn;          // ras connection
    UINT_PTR    uTimerId;       // timer for redial
    HANDLE      hEvent;         // event when dialing is complete
    DWORD       dwFlags;
    RASDIALPARAMSW params;
} DIALSTATE;

BOOL
GetRedialParameters(
    IN LPWSTR pszConn,
    OUT LPDWORD pdwDialAttempts,
    OUT LPDWORD pdwDialInterval
    );

#define DEFAULT_DIAL_ATTEMPTS 10
#define DEFAULT_DIAL_INTERVAL 5

// When dealing with custom dial handler, it will inform us of disconnections.
// We keep an internal state
#define STATE_NONE          0
#define STATE_CONNECTED     1
#define STATE_DISCONNECTED  2

// info relevant to a custom dial handler
typedef struct _autodial {
    BOOL    fConfigured;
    BOOL    fEnabled;
    BOOL    fHasEntry;
    BOOL    fUnattended;
    BOOL    fSecurity;
    BOOL    fForceDial;
    WCHAR   pszEntryName[RAS_MaxEntryName + 1];
} AUTODIAL;

typedef struct __cdhinfo {
    DWORD   dwHandlerFlags;
    WCHAR   pszDllName[MAX_PATH];
    WCHAR   pszFcnName[MAX_PATH];
    BOOL    fHasHandler;
} CDHINFO;

// dummy connection handle used to mean custom dial handler
#define CDH_HCONN   DWORD_PTR(-3)

#define SAFE_RELEASE(a)            \
                if(a)              \
                {                  \
                    a->Release();  \
                    a = NULL;      \
                }

// List of properties supported by CDialEngine
typedef enum {
    PropInvalid,
    PropUserName,
    PropPassword,
    PropDomain,
    PropSavePassword,
    PropPhoneNumber,
    PropRedialCount,
    PropRedialInterval,
    PropLastError,
    PropResolvedPhone
} DIALPROP;

typedef struct _PropMap {
    LPWSTR      pwzProperty;
    DIALPROP    Prop;
} PROPMAP;

//
// Class definitions for default implementations
//
class CDialEngine : IDialEngine
{
private:
    ULONG               m_cRef;
    IDialEventSink *    m_pdes;
    RASDIALPARAMSW      m_rdp;
    RASCREDENTIALSW     m_rcred;
    RASCONNSTATE        m_rcs;
    HRASCONN            m_hConn;
    HWND                m_hwnd;
    BOOL                m_fPassword;
    BOOL                m_fSavePassword;
    BOOL                m_fCurrentlyDialing;
    BOOL                m_fCancelled;
    UINT                m_uRasMsg;
    DWORD               m_dwTryCurrent;
    DWORD               m_dwTryTotal;
    DWORD               m_dwWaitCurrent;
    DWORD               m_dwWaitTotal;
    DWORD               m_dwError;
    UINT_PTR            m_uTimerId;

public:
    CDialEngine();
    ~CDialEngine();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDialEngine members
    STDMETHODIMP         Initialize(LPCWSTR pwzConnectoid, IDialEventSink *pIDES);
    STDMETHODIMP         GetProperty(LPCWSTR pwzProperty, LPWSTR pwzValue, DWORD dwBufSize);
    STDMETHODIMP         SetProperty(LPCWSTR pwzProperty, LPCWSTR pwzValue);
    STDMETHODIMP         Dial();
    STDMETHODIMP         HangUp();
    STDMETHODIMP         GetConnectedState(DWORD *pdwState);
    STDMETHODIMP         GetConnectHandle(DWORD_PTR *pdwHandle);

    // other members
    VOID                 OnRasEvent(RASCONNSTATE rcs, DWORD dwError);
    VOID                 OnTimer();
    static LONG_PTR CALLBACK
                         EngineWndProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    DWORD                MapRCS(RASCONNSTATE rcs);
    VOID                 UpdateRasState();
    STDMETHODIMP         StartConnection();
    STDMETHODIMP         CleanConnection();
    VOID                 EndOfOperation();
    DIALPROP             PropertyToOrdinal(LPCWSTR pwzProperty);
    BOOL                 ResolvePhoneNumber(LPWSTR pwzBuffer, DWORD dwLen);
};

class CDialUI : IDialEventSink
{
private:
    typedef enum tagSTATE
    {
        UISTATE_Interactive,
        UISTATE_Dialing,
        UISTATE_Unattended
    } UISTATE;

    ULONG               m_cRef;
    IDialEngine *       m_pEng;
    IDialBranding *     m_pdb;
    HWND                m_hwndParent;
    HWND                m_hwnd;         // dialog box
    DWORD               m_dwError;      // final dialing result
    DWORD               m_dwFlags;
    UISTATE             m_State;
    BOOL                m_fOfflineSemantics;
    BOOL                m_fSavePassword;
    BOOL                m_fAutoConnect;
    BOOL                m_fPasswordChanged;
    DIALSTATE *         m_pDial;
    BOOL                m_fCDH;
    BOOL                m_fDialedCDH;
    CDHINFO             m_cdh;

public:
    CDialUI(HWND hwndParent);
    ~CDialUI();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDialEventSink members
    STDMETHODIMP         OnEvent(DWORD dwEvent, DWORD dwStatus);

    // other members
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID                 OnInitDialog();
    VOID                 OnConnect();
    VOID                 OnCancel();
    VOID                 OnSelChange();
    DWORD                StartDial(DIALSTATE *pDial, DWORD dwFlags);
    VOID                 EnumerateConnectoids();
    VOID                 SaveProps();
    VOID                 GetProps();
    VOID                 FixUIComponents();

    BOOL DialedCDH(VOID)
    {
        return m_fDialedCDH;
    }
};



// CDH prototypes
BOOL
IsCDH(
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh
    );

BOOL
CallCDH(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh,
    IN DWORD dwOperation,
    OUT LPDWORD lpdwResult
    );

BOOL
IsAutodialEnabled(
    OUT BOOL    *pfForceDial,
    IN AUTODIAL *pConfig
    );

BOOL
FixProxySettingsForCurrentConnection(
    IN BOOL fForceUpdate
    );

VOID
GetConnKeyA(
    IN LPSTR pszConn,
    IN LPSTR pszKey,
    IN int iLen
    );

VOID
GetConnKeyW(
    IN LPWSTR pszConn,
    IN LPWSTR pszKey,
    IN int iLen
    );

BOOL
InternetAutodialIfNotLocalHost(
    IN LPSTR OPTIONAL pszURL,
    IN LPSTR OPTIONAL pszHostName
    );

BOOL
DialIfWin2KCDH(
    LPWSTR              pszEntry,
    HWND                hwndParent,
    BOOL                fHideParent,
    DWORD               *lpdwResult,
    DWORD_PTR           *lpdwConnection
    );

BOOL
InitCommCtrl(
    VOID
    );

VOID
ExitCommCtrl(
    VOID
    );

DWORD
GetAutodialMode(
    );

DWORD
SetAutodialMode(
    IN DWORD dwMode
    );

DWORD
GetAutodialConnection(
    CHAR    *pszBuffer,
    DWORD   dwBufferLength
    );

DWORD
SetAutodialConnection(
    CHAR    *pszConnection
    );

#endif // _AUTODIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\write.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    write.cxx

Abstract:

    This file contains the implementation of the HttpWriteData API.

    Contents:
        HttpWriteData
        HTTP_REQUEST_HANDLE_OBJECT::WriteData

Author:

    Arthur Bierer (arthurbi) 07-Apr-1997

Revision History:



--*/

#include <wininetp.h>
#include "httpp.h"



//
// functions
//

#if !defined(THREAD_POOL)


INTERNETAPI_(BOOL) HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HttpWriteData",
                "%#x, %#x, %d, %#x",
                hRequest,
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    DWORD error;

    //
    // find path from internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequest,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // need to set these for both local and remote paths, in case we're in async
    // mode
    //

    DWORD context;

    error = RGetContext(hRequest, &context);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //InternetSetObjectHandle(hRequest);
    //InternetSetContext(context);

    //
    // Cast it to the object that we know. We are going to do call
    // into the method to do the work.
    //

    HTTP_REQUEST_HANDLE_OBJECT *pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    if (!IS_VALID_HTTP_STATE(pRequest, WRITE, TRUE)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
    } else {
        // This request needs a special CR-LF added to the end at EndRequest
        pRequest->SetAddCRLF(TRUE);
        error = pRequest->WriteData(lpBuffer,
                                   dwNumberOfBytesToWrite,
                                   lpdwNumberOfBytesWritten
                                   );
    }



quit:


    DEBUG_LEAVE(error);

    return error;
}




DWORD
HTTP_REQUEST_HANDLE_OBJECT::WriteData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT WriteData method

    Writes data from users buffer. Writes the data to the currently open
    socket.

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::WriteData",
                "%#x, %d, %#x",
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    DWORD error = ERROR_SUCCESS;

    if ( _Socket == NULL )
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    error = _Socket->Send(lpBuffer, dwNumberOfBytesToWrite, SF_INDICATE);
    if (error == ERROR_SUCCESS)
    {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
    }
    else
    {
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


#else




DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

    dwSocketFlags           - controlling socket operation


Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/


{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpWriteData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(new CFsm_HttpWriteData(lpBuffer,
                                              dwNumberOfBytesToWrite,
                                              lpdwNumberOfBytesWritten,
                                              dwSocketFlags,
                                              (HTTP_REQUEST_HANDLE_OBJECT *)hRequest
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpWriteData::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpWriteData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpWriteData * stateMachine = (CFsm_HttpWriteData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:

        pRequest->SetAddCRLF(TRUE);

        //
        // Fall through
        //

    case FSM_STATE_CONTINUE:
        error = pRequest->HttpWriteData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm(
    IN CFsm_HttpWriteData * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpWriteData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {
        if (!IsValidHttpState(WRITE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
            goto quit;
        }

        error = _Socket->Send(
                           fsm.m_lpBuffer,
                           fsm.m_dwNumberOfBytesToWrite,
                           SF_INDICATE
                           );

    }

    if (error == ERROR_SUCCESS)
    {
        *fsm.m_lpdwNumberOfBytesWritten = fsm.m_dwNumberOfBytesToWrite;
    }


quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


#endif // defined(THREAD_POOL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\socket.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    socket.cxx

Abstract:

    This file contains general socket utilities.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection
        CFsm_OpenConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloseConnection
        HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection
        HTTP_REQUEST_HANDLE_OBJECT::AbortConnection
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel
        CFsm_OpenProxyTunnel::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    18-Dec-1995 rfirth
        Reworked for C++

    27-Mar-1996 arthurbi
        Added OpenProxyTunnel Method

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection(
    IN BOOL bNewConnection,
    IN BOOL fNoCreate /* = FALSE */
    )

/*++

Routine Description:

    Get a connection to the web server. Either use a pre-existing keep-alive
    connection from the global pool or create a new connection

Arguments:

    bNewConnection  - TRUE if we are NOT to get a connection from the keep-alive
                      pool

    fNoCreate       - TRUE if we should NOT create a new socket if a k-a isn't found.
                      This is currently for the SSL tunneling case where we want to break
                      and send a CONNECT if a k-a doesn't match our criteria.
                      

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Opened connection

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection",
                "%B",
                bNewConnection
                ));

    DWORD error = DoFsm(new CFsm_OpenConnection(bNewConnection, this, fNoCreate));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenConnection state

Arguments:

    Fsm - containing open connection state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenConnection * stateMachine = (CFsm_OpenConnection *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm(
    IN CFsm_OpenConnection * Fsm
    )

/*++

Routine Description:

    Open connection FSM

Arguments:

    Fsm - containing state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenConnection & fsm = *Fsm;
    DWORD error = fsm.GetError();
    CServerInfo * pServerInfo = GetServerInfo();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // BUGBUG - redundancy. Either put these in the FSM or figure out why we need
    //          to do proxy name processing here
    //

    //
    // if this object was created from an InternetOpen() handle which specified
    // INTERNET_OPEN_TYPE_PROXY then we connect to the proxy, otherwise we
    // connect to the server specified in InternetConnect()
    //

    LPSTR hostName;
    LPSTR hostNameServer;
    DWORD hostLength;
    INTERNET_PORT hostPort;

    hostName = hostNameServer = GetHostName(&hostLength);
    hostPort = GetHostPort();

    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        SetViaProxy(TRUE);
        hostName = proxyHostName;
        hostLength = proxyHostNameLength;
        hostPort = proxyHostPort;
    }

    INET_ASSERT(hostName != NULL);
    INET_ASSERT(hostPort != INTERNET_INVALID_PORT_NUMBER);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto get_continue;            
        case FSM_STATE_2:
            goto connect_continue;       
        default:

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }
    }

    //
    // we may already have a keep-alive connection - don't ask for a new one.
    // This happens in the challenge phase of a multi-part (e.g. NTLM) auth
    // negotiation over keep-alive
    //

    if (IsWantKeepAlive() && !fsm.m_bNewConnection && (_Socket != NULL)
    && _Socket->IsOpen()) {

        //INET_ASSERT(_bKeepAliveConnection);

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x, ALREADY open on Socket=%#x\n", this, _Socket );
        //}


        error = ERROR_SUCCESS;
        goto quit;
    }

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this request wants a keep-alive connection AND we are allowed to use
    // one (i.e. not forced to generate a new connection) AND we can find one
    // then we're done, otherwise we have to generate a new connection
    //

    DWORD dwSocketFlags;

    dwSocketFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;
    if ((IsWantKeepAlive() || (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION))
    && !fsm.m_bNewConnection) {
        dwSocketFlags |= SF_KEEP_ALIVE;
    }
    if (GetOpenFlags() & INTERNET_FLAG_SECURE) {
        dwSocketFlags |= SF_SECURE;
        if (m_pSecurityInfo && !m_pSecurityInfo->InCache()) {
                // Don't grab a keep-alive if a fully verified cert
                // hasn't been cached.  VerifyTrust only caches after
                // verification has been done with no errors ignored.
                dwSocketFlags &= ~SF_KEEP_ALIVE;
        }
    }
    if ( IsTunnel() )
    {
        dwSocketFlags |= SF_TUNNEL;
        //    dprintf("Opening Tunnel for nested req=%#x, Socket Flags=%#x, K-A=%B, Secure=%B, N-B=%B\n",
        //             this, dwSocketFlags, (dwSocketFlags & SF_KEEP_ALIVE), (dwSocketFlags & SF_SECURE),
        //            (dwSocketFlags & SF_NON_BLOCKING));
    }


    INET_ASSERT(_Socket == NULL);

    _Socket = NULL;
    fsm.SetFunctionState(FSM_STATE_1);

    // If m_fNoCreate flag is set, then we're attempting to find
    // a matching SSL tunnel that's already been established.
    error = DoFsm(new CFsm_GetConnection(
                            dwSocketFlags,
                            fsm.m_fNoCreate ? GetHostPort() : hostPort,
                            GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                            10000,  // dwLimitTimeout
                            &_Socket,
                            pServerInfo,
                            fsm.m_fNoCreate ? hostNameServer : NULL
                            ));

get_continue:

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (_Socket != NULL) {

        //
        // _bKeepAliveConnection now means "this is a pre-existing k-a socket".
        // Only meaningful when re-establishing connect when dropped by server
        //

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x\n opened on K-A Socket=%#x\n", this, _Socket );
        //}


//dprintf("%s existing K-A connection %#x\n", GetURL(), _Socket->GetSocket());
        _bKeepAliveConnection = TRUE;

        //
        // Get any security Info
        //

        if (_Socket->IsSecure()) {
            if (m_pSecurityInfo != NULL) {
                /* SCLE ref */
                m_pSecurityInfo->Release();
            }
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            ((ICSecureSocket*)_Socket)->SetSecureFlags(SECURITY_FLAG_SECURE);
        }

        //
        // successfully got keep-alive connection from the pool
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("%skeep-alive connection: socket %#x, port %d\n",
                    _Socket->IsSecure() ? "SSL " : "",
                    _Socket->GetSocket(),
                    _Socket->GetSourcePort()
                    ));

        goto quit;
    }
    else if (fsm.m_fNoCreate)
    {
        goto quit;
    }

    //
    // the socket didn't come from the pool
    //

    _bKeepAliveConnection = FALSE;

    //
    // we may already have a socket if we're reusing the object
    //

    if (GetOpenFlags() & INTERNET_FLAG_SECURE) {
        _Socket = new ICSecureSocket(GetErrorMask());
        if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            if (NULL == (m_pSecurityInfo = GlobalCertCache.Find(GetHostName()))) {
                /* SCLE ref */
                m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            }
        }

        if (_Socket != NULL) {
            _Socket->SetEncryption();
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetSecurityEntry(&m_pSecurityInfo);
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
            ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
       }
    } else {
        _Socket = new ICSocket;
    }
    if (_Socket != NULL) {
        fsm.m_bCreatedSocket = TRUE;
        
        // If app asks to exempt connection limit for this session, 
        // we mark the Socket accordingly.
        if (ConnLimitExempted())
        {
            _Socket->ExemptConnLimit(); 
        }
    } else {

        //
        // balance number of available connections
        //

        ReleaseConnection(FALSE, FALSE, FALSE);
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Turn on Socks, if needed.
    //

    GetSocksProxyName(&proxyHostName,
                      &proxyHostNameLength,
                      &proxyHostPort
                      );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        _Socket->EnableSocks(proxyHostName, proxyHostPort);
    }

    //
    // NOTE: if secure connection is required, TargetServer must
    //       be a fully qualified domain name.
    //       The hostname is used in comparison with CN found in
    //       the certificate.  The hostname MUST NOT BE the
    //       result of a DNS lookup. DNS lookups are open to
    //       spoofing, and that may prevent a security from
    //       being detected.
    //
    //
    // If we're Posting or sending data, make sure
    //  the SSL connection code knows about it.  Therefore we set
    //  the flag "SF_SENDING_DATA" for the purposes of
    //  generating errors if found while making the connection.
    //

    _Socket->SetPort(hostPort);
    fsm.SetFunctionState(FSM_STATE_2);
    error = _Socket->Connect(GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                             GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                             SF_INDICATE
                             | (IsAsyncHandle() ? SF_NON_BLOCKING : 0)
                             | (((GetMethodType() == HTTP_METHOD_TYPE_POST)
                             || (GetMethodType() == HTTP_METHOD_TYPE_PUT))
                                ? SF_SENDING_DATA
                                : 0)
                             );

connect_continue:

    if (error == ERROR_SUCCESS) {
//dprintf("%s NEW connection %#x\n", GetURL(), _Socket->GetSocket());

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("new connection: socket %#x\n",
                    _Socket->GetSocket()
                    ));

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x opened for Socket=%#x\n", this, _Socket );
        //}


        // This assert is not strictly valid - there is a window in which the Request handle
        // could be closed, invalidating the m_Socket member of ICSocket. (IEv6 bug 24918)
        // Code downstream of this accounts for that possibility.

        // for eg. SetTimeout would lead to a WSA_NOT_SOCK error and the error is replaced with
        // ERROR_CANCELLED. and SetLinger has an Exc. Handler around the winsock call.
        
        //INET_ASSERT(_Socket->IsOpen());

        //pServerInfo->AddActiveConnection();

        //
        // enable receive timeout - ignore any errors
        //

        _Socket->SetTimeout(RECEIVE_TIMEOUT,
                            GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT)
                            );

        //
        // set zero linger: force connection closed at transport level when
        // we close the socket. Ignore the error
        //

        _Socket->SetLinger(TRUE, 0);
    }

quit:

    if (error != ERROR_IO_PENDING) {

        //
        // if we created the socket but failed to connect then delete the socket
        // object
        //

        if ((error != ERROR_SUCCESS) && fsm.m_bCreatedSocket) {

            //
            // we created a socket so we must increase the available connection
            // count on failure
            //
            if (fsm.IsInvalid() && fsm.GetState() == FSM_STATE_ERROR) 
            {
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Fsm in invalid state"));
            }
            else
            {

                INET_ASSERT(_Socket != NULL);

                ReleaseConnection(TRUE,     // close socket (if open)
                                FALSE,    // don't indicate
                                TRUE      // dispose of socket object
                                );
            }
        }
//dprintf("%s get/connect pending socket %#x\n", GetURL(), _Socket ? _Socket->GetSocket() : 0);
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloseConnection(
    IN BOOL bForceClosed
    )

/*++

Routine Description:

    Performs the opposite of OpenConnection(), i.e. closes the socket or marks
    it not in use if keep-alive

Arguments:

    bForceClosed    - TRUE if we are to forcibly release a keep-alive connection
                      (i.e. the server timed out before we did)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::CloseConnection",
                "%B",
                bForceClosed
                ));

//dprintf("*** closing %s%s socket %#x\n",
//        (_bKeepAliveConnection || IsKeepAlive()) ? "K-A " : "",
//        GetURL(),
//        _Socket ? _Socket->GetSocket() : 0
//        );

    DWORD error = ERROR_SUCCESS;
    BOOL bClose = TRUE;
    BOOL bDelete = TRUE;

    if (_Socket == NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("socket already deleted\n"
                    ));

        goto quit;
    }
    if (_bKeepAliveConnection || IsKeepAlive()) {

        //
        // keep-alive connection: just return the connection to the pool
        //

        if ((IsContentLength() && (GetBytesInSocket() != 0))
        || (IsChunkEncoding() && !IsChunkedEncodingFinished())
        || IsNoLongerKeepAlive() || _Socket->IsClosed()
        || ((_State & 0x0F) < (HttpRequestStateObjectData & 0x0F))) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("forcing %#x [%#x] closed: bytes left = %d/%d; no longer k-a = %B; closed = %B\n",
                        _Socket,
                        _Socket->GetSocket(),
                        GetBytesInSocket(),
                        GetContentLength(),
                        IsNoLongerKeepAlive(),
                        _Socket->IsClosed()
                        ));

//dprintf("forcing k-a %#x closed - bytes=%d/%d, no longer=%B, chunked=%B, chunk-finished=%B\n",
//        _Socket->GetSocket(),
//        GetBytesInSocket(),
//        GetContentLength(),
//        IsNoLongerKeepAlive(),
//        IsChunkEncoding(),
//        IsChunkedEncodingFinished()
//        );
            bForceClosed = TRUE;
        }
        if (!bForceClosed) {
            bClose = FALSE;
            bDelete = FALSE;
        } else {
//dprintf("%#x forced close\n", _Socket->GetSocket());
        }
    }

    ReleaseConnection(bClose, TRUE, bDelete);
    _Socket = NULL;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;

quit:

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection(
    IN BOOL bClose,
    IN BOOL bIndicate,
    IN BOOL bDispose
    )

/*++

Routine Description:

    Releases the connection back to the server limited pool and optionally
    closes the socket handle and destroys the socket object

Arguments:

    bClose      - if TRUE, increments the available connection count in the
                  server info object and closes the handle, else we are
                  returning a keep-alive connection; after this call we no
                  longer have a socket object owned by this request handle
                  object

    bIndicate   - TRUE if we indicate to the user when we close the socket
                  handle

    bDispose    - TRUE if we are disposing of the socket object (mutually
                  exclusive with !bClose), in which case we will no longer have
                  a socket object after this call returns

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection",
                 "%B, %B, %B",
                 bClose,
                 bIndicate,
                 bDispose
                 ));


    INET_ASSERT(_Socket != NULL);
    //INET_ASSERT(_Socket->IsOpen());

    BOOL fExemptConnLimit = _Socket->ConnLimitExempted();

    CServerInfo * pServerInfo = GetServerInfo();

    // Always disconnect sockets which have been marked as authenticated.
    // This is to avoid posting data to IIS4 while preauthenticating
    // and inducing the server to close the connection.
    if (_Socket)
        bClose = (bClose || _Socket->IsAuthenticated());
        
    ICSocket * pSocket = bClose ? NULL : _Socket;

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo != NULL) {
        if (bClose && (_Socket != NULL)) {

            //
            // BUGBUG - this should be set based on bGraceful parameter
            //

            _Socket->SetLinger(FALSE, 0);

            //INET_ASSERT(!_bKeepAliveConnection || _bNoLongerKeepAlive);

            _Socket->Disconnect(bIndicate ? SF_INDICATE : 0);
            if (bDispose) {
                _Socket->Dereference();
                _Socket = NULL;
            }
        } else {
            _Socket = NULL;
        }
        //if (IsResponseHttp1_1() && IsKeepAlive()) {
        //    pServerInfo->ReleasePipelinedConnection(pSocket);
        //} else {
            pServerInfo->ReleaseConnection(pSocket, fExemptConnLimit);
        //}
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AbortConnection(
    IN BOOL bForce
    )

/*++

Routine Description:

    Aborts the current connection. Closes the socket and frees up all receive
    buffers. If the connection is keep-alive, we have the option to forcefully
    terminate the connection, or just return the socket to the keep-alive pool

Arguments:

    bForce  - if TRUE and keep-alive, forcefully close the keep-alive socket

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::AbortConnection",
                "%B",
                bForce
                ));

    DWORD error;

    error = CloseConnection(bForce);
    if (error == ERROR_SUCCESS) {

        //
        // destroy all response variables. This is similar to ReuseObject()
        // except we don't change the object state, or reset the end-of-file
        // state
        //

        _ResponseHeaders.FreeHeaders();
        FreeResponseBuffer();
        ResetResponseVariables();
        _dwCurrentStreamPosition = 0;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel(
    VOID
    )

/*++

Routine Description:

    Creates a connection with the requested server via a Proxy
    tunnelling method.

    Works by creating a nested child HTTP and Connect request object.
    These objects send a "CONNECT" verb to the proxy server asking for
    a connection to made with the destination server. Upon completion the
    child objects are discarded.  If a class 200 response is not received from
    proxy server, the proxy response is copied into this object
    and returned to the user.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel",
                 NULL
                 ));

    DWORD error = DoFsm(new CFsm_OpenProxyTunnel(this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenProxyTunnel::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenProxyTunnel state

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenProxyTunnel::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenProxyTunnel * stateMachine = (CFsm_OpenProxyTunnel *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->OpenProxyTunnel_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm(
    IN CFsm_OpenProxyTunnel * Fsm
    )

/*++

Routine Description:

    State machine for OpenProxyTunnel

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenProxyTunnel & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    // Need to bury error on blocked item that failed to find
    // established SSL tunnel
    if (error != ERROR_SUCCESS && fsm.GetFunctionState() != FSM_STATE_2) {
        goto quit;
    }
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }
    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto send_continue;

        case FSM_STATE_2:
            goto keep_alive_tunnel;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);
            goto quit;
        }
    }

    // Do not continue if handle is in NTLM challenge state - we
    // already have a valid socket set up for tunnelling.
    if ((_Socket != NULL) && (GetAuthState() == AUTHSTATE_CHALLENGE))
    {
        DEBUG_PRINT(
            HTTP,
            INFO,
            ("authstate is %s, completing auth over existing tunnel\n", InternetMapAuthState(GetAuthState()))
            );

        error = ERROR_SUCCESS;
        goto quit;
    }

    // First, try and fetch an already established tunnel
    // from the keep-alive pool.  If so, we can avoid the nested
    // CONNECT request.
    //
    if (_Socket == NULL)
    {
        error = OpenConnection(FALSE, TRUE);

        if (error == ERROR_IO_PENDING)
        {
            fsm.SetFunctionState(FSM_STATE_2);
            goto quit;
        }
keep_alive_tunnel:
        if (error == ERROR_SUCCESS && _Socket != NULL)
        {
            // No need to create nested request.  We found an active SSL tunnel
            // for this server in the keep-alive pool.
            goto quit;
        }
        else
        {
            // Start over as normal tunnel since bypass to find
            // keep-alive failed.
            error = ERROR_SUCCESS;
        }
    }

    //
    // Handle Magic... Get the Internet Handle Object,
    //  then constuct a new Connect Object, and new HttpRequest Object.
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();
    INET_ASSERT(pConnect != NULL);

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();
    INET_ASSERT(pInternet != NULL);

    //
    // increment the nested request level around InternetConnect(). This is
    // required to stop InternetConnect() believing this is the async part of
    // a two-part (FTP) request (original async hackery)
    //

    _InternetIncNestingCount();
    fsm.m_hConnect = InternetConnect(pInternet->GetPseudoHandle(),
                                     GetHostName(),
                                     GetHostPort(),
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0, // no flags
                                     INTERNET_NO_CALLBACK
                                     );
    _InternetDecNestingCount(1);
    if (!fsm.m_hConnect) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_IO_PENDING);

        goto quit;
    }

    //
    // Now do an Open Request. This will pick up the secure proxy flag.
    //

    fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                     "CONNECT",
                                     "/",    // we don't need this for a CONNECT
                                     NULL,
                                     NULL,
                                     NULL,
                                     (GetInternetOpenFlags() & INTERNET_FLAG_ASYNC)
                                     | INTERNET_FLAG_RELOAD
                                     | INTERNET_FLAG_NO_CACHE_WRITE
                                     | INTERNET_FLAG_NO_AUTO_REDIRECT
                                     | INTERNET_FLAG_NO_COOKIES
                                     | INTERNET_FLAG_KEEP_CONNECTION, 
                                     INTERNET_NO_CALLBACK  // should be _Context?
                                     //_Context
                                     );
    if (!fsm.m_hRequest) {
        error = GetLastError();
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(fsm.m_hRequest,
                               (LPVOID *)&fsm.m_hRequestMapped,
                               FALSE);
    if ((error != ERROR_SUCCESS) || (fsm.m_hRequestMapped == NULL)) {
        goto quit;
    }

    fsm.m_pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.m_hRequestMapped;

    //
    // we need to set the special secure proxy flag in the request object
    //

    fsm.m_pRequest->SetTunnel();


    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );
    fsm.m_pRequest->SetProxyName(proxyHostName,
                                 proxyHostNameLength,
                                 proxyHostPort
                                 );

    //
    // Transfer any proxy user/pass from the handle.
    //
    LPSTR lpszUser, lpszPass;

    // Get and invalidate username + password off of outer handle.
    if (GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
    {
        // This will automatically re-validate the username/password
        // on the tunneling handle.
        fsm.m_pRequest->SetUserOrPass (lpszUser, IS_USER, IS_PROXY);
        fsm.m_pRequest->SetUserOrPass (lpszPass, IS_PASS, IS_PROXY);
    }

    //
    // Transfer any authentication context to the tunnelling handle.
    //

    //fsm.m_pRequest->SetAuthCtx (_pTunnelAuthCtx);


    //dprintf("New tunnel request %#x making nested request= %#x\n", this, fsm.m_pRequest);

    //
    // Do the Nested SendRequest to the Proxy Server.
    //  ie send the CONNECT method.
    //

    if (ShouldSendUTF8ServerNameToProxy())
    {
        DWORD dwSendUTF8 = 1;
        DWORD dwCodePage = GetCodePage();
        InternetSetOption(fsm.m_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
        InternetSetOption(fsm.m_hRequest, INTERNET_OPTION_CODEPAGE, &dwCodePage, sizeof(DWORD));
    }
    fsm.SetFunctionState(FSM_STATE_1);
    if (!HttpSendRequest(fsm.m_hRequest, NULL, 0, NULL, 0)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            goto done;
        }
        goto quit;
    }

send_continue:

    //
    // Check Status Code Returned from proxy Server Here.
    // If its not 200 we let the user view it as a Proxy Error
    //  and DON'T continue our connection to the SSL/PCT Server.
    //

    //dprintf("Received Nested Response, Socket=%#x, org request=%#x, nested request=%#x\n", fsm.m_pRequest->_Socket, this, fsm.m_pRequest);

    _StatusCode = fsm.m_pRequest->GetStatusCode();

    switch (_StatusCode) {

        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_PROXY_AUTH_REQ:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            break;

        default:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            goto quit;
    }

    //
    // Transfer any authentication context back to the outer handle.
    //

    if ( _pTunnelAuthCtx ) {
        delete _pTunnelAuthCtx;
    }

    _pTunnelAuthCtx = fsm.m_pRequest->GetAuthCtx();
    
    if (_pTunnelAuthCtx)
    {
        _pTunnelAuthCtx->_pRequest = NULL;
    }

    fsm.m_pRequest->SetAuthCtx (NULL);

    //
    // pull the socket handle from the socket object used to communicate with
    // the proxy
    //

    INET_ASSERT(fsm.m_pRequest->_Socket != NULL);

    /*
    if server returned anything other than 200 then we failed; revert to non-
    secure socket
    */

    if (_Socket == NULL) {
        _Socket = new ICSecureSocket(GetErrorMask());
    }
    if(m_pSecurityInfo == NULL)
    {
        /* SCLE ref */
        if(NULL == (m_pSecurityInfo = GlobalCertCache.Find(GetHostName())))
        {
            /* SCLE ref */
            m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    if (_Socket != NULL) {

        INET_ASSERT(_Socket->IsSecure());
        INET_ASSERT(_Socket->IsClosed());

        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetSecurityEntry(&m_pSecurityInfo);
        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
        ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);

    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    _Socket->SetSocket(fsm.m_pRequest->_Socket->GetSocket());
    _Socket->SetSourcePort(fsm.m_pRequest->_Socket->GetSourcePort());
    _Socket->SetPort(fsm.m_pRequest->GetHostPort());
    if (fsm.m_pRequest->_Socket->ConnLimitExempted())
    {
        _Socket->ExemptConnLimit();
    }

    //
    // we need to destroy the ICSocket object in the tunnelled request handle
    // because we don't want to influence the available connection count when
    // we close the connection when we close the handle below
    //

    fsm.m_pRequest->_Socket->SetLinger(FALSE, 0);
    fsm.m_pRequest->_Socket->SetSocket(INVALID_SOCKET);
    fsm.m_pRequest->_Socket->Destroy();
    fsm.m_pRequest->_Socket = NULL;

quit:

    if (fsm.m_hRequestMapped != NULL) {
        DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    }

    if (fsm.m_hRequest != NULL) {

        BOOL bOk;
        bOk = InternetCloseHandle(fsm.m_hRequest);
        INET_ASSERT(bOk);
    }

    if (fsm.m_hConnect != NULL) {

        BOOL bOk;
        bOk = InternetCloseHandle(fsm.m_hConnect);
        INET_ASSERT(bOk);
    }

    //
    // We Reset the ThreadInfo back to the the previous
    //  object handle, and context values.
    //

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, GetPseudoHandle(), (HINTERNET)this);
        _InternetClearLastError(lpThreadInfo);
        _InternetSetContext(lpThreadInfo, GetContext());
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN HTTP_REQUEST_HANDLE_OBJECT *pChildRequestObj
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 pChildRequestObj
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(pChildRequestObj->_BytesReceived);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pChildRequestObj->_ResponseBuffer,
           pChildRequestObj->_BytesReceived
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                pChildRequestObj->_BytesReceived
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

    //
    // Copy any chunk-transfer information.
    //

    if ( pChildRequestObj->IsChunkEncoding() )
    {
        _ctChunkInfo = pChildRequestObj->_ctChunkInfo;
        _ResponseBufferDataReadyToRead = pChildRequestObj->_ResponseBufferDataReadyToRead;
        SetHaveChunkEncoding(TRUE);
    }

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN LPBYTE pBuffer,
    IN DWORD dwBufferLen
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 0
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(dwBufferLen);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pBuffer,
           dwBufferLen
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                dwBufferLen
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

    //
    // Copy any chunk-transfer information.
    //

    /*
    if ( pChildRequestObj->IsChunkEncoding() )
    {
        _ctChunkInfo = pChildRequestObj->_ctChunkInfo;
        _ResponseBufferDataReadyToRead = pChildRequestObj->_ResponseBufferDataReadyToRead;
        SetHaveChunkEncoding(TRUE);
    }
    */

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\cookie.h ===
// cookie.h - header for external cookie funcs code.


BOOL OpenTheCookieJar();
void CloseTheCookieJar();
VOID PurgeCookieJarOfStaleCookies();


#define COOKIE_SECURE   INTERNET_COOKIE_IS_SECURE
#define COOKIE_SESSION  INTERNET_COOKIE_IS_SESSION      // never saved to disk
#define COOKIE_RESTRICT INTERNET_COOKIE_IS_RESTRICTED   // only used for 1st party context

#define COOKIE_P3PPOLICY    0x10000         // the cookie has associated P3P policy

#define COOKIE_NOUI     4

BOOL InternetGetCookieEx( LPCSTR pchURL, LPCSTR pchCookieName, LPSTR pchCookieData OPTIONAL,
                          LPDWORD pcchCookieData, DWORD dwFlags, LPVOID lpReserved);


BOOL InternalInternetSetCookie( LPCSTR  pchURL, LPCSTR  pchCookieName, LPCSTR  pchCookieData,
                          DWORD dwFlags, LPVOID lpReserved);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\http\hashgen\hashgen.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hashgen.cpp

Abstract:

    Table Generator for hhead.cxx, which contains all known HTTP headers for wininet project.
        This is also the location where all known HTTP headers must be added.

Author:

    Arthur Bierer (arthurbi) 12-Jan-1998

Revision History:

--*/

//
// Instructions for adding new HTTP header:
// 1. Update wininet.w and rebuild wininet.h with new HTTP_QUERY_ code
// 2. Add/Edit header to this file/program, hashgen.cpp with the 
//     new header string (see Items[] array below)
// 3. Compile new hashgen.exe, Execute with -o, write down a good seed
//      note that this may take all night to find a good seed which
//      give a nice smaller table size. (note this can be skipped if
//      you just need a quick table for dev purposes) 
// 4. Re-Execute hashgen.exe with -b# set with your seed to generate
//     hhead.cxx
// 5. Transfer new hhead.cxx file to wininet\http
// 6. Update const defines MAX_HEADER_HASH_SIZE and HEADER_HASH_SEED
//     from new hhead.cxx to wininet\http\headers.h
// 7. Transfer and checkin hashgen.cpp, wininet.w, headers,h, hhead.cxx
//     in their appropriate directories.
//


//
// Includes...
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <wininet.h>

//
// macros
//

#define IS_ARG(c)   ((c) == '-')
#define DIM(x)	(sizeof(x) / sizeof(x[0]))

#define ENUMDEF(x, y) ,x, #x, #y
#define OUTPUT_CODE_FILE "hhead.cxx" 
#define MAX_SIZE_HASHARRAY_TO_ATTEMPT 600
#define UNKNOWN_HASH_ENTRY 0 // character to put in array when when its not valid

//
// Items - This is the array that must be edited for Wininet to process new 
//  HTTP headers
//
//  Things to keep in mind before you add to this array
//  1. Headers are Alphatized for convience sake
//  2. All NULL entries MUST be at the end of the array
//  3. All HTTP_QUERY_* codes in wininet.h MUST have an entry even if they are not strings
//  4. Entries are as follows: 
//      header string, HTTP_QUERY_* code in wininet.h, flags used in wininet\http\query.cxx
//  5. All entries must be in lowercase.
//


struct Item
{
    char  *ptok;
    DWORD id;
    char  *pidName;
    char  *pFlagsName;
} Items[] = 
{
{ "Accept"              ENUMDEF(HTTP_QUERY_ACCEPT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Charset"      ENUMDEF(HTTP_QUERY_ACCEPT_CHARSET, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Encoding"     ENUMDEF(HTTP_QUERY_ACCEPT_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Language"     ENUMDEF(HTTP_QUERY_ACCEPT_LANGUAGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Ranges"       ENUMDEF(HTTP_QUERY_ACCEPT_RANGES, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Age"                 ENUMDEF(HTTP_QUERY_AGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Allow"               ENUMDEF(HTTP_QUERY_ALLOW, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Authorization"       ENUMDEF(HTTP_QUERY_AUTHORIZATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Cache-Control"       ENUMDEF(HTTP_QUERY_CACHE_CONTROL, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Connection"          ENUMDEF(HTTP_QUERY_CONNECTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Base"        ENUMDEF(HTTP_QUERY_CONTENT_BASE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Description" ENUMDEF(HTTP_QUERY_CONTENT_DESCRIPTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Disposition" ENUMDEF(HTTP_QUERY_CONTENT_DISPOSITION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Encoding"    ENUMDEF(HTTP_QUERY_CONTENT_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Id"          ENUMDEF(HTTP_QUERY_CONTENT_ID, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Language"    ENUMDEF(HTTP_QUERY_CONTENT_LANGUAGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Length"      ENUMDEF(HTTP_QUERY_CONTENT_LENGTH, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER)) },
{ "Content-Location"    ENUMDEF(HTTP_QUERY_CONTENT_LOCATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Md5"         ENUMDEF(HTTP_QUERY_CONTENT_MD5, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Range"       ENUMDEF(HTTP_QUERY_CONTENT_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Transfer-Encoding" ENUMDEF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Type"        ENUMDEF(HTTP_QUERY_CONTENT_TYPE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },                    
{ "Cookie"              ENUMDEF(HTTP_QUERY_COOKIE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Cost"                ENUMDEF(HTTP_QUERY_COST, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Date"                ENUMDEF(HTTP_QUERY_DATE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Derived-From"        ENUMDEF(HTTP_QUERY_DERIVED_FROM, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Etag"                ENUMDEF(HTTP_QUERY_ETAG, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Expect"              ENUMDEF(HTTP_QUERY_EXPECT, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Expires"             ENUMDEF(HTTP_QUERY_EXPIRES, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Forwarded"           ENUMDEF(HTTP_QUERY_FORWARDED, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "From"                ENUMDEF(HTTP_QUERY_FROM, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Host"                ENUMDEF(HTTP_QUERY_HOST, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Modified-Since"   ENUMDEF(HTTP_QUERY_IF_MODIFIED_SINCE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "If-Match"            ENUMDEF(HTTP_QUERY_IF_MATCH, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-None-Match"       ENUMDEF(HTTP_QUERY_IF_NONE_MATCH, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Range"            ENUMDEF(HTTP_QUERY_IF_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Unmodified-Since" ENUMDEF(HTTP_QUERY_IF_UNMODIFIED_SINCE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Last-Modified"       ENUMDEF(HTTP_QUERY_LAST_MODIFIED, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Link"                ENUMDEF(HTTP_QUERY_LINK, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Location"            ENUMDEF(HTTP_QUERY_LOCATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Mime-Version"        ENUMDEF(HTTP_QUERY_MIME_VERSION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Max-Forwards"        ENUMDEF(HTTP_QUERY_MAX_FORWARDS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Message-id"          ENUMDEF(HTTP_QUERY_MESSAGE_ID, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Ms-Echo-Request"     ENUMDEF(HTTP_QUERY_ECHO_REQUEST, 0) },
{ "Ms-Echo-Reply"       ENUMDEF(HTTP_QUERY_ECHO_REPLY, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Orig-Uri"            ENUMDEF(HTTP_QUERY_ORIG_URI, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Pragma"              ENUMDEF(HTTP_QUERY_PRAGMA, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Authenticate"  ENUMDEF(HTTP_QUERY_PROXY_AUTHENTICATE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Authorization" ENUMDEF(HTTP_QUERY_PROXY_AUTHORIZATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Connection"    ENUMDEF(HTTP_QUERY_PROXY_CONNECTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Support"       ENUMDEF(HTTP_QUERY_PROXY_SUPPORT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Public"              ENUMDEF(HTTP_QUERY_PUBLIC, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Range"               ENUMDEF(HTTP_QUERY_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Referer"             ENUMDEF(HTTP_QUERY_REFERER, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Refresh"             ENUMDEF(HTTP_QUERY_REFRESH, 0) },
{ "Retry-After"         ENUMDEF(HTTP_QUERY_RETRY_AFTER, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Server"              ENUMDEF(HTTP_QUERY_SERVER, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Set-Cookie"          ENUMDEF(HTTP_QUERY_SET_COOKIE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Title"               ENUMDEF(HTTP_QUERY_TITLE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Transfer-Encoding"   ENUMDEF(HTTP_QUERY_TRANSFER_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Unless-Modified-Since" ENUMDEF(HTTP_QUERY_UNLESS_MODIFIED_SINCE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Upgrade"             ENUMDEF(HTTP_QUERY_UPGRADE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Uri"                 ENUMDEF(HTTP_QUERY_URI, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "User-Agent"          ENUMDEF(HTTP_QUERY_USER_AGENT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Vary"                ENUMDEF(HTTP_QUERY_VARY, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Via"                 ENUMDEF(HTTP_QUERY_VIA, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Warning"             ENUMDEF(HTTP_QUERY_WARNING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "WWW-Authenticate"    ENUMDEF(HTTP_QUERY_WWW_AUTHENTICATE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Authentication-Info" ENUMDEF(HTTP_QUERY_AUTHENTICATION_INFO, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "PassportURLs"        ENUMDEF(HTTP_QUERY_PASSPORT_URLS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "PassportConfig"      ENUMDEF(HTTP_QUERY_PASSPORT_CONFIG, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
// NULL strs must be in end of array
{  NULL                 ENUMDEF(HTTP_QUERY_VERSION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },         
{  NULL                 ENUMDEF(HTTP_QUERY_STATUS_CODE, HTTP_QUERY_FLAG_NUMBER) },
{  NULL                 ENUMDEF(HTTP_QUERY_STATUS_TEXT, 0) },
{  NULL                 ENUMDEF(HTTP_QUERY_RAW_HEADERS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_RAW_HEADERS_CRLF, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_REQUEST_METHOD, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_ECHO_HEADERS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_ECHO_HEADERS_CRLF, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
};


//
// Declarations of common strings used in creating output "C" file
//

char szFileHeader[] = 
{"/*++\n\n"
 "Copyright (c) 1997 Microsoft Corporation\n\n"
 "Module Name:\n\n"
 "    "
 OUTPUT_CODE_FILE
 "\n\n"
 "Abstract:\n\n"
 "    This file contains autogenerated table values of a perfect hash function\n"
 "    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp\n"
 "    Contents:\n"
 "      GlobalKnownHeaders\n"
 "      GlobalHeaderHashs\n\n"
 "Author:\n\n"
 "   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]\n\n"
 "Revision History:\n\n"
 "--*/\n\n\n" };


char szComment1[] = {
"//\n"
"// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.\n"
"// This array must be used with the same hash function used to generate it.\n"
"// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.\n"
"//   0-ed entries indicate error values\n"
"//\n\n" };

char szComment2[] = {
"//\n"
"// GlobalKnownHeaders - array of HTTP request and response headers that we understand.\n"
"// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H\n"
"//\n\n" 
"#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal\n\n" };

char szDef1[] = {
"#ifdef HEADER_HASH_SEED\n"
"#if (HEADER_HASH_SEED != %u)\n"
"#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header\n"
"#endif\n"
"#else\n"
"#define HEADER_HASH_SEED %u\n"
"#endif\n\n" };

char szDef2[] = {
"#ifdef MAX_HEADER_HASH_SIZE\n"
"#if (MAX_HEADER_HASH_SIZE != %u)\n"
"#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header\n"
"#endif\n"
"#else\n"
"#define MAX_HEADER_HASH_SIZE %u\n"
"#endif\n\n" };

char szDef3[] = {
"#ifdef HTTP_QUERY_MAX\n"
"#if (HTTP_QUERY_MAX != %u)\n"
"#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp\n"
"#endif\n"
"#endif\n\n" };


char szIncludes[] = {
"#include <wininetp.h>\n"
"#include \"httpp.h\"\n\n" };


//
// Hash - function used to create table, 
//   THIS FUNCTION MUST BE THE SAME AS THE ONE USED in WININET
//

DWORD Hash(char *pszName, DWORD j, DWORD seed)
{
	DWORD hash = seed;

	while (*pszName)
	{
		hash += (hash << 5) + *pszName++;
	}
    return (j==0) ? hash : hash % j;
}

//
// CompareItems - a util function for qsort-ing by ID for table creation
//   in the output file
//

int __cdecl CompareItems (const void *elem1, const void *elem2 ) 
{
    const struct Item *pItem1, *pItem2;

    pItem1 = (struct Item *) elem1;
    pItem2 = (struct Item *) elem2;

    if ( pItem1->id < pItem2->id )    
    {
        return -1;
    }
    else if ( pItem1->id > pItem2->id )
    {
        return 1;
    }

    return 0;
}


//
// usage() - print out our usage instructions to command line
//

void usage() {
    fprintf(stderr,
           "\n"
           "usage: hashgen [-m[#]] [-b[#]] [-t[#]] [-o] [-p<path>] [-f<filename>]\n"
           "\n"
           "where: -m[#] = Max hash table size to test with, default = 600\n"
           "       -b[#] = Starting hash seed, default = 0\n"
           "       -t[#] = Threshold of table size to halt search at, default = 200\n"
           "       -o    = Enable optimal exhaustive search mode (can take 24+ hrs)\n"
           "       -p    = Path used for output generation\n"
           "       -f    = Output filename, \"hhead.cxx\" is assumed\n"
           "\n"
           "Instructions for adding new HTTP header:\n"
           "\t1. Update wininet.w and rebuild wininet.h with new HTTP_QUERY_ code\n"
           "\t2. Add/Edit this file/program, hashgen.cpp with the new header string\n"
           "\t3. Compile/Execute new hashgen.exe with -o, write down a good seed\n"
           "\t4. Re-Execute hashgen.exe with -b# set with your seed to generate\n"
           "\t    hhead.cxx\n"
           "\t5. Transfer new hhead.cxx file to wininet\\http\n"
           "\t6. Update const defines MAX_HEADER_HASH_SIZE and HEADER_HASH_SEED\n"
           "\t    from new hhead.cxx to wininet\\http\\headers.h\n"
           "\t7. Transfer and checkin hashgen.cpp, wininet.w, headers,h, hhead.cxx\n"
           );
    exit(1);
}

//
// MakeMeLower - Makes a lower case string using a static 255 byte array
//

LPSTR
MakeMeLower(
    IN LPSTR lpszMixedCaseStr
    )
{
    static CHAR szLowerCased[256];

    if ( lstrlen(lpszMixedCaseStr) > 255 ) 
    {
        fprintf(stderr, "Internal error: an HTTP header is too long\n\n");
        return szLowerCased;
    }

    lstrcpy( szLowerCased, lpszMixedCaseStr );
    CharLower(szLowerCased);

    return szLowerCased;
}
     


//
// main - where it all gets done !!!!
//

void
__cdecl
//_CRTAPI1
main(
    int   argc,
    char * argv[]
    )
{
    DWORD nMax = MAX_SIZE_HASHARRAY_TO_ATTEMPT;
    DWORD dwBestNumber = 0, dwBestSeed = 0 /*349160*/ /*4458*//*202521*/;
    DWORD dwSearchThreshold = 200;
    BOOL bFoundOne = FALSE;
    BOOL bFindOptimalSeed = FALSE;
    LPSTR szPath = "";
    LPSTR szFileName = OUTPUT_CODE_FILE;
	DWORD i, j, k;
    DWORD dwValidStringsInArray = 0;
	DWORD *pHash = new DWORD[nMax];

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'm':
                nMax = (DWORD)atoi(++*argv);
                break;

            case 'b':
                dwBestSeed = (DWORD)atoi(++*argv);
                break;

            case 't':
                dwSearchThreshold = (DWORD)atoi(++*argv);
                break;
            
            case 'p':
                szPath = ++*argv;
                break;

            case 'f':
                szFileName = ++*argv;
                break;

            case 'o':
                bFindOptimalSeed = TRUE;
                break;
            default:
                fprintf(stderr,"error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }         
        } else {
            fprintf(stderr,"error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    //
    // Let the Work begin...
    //

    dwBestNumber = nMax;

    if (bFindOptimalSeed)
    {
        printf("This will take a while, perhaps all night(consider a Ctrl-C)...\n");
    }

    for (i = 0; i < DIM(Items); i++ )
    {
        if ( Items[i].ptok )
            dwValidStringsInArray++;
    }

	for (i = dwBestSeed; i < (~0); i++)
	{
		//printf("%d,\n", i);
		for (j = dwValidStringsInArray; j < nMax; j++)
		{
            memset (pHash, UNKNOWN_HASH_ENTRY, nMax * sizeof(DWORD));
			for (k = 0; k < dwValidStringsInArray; k++)
			{
				DWORD HashNow = Hash(MakeMeLower(Items[k].ptok), j, i) /*% j(table_size), i(seed)*/;

                if ( HashNow > j )
                {
                    fprintf(stderr, "Error, Error - exceed table size, bad hash alg\n");
                    break;
                }

                if (pHash[HashNow] != UNKNOWN_HASH_ENTRY)
                    break;
                else
                {
                    pHash[HashNow] = Items[k].id+1;
                }
			}

            if ( k == dwValidStringsInArray )
            {
                //printf( "Found one with hash_size=%d, seed=%u...\n", j,i );
                bFoundOne = TRUE;
                goto found_one;
            }
		}
found_one:

        if ( bFoundOne )
        {
            if (j < dwBestNumber)
            {
                dwBestNumber = j;
                dwBestSeed = i;

                printf("Found a New One, hashtable_size=%d, seed=%u...\n", j ,i);
                
                if ( !bFindOptimalSeed && dwBestNumber < dwSearchThreshold )
                {
                    goto stop_search;
                }
            }

            bFoundOne = FALSE;
        }
	}

stop_search:

    if ( dwBestNumber < nMax && dwBestNumber == j)
    {
        printf("Generating %s which contains, perfect hash for known headers\n", OUTPUT_CODE_FILE);

	    FILE *f;
        CHAR szOutputFileAndPath[512];

        strcpy(szOutputFileAndPath, szPath);
        strcat(szOutputFileAndPath, szFileName);

        f = fopen(szOutputFileAndPath, "w");

        if ( f == NULL )
        {
            fprintf(stderr, "Err: Could Not Open %s for writing\n", szOutputFileAndPath);
            exit(-1);
        }

        fprintf(f, szFileHeader); // print header

        fprintf(f, szIncludes); // includes

        fprintf(f, szDef1, dwBestSeed, dwBestSeed);
        fprintf(f, szDef2, dwBestNumber, dwBestNumber);
        fprintf(f, szDef3, HTTP_QUERY_MAX);

        fprintf(f, szComment1); // print comment
         
        if ( dwBestNumber < 255 )
        {       
            fprintf(f, "const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {\n");
        }
        else
        {
            fprintf(f, "const WORD GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {\n");
        }
        
        DWORD col = 0;

        //
        // spit our Nicely calculated perfect hash table..         
        //

        for ( i = 0; i < dwBestNumber; i++ )
        {
            col++;
            if ( col == 1 )
            {
                fprintf(f, "    ");
            }

            fprintf(f, "%3u, ", (BYTE) pHash[i]);    

            if ( col == 6 )
            {
                fprintf(f, "\n");
                col = 0;
            }
        }

        fprintf(f, "\n   };\n\n");


        //
        // Now spit our KnownHeader array...
        //
            
        qsort(Items, DIM(Items), sizeof(Items[0]), CompareItems);

        fprintf(f, szComment2);

        if ( DIM(Items) != (HTTP_QUERY_MAX+1) )
        {
            fprintf(stderr, "ERROR, HTTP_QUERY_MAX the wrong size,( different wininet.h's? )\n");
            return;
        }

        fprintf(f, "const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {\n");

	    for (j = 0; j < DIM(Items); j++)
	    {
            char szBuffer[256];
            DWORD dwHash = 0;

            sprintf(szBuffer, "    HEADER_ENTRY(\"%s\",", (Items[j].ptok ? Items[j].ptok : "\0"));
            if ( Items[j].ptok )
            {
                dwHash = Hash(MakeMeLower(Items[j].ptok), 0, dwBestSeed);
            }

            fprintf(f, "%-45s  %s, 0x%X),\n", szBuffer, Items[j].pFlagsName, dwHash);                                                 
	    }

        fprintf(f,"    };\n\n\n");

    	fclose(f);
    }
    else
    {
        fprintf(stderr, "Error, could not find an ideal number\n");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\cookexp.h ===
//  Exports the cookies of the current user to a text file in a format
//parseable by Netscape Navigator.

//  -- declarations moved to wininet.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\dummy.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dummy.cxx

Abstract:

    Dummy file for build so we can generate the precompiled header for the
    internet project

    Contents:

Author:

     Richard L Firth (rfirth) 03-Feb-1995

Revision History:

    03-Feb-1995
        Created

--*/

#include "wininetp.h"

void __cdecl main(int, char**);

void __cdecl main(int argc, char** argv) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\handle.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header file for common\handle.cxx

Author:

    Richard L Firth (rfirth) 01-Nov-1994

Revision History:

    01-Nov-1994 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
HandleInitialize(
    VOID
    );

VOID
HandleTerminate(
    VOID
    );

DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    );

DWORD
FreeHandle(
    IN HINTERNET Handle
    );

DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    );

DWORD
DereferenceObject(
    IN LPVOID lpObject
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\ftpinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpinit.h

Abstract:

    Prototypes for ftpinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

VOID
FtpInitialize(
    VOID
    );

VOID
FtpTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\gfrinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gfrinit.h

Abstract:

    Prototypes for gfrinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

VOID
GopherInitialize(
    VOID
    );

VOID
GopherTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\debugmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.h

Abstract:

    Header for debugmem.cxx

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Revision History:

    02-Feb-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// USE_PRIVATE_HEAP_IN_RETAIL - by default we use the process heap in the retail
// build. Alternative is to use a private (wininet) heap (which we do in the
// debug version if required)
//

#if !defined(USE_PRIVATE_HEAP_IN_RETAIL)
#define USE_PRIVATE_HEAP_IN_RETAIL  0
#endif

//
// prototypes
//

VOID
InternetDebugMemInitialize(
    VOID
    );

VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    );

HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    );

SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    );

BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    );

//
// macros
//

#if defined(USE_DEBUG_MEMORY)

#define ALLOCATOR(Flags, Size) \
    InternetDebugAllocMem(Flags, Size, __FILE__, __LINE__)

#define DEALLOCATOR(hLocal) \
    InternetDebugFreeMem(hLocal, __FILE__, __LINE__)

#define REALLOCATOR(hLocal, Size, Flags) \
    InternetDebugReAllocMem(hLocal, Size, Flags, __FILE__, __LINE__)

#define MEMORYSIZER(hLocal) \
    InternetDebugSizeMem(hLocal, __FILE__, __LINE__)

#define INITIALIZE_DEBUG_MEMORY() \
    InternetDebugMemInitialize()

#define TERMINATE_DEBUG_MEMORY(bReport) \
    InternetDebugMemTerminate(bReport)

#define CHECK_MEMORY_FREED(bReport) \
    InternetDebugCheckMemFreed(bReport)

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    InternetDebugMemReport(bTermSym, bCloseFile)

#else   // retail version

#if USE_PRIVATE_HEAP_IN_RETAIL

#error no other memory allocation schemes defined

#else

#ifndef WININET_UNIX_PRVATE_ALLOCATOR
#define ALLOCATOR(Flags, Size) \
    LocalAlloc(Flags, Size)

#define DEALLOCATOR(hLocal) \
    LocalFree(hLocal)

#define REALLOCATOR(hLocal, Size, Flags) \
    LocalReAlloc(hLocal, Size, Flags)

#define MEMORYSIZER(hLocal) \
    LocalSize(hLocal)
#else

HLOCAL IEUnixLocalAlloc(UINT wFlags, UINT wBytes);
HLOCAL IEUnixLocalReAlloc(HLOCAL hMemory, UINT wBytes, UINT wFlags);
HLOCAL IEUnixLocalFree(HLOCAL hMem);
UINT IEUnixLocalSize(HLOCAL hMem);
LPVOID IEUnixLocalLock(HLOCAL hMem);

#define ALLOCATOR(Flags, Size)\
    IEUnixLocalAlloc(Flags, Size)
#define DEALLOCATOR(hLocal)\
    IEUnixLocalFree(hLocal)
#define REALLOCATOR(hLocal, Size, Flags)\
    IEUnixLocalReAlloc(hLocal, Size, Flags)
#define MEMORYSIZER(hLocal) \
    IEUnixLocalSize(hLocal)
#endif /* unix */
#endif // USE_PRIVATE_HEAP_IN_RETAIL

#define INITIALIZE_DEBUG_MEMORY() \
    /* NOTHING */

#define TERMINATE_DEBUG_MEMORY(bReport) \
    /* NOTHING */

#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */

#endif // defined(USE_DEBUG_MEMORY)

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((HLOCAL)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((HLOCAL)(hLocal))

#if defined(__cplusplus)
}
#endif

//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#include "iert.h"
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef wcsdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define wcsdup(s)         NewStringW(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)

 
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\defaults.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    defaults.h

Abstract:

    Contains all default manifests for WININET

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

//
// default timeout values and retry counts
//

#define DEFAULT_CONNECT_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minute
#define DEFAULT_CONNECT_RETRIES             5
#ifndef unix
#define DEFAULT_SEND_TIMEOUT                ((LONG)(5 * 60 * 1000)) // 5 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(60 * 60 * 1000)) // 60 minutes
#define DEFAULT_FTP_ACCEPT_TIMEOUT          ((LONG)(5 * 60 * 1000)) // 5 minutes
#else
#define DEFAULT_SEND_TIMEOUT                ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_FTP_ACCEPT_TIMEOUT          ((LONG)(1 * 60 * 1000)) // 1 minutes
#endif /* unix */
#define DEFAULT_KEEP_ALIVE_TIMEOUT          (1 * 60 * 1000)         // 1 minute
#define DEFAULT_FROM_CACHE_TIMEOUT          (5 * 1000)              // 5 seconds
#define DEFAULT_DNS_CACHE_ENTRIES           32
#define DEFAULT_DNS_CACHE_TIMEOUT           (30 * 60)               // 30 minutes
#define DEFAULT_MAX_HTTP_REDIRECTS          100

// JMH - BUGBUG  max connections raised for beta 2, should be reset in RC1 to 2
#define DEFAULT_MAX_CONNECTIONS_PER_SERVER  2                       // default HTTP 1.1
// #define DEFAULT_MAX_CONNECTIONS_PER_SERVER  4                       // default HTTP 1.1 raised for Beta 2 only

#define DEFAULT_MAX_CONS_PER_1_0_SERVER     4                       // default HTTP 1.0
#define DEFAULT_CONNECTION_LIMIT_TIMEOUT    (1 * 60 * 1000)         // 1 minute
#define DEFAULT_CONNECTION_INACTIVE_TIMEOUT (10 * 1000)             // 10 seconds
#define DEFAULT_SERVER_INFO_TIMEOUT         (2 * 60 * 1000)         // 2 minutes
#define DEFAULT_NETWORK_OFFLINE_TIMEOUT     (5 * 1000)              // 5 seconds
#define DEFAULT_DIAL_UP_OFFLINE_TIMEOUT     (20 * 1000)             // 20 seconds
#define DEFAULT_IDLE_TIMEOUT                1000                    // 1 second
#define DEFAULT_NETWORK_PING_RETRIES        1
#define DEFAULT_DIAL_UP_PING_RETRIES        4

//
// thread pool default constants
//

#define DEFAULT_MINIMUM_THREADS     0
#define DEFAULT_MAXIMUM_THREADS     4   // arbitrary
#define DEFAULT_INITIAL_THREADS     1
#define DEFAULT_THREAD_IDLE_TIMEOUT (2 * 60 * 1000) // 2 minutes
#define DEFAULT_WORK_QUEUE_LIMIT    8
#define DEFAULT_WORK_ITEM_PRIORITY  0

//
// async scheduler thread default constants
//

#define DEFAULT_WORKER_THREAD_TIMEOUT       (2 * 60 * 1000)        // 2 minutes
#define DEFAULT_MAXIMUM_QUEUE_DEPTH         2
#define DEFAULT_FIBER_STACK_SIZE            (16 K)
#define DEFAULT_CREATE_FIBER_ATTEMPTS       4

//
// default sizes
//

#define DEFAULT_RECEIVE_BUFFER_INCREMENT        (1 K)
#define DEFAULT_TRANSPORT_PACKET_LENGTH         (1 K)
#define DEFAULT_HTML_QUERY_BUFFER_LENGTH        (4 K)
#define DEFAULT_SOCKET_SEND_BUFFER_LENGTH       ((DWORD)-1)
#define DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH    ((DWORD)-1)
#define DEFAULT_SOCKET_QUERY_BUFFER_LENGTH      (8 K)

//
// default strings
//

#define DEFAULT_HTTP_REQUEST_VERB       "GET"
#define DEFAULT_EMAIL_NAME              "user@domain"
#define DEFAULT_URL_SCHEME_NAME         "http"

// default SSL protocols
#define DEFAULT_SECURE_PROTOCOLS        (SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\cookimp.h ===
#ifndef _COOKIMP_H_
#define _COOKIMP_H_

#define NS_NAVI3        	0x00030000
#define NS_NAVI4        	0x00040000
#define NS_NAVI5        	0x00050000  //  NS_NAVI5 is a guess

BOOL FindNetscapeCookieFile( IN DWORD dwNSVer, OUT LPTSTR szFilename, /* in-out */ LPDWORD lpnBufSize);

//  functions to identify active NS version

BOOL GetActiveNetscapeVersion( LPDWORD lpVersion);
BOOL GetExecuteableFromExtension( IN LPCTSTR szExtension, OUT LPTSTR szFilepath, 
                            LPDWORD pcFilenameSize, OUT LPTSTR* pFilenameSubstring);


//  writes version of Netscape to registry for future reference

BOOL SetNetscapeImportVersion( IN DWORD dwNSVersion);
BOOL GetNetscapeImportVersion( OUT DWORD* pNSVersion);

//  dumps the contents of a file out to memory

BOOL ReadFileToBuffer( IN LPCTSTR szFilename, LPBYTE* ppBuf, LPDWORD lpcbBufSize);


/*
Current behavior for cookie importing:
on first entry:
	Check if netscape is default browser, identify version and save in registry.

on every entry:
	check if version is saved in registry, destructively merge
*/


/*
Something of a justification for behavior:
  There are a couple ways to determine the version of cookie file to be imported from.  For all
intents ane purposes, what is being determined is whether the version to import from is less than
or greater than/equal to four.
  The version of the the executeable associated with htm files is what we use.  If the executeable
associated with htm files is not netscape, then presumeably the user isn't using netscape and we
don't want the cookies anyhow.
  An alternative was to use the last installed version of netscape installed which is indicated
in the CurrentVersion\\AppPaths reg key.  This key gets ripped away though, if the user uninstalls
one version and uses an older version.  Also, we can't expect the user to be using the last
installed version of netscape.

  Once IE is installed and ran, it may be associated with htm files while we still want to import
cookies from the once active version of netscape.  Because of this the version of netscape found
to be used during DllInstall(true,HKLM is) saved in the registry.  This works on 
uninstallation/reinstallation since we can always expect DllInstall(true,HKLM) to be ran again
before reentry into any DllInstall(true,HKCU) where the cookies are imported for each user.
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    External definitions for data in dll\globals.c

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

// Side-By-Side (loading different urlmon )
#ifdef _SBS_
#define URLMON_DLL "sbsurlmk.dll"
#else
#define URLMON_DLL "urlmon.dll"
#endif // _SBS_

//
// macros
//

#define IsGlobalStateOnline() \
    (((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE) \
        ? TRUE : FALSE)

#define IsGlobalStateOffline() \
    (((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE) \
        ? TRUE : FALSE)

#define IsGlobalStateOfflineUser() \
    (((GlobalDllState \
        & (INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER)) \
        == (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER)) \
        ? TRUE : FALSE)

#define UPDATE_GLOBAL_PROXY_VERSION() \
    InterlockedIncrement((LPLONG)&GlobalProxyVersionCount)


#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


#define INTERNET_MAX_WELL_KNOWN_PORT 1023
#define INTERNET_DEFAULT_FTP_PORT    21
#define INTERNET_DEFAULT_SMTP_PORT   25 
#define INTERNET_DEFAULT_POP3_PORT   110
#define INTERNET_DEFAULT_NNTP_PORT   119
#define INTERNET_DEFAULT_IMAP_PORT   143 


//
// external variables
//

extern HINSTANCE GlobalDllHandle;
#define GlobalResHandle     GlobalDllHandle  // change for plugable ui
extern DWORD GlobalPlatformType;
extern DWORD GlobalPlatformVersion5;
extern DWORD GlobalPlatformMillennium;
extern DWORD GlobalPlatformWhistler;

extern DWORD GlobalDllState;
extern BOOL GlobalDataInitialized;
extern BOOL GlobalTruncateFileName;

extern DWORD InternetMajorVersion;
extern DWORD InternetMinorVersion;
extern DWORD InternetBuildNumber;

extern DWORD GlobalConnectTimeout;
extern DWORD GlobalConnectRetries;
extern DWORD GlobalSendTimeout;
extern DWORD GlobalReceiveTimeout;
extern DWORD GlobalDataSendTimeout;
extern DWORD GlobalDataReceiveTimeout;
extern DWORD GlobalFromCacheTimeout;
extern DWORD GlobalFtpAcceptTimeout;
extern DWORD GlobalTransportPacketLength;
extern DWORD GlobalKeepAliveSocketTimeout;
extern DWORD GlobalSocketSendBufferLength;
extern DWORD GlobalSocketReceiveBufferLength;
extern DWORD GlobalMaxHttpRedirects;
extern DWORD GlobalMaxConnectionsPerServer;
extern DWORD GlobalMaxConnectionsPer1_0Server;
extern DWORD GlobalConnectionInactiveTimeout;
extern DWORD GlobalServerInfoTimeout;
extern const DWORD GlobalMaxSizeStatusLineResultText;
extern BOOL  GlobalHaveInternetOpened;

extern DWORD GlobalCacheMode;
#define CACHEMODE_NORMAL  0
#define CACHEMODE_REFRESH 1
#define CACHEMODE_BYPASS  2

extern BOOL InDllCleanup;
extern BOOL GlobalPleaseQuitWhatYouAreDoing;
extern BOOL GlobalDynaUnload;
extern BOOL GlobalUseSchannelDirectly;
extern BOOL GlobalDisableKeepAlive;
extern BOOL GlobalDisablePassport;
extern DWORD GlobalSecureProtocols;
extern BOOL GlobalEnableHttp1_1;
extern BOOL GlobalEnableProxyHttp1_1;
extern BOOL GlobalDisableReadRange;
extern BOOL GlobalIsProcessExplorer;
extern BOOL GlobalEnableFortezza;
extern BOOL GlobalEnableRevocation;
extern BOOL GlobalIsProcessNtService;
extern DWORD GlobalSslStateCount;
extern BOOL GlobalEnableGopher;

#if defined(SITARA)

extern BOOL GlobalEnableSitara;
extern BOOL GlobalHasSitaraModemConn;

#endif // SITARA

extern BOOL GlobalEnableUtf8Encoding;

extern BOOL GlobalBypassEditedEntry;
extern BOOL fDontUseDNSLoadBalancing;
extern BOOL GlobalDisableNT4RasCheck;

extern BOOL GlobalWarnOnPost;
extern BOOL GlobalWarnAlways;
extern BOOL GlobalWarnOnZoneCrossing;
extern BOOL GlobalWarnOnBadCertSending;
extern BOOL GlobalWarnOnBadCertRecving;
extern BOOL GlobalWarnOnPostRedirect;
extern BOOL GlobalAlwaysDrainOnRedirect;

extern LONG GlobalInternetOpenHandleCount;
extern DWORD GlobalProxyVersionCount;
extern BOOL GlobalAutoProxyNeedsInit;
extern BOOL GlobalAutoProxyInInit;
extern BOOL GlobalAutoProxyCacheEnable;
extern BOOL GlobalDisplayScriptDownloadFailureUI;
extern BOOL GlobalUseLanSettings;
extern BOOL GlobalSendExtraCRLF;
extern BOOL GlobalBypassFtpTimeCheck;

extern BOOL GlobalSendUTF8ServerToProxy;
extern BOOL GlobalMBCSAPIforCrack;
extern BOOL GlobalUseUTF8ServerForNameRes;

extern BOOL g_bHibernating;
extern BOOL g_bDisableHibernation;
//extern BOOL GlobalAutoProxyInDeInit;

//extern DWORD GlobalServerInfoAllocCount;
//extern DWORD GlobalServerInfoDeAllocCount;

extern SERIALIZED_LIST GlobalObjectList;
extern SERIALIZED_LIST GlobalServerInfoList;

extern LONGLONG dwdwHttpDefaultExpiryDelta;
extern LONGLONG dwdwFtpDefaultExpiryDelta;
extern LONGLONG dwdwGopherDefaultExpiryDelta;
extern LONGLONG dwdwSessionStartTime;
extern LONGLONG dwdwSessionStartTimeDefaultDelta;

extern DWORD GlobalUrlCacheSyncMode;
extern DWORD GlobalDiskUsageLowerBound;
extern DWORD GlobalScavengeFileLifeTime;

extern BOOL  GlobalLeashLegacyCookies;

extern LPSTR vszMimeExclusionList, vszHeaderExclusionList;

extern LPSTR *lpvrgszMimeExclusionTable, *lpvrgszHeaderExclusionTable;

extern DWORD *lpvrgdwMimeExclusionTableOfSizes;

extern DWORD vdwMimeExclusionTableCount, vdwHeaderExclusionTableCount;


extern SECURITY_CACHE_LIST GlobalCertCache;

extern BOOL GlobalDisableSslCaching;
extern BOOL GlobalDisableNTLMPreAuth;

extern CRITICAL_SECTION AuthenticationCritSec;
extern CRITICAL_SECTION GeneralInitCritSec;
extern CRITICAL_SECTION LockRequestFileCritSec;
extern CRITICAL_SECTION AutoProxyDllCritSec;
extern CRITICAL_SECTION ZoneMgrCritSec;
extern CRITICAL_SECTION MlangCritSec;

extern const char vszSyncMode[];

extern const char vszDisableSslCaching[];


// Default user agent string
// This will be used when no other information is available
extern const char gszDefaultUserAgent[];

// moved to proxysup.hxx
//extern PROXY_INFO GlobalProxyInfo;

extern BOOL vfPerUserCookies;

BOOL GetWininetUserName(VOID);
// BUGBUG: GetWininetUserName must be called before accessing vszCurrentUser.
// Instead, it should return the username ptr and the global not accessed.
extern char vszCurrentUser[];
extern DWORD vdwCurrentUserLen;

extern const char vszAllowCookies[];
extern const char vszPerUserCookies[];

extern INTERNET_VERSION_INFO InternetVersionInfo;
extern HTTP_VERSION_INFO HttpVersionInfo;
extern BOOL fCdromDialogActive;
extern DWORD g_dwCredPersistAvail;

extern CUserName GlobalUserName;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

extern char gszAt[];
extern char gszBang[];
extern char gszCRLF[3];

//
// novell client32 (hack) "support"
//

extern BOOL GlobalRunningNovellClient32;
extern BOOL GlobalNonBlockingClient32;


// shfolder.dll hmod handle
extern HMODULE g_HMODSHFolder;

// shell32.dll hmod handle
extern HMODULE g_HMODShell32;



extern DWORD GlobalIdentity;
extern GUID GlobalIdentityGuid;
#ifdef WININET6
extern HKEY GlobalCacheHKey;
#endif

extern BOOL GlobalSuppressCookiesPolicy;


//
// Localization Structures
//

//
// This definition must be big enough to hold the largest set of localized
// strings.
//

#define LOCAL_STRINGS_MAX_BUFFER 4096

//
// *WARNING* - The order of elements in the following structure must match the
// order of elements in the uStringId array in the FetchLocalStrings routine in
// dll/Globals.cxx.
//

typedef struct {
    LPWSTR
        szEnterAuthInfo,
        szCertInfo,
        szStrengthHigh,
        szStrengthMedium,
        szStrengthLow,
        szCertSubject,
        szCertIssuer,
        szCertEffectiveDate,
        szCertExpirationDate,
        szCertProtocol,
        szCertUsage,
        szHttpsEncryptAlg,
        szHttpsHashAlg,
        szHttpsExchAlg,
        szCertComment,
        szCommentExpires,
        szCommentNotValid,
        szCommentBadCN,
        szCommentBadCA,
        szCommentBadSignature,
        szCommentRevoked,
        szCiphMsg,
        szHashMsg,
        szExchMsg,
        szFingerprint,
        szDomain,
        szRealm,
        szSite,
        szFirewall;

    WCHAR
        rgchBuffer[LOCAL_STRINGS_MAX_BUFFER];
} LOCAL_STRINGS, *PLOCAL_STRINGS;

typedef struct {
    LPSTR
        szEnterAuthInfo,
        szCertInfo,
        szStrengthHigh,
        szStrengthMedium,
        szStrengthLow,
        szCertSubject,
        szCertIssuer,
        szCertEffectiveDate,
        szCertExpirationDate,
        szCertProtocol,
        szCertUsage,
        szHttpsEncryptAlg,
        szHttpsHashAlg,
        szHttpsExchAlg,
        szCertComment,
        szCommentExpires,
        szCommentNotValid,
        szCommentBadCN,
        szCommentBadCA,
        szCommentBadSignature,
        szCommentRevoked,
        szCiphMsg,
        szHashMsg,
        szExchMsg,
        szFingerprint,
        szDomain,
        szRealm,
        szSite,
        szFirewall;

    CHAR
        rgchBuffer[LOCAL_STRINGS_MAX_BUFFER];
} LOCAL_STRINGSA, *PLOCAL_STRINGSA;

//
// prototypes
//


void SetUserOrPass (LPSTR lpszIn, BOOL fUser);
void TimeStampCreds(void); 
PSYSTEMTIME GetCredTimeStamp(void);
BOOL GetUserAndPass (LPSTR *pszUser, LPSTR *pszPass);

VOID
GlobalDllInitialize(
    VOID
    );

VOID
GlobalDllTerminate(
    VOID
    );

DWORD
GlobalDataInitialize(
    VOID
    );

VOID
GlobalDataTerminate(
    VOID
    );

BOOL
IsHttp1_1(
    VOID
    );

BOOL
IsOffline(
    VOID
    );

DWORD
SetOfflineUserState(
    IN DWORD dwState,
    IN BOOL bForce
    );

VOID
GlobalDataReadWarningUIFlags(
    VOID
    );

PLOCAL_STRINGS
FetchLocalStrings(
    VOID
    );

PLOCAL_STRINGSA
FetchLocalStringsA(
    VOID
    );
    
VOID
ChangeGlobalSettings(
    VOID
    );

VOID
RefreshOfflineFromRegistry(
    VOID
    );

VOID
PerformStartupProcessing(
    VOID
    );

DWORD
GetSitaraProtocol(
    VOID
    );


typedef HRESULT
(STDAPICALLTYPE * PFNINETMULTIBYTETOUNICODE)
(
    LPDWORD  lpdword,
    DWORD    dwSrcEncoding,
    LPCSTR   lpSrcStr,
    LPINT    lpnSrcSize,
    LPWSTR   lpDstStr,
    LPINT    lpDstStrSize
);

// Loads Mlang and returns a pointer to the MultiByte to Unicode converter.
// Could return NULL if mlang.dll couldn't be loaded for some reason. 
PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\httpfilt.h ===
#ifndef _HTTPFILT_
#define _HTTPFILT_

//#include <wininet.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SZFN_FILTEROPEN "HttpFilterOpen"

BOOL
WINAPI
HttpFilterOpen
(
    OUT LPVOID *lppvFilterContext,
    IN  LPCSTR szFilterName,
    IN  LPVOID lpReserved
);

typedef BOOL (WINAPI *PFN_FILTEROPEN)
   (LPVOID*, LPCSTR, LPVOID);

#define SZFN_FILTERCLOSE "HttpFilterClose"

BOOL
WINAPI
HttpFilterClose
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN     BOOL       fInShutdown        // TRUE if in DLL_PROCESS_DETACH
);

typedef BOOL (WINAPI *PFN_FILTERCLOSE)
   (LPVOID, BOOL);

// Per Transaction
// There are called one for every HTTP transaction that WinInet performs.

#define SZFN_FILTERBEGINNINGTRANSACTION "HttpFilterBeginningTransaction"

BOOL
WINAPI
HttpFilterBeginningTransaction
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERBEGINNINGTRANSACTION)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

//This is called when a transaction begins.  It gives the caller an oppurtunity
// to examine the request header and modify it.

#define SZFN_FILTERONRESPONSE "HttpFilterOnResponse"

BOOL
WINAPI
HttpFilterOnResponse
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONRESPONSE)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

// This is called when the HTTP response returns and all of the HTTP headers are
// vailable to examine.

#define SZFN_FILTERONBLOCKINGOPS "HttpFilterOnBlockingOps"

BOOL
WINAPI
HttpFilterOnBlockingOps
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     HWND       hWnd,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONBLOCKINGOPS)
        (LPVOID, LPVOID*, HINTERNET, HWND, LPVOID);

// Called in response to any of the above APIs returning FALSE and setting the
// GetLastError() value to INTERNET_ERROR_NEED_BLOCKING_UI.  The caller can put
// up UI in this situation.using hWnd as the parent Window.

#define SZFN_FILTERONTRANSACTIONCOMPLETE "HttpFilterOnTransactionComplete"

BOOL
WINAPI
HttpFilterOnTransactionComplete
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONTRANSACTIONCOMPLETE)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

// Called when I the transaction is complete.  This gives the caller an
// opportunity to clean up any transaction specific data.  Filter returns TRUE
// to indicate "I took no action - you should proceed", FALSE to indicate that
// the value from GetLastError() will have ben set.


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _HTTPFILT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\httpinit.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    httpinit.h

Abstract:

    Prototypes for httpinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
HttpInitialize(
    VOID
    );

BOOL
HttpTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\inetsspi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsspi.h

Abstract:

    Contains all constant values and prototype decls used in inetsspi.cxx

Author:

    Sophia Chung (SophiaC)  02-Jan-1996

Revision History:

--*/

#ifndef _INETSSPI_H_
#define _INETSSPI_H_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active
#define ENC_CAPS_SCHANNEL_CREDS    0x00000004       // Uses SCHANNEL Creds Struct

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

#define IS_CRED_INVALID(s) (((s)->dwUpper == 0xFFFFFFFF) && ((s)->dwLower == 0xFFFFFFFF))

typedef struct _SEC_PROVIDER
{
    CHAR            *pszName;          // security pkg name
    CredHandle      hCreds;           // credential handle
    DWORD           dwFlags;          // encryption capabilities
    BOOL            fEnabled;         // enable flag indicator
    DWORD           dwProtocolFlags;  // protocol flags that this provider supports.
    PCCERT_CONTEXT  pCertCtxt;        // cert context to use when getting default credentials.
} SEC_PROVIDER, *PSEC_PROVIDER;

//
//  Array of encryption providers
//

extern SEC_PROVIDER SecProviders[];

//
//  Global EncProvider flag
//

extern DWORD dwEncFlags;


//
//  Prototypes
//

BOOL
SecurityPkgInitialize(
    BOOL fForce = FALSE
    );

DWORD
EncryptData(
    IN CtxtHandle* hContext,
    IN LPVOID   lpBuffer,
    IN DWORD    dwInBufferLen,
    OUT LPVOID *lplpBuffer,
    OUT DWORD  *lpdwOutBufferLen,
    OUT DWORD  *lpdwInBufferBytesEncrypted
    );

DWORD
DecryptData(
    IN CtxtHandle* hContext,
    IN OUT DBLBUFFER* pdblbufBuffer,
    OUT DWORD     *lpdwBytesNeeded,
    OUT LPBYTE        lpOutBuffer,
    IN OUT DWORD  *lpdwOutBufferLeft,
    IN OUT DWORD  *lpdwOutBufferReceived,
    IN OUT DWORD  *lpdwOutBufferBytesRead
    );

VOID
TerminateSecConnection(
    IN CtxtHandle* hContext
    );


DWORD 
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo);


#ifdef __cplusplus
}
#endif

#endif //_INETSSPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\parsers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.h

Abstract:

    Contains prototypes etc. for common\parsers.cxx

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD ConvertedNumber
    );

BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD ConvertedNumber
    );

BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT ConvertedNumber
    );

BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\oldnames.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldnames.h

Abstract:

    contains old names of cache structures, etc.

Author:

    Richard L Firth (rfirth) 09-May-1996

Revision History:

    09-May-1996 rfirth
        Created

--*/

#define CACHE_ENTRY_INFO            INTERNET_CACHE_ENTRY_INFO
#define LPCACHE_ENTRY_INFO          LPINTERNET_CACHE_ENTRY_INFO

#define CACHE_ENTRY_INFOA           INTERNET_CACHE_ENTRY_INFOA
#define LPCACHE_ENTRY_INFOA         LPINTERNET_CACHE_ENTRY_INFOA

#define CACHE_ENTRY_INFOW           INTERNET_CACHE_ENTRY_INFOW
#define LPCACHE_ENTRY_INFOW         LPINTERNET_CACHE_ENTRY_INFOW

#define CACHE_CONFIG_PATH_ENTRY     INTERNET_CACHE_CONFIG_PATH_ENTRY
#define LPCACHE_CONFIG_PATH_ENTRY   LPINTERNET_CACHE_CONFIG_PATH_ENTRY

#define CACHE_CONFIG_PATH_ENTRYA    INTERNET_CACHE_CONFIG_PATH_ENTRYA
#define LPCACHE_CONFIG_PATH_ENTRYA  LPINTERNET_CACHE_CONFIG_PATH_ENTRYA

#define CACHE_CONFIG_PATH_ENTRYW    INTERNET_CACHE_CONFIG_PATH_ENTRYW
#define LPCACHE_CONFIG_PATH_ENTRYW  LPINTERNET_CACHE_CONFIG_PATH_ENTRYW

#define CACHE_CONFIG_INFO           INTERNET_CACHE_CONFIG_INFO
#define LPCACHE_CONFIG_INFO         LPINTERNET_CACHE_CONFIG_INFO

#define CACHE_CONFIG_INFOA          INTERNET_CACHE_CONFIG_INFOA
#define LPCACHE_CONFIG_INFOA        LPINTERNET_CACHE_CONFIG_INFOA

#define CACHE_CONFIG_INFOW          INTERNET_CACHE_CONFIG_INFOW
#define LPCACHE_CONFIG_INFOW        LPINTERNET_CACHE_CONFIG_INFOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\inetchar.h ===
#ifndef INETCHAR_H

#define INETCHAR_H

/* Copyright (c) 1998  Microsoft Corporation

Module Name:

    inetchar.h

Abstract:

    macros for converting between Unicode and MultiByte characters.

    Contents:
        REASSIGN_ALLOC
        REASSIGN_SIZE
        ALLOC_MB
        UNICODE_TO_ANSI
        MAYBE_COPY_ANSI
        
Author:

    Ahsan S. Kabir  

Revision History:

    18Nov97 akabir
        Created

*/

//

// ---- Macros to simplify recovering values from memory packets -------------

#define REASSIGN_ALLOC(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwAlloc;
    
#define REASSIGN_SIZE(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwSize;


// -- (MAYBE_)ALLOC_MB ------------
// Macros to allocate enough memory for an ansi-equivalent string

#define ALLOC_MB(URLW,DWW,MPMP) { \
    MPMP.dwAlloc = ((DWW ? DWW : lstrlenW(URLW))+ 1)*sizeof(WCHAR); \
    MPMP.psStr = (LPSTR)ALLOC_BYTES(MPMP.dwAlloc*sizeof(CHAR)); }


// -- UNICODE_TO_ANSI -----
// Base case macro to convert from unicode to ansi
// We're subtracting 1 because we're converting the nullchar in dwAlloc.

#define UNICODE_TO_ANSI(pszW, mpA) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,NULL); \
        mpA.psStr[mpA.dwSize]= '\0';

#define UNICODE_TO_ANSI_CHECKED(pszW, mpA, pfNotSafe) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,pfNotSafe); \
        mpA.psStr[mpA.dwSize]= '\0';


// -- (MAYBE_)COPY_ANSI ----
//  Given ansi source and widechar destination pointers, convert from the former to latter

#define COPY_ANSI(mp,pszW,dwW) { dwW = MultiByteToWideChar(CP_ACP, 0, mp.psStr, mp.dwSize+1, pszW, dwW) - 1; }


#define MAYBE_COPY_ANSI(mp,pszW,dwW) { if (pszW && mp.psStr) \
            { dwW = MultiByteToWideChar(CP_ACP, 0, mp.psStr, mp.dwSize+1, pszW, dwW) - 1; } }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\inetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetp.h

Abstract:

    Contains the Internet Gateway Service private functions proto type
    definitions.

Author:

    Madan Appiah  (madana)  11-Nov-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _INETP_
#define _INETP_

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// flags for close functions
//

#define CF_EXPEDITED_CLOSE  0x00000001

//
// define used to expire entries
//

#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)

//
// define signature for LockRequestInfo structure
//
#define LOCK_REQUEST_SIGNATURE  0xAA55AA55

//
// types
//

typedef enum {
    TypeGenericHandle = 'HneG',
    TypeInternetHandle = 'tenI',
    TypeFtpConnectHandle = 'noCF',
    TypeFtpFindHandle = 'dnFF',
    TypeFtpFindHandleHtml = 'HnFF',
    TypeFtpFileHandle = 'liFF',
    TypeFtpFileHandleHtml = 'HlFF',
    TypeGopherConnectHandle = 'noCG',
    TypeGopherFindHandle = 'dnFG',
    TypeGopherFindHandleHtml = 'HnFG',
    TypeGopherFileHandle = 'liFG',
    TypeGopherFileHandleHtml = 'HlFG',
    TypeHttpConnectHandle = 'noCH',
    TypeHttpRequestHandle = 'qeRH',
    TypeFileRequestHandle = 'flRH',
    TypeWildHandle = 'dliW'
} HINTERNET_HANDLE_TYPE, *LPHINTERNET_HANDLE_TYPE;

typedef enum {
    HTML_STATE_INVALID,
    HTML_STATE_START,
    HTML_STATE_HEADER,
    HTML_STATE_WELCOME,
    HTML_STATE_DIR_HEADER,
    HTML_STATE_BODY,
    HTML_STATE_DIR_FOOTER,
    HTML_STATE_FOOTER,
#ifdef EXTENDED_ERROR_HTML
    HTML_STATE_END,
    HTML_STATE_ERROR_BODY
#else
    HTML_STATE_END
#endif
} HTML_STATE, *LPHTML_STATE;

typedef enum {
    READ_BUFFER_SIZE_INDEX,
    WRITE_BUFFER_SIZE_INDEX
} BUFFER_SIZE_INDEX;

typedef struct {

    DWORD   dwSignature;
    DWORD   dwSize;
    DWORD   dwCount;
    BOOL    fNoCacheLookup;
    BOOL    fNoDelete;
    HANDLE  hFile;
    LPSTR   UrlName;
    LPSTR   FileName;
    char    rgBuff[1];
}
LOCK_REQUEST_INFO, *LPLOCK_REQUEST_INFO;

//
// typedef virtual close function.
//

typedef BOOL ( *CLOSE_HANDLE_FUNC ) ( HINTERNET );
typedef BOOL ( *CONNECT_CLOSE_HANDLE_FUNC ) ( HINTERNET, DWORD );

//
// prototypes
//

BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    );

DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    );

//
// remote/RPC/object functions
//

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    );

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    );

DWORD
RSetHtmlHandleType(
    HINTERNET Handle
    );

DWORD
RSetHtmlState(
    HINTERNET Handle,
    HTML_STATE State
    );

DWORD
RGetHtmlState(
    HINTERNET Handle,
    LPHTML_STATE lpState
    );

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    );

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    );

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    );

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    );

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    );

DWORD
RGetParentHandle(
    HINTERNET hChild,
    LPHINTERNET lphParent
    );

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    );

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    );

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    );

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    );

DWORD
RGetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    LPDWORD lpdwBufferSize
    );

DWORD
RSetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    DWORD dwBufferSize
    );

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback
    );

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType
    );

DWORD
RAddAsyncRequest(
    IN HINTERNET Handle,
    BOOL fNoCallbackOK
    );

DWORD
RRemoveAsyncRequest(
    IN HINTERNET Handle
    );

DWORD
RMakeInternetConnectObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    LPSTR lpszServerName,
    INTERNET_PORT nServerPort,
    LPSTR lpszUserName,
    LPSTR lpszPassword,
    DWORD ServiceType,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

HINTERNET
FindExistingConnectObject(
    IN HINTERNET hInternet,
    IN LPSTR lpHostName,
    IN INTERNET_PORT nPort,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    IN DWORD dwServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

INT
FlushExistingConnectObjects(
    IN HINTERNET hInternet
    );

DWORD
RMakeGfrFindObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RMakeGfrFixedObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    DWORD dwFixedType
    );

DWORD
RMakeGfrFileObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RGetLocalHandle(
    HINTERNET Handle,
    HINTERNET *LocalHandle
    );

DWORD
RMakeHttpReqObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

//
// FTP remote functions
//

DWORD
RMakeFtpFindObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RMakeFtpFileObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

//
// non-exported Internet subordinate functions
//

BOOL
FtpFindNextFileA(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    );

BOOL
FtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOL
FtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

BOOL
FtpCloseFile(
    IN HINTERNET hFtpSession
    );

BOOL
GopherFindNextA(
    IN HINTERNET hGopherFind,
    OUT LPGOPHER_FIND_DATA lpFindFileData
    );

BOOL
GopherReadFile(
    IN HINTERNET hGopherFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    );

DWORD
HttpReadData(
    IN HINTERNET hHttpRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    );

PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

DWORD
wFtpConnect(
    IN LPCSTR pszFtpSite,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR pszUsername,
    IN LPCSTR pszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpMakeConnection(
    IN HINTERNET hFtpSession,
    IN LPCSTR pszUsername,
    IN LPCSTR pszPassword
    );

DWORD
wFtpDisconnect(
    IN HINTERNET hFtpSession,
    IN DWORD dwFlags
    );

DWORD
wFtpQueryDataAvailable(
    IN HINTERNET hFtpSession,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

DWORD
wGopherQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

DWORD
pHttpGetUrlInfo(
    IN HANDLE RequestHandle,
    IN LPBYTE Headers,
    IN DWORD HeadersLength,
    IN LPBYTE UrlBuf,
    IN OUT DWORD *UrlBufLen,
    IN BOOL ReloadFlagCheck
    );

DWORD
pFtpGetUrlString(
    IN LPSTR    lpszTargetName,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pFtpGetUrlInfo(
    IN HANDLE InternetConnectHandle,
    OUT LPSTR Url
    );

DWORD
pGopherGetUrlString(
    IN LPSTR   lpszTargetName,
    IN LPSTR   lpszCWD,
    IN LPSTR   lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD   dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pGfrGetUrlInfo(
    IN HANDLE InternetConnectHandle,
    OUT LPSTR Url
    );


DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR     lpszFileExtension,
    IN BOOL fNormal
    );

BOOL
GetCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

BOOL
IncrementCurrentSettingsVersion(
    LPDWORD lpdwVer
    );


extern DWORD  GlobalSettingsVersion;
extern BOOL   GlobalSettingsLoaded;
extern const char   vszSyncMode[];
extern const char   vszInvalidFilenameChars[];


#if defined(__cplusplus)
}
#endif

#endif // _INETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\iwinsock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    iwinsock.hxx

Abstract:

    Contains prototypes for indirected sockets functions

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Moved into SOCKET_FUNC_ARRAY in order to supports Socks.

--*/

#if !defined(_IWINSOCK_)
#define _WINSOCK_

#if defined(__cplusplus)
extern "C" {
#endif

//
// includes
//

#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

//
// prototypes
//

VOID
IwinsockInitialize(
    VOID
    );

VOID
IwinsockTerminate(
    VOID
    );

DWORD
LoadWinsock(
    VOID
    );

VOID
UnloadWinsock(
    VOID
    );

DWORD
SafeCloseSocket(
    IN SOCKET Socket
    );

//
// sockets functions
//

extern
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

extern
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    );

extern
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    );

extern
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    );

extern
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyaddr)(
    const char FAR * addr,
    int len,
    int type
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    const char FAR * lpHostName
    );

extern
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getpeername)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

extern
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    );

extern
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    );

extern
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    );

extern
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    );

extern
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    );

extern
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    );

extern
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    );

extern
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    );

extern
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    );

extern
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    );

extern
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    );

extern
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    );

extern
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    );

//
// WSA functions
//

extern
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    );

extern
int
(PASCAL FAR * _I_WSACleanup)(
    void
    );

extern
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    );

extern
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    );

extern
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    );

//
// address family independent APIs
//

extern
int
(PASCAL FAR * _I_getaddrinfo)(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

extern
void
(PASCAL FAR * _I_freeaddrinfo)(
    IN struct addrinfo *ai
    );

extern
int
(PASCAL FAR * _I_getnameinfo)(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    );

//
// winsock2 name resolution API.
//

extern
int
(PASCAL FAR * _I_WSALookupServiceBeginW)(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );


extern
int
(PASCAL FAR * _I_WSALookupServiceNextW)(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    );

extern
int
(PASCAL FAR * _I_WSALookupServiceEnd)(
    IN HANDLE  hLookup
    );


extern
int
(PASCAL FAR * _I_WSANSPIoctl)(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    );



//
// macros
//

#ifndef unix
#if defined(FD_ISSET)
#undef FD_ISSET
#endif

#define FD_ISSET(fd, set) _I___WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))
#endif /* unix */

#if INET_DEBUG

VOID
IWinsockCheckSockets(
    VOID
    );

#define CHECK_SOCKETS() IWinsockCheckSockets()

#else

#define CHECK_SOCKETS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif

#endif // _IWINSOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\inetdbg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;

//
// INTERNET_DEBUG_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _INTERNET_DEBUG_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _INTERNET_DEBUG_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} INTERNET_DEBUG_RECORD, *LPINTERNET_DEBUG_RECORD;

//
// INTERNET_FUNCTION_TRIGGER - if we are required to trigger on a function, this
// structure maintains the debugging flags
//

typedef struct _INTERNET_FUNCTION_TRIGGER {

    //
    // Next - we maintain a singly-linked list of INTERNET_FUNCTION_TRIGGERs
    //

    struct _INTERNET_FUNCTION_TRIGGER* Next;

    //
    // Hash - hash value for the function name, to cut-down strcmp's to 1
    //

    DWORD Hash;

    //
    // Function - name of the function - must match exactly
    //

    LPCSTR Function;

    //
    // Category - category debug flags to use when this function triggers
    //

    DWORD MajorCategory;

} INTERNET_FUNCTION_TRIGGER, *LPINTERNET_FUNCTION_TRIGGER;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

LPSTR
InternetMapStatus(
    IN DWORD Status
    );

LPSTR
InternetMapOption(
    IN DWORD Option
    );

LPSTR
InternetMapSSPIError(
    IN DWORD Status
    );

LPSTR
InternetMapHttpOption(
    IN DWORD Option
    );

LPSTR
InternetMapHttpState(
    IN DWORD State
    );

LPSTR
InternetMapHttpStateFlag(
    IN DWORD Flag
    );

LPSTR
InternetMapAuthScheme(
    IN DWORD Scheme
    );

LPSTR
InternetMapAuthState(
    IN DWORD State
    );

LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    );

LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    );

LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    );

LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    );

LPSTR
InternetMapService(
    IN DWORD Service
    );         

LPSTR
InternetMapWinsockCallbackType(
    IN DWORD CallbackType
    );

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN ctToken
    );

LPSTR
InternetMapChunkState(
    IN CHUNK_STATE csState
    );

DWORD
InternetHandleCount(
    VOID
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

#else

#define dprintf (VOID)

#endif // #ifdef ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(RETAIL_LOGGING)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\makefile.inc ===
!IFNDEF BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!ENDIF

!IFNDEF SDKINC
SDKINC=$(BASEDIR)\public\sdk\inc
!ENDIF

$(O)\unsup.h: unsup.w
    wcshdr < unsup.w > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\macros.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all internal macros used in INTERNET.DLL

    Contents:
        ROUND_UP_?K
        ROUND_UP_DWORD
        NEW
        DEL
        NEW_STRING
        DEL_STRING
        NEW_MEMORY
        ZAP
        PRIVATE
        PUBLIC
        GLOBAL
        LOCAL
        DEBUG_FUNCTION
        SKIPWS

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// macros
//

//
// ROUND_UP_ - return (n) rounded up to the next (k) bytes
//

#define ROUND_UP_NK(n, k)   (((n) + ((_ ## k ## K) - 1)) & -(_ ## k ## K))
#define ROUND_UP_2K(n)      ROUND_UP_NK(n, 2)
#define ROUND_UP_4K(n)      ROUND_UP_NK(n, 4)
#define ROUND_UP_8K(n)      ROUND_UP_NK(n, 8)
#define ROUND_UP_16K(n)     ROUND_UP_NK(n, 16)

//
// ROUND_UP_DWORD - return (n) rounded up to the next 4 bytes
//

#define ROUND_UP_DWORD(value) \
    (((value) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))

//
// NEW - allocates a new 'object' of type (obj). Memory is allocated with
// LocalAlloc and initialized to zeroes
//

#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))

//
// DEL - (should be DELETE, but that symbol is taken) - does opposite of NEW()
//

#define DEL(object) \
    FREE_MEMORY(object)

//
// NEW_STRING - performs NEW for a string
//

#define NEW_STRING(string) \
    NewString(string, 0)

//
// DEL_STRING - performs DEL for a string
//

#define DEL_STRING(string) \
    FREE_MEMORY(string)

//
// NEW_MEMORY - performs NEW for arbitrary sized memory
//

#define NEW_MEMORY(n, type) \
    (type FAR *)ALLOCATE_FIXED_MEMORY(n * sizeof(type))

//
// ZAP - zeroes an object (must be a variable, not a pointer)
//

#define ZAP(thing) \
    ZeroMemory((PVOID)&thing, sizeof(thing))

//
// STRTOUL - character-width independent (compile-time controlled) strtoul
//

#define STRTOUL             strtoul

//
// PRIVATE - make static items visible in debug version *FOR GLOBALS ONLY*. Use
// LOCAL in functions
//

#if INET_DEBUG

#define PRIVATE

#else

//#define PRIVATE static
#define PRIVATE

#endif // INET_DEBUG

//
// PUBLIC - just used as an aide-a-programmer pour le nonce
//

#define PUBLIC

//
// GLOBAL - same as PUBLIC, aide-a-programmer (for now) that tells you this
// thang has global scope
//

#define GLOBAL

//
// LOCAL - always expands to static, so you know that this thing only has
// local scope (within the current block)
//

#define LOCAL   static

//
// DEBUG_FUNCTION - this is a debug-only routine (if it get compiled in retail
// version a compile-time error is generated)
//

#if INET_DEBUG

#define DEBUG_FUNCTION

#else

#define DEBUG_FUNCTION

#endif // INET_DEBUG

//
// SKIPWS - skips blank widespace on the front of a string
//

#define SKIPWS(s) while (*(s)==' ' || *(s)=='\t') (s)++;


//
// MAKE_LOWER - takes an assumed upper character and bit manipulates into a lower.
//              (make sure the character is Upper case alpha char to begin, otherwise it corrupts)
//

#define MAKE_LOWER(c) (c | 0x20)

//
// MAKE_UPPER - takes an assumed lower character and bit manipulates into a upper.
//              (make sure the character is Lower case alpha char to begin, otherwise it corrupts)
//

#define MAKE_UPPER(c) (c & 0xdf)

//
// FASTCALL - used to bypass problems that may arise with UNIX compilers
//

#ifdef FASTCALL
#undef FASTCALL
#endif

#ifdef unix
#define FASTCALL
#else
#define FASTCALL __fastcall
#endif


//
// macro to cast FILETIME to LONGLONG
//
#define FT2LL(x) ( ((LONGLONG)((x).dwLowDateTime)) | (((LONGLONG)((x).dwHighDateTime))<<32) )


//
// Inline function to handle adding LONGLONG to FILETIME.
//
static __inline
void AddLongLongToFT( IN OUT LPFILETIME lpft,
                      IN     LONGLONG   llVal )
{
        LONGLONG llTmp;

        llTmp = FT2LL(*lpft);
        llTmp += llVal;

        lpft->dwLowDateTime =  ((LPDWORD)&llTmp)[0];
        lpft->dwHighDateTime = ((LPDWORD)&llTmp)[1];
}





//
// Macro to compute the number of bytes between two pointers
// The type of this expression is size_t, a signed integral
// type matching the size of a pointer
//
#define PtrDifference(x,y)  ((LPBYTE)(x) - (LPBYTE)(y))

//
// Macro to typecast 64-bit quantity to 32-bits
// Asserts in debug mode if the typecast loses information
//
#ifdef  DBG
#define GuardedCast(x)      ((x)<=0xFFFFFFFFL ? (DWORD)(x) : (InternetAssert(FALSE, __FILE__, __LINE__), 0))
#else
#define GuardedCast(x)      (DWORD)(x)
#endif

// Macro for the most common case
#define PtrDiff32(x,y)      (GuardedCast(PtrDifference(x,y)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\readhtml.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    readhtml.h

Abstract:

    Prototypes, etc. for readhtml.h

Author:

    Richard L Firth (rfirth) 26-Jun-1995

Revision History:

    26-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

BOOL
ReadHtmlUrlData(
    IN HINTERNET hInternet,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
QueryHtmlDataAvailable(
    IN HINTERNET hInternet,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\persist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.h

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created

--*/

#ifndef PERSIST_H
#define PERSIST_H

#include <pstore.h>

#define DISABLE_PASSWORD_CACHE_VALUE  "DisablePasswordCaching"
#define DISABLE_PASSWORD_CACHE        1

#define CRED_PERSIST_NOT_AVAIL        0
#define CRED_PERSIST_AVAIL            1
#define CRED_PERSIST_UNKNOWN          2

// PWL related defines.

// Password-cache-entry, this should be in PCACHE.
#define PCE_WWW_BASIC 0x13  
#define MAX_AUTH_FIELD_LENGTH           MAX_FIELD_LENGTH * 2

#define WNETDLL_MODULE                  "mpr.dll"
#define PSTORE_MODULE                   "pstorec.dll"
#define WNETGETCACHEDPASS               "WNetGetCachedPassword"
#define WNETCACHEPASS                   "WNetCachePassword"
#define WNETREMOVECACHEDPASS            "WNetRemoveCachedPassword"

// MPR.DLL exports used by top level API.
typedef DWORD (APIENTRY *PFWNETGETCACHEDPASSWORD)    (LPSTR, WORD, LPSTR, LPWORD, BYTE);
typedef DWORD (APIENTRY *PFWNETCACHEPASSWORD)        (LPSTR, WORD, LPSTR, WORD, BYTE, UINT);
typedef DWORD (APIENTRY *PFWNETREMOVECACHEDPASSWORD) (LPSTR, WORD, BYTE);


// ----------------Public function prototypes----------------------

// Determines availability of credential cache.
DWORD  InetInitCredentialPersist();

// Persist credentials (username/password).
DWORD InetSetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealmOrDomain, 
                                 LPSTR szUser, 
                                 LPSTR szPass);


// Get persisted credentials (username/password).
DWORD InetGetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealmOrDomain, 
                                 LPSTR szUser, 
                                 LPSTR szPass);


// Remove persisted credentials (username/password).
DWORD InetRemoveCachedCredentials (LPSTR szHost, LPSTR szRealmOrDomain);



#endif //PERSIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\proxreg.h ===
#include <inetreg.h>

#define BLOB_BUFF_GRANULARITY   1024

class CRegBlob
{
    private:
        HKEY    _hkey;
        BOOL    _fWrite;
        BOOL    _fCommit;
        DWORD   _dwOffset;
        DWORD   _dwBufferLimit;
        BYTE *  _pBuffer;
        LPCSTR  _pszValue;

    public:
        CRegBlob(BOOL fWrite);
        ~CRegBlob();
        DWORD Init(HKEY hBaseKey, LPCSTR pszSubKey, LPCSTR pszValue);
        DWORD Abandon();
        DWORD Commit();
        DWORD WriteString(LPCSTR pszString);
        DWORD ReadString(LPCSTR * ppszString);
        DWORD WriteBytes(LPCVOID pBytes, DWORD dwByteCount);
        DWORD ReadBytes(LPVOID pBytes, DWORD dwByteCount);

    private:
        DWORD Encrpyt();
        DWORD Decrypt();
};


class CRefdKey
{
public:
    ULONG CRefdKey::AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    ULONG CRefdKey::Release()
    {
        UINT cNewRef = InterlockedDecrement(&_cRef);
        if (cNewRef == 0)
        {
            delete this;
        }
        return cNewRef;
    }

    HKEY GetKey() { return _hkey; }
    CRefdKey(HKEY hkey) : _hkey(hkey), _cRef(1) {}
    ~CRefdKey()
    {
        if ((_hkey != NULL)                  &&
            (_hkey != HKEY_LOCAL_MACHINE)    &&
            (_hkey != HKEY_CURRENT_USER))
        {
            RegCloseKey(_hkey);
        }
    }

private:
    LONG _cRef;
    HKEY _hkey;
};


// NOTE! Changes to the following struct must be made in a backwards-compatible
//       manner. Do not remove fields; only add to the end of the struct.
//       And if you do change the struct, you must increment
//       INTERNET_PROXY_INFO_EX_VERSION and the code in ReadProxySettings to
//       support reading in older versions.

typedef struct {

    //
    // dwStructSize - Structure size to handle growing list of new entries or priv/pub structures
    //

    DWORD dwStructSize;

    //
    // dwFlags - Proxy type flags
    //

    DWORD dwFlags;

    //
    // dwCurrentSettingsVersion - a counter incremented every time we change our settings
    //

    DWORD dwCurrentSettingsVersion;

    //
    // lpszConnectionName - name of the Connectoid for this connection
    //
    
    LPCSTR lpszConnectionName;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;

    //
    // lpszAutoconfigUrl - autoconfig URL
    //

    LPCSTR lpszAutoconfigUrl;
    LPCSTR lpszAutoconfigSecondaryUrl;

    //
    // dwAutoDiscoveryFlags - auto detect flags.
    //

    DWORD dwAutoDiscoveryFlags;

    // 
    // lpszLastKnownGoodAutoConfigUrl - Last Successful Url 
    //

    LPCSTR lpszLastKnownGoodAutoConfigUrl;

    //
    // dwAutoconfigReloadDelayMins - number of mins until automatic 
    //    refresh of auto-config Url, 0 == disabled.
    //

    DWORD dwAutoconfigReloadDelayMins;

    //
    // ftLastKnownDetectTime - When the last known good Url was found with detection.
    //

    FILETIME ftLastKnownDetectTime;

    //
    // dwDetectedInterfaceIpCount - Number of IPs detected in last detection
    //

    DWORD dwDetectedInterfaceIpCount;

    //
    // dwDetectedInterfaceIp - Array of DWORD of IPs detected in last detection
    //

    DWORD *pdwDetectedInterfaceIp;

} INTERNET_PROXY_INFO_EX, * LPINTERNET_PROXY_INFO_EX;


// version stamp of INTERNET_PROXY_INFO_EX
#define INTERNET_PROXY_INFO_EX_VERSION      60      // 60 := IE 5.x & 6.0 format


// name of blob for saved legacy settings
#define LEGACY_SAVE_NAME            "SavedLegacySettings"

DWORD
WriteProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo,
    BOOL fForceUpdate
    );

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

BOOL
ReadLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy
    );

BOOL
WriteLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy,
    IN BOOL    fOverwrite
    );

DWORD
SetPerConnOptions(
    HINTERNET hInternet,    
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2
    );

CRefdKey*
FindBaseProxyKey(
    VOID
    );

BOOL
CloseBaseProxyKey(
    CRefdKey* prk
    );

BOOL
EnableAutodiscoverForDialup(
    VOID
    );

VOID
CheckForUpgrade(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\parseurl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.h

Abstract:

    Header for parseurl.c and protocol-specific parsers

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Revision History:

    26-Apr-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define SAFE                0x00    // character is safe in all schemes
#define SCHEME_FTP          0x01    // character is unsafe in FTP scheme
#define SCHEME_GOPHER       0x02    // character is unsafe in gopher scheme
#define SCHEME_HTTP         0x04    // character is unsafe in HTTP scheme
#define UNSAFE              0x80    // character is unsafe in all schemes

#define SCHEME_ANY          (SCHEME_FTP | SCHEME_GOPHER | SCHEME_HTTP)

//
// types
//

typedef
DWORD
(*LPFN_URL_PARSER)(
    LPHINTERNET,
    LPSTR,
    DWORD,
    LPSTR,
    DWORD,
    DWORD,
    DWORD_PTR
    );

//
// prototypes
//

BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    );

BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    );

DWORD
ParseUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPVOID hMapped,
    IN LPCSTR Url,
    IN LPCSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* UrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    );

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    );

//
// flags for EncodeUrlPath
//

#define NO_ENCODE_PATH_SEP  0x00000001

DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR UnescapedString,
    IN OUT LPDWORD UnescapedLength
    );

DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    );

DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT INTERNET_PORT* lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    );

LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    );

//
// protocol-specific URL parsers
//

DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
ParseGopherUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
GopherLocatorToUrl(
    IN LPSTR Locator,
    OUT LPSTR Buffer,
    IN DWORD BufferLength,
    OUT LPDWORD UrlLength
    );

DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\resinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resinfo.h

Abstract:

    Resource owner info header. Used for tracking resources in debug build

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if INET_DEBUG

//
// types
//

//typedef struct {
//    DWORD Tid;
//    DWORD CallersAddress;
//    DWORD CallersCaller;
//    DWORD SourceFileLine;
//    LPSTR SourceFileName;
//} RESOURCE_INFO, *LPRESOURCE_INFO;
typedef struct {
    DWORD Tid;
    LPSTR SourceFileName;
    DWORD SourceFileLine;
} RESOURCE_INFO, *LPRESOURCE_INFO;

//#define GET_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define GET_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

//#define INITIALIZE_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define INITIALIZE_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

#else

#define GET_RESOURCE_INFO(pResource)
#define INITIALIZE_RESOURCE_INFO(pResource)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for dll\registry.c

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"


//
// prototypes
//

VOID
EnsureInternetSettingsKeyCached(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    );

DWORD
GetMyDomainName(
    OUT LPSTR DomainName,
    IN OUT LPDWORD Length
    );

BOOL
GetFileExtensionFromMimeType(
    IN LPCSTR  lpszMimeType,
    IN DWORD   dwMimeLen,
    IN LPSTR   lpszFileExtension,
    IN OUT LPDWORD lpdwLen
    );

//DWORD
//InternetGetComputerName(
//    OUT LPSTR Buffer,
//    IN OUT LPDWORD Length
//    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

#ifdef WININET6
DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
#endif

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );

//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

DWORD
CreateMimeExclusionTableForCache(VOID);

DWORD
CreateHeaderExclusionTableForCache(VOID);

VOID
DestroyMimeExclusionTableForCache(VOID);

VOID
DestroyHeaderExclusionTableForCache(VOID);

#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\rashelp.h ===
#ifndef _RASHELP_H_
#define _RASHELP_H_

#include <regstr.h>
#include <inetreg.h>
#include <windowsx.h>
#include <rasdlg.h>

typedef enum
{
    ENUM_NONE,
    ENUM_MULTIBYTE,             // Win9x
    ENUM_UNICODE,               // NT4
    ENUM_WIN2K                  // Win2K
} ENUM_TYPE;

/////////////////////////////////////////////////////////////////////////////////////
class GetOSVersion
{
protected:
    static ENUM_TYPE    _EnumType;

public:
    GetOSVersion();
    ~GetOSVersion();
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEnumHelp : public GetOSVersion
{
private:

    //
    // Win2k version of RASENTRYNAMEW struct
    //

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASENTRYNAMEW struct tagW2KRASENTRYNAMEW
    W2KRASENTRYNAMEW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        DWORD dwFlags;
        WCHAR szPhonebookPath[MAX_PATH + 1];
    };
    #define LPW2KRASENTRYNAMEW W2KRASENTRYNAMEW*
    #include <poppack.h>

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASENTRYNAMEA * _preList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    CHAR            _szCurrentEntryA[RAS_MaxEntryName + 1];
    WCHAR           _szCurrentEntryW[RAS_MaxEntryName + 1];


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD   GetError();
    DWORD   GetEntryCount();
    LPSTR   GetEntryA(DWORD dwEntry);
    LPWSTR  GetEntryW(DWORD dwEntry);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEnumConnHelp : public GetOSVersion
{
private:

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASCONNW struct tagW2KRASCONNW
    W2KRASCONNW
    {
        DWORD    dwSize;
        HRASCONN hrasconn;
        WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
        //#if (WINVER >= 0x400)
        WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
        //#endif
        //#if (WINVER >= 0x401)
        WCHAR    szPhonebook [ MAX_PATH ];
        DWORD    dwSubEntry;
        //#endif
        //#if (WINVER >= 0x500)
        GUID     guidEntry;
        //#endif
    };
    #define LPW2KRASCONNW W2KRASCONNW*
    #include <poppack.h>

    DWORD           _dwLastError;       // Any error we got during enumeration
    DWORD           _dwConnections;     // Number of connections
    DWORD           _dwStructSize;
    RASCONNA        *_pRasCon;

    // Last entry returned as multibyte or unicode when conversion required
    WCHAR    _szEntryNameW[ RAS_MaxEntryName + 1 ];
//    WCHAR    _szDeviceTypeW[ RAS_MaxDeviceType + 1 ];
//    WCHAR    _szDeviceNameW[ RAS_MaxDeviceName + 1 ];
//    WCHAR    _szPhonebookW[ MAX_PATH ];

    CHAR    _szEntryNameA[ RAS_MaxEntryName + 1 ];
//    CHAR    _szDeviceTypeA[ RAS_MaxDeviceType + 1 ];
//    CHAR    _szDeviceNameA[ RAS_MaxDeviceName + 1 ];
//    CHAR    _szPhonebookA[ MAX_PATH ];

public:
    RasEnumConnHelp();
    ~RasEnumConnHelp();

    DWORD   Enum();
    DWORD   GetError();
    DWORD   GetConnectionsCount();
    LPWSTR  GetEntryW(DWORD dwConnectionNum);
    LPSTR   GetEntryA(DWORD dwConnectionNum);
    LPWSTR  GetLastEntryW(DWORD dwConnectionNum);
    LPSTR   GetLastEntryA(DWORD dwConnectionNum);
    HRASCONN GetHandle(DWORD dwConnectionNum);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEntryPropHelp : public GetOSVersion
{
private:

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASENTRYW struct tagW2KRASENTRYW
    W2KRASENTRYW
    {
        DWORD       dwSize;
        DWORD       dwfOptions;
        //
        // Location/phone number
        //
        DWORD       dwCountryID;
        DWORD       dwCountryCode;
        WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
        WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;
        //
        // PPP/Ip
        //
        RASIPADDR   ipaddr;
        RASIPADDR   ipaddrDns;
        RASIPADDR   ipaddrDnsAlt;
        RASIPADDR   ipaddrWins;
        RASIPADDR   ipaddrWinsAlt;
        //
        // Framing
        //
        DWORD       dwFrameSize;
        DWORD       dwfNetProtocols;
        DWORD       dwFramingProtocol;
        //
        // Scripting
        //
        WCHAR       szScript[ MAX_PATH ];
        //
        // AutoDial
        //
        WCHAR       szAutodialDll[ MAX_PATH ];
        WCHAR       szAutodialFunc[ MAX_PATH ];
        //
        // Device
        //
        WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // X.25
        //
        WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
        WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
        WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
        WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
        DWORD       dwChannels;
        //
        // Reserved
        //
        DWORD       dwReserved1;
        DWORD       dwReserved2;
        //#if (WINVER >= 0x401)
        //
        // Multilink
        //
        DWORD       dwSubEntries;
        DWORD       dwDialMode;
        DWORD       dwDialExtraPercent;
        DWORD       dwDialExtraSampleSeconds;
        DWORD       dwHangUpExtraPercent;
        DWORD       dwHangUpExtraSampleSeconds;
        //
        // Idle timeout
        //
        DWORD       dwIdleDisconnectSeconds;
        //#endif

        //#if (WINVER >= 0x500)
        //
        // Entry Type
        //
        DWORD       dwType;

        //
        // EncryptionType
        //
        DWORD       dwEncryptionType;

        //
        // CustomAuthKey to be used for EAP
        //
        DWORD       dwCustomAuthKey;

        //
        // Guid of the connection
        //
        GUID        guidId;

        //
        // Custom Dial Dll
        //
        WCHAR       szCustomDialDll[MAX_PATH];

        //
        // Vpn Strategy
        //
        DWORD       dwVpnStrategy;
        //#endif
    };
    #define LPW2KRASENTRYW W2KRASENTRYW*
    #include <poppack.h>

    DWORD           _dwStructSize;
    DWORD           _dwLastError;       // Any error we got during enumeration
    RASENTRYA       *_pRasEntry;

    // Last entry returned as multibyte or unicode when conversion required
    WCHAR    _szEntryNameW[ RAS_MaxEntryName + 1 ];
    WCHAR    _szDeviceTypeW[ RAS_MaxDeviceType + 1 ];
    WCHAR    _szAutodialDllW[ MAX_PATH ];
    WCHAR    _szAutodialFuncW[ MAX_PATH ];
    WCHAR    _szCustomDialDllW[ MAX_PATH ];
    WCHAR    _szPhoneNumberW[ RAS_MaxPhoneNumber + 1 ];
    WCHAR    _szAreaCodeW[ RAS_MaxAreaCode + 1 ];
    CHAR     _szEntryNameA[ RAS_MaxEntryName + 1 ];
    CHAR     _szDeviceTypeA[ RAS_MaxDeviceType + 1 ];
    CHAR     _szAutodialDllA[ MAX_PATH ];
    CHAR     _szAutodialFuncA[ MAX_PATH ];

public:
    RasEntryPropHelp();
    ~RasEntryPropHelp();

    DWORD   GetError();
    DWORD   GetA(LPSTR lpszEntryName);
    DWORD   GetW(LPWSTR lpszEntryName);
    LPWSTR  GetDeviceTypeW(VOID);
    LPSTR   GetDeviceTypeA(VOID);
    LPWSTR  GetAutodiallDllW();
    LPSTR   GetAutodiallDllA();
    LPWSTR  GetAutodialFuncW();
    LPSTR   GetAutodialFuncA();
    LPWSTR  GetCustomDialDllW();
    LPWSTR  GetPhoneNumberW();
    DWORD   GetCountryCode();
    DWORD   GetOptions();
    LPWSTR  GetAreaCodeW();

};

/////////////////////////////////////////////////////////////////////////////////////
class RasEntryDialParamsHelp : public GetOSVersion
{
private:
    DWORD           _dwLastError;       // Any error we got during enumeration
    RASDIALPARAMSA  *_pRasDialParamsA;

public:
    RasEntryDialParamsHelp();
    ~RasEntryDialParamsHelp();
    DWORD GetError();
    DWORD SetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword);
    DWORD GetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL pfRemovePassword);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasGetConnectStatusHelp : public GetOSVersion
{
private:
    DWORD           _dwLastError;       // Any error we got during enumeration
    DWORD           _dwStructSize;
    RASCONNSTATUSA  *_pRasConnStatus;

public:
    RasGetConnectStatusHelp(HRASCONN hrasconn);
    ~RasGetConnectStatusHelp();
    DWORD GetError();
    RASCONNSTATE ConnState();
};

/////////////////////////////////////////////////////////////////////////////////////
class RasDialHelp : public GetOSVersion
{
private:
    // We currently build with WINVER == 0x400, on NT we RasDialW needs the 401 struct to support
    //   connectoids greater than 20 chars as found in IE501 bug 82419
    // match RAS packing so structs match
    #include <pshpack4.h>
    #define NT4RASDIALPARAMSW struct tagNT4RASDIALPARAMSW
    NT4RASDIALPARAMSW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
        WCHAR szUserName[ UNLEN + 1 ];
        WCHAR szPassword[ PWLEN + 1 ];
        WCHAR szDomain[ DNLEN + 1 ];
    //#if (WINVER >= 0x401)
        DWORD dwSubEntry;
        ULONG_PTR dwCallbackId;
    //#endif
    };
    #define LPNT4RASDIALPARAMSW NT4RASDIALPARAMSW*
    #include <poppack.h>

    DWORD           _dwLastError;       // Any error we got during enumeration
    RASDIALPARAMSA *_pRasDialParams;
    LPSTR           _lpszPhonebookA;

public:
    RasDialHelp(LPRASDIALEXTENSIONS lpRDE, LPWSTR lpszPB, LPRASDIALPARAMSW lpRDPW,  DWORD dwType, LPVOID lpvNot, LPHRASCONN lphRasCon);
    ~RasDialHelp();
    DWORD GetError();
};


/////////////////////////////////////////////////////////////////////////////////////
#endif // _RASHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\rescache.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains prototypes, structures, manifests for rescache.c

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// manifests
//

#define RESOLVER_CACHE_DISABLED         -1
#define MINIMUM_RESOLVER_CACHE_ENTRIES  1
#define MAXIMUM_RESOLVER_CACHE_ENTRIES  128 // arbitrary, just in case user decides to wack it up
#define LIVE_FOREVER                    ((DWORD)-1)
#define LIVE_DEFAULT                    ((DWORD)0)

//
// types
//

//
// RESOLVER_CACHE_ENTRY_STATE - the cache entry can be in-use, unused, or
// awaiting deletion
//

typedef enum {
    ENTRY_UNUSED = 1,
    ENTRY_IN_USE,
    ENTRY_DELETE
} RESOLVER_CACHE_ENTRY_STATE;

//
// RESOLVER_CACHE_ENTRY - we maintain a doubly-linked list of these. The list is
// maintained in MRU order - we throw out the one at the far end of the list.
// Because the name resolution APIs do not return the time-to-live in the DNS
// answer, we cannot honor it (an argument for why we should let the resolver
// do the caching - if only all platforms did this). When we get a response we
// set the ExpirationTime field to a default value. On future cache hits, if
// the current time is >= the ExpirationTime value then we must throw out this
// entry and refresh the cache
//

typedef struct {

    //
    // ListEntry - cache entries comprise a double-linked list
    //

    LIST_ENTRY ListEntry;

    //
    // ExpirationTime - formed by adding the time-to-live value from the DNS
    // response to the result obtained from time(). If ever time() returns a
    // value >= ExpirationTime, this entry is stale and must be refreshed
    //

    DWORD ExpirationTime;

    //
    // HostName - original name that resolved to this entry
    //

    LPSTR HostName;

    //
    // State - unused, in-use, or delete
    //

    RESOLVER_CACHE_ENTRY_STATE State;

    //
    // ReferenceCount - only change State when zero
    //

    LONG ReferenceCount;

    //
    // AddrInfo - pointer to a list of addrinfo structures
    //

    LPADDRINFO AddrInfo;

} RESOLVER_CACHE_ENTRY, *LPRESOLVER_CACHE_ENTRY;

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

VOID
InitializeResolverCache(
    VOID
    );

VOID
TerminateResolverCache(
    VOID
    );

LPRESOLVER_CACHE_ENTRY
QueryResolverCache(
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL,
    OUT LPADDRINFO * AddrInfo,
    OUT LPDWORD TimeToLive
    );

VOID
AddResolverCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO lpAddrInfo,
    IN DWORD TimeToLive
    );

VOID
FlushResolverCache(
    VOID
    );

VOID
ThrowOutResolverCacheEntry(
    IN LPADDRINFO lpAddrinfo
    );

VOID
ReleaseResolverCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY cacheEntry
    );

#if defined(__cplusplus)
}
#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains name resolution cache structure definition

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
InitNameresCache(
    VOID
);

DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpAddressInfoList
);

DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
);

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
);

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfoList
);

DWORD
DeinitNameresCache(
    VOID
);

#if defined(__cplusplus)
}
#endif

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\resolver.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resolver.h

Abstract:

    Definitions etc. for Berkeley resolver

Author:

    Richard L Firth (rfirth) 15-Jun-1996

Revision History:

    15-Jun-1996 rfirth
        Created

--*/

//
// includes
//

#include <nameser.h>
#include <resolv.h>

//
// manifests
//

#if PACKETSZ > 1024
#define MAXPACKET       PACKETSZ
#else
#define MAXPACKET       1024
#endif

#define DBG_RESOLVER    DBG_SOCKETS
#define DBG_VXD_IO      DBG_SOCKETS

#define DLL_PRINT(x)    DEBUG_PRINT(SOCKETS, INFO, x)
#define WS_PRINT(x)     DEBUG_PRINT(SOCKETS, INFO, x)
#define WS_ASSERT       INET_ASSERT
#define DLL_ASSERT      INET_ASSERT

//
// macros
//
#ifndef unix
#define bcopy(s, d, c)  memcpy((u_char *)(d), (u_char *)(s), (c))
#define bzero(d, l)     memset((d), '\0', (l))
#endif /* unix */
#define bcmp(s1, s2, l) memcmp((s1), (s2), (l))

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// types
//

typedef union {
    HEADER hdr;
    unsigned char buf[MAXPACKET];
} querybuf;

typedef union {
    long al;
    char ac;
} align;

//extern char VTCPPARM[];
//extern char NTCPPARM[];
//extern char TCPPARM[];
//extern char TTCPPARM[];

#ifndef unix
typedef long                   daddr_t;
typedef char FAR *             caddr_t;
struct iovec {
    caddr_t iov_base;
    int     iov_len;
};

struct uio {
    struct  iovec *uio_iov;
    int     uio_iovcnt;
    int     uio_offset;
    int     uio_segflg;
    int     uio_resid;
};

enum    uio_rw { UIO_READ, UIO_WRITE };
#endif /* unix */
/*
 * Segment flag values (should be enum).
 */
#define UIO_USERSPACE   0               /* from user data space */
#define UIO_SYSSPACE    1               /* from system space */
#define UIO_USERISPACE  2               /* from user I space */

#define MAXALIASES      35
#define MAXADDRS        35

#define HOSTDB_SIZE     (_MAX_PATH + 7)   // 7 == strlen("\\hosts") + 1
#define PROTODB_SIZE    (_MAX_PATH + 10)
#define SERVDB_SIZE     (_MAX_PATH + 10)

typedef struct _WINSOCK_TLS_DATA {
    char * GETHOST_h_addr_ptrs[MAXADDRS + 1];
    struct hostent GETHOST_host;
    char * GETHOST_host_aliases[MAXALIASES];
    char GETHOST_hostbuf[BUFSIZ + 1];
    //struct in_addr GETHOST_host_addr;
    //char GETHOST_HOSTDB[HOSTDB_SIZE];
    //FILE *GETHOST_hostf;
    //char GETHOST_hostaddr[MAXADDRS];
    //char *GETHOST_host_addrs[2];
    //int GETHOST_stayopen;
    //char GETPROTO_PROTODB[PROTODB_SIZE];
    //FILE *GETPROTO_protof;
    //char GETPROTO_line[BUFSIZ+1];
    //struct protoent GETPROTO_proto;
    //char *GETPROTO_proto_aliases[MAXALIASES];
    //int GETPROTO_stayopen;
    //char GETSERV_SERVDB[SERVDB_SIZE];
    //FILE *GETSERV_servf;
    //char GETSERV_line[BUFSIZ+1];
    //struct servent GETSERV_serv;
    //char *GETSERV_serv_aliases[MAXALIASES];
    //int GETSERV_stayopen;
    struct state R_INIT__res;
    //char INTOA_Buffer[18];
    //CSOCKET * DnrSocketHandle;
    //BOOLEAN IsBlocking;
    BOOLEAN IoCancelled;
    //BOOLEAN ProcessingGetXByY;
    BOOLEAN GetXByYCancelled;
    //BOOLEAN EnableWinsNameResolution;
    //BOOLEAN DisableWinsNameResolution;
    //SOCKET SocketHandle;
    //PBLOCKING_HOOK BlockingHook;
    //HANDLE EventHandle;
    //ULONG CreateOptions;
    INT DnrErrorCode;
//#if DBG
//    ULONG IndentLevel;
//#endif
} WINSOCK_TLS_DATA, * LPWINSOCK_TLS_DATA;

//extern DWORD SockTlsSlot;

//#define ACCESS_THREAD_DATA(a, file) \
//            (((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))-> \
//                ## file ## _ ## a )

#define ACCESS_THREAD_DATA(a, file) (lpResolverInfo->file ## _ ## a)

#define _h_addr_ptrs    ACCESS_THREAD_DATA(h_addr_ptrs, GETHOST)
#define _host           ACCESS_THREAD_DATA(host, GETHOST)
#define _host_aliases   ACCESS_THREAD_DATA(host_aliases, GETHOST)
#define _hostbuf        ACCESS_THREAD_DATA(hostbuf, GETHOST)
#define _host_addr      ACCESS_THREAD_DATA(host_addr, GETHOST)
//#define HOSTDB          ACCESS_THREAD_DATA(HOSTDB, GETHOST)
//#define hostf           ACCESS_THREAD_DATA(hostf, GETHOST)
//#define hostaddr        ACCESS_THREAD_DATA(hostaddr, GETHOST)
//#define host_addrs      ACCESS_THREAD_DATA(host_addrs, GETHOST)
//#define stayopen        ACCESS_THREAD_DATA(stayopen, GETHOST)
#define _res            ACCESS_THREAD_DATA( _res, R_INIT )

//#define SockThreadProcessingGetXByY lpResolverInfo->ProcessingGetXByY
#define SockThreadGetXByYCancelled  lpResolverInfo->GetXByYCancelled
#define SockDnrSocket               lpResolverInfo->DnrSocketHandle
#define SockThreadDnrErrorCode      lpResolverInfo->DnrErrorCode

//#define SockThreadIsBlocking \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->IsBlocking )
//
//#define SockThreadIoCancelled \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->IoCancelled )
//
//#define SockThreadProcessingGetXByY \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->ProcessingGetXByY )
//
//#define SockThreadGetXByYCancelled \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->GetXByYCancelled )
//
//#define SockThreadSocketHandle \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->SocketHandle )
//
//#define SockThreadBlockingHook \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->BlockingHook )
//
//#define SockThreadEvent \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->EventHandle )
//
//#define SockDnrSocket \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DnrSocketHandle )
//
//#define SockEnableWinsNameResolution \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->EnableWinsNameResolution )
//
//#define SockDisableWinsNameResolution \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DisableWinsNameResolution )
//
//#define SockCreateOptions \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->CreateOptions )
//
//#define SockThreadDnrErrorCode \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DnrErrorCode )

#define LPSOCK_THREAD   LPWINSOCK_TLS_DATA
#define GET_THREAD_DATA(p) p = InternetGetResolverInfo()
//#define I_SetLastError  SetLastError
#define DllAllocMem(n)  ALLOCATE_MEMORY(LMEM_FIXED, n)
#define DllFreeMem      FREE_MEMORY

//
// well-known DHCP VxD ID (from netvxd.h)
//

#define VDHCP_Device_ID     0x049A

//
// prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

static
int
dn_find(
    unsigned char  *exp_dn,
    unsigned char  *msg,
    unsigned char **dnptrs,
    unsigned char **lastdnptr
    );

int
dn_skipname(
    unsigned char *comp_dn,
    unsigned char *eom
    );

void
fp_query(
    char *msg,
    FILE *file
    );

//int
//gethostname(
//    OUT char *name,
//    IN int namelen
//    );

void
p_query(
    char *msg
    );

extern
void
putshort(
    u_short s,
    u_char *msgp
    );

void
putlong(
    u_long l,
    u_char *msgp
    );

void
_res_close(
    void
    );

//DWORD
//sendv(
//    CSOCKET *      s,           /* socket descriptor */
//    struct iovec  *iov,         /* array of vectors */
//    int            iovcnt       /* size of array */
//    );

//int
//strcasecmp(
//    char *s1,
//    char *s2
//    );
//
//int
//strncasecmp(
//    char *s1,
//    char *s2,
//    int   n
//    );
//
//struct hostent *
//myhostent (
//    void
//    );
//
//struct hostent *
//localhostent (
//    void
//    );
//
//struct hostent *
//dnshostent (
//    void
//    );
//
//BOOL
//querydnsaddrs (
//    IN LPDWORD *Array,
//    IN PVOID Buffer
//    );
//
//DWORD
//BytesInHostent (
//    PHOSTENT Hostent
//    );
//
//DWORD
//CopyHostentToBuffer (
//    char FAR *Buffer,
//    int BufferLength,
//    PHOSTENT Hostent
//    );
//
//struct hostent *
//_gethtbyname (
//    IN char *name
//    );

BOOL
OkToUseInternetAsyncGetHostByName(
    VOID
    );

LPHOSTENT
InternetAsyncGetHostByName(
    IN LPSTR lpszHostName,
    OUT LPDWORD lpdwTtl
    );

LPWINSOCK_TLS_DATA
InternetGetResolverInfo(
    VOID
    );

LPHOSTENT
getanswer(
    OUT querybuf *answer,
    OUT int      *ttl,
    IN int       anslen,
    IN int       iquery
    );

//ULONG
//SockNbtResolveName (
//    IN PCHAR Name
//    );

//PHOSTENT
//QueryHostentCache (
//    IN LPSTR Name OPTIONAL,
//    IN DWORD IpAddress OPTIONAL
//    );

//FILE *
//SockOpenNetworkDataBase(
//    IN  char *Database,
//    OUT char *Pathname,
//    IN  int   PathnameLen,
//    IN  char *OpenFlags
//    );
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\util.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header for util.cxx

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if !defined(__UTIL_H__)
#define __UTIL_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))
#define PLATFORM_TYPE_UNIX          ((DWORD)(2))

#define PLATFORM_SUPPORTS_UNICODE   0x00000001

// max header allowed by wininet in the cache

#define MAX_HEADER_SUPPORTED            2048
#define MAX_USERNAME                    128
#define DEFAULT_MAX_EXTENSION_LENGTH    8

/*
 * These should surround any call to g_pSecMgr->PUA, or MUTZ calls in urlmon
 * [ potentially ANYTHING that passes a URL to the sec. mgr. ]
 * to prevent the auto_proxy queueing calls going async.
 *
 * Why not just put it in HostBypassesProxy()?
 *
 * Try only HostBypassesProxy() and then later, we'll add to the urlmon calls
 * if need be.
 *
 * Can optimize these to surround the outermost calls to these functions where
 * the fsm is already available, but in doing so, make sure that no paths
 * that would legitimately send the autoproxy async are made sync.
 *
 *  USE ONLY ONE EACH OF THESE CALLS IN A FUNCTION, and 
 *  MAKE SURE THEY ARE PAIRED UP and IN THE SAME SCOPE.
 */

#define START_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL \
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();\
    BOOL bSetNonBlocking = FALSE;\
    CFsm* pFsm;\
    if (lpThreadInfo && (pFsm=lpThreadInfo->Fsm) && lpThreadInfo->IsAsyncWorkerThread && !pFsm->IsBlocking())\
    {\
        pFsm->SetBlocking(TRUE);\
        bSetNonBlocking = TRUE;\
    }

#define END_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL \
{\
    if (bSetNonBlocking)\
    {\
        pFsm->SetBlocking(FALSE);\
    }\
}

//
// types
//

//
// TRI_STATE - for places where we need to differentiate between TRUE/FALSE and
// uninitialized
//

typedef enum {
    TRI_STATE_UNKNOWN = -1,
    TRI_STATE_FALSE = 0,
    TRI_STATE_TRUE = 1
} TRI_STATE;

//
// DLL_ENTRY_POINT - maps a name to an entry point in a DLL
//

typedef struct {
    LPSTR lpszProcedureName;
    FARPROC * lplpfnProcedure;
} DLL_ENTRY_POINT, * LPDLL_ENTRY_POINT;

//
// DLL_INFO - used to dynamically load/unload libraries
//

typedef struct {
    LPSTR lpszDllName;
    HINSTANCE hModule;
    LONG LoadCount;
    DWORD dwNumberOfEntryPoints;
    LPDLL_ENTRY_POINT lpEntryPoints;
} DLL_INFO, * LPDLL_INFO;

//
// macros
//

#define IsPlatformWin95() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WIN95) ? TRUE : FALSE)

#define IsPlatformWinNT() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : FALSE)

//#define IsUnicodeSupported() \
//    (BOOL)((PlatformSupport() & PLATFORM_SUPPORTS_UNICODE) ? TRUE : FALSE)

#define DLL_ENTRY_POINT_ELEMENT(name) \
    # name, (FARPROC *)&_I_ ## name

#define DLL_INFO_INIT(name, entryPoints) { \
    name, \
    NULL, \
    0, \
    ARRAY_ELEMENTS(entryPoints), \
    (LPDLL_ENTRY_POINT)&entryPoints \
}


#define CompareFileTime(ft1, ft2)   \
    (((*(LONGLONG UNALIGNED *)&ft1) > (*(LONGLONG UNALIGNED *)&ft2)) ? 1 : \
     (((*(LONGLONG UNALIGNED *)&ft1) == (*(LONGLONG UNALIGNED *)&ft2)) ? 0 : -1 ) )



//
// prototypes
//

LPSTR
NewString(
    IN LPCSTR String,
    IN DWORD dwLen = 0
    );

LPWSTR
NewStringW(
    IN LPCWSTR String,
    IN DWORD dwLen = 0
    );


LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    );

HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    );

LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    );

LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    );

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    );

DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os = NULL
    );

DWORD
PlatformSupport(
    VOID
    );

DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    );

DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    );

DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    );

//
// flags for LoadDllEntryPoints()
//

#define LDEP_PARTIAL_LOAD_OK    0x00000001  // ok if not all entry points can be loaded

DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    );

DWORD
MapInternetError(
    IN DWORD ErrorCode
    );

DWORD
CalculateHashValue(
    IN LPSTR lpszString
    );

VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    );

//DWORD DwRemoveDots (
//    char * pchPath
//    );


LPSTR GetFileExtensionFromUrl(
    LPSTR lpszUrl,
    LPDWORD lpdwLength
    );

DWORD
CheckExpired(
    HINTERNET   handle,
    BOOL    *lpfIsExpired,
    LPCACHE_ENTRY_INFO lpCEI,
    LONGLONG DefaultExpiryDelta
    );


LPTSTR
FTtoString(
    IN FILETIME *pftTime
    );

BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
);

BOOL
InternetSettingsChanged(
    VOID
    );

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    );

LPTSTR
FormatCertInfo(
    IN INTERNET_CERTIFICATE_INFO *pCertInfo
    );

BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    );

//DWORD
//UnicodeToUtf8(
//    IN LPCWSTR pwszIn,
//    IN DWORD dwInLen,
//    OUT LPBYTE pszOut,
//    IN OUT LPDWORD pdwOutLen
//    );

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    );

LPSTR
ConvertMBCSToUTF8(
    IN LPCSTR lpszMBCSHostName,
    IN DWORD dwMBCSHostNameLength,
    IN DWORD dwCodePage,
    OUT DWORD * pdwUTF8HostNameLength,
    BOOL bLowerCase = TRUE
    );
    
DWORD 
GetTickCountWrap();

char *FindNamedValue(char *pszHeader, 
                     const char *pszFieldName, 
                     unsigned long *pdwValSize);

#ifdef DONT_USE_IERT
char *
StrTokEx(
    IN OUT char ** pstring, 
    IN const char * control);

double 
StrToDbl(
    IN const char *str, 
    IN OUT char **strStop);
#endif //DONT_USE_IERT

char* StrTokEx2(char** pstring, const char* control);

BOOL IsAddressValidIPString(LPCSTR pszHostIP);

BOOL
RefreshSslState(
    VOID
    );

BOOL
IsInGUIModeSetup();

#if defined(__cplusplus)
}
#endif

#endif // defined(__UTIL_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

typedef struct {

#if INET_DEBUG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // INET_DEBUG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CRITICAL_SECTION Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if INET_DEBUG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if INET_DEBUG

VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // INET_DEBUG

#define InitializeSerializedList(list) \
    { \
        InitializeListHead(&(list)->List); \
        InitializeCriticalSection(&(list)->Lock); \
        (list)->ElementCount = 0; \
    }

#define TerminateSerializedList(list) \
    DeleteCriticalSection(&(list)->Lock)

#define LockSerializedList(list) \
    EnterCriticalSection(&(list)->Lock)

#define UnlockSerializedList(list) \
    LeaveCriticalSection(&(list)->Lock)

#define InsertAtHeadOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertHeadList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define InsertAtTailOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertTailList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define RemoveFromSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        RemoveEntryList(entry); \
        --(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // INET_DEBUG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\urlcache.h ===
#ifndef URLCACHE_H

#define URLCACHE_H

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    urlcache.h

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:

    Rajeev Dujari (rajeevd) 10-Apr-1997

Revision History:

    10-Apr-97 rajeevd
        Created

--*/

struct CACHE_ENTRY_INFOEX : INTERNET_CACHE_ENTRY_INFO
{
    FILETIME ftDownload;
    FILETIME ftPostCheck;
};

DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

void UrlCacheFlush (void); // check registry to flush cache

DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE
);

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};


DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile);

DWORD UrlCacheSendNotification (IN DWORD dwOp);

BOOL IsExpired
(
    CACHE_ENTRY_INFOEX* pInfo, 
    DWORD dwCacheFlags, 
    BOOL* pfLaxyUpdate
);

extern const char vszUserNameHeader[4];

#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL DLLUrlCacheEntry( IN DWORD Reason );

BOOL GetIE5ContentPath( LPSTR szPath);

DWORD SwitchIdentity(GUID* guidIdentity);
DWORD RemoveIdentity(GUID* guidIdentity);
DWORD AlterIdentity(DWORD dwControl);

#ifdef WININET6
DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw);
DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw);
#endif

#endif //URLCACHE.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\xpltfrm.h ===
#ifndef __XPLTFRM_H__
#define __XPLTFRM_H__

#include <platform.h>

#ifdef unix
#define LONGLONG_ZERO 0LL
#define __int8 char
#define DIR_SEPARATOR_CHAR TEXT('/')
#define DIR_SEPARATOR_STRING TEXT("/")
#define WEBDIR_STRING "Web/"
// Follwing is workaround for MainWin Registry API bug 2053.
#else
#define LONGLONG_ZERO 0i64
#define DIR_SEPARATOR_CHAR TEXT('\\')
#define DIR_SEPARATOR_STRING TEXT("\\")
#define WEBDIR_STRING "Web\\" 
#endif /* unix */

#endif /* __XPLTFRM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\secinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    secinit.h

Abstract:

    Contains prototypes for indirected security functions

Author:

    Sophia Chung (sophiac) 7-Feb-1996

Revision History:

--*/

#if !defined(_SECINIT_)

#define _SECINIT_

#if defined(__cplusplus)
extern "C" {
#endif

#include <sspi.h>

extern CRITICAL_SECTION InitializationSecLock;

extern PSecurityFunctionTable   GlobalSecFuncTable;
extern WIN_VERIFY_TRUST_FN      pWinVerifyTrust;
extern WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;
extern SSL_CRACK_CERTIFICATE_FN pSslCrackCertificate;
extern SSL_FREE_CERTIFICATE_FN  pSslFreeCertificate;

extern HCERTSTORE   g_hMyCertStore;
extern BOOL         g_bOpenMyCertStore;
extern BOOL         g_fDoSpecialMagicForSGCCerts;

#define g_EnumerateSecurityPackages \
        (*(GlobalSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(GlobalSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(GlobalSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(GlobalSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(GlobalSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(GlobalSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(GlobalSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved4))

LONG WINAPI WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD);

// Don't use WinVerifyTrust directly to verify secure channel connections.
// Use the wininet wrapper WinVerifySecureChannel instead.
#define g_WinVerifyTrust \
        pWinVerifyTrust


#define g_SslCrackCertificate \
        pSslCrackCertificate

#define g_SslFreeCertificate pSslFreeCertificate
        

typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

#define CRYPT_INSTALL_DEFAULT_CONTEXT_NAME      "CryptInstallDefaultContext"

typedef BOOL
(WINAPI * CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
);

#define CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME    "CryptUninstallDefaultContext"
    
typedef BOOL
(WINAPI * CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)   
(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
);

typedef PCCERT_CHAIN_CONTEXT
(WINAPI *CERT_FIND_CHAIN_IN_STORE_FN)
(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
);

#define CERT_FIND_CHAIN_IN_STORE_NAME            "CertFindChainInStore"

typedef VOID
(WINAPI *CERT_FREE_CERTIFICATE_CHAIN_FN)
(
    IN PCCERT_CHAIN_CONTEXT pChainContext
);

#define CERT_FREE_CERTIFICATE_CHAIN_NAME        "CertFreeCertificateChain"


extern CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext;
extern CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext;
extern CERT_FIND_CHAIN_IN_STORE_FN        g_CertFindChainInStore;
extern CERT_FREE_CERTIFICATE_CHAIN_FN     g_CertFreeCertificateChain;

extern HCRYPTPROV GlobalFortezzaCryptProv;

#define LOCK_SECURITY()   EnterCriticalSection( &InitializationSecLock )
#define UNLOCK_SECURITY() LeaveCriticalSection( &InitializationSecLock )


//
// prototypes
//

VOID
SecurityInitialize(
    VOID
    );

VOID
SecurityTerminate(
    VOID
    );

DWORD
ReopenMyCertStore(
    VOID
    );

DWORD
CloseMyCertStore(
    VOID
    );

DWORD
LoadSecurity(
    VOID
    );

VOID
UnloadSecurity(
    VOID
    );

DWORD
LoadWinTrust(
    VOID
    );


BOOL
IsFortezzaInstalled(
    VOID
    );

BOOL AttemptedFortezzaLogin(
    VOID
    );

DWORD FortezzaLogOn(
    HWND hwnd
    );

#if defined(__cplusplus)
}
#endif

#endif // _SECINIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\thrdinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.h

Abstract:

    Per-thread structure definitions/macros

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define INTERNET_THREAD_INFO_SIGNATURE  'drhT'  // "Thrd"

//
// forward references
//

class CFsm;

//
// types
//

//
// INTERNET_THREAD_INFO - per-thread information, handily referenced via a TLS
// slot
//

typedef struct _INTERNET_THREAD_INFO {

    //
    // List - doubly linked list that we delete on DLL_PROCESS_DETACH
    //

    LIST_ENTRY List;

#if INET_DEBUG

    //
    // Signature - lets us know that this structure is probably an
    // INTERNET_THREAD_INFO
    //

    DWORD Signature;

#endif

    //
    // ThreadId - used to identify this thread within a process
    //

    DWORD ThreadId;

    //
    // ErrorNumber - arbitrary error code, supplied in InternetSetLastError
    //

    DWORD ErrorNumber;

    //
    // hErrorText - we store the last error text on a per-thread basis. This
    // handle identifies a moveable buffer
    //

    HLOCAL hErrorText;

    //
    // ErrorTextLength - length of the error text in hErrorText
    //

    DWORD ErrorTextLength;

    //
    // Context - arbitrary app-supplied context value. This is used by
    // StatusCallback to identify which operation the callback is for. We keep
    // the context in the per-thread information so we don't have to pass it
    // around, nor across the wire in the case of an RPC callback
    //

    DWORD_PTR Context;

    //
    // hObject - the current Internet object handle being used in this API. We
    // need this to maintain context e.g. when we want to get timeout values
    //

    HINTERNET hObject;

    //
    // hObjectMapped - this is the address of the real object mapped to hObject
    //

    HINTERNET hObjectMapped;

    //
    // IsAsyncWorkerThread - TRUE if this thread is an async worker thread
    //

    BOOL IsAsyncWorkerThread;

    //
    // InCallback - TRUE if we have made an app callback. Used to detect
    // re-entrancy
    //

    BOOL InCallback;

    //
    // IsAutoProxyProxyThread - TRUE if we are the thread running auto-proxy requests.  Used
    //  to allow direct shutdown of auto-proxy during PROCESS_DETACH
    //

    BOOL IsAutoProxyProxyThread;

    //
    // NestedRequests - incremented when we detect that we're processing an API
    // in the async worker thread context. If this API then calls other APIs,
    // then we need to treat (mapped) handles differently in the called APIs
    //

    DWORD NestedRequests;

    //
    // dwMappedErrorCode - the real error code returned by e.g. a winsock API,
    // before it was mapped to a WinInet error
    //

    DWORD dwMappedErrorCode;

    //
    // Fsm - currently executing Finite State Machine
    //

    CFsm * Fsm;

#ifdef ENABLE_DEBUG

    //
    // IsAsyncSchedulerThread - TRUE if this INTERNET_THREAD_INFO belongs to the
    // one-and-only async scheduler thread
    //

    BOOL IsAsyncSchedulerThread;

    //
    // per-thread debug variables
    //

    //
    // Pointer to LIFO (stack) of INTERNET_DEBUG_RECORDs. Used to generate
    // indented call-tracing for diagnostics
    //

    LPINTERNET_DEBUG_RECORD Stack;

    //
    // CallDepth - nesting level for calls
    //

    int CallDepth;

    //
    // IndentIncrement - the current indent level. Number of spaces
    //

    int IndentIncrement;

    //
    // StartTime and StopTime - used for timing calls to e.g. send(), recv()
    //

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;

#endif // #ifdef ENABLE_DEBUG

} INTERNET_THREAD_INFO, *LPINTERNET_THREAD_INFO;

//
// macros
//

//
// InternetClearLastError - frees the response text buffer for this thread
//

#define InternetClearLastError() \
    InternetSetLastError(0, NULL, 0, 0)

//
// InternetResetContext - resets the per-thread call-back context value
//

#define InternetResetContext() \
    InternetSetContext(INTERNET_NO_CALLBACK)

//
// InternetResetObjectHandle - resets the per-thread current object handle
//

#define InternetResetObjectHandle() \
    InternetSetObjectHandle(NULL)

//
// _InternetIncNestingCount - increments nesting level count
//

#define _InternetIncNestingCount() \
    lpThreadInfo->NestedRequests++;

// ** debug version
//#define _InternetIncNestingCount() \
//    if ( lpThreadInfo->NestedRequests > 0xffff ) { \
//        OutputDebugString("InternetIncNestingCount, inc over threshold, contact arthurbi, x68073 (sechs)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests++;

//
// _InternetDecNestingCount - decrements nesting level count
//

#define _InternetDecNestingCount(dwNestingLevel) \
    lpThreadInfo->NestedRequests -= dwNestingLevel;

// ** debug version
//#define _InternetDecNestingCount(dwNestingLevel) \
//    if ( lpThreadInfo->NestedRequests == 0 ) { \
//        OutputDebugString("InternetDecNestingCount, attempting to dec 0, contact arthurbi, x68073 (sieben)\n"); \
//        DebugBreak(); \
//    } \
//    if ( dwNestingLevel != 1 && dwNestingLevel != 0 ) { \
//        OutputDebugString("InternetDecNestingCount, invalid nesting level, contact arthurbi, x68073 (acht)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests -= dwNestingLevel;

//
// _InternetSetObjectHandle - set the object handle given the thread info block
//

#define _InternetSetObjectHandle(lpThreadInfo, hInternet, hMapped) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new obj handle on thrd=%x, old=%x, new=%x (map: old=%x, new=%x)\n", \
            lpThreadInfo, \
            lpThreadInfo->hObject, \
            hInternet, \
            lpThreadInfo->hObjectMapped, \
            hMapped \
            )); \
    if ( lpThreadInfo->IsAutoProxyProxyThread ) \
        GlobalProxyInfo.SetAbortHandle(hInternet); \
    lpThreadInfo->hObject = hInternet; \
    lpThreadInfo->hObjectMapped = hMapped;

//
// _InternetSetContext - set the object context given the thread info block
//

#define _InternetSetContext(lpThreadInfo, dwContext) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new context on thrd=%x, old=%x, new=%x\n", \
            lpThreadInfo, \
            lpThreadInfo->Context, \
            dwContext \
            )); \
    lpThreadInfo->Context = dwContext;

//
// _InternetClearLastError - clear the last error info given the thread info
// block
//

#define _InternetClearLastError(lpThreadInfo) \
    _InternetSetLastError(lpThreadInfo, 0, NULL, 0, 0)

//
// _InternetResetObjectHandle - clear the object handle given the thread info
// block
//

#define _InternetResetObjectHandle(lpThreadInfo) \
    _InternetSetObjectHandle(lpThreadInfo, NULL, NULL)

//
// _InternetGetObjectHandle - retrieves the object handle from the per-thread
// info block
//

#define _InternetGetObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObject

//
// _InternetGetMappedObjectHandle - retrieves the mapped object handle from the
// per-thread info block
//

#define _InternetGetMappedObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObjectMapped

//
// _InternetGetContext - retrieve the context from the per-thread info block
//

#define _InternetGetContext(lpThreadInfo) \
    lpThreadInfo->Context

//
// _InternetResetContext - reset context in per-thread info block given
// per-thread info block
//

#define _InternetResetContext(lpThreadInfo) \
    _InternetSetContext(lpThreadInfo, 0)

//
// InternetDisableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetDisableAsync(lpThreadInfo) \
    _InternetSetAsync(FALSE)

//
// InternetEnableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetEnableAsync(lpThreadInfo, Val) \
    _InternetSetAsync(TRUE)

//
// _InternetGetAsync - returns the async worker thread indication from the
// thread info block
//

#define _InternetGetAsync(lpThreadInfo) \
    lpThreadInfo->IsAsyncWorkerThread

//
// _InternetSetAsync - turns on or off the async worker thread indication in the
// thread info block
//

#define _InternetSetAsync(lpThreadInfo, Val) \
    lpThreadInfo->IsAsyncWorkerThread = Val

#define _InternetGetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback

#define _InternetSetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = TRUE

#define _InternetResetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = FALSE

#define _InternetSetAutoProxy(lpThreadInfo) \
    lpThreadInfo->IsAutoProxyProxyThread = TRUE

#if INET_DEBUG

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE)

#else

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    /* NOTHING */

#endif

//
// prototypes
//

#define UI_ACTION_CODE_NONE_TAKEN                   0
#define UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
#define UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
#define UI_ACTION_CODE_USER_ACTION_COMPLETED        3


DWORD
ChangeUIBlockingState(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwError,
    OUT LPDWORD  lpdwActionTaken,
    OUT LPDWORD  lpdwResultCode,
    IN OUT LPVOID * lplpResultData
    );

DWORD
ResumeAfterUserInput(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwResultCode,
    OUT LPBOOL   pfItemResumed
    );

LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    );

VOID
InternetDestroyThreadInfo(
    VOID
    );

VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

VOID
InternetTerminateThreadInfo(
    VOID
    );

LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    );

VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    );

DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo
    );

DWORD
InternetIndicateStatus(
    IN DWORD dwInternetStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    );

DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

#define SLE_APPEND          0x00000001
#define SLE_ZERO_TERMINATE  0x00000002

DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

LPSTR
InternetLockErrorText(
    VOID
    );

VOID
InternetUnlockErrorText(
    VOID
    );

VOID
InternetSetContext(
    IN DWORD_PTR dwContext
    );

VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    );

HINTERNET
InternetGetObjectHandle(
    VOID
    );

HINTERNET
InternetGetMappedObjectHandle(
    VOID
    );

//
// external data
//

extern SERIALIZED_LIST ThreadInfoList;

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
        ulong           ipsi_forwarding;
        ulong           ipsi_defaultttl;
        ulong           ipsi_inreceives;
        ulong           ipsi_inhdrerrors;
        ulong           ipsi_inaddrerrors;
        ulong           ipsi_forwdatagrams;
        ulong           ipsi_inunknownprotos;
        ulong           ipsi_indiscards;
        ulong           ipsi_indelivers;
        ulong           ipsi_outrequests;
        ulong           ipsi_routingdiscards;
        ulong           ipsi_outdiscards;
        ulong           ipsi_outnoroutes;
        ulong           ipsi_reasmtimeout;
        ulong           ipsi_reasmreqds;
        ulong           ipsi_reasmoks;
        ulong           ipsi_reasmfails;
        ulong           ipsi_fragoks;
        ulong           ipsi_fragfails;
        ulong           ipsi_fragcreates;
        ulong           ipsi_numif;
        ulong           ipsi_numaddr;
        ulong           ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
        ulong           icmps_msgs;
        ulong           icmps_errors;
        ulong           icmps_destunreachs;
        ulong           icmps_timeexcds;
        ulong           icmps_parmprobs;
        ulong           icmps_srcquenchs;
        ulong           icmps_redirects;
        ulong           icmps_echos;
        ulong           icmps_echoreps;
        ulong           icmps_timestamps;
        ulong           icmps_timestampreps;
        ulong           icmps_addrmasks;
        ulong           icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
        ICMPStats       icsi_instats;
        ICMPStats       icsi_outstats;
} ICMPSNMPInfo;

#define IP_FORWARDING           1
#define IP_NOT_FORWARDING       2

typedef struct IPAddrEntry {
        ulong           iae_addr;
        ulong           iae_index;
        ulong           iae_mask;
        ulong           iae_bcastaddr;
        ulong           iae_reasmsize;
        ushort          iae_context;
        ushort          iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
        ulong           ire_context;
} IPRouteEntry;

typedef struct IPRouteEntry95 {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
} IPRouteEntry95;

typedef struct AddrXlatInfo {
        ulong           axi_count;
        ulong           axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                                 1
#define ICMP_MIB_STATS_ID                               1

#define AT_MIB_ADDRXLAT_INFO_ID                 1
#define AT_MIB_ADDRXLAT_ENTRY_ID                0x101

#define IP_MIB_RTTABLE_ENTRY_ID                 0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID               0x102

#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\wininetd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wininetd.h

Abstract:

    Contains the interface for the WININET diagnostic capabilities.

    This interface only exists in the debug version of WININET.DLL.
    Calling the debug functions in the retail version of the DLL will
    yield ERROR_INVALID_PARAMETER

Author:

    Richard L Firth (rfirth) 14-Jun-1995

Revision History:

    14-Jun-1995 rfirth
        Created

--*/

//
// manifests
//

//
// if the environment or registry variable "WininetLog" is set to !0 then the
// following values will be used for control, category and error level resp.
// These options generate "WININET.LOG" in the current directory
//

#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define INTERNET_OPTION_GET_DEBUG_INFO      1001
#define INTERNET_OPTION_SET_DEBUG_INFO      1002
#define INTERNET_OPTION_GET_HANDLE_COUNT    1003
#define INTERNET_OPTION_GET_TRIGGERS        1004
#define INTERNET_OPTION_SET_TRIGGERS        1005
#define INTERNET_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         INTERNET_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          INTERNET_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_INET            0x00000001  // e.g. InternetOpenUrl()
#define DBG_FTP             0x00000002  // e.g. FtpFindFirstFile()
#define DBG_GOPHER          0x00000004  // e.g. GopherFindFirstFile()
#define DBG_HTTP            0x00000008  // e.g. HttpOpenRequest()
#define DBG_API             0x00000010  // APIs
#define DBG_UTIL            0x00000020  // various utility functions
#define DBG_UNICODE         0x00000040  // wide character functions
#define DBG_WORKER          0x00000080  // worker functions
#define DBG_HANDLE          0x00000100  // handle creation/deletion functions
#define DBG_SESSION         0x00000200  // session/creation functions
#define DBG_SOCKETS         0x00000400  // sockets functions
#define DBG_VIEW            0x00000800  // gopher view functions
#define DBG_BUFFER          0x00001000  // gopher buffer functions
#define DBG_PARSE           0x00002000  // FTP/gopher parse functions
#define DBG_MEMALLOC        0x00004000  // Debug memory allocation/free functions
#define DBG_SERIALST        0x00008000  // Serialized List functions
#define DBG_THRDINFO        0x00010000  // INTERNET_THREAD_INFO functions
#define DBG_PROTOCOL        0x00020000  // protocol functions
#define DBG_DLL             0x00040000  // DLL functions
#define DBG_REFCOUNT        0x00080000  // logs all reference count functions
#define DBG_REGISTRY        0x00100000  // logs all registry functions
#define DBG_TRACE_SOCKETS   0x00200000  // monitors socket usage
#define DBG_ASYNC           0x00400000  // logs async functions
#define DBG_CACHE           0x00800000  // logs cache specific stuff
#define DBG_INVALID_HANDLES 0x01000000  // logs invalid handles (e.g. in InternetCloseHandle())
#define DBG_OBJECTS         0x02000000  // dump object info
#define DBG_PROXY           0x04000000  // dump proxy info
#define DBG_RESLOCK         0x08000000  // dump resource lock info
#define DBG_DIALUP          0x10000000  // dump dial-up info
#define DBG_GLOBAL          0x20000000  // dump global-scope functions
#define DBG_HTTPAUTH        0x40000000  // authentication functions
#define DBG_ANY             0xFFFFFFFF  // internal

//
// types
//

//
// INTERNET_DEBUG_INFO - structure that receives the current debugging variables
// via InternetQueryOption(), or which contains the new debugging variables to
// be set via InternetSetOption()
//

typedef struct {

    //
    // ErrorLevel - DBG_INFO, etc.
    //

    int ErrorLevel;

    //
    // ControlFlags - DBG_THREAD_INFO, etc.
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - DBG_INET, etc.
    //

    DWORD CategoryFlags;

    //
    // BreakFlags - DBG_API, etc. where breakpoints will be taken
    //

    DWORD BreakFlags;

    //
    // IndentIncrement - increment to use for each depth increase
    //

    int IndentIncrement;

    //
    // Filename - name of output log being used/to use
    //

    char Filename[1];

} INTERNET_DEBUG_INFO, *LPINTERNET_DEBUG_INFO;

//
// INTERNET_TRIGGER_INFO - a diagnostic trigger. Triggers are enabled when the
// function named in this structure is executed. Triggers can enable or disable
// diagnostics
//

typedef struct {

    //
    // FunctionName - name of the function to act as trigger. ControlFlags has
    // DBG_TRIGGER_ON or DBG_TRIGGER_OFF set
    //

    LPCSTR FunctionName;

    //
    // ControlFlags - control flags to use when the trigger is enabled. If the
    // trigger disables diagnostics then the previous control flags will be
    // restored
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - category flags to use when the trigger is enabled. See
    // ControlFlags
    //

    DWORD CategoryFlags;

} INTERNET_TRIGGER_INFO, *LPINTERNET_TRIGGER_INFO;

//
// INTERNET_DEBUG_TRIGGERS - 1 or more of these will be returned from/given to
// InternetQueryOption()/InternetSetOption()
//

typedef struct {

    //
    // Count - number of INTERNET_TRIGGER_INFO structures contained herein
    //

    DWORD Count;

    //
    // Triggers - an array of 0 or more INTERNET_TRIGGER_INFO structures
    //

    INTERNET_TRIGGER_INFO Triggers[1];

} INTERNET_DEBUG_TRIGGERS, *LPINTERNET_DEBUG_TRIGGERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\ntddtcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"


//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif  // ifndef _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			512

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
// Don't #define memmove to RtlMoveMemory for wchar.h
// because the protoypes don't match.
#pragma push_macro("memmove")
#undef memmove
#include <wchar.h>
#pragma pop_macro("memmove")


LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    );

LONG
wtol (
    IN LPWSTR Src
    );


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(wtol)(Src)

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscat)((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscpy)((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(wcslen)(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(wcswcs)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(_wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(wcscmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(ultow)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(atol)(Src)

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(strstr)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)
#define STRREV(s)           (LPTSTR)MAKE_STR_FUNCTION(strrev)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(lstrcmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_strnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(_ultoa)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  MAKE_STR_FUNCTION(memcpy)
#define MEMMOVE                 MAKE_STR_FUNCTION(memmove)

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((MAKE_STR_FUNCTION(wcslen)(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\wininetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Includes all headers for precompiled header to build Windows Internet
    client DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#ifndef __WININETP_H__
#define __WININETP_H__ 1

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

// #define STRESS_BUG_DEBUG // for stress debugging

#if DBG

#define STRESS_BUG_DEBUG // for stress debugging

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG


#define WININET_SELFREG     1
//
// common include files
//


//
// CRT includes
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h> // Pull in the 'offsetof' macro.
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <excpt.h>
#include <limits.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>

#if defined(__cplusplus)
}
#endif

//#include <fastcrit.h>

//
// SSL/PCT Security includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>    // standard SSPI interface
#include <issperr.h> // SSPI errors.
#include <spseal.h>  // Private SSPI Seal/UnSeal functions.
#include <schnlsp.h> // shared private schannel/wininet interfaces.
#include <wintrust.h> // various CAPI stuff for cert management
#include <wincrypt.h>
#if defined(__cplusplus)
}
#endif


//
// WININET includes
//

#include <iwinsock.h>
#include <wininet.h>
#include <winineti.h>
#include <oldnames.h>
#include <unsup.h>      // no longer supported items
#include <wininetd.h>
#include <resinfo.h>
#include <serialst.h>
#include <blocklst.hxx>
#include <chunk.hxx>
#include <inetdbg.h>
#include <debugmem.h>
#include <shlwapi.h>
#define NO_SHLWAPI_MLUI
#include <shlwapip.h>
#include <malloc.h>
#include <crtsubst.h>
#include <handle.h>
#include <constant.h>
#include <macros.h>
#include <inetp.h>
#include <util.h>
#include <proxreg.h>
#include <icstring.hxx>
#include <cliauth.hxx>
#include <certcach.hxx>
#include <buffer.hxx>
#include <resolver.h>
#include <thrdinfo.h>
#include <defaults.h>
#include <passport.h>
#include <spluginx.hxx>
#include <splugin.hxx>
#include <secinit.h>
#include <inetsspi.h>
#include <tstr.h>
#include <readhtml.h>
#include <ftpinit.h>
#include <gfrinit.h>
#include <httpinit.h>
#include <registry.h>
#include <parseurl.h>
#include <username.hxx>
#include <globals.h>
#include <autoprox.hxx>
#include <reslock.hxx>
#include <proxysup.hxx>
#include <httpfilt.hxx>
#include <hinet.hxx>
#include <priolist.hxx>
#include <icasync.hxx>
#include <caddrlst.hxx>
#include <icsocket.hxx>
#include <ssocket.hxx>
#include <servinfo.hxx>
#include <urlcache.h>
#include <connect.hxx>
#include <ftp.hxx>
#include <gopher.hxx>
#include <http.hxx>
#include <cookie.h>
#include <rescache.h>
#include <parsers.h>
#include <fsm.hxx>
#include <mpacket.hxx>
#include <inetchar.h>
#include <bgtask.hxx>
#include <cookimp.h>
#include <cookexp.h>
#include <401imprt.hxx>
#include <commctrl.h>
#include <shfusion.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <resource.h>


//
//  Various protocol package initializers.
//

BOOL
WINAPI
WinInetDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

#if defined(__cplusplus)
}
#endif

// privacy helper function used in dllinstall
void CheckPrivacyDefaults(void);

//
// Need version 0x400 for ras defines for this to work on win95 gold.
//
#if defined(__cplusplus)
extern "C" {
#endif

#undef WINVER
#define WINVER 0x400

#include <ras.h>
#include <raserror.h>

#ifdef ICECAP
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall MarkCAP(long lMark);  // write mark to MEA
extern "C" void _stdcall AllowCAP(void);  // Allow profiling when 'profile=almostnever'
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define MarkCAP(n)
#define AllowCAP()
#endif

#if defined(__cplusplus)
}
#endif

/* X-Platform stuff */
#include <xpltfrm.h>

#endif /* __WININETP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\dialui.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dialui.cxx

Abstract:

    Contains the implementation of all ui for wininet's dialing support

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    22-Apr-1997 darrenmi
        Created


--*/

#include <wininetp.h>

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Prompt to go offline dialog
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        return TRUE;
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDS_WORK_OFFLINE:
        case IDCANCEL:
            EndDialog(hDlg,TRUE);
            return TRUE;
            break;
        case IDS_TRY_AGAIN:
            EndDialog(hDlg,FALSE);
            return TRUE;
            break;
        default:
            break;
        }
        break;
   default:
        break;
   }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                          Go Online dialog
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK OnlineDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    switch(uMsg) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case ID_CONNECT:
                EndDialog(hDlg, TRUE);
                break;
            case IDCANCEL:
            case ID_STAYOFFLINE:
                EndDialog(hDlg, FALSE);
                break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\ierrdlg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ierrdlg.cxx

Abstract:

    Contains immplimentation of generic Windows Dialog
    Manipulation Code.  This Code will support several
    basic operations for putting up dialog UI.

    Contents:
        LaunchDlg
        LaunchAuthPlugInDlg
        MapWininetErrorToDlgId
        (AuthDialogProc)
        (OkCancelDialogProc)
        (CertPickDialogProc)

Author:

    Arthur L Bierer (arthurbi) 04-Apr-1996

Revision History:

    04-Apr-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include "ierrui.hxx"
#include "iehelpid.h"
#include <persist.h>
#ifdef UNIX
#include <unixui.h>
#endif /* UNIX */

#include <wincred.h>
#include <ntverp.h>


// NOTE- This is not a path delmiter. It is used
// to separate NT DOMAIN\USERNAME fields.
#define DOMAIN_DELIMITER '\\'
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//
// private prototypes
//

INT_PTR
CALLBACK
AuthDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

INT_PTR
CALLBACK
OkCancelDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

INT_PTR
CALLBACK
InsertCDDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );


VOID
UpdateGlobalSecuritySettings(
    IN DWORD dwCtlId,
    IN DWORD dwFlags
    );




//
// public functions
//


DWORD
LaunchAuthPlugInDlg(
                HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                AUTHCTX * pAuthCtx,
                HWND hWnd,
                DWORD dwError,
                DWORD dwFlags,
                InvalidPassType *pipAuthUIInfo
                )
/*++

Routine Description:

    Creates and Launches a Security Plug-In supported Dialog.
    The PlugIn will register a callback function that can be called
    by WININET to put up a custom authentication Dialog.

    The PlugIn is expected to make a "DialogBox" call and return
    its results using WININET error code conventions.


Arguments:

    lppvContext - pointer to context pointer

    hWnd       - Parent Window handle to show the dialog from.

    dwError    - Error code that caused this authentication to come up,
                 should always be ERROR_INTERNET_PASSWORD_INVALID.

    dwFlags    - A special flags assoicated with this authentication.

    pPwdCacheEntry - A Password cache entry structure.

    pipAuthUIInfo - Username/Password structure to return the result.


Return Value:

    DWORD
        ERROR_SUCCESS    -  Success.

        ERROR_CANCELLED  -  User clicked "Cancel" or "No" in the dialog.

        ERROR_BAD_FORMAT -  We faulted while trying to calldown to the plugin.
--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "LaunchAuthPlugInDlg",
                "%#x, %#x, %d (%s), %#x, %#x",
                pAuthCtx->_pvContext,
                hWnd,
                dwError,
                InternetMapError(dwError),
                dwFlags,
                pAuthCtx->_pPWC
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // If this Authentication Scheme Handles Its Own UI, then we need
    //  to Defer to Its Own Dialog Code.
    //

    if (pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI)
    {
        // Digest context handles its own ui.
        if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
        {
            error = ((DIGEST_CTX*) pAuthCtx)->PromptForCreds(hWnd);
        }
        else
        {
            __try
            {
                // The package handles it's own UI, possibly generating an auth
                // header.

                // Since AuthenticateUserUI calls into GetSecAuthMsg which
                // calls into InitializeSecurityPackage we use the same method
                // embbeded in PLUG_CTX methods of checking the return code of the
                // SSPI call against SEC_E_OK to know if the auth context can transit
                // to AUTHSTATE_CHALLENGE.
                SECURITY_STATUS ssResult;
                ssResult = SEC_E_INTERNAL_ERROR;

                error = AuthenticateUserUI
                    (&pAuthCtx->_pvContext, hWnd, dwError, dwFlags, pipAuthUIInfo, 
                        pAuthCtx->GetScheme(), ((PLUG_CTX*)pAuthCtx)->GetUrl(), &ssResult);


                // Transit to the correct auth state.
                if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
                {
                    if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NEGOTIATE)
                        ((PLUG_CTX*)pAuthCtx)->ResolveProtocol();

                    // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
                    // Negotiate does not transit to challenge.
                    // Any other protocol + SEC_E_OK only transits to challenge.
                    if ((pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS
                        && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                        || (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
                    {
                        /*pAuthCtx->_pRequest*/pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
                    }        
                }
            }


            __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                            ? EXCEPTION_EXECUTE_HANDLER
                            : EXCEPTION_CONTINUE_SEARCH )
            {
                DEBUG_PRINT(HTTP,
                        ERROR,
                        ("AuthenticateUserUI call down Faulted, return failure\n"));

                error = ERROR_BAD_FORMAT;
                goto quit;
            }
            ENDEXCEPT
        }
    }
    else
    {
        //
        // I don't expect to be called in this case
        //

        INET_ASSERT(FALSE);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
LaunchDlg(
          IN HWND      hWnd,
          IN LPVOID    lpParam,
          IN DWORD     dwDlgResource,
          IN DLGPROC   pDlgProc
          )
/*++

Routine Description:

    Creates and Launches the appropriate dialog based on
    the dialog resource passed in.

Arguments:

    hWnd    - Parent Window handle to show the dialog from.

    lpParam - Void pointer which will become the lParam value passed
              the dialog box proc.

    dwDlgResource - the dialog resource id.

    pDlgProc      - Pointer to Function to use for this dialog.

Return Value:

    DWORD
        ERROR_SUCCESS    -  Success.

        ERROR_CANCELLED  -  User clicked "Cancel" or "No" in the dialog.
--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "LaunchDlg",
                "%#x, %#x, %d %x",
                hWnd,
                lpParam,
                dwDlgResource,
                pDlgProc
                ));

    DWORD error = ERROR_SUCCESS;
    INT_PTR result = 0;

    if ((dwDlgResource == IDD_NTLM_AUTH) ||
        (dwDlgResource == IDD_REALM_AUTH) ||
        (dwDlgResource == 0 /*Passport Auth*/) )
    {
        DWORD DisableCredMgr = 0;
        InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                     "DisableCredManager",
                                    (LPDWORD) &DisableCredMgr
                          );

        if (GlobalPlatformWhistler && !DisableCredMgr)
        {
            CREDINFODLGTYPE *pDlgInfo = (CREDINFODLGTYPE *) lpParam;
            
            pDlgInfo->pAuthCtx->InitCredUI();
            HMODULE hCredUI = pDlgInfo->pAuthCtx->_hCredUI;
            PFN_CREDUI_PROMPTFORCREDENTIALS pfnCredUIPromptForCredentials = pDlgInfo->pAuthCtx->_pfnCredUIPromptForCredentials;
            PFN_CREDUI_PROMPTFORCREDENTIALS_W pfnCredUIPromptForCredentialsW = pDlgInfo->pAuthCtx->_pfnCredUIPromptForCredentialsW;

            if ( hCredUI != NULL)
            {
                DWORD dwCredFlags = 0;

                if (dwDlgResource == 0 /*Passport Auth*/)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)pDlgInfo->pAuthCtx;
                    HTTP_REQUEST_HANDLE_OBJECT  *pRequest = pDlgInfo->pRequest;

                    HBITMAP hBitmap = NULL;
                    PWSTR pszCbtxtW = NULL;
                    PSTR pszCbtxtA = NULL;
                    DWORD dwszCbChars = 0;

                    WCHAR szUserNameW[CREDUI_MAX_USERNAME_LENGTH];
                    szUserNameW[0] = L'\0';

                    if (pPPCtx->PromptForCreds(&hBitmap, NULL, &dwszCbChars, NULL, NULL) == TRUE) // need to prompt user
                    {
                        // alloc the text and get it.
                        if ( dwszCbChars > 0  )
                        {
	                        pszCbtxtW = (PWSTR)HeapAlloc ( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwszCbChars + 1)*sizeof(WCHAR));
	                        pszCbtxtA = (PSTR)HeapAlloc ( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwszCbChars + 1)*sizeof(CHAR));
	                        if ( pszCbtxtW != NULL && pszCbtxtA != NULL )
	                        {
		                        if ( pPPCtx->PromptForCreds(NULL, pszCbtxtW, &dwszCbChars, NULL, NULL ) == TRUE )
		                        {
                                    // convert WtoA
			                        if ( ::WideCharToMultiByte(CP_ACP, 0, 
                                                                pszCbtxtW, -1, 
                                                                pszCbtxtA, dwszCbChars + 1, 
                                                                NULL, NULL) == 0 )
			                        {
				                        // failed, don't send
				                        HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
				                        HeapFree ( GetProcessHeap(), 0, pszCbtxtA );
				                        pszCbtxtW = NULL;
				                        pszCbtxtA = NULL;
			                        }
                                    else
                                    {
                                        UrlUnescapeA(pszCbtxtA, NULL, NULL, URL_UNESCAPE_INPLACE);

                                        if (::MultiByteToWideChar(CP_UTF8, 0, pszCbtxtA, -1, pszCbtxtW, (dwszCbChars + 1)*sizeof(WCHAR)) == 0)
                                        {
                                            // failed, don't send
                                            HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
                                            HeapFree ( GetProcessHeap(), 0, pszCbtxtA );
                                            pszCbtxtW = NULL;
                                            pszCbtxtA = NULL;
                                        }
                                    }

		                        }

	                        }

                        }

                        CREDUI_INFOW CredUIInfo;
                        CredUIInfo.cbSize = sizeof(CredUIInfo);
                        CredUIInfo.hbmBanner = hBitmap;
                        CredUIInfo.hwndParent = hWnd;
                        CredUIInfo.pszCaptionText = NULL;
                        CredUIInfo.pszMessageText = pszCbtxtW;

                        WCHAR szPasswordW[CREDUI_MAX_PASSWORD_LENGTH];
                        szPasswordW[0] = L'\0';

                        dwCredFlags = 0;
                        if (pPPCtx->_pPWC && pPPCtx->_pPWC->lpszUser)
                        {
                            ::MultiByteToWideChar(CP_ACP, 0, pPPCtx->_pPWC->lpszUser, -1, szUserNameW, strlen(pPPCtx->_pPWC->lpszUser) + 1);
                        }
                        if (szUserNameW[0] != L'\0')
                        {
                            dwCredFlags |= CREDUI_FLAGS_KEEP_USERNAME;
                        }

                        WCHAR wServerName[128];
                        ::MultiByteToWideChar(CP_ACP, 0, pRequest->GetServerName(), -1, wServerName, 128);
                        DWORD dwRet = (*pfnCredUIPromptForCredentialsW) ( &CredUIInfo, 
                                               wServerName, 
                                               NULL,
                                               ERROR_LOGON_FAILURE,
                                               szUserNameW,
                                               CREDUI_MAX_USERNAME_LENGTH,
                                               szPasswordW,
                                               CREDUI_MAX_PASSWORD_LENGTH,
                                               NULL,
                                               dwCredFlags );	


                        if ( dwRet ==  ERROR_SUCCESS)
                        {
                            CHAR szUserNameA[CREDUI_MAX_USERNAME_LENGTH];
                            CHAR szPasswordA[CREDUI_MAX_PASSWORD_LENGTH];
			                ::WideCharToMultiByte(CP_ACP, 0, 
                                                        szUserNameW, -1, 
                                                        szUserNameA, CREDUI_MAX_USERNAME_LENGTH, 
                                                        NULL, NULL);
			                ::WideCharToMultiByte(CP_ACP, 0, 
                                                        szPasswordW, -1, 
                                                        szPasswordA, CREDUI_MAX_PASSWORD_LENGTH, 
                                                        NULL, NULL);
                            AuthLock();

                            //pRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                            pRequest->SetUserOrPass ((LPSTR)szUserNameA, TRUE, FALSE);
                            pRequest->SetUserOrPass ((LPSTR)szPasswordA, FALSE, FALSE);
                            pRequest->TimeStampCreds();
                            AuthUnlock();

                            ZeroMemory ( szPasswordW, CREDUI_MAX_PASSWORD_LENGTH * sizeof(WCHAR) );
                            ZeroMemory ( szPasswordA, CREDUI_MAX_PASSWORD_LENGTH * sizeof(CHAR) );
                        }


                        if ( pszCbtxtW != NULL )
                            HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
                        if ( pszCbtxtA != NULL )
                            HeapFree ( GetProcessHeap(), 0, pszCbtxtA );


                        switch ( dwRet )
                        {
                        case ERROR_SUCCESS:
                            g_fIgnoreCachedCredsForPassport = FALSE;
                            // user entered information, try CredReadDomainCredentials again, the
                            // Credentials entered by the user should be found by that call now.
                            break;

                        case ERROR_CANCELLED:
                            // user cancelled from the dialog, fail authentication attempt.
                            error = ERROR_CANCELLED;
                            goto quit;

                            // comment: double-check return code
                        }
                    }
                }
                else
                {
                    InvalidPassType *ipt = pDlgInfo->pipt;

                    CREDUI_INFO uiInfo;
                    dwCredFlags = 0;

                    uiInfo.cbSize = sizeof(uiInfo);
                    uiInfo.hwndParent = hWnd;
                    uiInfo.pszCaptionText = NULL;
                    uiInfo.hbmBanner = NULL;


                    if (dwDlgResource == IDD_NTLM_AUTH)
                    {
                        PLUG_CTX* pAuthCtx = (PLUG_CTX*) (pDlgInfo->pAuthCtx);
                        
                        uiInfo.pszMessageText = NULL;

//                        dwCredFlags = CREDUI_FLAGS_EXPECT_CONFIRMATION;

                        // If we're always prompting in this zone, write a server
                        // specific credential because we may or may not have
                        // target info and need to provide a consistent experience
                        // in either case:

                        if (GetCredPolicy(pDlgInfo->pRequest->GetURL()) ==
                            URLPOLICY_CREDENTIALS_MUST_PROMPT_USER)
                        {
                            dwCredFlags |= CREDUI_FLAGS_SERVER_CREDENTIAL;
                        }

                        // need to check if credential persistence is available
                        // borrowed from AuthDlgProc
                        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                            g_dwCredPersistAvail = InetInitCredentialPersist();

                        if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
                            dwCredFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;

                        error = (*pfnCredUIPromptForCredentials) ( &uiInfo,
                                               ipt->lpszHost,
                                               NULL,
                                               pAuthCtx->_SecStatus,
                                               // ERROR_LOGON_FAILURE,
                                               ipt->lpszUsername,
                                               min(CREDUI_MAX_USERNAME_LENGTH, ipt->ulMaxField - 1),
                                               ipt->lpszPassword,
                                               min(CREDUI_MAX_PASSWORD_LENGTH, ipt->ulMaxField - 1),
                                               NULL,
                                               dwCredFlags );	

                    }


                    if ((error == ERROR_NO_SUCH_LOGON_SESSION) ||
                        (dwDlgResource == IDD_REALM_AUTH))
                    {
                        dwCredFlags = CREDUI_FLAGS_EXCLUDE_CERTIFICATES |
                                      CREDUI_FLAGS_DO_NOT_PERSIST | 
                                      CREDUI_FLAGS_GENERIC_CREDENTIALS;

                        
                        BOOL fSave = FALSE;
                        BOOL fLastCredentialsFromStore = FALSE;
                        PSTR pszMessageText = NULL;

                        // If we have a realm name, use it for the message text.
                        // If the name is too long, truncate it by copying to a
                        // new buffer. If out of memory, just pass NULL to get the
                        // default message text:

                        if (ipt->lpszRealm != NULL)
                        {
                            DWORD cbMessageText = lstrlenA(ipt->lpszRealm);

                            if (cbMessageText <= CREDUI_MAX_MESSAGE_LENGTH)
                            {
                                uiInfo.pszMessageText = ipt->lpszRealm;
                            }
                            else
                            {
                                pszMessageText = new CHAR[cbMessageText + 1];

                                if (pszMessageText != NULL)
                                {
                                    if (lstrcpyn(pszMessageText,
                                                 ipt->lpszRealm,
                                                 CREDUI_MAX_MESSAGE_LENGTH) == NULL)
                                    {
                                        delete [] pszMessageText;
                                        pszMessageText = NULL;
                                    }
                                }

                                uiInfo.pszMessageText = pszMessageText;
                            }
                        }
                        else
                        {
                            uiInfo.pszMessageText = NULL;
                        }

                        // First, determine if credential persistence is available:

                        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                        {
                            g_dwCredPersistAvail = InetInitCredentialPersist();
                        }

                        if (g_dwCredPersistAvail != CRED_PERSIST_NOT_AVAIL)
                        {
                            dwCredFlags |= CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX;
                        }

                        // If any credentials are passed in, use them:

                        if (ipt->lpszUsername[0] && ipt->lpszPassword[0])
                        {
                            fLastCredentialsFromStore = FALSE;
                            ipt->lpszPassword[0] = '\0';
                        }
                        else
                        {
                            ipt->lpszUsername[0] = '\0';
                            ipt->lpszPassword[0] = '\0';

                            // Attempt to get credentials from persisted store:

                            if (g_dwCredPersistAvail != CRED_PERSIST_NOT_AVAIL)
                            {
                                if (InetGetCachedCredentials(
                                        ipt->lpszHost,
                                        ipt->lpszRealm,
                                        ipt->lpszUsername,
                                        ipt->lpszPassword) == ERROR_SUCCESS)
                                {
                                    fSave = TRUE;
                                    fLastCredentialsFromStore = TRUE;
                                }
                                else
                                {
                                    fSave = FALSE;
                                    fLastCredentialsFromStore = FALSE;
                                }
                            }
                        }

                        error =
                            pfnCredUIPromptForCredentials(
                                &uiInfo,
                                ipt->lpszHost,
                                NULL,
                                // pAuthCtx->_SecStatus,
                                ERROR_LOGON_FAILURE,
                                ipt->lpszUsername,
                                min(CREDUI_MAX_USERNAME_LENGTH, ipt->ulMaxField - 1),
                                ipt->lpszPassword,
                                min(CREDUI_MAX_PASSWORD_LENGTH, ipt->ulMaxField - 1),
                                g_dwCredPersistAvail ? &fSave : NULL,
                                dwCredFlags);


                        if (fSave)
                        {
                            InetSetCachedCredentials(
                                ipt->lpszHost,
                                ipt->lpszRealm,
                                ipt->lpszUsername,
                                ipt->lpszPassword);
                        }
                        else if (fLastCredentialsFromStore)
                        {
                            InetRemoveCachedCredentials(
                                ipt->lpszHost,
                                ipt->lpszRealm);
                        }

                        // Free our temporary message buffer, if necessary:

                        if (pszMessageText != NULL)
                        {
                            delete [] pszMessageText;
                        }
                    }

                    // Translate all failure cases into ERROR_CANCELLED for now:

                    if (error != ERROR_SUCCESS)
                    {
                        error = ERROR_CANCELLED;
                    }
                }

            }
            else
            {
                error = ERROR_CANCELLED;
            }

            goto quit;
        }
        else
        {
            // we are not using the Whistler CredUI
            if (dwDlgResource == 0 /*Passport Auth*/)
            {
                // biaow-todo: we don't know how to handle Passport-CredUI for downlevel yet;
                // panic in checked build
                INET_ASSERT(TRUE);

                // consider this "Cancelled" in retail...
                error = ERROR_CANCELLED;
                goto quit;
            }

            pDlgProc = AuthDialogProc;
            INET_ASSERT(pDlgProc);
        }
    }

    //
    // Launch the Dialog Box, and wait for it to complete
    //

    // Should actually cast lpParam as CREDINFODLGTYPE* and pass
    // pipt element instead of just lpParam.

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);

    result = DialogBoxParamWrapW(GlobalResHandle,
                            MAKEINTRESOURCEW(dwDlgResource),
                            hWnd,
                            (DLGPROC) pDlgProc,
                            (LPARAM) lpParam);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
    if ( result == FALSE || result == -1)
    {
        error = ERROR_CANCELLED;
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

DWORD
MapWininetErrorToDlgId(
    IN  DWORD        dwError,
    OUT LPDWORD     lpdwDlgId,
    OUT LPDWORD     lpdwDlgFlags,
    OUT DLGPROC     *ppDlgProc
    )

/*++

Routine Description:

    Maps a Wininet Error Code to an internal Dlg Resource Id.

Arguments:

    dwError      -  A Wininet defined error code with an expected
                    assoicated dlg.

    lpdwDlgId    -  Pointer to location where Dlg Id result will be returend.
                    This ID can be used for creating a Dlg Resource.

    lpdwDlgFlags -  Pointer to DWORD flags used to store various capiblites
                    for Dialog.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_INVALID_PARAMETER

Comments:

    none.

--*/

{
    typedef struct {
        DWORD   dwWininetError;
        DWORD   dwDlgId;
        DLGPROC pDlgProc;
        DWORD   dwDlgFlags;
    } ErrorToDlgIdMappingType;


    ErrorToDlgIdMappingType MapErrorToDlg[] = {
        { ERROR_INTERNET_SEC_CERT_CN_INVALID,       IDD_BAD_CN,                      OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_CERT_CN_INVALID)   },
        { ERROR_INTERNET_SEC_CERT_DATE_INVALID,     IDD_CERT_EXPIRED,                OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_CERT_DATE_INVALID) },
        { ERROR_INTERNET_MIXED_SECURITY,            IDD_MIXED_SECURITY,              OkCancelDialogProc, 0 },
        { ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR,    IDD_HTTP_TO_HTTPS_ZONE_CROSSING, OkCancelDialogProc, 0 },
        { ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR,    IDD_HTTPS_TO_HTTP_ZONE_CROSSING, OkCancelDialogProc, 0 },
        { ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION,   IDD_HTTP_POST_REDIRECT,          OkCancelDialogProc, 0 },
        { ERROR_INTERNET_CHG_POST_IS_NON_SECURE,    IDD_WARN_ON_POST,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_POST_IS_NON_SECURE,        IDD_WARN_ON_POST,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_INVALID_CA,                IDD_INVALID_CA,                  OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_INVALID_CA)},
        { ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,   IDD_CERTPICKER,                  CertPickDialogProc, 0 },
        { ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT,     IDD_SCRIPT_ERROR,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT, IDD_FAILED_DOWNLOAD,             OkCancelDialogProc, (DLG_FLAGS_BRING_TO_FOREGROUND)},
        { ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR,   IDD_HTTPS_TO_HTTP_SUBMIT_REDIRECT,OkCancelDialogProc, 0 },
        { ERROR_INTERNET_INSERT_CDROM,              IDD_INSERT_CDROM,                InsertCDDialogProc, 0 },
        { ERROR_INTERNET_SEC_CERT_ERRORS,           IDD_SEC_CERT_ERRORS,             OkCancelDialogProc, DLG_FLAGS_CAN_HAVE_CERT_INFO },
        { ERROR_INTERNET_SEC_CERT_REV_FAILED,       IDD_REVOCATION_PROBLEM,          OkCancelDialogProc, DLG_FLAGS_CAN_HAVE_CERT_INFO },
    };


    INET_ASSERT(lpdwDlgId);
    INET_ASSERT(lpdwDlgFlags);

    *lpdwDlgId    = 0;
    *lpdwDlgFlags = 0;
    *ppDlgProc    = 0;

    for ( DWORD i = 0; i < ARRAY_ELEMENTS(MapErrorToDlg); i++ )
    {
        if (  dwError == MapErrorToDlg[i].dwWininetError )
        {
            *lpdwDlgId    = MapErrorToDlg[i].dwDlgId;
            *lpdwDlgFlags = MapErrorToDlg[i].dwDlgFlags;
            *ppDlgProc    = MapErrorToDlg[i].pDlgProc;
            return ERROR_SUCCESS;
        }
    }

    INET_ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;
}


//
// private functions.
//

BOOL
CALLBACK
ResizeAuthDialogProc(
    HWND hwnd,
    LPARAM lparam
    )
{
    // passed lpRect contains top and bottom for inserted region, move all elements
    // below the top down by bottom-top
    LPRECT lpInsertRect = (LPRECT) lparam;
    RECT ChildRect;
    HWND hwndParent;

    hwndParent = GetParent(hwnd);
    if(!hwndParent)
       return FALSE;

    GetWindowRect(hwnd, &ChildRect);
    if(ChildRect.top >= lpInsertRect->top) {
        ScreenToClient(hwndParent, (LPPOINT) &ChildRect.left);
        SetWindowPos(hwnd, 0, ChildRect.left, ChildRect.top + (lpInsertRect->bottom - lpInsertRect->top), 0, 0, SWP_NOZORDER|SWP_NOSIZE);
    }
    return TRUE;
}

INT_PTR
CALLBACK
AuthDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Handles authentication dialog

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    const static DWORD mapIDCsToIDHs[] =
    {
        IDC_SITE_OR_FIREWALL, IDH_AUTH_SERVER_FIREWALL,
        IDC_SERVER_OR_PROXY,  IDH_AUTH_SERVER_FIREWALL,
        IDC_USERNAME_TAG,     IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
        IDC_USERNAME,         IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
        IDC_PASSWORD_TAG,     IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
        IDC_PASSWORD,         IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
        IDC_DOMAIN_TAG,       IDH_AUTH_DOMAIN,
        IDC_DOMAIN_FIELD,     IDH_AUTH_DOMAIN,
        IDC_SAVE_PASSWORD,    IDH_AUTH_SAVE_PASSWORD,
        IDC_REALM_TAG,        IDH_AUTH_REALM,
        IDC_REALM_FIELD,      IDH_AUTH_REALM,
        0,0
    };

    static BOOL fLastCredentialsFromStore = FALSE;
    WCHAR  wszTmp[MAX_FIELD_LENGTH];

    CREDINFODLGTYPE *pDlgInfo;
    InvalidPassType *ipt;
    PLOCAL_STRINGS plszStrings = FetchLocalStrings();

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        CHAR szUsername[MAX_FIELD_LENGTH],
             szPassword[MAX_FIELD_LENGTH];

        CHAR *pUsr, *pDmn, *ptr;

        pDlgInfo = (CREDINFODLGTYPE *) lparam;
        ipt = pDlgInfo->pipt;

        SetForegroundWindow(hwnd);

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               (LONG_PTR)ipt);

        // First determine if credential persistence is available.
        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
            g_dwCredPersistAvail = InetInitCredentialPersist();

        if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
            ShowWindow(GetDlgItem(hwnd, IDC_SAVE_PASSWORD), SW_HIDE);

        // If any credentials are passed in, use them.
        if (*ipt->lpszUsername && *ipt->lpszPassword)
        {
            // Flag that credentials did not come from
            // persistent store and copy values.
            fLastCredentialsFromStore = FALSE;
            memcpy(szUsername, ipt->lpszUsername, ipt->ulMaxField-1);
//            memcpy(szPassword, ipt->lpszPassword, ipt->ulMaxField-1);
            *szPassword = '\0';
        }
        else
        {
            // Otherwise, get any persisted credentials for this domain or realm.

            // Current credentials are originally blank.
            *szUsername = '\0';
            *szPassword = '\0';

            // Attempt to get credentials from persisted store.
            if (g_dwCredPersistAvail)
            {
                if (InetGetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                    szUsername, szPassword) == ERROR_SUCCESS)
                {
#ifdef UNIX
                    /* If the user had not selected to store the password,
                     * we will save the password as NULL, but still save the
                     * username and domain. So, if the password is null, we
                     * don't check the button (this is ok because if somebody
                     * wants to save a null password, it will come out as
                     * null, but the button is not checked. Do you really
                     * want ie to tell you that you saved a null password ?)
                     */
                    if (!*szPassword) {
                       fLastCredentialsFromStore = FALSE;
                       CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                    }
                    else
#endif /* UNIX */
                    {
                       // Record that credentials were retrieved.
                       CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);
                       fLastCredentialsFromStore = TRUE;
                    }
                }
                else
                {
                    // Credentials were not retrieved.
                    fLastCredentialsFromStore = FALSE;
                    CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                }
            }
        }

        // If credential persistence is available, the save checkbox
        // is now visible. If credentials were retrieved from persistent
        // store then fLastCredentialsFromStore will now be set to TRUE
        // and the save check box will be checked. Otherwise,
        // fLastCredentialsFromStore will now be set to FALSE.

        // If the authentication type is NTLM, crack the domain\username stored
        // in ipt->lpszUsername into its constituent parts (domain and username).
        if (ipt->eAuthType == NTLM_AUTH)
        {
            // Scan Domain\Username for backslash.
            pUsr = strchr(szUsername, DOMAIN_DELIMITER);

            // Found backslash - replace with '\0'.
            if (pUsr)
            {
                *pUsr = '\0';
                pUsr++;
                pDmn = szUsername;
            }
            // No backslash found - take as username.
            else
            {
                pUsr = szUsername;
                pDmn = NULL;
            }

            // Set user and domain fields.
            SetWindowTextWrapW(GetDlgItem(hwnd,
                IDC_DOMAIN_OR_REALM), plszStrings->szDomain);

            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (pUsr, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_USERNAME), wszTmp);

            // Indicate field is domain.
            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            if (pDmn)
                SHAnsiToUnicode (pDmn, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_DOMAIN_FIELD), wszTmp);

            // Hide IDC_REALM_FIELD which overlays IDC_DOMAIN_FIELD
            ShowWindow(GetDlgItem(hwnd,IDC_REALM_FIELD), SW_HIDE);
        }

        // Otherwise if auth type is basic or digest, simply display username.
        else if (ipt->eAuthType == REALM_AUTH)
        {
            // Set user and realm fields.
            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (szUsername, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                wszTmp);

            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (ipt->lpszRealm, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_REALM_FIELD),
                wszTmp);

            // Indicate field is realm.
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_REALM),
                plszStrings->szRealm);

            // qfe 4857 - long realm names are truncated
            if(ipt->lpszRealm && lstrlen(ipt->lpszRealm) > 20) {
                RECT WndRect;
                RECT RealmRect;
                // about 20 chars will fit per line, but bound it at 6 lines
                int cy = min(6, (lstrlen(ipt->lpszRealm) / 20));

                //resize window, text box, reposition all lower elements in callback

                GetWindowRect(GetDlgItem(hwnd,IDC_REALM_FIELD), &RealmRect);
                cy *= RealmRect.bottom - RealmRect.top;  // Scale box taller
                SetWindowPos(GetDlgItem(hwnd,IDC_REALM_FIELD), 0, 0, 0, RealmRect.right- RealmRect.left, RealmRect.bottom- RealmRect.top + cy, SWP_NOZORDER|SWP_NOMOVE);

                GetWindowRect(hwnd, &WndRect);
                SetWindowPos(hwnd, 0, 0, 0, WndRect.right - WndRect.left, WndRect.bottom - WndRect.top + cy, SWP_NOZORDER|SWP_NOMOVE);

                RealmRect.top = RealmRect.bottom;
                RealmRect.bottom +=cy;   // RealmRect contains the inserted region
                EnumChildWindows(hwnd, ResizeAuthDialogProc, (LPARAM) &RealmRect);

            }

        }

        // Set password field.
        SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD), szPassword);

        // Indicate Site or Firewall as appropriate.
        if (ipt->fIsProxy)
        {
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_SITE_OR_FIREWALL),
            plszStrings->szFirewall);
        }
        else
        {
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_SITE_OR_FIREWALL),
            plszStrings->szSite);
        }

        // Finally indicate site/proxy.
        SetWindowText (GetDlgItem(hwnd,IDC_SERVER_OR_PROXY),
            ipt->lpszHost);

        (void)SendMessage(GetDlgItem(hwnd,IDC_USERNAME),
                          EM_LIMITTEXT,
                          (WPARAM)ipt->ulMaxField-1,
                          0L);

        (void)SendMessage(GetDlgItem(hwnd,IDC_PASSWORD),
                          EM_LIMITTEXT,
                          (WPARAM)ipt->ulMaxField-1,
                          0L);

        // If we already have a username, select
        // current password and put caret at end.
        if (*szUsername)
        {
            SendMessage(GetDlgItem(hwnd, IDC_PASSWORD),
                EM_SETSEL, 0, -1);

            SetFocus(GetDlgItem(hwnd, IDC_PASSWORD));
        }
        // Otherwise, select username
        else
        {
            SendMessage(GetDlgItem(hwnd, IDC_USERNAME),
                EM_SETSEL, 0, -1);

            SetFocus(GetDlgItem(hwnd, IDC_USERNAME));
        }

        // Return FALSE since we are always setting the keyboard focus.
        return FALSE;

    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;
        DWORD cbUsr, cbPass, cbDmn;

        ipt =
            (InvalidPassType *) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case IDOK:

                    INET_ASSERT(ipt);
                    INET_ASSERT(ipt->ulMaxField > 0 );
                    INET_ASSERT(ipt->lpszUsername);
                    INET_ASSERT(ipt->lpszPassword);

                    if (ipt->eAuthType == REALM_AUTH)
                    {
                        // Basic or digest auth - not much to do.
                        cbDmn = 0;

                        // Does not include null.

                        cbUsr = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        INET_ASSERT(MAX_FIELD_LENGTH >= ipt->ulMaxField);
                        // Convert this  blindly to ANSI
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername, ipt->ulMaxField);
                    }

                    // NTLM auth - separate domain and username if necessary.
                    else if (ipt->eAuthType == NTLM_AUTH)
                    {
                        // Does not include null.



                        cbDmn = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_DOMAIN_FIELD),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        // Convert this blindly to ANSI
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername, ipt->ulMaxField);
                        // Domain was typed in.
                        if (cbDmn)
                        {
                            // Check for backslash.
                            ptr = strchr(ipt->lpszUsername, DOMAIN_DELIMITER);
                            if (!ptr)
                            {
                                // No backslash - append one.
                                *(ipt->lpszUsername + cbDmn) = DOMAIN_DELIMITER;
                                *(ipt->lpszUsername + cbDmn + 1) = '\0';
                            }
                            // Found a backslash.
                            else
                            {
                                // Strip after backslash.
                                cbDmn = (DWORD)(ptr - ipt->lpszUsername);
                                *(ptr+1) = '\0';
                            }

                            cbDmn++;
                        }

                        // Get the username and append to domain.
                        cbUsr = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        // Convert this blindly to ANSI
                        // BUGBUG - should i
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername + cbDmn, (ipt->ulMaxField - cbDmn));

                    }


                    // Get the password.
                    cbPass = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_PASSWORD),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                    SHUnicodeToAnsi(wszTmp, ipt->lpszPassword, ipt->ulMaxField);


                    // If save box checked, persist credentials.
                    if (IsDlgButtonChecked(hwnd, IDC_SAVE_PASSWORD) == BST_CHECKED)
                    {
                        InetSetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                            ipt->lpszUsername, ipt->lpszPassword);
                    }
                    else
                    {
#ifndef UNIX
                        // Otherwise remove the credentials from persisted
                        // store, but only if necessary.
                        if (fLastCredentialsFromStore)
                        {
                            // Current and original credentials are same. Remove
                            // credentials.
                            InetRemoveCachedCredentials(ipt->lpszHost, ipt->lpszRealm);
                        }
#else
                    /*
                     * On Unix, we need to save the username/domain and not
                     * the password in this case
                     */
                    {
                        InetSetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                            ipt->lpszUsername, NULL);
                    }
#endif /* UNIX */
                    }

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        return TRUE;
        }

    case WM_HELP:               // F1
        WinHelp((HWND) ((LPHELPINFO) lparam)->hItemHandle,
                 "iexplore.hlp",
                 HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs);

    break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( hwnd,
                 "iexplore.hlp",
                 HELP_CONTEXTMENU,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs);
        break;
    }

    return FALSE;
}
VOID
UpdateGlobalSecuritySettings(
    IN DWORD dwCtlId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Updates several Global flags, and writes the update to the registry.
    The update is based on dwCtlId which is a dialog resource id.

    The update ALWAYS turns OFF the flag, since the only of turning
    it back on is to use the Ctl Pannel/Internet/Security PropSheet.

Arguments:

    dwCtlId    - Dialog ID to base update on.

    dwFlags    - Flags assoicated with the dialog.

Return Value:

    VOID
        none.


--*/

{
#ifndef WININET6
    switch ( dwCtlId )
    {
        case IDD_BAD_CN:
//        case IDD_BAD_CN_SENDING:

            //
            // BUGBUG [arthurbi] these are grouped together,
            //  they should be seperate.
            //

            GlobalWarnOnBadCertRecving = FALSE;
            GlobalWarnOnBadCertSending = FALSE;

            InternetWriteRegistryDword("WarnOnBadCertSending",
                                      (DWORD)GlobalWarnOnBadCertSending);

            InternetWriteRegistryDword("WarnOnBadCertRecving",
                                      (DWORD)GlobalWarnOnBadCertRecving);


            break;


        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:

            GlobalWarnOnZoneCrossing = FALSE;


            InternetWriteRegistryDword("WarnOnZoneCrossing",
                                      (DWORD)GlobalWarnOnZoneCrossing);

            break;

        case IDD_WARN_ON_POST:

            GlobalWarnOnPost = FALSE;


            InternetWriteRegistryDword("WarnOnPost",
                                      (DWORD)GlobalWarnOnPost);

            break;

        case IDD_HTTP_POST_REDIRECT:

            GlobalWarnOnPostRedirect = FALSE;

            InternetWriteRegistryDword("WarnOnPostRedirect",
                                      (DWORD)GlobalWarnOnPostRedirect);

            break;
    }
#else
    switch ( dwCtlId )
    {
        case IDD_BAD_CN:
//        case IDD_BAD_CN_SENDING:

            //
            // BUGBUG [arthurbi] these are grouped together,
            //  they should be seperate.
            //

            GlobalWarnOnBadCertRecving = FALSE;
            GlobalWarnOnBadCertSending = FALSE;

            InternetIDEWriteRegistryDword("WarnOnBadCertSending",
                                      (DWORD)GlobalWarnOnBadCertSending);

            InternetIDEWriteRegistryDword("WarnOnBadCertRecving",
                                      (DWORD)GlobalWarnOnBadCertRecving);


            break;


        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:

            GlobalWarnOnZoneCrossing = FALSE;


            InternetIDEWriteRegistryDword("WarnOnZoneCrossing",
                                      (DWORD)GlobalWarnOnZoneCrossing);

            break;

        case IDD_WARN_ON_POST:

            GlobalWarnOnPost = FALSE;


            InternetIDEWriteRegistryDword("WarnOnPost",
                                      (DWORD)GlobalWarnOnPost);

            break;

        case IDD_HTTP_POST_REDIRECT:

            GlobalWarnOnPostRedirect = FALSE;

            InternetIDEWriteRegistryDword("WarnOnPostRedirect",
                                      (DWORD)GlobalWarnOnPostRedirect);

            break;

    }
#endif
}


BOOL
SetCertDlgItem(
    HWND hDlg,
    DWORD dwIconCtl,
    DWORD dwTextCtl,
    DWORD dwString,
    BOOL  fError
)
/*++

--*/
{
    INET_ASSERT(hDlg);

    //
    // The default dialog code always load icons sized 32x32.  To get 16x16
    // we have to LoadImage to the correct size and then set the icon via
    // a windows message.
    //

    HICON hicon = (HICON)LoadImage(GlobalResHandle,
                               MAKEINTRESOURCE(fError ? IDI_WARN : IDI_SUCCESS),
                                   IMAGE_ICON, 16, 16, 0);

    if (hicon)
    {
        HICON hiconOld = (HICON)SendDlgItemMessage(hDlg, dwIconCtl,
                                                   STM_SETIMAGE,
                                                   (WPARAM)IMAGE_ICON,
                                                   (LPARAM)hicon);

        if (hiconOld)
            DestroyIcon(hiconOld);
    }

    //
    // The dialog displays the error string by default.  Replace this with the
    // success string if an error didn't occur.
    //

    if (!fError)
    {
        WCHAR sz[512];

        if (LoadStringWrapW(GlobalResHandle, dwString, sz, ARRAY_ELEMENTS(sz)))
            SetDlgItemTextWrapW(hDlg, dwTextCtl, sz);
    }

    return TRUE;
}

BOOL InitSecCertErrorsDlg(
    HWND hDlg,
    PERRORINFODLGTYPE pDlgInfo
)
/*++

--*/
{
    INET_ASSERT(pDlgInfo);

    //
    // Get the errors that occured from the hInternetMapped object.
    //

    DWORD dwFlags;

    if (pDlgInfo->hInternetMapped)
    {
        dwFlags = ((HTTP_REQUEST_HANDLE_OBJECT*)pDlgInfo->hInternetMapped)->GetSecureFlags();
    }
    else
    {
        dwFlags = -1; // Display all errors.
    }

    //
    // If an error occured set the ignore flag so if the users selects to bypass
    // this error it gets ignored the next time through.  Then initialize the
    // dialog icons and text.
    //

    if (dwFlags & DLG_FLAGS_INVALID_CA)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_INVALID_CA;
    }

    SetCertDlgItem(hDlg, IDC_CERT_TRUST_ICON, IDC_CERT_TRUST_TEXT,
                   IDS_CERT_TRUST, dwFlags & DLG_FLAGS_INVALID_CA);

    if (dwFlags & DLG_FLAGS_SEC_CERT_DATE_INVALID)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
    }

    SetCertDlgItem(hDlg, IDC_CERT_DATE_ICON, IDC_CERT_DATE_TEXT,
                   IDS_CERT_DATE, dwFlags & DLG_FLAGS_SEC_CERT_DATE_INVALID);

    if (dwFlags & DLG_FLAGS_SEC_CERT_CN_INVALID)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
    }

    SetCertDlgItem(hDlg, IDC_CERT_NAME_ICON, IDC_CERT_NAME_TEXT,
                   IDS_CERT_NAME, dwFlags & DLG_FLAGS_SEC_CERT_CN_INVALID);

    //
    // Set the focus to the "No" button and return FALSE so the default dialog
    // code doesn't set the focus to "Yes".
    //

    SetFocus(GetDlgItem(hDlg, IDCANCEL));

    return FALSE;
}


INT_PTR
CALLBACK
OkCancelDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Supports Yes/No, Ok/Cancel decisions for the authentication UI.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    BOOL              fRet = FALSE;
    PERRORINFODLGTYPE pDlgInfo;

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               lparam);

        pDlgInfo = (PERRORINFODLGTYPE)lparam;

        if (IDD_SEC_CERT_ERRORS == pDlgInfo->dwDlgId)
        {
            fRet = InitSecCertErrorsDlg(hwnd, pDlgInfo);
        }
        else if (IDD_REVOCATION_PROBLEM == pDlgInfo->dwDlgId)
        {
            DWORD dwFlags = 0;

            if (pDlgInfo->hInternetMapped)
                dwFlags = ((HTTP_REQUEST_HANDLE_OBJECT*)pDlgInfo->hInternetMapped)->GetSecureFlags();
            if (dwFlags & DLG_FLAGS_SEC_CERT_REV_FAILED)
                pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_FAILED_REVOCATION;
        }
        else
        {
#ifdef UNIX
        /* Unix Does not support Context-sensitive help.
         * Don't show the More Info button
         */
        //UnixAdjustButtonSpacing(hwnd, pDlgInfo->dwDlgId);
        UnixRemoveMoreInfoButton(hwnd, pDlgInfo->dwDlgId);
#endif /* UNIX */

            fRet = TRUE;
        }

        // set this dialog as foreground if necessary
        if(pDlgInfo->dwDlgFlags & DLG_FLAGS_BRING_TO_FOREGROUND)
        {
            SetForegroundWindow(hwnd);
        }

        break;

    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;

        pDlgInfo =
            (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_CERT_EDIT:

                    //
                    // BUGBUG why can't we do this on WM_INITDIALOG?
                    //

                    if ( wNotificationCode == EN_SETFOCUS)
                    {
                        //
                        // clear any selection, caused by it being the first
                        //  edit control on the dlg page.
                        //

                        if ( ! (pDlgInfo->dwDlgFlags & DLG_FLAGS_HAS_DISABLED_SELECTION) )
                        {
                            SendDlgItemMessage(hwnd,ID_CERT_EDIT,EM_SETSEL,(WPARAM) (INT)-1,0);
                            pDlgInfo->dwDlgFlags |= DLG_FLAGS_HAS_DISABLED_SELECTION;
                        }
                    }

                    break;

                case ID_TELL_ME_ABOUT_SECURITY:
                    {
                    //
                    // Launches help for this button.
                    //

                    //
                    // BUGBUG remove the constant "iexplore.hlp"
                    //
                    UINT uiID = 1;

                    switch (pDlgInfo->dwDlgId)
                    {
                        case IDD_CONFIRM_COOKIE:
                            uiID = IDH_SEC_SEND_N_REC_COOKIES;
                            break;

                        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                            uiID = IDH_SEC_ENTER_SSL;
                            break;

                        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                             uiID = IDH_SEC_ENTER_NON_SECURE_SITE;
                             break;

                        case IDD_INVALID_CA:
                            uiID = IDH_SEC_ENTER_SSL_W_INVALIDCERT;
                            break;

                        case IDD_BAD_CN:
                            uiID = IDH_SEC_SIGNED_N_INVALID;
                            break;

                        case IDD_MIXED_SECURITY:
                            uiID = IDH_SEC_MIXED_DOWNLOAD_FROM_SSL;
                            break;

                    }
                    WinHelp(
                            hwnd,
                            "iexplore.hlp",
                            HELP_CONTEXT,
                            (ULONG_PTR)uiID
                            );
                    break;
                    }


                case ID_SHOW_CERTIFICATE:

                    //
                    // If this dialog supports this behavior, then launch
                    //  a show certficate dlg.
                    //

                    if ( (pDlgInfo->dwDlgFlags & DLG_FLAGS_CAN_HAVE_CERT_INFO) &&
                         wNotificationCode == BN_CLICKED)
                    {
                        INTERNET_SECURITY_INFO ciSecInfo;


                        if (ERROR_SUCCESS == ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetSecurityInfo(
                                                    (LPINTERNET_SECURITY_INFO) &ciSecInfo))
                        {



                            ShowSecurityInfo(
                                hwnd,
                                &ciSecInfo
                                );

                            CertFreeCertificateContext(ciSecInfo.pCertificate);
                        }
                    }

                    break;

                case IDOK:
                case IDYES:

                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    //
                    // Save flags, and change any global vars,
                    //  and registry values if needed.
                    //

                    if (pDlgInfo->hInternetMapped)
                    {
                        HTTP_REQUEST_HANDLE_OBJECT *pHttpRequest;

                        pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)
                                pDlgInfo->hInternetMapped;

                        pHttpRequest->SetSecureFlags(
                                pDlgInfo->dwDlgFlags
                                );
                    }

                    //
                    // If the user checked the "overide" check-box
                    //  let us map it, and force a general
                    //  override of all errors of this type.
                    //

                    if ( IsDlgButtonChecked(hwnd, IDC_DONT_WANT_WARNING) == BST_CHECKED )
                    {
                        UpdateGlobalSecuritySettings(
                            pDlgInfo->dwDlgId,
                            pDlgInfo->dwDlgFlags
                            );
                    }

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:
                case IDNO:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        fRet = TRUE;
        break;
        }
    }

    return fRet;
}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

BOOL
InitCookieDialog(HWND hwnd,PCOOKIE_DLG_INFO pcdi)
/*++
    Fills in all of the fields and resizes the cookie dialog correctly

  Returns TRUE, unless the pcdi is invalid
--*/
{
    RECT rctDlg, rctDetails;
    INT cy;
    SYSTEMTIME st;
    DWORD dwResource;
    BOOL fResult = FALSE;

    INET_ASSERT(pcdi);

    WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
    WCHAR wszTemp2[INTERNET_MAX_URL_LENGTH];

    if (!pcdi                   ||
        !pcdi->pszServer)
        goto Cleanup;

/*  Don't necessarily have a pic anymore

    if (!pcdi                   ||
        !pcdi->pszServer        ||
        !pcdi->pic->pszName      ||
        !pcdi->pic->pszData      ||
        !pcdi->pic->pszDomain    ||
        !pcdi->pic->pszPath      )
        return FALSE;
*/


    SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pcdi);

    //  do init here.  do we need to do a load loadicon??

    // must limit the size of the window

    GetWindowRect(hwnd, &rctDlg);
    GetWindowRect(GetDlgItem(hwnd, IDC_COOKIE_INFO), &rctDetails);

    pcdi->cx = rctDlg.right - rctDlg.left;
    pcdi->cy = rctDlg.bottom - rctDlg.top;
    cy = rctDetails.top - rctDlg.top;

    SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0,
        pcdi->cx, cy,
        SWP_NOMOVE | SWP_NOZORDER);

    if(pcdi->pic && pcdi->pic->pszDomain)
    {
        LoadStringWrapW(GlobalResHandle, IDS_COOKIE_SAVE, wszTemp, ARRAYSIZE(wszTemp));
        wnsprintfW(wszTemp2, ARRAYSIZE(wszTemp2), wszTemp, pcdi->pic->pszDomain);
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_QUESTION), wszTemp2);
    }
    else
    {
        INET_ASSERT(FALSE);
    }

    // Convert to W before setting these fields
    if(pcdi->pic)
    {
        //
        // if we have a pic, fill out the members
        //
        if(SHAnsiToUnicode(pcdi->pic->pszData, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_DATA),wszTemp);
        
        if(SHAnsiToUnicode(pcdi->pic->pszDomain, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_DOMAIN),wszTemp);
        
        if(SHAnsiToUnicode(pcdi->pic->pszPath, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_PATH),wszTemp);
        
        if (pcdi->dwOperation & COOKIE_OP_3RD_PARTY)
            LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
        else
            LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
        
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_3RDPARTY), wszTemp);
        
        if (pcdi->dwOperation & COOKIE_OP_SESSION)
            LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
        else
            LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
        
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_SESSION), wszTemp);

        if( pcdi->pic->pszP3PPolicy != NULL)
            if( SHAnsiToUnicode( pcdi->pic->pszP3PPolicy, wszTemp, ARRAYSIZE( wszTemp)))
                SetWindowTextWrapW( GetDlgItem( hwnd, IDC_COOKIE_POLICY), wszTemp);
        
        if(0 == (pcdi->dwOperation & COOKIE_OP_GET))
        {
            if(SHAnsiToUnicode(pcdi->pic->pszName, wszTemp, ARRAYSIZE(wszTemp)))
                SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_NAME),wszTemp);
            
            if (pcdi->pic->dwFlags & INTERNET_COOKIE_IS_SECURE)
                LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
            else
                LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
            
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_SECURE),
                wszTemp);
            
            if(pcdi->pic->pftExpires &&
                FileTimeToSystemTime(pcdi->pic->pftExpires, &st) )
            {
                LCID lcid = GetUserDefaultLCID();
                WCHAR szDate[64];
                WCHAR szTime[64];
                WCHAR szDateFormat[] = L"ddd',' MMM dd yyyy";
                WCHAR szTimeFormat[] = L"HH':'mm':'ss";

                GetDateFormatWrapW(lcid, 0, &st, szDateFormat, szDate, 64);
                GetTimeFormatWrapW(lcid, 0, &st, szTimeFormat, szTime, 64);
            
                StrCpyNW(wszTemp, szDate, 64);
                StrCatBuffW(wszTemp, L" ", ARRAYSIZE(wszTemp));
                StrCatBuffW(wszTemp, szTime, ARRAYSIZE(wszTemp));
            }
            else
                LoadStringWrapW(GlobalResHandle, IDS_COOKIE_EXPIRES_ENDSESSION, wszTemp, ARRAYSIZE(wszTemp));
            
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_EXPIRES),
                wszTemp);
        }       
    }

    // BUGBUGHACK - we actually should be called with the clients hwnd as parent -zekel 15MAY97
    //  then we wouldnt have to do this.  this avoids the window coming up behind a browser window.
    //  of course they can still switch out, and close the browser, which will fault.
    SetForegroundWindow(hwnd);

    fResult = TRUE;

Cleanup:

    return fResult;
}

#define COOKIE_DONT_ALLOW   1
#define COOKIE_ALLOW        2
#define COOKIE_ALLOW_ALL    4
#define COOKIE_DONT_ALLOW_ALL 8

INT_PTR
CALLBACK
CookieDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

{

    DWORD  dwEndDlg = 0;
    BOOL fReturn = FALSE;
    PCOOKIE_DLG_INFO pcdi;

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        if(!InitCookieDialog(hwnd, (PCOOKIE_DLG_INFO) lparam))
        {
            dwEndDlg = COOKIE_DONT_ALLOW;
        }

        if( IsOS(OS_WHISTLERORGREATER))
        {
            HICON hIcon = LoadIcon(GlobalResHandle, MAKEINTRESOURCE(IDI_PRIVACY_XP));
            if( hIcon != NULL)
                SendDlgItemMessage(hwnd, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            // icons loaded with LoadIcon never need to be released
        }
            
        fReturn = TRUE;
        break;

    case WM_COMMAND:
        {

            pcdi = (PCOOKIE_DLG_INFO) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (LOWORD(wparam))
            {
                case IDYES:
                    dwEndDlg = COOKIE_ALLOW;

                    if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_COOKIE_ALLOW_ALL))
                    {
                        pcdi->dwStopWarning = COOKIE_ALLOW_ALL;
                    }
                    fReturn = TRUE;
                    break;


                case IDNO:
                    dwEndDlg = COOKIE_DONT_ALLOW;

                    if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_COOKIE_ALLOW_ALL))
                    {
                        pcdi->dwStopWarning = COOKIE_DONT_ALLOW_ALL;
                    }
                    fReturn = TRUE;
                    break;

                case IDC_COOKIE_HELP:
                    WinHelp(hwnd,
                            "iexplore.hlp",
                            HELP_CONTEXT,
                            (pcdi->dwOperation & COOKIE_OP_3RD_PARTY) ?
                                (ULONG_PTR)IDH_COOKIE_THIRD_PARTY :
                                (ULONG_PTR)IDH_COOKIE_FIRST_PARTY
                            );
                    fReturn = TRUE;
                    break;

                case IDC_COOKIE_DETAILS:

                    //
                    //  Fold out the bottom of the dialog
                    //

                    SetWindowPos(hwnd, HWND_TOP, 0, 0,
                        pcdi->cx, pcdi->cy,
                        SWP_NOMOVE | SWP_NOZORDER);

                    EnableWindow(GetDlgItem(hwnd, IDC_COOKIE_DETAILS), FALSE);

                    PostMessage( hwnd, WM_NEXTDLGCTL, 
                                 (WPARAM)GetDlgItem( hwnd, IDC_COOKIE_NAME), TRUE);

                    fReturn = TRUE;
                    break;

            }
        }

        break;

    }

    if(dwEndDlg)
    {
        EndDialog(hwnd, (dwEndDlg == COOKIE_DONT_ALLOW) ? ERROR_HTTP_COOKIE_DECLINED : ERROR_SUCCESS);
    }

    return fReturn;
}

INT_PTR
CALLBACK
InsertCDDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

{
    PERRORINFODLGTYPE pDlgInfo;
    DWORD dwDlgEnd = 0;
    HTTP_REQUEST_HANDLE_OBJECT* phro;
    CHAR szName[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    BOOL fCD;

    // Cache container info struct.
    BYTE buf[2048];
    DWORD cbCoI = 2048;
    LPINTERNET_CACHE_CONTAINER_INFO pCoI = (LPINTERNET_CACHE_CONTAINER_INFO) buf;

    LPSTR pszUrl;
    BOOL fReturn = FALSE;

    switch (msg)
    {
        // On dialog initialize.
        case WM_INITDIALOG:
        {
            INET_ASSERT(lparam);

            // Get the http request object.
            pDlgInfo = (PERRORINFODLGTYPE)lparam;
            (void)SetWindowLongPtr(hwnd, DWLP_USER, lparam);

            phro = (HTTP_REQUEST_HANDLE_OBJECT*) pDlgInfo->hInternetMapped;

            // Set the dialog window text with the container name.
            pszUrl = phro->GetURL();
            if (pszUrl && GetUrlCacheContainerInfo(pszUrl, pCoI, &cbCoI, 0))
                SetWindowText(GetDlgItem(hwnd,IDC_CD_NAME), pCoI->lpszVolumeTitle);

            fReturn = TRUE;
            break;
        }

        // User entered info.
        case WM_COMMAND:
        {
            pDlgInfo = (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);
            INET_ASSERT(pDlgInfo);

            switch (LOWORD(wparam))
            {
                case IDC_USE_CDROM:
                    dwDlgEnd = ERROR_INTERNET_FORCE_RETRY;

                    // Signal that dialog is no longer active.
                    fCD = InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) FALSE);
                    INET_ASSERT(fCD);
                    fReturn = TRUE;
                    break;

                case IDC_CONNECT_TO_INTERNET:

                    // Delete all containers with the same volume label.

                    // Get the http request object.
                    phro = (HTTP_REQUEST_HANDLE_OBJECT*) pDlgInfo->hInternetMapped;

                    // Set the dialog window text with the container name.
                    pszUrl = phro->GetURL();

                    // Get the container info for this url.
                    if (pszUrl && GetUrlCacheContainerInfo(pszUrl, pCoI, &cbCoI, 0))
                    {
                        // Found a volume label:
                        if (*pCoI->lpszVolumeLabel)
                            strcpy(szVolumeLabel, pCoI->lpszVolumeLabel);
                        else
                            *szVolumeLabel = '\0';

                        // Start an enumeration of containers.
                        DWORD dwOptions, dwModified;
                        dwOptions = dwModified = 0;
                        HANDLE hConFind = FindFirstUrlCacheContainer(&dwModified,
                            pCoI, &(cbCoI = 2048), dwOptions);
                        if (hConFind)
                        {
                            // If the volume label of the first container found
                            // match the volume label of the associated url then
                            // delete this container.
                            if ((*pCoI->lpszVolumeLabel == '\0')
                                || (!strcmp(szVolumeLabel, pCoI->lpszVolumeLabel)))
                            {
                                DeleteUrlCacheContainer(pCoI->lpszName, 0);
                            }
                            // Similarly, delete each container which
                            // is found to have a matching volume label.
                            while (FindNextUrlCacheContainer(hConFind,
                                   pCoI, &(cbCoI = 2048)))
                            {
                                if ((*pCoI->lpszVolumeLabel == '\0')
                                    || (!strcmp(szVolumeLabel, pCoI->lpszVolumeLabel)))
                                {
                                    DeleteUrlCacheContainer(pCoI->lpszName, 0);
                                }
                            }
                            FindCloseUrlCache(hConFind);
                        }
                    }
                    dwDlgEnd = ERROR_CANCELLED;

                    // Signal that dialog is no longer active.
                    fCD = InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) FALSE);
                    INET_ASSERT(fCD);
                    fReturn = TRUE;
                    break;
            }
        }

        break;
    }

    if (dwDlgEnd)
        EndDialog(hwnd, dwDlgEnd);

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\ierrui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ierrui.cxx

Abstract:

    Contains immplimentation of generic Error UI API.

    Contents:
        InternetErrorDlg
        InternetConfirmZoneCrossing
        (wErrorUIInvalidPassword)

Author:

    Arthur L Bierer (arthurbi) 04-Apr-1996

Revision History:

    04-Apr-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include <persist.h>
#include "ierrui.hxx"


//
// private prototypes
//



PRIVATE
DWORD
wErrorUIInvalidPassword(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID *lppvData
    );


//
// public functions
//

INTERNETAPI_(DWORD) InternetErrorDlg(IN HWND hWnd,
                 IN OUT HINTERNET hRequest,
                 IN DWORD dwError,
                 IN DWORD dwFlags,
                 IN OUT LPVOID *lppvData
                 )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a problem with a WinINet HttpSendRequest.
    Can optionally store the results of dialog in the HTTP handle.
    Data may be specified in the lppvData pointer, or optionally InternetErrorDlg
    will gather the information from the HTTP handle

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    hRequest -    An open HTTP request handle
                  where headers will be added if needed.

    dwError -     The Error code to which the appropriate UI will be shown for.

    dwFlags -     Can be any of all of the following Flags:

                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA - generates lppvData, and queries
                    internet handle for information.

                    FLAGS_ERROR_UI_FILTER_FOR_ERRORS - scans the returned headers,
                    and determines if there is a "hidden" error, such as an authentication
                    failure.

                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS - On successful return of the dialog,
                    this flag will causes the results to be stored in the handle.

                    FLAGS_ERROR_UI_SERIALIZE_DIALOGS - display only one auth dlg and
                    notify subsequent threads when the dialog has been dismissed.

    lppvData -    Contains a Pointer to a Pointer where a stucture is stored containing
                  error specific data, and Dialog results.


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Serveral Error codes defined in winerror.h or wininet.w

Comments:

    BUGBUG - need to look into multiple authentication scheme handling, and
    how it relates to the UI

--*/

{
    DEBUG_ENTER_API((DBG_HTTP,
                     Dword,
                     "InternetErrorDlg",
                     "%#x, %#x, %s (%d), %#x, %#x",
                     hWnd,
                     hRequest,
                     InternetMapError(dwError),
                     dwError,
                     dwFlags,
                     lppvData
                     ));

    DWORD dwStatusCode = HTTP_STATUS_OK;
    DWORD error = ERROR_SUCCESS;
    HINTERNET hMappedRequestHandle = NULL;
    HINTERNET_HANDLE_TYPE handleType;
    HTTP_REQUEST_HANDLE_OBJECT *lpRequest;

    LPVOID lpVoidData;

    //
    // Check Parameters
    //

    if ( !(dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI) &&
         !IsWindow(hWnd) )
    {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    if ( hRequest )
    {
        error = MapHandleToAddress(hRequest, (LPVOID *)&hMappedRequestHandle, FALSE);

        if ( error != ERROR_SUCCESS )
            goto quit;

        //
        //  We only support HttpRequestHandles for this form of UI.
        //


        error = RGetHandleType(hMappedRequestHandle, &handleType);

        if ( error != ERROR_SUCCESS || handleType != TypeHttpRequestHandle )
            goto quit;

        lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hMappedRequestHandle;

        //
        // See if we can detect an error if needed
        //

        if ( dwFlags & FLAGS_ERROR_UI_FILTER_FOR_ERRORS )
        {
            dwStatusCode = lpRequest->GetStatusCode();

            if ( dwStatusCode == HTTP_STATUS_DENIED || dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ )
                dwError = ERROR_INTERNET_INCORRECT_PASSWORD;

            if ( lpRequest->GetBlockingFilter())
                dwError = ERROR_INTERNET_NEED_UI;
        }
    }
    else
    {
        if( ERROR_INTERNET_NEED_UI                  == dwError ||
            ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED  == dwError ||
            ERROR_INTERNET_INSERT_CDROM             == dwError ||
            ERROR_INTERNET_INCORRECT_PASSWORD       == dwError )
        {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // If the Caller didn't pass us anything, then we create our own
    // structure. Lets NULL it, and then allocate it later
    //
    //

    if ( !lppvData )
    {
        lppvData = &lpVoidData;
        *lppvData = NULL;
    }

    if  (   dwFlags & FLAGS_ERROR_UI_FLAGS_GENERATE_DATA
       && !(dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS))
    {
        *lppvData = NULL;
    }

    //
    // Determine what Function to handle this based on what error where given
    //

    BOOL fRet;

    switch ( dwError )
    {
        case ERROR_INTERNET_NEED_UI:
            fRet = HttpFiltOnBlockingOps
                (lpRequest, hRequest, hWnd);
            error = fRet? ERROR_SUCCESS : GetLastError();
            break;

        case ERROR_INTERNET_INCORRECT_PASSWORD:
            error = wErrorUIInvalidPassword(hWnd,
                                    hMappedRequestHandle,
                                    dwError,
                                    dwFlags,
                                    lppvData);

            break;

        case ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION:
            // If we are in silent mode, we will have to
            // decline the cookie without throwing up a
            // dialog
            if((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_HTTP_COOKIE_DECLINED;
            }
            else
            {
                COOKIE_DLG_INFO info;

                memset(&info, 0, sizeof(info));
                info.dwOperation = COOKIE_OP_SET;
                info.pic = (INTERNET_COOKIE*)(*lppvData);

                if(info.pic->dwFlags & INTERNET_COOKIE_IS_SESSION)
                {
                    info.dwOperation |= COOKIE_OP_SESSION;
                }

                error = ConfirmCookie(hWnd,
                                      lpRequest,
                                      &info);

            }
            break;

        case ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX:
            // If we are in silent mode, we will have to
            // decline the cookie without throwing up a
            // dialog
            if((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_HTTP_COOKIE_DECLINED;
            }
            else
            {
                error = ConfirmCookie(hWnd,
                                      lpRequest,
                                      (COOKIE_DLG_INFO *)(*lppvData));
            }
            break;

        case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED:
            //
            // Call the function which gets the cert context from the
            // Fortezza CSP.

            error = FortezzaLogOn(hWnd);
            break;

        case ERROR_INTERNET_SEC_CERT_REVOKED:
            {
                static WCHAR szMsgBoxText[128]  = L"\0";
                static WCHAR szCaption[64]      = L"\0";
                if (!szCaption[0])
                {
                    LoadStringWrapW(GlobalDllHandle, IDS_CERT_REVOKED, szMsgBoxText, sizeof(szMsgBoxText));
                    LoadStringWrapW(GlobalDllHandle, IDS_SECURITY_CAPTION, szCaption, sizeof(szCaption));
                }
                MessageBoxWrapW(hWnd, szMsgBoxText, szCaption, MB_OK | MB_ICONWARNING);
                error = ERROR_CANCELLED;
            }
            break;

        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
        case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR:

            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnZoneCrossing )
                break;


            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION:
            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnPostRedirect )
                break;


            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_INTERNET_POST_IS_NON_SECURE:
        case ERROR_INTERNET_CHG_POST_IS_NON_SECURE:

            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnPost )
                break;

            //
            // If we're not warning always, ie only warning
            //  if the user actually changed some fields, then
            //  bail out, and don't warn.
            //

            if ( ! GlobalWarnAlways &&
                   dwError == ERROR_INTERNET_POST_IS_NON_SECURE )
                break;

            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
        case ERROR_INTERNET_SEC_CERT_CN_INVALID:
        case ERROR_INTERNET_MIXED_SECURITY:
        case ERROR_INTERNET_INVALID_CA:
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
        case ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT:
        case ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT:
        case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR:
        case ERROR_INTERNET_INSERT_CDROM:
        case ERROR_INTERNET_SEC_CERT_ERRORS:
        case ERROR_INTERNET_SEC_CERT_REV_FAILED:

l_launchdlg:
            // if silent flag is set, we can just pass
            // ERROR_CANCELLED back without throwing up
            // a dialog
            if ((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_CANCELLED;
            }
            else
            {
                ERRORINFODLGTYPE ErrorInfoDlgInfo;
                DLGPROC          pDlgProc;


                MapWininetErrorToDlgId(
                                       dwError,
                                       &ErrorInfoDlgInfo.dwDlgId,
                                       &ErrorInfoDlgInfo.dwDlgFlags,
                                       &pDlgProc
                                       );


                INET_ASSERT(pDlgProc);

                ErrorInfoDlgInfo.hInternetMapped =
                    hMappedRequestHandle;
                if (ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED == dwError)
                {
                    CERT_CONTEXT_ARRAY* pCertContextArray = 
                        ((HTTP_REQUEST_HANDLE_OBJECT *)hMappedRequestHandle)->GetCertContextArray();

                    if (pCertContextArray)
                    {
                        const DWORD c_dwArraySize = pCertContextArray->GetArraySize();

                        if (1 == c_dwArraySize || 0 == c_dwArraySize)
                        {
                            const BOOL fRestricted =
                                lpRequest->GetOpenFlags() & INTERNET_FLAG_RESTRICTED_ZONE;
                            const DWORD dwClientCertPromptPolicy =
                                ::GetClientCertPromptPolicy(lpRequest->GetURL(), fRestricted);
                            if (dwClientCertPromptPolicy == URLPOLICY_ALLOW)
                            {
                                // If 1, select index 0, otherwise -1 if none
                                pCertContextArray->SelectCertContext(c_dwArraySize ? 0 : -1);
                                error = ERROR_SUCCESS;
                                break;
                            }
                        }
                    }
                }
                error = LaunchDlg(
                          hWnd,
                          (LPVOID) &ErrorInfoDlgInfo,
                          ErrorInfoDlgInfo.dwDlgId,
                          pDlgProc
                          );


            }

            break;
        default:
            //
            // if we're filtering for errors, then its not an error
            // since we're intented to process all errors
            //

            if ( ! (dwFlags & FLAGS_ERROR_UI_FILTER_FOR_ERRORS) )
                error = ERROR_NOT_SUPPORTED;
            break;
    }

quit:

    if ( hMappedRequestHandle != NULL )
        DereferenceObject((LPVOID)hMappedRequestHandle);

    DEBUG_LEAVE_API(error);

    return error;
}


INTERNETAPI_(DWORD) InternetConfirmZoneCrossingA(
    IN HWND hWnd,
    IN LPSTR szUrlPrev,
    IN LPSTR szUrlNew,
    BOOL bPost
    )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a zone crossing ( going
    between HTTPS to HTTP or HTTPS to HTTP ) when one is detected.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    szUrlPrev -   Previous URL string.

    szUrlNew  -   New URL string that the User is about to go to.

    bPost     -   TRUE if a POST is being done, FALSE otherwise.

Return Value:

    DWORD
    Success - ERROR_SUCCESS
               ( user either confirmed OK to continue, or there was no
                 UI needed )

    Failure - ERROR_CANCELLED ( user canceled, we want to stop )
              ERROR_NOT_ENOUGH_MEMORY

Comments:

    none.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetConfirmZoneCrossingA",
                     "%#x, %q, %q, %d",
                     hWnd,
                     szUrlPrev,
                     szUrlNew,
                     bPost));

    DWORD error = ERROR_SUCCESS;
    INTERNET_SCHEME ustPrevScheme;
    INTERNET_SCHEME ustNewScheme;

    INET_ASSERT(szUrlNew);


    //
    // If the Previous one is NULL, then we could be starting out
    //  for the first time
    //

    if ( szUrlPrev == NULL )
        goto quit;


    error = CrackUrl(szUrlPrev,
             lstrlen(szUrlPrev),
             FALSE,
             &ustPrevScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             NULL,          //  Host Name
             NULL,          //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Length
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra
             NULL,          //  Extra Length
             NULL
             );

    if ( error != ERROR_SUCCESS )
    {
        error = ERROR_SUCCESS;
        ustPrevScheme = INTERNET_SCHEME_UNKNOWN;
    }


    error = CrackUrl(szUrlNew,
             lstrlen(szUrlNew),
             FALSE,
             &ustNewScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             NULL,          //  Host Name
             NULL,          //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Length
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra
             NULL,          //  Extra Length
             NULL
             );

    if ( error != ERROR_SUCCESS )
    {
        error = ERROR_SUCCESS;
        ustNewScheme = INTERNET_SCHEME_UNKNOWN;
    }

    //
    // First Eliminate the obvious.
    //

    if ( ustPrevScheme == ustNewScheme )
        goto quit;


    //
    // Next, if it wasn't HTTPS, and it is now
    //  we've caught one zone cross.
    //

    if ( ustPrevScheme != INTERNET_SCHEME_HTTPS &&
         ustNewScheme  == INTERNET_SCHEME_HTTPS   )
    {
        error = ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR;
    }


    //
    // Otherwise, if it was HTTPS, and it is now
    //  no longer HTTPS, we also flag it.
    //

    else if ((ustPrevScheme == INTERNET_SCHEME_HTTPS)
             && ((ustNewScheme != INTERNET_SCHEME_HTTPS)
                 && (ustNewScheme != INTERNET_SCHEME_JAVASCRIPT)
                 && (ustNewScheme != INTERNET_SCHEME_VBSCRIPT))) {
        error = ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR;
    }


    if ( error != ERROR_SUCCESS &&
         hWnd )
    {
        error = InternetErrorDlg(
                 hWnd,
                 NULL,  // hRequest
                 error,
                 0,
                 NULL   // non Data structure to pass.
                 );
    }

quit:
    DEBUG_LEAVE_API(error);
    return error;
}


//
// private functions
//


PRIVATE
DWORD
wErrorUIInvalidPassword(IN HWND hWnd,
                        IN HINTERNET hRequest,
                        IN DWORD dwError,
                        IN DWORD dwFlags,
                        IN OUT LPVOID *lppvData
                        )
/*++

Routine Description:

    Creates an Error Dialog asking the User for his Username and Password.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    hRequest -    An open HTTP request handle, that is MAPPED,
                  where headers will be added if needed.

    dwError -     The Error code to which the appropriate UI will be shown for.

    dwFlags -     Can be any of all of the following Flags:

                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA - generates lppvData, and queries
                    internet handle for information.

                    FLAGS_ERROR_UI_FILTER_FOR_ERRORS - scans the returned headers,
                    and determines if there is a "hidden" error, such as an authentication
                    failure.

                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS - On successful return of the dialog,
                    this flag will causes the results to be stored in the handle.

                    FLAGS_ERROR_UI_FLAGS_NO_UI - Don't show any User interface. Silently,
                    accepts the Username, and Password that is passed in.

    lppvData -    Contains a Pointer to a Pointer where a stucture is stored containing
                  error specific data, and Dialog results.


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Serveral Error codes defined in winerror.h or wininet.w

Comments:

    BUGBUG - need to look into multiple authentication scheme handling, and
    how it relates to the UI
    BUGBUG - need to handle case where one thread calls into this function,
    and a second threads also calls in to put up UI on the same User-Pass Info
    as the first.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "wErrorUIInvalidPassword",
                "%#x, %#x, %d (%s), %#x, %#x",
                hWnd,
                hRequest,
                dwError,
                InternetMapError(dwError),
                dwFlags,
                lppvData
                ));

    DWORD error = ERROR_SUCCESS;
    BOOL fMustLock = FALSE;
    InvalidPassType ipt;
    ipt.lpszPassword = NULL;
    
    // Get the request handle and connect handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequest;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect =
        (INTERNET_CONNECT_HANDLE_OBJECT *) pRequest->GetParent();

    // Validate parameters.
    if (!pConnect || (!(dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI) && !IsWindow(hWnd)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // Get the authentication context.
    AUTHCTX *pAuthCtx;
    pAuthCtx = pRequest->GetAuthCtx();
    if (!pAuthCtx)
    {
        pAuthCtx = pRequest->GetTunnelAuthCtx();
        if (!pAuthCtx)
        {
            error = ERROR_SUCCESS;
            goto quit;
        }
    }

    PWC *pwc;
    pwc = pAuthCtx->_pPWC;
    // INET_ASSERT (pwc && pwc->nLockCount); w/ Passport, this is no longer true

    //
    //  Initialize InvalidPassType struct
    //

    if (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_PASSPORT)
    {
        char szUserBuf[MAX_FIELD_LENGTH], szPassBuf[MAX_FIELD_LENGTH];
        ipt.ulMaxField = MAX_FIELD_LENGTH - 1;
        ipt.lpszPassword = szUserBuf;
        ipt.lpszUsername = szPassBuf;
        
        if (pAuthCtx->_pszFQDN)
        {
            ipt.lpszHost = (LPSTR)pAuthCtx->_pszFQDN;
        }
        else
        {
            ipt.lpszHost = pAuthCtx->_pPWC->lpszHost;
        }
        
        ipt.fIsProxy = pAuthCtx->_fIsProxy;
    
    
        //
        // Transfer password cache entry fields to UI structure.
        //
        AuthLock();
        LPSTR lpszPass = pwc->GetPass();

        if (pwc->lpszUser)
            lstrcpyn (ipt.lpszUsername, pwc->lpszUser, MAX_FIELD_LENGTH);
        else
            ipt.lpszUsername[0] = 0;
        if (lpszPass)
            lstrcpyn (ipt.lpszPassword, lpszPass, MAX_FIELD_LENGTH);
        else
            ipt.lpszPassword[0] = 0;
        ipt.lpszRealm = pwc->lpszRealm;

        if (lpszPass)
        {
            memset(lpszPass, 0, strlen(lpszPass));
            FREE_MEMORY(lpszPass);
        }
        
        AuthUnlock();
    }

    if (dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS)
    {
        // Queue this thread if we're already in a dialog.
        INET_ASSERT (lppvData);
        INTERNET_AUTH_NOTIFY_DATA *pNotify =
            (INTERNET_AUTH_NOTIFY_DATA *) *lppvData;
        if (IsBadReadPtr (pNotify, sizeof(*pNotify)))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        if (AuthInDialog (pAuthCtx, pNotify, &fMustLock))
        {
            // The auth context maintains a context handle
            // to correctly process the 'stale' subheader.
            // Setting _nRetries to 0 will cause no context handle to
            // be passed into the package and restart auth for this context
            // from scratch. Therefore, no attempt will be made to parse the
            // stale header which is the correct behavior.
            if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
            {
                ((DIGEST_CTX*)pAuthCtx)->_nRetries = 0;
            }
            error = ERROR_INTERNET_DIALOG_PENDING;
            goto quit;
        }
    }

    if ((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
    {
        // No UI - retrieve any persisted credentials.
        error = InetGetCachedCredentials(pwc->lpszHost, pwc->lpszRealm,
            ipt.lpszUsername, ipt.lpszPassword);
    }
    else // Launch the appropriate dialog.
    {
        if ((pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI))
        {
            // If auth package handles its own UI, let it.
            error = LaunchAuthPlugInDlg
                (pRequest, pAuthCtx, hWnd, dwError, dwFlags, &ipt);
        }
        else
        {
            if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC
                || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
            {
                ipt.eAuthType = REALM_AUTH;
            }
            else if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
            {
                ipt.eAuthType = PASSPORT_AUTH;
            }
            else
            {
                INET_ASSERT(pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NTLM 
                    || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS
                    || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NEGOTIATE);
                ipt.eAuthType = NTLM_AUTH;
            }

            CREDINFODLGTYPE CredInfoDlgInfo;
            CredInfoDlgInfo.pipt = &ipt;
            CredInfoDlgInfo.pRequest = pRequest;
            CredInfoDlgInfo.pAuthCtx = pAuthCtx;

            if (ipt.eAuthType == REALM_AUTH)
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, IDD_REALM_AUTH, NULL);
            else if (ipt.eAuthType == PASSPORT_AUTH)
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, 0,              NULL);
            else
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, IDD_NTLM_AUTH, NULL);
        }
    }
        
    // If dialog was OK, return as follows.
    if (error == ERROR_SUCCESS)
    {
        AuthLock();

        if (ipt.eAuthType == NTLM_AUTH)
        {
            pwc->SetUser (ipt.lpszUsername);
            pwc->SetPass (ipt.lpszPassword, GlobalPlatformWhistler ? TRUE: FALSE);
        }
        else if (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_PASSPORT)
        {
            // Update user/pass which would overwrite PWC.
            // Update PWC so related requests will be retried.
            
            //if (ipt.lpszUsername[0])
            {
                pRequest->SetUserOrPass (ipt.lpszUsername, IS_USER, pAuthCtx->_fIsProxy);
                pwc->SetUser (ipt.lpszUsername);
            }
            
            //if (ipt.lpszPassword[0])
            {
                pRequest->SetUserOrPass (ipt.lpszPassword, IS_PASS, pAuthCtx->_fIsProxy);
                pwc->SetPass (ipt.lpszPassword);
            }
    
        }
        AuthUnlock();

        // Retry this request.
        error = ERROR_INTERNET_FORCE_RETRY;
    }

    // Notify any waiting threads.

    if (dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS)
    {
        if (fMustLock)
        {
            // fMustLock will have been set by AuthInDialog if this is
            // a reentrant call to InternetErrorDlg by AuthNotify. If this
            // is the case, acquire the lock and do not call AuthNotify.
            // so that when control is returned to AuthNotify the lock will
            // already be correctly acquired.
            AuthLock();
        }
        else
        {
            AuthNotify (pwc, error);
        }
    }

quit:

    if (ipt.lpszPassword)
    {
        memset(ipt.lpszPassword, 0, strlen(ipt.lpszPassword));
    }

    //
    // IE30 compat: must return ERROR_SUCCESS to avoid bogus dialog.
    //
    if ( error == ERROR_CANCELLED )
        error = ERROR_SUCCESS;

    DEBUG_LEAVE(error);
    return error;
}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

DWORD
ConfirmCookie(
            HWND hwnd,
            HTTP_REQUEST_HANDLE_OBJECT *lpRequest,
            COOKIE_DLG_INFO *pcdi
            )
{
    DWORD dw;
    BYTE *buf = NULL;

    //
    //  Get the server name
    //
    WCHAR wszServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    if (lpRequest)
    {
        DEBUG_ONLY(lpRequest->GetHostName(&dw));
        INET_ASSERT(dw <= ARRAYSIZE(wszServer));
        CHAR szServerTmp[INTERNET_MAX_HOST_NAME_LENGTH + 1];
        lpRequest->CopyHostName(szServerTmp);
        if(SHAnsiToUnicode(szServerTmp, wszServer, ARRAYSIZE(wszServer))) 
            pcdi->pszServer = wszServer;
    }
    else if(pcdi->pic)
    {
        if(SHAnsiToUnicode(pcdi->pic->pszDomain, wszServer, ARRAYSIZE(wszServer))) 
            pcdi->pszServer = wszServer;
    }

    /* Consult per-site decisions one more time.
       By the time the prompt is being displayed, another instance
       of the cookie-prompt MAY have already written a decision. */ 
    unsigned long dwPerSiteDecision = COOKIE_STATE_UNKNOWN;

    if (InternetGetPerSiteCookieDecisionW(pcdi->pszServer, &dwPerSiteDecision) &&
        dwPerSiteDecision!=COOKIE_STATE_UNKNOWN)
    {
        if (dwPerSiteDecision==COOKIE_STATE_ACCEPT) 
            return ERROR_SUCCESS;
        else
            return ERROR_HTTP_COOKIE_DECLINED;
    }

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);

    // Can typecast as long as "CookieDialogProc" only returns true or false
    dw = (BOOL ) DialogBoxParamWrapW(GetModuleHandle("WININET.DLL"),
                                    MAKEINTRESOURCEW(IDD_CONFIRM_COOKIE),
                                    hwnd,
                                    (DLGPROC) CookieDialogProc,
                                    (LPARAM) pcdi);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return dw;
}


INTERNETAPI_(DWORD) InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    BOOL bPost
    )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a zone crossing ( going
    between HTTPS to HTTP or HTTPS to HTTP ) when one is detected.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    szUrlPrev -   Previous URL string.

    szUrlNew  -   New URL string that the User is about to go to.

    bPost     -   TRUE if a POST is being done, FALSE otherwise.

Return Value:

    DWORD
    Success - ERROR_SUCCESS
               ( user either confirmed OK to continue, or there was no
                 UI needed )

    Failure - ERROR_CANCELLED ( user canceled, we want to stop )
              ERROR_NOT_ENOUGH_MEMORY

Comments:

    none.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetConfirmZoneCrossingW",
                     "%wq, %wq, %d",
                     szUrlPrev,
                     szUrlNew,
                     bPost));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpNew, mpPrev;

    if (!(szUrlPrev && szUrlNew))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(szUrlPrev,0,mpPrev);
    ALLOC_MB(szUrlNew,0,mpNew);
    if (!(mpPrev.psStr && mpNew.psStr))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(szUrlPrev,mpPrev);
    UNICODE_TO_ANSI(szUrlNew,mpNew);
    dwErr = InternetConfirmZoneCrossingA(hWnd, mpPrev.psStr, mpNew.psStr, bPost);

cleanup:
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\persist.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created

--*/

#include <wininetp.h>
#include <persist.h>

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals

// PWL related variables.
static HMODULE MhmodWNET                                     = NULL;
static PFWNETGETCACHEDPASSWORD pfWNetGetCachedPassword       = NULL;
static PFWNETCACHEPASSWORD pfWNetCachePassword               = NULL;
static PFWNETREMOVECACHEDPASSWORD pfWNetRemoveCachedPassword = NULL;

// Pstore related variables.
static PST_PROVIDERID s_provID                       = GUID_NULL;
static WCHAR c_szWininetCacheCredentials[]           = L"WininetCacheCredentials";
static PFNPSTORECREATEINSTANCE pPStoreCreateInstance = NULL;


// Webcheck is currently using this GUID for pstore:
// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
// static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

// Wininet uses this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType = 
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.

// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred);
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey);

STDAPI CreatePStore (IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore  *pIPStore);


/*--------------------------- Top Level APIs ---------------------------------*/


BOOL ReadLSARegistryDword( CHAR* lpszValueName, DWORD* pdwValue)
{
    BOOL bRetVal = FALSE;
    HKEY key;
    DWORD dwType;

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Control\\Lsa",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        
        DWORD dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                lpszValueName,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwSize ) == ERROR_SUCCESS )
        {
            bRetVal = TRUE;
        }


        RegCloseKey(key);

    }

    return bRetVal;

}

/*-----------------------------------------------------------------------------
    InetInitCredentialPersist
  ---------------------------------------------------------------------------*/
DWORD InetInitCredentialPersist()
{
    HRESULT hr;
    IPStore *pIPStore = NULL;
    DWORD dwDisable, dwAvail, dwLSADisable;
    HINSTANCE hInstPStoreC = 0;
    BOOL fPersistDisabled = FALSE;

    AuthLock();
    
    // First check to see if persistence is disabled via registry.
    if ((InternetReadRegistryDword(DISABLE_PASSWORD_CACHE_VALUE, &dwDisable) == ERROR_SUCCESS)
        && (dwDisable == CRED_PERSIST_AVAIL))
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }

    // check to see if credmgr registry has disabled it
    if ( ReadLSARegistryDword( "DisableDomainCreds", & dwLSADisable ) && dwLSADisable )
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    
    // We use PWL for Win95; this should be available.
    if (IsPlatformWin95())
    {
        dwAvail = CRED_PERSIST_AVAIL;
        goto quit;
    }

    // If is WinNt, check if PStore is installed. 
    hInstPStoreC = LoadLibrary(PSTORE_MODULE);
    if (!hInstPStoreC)
    {
        dwAvail = CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    else
    {
        // Get CreatePStoreInstance function pointer.
        pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE) 
            GetProcAddress(hInstPStoreC, "PStoreCreateInstance");
        
        if (!pPStoreCreateInstance)
        {
            dwAvail = CRED_PERSIST_NOT_AVAIL;
            goto quit;
        }
    }
    
    // Create an IPStore.
    hr = CreatePStore(&pIPStore);
        
    // Succeeded in creating an IPStore.
    if (SUCCEEDED(hr) && pIPStore)
    {
        ReleasePStore(pIPStore);
        dwAvail = CRED_PERSIST_AVAIL;
    }
    else
    {
        // Failed to create an IPStore.
        dwAvail = CRED_PERSIST_NOT_AVAIL;
    }

quit:
    g_dwCredPersistAvail = dwAvail;

    AuthUnlock();

    return g_dwCredPersistAvail;
}


/*-----------------------------------------------------------------------------
  InetSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetSetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealm, 
                                 LPSTR szUser, 
                                 LPSTR szPass)
{
    DWORD cbKey, cbCred, dwError = ERROR_INTERNET_INTERNAL_ERROR;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH], 
         szCred[MAX_AUTH_FIELD_LENGTH];

    INET_ASSERT(szHost && *szHost && szRealm 
        && szUser && *szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    // Form key and credential strings.
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;
#ifndef UNIX
    cbCred = wsprintf(szCred,"%s:%s", szUser, szPass) + 1;
#else
    /* wsprintf on UNIX puts "(null)" if szPass is null. */
    cbCred = szPass ? (wsprintf(szCred,"%s:%s", szUser, szPass) + 1) :
                      (wsprintf(szCred,"%s:", szUser) + 1);
#endif /* UNIX */
        
    // Store credentials.
    if (IsPlatformWin95())
    {
        // Store credentials using PWL.
        dwError = PWLSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }
    else
    {
        // Store credentials using PStore.
        dwError = PStoreSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }

quit:

    return dwError;
}


/*-----------------------------------------------------------------------------
  InetGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetGetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealm, 
                                 LPSTR szUser, 
                                 LPSTR szPass)

{
    DWORD cbKey, cbCred, nUser, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH],
         *ptr;

    INET_ASSERT(szHost && *szHost && szRealm && szUser && szPass);

    // Check if credential persistence is available.
    if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        InetInitCredentialPersist();
    
    if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    // Key string in form of host/[realm or domain].
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;
    cbCred = MAX_AUTH_FIELD_LENGTH;

    if (IsPlatformWin95())
    {
        // Store credentials using PWL.
        if ((dwError = PWLGetCachedCredentials(szKey, cbKey, 
            szCred, &cbCred)) != WN_SUCCESS)
            goto quit;
    }
    else
    {
        // Store credentials using PStore.
        if ((dwError = PStoreGetCachedCredentials(szKey, cbKey, 
            szCred, &cbCred)) != ERROR_SUCCESS)
            goto quit;
    }

    // Should have retrieved credentials in form of username:password.
    ptr = strchr(szCred, ':');

    // Should never happen since username & password are required.
    if (!ptr || (ptr == szCred))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    // Copy username & null terminate.
    nUser = (DWORD)(ptr - szCred);
    memcpy(szUser, szCred, nUser);
    szUser[nUser] = '\0';

    // Copy password with null terminator.
    memcpy(szPass, ptr+1, cbCred - nUser);

quit:
    
    return dwError;
}


/*-----------------------------------------------------------------------------
  InetRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetRemoveCachedCredentials (LPSTR szHost, LPSTR szRealm)
{
    DWORD cbKey, dwError;
    CHAR szKey[MAX_AUTH_FIELD_LENGTH];

    INET_ASSERT(szHost && *szHost && szRealm);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    // Form key string.
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;

    if (IsPlatformWin95())
    {
        // Remove credentials from PWL.
        dwError = PWLRemoveCachedCredentials(szKey, cbKey);
    }
    else
    {
        // Remove credentials from PStore.
        dwError =  PStoreRemoveCachedCredentials(szKey, cbKey);
    }

quit:
    return dwError;
}


/*--------------------------- PWL Functions ---------------------------------*/



/*-----------------------------------------------------------------------------
  PWLSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                              LPSTR szCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;
    
    // Store credentials.  
    dwError =  (*pfWNetCachePassword)(szKey, (WORD) cbKey, szCred, (WORD) cbCred, PCE_WWW_BASIC, 0); 

    return dwError;
}




/*-----------------------------------------------------------------------------
  PWLGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, 
                                LPSTR szCred, LPDWORD pcbCred)
{    
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    // Retrieve credentials.
    dwError = (*pfWNetGetCachedPassword) (szKey, (WORD) cbKey, szCred, 
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);
    
    return dwError;
}



/*-----------------------------------------------------------------------------
  PWLRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    dwError = (*pfWNetRemoveCachedPassword) (szKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


/*-----------------------------------------------------------------------------
  LoadWNet
  ---------------------------------------------------------------------------*/
BOOL LoadWNet(VOID)
{
    BOOL fReturn;
    
    AuthLock();

    // MPR.DLL already loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);
    
    // Fail if not loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(pfWNetGetCachedPassword 
          && pfWNetCachePassword
          && pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    AuthUnlock();
    
    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



/*-----------------------------------------------------------------------------
  PStoreSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                                 LPSTR szCred, DWORD cbCred, 
                                 BOOL fRemove)
{
    INET_ASSERT(pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;
    
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];
    
    IPStore *       pStore = NULL;
    
    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = c_szWininetCacheCredentials;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    INET_ASSERT(pStore != NULL);
               
    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType, 
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;
            
    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);
    
    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (szCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               wszKey,
                               cbCred,
                               (LPBYTE) szCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                wszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);
    
    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}                                                                       


/*-----------------------------------------------------------------------------
  PStoreGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                                 LPSTR szCred, LPDWORD pcbCred)
{
    INET_ASSERT(pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;
    
    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];

    
    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    INET_ASSERT(pStore != NULL);

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          wszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(szCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    
    return dwError;
}

/*-----------------------------------------------------------------------------
  PStoreRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(szKey, cbKey, NULL, 0, TRUE);
}

// PStore utility functions

/*-----------------------------------------------------------------------------
  CreatePStore
  ---------------------------------------------------------------------------*/
STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;
    DWORD dwError;

    
    hr = pPStoreCreateInstance (ppIPStore,
                                  IsEqualGUID(s_provID, GUID_NULL) ? NULL : &s_provID,
                                  NULL,
                                  0);

  if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}


/*-----------------------------------------------------------------------------
  ReleasePStore
  ---------------------------------------------------------------------------*/
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\resolv.h ===
/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  RESOLV.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/0/s.resolv.h
 *  @(#)resolv.h    5.3
 *
 *  Last delta created  14:05:35 3/4/91
 *  This file extracted 11:19:25 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1987, 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)resolv.h    5.10 (Berkeley) 6/1/90
 */

#ifndef _RESOLV_INCLUDED
#define _RESOLV_INCLUDED

/*
 * Global defines and variables for resolver stub.
 */
#define MAXNS       3       /* max # name servers we'll track */
#define MAXDFLSRCH  3       /* # default domain levels to try */
#define MAXDNSRCH   6       /* max # domains in search path */
#define LOCALDOMAINPARTS 2      /* min levels in name that is "local" */

#define RES_TIMEOUT 4       /* min. seconds between retries */

struct state {
    int  retrans;          /* retransmition time interval */
    int  retry;            /* number of times to retransmit */
    long options;          /* option flags - see below. */
    int  nscount;          /* number of name servers */
    struct   sockaddr_in nsaddr_list[MAXNS];  /* address of name server */
#define nsaddr   nsaddr_list[0]        /* for backward compatibility */
    unsigned short  id;        /* current packet id */
    char     defdname[MAXDNAME];       /* default domain */
    char    *dnsrch[MAXDNSRCH+1];      /* components of domain to search */
};

/*
 * Resolver options
 */
#define RES_INIT    0x0001      /* address initialized */
#define RES_DEBUG   0x0002      /* print debug messages */
#define RES_AAONLY  0x0004      /* authoritative answers only */
#define RES_USEVC   0x0008      /* use virtual circuit */
#define RES_PRIMARY 0x0010      /* query primary server only */
#define RES_IGNTC   0x0020      /* ignore trucation errors */
#define RES_RECURSE 0x0040      /* recursion desired */
#define RES_DEFNAMES    0x0080      /* use default domain name */
#define RES_STAYOPEN    0x0100      /* Keep TCP socket open */
#define RES_DNSRCH  0x0200      /* search up local domain tree */
#define RES_MODE_HOST_ONLY 0x0400          /* use the host file only */
#define RES_MODE_DNS_ONLY  0x0800          /* use the DNS only */
#define RES_MODE_HOST_DNS  0x1000          /* use the host file then the DNS */
#define RES_MODE_DNS_HOST  0x2000          /* use the DNS then the host file */

#define RES_DEFAULT (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)

extern struct state _res;
extern char *p_cdname(), *p_rr(), *p_type(), *p_class(), *p_time();


//
// Resolver function prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

int
dn_comp(
    IN      unsigned char  *exp_dn,
    OUT     unsigned char  *comp_dn,
    IN      int             length,
    IN      unsigned char **dnptrs,     OPTIONAL
    IN OUT  unsigned char **lastdnptr   OPTIONAL
    );

int
res_init(
    void
    );

int
res_send(
    IN  char *buf,
    IN  int buflen,
    OUT char *answer,
    IN  int anslen
    );

int
res_query(
    IN  char          *name,      /* domain name */
    IN  int            Class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer buffer */
    );

int
res_search(
    IN  char           *name,     /* domain name */
    IN  int            Class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer */
    );

int
res_mkquery(
    IN  int          op,             // opcode of query
    IN  char        *dname,          // domain name
    IN  int          Class,                  // class of query
    IN  int          type,               // type of query
    IN  char        *data,    OPTIONAL       // resource record data
    IN  int          datalen, OPTIONAL       // length of data
    IN  struct rrec *newrr,   OPTIONAL       // new rr for modify or append
    OUT char        *buf,            // buffer to put query
    IN  int          buflen                  // size of buffer
    );

#endif    // _RESOLV_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inc\private\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *  @(#)nameser.h   5.3
 *
 *  Last delta created  14:06:04 3/4/91
 *  This file extracted 11:19:28 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)nameser.h   5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ    512     /* maximum packet size */
#define MAXDNAME    256     /* maximum domain name */
#define MAXCDNAME   255     /* maximum compressed domain name */
#define MAXLABEL    63      /* maximum length of domain label */
    /* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ    4
    /* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ   10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT 53

/*
 * Currently defined opcodes
 */
#define QUERY       0x0     /* standard query */
#define IQUERY      0x1     /* inverse query */
#define STATUS      0x2     /* nameserver status query */
/*#define xxx       0x3     /* 0x3 reserved */
    /* non standard */
#define UPDATEA     0x9     /* add resource record */
#define UPDATED     0xa     /* delete a specific resource record */
#define UPDATEDA    0xb     /* delete all nemed resource record */
#define UPDATEM     0xc     /* modify a specific resource record */
#define UPDATEMA    0xd     /* modify all named resource record */

#define ZONEINIT    0xe     /* initial zone transfer */
#define ZONEREF     0xf     /* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR     0       /* no error */
#endif
#define FORMERR     1       /* format error */
#define SERVFAIL    2       /* server failure */
#define NXDOMAIN    3       /* non existent domain */
#define NOTIMP      4       /* not implemented */
#define REFUSED     5       /* query refused */
    /* non standard */
#define NOCHANGE    0xf     /* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A     1       /* host address */
#define T_NS        2       /* authoritative server */
#define T_MD        3       /* mail destination */
#define T_MF        4       /* mail forwarder */
#define T_CNAME     5       /* connonical name */
#define T_SOA       6       /* start of authority zone */
#define T_MB        7       /* mailbox domain name */
#define T_MG        8       /* mail group member */
#define T_MR        9       /* mail rename name */
#define T_NULL      10      /* null resource record */
#define T_WKS       11      /* well known service */
#define T_PTR       12      /* domain name pointer */
#define T_HINFO     13      /* host information */
#define T_MINFO     14      /* mailbox information */
#define T_MX        15      /* mail routing information */
#define T_TXT       16      /* text strings */
#define T_AFSDB     18      /* AFS database servers */
    /* non standard */
#define T_UINFO     100     /* user (finger) information */
#define T_UID       101     /* user ID */
#define T_GID       102     /* group ID */
#define T_UNSPEC    103     /* Unspecified format (binary data) */
    /* Query type values which do not appear in resource records */
#define T_AXFR      252     /* transfer zone of authority */
#define T_MAILB     253     /* transfer mailbox records */
#define T_MAILA     254     /* transfer mail agent records */
#define T_ANY       255     /* wildcard match */

/*
 * Values for class field
 */

#define C_IN        1       /* the arpa internet */
#define C_CHAOS     3       /* for chaos net at MIT */
#define C_HS        4       /* for Hesiod name server at MIT */
    /* Query class values which do not appear in resource records */
#define C_ANY       255     /* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax) */
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER  LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(ux10) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#ifndef BYTE_ORDER      /* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_AMD64_) || defined(IA64)
#define BYTE_ORDER  LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
    /* you must determine what the correct bit order is for your compiler */
    UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
    unsigned short  id;     /* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
            /* fields in third byte */
    unsigned char   qr:1;       /* response flag */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   rd:1;       /* recursion desired */
            /* fields in fourth byte */
    unsigned char   ra:1;       /* recursion available */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   rcode:4;    /* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
            /* fields in third byte */
    unsigned char   rd:1;       /* recursion desired */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   qr:1;       /* response flag */
            /* fields in fourth byte */
    unsigned char   rcode:4;    /* response code */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   ra:1;       /* recursion available */
#endif
            /* remaining bytes */
    unsigned short  qdcount;    /* number of question entries */
    unsigned short  ancount;    /* number of answer entries */
    unsigned short  nscount;    /* number of authority entries */
    unsigned short  arcount;    /* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK  0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
    short           r_zone;         /* zone number */
    short           r_class;        /* class number */
    short           r_type;         /* type number */
    unsigned long   r_ttl;          /* time to live */
    int         r_size;         /* size of data area */
    char           *r_data;             /* pointer to data */
};

extern  unsigned short  _getshort(char *);
extern  unsigned long   _getlong(char *);

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
    (s) = *(cp)++ << 8; \
    (s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
    (l) = *(cp)++ << 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
    *(cp)++ = (s) >> 8; \
    *(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
    (cp)[3] = l; \
    (cp)[2] = (l >>= 8); \
    (cp)[1] = (l >>= 8); \
    (cp)[0] = l >> 8; \
    (cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetui.rc
//
#define IDS_SECERT_SUBJECT              1
#define ISNO                            2
#define IDS_SECERT_ISSUER               2
#define IDS_SECERT_EFFECTIVE            3
#define IDCANCEL2                       3
#define IDS_SECERT_EXPIRATION           4
#define IDCANCEL3                       4
#define IDS_SECERT_PROTOCOL             5
#define IDS_SECERT_SIGALG               6
#define IDS_SECERT_ENCRALG              7
#define IDS_SECERT_ENCRSTRENGTH         8
#define IDS_LW95_ENTERAUTHINFO          9
#define IDS_SECERT_CERTINFO             10
#define IDS_SECERT_STRENGTH_HIGH        11
#define IDS_SECERT_STRENGTH_MEDIUM      12
#define IDS_SECERT_STRENGTH_LOW         13
#define IDS_CERT_SUBJECT                14
#define IDS_CERT_ISSUER                 15
#define IDS_CERT_EFFECTIVE_DATE         16
#define IDS_CERT_EXPIRATION_DATE        17
#define IDS_CERT_PROTOCOL               18
#define IDS_CERT_SIG_ALG                19
#define IDS_CERT_ENCRYPT_ALG            20
#define IDS_CERT_PRIV_STRENTH           21
#define IDS_CERT_USAGE                  21
#define IDS_COMMENT_EXPIRES             22
#define IDS_COMMENT_NOT_VALID           23
#define IDS_COMMENT_BAD_CN              24
#define IDS_COMMENT_BAD_CA              25
#define IDS_CERT_COMMENT                26
#define IDS_COMMENT_BAD_SIGNATURE       27
#define IDS_FTP_ROOT                    28
#define IDS_FTP_DIR                     29
#define IDS_FTP_UPLEVEL                 30
#define IDS_GOPHER_ROOT                 31
#define IDS_GOPHER_DIR                  32
#define IDS_GOPHER_INDEX                33
#define IDS_GOPHER_CSO                  34
#define IDS_TAG_DIRECTORY               35
#define IDS_TAG_SEARCH                  36
#define IDS_CACHE_DEFAULT_SUBDIR        37
#define IDS_COOKIES_DEFAULT_SUBDIR      38
#define IDS_HISTORY_DEFAULT_SUBDIR      39
#define IDS_COMMENT_REVOKED             40
#define IDS_CERT_FINGERPRINT            41
#define IDD_CERTPICKER                  101
#define IDD_INVALID_CERT                102
#define IDD_INVALID_CA                  102
#define IDD_VIEW_CERT                   103
#define IDD_CONFIRM_COOKIE              104
#define IDI_COOKIE_ICON                 105
#define IDD_FAILED_DOWNLOAD             106
#define IDD_SCRIPT_ERROR                107
#define IDD_AUTODIAL_SELECT             108
#define IDD_CONNECT_TO                  109
#define IDD_GOONLINE                    110
#define IDC_GOONLINE_TOPMESSAGE         111
#define IDS_GOONLINE_REFRESH_CAPTION    112
#define IDS_GOONLINE_REFRESH_TOPMESSAGE 113
#define IDI_DIAL                        114
#define IDD_PROGRESS                    115
#define IDI_SECURITY1                   116
#define IDD_HTTP_POST_REDIRECT          117
#define IDI_SECURITY2                   118
#define IDI_SECURITY3                   119
#define IDC_LINKFROMDLG                 120
#define IDD_CERT_EXPIRED                121
#define IDB_DIAL                        122
#define IDD_AUTHENTICATION              124
#define IDD_NTLM_AUTH                   124
#define IDD_SEC_CERT_ERRORS             125
#define IDB_CHECK                       126
#define IDD_REALM_AUTH                  126
#define IDB_X                           127
#define IDC_CERT_TRUST_TEXT             128
#define IDI_SECURITY4                   128
#define IDC_CERT_DATE_TEXT              129
#define IDC_CERT_NAME_TEXT              130
#define IDC_CERT_TRUST_ICON             131
#define IDC_CERT_DATE_ICON              132
#define IDC_CERT_NAME_ICON              133
#define IDS_CERT_TRUST                  134
#define IDS_CERT_DATE                   135
#define IDS_CERT_NAME                   136
#define IDI_WARN                        137
#define IDI_SUCCESS                     138
#define IDS_SECURITY_CAPTION            139
#define IDS_CERT_REVOKED                140
#define IDD_REVOCATION_PROBLEM          141
#define IDI_OFFLINE                     142
#define IDI_CONNECT                     143
#define IDS_COOKIE_SENDING              147
#define IDS_COOKIE_RECEIVING            148
#define IDS_COOKIE_SENDING_DOMAIN       149
#define IDS_COOKIE_RECEIVING_DOMAIN     150
#define IDI_PRIVACY                     151
#define IDI_PRIVACY_XP                  152
#define IDC_PRIVACY_ICON                153
#define IDC_DONT_WANT_WARNING           1001
#define IDC_CERTPICKLIST                1002
#define IDC_FIELDLIST                   1005
#define IDC_CERT_SUBJECT                1006
#define IDC_CERT_ISSUER                 1007
#define IDC_CERT_EXPIRES                1008
#define IDC_CERT_STATUS                 1009
#define IDC_DELETE_CERT                 1010
#define IDC_EDIT1                       1010
#define IDC_COOKIE_DATA                 1010
#define IDC_USER_NAME                   1010
#define IDC_DOMAIN_FIELD                1010
#define IDC_DETAILSLIST                 1011
#define IDC_COOKIE_DETAILS              1011
#define IDC_EDIT2                       1012
#define IDC_COOKIE_HELP                 1012
#define IDC_DETAILS_LIST                1012
#define IDC_COOKIE_ALLOW_ALL            1013
#define IDC_COOKIE_NAME                 1014
#define IDC_COOKIE_DOMAIN               1016
#define IDC_COOKIE_PATH                 1017
#define IDC_COOKIE_EXPIRES              1018
#define IDC_COOKIE_SECURE               1019
#define IDC_COOKIE_SERVER               1021
#define IDC_COOKIE_ICON                 1022
#define IDC_COOKIE_INFO                 1023
#define IDC_SAVE_PASSWORD               1024
#define IDC_CONNECT_TO                  1025
#define IDC_CONN_TXT                    1025
#define ID_CONNECT                      1026
#define IDC_URL                         1027
#define ID_STAYOFFLINE                  1028
#define IDC_UNATTENDED                  1029
#define IDC_PROGRESS                    1030
#define IDC_STATUS                      1031
#define IDC_ZONEALERTTEXT               1032
#define IDC_BUTTON_EXPORT               1034
#define IDC_BUTTON_IMPORT               1035
#define IDC_AUTOCONNECT                 1036
#define IDC_BMP                         1039
#define IDC_AVI                         1040
#define IDC_SETTINGS                    1041
#define IDC_PROXY_OR_SERVER             1041
#define IDC_SERVER_OR_PROXY             1041
#define IDC_SITE_OR_FIREWALL            1042
#define IDC_DOMAIN_OR_REALM             1043
#define IDC_DOMAIN                      1043
#define IDC_DOMAIN_TAG                  1043
#define IDC_REALM_FIELD                 1044
#define IDC_REALM                       1045
#define IDC_REALM_TAG                   1045
#define IDC_USERNAME_TAG                1046
#define IDC_PASSWORD_TAG                1047
#define IDC_CONN_LIST                   1048
#define IDC_NAME_TXT                    1050
#define IDC_PASSWORD_TXT                1051
#define IDS_TRY_AGAIN                   1053
#define IDC_COOKIE_3RD_PARTY            1055
#define IDC_COOKIE_SEND_RECEIVE         1056
#define IDC_COOKIE_DESCRIPTION          1057
#define IDC_COOKIE_QUESTION             1058
#define IDC_COOKIE_3RDPARTY             1059
#define IDC_COOKIE_SESSION              1060
#define IDC_COOKIE_POLICY               1061
#define IDD_WARN_ON_POST                1175
#define IDD_HTTP_TO_HTTPS_ZONE_CROSSING 1177
#define IDD_HTTPS_TO_HTTP_ZONE_CROSSING 1178
#define IDD_MIXED_SECURITY              1179
#define ID_TELL_ME_ABOUT_SECURITY       1181
#define ID_TELL_ME_ABOUT_SECURITY2      1182
#define IDD_BAD_CN                      1188
#define IDD_BASIC_AUTHENTICATION        1216
#define IDC_REALM_NAME                  1217
#define IDC_USERNAME                    1218
#define IDC_PASSWORD                    1219
#define IDD_SHOW_CERT                   1301
#define IDD_CERTPICKER1                 1302
#define IDD_CERTVIEWER                  1302
#define IDD_HTTPS_POST_REDIRECT         1303
#define IDD_HTTPS_TO_HTTP_SUBMIT_REDIRECT 1303
#define ID_CERT_EDIT                    1318
#define ID_SHOW_CERTIFICATE             1630
#define ID_SHOW_CERTIFICATE2            1631
#define ID_CERT_MORE_INFO               1632
#define IDS_SETTING_COOKIE              1800
#define IDS_SETTING_COOKIE_TITLE        1801
#define IDS_YES                         1802
#define IDS_NO                          1803
#define IDS_COOKIE_EXPIRES_ENDSESSION   1804
#define IDS_PROTOCOL_UNKNOWN            1806
#define IDS_PROTOCOL_SSL2               1807
#define IDS_PROTOCOL_SSL3               1808
#define IDS_PROTOCOL_PCT1               1809
#define IDS_PROTOCOL_TLS1               1810
#define IDS_CIPHER_UNKNOWN              1811
#define IDS_ALG_MD2                     1812
#define IDS_ALG_MD4                     1813
#define IDS_ALG_MD5                     1814
#define IDS_ALG_SHA                     1815
#define IDS_ALG_MAC                     1816
#define IDS_ALG_HMAC                    1817
#define IDS_ALG_RSA_SIGN                1818
#define IDS_ALG_DSS_SIGN                1819
#define IDS_ALG_RSA_KEYX                1820
#define IDS_ALG_DES                     1821
#define IDS_ALG_3DES_112                1822
#define IDS_ALG_3DES                    1823
#define IDS_ALG_RC2                     1824
#define IDS_ALG_RC4                     1825
#define IDS_ALG_RC5                     1826
#define IDS_ALG_SEAL                    1827
#define IDS_ALG_DH_SF                   1828
#define IDS_ALG_DH_EPHEM                1829
#define IDS_ALG_KEA_KEYX                1830
#define IDS_ALG_SKIPJACK                1831
#define IDS_ALG_TEK                     1832
#define IDS_STRING_CIPHMSG              1833
#define IDS_STRING_HASHMSG              1834
#define IDS_STRING_EXCHMSG              1835
#define IDS_HASH_UNKNOWN                1836
#define IDS_EXCH_UNKNOWN                1837
#define IDS_CERT_HASH_ALG               1838
#define IDS_CERT_EXCH_ALG               1839
#define IDS_EXPORTCERT_ERRORTEXT        1900
#define IDS_EXPORTCERT_ERRORTITLE       1901
#define IDS_IMPORTCERT_ERRORTEXT        1902
#define IDS_IMPORTCERT_ERRORTITLE       1903
#define IDS_RNADLL_FILENAME             2000
#define IDS_CONNECTED_TO                2001
#define IDS_INETCFG_FILENAME            2002
#define IDS_REDIAL_WAIT                 2003
#define IDS_REDIAL_ATTEMPT              2004
#define IDS_DIALING                     2005
#define IDS_AUTHENTICATE                2006
#define IDS_CANCEL                      2007
#define IDS_WORK_OFFLINE                2008
#define IDS_CONNECTED                   2009
#define IDS_DISCONNECTED                2010
#define IDS_NOCERT_TITLE                2011
#define IDS_NOCERT                      2012
#define IDS_CONNECT_TO                  2013
#define IDS_PPPRANDOMFAILURE            2014
#define IDS_MEDIAINIERROR               2015
#define IDS_PHONEBUSY                   2016
#define IDS_NOANSWER                    2017
#define IDS_NODIALTONE                  2019
#define IDS_NODEVICE                    2020
#define IDS_TCPINSTALLERROR             2021
#define IDS_AUTHFAILURE                 2022
#define IDS_DOMAIN                      2023
#define IDS_REALM                       2024
#define IDS_SITE                        2025
#define IDS_FIREWALL                    2026
#define IDD_CHOOSE_CONNECTION           4001
#define IDD_NEW                         4002
#define IDD_DISABLEAUTODIAL             4003
#define IDD_TX_CHOOSE_CONNECTION        4004
#define IDD_EDIT                        4005
#define IDD_ZONE_ALERT                  4006
#define IDD_INVALID_CERT_CONTENTS       4007
#define IDD_INSERT_CDROM                4008
#define IDC_CD_NAME                     4009
#define IDC_USE_CDROM                   4011
#define IDC_CONNECT_TO_INTERNET         4012
#define IDS_LAN_CONNECTION              4013
#define IDD_GOOFFLINE                   4014
#define IDS_RASPHONEBOOK                4015
#define IDS_CONFIRM_PERM_COOKIE         4016
#define IDS_PERM_COOKIE                 4016
#define IDS_PROXY_TITLE                 4018
#define IDS_PROXY_MSG                   4019
#define IDS_CACHE_DEFAULT_SUBDIR_UNIX   4020
#define IDS_COOKIE_SAVE                 4021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        151
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1061
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\download.h ===
#ifndef _DOWNLOAD_H_
#define _DOWNLOAD_H_

#include "hierarchy.h"

struct   ResourceInfo {

   P3PURL     pszFinalURL;
   int        cbURL;
   char      *pszLocalPath;
   int        cbPath;
   FILETIME   ftExpiryDate;
};

int   downloadToCache(P3PCURL pszLocation, ResourceInfo *pInfo = NULL,
                      HANDLE *phCancelReq = NULL, 
                      P3PRequest *pRequest = NULL);

void  endDownload(HANDLE hConnect);

int   setExpiration(P3PCURL pszResource, const char *pszExpData, BOOL fRelative, FILETIME *pftExpire);

int   setExpiration(P3PCURL pszResource, FILETIME ftExpire);

bool  operator > (const FILETIME &ftA, const FILETIME &ftB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\unixui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    unixui.cxx

Abstract:

    Contains Unix fixes

    Contents:
        //UnixAdjustButtonSpacing
        UnixRemoveMoreInfoButton

Author:

    Sriram Nambakam (v-sriran) 07-Dec-1998

Revision History:

    07-Dec-1998 v-sriran
        Created

--*/

#include <wininetp.h>
#include "ierrui.hxx"
#include "iehelpid.h"
#include "unixui.h"
#include <mainwin.h>

#if 0

#define MOVE_LEFT   0
#define MOVE_CENTER 1
#define MOVE_RIGHT  2

static void hAdjustButtonSpacing(HWND   hwnd,
                                 short  buttonSpacingStyle,
                                 short  cButtons,
                                 short  dwSpacing,
                                 ...);
                    

/* HACKHACK
 * On Unix, we draw a focus rectangle around the button that is currently
 * selected. And, the focus rectangle will overlap with the next button.
 * We programatically move the button to the *left*, to make it look good.
 */

void UnixAdjustButtonSpacing(HWND  hwnd, DWORD dwDlgId)
{
     switch(dwDlgId)
     {
           case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                /* In these the More Info button is ID_TELL_ME_ABOUT_SECURITY */
                hAdjustButtonSpacing(hwnd,
                                     MOVE_LEFT,
                                     1,
                                     5,
                                     IDOK);
                
                break;
#ifdef NOT_YET_IMPLEMENTED
           case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                break;
           case IDD_MIXED_SECURITY:
                break;
           case IDD_INVALID_CA:
                break;
           case IDD_BAD_CN:
                break;
           case IDD_CONFIRM_COOKIE:
                /* In this the More Info button is IDC_COOKIE_DETAILS */
                break;
#endif /* NOT_YET_IMPLEMENTED */
     }
}

/* 
 * This function assumes all buttons are of equal width for MOVE_CENTER
 */
void hAdjustButtonSpacing(HWND    hwnd,
                          short   buttonSpacingStyle,
                          short   cButtons,
                          short   dwSpacing,
                          ...)
{
     va_list Arguments;
     DWORD dwButtonId;

     va_start(Arguments, dwSpacing);

     if (buttonSpacingStyle != MOVE_CENTER && dwSpacing)
     {
        HWND hCurButton;
        RECT rect;

        for (short i = 0; i < cButtons; i++)
        {
            dwButtonId = (DWORD)va_arg(Arguments,ULONG);
            if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
            {
               GetWindowRect(hCurButton, &rect); 
               ScreenToClient(hwnd, (LPPOINT)&rect);
               SetWindowPos(hCurButton,
                            NULL,
                            (buttonSpacingStyle == MOVE_LEFT ? rect.left-dwSpacing : rect.left+dwSpacing),
                            rect.top,
                            0,
                            0,
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
            }
        }
     }
     else /* MOVE_CENTER; dwSpacing does not matter */
     {
     }

     va_end(Arguments);

     return;
}
#endif /* 0 */

#define MOVE_CENTER 0x0001

static void hRemoveAndAdjust(HWND   hwnd,
                             DWORD  dwFlags,
                             short  cButtons,
                             ...);

/* If we have Button1 Button2 "More Info"
 * The following function makes it
 * <nothing> Button1 Button2
 * And, you have to pass the ids of "More Info" Button2 Button1 in the
 * variable argument list in that order
 */

void UnixRemoveMoreInfoButton(HWND  hwnd, DWORD dwDlgId)
{
     switch(dwDlgId)
     {
           case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                /* In these the More Info button is ID_TELL_ME_ABOUT_SECURITY */
                hRemoveAndAdjust(hwnd,
                                 MOVE_CENTER,
                                 2,
                                 ID_TELL_ME_ABOUT_SECURITY,
                                 IDOK);
                
                break;
           case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                hRemoveAndAdjust(hwnd,
                                 0,
                                 3,
                                 ID_TELL_ME_ABOUT_SECURITY,
                                 IDCANCEL,
                                 IDOK);
                break;
#ifdef NOT_YET_IMPLEMENTED
           case IDD_MIXED_SECURITY:
                break;
           case IDD_INVALID_CA:
                break;
           case IDD_BAD_CN:
                break;
           case IDD_CONFIRM_COOKIE:
                /* In this the More Info button is IDC_COOKIE_DETAILS */
                break;
#endif /* NOT_YET_IMPLEMENTED */
     }
}

void hRemoveAndAdjust(HWND   hwnd,
                      DWORD  dwFlags,
                      short  cButtons,
                      ...)
{
     va_list Arguments;
     DWORD   dwMoreInfoButtonId, dwButtonId;
     HWND    hMoreInfoButton, hDefButton;
     RECT    rectCur, rectPrev;

     hDefButton = MwRemoveDefPushButtonStyle(hwnd);

     /* Expect the first button to be the More Info Button
      * Hide the More Info Button, and move the other buttons to
      * the appropriate positions
      */

     if (cButtons < 2)
        goto Cleanup;

     /* We should use MOVE_CENTER only if there are two buttons in the move
      * list, and we hide the more info button, and move the other one to
      * the center
      */
     if ((dwFlags & MOVE_CENTER) && cButtons != 2)
        goto Cleanup;

     va_start(Arguments, cButtons);

     dwMoreInfoButtonId = (DWORD)va_arg(Arguments, ULONG);
     hMoreInfoButton = GetDlgItem(hwnd, dwMoreInfoButtonId);
     if (!hMoreInfoButton)
        goto Cleanup;

     GetWindowRect(hMoreInfoButton, &rectPrev); 
     ScreenToClient(hwnd, (LPPOINT)&rectPrev);

     if (dwFlags & MOVE_CENTER)
     {
        HWND hCurButton;
        dwButtonId = (DWORD)va_arg(Arguments,ULONG);
        if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
        {
           RECT rectDlg;

           GetWindowRect(hCurButton, &rectCur); 
           ScreenToClient(hwnd, (LPPOINT)&rectCur);
      
           GetWindowRect(hwnd, &rectDlg);
           ScreenToClient(hwnd, (LPPOINT)&rectDlg);
           SetWindowPos(hCurButton,
                        NULL,
                        ((rectDlg.right - rectDlg.left)/2)-((rectCur.right-rectCur.left)/2),
                        rectCur.top,
                        0,
                        0,
                        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
        }
     }
     else
     {
        HWND hCurButton;

        for (short i = 1; i < cButtons; i++)
        {
            dwButtonId = (DWORD)va_arg(Arguments,ULONG);
            if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
            {
               GetWindowRect(hCurButton, &rectCur); 
               ScreenToClient(hwnd, (LPPOINT)&rectCur);
               SetWindowPos(hCurButton,
                            NULL,
                            rectPrev.left,
                            rectPrev.top,
                            0,
                            0,
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
               memcpy(&rectPrev, &rectCur, sizeof(RECT));
            }
        }
     }

     /* Hide the More Info Button */
     ShowWindow(hMoreInfoButton, SW_HIDE);

Cleanup:

     if (hDefButton)
        MwRestoreDefPushButtonStyle(hDefButton);

     return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\unixui.h ===
#ifndef UNIXUI_H__
#define UNIXUI_H__

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

//void UnixAdjustButtonSpacing(HWND hwnd, DWORD dwDlgId);
void UnixRemoveMoreInfoButton(HWND hwnd, DWORD dwDlgId);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* UNIXUI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\hierarchy.h ===
#ifndef _HIERARCHY_H_
#define _HIERARCHY_H_

/*
This file defines object hierarchy for P3P implementation
*/
class P3PObject { 

public:
    virtual ~P3PObject() { }  // Virtual destructor required for inheritance

    virtual int QueryProperty(int property, void *description, unsigned char *result, int space)
        { return -1; }        // Provide stub implementation

    /* caution when overriding this function-- handles must point to the
       base class P3PObject regardless of actual derived class.
       pointer values would be different in the presence of MI */
    virtual P3PHANDLE   GetHandle() { return (P3PHANDLE) this; }

    virtual void        Free()      { delete this; }
};


class P3PRequest : public P3PObject {

public:
   P3PRequest(P3PSignal *pSignal=NULL);
   ~P3PRequest();

   virtual int execute()           = 0;

   virtual int queryStatus()       { return status; }

   virtual void Free();

   /* Function invoked by CreateThread -- 
      used for running P3P requests in separate thread. */
   static unsigned long __stdcall ExecRequest(void *pv);

   virtual void   enterIOBoundState();
   virtual void   leaveIOBoundState();

protected:
   /* Default implementation provided for following functions... */
   virtual int run();
   virtual void waitForCompletion();

   HANDLE hComplete;   /* Event handle for signaling completion */
   int    status;      /* Current status */
   P3PSignal retSignal;/* Used for signaling on non-blocking requests */

   CRITICAL_SECTION  csRequest;
   BOOL fRunning     : 1;
   BOOL fCancelled   : 1;
   BOOL fIOBound     : 1;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\map2policy.cpp ===
#include <wininetp.h>

#include "map2policy.h"

#include "download.h"
#include "policyref.h"
#include "p3pparser.h"

const char gszP3PWellKnownLocation[] = "/w3c/p3p.xml";

#define different(s, p) !(s&&p&&!strcmp(s,p))

INTERNETAPI_(int) MapResourceToPolicy(P3PResource *pResource, P3PURL pszPolicy, unsigned long dwSize, P3PSignal *pSignal) {

   int ret = P3P_Error;
   
   MR2P_Request *pRequest = new MR2P_Request(pResource, pszPolicy, dwSize, pSignal);
   if (pRequest) {
      if (!pSignal) {
         ret = pRequest->execute();
         delete pRequest;
      }
      else {
   
         DWORD dwThreadID;
         CreateThread(NULL, 0, P3PRequest::ExecRequest, (void*)pRequest, 0, &dwThreadID);
         pSignal->hRequest = pRequest->GetHandle();
         ret = P3P_InProgress;
      }
   }
   return ret;
}

INTERNETAPI_(int) GetP3PRequestStatus(P3PHANDLE hObject) {

   P3PObject *pObject = (P3PObject*) hObject;
   P3PRequest *pRequest = (P3PRequest*) pObject;

   return pRequest->queryStatus();
}

INTERNETAPI_(int) FreeP3PObject(P3PHANDLE hObject) {

   P3PObject *pObject = (P3PObject*) hObject;
   pObject->Free();
   return P3P_Done;
}

/*
Implementation of MR2P_Request class
*/
MR2P_Request::MR2P_Request(P3PResource *pResource, 
                           P3PURL pszPolicy, unsigned long dwSize,
                           P3PSignal *pSignal) 
: P3PRequest(pSignal) {

   static BOOL fNoInterrupt = TRUE;

   this->pResource = pResource;
   this->pszPolicyOut = pszPolicy;
   this->dwLength = dwSize;

   cTries = 0;
   ppPriorityOrder = NULL;
   pLookupContext = NULL;

   pszPolicyInEffect = NULL;
}

MR2P_Request::~MR2P_Request() {

   delete [] ppPriorityOrder;
   endDownload(hPrimaryIO);
}

int MR2P_Request::execute() {
  
   int nDepth = 0;
   P3PResource *pr;

   /* Clear out parameters */
   *pszPolicyOut = '\0';

   /* Determine depth of the resource tree */
   for (pr=pResource; pr; pr=pr->pContainer)
      nDepth++;
      
   /* 
   Construct priority order for trying the policy-reference files.
   According P3P V1 spec, we traverse the tree downwards starting with
   top-level document 
   */
   int current = nDepth;
   ppPriorityOrder = new P3PResource*[nDepth];

   for (pr=pResource; pr; pr=pr->pContainer)
      ppPriorityOrder[--current] = pr;

   for (int k=0; k<nDepth; k++) {

      pLookupContext = pr = ppPriorityOrder[k];

      char achWellKnownLocation[URL_LIMIT] = "";
      unsigned long dwLength = URL_LIMIT;

      UrlCombine(pr->pszLocation, gszP3PWellKnownLocation,
                 achWellKnownLocation, &dwLength, 0);

      P3PCURL pszReferrer = pr->pszLocation;

      /*
      Since policy-refs derived from link-tag, P3P headers or
      the well-known location could be same URL, we avoid trying
      the same PREF multiple times as an optimization
      In order of precedence:
      - Check well known location first -- always defined */
      if (tryPolicyRef(achWellKnownLocation, pszReferrer))
         break;

      /* ... followed by policy-ref from P3P header, if one exists and
         is different from the well-known location */
      if (pr->pszP3PHeaderRef                                  && 
          different(pr->pszP3PHeaderRef, achWellKnownLocation) &&
          tryPolicyRef(pr->pszP3PHeaderRef, pszReferrer))
         break;

      /* followed by policy-ref from HTML link tag, if one exists and
         is different from both the well-known location and P3P header */
      if (pr->pszLinkTagRef                                    && 
          different(pr->pszLinkTagRef, achWellKnownLocation)   &&
          different(pr->pszLinkTagRef, pr->pszP3PHeaderRef)    &&
          tryPolicyRef(pr->pszLinkTagRef, pszReferrer))
         break;
   }

   int ret = pszPolicyInEffect ? P3P_Done : P3P_NoPolicy;

   return ret;
}

bool MR2P_Request::tryPolicyRef(P3PCURL pszPolicyRef, P3PCURL pszReferrer) {

   if (pszPolicyRef==NULL)
      return false;

   P3PCHAR achFinalLocation[URL_LIMIT];
   unsigned long dwSpace = URL_LIMIT;
   char achFilePath[MAX_PATH];
   
   ResourceInfo ri;

   ri.pszFinalURL = achFinalLocation;
   ri.cbURL = URL_LIMIT;
   ri.pszLocalPath = achFilePath;
   ri.cbPath = MAX_PATH;
   
   if (downloadToCache(pszPolicyRef, &ri, &hPrimaryIO, this)>0) {

      P3PContext context = { ri.pszFinalURL, pszReferrer };
      context.ftExpires = ri.ftExpiryDate;

      P3PPolicyRef *pPolicyRef = interpretPolicyRef(achFilePath, &context);

      if (pPolicyRef) {

         FILETIME ftCurrentTime;      
         GetSystemTimeAsFileTime(&ftCurrentTime);

         if (pPolicyRef->getExpiration() > ftCurrentTime)
            pszPolicyInEffect = pPolicyRef->mapResourceToPolicy(pResource->pszLocation, pResource->pszVerb);
         if (pszPolicyInEffect)
            strncpy(pszPolicyOut, pszPolicyInEffect, dwLength);

         delete pPolicyRef;
      }
   }

   /* close the primary-IO handle and set it to NULL */
   endDownload(hPrimaryIO);
   hPrimaryIO = NULL;

   return (pszPolicyInEffect!=NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\p3pglobal.h ===
#ifndef _P3PGLOBAL_H_
#define _P3PGLOBAL_H_

/***
This file is OBSELETE.
Public P3P declarations have been moved to wininet.w
***/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\inetui\schnlui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    schnlui.cxx

Abstract:

    Contains immplimentation of generic Windows Dialog
    Manipulation Code.  This code supports SCHANNEL
    (Secure Channel SSL/PCT) specific UI for Certifcates.

    Contents:
        CertPickDialogProc

Author:

    Arthur L Bierer (arthurbi) 27-Jun-1996

Revision History:

    27-Jun-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include <ntsecapi.h>
#include "resource.h"
#include "ierrui.hxx"
#include "inethelp.h"
#include <softpub.h>
#include <htmlhelp.h>

#define USE_NT5_CRYPTOUI
#ifdef USE_NT5_CRYPTOUI
#include <cryptui.h>
HINSTANCE g_hCryptoUI = NULL;   // handle for cryptui.dll
#endif

//
// private prototypes, and defines.
//

#define TYPICAL_MD5_HASH_SIZE 16

#define NUM_DN_UNITS    6
#define MAX_ITEM_LEN    1000

#define DN_COMMON_NAME  0
#define DN_COUNTRY      1
#define DN_ORG          2
#define DN_ORGUNIT      3
#define DN_LOCALE       4
#define DN_STATE        5

#define MAX_CERT_FIELDS 20

typedef struct _ATTR_MAP
{
    DWORD dwAttr;
    DWORD dwStringID;
} ATTR_MAP;

// Now for some common attribute maps


ATTR_MAP ProtocolAttrMap[] =
{
    {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
    {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
    {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
    {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
};

ATTR_MAP AlgAttrMap[] =
{
    {CALG_MD2, IDS_ALG_MD2},
    {CALG_MD4, IDS_ALG_MD4},
    {CALG_MD5, IDS_ALG_MD5},
    {CALG_SHA, IDS_ALG_SHA},
    {CALG_SHA1, IDS_ALG_SHA},
    {CALG_MAC, IDS_ALG_MAC},
    {CALG_HMAC, IDS_ALG_HMAC},
    {CALG_RSA_SIGN, IDS_ALG_RSA_SIGN},
    {CALG_DSS_SIGN, IDS_ALG_DSS_SIGN},
    {CALG_RSA_KEYX, IDS_ALG_RSA_KEYX},
    {CALG_DES, IDS_ALG_DES},
    {CALG_3DES_112, IDS_ALG_3DES_112},
    {CALG_3DES, IDS_ALG_3DES},
    {CALG_RC2, IDS_ALG_RC2},
    {CALG_RC4, IDS_ALG_RC4},
    {CALG_RC5, IDS_ALG_RC5},
    {CALG_SEAL, IDS_ALG_SEAL},
    {CALG_DH_SF, IDS_ALG_DH_SF},
    {CALG_DH_EPHEM, IDS_ALG_DH_EPHEM},
    {CALG_KEA_KEYX, IDS_ALG_KEA_KEYX},
    {CALG_SKIPJACK, IDS_ALG_SKIPJACK},
    {CALG_TEK, IDS_ALG_TEK}
};





typedef struct {
    LPWSTR lpszListBoxText;
    LPWSTR lpszEditBoxText;
    DWORD dwSpcCtlId;       // special id for item to be placed in ctl.
} ShowCertMapping;


#define szHelpFile "iexplore.hlp"




//
// private function declariations
//



PRIVATE
BOOL
PlaceCertContextsInListBox(
    IN HWND hWndListBox,
    IN HWND hWndViewCertButton,
    IN HWND hWndExportButton,
    IN CERT_CONTEXT_ARRAY* pCertContexts
    );

PRIVATE
BOOL
PlaceCertificateDataIntoListBox(
    IN HWND hWndDlg,
    IN HWND hWndListBox,
    IN ShowCertMapping *pMapCertFields
    );

PRIVATE
DWORD
OnSelectionOfACertField(
    IN HWND hWndListBox,
    IN HWND hWndEditBox,
    IN ShowCertMapping *pMapCertFields
    );

PRIVATE
BOOL
CALLBACK
ViewCertDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

LPWSTR  GetCertStatus(LPINTERNET_SECURITY_INFO pciCert);
//
// public functions
//

#ifdef USE_NT5_CRYPTOUI
//+-------------------------------------------------------------------------
// Returns TRUE if cryptui.dll was found
//--------------------------------------------------------------------------
BOOL UseCryptoUI()
{
    static long fTriedOnce = FALSE;

    // Only try to load the dll once
    if (!fTriedOnce)
    {
        //
        // Note: if this gets called by multiple threads the worst that will
        // happen is that load library will be called twice.  Apparently,
        // there is is no danger of the global getting mangled because
        // writes are atomic.
        //
        g_hCryptoUI = LoadLibrary("cryptui.dll");
        fTriedOnce = TRUE;
    }

    return (g_hCryptoUI != NULL);
}

//+-------------------------------------------------------------------------
// Delay load version of the function in cryptui.dll
//--------------------------------------------------------------------------
BOOL _CryptUIDlgViewCertificate(
    IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCT   pCertViewInfo,
    OUT BOOL                               *pfPropertiesChanged  // OPTIONAL
    )
{
    // Caller must call UseCryptoUI() first to load the dll!
    INET_ASSERT(g_hCryptoUI);
    typedef BOOL (CALLBACK* CRYPTUIDLGVIEWCERTIFICATE)(PCCRYPTUI_VIEWCERTIFICATE_STRUCT, BOOL*);

    static CRYPTUIDLGVIEWCERTIFICATE fnCryptUIDlgViewCertificate = NULL;

    if (fnCryptUIDlgViewCertificate == NULL)
    {
        //
        // Note: if this gets called by multiple threads the worst that will
        // happen is that GetProcAddress will be called twice.  Apparently,
        // there is is no danger of the global getting mangled because
        // writes are atomic.
        //
        fnCryptUIDlgViewCertificate = (CRYPTUIDLGVIEWCERTIFICATE)GetProcAddress(g_hCryptoUI, "CryptUIDlgViewCertificateA");
        if (fnCryptUIDlgViewCertificate == NULL)
        {
            return FALSE;
        }
    }

    // Call the real function
    return fnCryptUIDlgViewCertificate(pCertViewInfo, pfPropertiesChanged);
}
#endif USE_NT5_CRYPTOUI

INTERNETAPI_(BOOL) InternetAlgIdToStringA(
    IN ALG_ID       ai,
    IN LPSTR        lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a algid to a user-displayable string.

Arguments:

    ai - Algorithm identifiers ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)

    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetAlgIdToStringA",
                     "%#x, %q, %#x, %#x",
                     ai,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if ((dwReserved!=0) || (lpdwstrLength == NULL))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (lpstr == NULL)
        *lpdwstrLength = 0;

    int i;
    for (i=0; i < ARRAY_ELEMENTS(AlgAttrMap) ; i++ )
    {
        if (ai == AlgAttrMap[i].dwAttr)
            break;
    }

    if ( i == ARRAY_ELEMENTS(AlgAttrMap) )
    {
        INET_ASSERT(FALSE);     // Could be because our table is not up to date.
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    CHAR szTempBuffer[100];

    int nRet;
    nRet = LoadStringA(GlobalDllHandle,
                           AlgAttrMap[i].dwStringID,
                           szTempBuffer,
                           ARRAY_ELEMENTS(szTempBuffer)
                           );

    // If the return value is within one less than the arraysize, it implies the
    // string could have been terminated by LoadString. This should not happen
    // since we have allocated a large enough buffer. If it does we need to bump the
    // size of the temporary array above.
    INET_ASSERT(nRet < ARRAY_ELEMENTS(szTempBuffer) - 1);

    if (*lpdwstrLength > (DWORD)nRet)
    {
        memcpy(lpstr, szTempBuffer, (nRet + 1));
        *lpdwstrLength = nRet;
        error = ERROR_SUCCESS;
    }
    else
    {
        *lpdwstrLength = nRet + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:
    if (ERROR_SUCCESS != error)
    {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(error==ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);
}

INTERNETAPI_(BOOL) InternetSecurityProtocolToStringA(
    IN DWORD        dwProtocol,
    IN LPSTR        lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a security protocol to a user-displayable string.

Arguments:

    dwProtocol - Security protocol identifier ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)

    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSecurityProtocolToStringA",
                     "%d, %q, %#x, %#x",
                     dwProtocol,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if ((dwReserved!=0) || (lpdwstrLength == NULL))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (lpstr == NULL)
        *lpdwstrLength = 0;

    int i;
    for (i=0; i < ARRAY_ELEMENTS(ProtocolAttrMap) ; i++ )
    {
        if (dwProtocol == ProtocolAttrMap[i].dwAttr)
            break;
    }

    if ( i == ARRAY_ELEMENTS(ProtocolAttrMap) )
    {
        INET_ASSERT(FALSE);     // Could be because our table is not up to date.
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    CHAR szTempBuffer[100];

    int nRet;
    nRet = LoadStringA(GlobalDllHandle,
                           ProtocolAttrMap[i].dwStringID,
                           szTempBuffer,
                           ARRAY_ELEMENTS(szTempBuffer)
                           );

    // If the return value is within one less than the arraysize, it implies the
    // string could have been terminated by LoadString. This should not happen
    // since we have allocated a large enough buffer. If it does we need to bump the
    // size of the temporary array above.
    INET_ASSERT(nRet < ARRAY_ELEMENTS(szTempBuffer) - 1);

    if (*lpdwstrLength > (DWORD)nRet)
    {
        memcpy(lpstr, szTempBuffer, (nRet + 1));
        *lpdwstrLength = nRet;
        error = ERROR_SUCCESS;
    }
    else
    {
        *lpdwstrLength = nRet + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:
    if (ERROR_SUCCESS != error)
    {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(error==ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);
}


LPWSTR DupAnsiToUnicode(
    char *lpszAnsi,
    INT iLen
    )
{
    
    DWORD cbSize = (iLen > 0 ) ? iLen : (lstrlen(lpszAnsi) + 1);
    WCHAR *pwszUnicode = NULL;
    pwszUnicode = new WCHAR[cbSize];
    if(pwszUnicode)
    {
        SHAnsiToUnicode(lpszAnsi, pwszUnicode, cbSize);
    }
    return pwszUnicode;
}



DWORD
ShowSecurityInfo(
    IN HWND                            hWndParent,
    IN LPINTERNET_SECURITY_INFO        pSecurityInfo
    )

/*++

Routine Description:

    Displays a dialog box that shows the information found
    inside of a certificate.

Arguments:

    hWndParent - Parent Window Handle

    pCertInfoEx - Certificate Information structure, containing the
                fields of info to show.

Return Value:

    DWORD
        Win32 or WININET error code.
--*/

{
#ifdef USE_NT5_CRYPTOUI
    //
    // For now, we use the new UI only if we can load the DLL.  Otherwise we
    // resort to the old UI.  Eventually, we may nuke the old UI.
    //
    if (UseCryptoUI())
    {
        CRYPTUI_VIEWCERTIFICATE_STRUCT cert;

        if(pWTHelperProvDataFromStateData && g_fDoSpecialMagicForSGCCerts)
        {
            WINTRUST_DATA           sWTD;
            WINTRUST_CERT_INFO      sWTCI;
            HTTPSPolicyCallbackData polHttps;
            LPCSTR pszPurpose = szOID_PKIX_KP_SERVER_AUTH;
            DWORD status;

            memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
            sWTD.cbStruct               = sizeof(WINTRUST_DATA);
            sWTD.dwUIChoice             = WTD_UI_NONE;
            sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
            sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
            sWTD.pCert                  = &sWTCI;
            sWTD.pwszURLReference       = NULL;
            sWTD.dwStateAction          = WTD_STATEACTION_VERIFY;
        
            memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
            sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
            sWTCI.psCertContext         = (CERT_CONTEXT *)pSecurityInfo->pCertificate;
            sWTCI.chStores              = 1;
            sWTCI.pahStores             = (HCERTSTORE *)&pSecurityInfo->pCertificate->hCertStore;

            memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
            polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
            polHttps.dwAuthType         = AUTHTYPE_SERVER;
            polHttps.fdwChecks          = INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                                          SECURITY_FLAG_IGNORE_WRONG_USAGE;
            polHttps.pwszServerName     = NULL;

            status = WinVerifySecureChannel(NULL, &sWTD);

            ZeroMemory(&cert, sizeof(cert));
            cert.dwSize         = sizeof(cert);
            cert.hwndParent     = hWndParent;
            cert.pCertContext   = pSecurityInfo->pCertificate;
            cert.hWVTStateData  = pWTHelperProvDataFromStateData(sWTD.hWVTStateData);
            cert.fpCryptProviderDataTrustedUsage = (status == ERROR_SUCCESS) ? TRUE : FALSE;
            cert.rgszPurposes = &pszPurpose;
            cert.cPurposes = 1;

            status = _CryptUIDlgViewCertificate(&cert, NULL);

            sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifySecureChannel(NULL, &sWTD);

            return status;    
        }
        else
        {
            ZeroMemory(&cert, sizeof(cert));
            cert.dwSize         = sizeof(cert);
            cert.hwndParent     = hWndParent;
            cert.pCertContext   = pSecurityInfo->pCertificate;
            cert.cStores        = 1;
            cert.rghStores      = (HCERTSTORE *) & (cert.pCertContext->hCertStore);

            return _CryptUIDlgViewCertificate(&cert, NULL);
        }

    }
#endif
#ifdef _WIN64
    return ERROR_INTERNET_INTERNAL_ERROR;
#else
    LPTSTR szResult = NULL;
    PLOCAL_STRINGS plszStrings;
    ShowCertMapping MapCertFields[MAX_CERT_FIELDS];

    WCHAR szTempBuffer[100];

    INT i = 0, j=0;
    DWORD error;
    LPTSTR lpszSubject = NULL;
    LPWSTR lpwszTempSubject = NULL;
    LPTSTR lpszIssuer = NULL;
    LPWSTR lpwszTempIssuer = NULL;

    WCHAR lpszProtocol[100];
    LPWSTR lpwszCipher = NULL;
    LPWSTR lpwszHash = NULL;
    LPWSTR lpwszExch = NULL;
    LPTSTR szFrom = NULL;
    LPWSTR pwszTempFrom = NULL;
    LPTSTR szUntil = NULL;
    LPWSTR pwszTempUntil = NULL;
    LPWSTR pwszStatus = NULL;
    LPSTR lpszHashStr = NULL;
    LPWSTR pwszTempHashStr = NULL;

    DWORD  adwFormatParams[3];


    PCERT_INFO pCertInfo =  NULL;
    DWORD  dwProtocolID =   IDS_PROTOCOL_UNKNOWN;
    DWORD  dwHashID =       IDS_HASH_UNKNOWN;
    DWORD  dwCipherID =     IDS_CIPHER_UNKNOWN;
    DWORD  dwExchID =       IDS_EXCH_UNKNOWN;
    DWORD cbSize;

    error = ERROR_SUCCESS;

    if((pSecurityInfo == NULL) || (pSecurityInfo->pCertificate == NULL))
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }


    pCertInfo = pSecurityInfo->pCertificate->pCertInfo;

    if(pCertInfo == NULL)
    {
       return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // Get the Certificate Information.
    //

    plszStrings = FetchLocalStrings();

    if ( plszStrings == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    szFrom = FTtoString(&pCertInfo->NotBefore);
    szUntil = FTtoString(&pCertInfo->NotAfter);



    //
    // Put a comment string about the certificate if there is one availble.
    //

    //
    // BUGBUG [arthurbi] This is broken.  We never determnine the host name,
    //  so therefore we never show a Comment for bad CA certificates.
    //

    pwszStatus = GetCertStatus(pSecurityInfo);

    if(pwszStatus)
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertComment;
        MapCertFields[i].lpszEditBoxText = pwszStatus;
        MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_COMMENT;
        i++;

    }

    if ( pCertInfo->Subject.cbData )
    {
        cbSize = CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        lpszSubject = new TCHAR[cbSize];

        if ( lpszSubject )
        {
            CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     lpszSubject,
                                     cbSize);
            MapCertFields[i].lpszListBoxText = plszStrings->szCertSubject;
            lpwszTempSubject = DupAnsiToUnicode(lpszSubject, cbSize);
            MapCertFields[i].lpszEditBoxText = lpwszTempSubject;
            MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_SUBJECT;
            i++;
        }
    }


    if ( pCertInfo->Issuer.cbData )
    {
        cbSize = CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        lpszIssuer = new TCHAR[cbSize];

        if ( lpszIssuer )
        {
            CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     lpszIssuer,
                                     cbSize);
            MapCertFields[i].lpszListBoxText = plszStrings->szCertIssuer;
            lpwszTempIssuer = DupAnsiToUnicode(lpszIssuer, cbSize);
            MapCertFields[i].lpszEditBoxText = lpwszTempIssuer;
            MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_ISSUER;
            i++;
        }
    }


    if ( szFrom )
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertEffectiveDate;
        pwszTempFrom = DupAnsiToUnicode(szFrom, 0);
        MapCertFields[i].lpszEditBoxText = pwszTempFrom;
        MapCertFields[i].dwSpcCtlId      = 0;
        i++;
    }


    if ( szUntil )
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertExpirationDate;
        pwszTempUntil = DupAnsiToUnicode(szUntil, 0);
        MapCertFields[i].lpszEditBoxText = pwszTempUntil;

        MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_EXPIRES;
        i++;
    }

    //
    // Get the fingerprint... aka MD5 Hash
    //

    {
        CHAR lpMD5Hash[TYPICAL_MD5_HASH_SIZE];
        DWORD dwMD5HashSize = TYPICAL_MD5_HASH_SIZE;
        BOOL fSuccess;

        fSuccess = CertGetCertificateContextProperty(
                    pSecurityInfo->pCertificate,
                    CERT_MD5_HASH_PROP_ID,
                    (LPVOID) lpMD5Hash,
                    &dwMD5HashSize
                    );

        if ( fSuccess )
        {
            CertHashToStr( lpMD5Hash,
                           dwMD5HashSize,
                           &lpszHashStr
                           );

            if ( lpszHashStr )
            {
                MapCertFields[i].lpszListBoxText = plszStrings->szFingerprint;
                pwszTempHashStr = DupAnsiToUnicode(lpszHashStr, 0);
                MapCertFields[i].lpszEditBoxText = pwszTempHashStr;

                MapCertFields[i].dwSpcCtlId      = 0;
                i++;
            }
        }
    }

    // Now fill in the connection attributes
    if(pSecurityInfo->dwProtocol)
    {

        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecurityInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadStringWrapW(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {

            MapCertFields[i].lpszEditBoxText = lpszProtocol;
            MapCertFields[i].lpszListBoxText = plszStrings->szCertProtocol;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }

    if(pSecurityInfo->aiCipher)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiCipher)
            {
                dwCipherID = AlgAttrMap[j].dwStringID;
                break;
            }
        }

        LoadStringWrapW(GlobalDllHandle,
                   dwCipherID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwCipherStrength;

        if (96 <= pSecurityInfo->dwCipherStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
        else if (64 <= pSecurityInfo->dwCipherStrength) // Passable key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthMedium;
        else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;



        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          plszStrings->szCiphMsg,
                          0,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPWSTR)&lpwszCipher,
                          0,
                          (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszCipher;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsEncryptAlg;
            MapCertFields[i].dwSpcCtlId      = 0;

            i++;
        }
    }

    if(pSecurityInfo->aiHash)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiHash)
            {
                dwHashID = AlgAttrMap[j].dwStringID;
                break;
            }
        }
        LoadStringWrapW(GlobalDllHandle,
                   dwHashID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwHashStrength;

        if (96 <= pSecurityInfo->dwHashStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
        else if (64 <= pSecurityInfo->dwHashStrength) // Passable key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthMedium;
        else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;

        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      plszStrings->szHashMsg,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR)&lpwszHash,
                      0,
                      (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszHash;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsHashAlg;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }
    if(pSecurityInfo->aiExch)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiExch)
            {
                dwExchID = AlgAttrMap[j].dwStringID;
                break;
            }
        }
        LoadStringWrapW(GlobalDllHandle,
                   dwExchID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwExchStrength;

        if (1024 <= pSecurityInfo->dwExchStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
         else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;

        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      plszStrings->szExchMsg,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR)&lpwszExch,
                      0,
                      (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszExch;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsExchAlg;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }

    //
    // Last Array Item is marked with 2 NULLs
    //

    MapCertFields[i].lpszListBoxText = NULL;
    MapCertFields[i].lpszEditBoxText = NULL;
    MapCertFields[i].dwSpcCtlId      = 0;


    INET_ASSERT(i < MAX_CERT_FIELDS);

    //
    // Now Launch the Dlg so we can show it.
    //

    ERRORINFODLGTYPE CertDlgInfo;

    CertDlgInfo.dwDlgFlags      = DLG_FLAGS_HAS_CERT_INFO;
    CertDlgInfo.dwDlgId         = IDD_SHOW_CERT;
    CertDlgInfo.hInternetMapped = NULL;
    CertDlgInfo.lpVoid          = (LPVOID) MapCertFields;

    LaunchDlg(
              hWndParent,
              (LPVOID) &CertDlgInfo,
              IDD_VIEW_CERT,
              ViewCertDlgProc
              );



quit:
    if(lpszIssuer) {
        FREE_MEMORY(lpszIssuer);
    }
    if(lpwszTempIssuer) {
        FREE_MEMORY(lpwszTempIssuer);
    }
    if(lpszSubject)
    {
        FREE_MEMORY(lpszSubject);
    }
    if(lpwszTempSubject) {
        FREE_MEMORY(lpwszTempSubject);
    }
    if (szFrom) {
        FREE_MEMORY(szFrom);
    }
    if(pwszTempFrom) {
        FREE_MEMORY(pwszTempFrom);
    }
    if (szUntil) {
        FREE_MEMORY(szUntil);
    }
    if(pwszTempUntil) {
        FREE_MEMORY(pwszTempUntil);
    }
    if (lpwszCipher) {
        FREE_MEMORY(lpwszCipher);
    }
    if (lpwszHash) {
        FREE_MEMORY(lpwszHash);
    }
    if (lpwszExch) {
        FREE_MEMORY(lpwszExch);
    }

    if (lpszHashStr) {
        delete lpszHashStr;
    }
    if(pwszTempHashStr) {
        FREE_MEMORY(pwszTempHashStr);
    }

    return error;
#endif
}


STDAPI_(DWORD) ShowCertificate(
    IN HWND                            hWndParent,
    IN LPVOID  pCertInfoEx
    )

/*++

Routine Description:

    Displays a dialog box that shows the information found
    inside of a certificate.

Arguments:

    hWndParent - Parent Window Handle

    pCertInfoEx - Certificate Information structure, containing the
                fields of info to show.

Return Value:

    DWORD
        Win32 or WININET error code.
--*/

{
    //DWORD error = ShowSecurityInfo(
    //                 hWndParent,
    //                (LPINTERNET_SECURITY_INFO) pCertInfoEx // BAD..
    //                 );

    //return error;

    return ERROR_INTERNET_INTERNAL_ERROR;
}







BOOL
CALLBACK
ViewCertDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Shows a Certificate, and relevent security information to the user.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    PERRORINFODLGTYPE pDlgInfo;

    const static DWORD mapIDCsToIDHs[] =
    {
         IDC_CERTPICKLIST                 ,IDH_LIST_CERT,
         ID_SHOW_CERTIFICATE              ,IDH_VIEW_CERT,
         IDC_DELETE_CERT                  ,IDH_DEL_CERT,
         0,0
    };

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        pDlgInfo = (PERRORINFODLGTYPE)lparam;

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               lparam);

        INET_ASSERT(pDlgInfo->dwDlgFlags & DLG_FLAGS_HAS_CERT_INFO );
        INET_ASSERT(pDlgInfo->lpVoid);

        PlaceCertificateDataIntoListBox(
            hwnd,
            GetDlgItem(hwnd,IDC_FIELDLIST),
            (ShowCertMapping *) pDlgInfo->lpVoid
            );

        OnSelectionOfACertField(
            GetDlgItem(hwnd,IDC_FIELDLIST),
            GetDlgItem(hwnd,IDC_DETAILSLIST),
            (ShowCertMapping *) pDlgInfo->lpVoid
            );


        return TRUE;

    case WM_HELP:                   // F1
        WinHelp( (HWND)((LPHELPINFO)lparam)->hItemHandle,
                szHelpFile,
                HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                );
        break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( (HWND) wparam,
                 szHelpFile,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                 );
        break;


    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;

        pDlgInfo =
            (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_TELL_ME_ABOUT_SECURITY:

                    //
                    // Launches help for this button.
                    //

                    WinHelp(
                            hwnd,
                            szHelpFile,
                            HELP_CONTEXT,
                            (ULONG_PTR)HELP_TOPIC_SECURITY
                            );
                                break;


                case IDC_FIELDLIST:

                    //
                    // If the user changes the selection of the listbox
                    //  move the edit control field data to the correct
                    //  entry.
                    //

                    if ( wNotificationCode == LBN_SELCHANGE )
                    {
                        OnSelectionOfACertField(
                            hWndCtrl,
                            GetDlgItem(hwnd,IDC_DETAILSLIST),
                            (ShowCertMapping *) pDlgInfo->lpVoid
                            );
                    }

                    break;

                case IDOK:
                case IDYES:

                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:
                case IDNO:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        return TRUE;
        }
    }

    return FALSE;
}



DWORD
ShowClientAuthCerts(
    IN HWND hWndParent
    )

/*++

Routine Description:

    Shows the Client Authentication Certificates found in the system.

Arguments:

    hWndParent - Parent Window Handle

Return Value:

    DWORD
        Win32 or WININET error code.

--*/


{
// With the NT5 crypto UI we don't need to display client-auth certs anymore.
// I left this in code in the source file in case we switch back to the old
// crypto dlls for some reason. Once we decide to move on to the new crypto dlls
// this code can be removed. - sgs
#ifndef USE_NT5_CRYPTOUI
    DWORD error;
    ERRORINFODLGTYPE ErrorInfoDlgInfo;

    ErrorInfoDlgInfo.hInternetMapped    = NULL;
    ErrorInfoDlgInfo.dwDlgId            = IDD_CERTVIEWER;
    ErrorInfoDlgInfo.lpVoid             = NULL;
    ErrorInfoDlgInfo.dwDlgFlags         = 0;


    CliAuthAquireCertChains(
        NULL,
        NULL,
        (CERT_CHAIN_ARRAY **) &ErrorInfoDlgInfo.lpVoid
        );

    //
    // Don't Care about error code, from function.
    //


    error = LaunchDlg(
              hWndParent,
              (LPVOID) &ErrorInfoDlgInfo,
              ErrorInfoDlgInfo.dwDlgId,
              CertPickDialogProc
              );

    if ( ErrorInfoDlgInfo.lpVoid )
        delete ErrorInfoDlgInfo.lpVoid;

    return error;
#else
    INET_ASSERT(FALSE);
    return ERROR_CALL_NOT_IMPLEMENTED;
#endif
}




DWORD
ParseX509EncodedCertificateForListBoxEntry(
    IN LPBYTE  lpCert,
    IN DWORD   cbCert,
    OUT LPSTR  lpszListBoxEntry,
    IN LPDWORD lpdwListBoxEntry
    )
/*++

Routine Description:

    Parses an X509 certificate, into a single text entry that
    can be displayed on a line in a listbox.

Arguments:

    lpCert           - Certificte bytes to parse

    cbCert           - Size of certificate to parse

    lpszListBoxEntry - Formated text to use in List Box.

    lpdwListBoxEntry - IN: size of lpszListBoxEntry, OUT: actual size of string.

Return Value:

    DWORD
        Win32 or WININET error code.

--*/

{
    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;
    PCCERT_CONTEXT pCert;
    PCERT_NAME_INFO pName = NULL;
    PCERT_RDN       pIdentRDN;
    PCERT_RDN_ATTR  pIdentifier;
    DWORD           cbIdentifier;
    DWORD cbName, cbName2;


    INET_ASSERT(lpdwListBoxEntry);

    if (lpszListBoxEntry == NULL)
        *lpdwListBoxEntry = 0;

    //
    //  30-Aug-1997 pberkman:
    //              we need to do this to be backwards compatible with this function.
    //              however, becuase the create context function does not get us properties
    //              when we are creating it from a already existing context, we need the
    //              ability to just pass in the pre-existing context.  To do this, just
    //              pass "-1" in for the cbCert and we'll do the "right thing".
    //
    if (cbCert == (-1))
    {
        pCert = (PCCERT_CONTEXT)lpCert;
    }
    else
    {
        pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                    lpCert,
                                    cbCert);
    }

    //
    //  30-Aug-1997 pberkman:
    //              look at the "Friendly Name" property first.
    //
    cbName = 0;
    CertGetCertificateContextProperty(pCert, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cbName);

    if (cbName > 0)
    {
        WCHAR *pbFName;

        if (pbFName = (WCHAR *)new BYTE[cbName])
        {
            if (CertGetCertificateContextProperty(pCert, CERT_FRIENDLY_NAME_PROP_ID, pbFName, &cbName))
            {
                cbName2 = WideCharToMultiByte(0, 0, (WCHAR *)pbFName, wcslen((WCHAR *)pbFName) + 1,
                                              lpszListBoxEntry, *lpdwListBoxEntry, NULL, NULL);

                if (cbName2 > *lpdwListBoxEntry)
                {
                    error = ERROR_INSUFFICIENT_BUFFER;
                    *lpdwListBoxEntry = cbName2;
                }

                delete pbFName;

                if ((pCert) && (cbCert != (-1)))
                {
                    CertFreeCertificateContext(pCert);
                }

                return(error);
            }

            delete pbFName;
        }
    }

    if(CryptDecodeObject(pCert->dwCertEncodingType,
                         X509_NAME,
                         pCert->pCertInfo->Subject.pbData,
                         pCert->pCertInfo->Subject.cbData,
                         0,
                         NULL,
                         &cbName))
    {
        pName = (PCERT_NAME_INFO)new BYTE[cbName];
        if(pName == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if(!CryptDecodeObject(pCert->dwCertEncodingType,
                                     X509_NAME,
                                     pCert->pCertInfo->Subject.pbData,
                                     pCert->pCertInfo->Subject.cbData,
                                     0,
                                     pName,
                                     &cbName))
        {
            delete pName;
            pName = NULL;
            error = GetLastError();

        }
    }
    else
    {
        error = GetLastError();
    }

    if((NULL != pName) && (pName->cRDN > 0))
    {
        pIdentifier = CertFindRDNAttr(szOID_COMMON_NAME, pName);

        if(pIdentifier == NULL)
        {
            pIdentifier = CertFindRDNAttr(szOID_ORGANIZATIONAL_UNIT_NAME, pName);
            if(pIdentifier == NULL)
            {
                pIdentifier = CertFindRDNAttr(szOID_ORGANIZATION_NAME, pName);
                if(pIdentifier == NULL)
                {
                    pIdentRDN = &pName->rgRDN[pName->cRDN-1];
                    pIdentifier = &pIdentRDN->rgRDNAttr[pIdentRDN->cRDNAttr-1];
                }
            }
        }


        if(pIdentifier != NULL)
        {
            cbIdentifier = CertRDNValueToStr(pIdentifier->dwValueType,
                              &pIdentifier->Value,
                              NULL,
                              0);

            if(cbIdentifier == 0)
            {
                error = GetLastError();
            }
            else if ( (lpszListBoxEntry != NULL) && (cbIdentifier > (*lpdwListBoxEntry)) )
            {
                error = ERROR_INSUFFICIENT_BUFFER;
                *lpdwListBoxEntry = cbIdentifier;
            }
            else
            {

                *lpdwListBoxEntry = CertRDNValueToStr(pIdentifier->dwValueType,
                                  &pIdentifier->Value,
                                  lpszListBoxEntry,
                                  cbIdentifier);
                error = ERROR_SUCCESS;
            }
        }
        else
        {
            *lpdwListBoxEntry = 0;

            error = ERROR_INTERNET_INVALID_OPERATION;
        }


        delete pName;
    }

    //
    //  30-Aug-1997 pberkman:
    //              we have to free this thing!
    //
    if ((pCert) && (cbCert != (-1)))
    {
        CertFreeCertificateContext(pCert);
    }

    return error;
}



DWORD
ShowX509EncodedCertificate(
    IN HWND    hWndParent,
    IN LPBYTE  lpCert,
    IN DWORD   cbCert
    )
/*++

Routine Description:

    Shows an encoded set of bytes which represent a certificate,
    in a dialog box.

Arguments:

    hWndParent

    lpCert

    cbCert

Return Value:

    DWORD
        ERROR_SUCCESS


--*/

{

    DWORD error;

#ifdef USE_NT5_CRYPTOUI

    //
    // For now, we use the new UI only if we can load the DLL.  Otherwise we
    // resort to the old UI.  Eventually, we may nuke the old UI.
    //

    if (UseCryptoUI())
    {
        CRYPTUI_VIEWCERTIFICATE_STRUCT cert;

        ZeroMemory(&cert, sizeof(cert));
        cert.dwSize = sizeof(cert);
        cert.hwndParent = hWndParent;
        cert.pCertContext = (PCCERT_CONTEXT)lpCert;
        cert.cStores = 1;
        cert.rghStores = (HCERTSTORE *) & (cert.pCertContext->hCertStore);

        return _CryptUIDlgViewCertificate(&cert, NULL);
    }
    else
#endif
    {
        X509Certificate *pCertData = NULL;
        INTERNET_SECURITY_INFO ciInfo;

        ZeroMemory(&ciInfo, sizeof(ciInfo));

        ciInfo.dwSize = sizeof(ciInfo);

        ciInfo.pCertificate = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                         lpCert,
                                                         cbCert);
        error = ShowSecurityInfo(
                                hWndParent,
                                &ciInfo
                                );
    }

    return error;
}



BOOL _GetSelectedCertContext(HWND hwnd, PERRORINFODLGTYPE pDlgInfo, PCCERT_CONTEXT *ppCertContext)
{
    CERT_CONTEXT_ARRAY* pCertContextArray;

    if (ppCertContext == NULL)
        return FALSE;

    *ppCertContext = NULL;

    pCertContextArray =
                ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();

    PCERT_CHAIN pcCertChain;
    LRESULT index;

    INET_ASSERT(pCertContextArray);
    if (!pCertContextArray)
        return FALSE;

    //
    // Retrieve the Cert from List box
    //

    index = SendDlgItemMessage(hwnd,
                               IDC_CERTPICKLIST,
                               LB_GETCURSEL,
                               0,
                               0);


    if ( index == LB_ERR )
        index = 0;


    if ( index >= (INT) pCertContextArray->GetArraySize())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    *ppCertContext =  pCertContextArray->GetCertContext((INT)index);

    if (!*ppCertContext)
        return FALSE;
    else
        return TRUE;
}


INT_PTR
CALLBACK
CertPickDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Supports Ok/Cancel decisions for the Client Authentication UI.
    Allows the User to select a specific Certificate that he wishes
    to use for Client Auth.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    PERRORINFODLGTYPE pDlgInfo;
    CERT_CONTEXT_ARRAY* pCertContextArray;
    LRESULT index;

    const static DWORD mapIDCsToIDHs[] =
    {
         IDC_CERTPICKLIST,      IDH_CLIENT_AUTHENTICATION_LIST,
         ID_SHOW_CERTIFICATE,   IDH_CLIENT_AUTHENTICATION_CERT_PROPS,
         IDCLOSE,               IDH_ORG_FAVORITES_CLOSE,
         IDC_BUTTON_IMPORT,     IDH_CLIENTAUTH_IMPORT,
         IDC_BUTTON_EXPORT,     IDH_CLIENTAUTH_EXPORT,
         0,0
    };


    switch (msg)
    {

    case WM_INITDIALOG:

        {
            INET_ASSERT(lparam);

            pDlgInfo = (PERRORINFODLGTYPE)lparam;

            (void)SetWindowLongPtr(hwnd,
                                   DWLP_USER,
                                   lparam);

            // We used to have other dialogs use the same dialog proc, but this
            // shouldn't happen with the removal of the personal certs dialog.
            INET_ASSERT(pDlgInfo->dwDlgId == IDD_CERTPICKER);
            pCertContextArray =
                ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();


            PlaceCertContextsInListBox(
                GetDlgItem(hwnd, IDC_CERTPICKLIST),
                GetDlgItem(hwnd, ID_SHOW_CERTIFICATE),
                GetDlgItem(hwnd, IDC_BUTTON_EXPORT),
                pCertContextArray
                );

            return TRUE;

        }

    case WM_HELP:                   // F1
        WinHelp( (HWND)((LPHELPINFO)lparam)->hItemHandle,
                szHelpFile,
                HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                );
        break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( (HWND) wparam,
                 szHelpFile,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                 );
        break;

    case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            WORD wNotificationCode = HIWORD(wparam);
            HWND hWndCtrl = (HWND) lparam;

            pDlgInfo =
                (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_TELL_ME_ABOUT_SECURITY:

                    //
                    // Launches help for this button.
                    //

                    WinHelp(
                            hwnd,
                            szHelpFile,
                            HELP_CONTEXT,
                            (ULONG_PTR)HELP_TOPIC_SECURITY
                            );
                                break;


                case ID_SHOW_CERTIFICATE:
                {
                    //
                    // If this dialog supports this behavior, then launch
                    //  a show certficate dlg.
                    //
                    PCCERT_CONTEXT pCertContext;

                    if ( wNotificationCode == BN_CLICKED &&
                         _GetSelectedCertContext(hwnd, pDlgInfo, &pCertContext ))
                    {
                        ShowX509EncodedCertificate( hwnd, (LPBYTE)pCertContext, sizeof(pCertContext) );
                    }

                    break;
                }

                case ID_CERT_MORE_INFO:
                    HtmlHelp(hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR)TEXT("cert_ovr.htm"));
                    break;

                case IDCANCEL:

                    index = -1;
                    goto lskip_getcursel;


                case IDOK:

                    //
                    // Get the selected Cert.
                    //

                    index = SendDlgItemMessage(hwnd,
                                        IDC_CERTPICKLIST,
                                        LB_GETCURSEL,
                                        0,
                                        0);

                    if ( index == LB_ERR )
                        index = -1;


        lskip_getcursel:


                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    //
                    // Select the Client Auth Cert to use,
                    //  but only if we've got the cert picker dialog.
                    //
                    pCertContextArray =
                        ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();

                    if (pCertContextArray)
                    {
                        pCertContextArray->SelectCertContext((INT)index);
                    }


                    EndDialog(hwnd, TRUE);
                    break;


                case IDCLOSE:

                    //
                    // We're done, so return FALSE.
                    //

                    EndDialog(hwnd, FALSE);
                    break;


            }

        return TRUE;
        }
    }

    return FALSE;
}





//
// private functions
//


PRIVATE
BOOL
PlaceCertContextsInListBox(
    IN HWND hWndListBox,
    IN HWND hWndViewCertButton,
    IN HWND hWndExportButton,
    IN CERT_CONTEXT_ARRAY* pCertContextArray
    )

/*++

Routine Description:

    Takes an array of CertContext's and puts them into a listbox,
    by cracking their contents one at a time.

Arguments:

    hWndListBox         - Window Handle to ListBox to add items to.

    pCertContext's         - Pointer to array of cert chains.

    hWndViewCertButton  - Window handle to ViewCert Button, NULL if no button is around

Return Value:

    BOOL
        TRUE    - success.

        FALSE   - failure.

--*/

{
    DWORD i = 0;

    if ( !pCertContextArray)
    {
        goto quit;
    }

    SendMessage(hWndListBox, LB_RESETCONTENT, 0, 0 );

    for ( i = 0; i < pCertContextArray->GetArraySize(); i++ )
    {
        PCCERT_CONTEXT pCert;
//        PCERT_NAME_INFO pName = NULL;
//        PCERT_RDN_ATTR  pCommonName;
        DWORD cbName;
        DWORD   dwRet;

        pCert =  pCertContextArray->GetCertContext(i);

        INET_ASSERT(pCert);

        LPSTR lpszSubject;

        cbName = 0;
        ParseX509EncodedCertificateForListBoxEntry(pCert->pbCertEncoded,
                                                   pCert->cbCertEncoded,
                                                   NULL,
                                                   &cbName);
        if (cbName > 0)
        {
            if (lpszSubject = new TCHAR[cbName])
            {
                if (ParseX509EncodedCertificateForListBoxEntry(pCert->pbCertEncoded,
                                                               pCert->cbCertEncoded,
                                                               lpszSubject,
                                                               &cbName) == ERROR_SUCCESS)
                {
                    SendMessage(hWndListBox, LB_INSERTSTRING, (WPARAM)-1, (LPARAM) lpszSubject);
                }

                FREE_MEMORY(lpszSubject);
            }
        }
    }


quit:


    // Select the first item in the list box
    // TODO: move selection to current default item.
    SendMessage(hWndListBox, LB_SETCURSEL, 0, 0 );

    // If nothing was added, disable the windows, otherwise enable them

    EnableWindow(hWndListBox, (i != 0));
    if ( hWndViewCertButton )
        EnableWindow(hWndViewCertButton, (i != 0));
    if ( hWndExportButton )
        EnableWindow(hWndExportButton, (i != 0));

    return TRUE;
}

PRIVATE
BOOL
PlaceCertificateDataIntoListBox(
    IN HWND hWndDlg,
    IN HWND hWndListBox,
    IN ShowCertMapping *pMapCertFields
    )
{

    DWORD i;

    INET_ASSERT(pMapCertFields);
    INET_ASSERT(IsWindow(hWndListBox));

    for ( i = 0; pMapCertFields[i].lpszListBoxText != NULL; i++ )
    {
        if ( pMapCertFields[i].dwSpcCtlId != 0 )
        {
            SetDlgItemTextWrapW(hWndDlg,pMapCertFields[i].dwSpcCtlId,
                pMapCertFields[i].lpszEditBoxText );

            SetWindowLong(GetDlgItem(hWndDlg,pMapCertFields[i].dwSpcCtlId),
                           GWL_STYLE, ES_READONLY |
                                        GetWindowLong(GetDlgItem(hWndDlg,pMapCertFields[i].dwSpcCtlId), GWL_STYLE));

        }

        SendMessage(hWndListBox, LB_ADDSTRING, 0, (LPARAM)pMapCertFields[i].lpszListBoxText);
    }

    INET_ASSERT(i>0);

    SendMessage(hWndListBox, LB_SETCURSEL, 0, 0 );

    return TRUE;
}

PRIVATE
DWORD
OnSelectionOfACertField(
    IN HWND hWndListBox,
    IN HWND hWndEditBox,
    IN ShowCertMapping *pMapCertFields
    )
{
    LRESULT index;

    index = SendMessage(hWndListBox, LB_GETCURSEL, 0, 0);

    if (index == LB_ERR )
        index = 0;


    if ( pMapCertFields[index].lpszListBoxText != NULL )
    {
        SetWindowTextWrapW(hWndEditBox,
                        pMapCertFields[index].lpszEditBoxText );

        SetWindowLong(hWndEditBox,
                       GWL_STYLE, ES_READONLY |
                                    GetWindowLong(hWndEditBox, GWL_STYLE));
    }

    return ERROR_SUCCESS;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE   _HRESULT_TYPEDEF_(0x800B0110L)
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00010000
#endif
/* get a string representing the status of a certificate */
LPWSTR  GetCertStatus(LPINTERNET_SECURITY_INFO pciCert)
{

    // We've done our handshake, now update the security info
    DWORD dwCertFlags;
    PLOCAL_STRINGS plszStrings;
    GUID                    gHTTPS = HTTPSPROV_ACTION;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD                   error;


    plszStrings = FetchLocalStrings();
    if(plszStrings == NULL)
    {
        return NULL;
    }

    if((pciCert == NULL) || (pciCert->pCertificate == NULL))
    {
        return NULL;
    }


    //
    //  initialize the structures for forward/backward support of wintrust.dll!!!
    //
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;


    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)pciCert->pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&pciCert->pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks = INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                         SECURITY_FLAG_IGNORE_WRONG_USAGE;




    polHttps.pwszServerName = NULL;


    sWTCI.pcwszDisplayName  = NULL;


    error = LoadWinTrust();

    if(ERROR_SUCCESS == error)
    {

        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    // If we are unable to verify revocation, then ignore.
    if(error == CERT_E_REVOCATION_FAILURE)
    {
        error = ERROR_SUCCESS;
    }


    switch(error)
    {
        case CERT_E_EXPIRED:
        case CERT_E_VALIDITYPERIODNESTING:
            return plszStrings->szCommentExpires;

        case CERT_E_UNTRUSTEDROOT:
            return plszStrings->szCommentBadCA;


        case CERT_E_CN_NO_MATCH:
            return plszStrings->szCommentBadCN;

        case CRYPT_E_REVOKED:
            return plszStrings->szCommentRevoked;

        case CERT_E_WRONG_USAGE:
            return plszStrings->szCertUsage;

        case CERT_E_ROLE:
        case CERT_E_PATHLENCONST:
        case CERT_E_CRITICAL:
        case CERT_E_PURPOSE:
        case CERT_E_ISSUERCHAINING:
        case CERT_E_MALFORMED:
        case CERT_E_CHAINING:
            return plszStrings->szCommentNotValid;

        case ERROR_SUCCESS:
            return NULL;

        default:
             return plszStrings->szCommentNotValid;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\map2policy.h ===
#include "hierarchy.h"

class MR2P_Request : public P3PRequest {

public:
   MR2P_Request(P3PResource *pResource,
                P3PURL pszPolicy, unsigned long dwSize,
                P3PSignal *pSignal);
                
   ~MR2P_Request();

   virtual int execute();

   /* function invoked by CreateThread -- 
      for running requests in another thread */
   static unsigned long __stdcall ExecRequest(void *pv);

protected:
   bool  tryPolicyRef(P3PCURL pszPolicyRef, P3PCURL pszReferrer=NULL);

private:
   // Request parameters
   P3PResource *pResource;
   unsigned long dwLength;

   // Out parameters
   P3PURL pszPolicyOut;

   // Internal state of the request
   int cTries;
   P3PResource **ppPriorityOrder;

   P3PResource *pLookupContext;
   P3PCURL pszPolicyInEffect;

   HANDLE   hPrimaryIO;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\p3pparser.h ===
#ifndef _POLICY_MANAGER_H_
#define _POLICY_MANAGER_H_

#include "p3pglobal.h"
#include "policyref.h"


struct P3PContext {

   /* Original URL of the file being parsed */
   P3PCURL  pszOriginalLoc;

   /* Document which referred to this P3P file */
   P3PCURL  pszReferrer;   

   /* Expiration time implied by HTTP headers */
   FILETIME ftExpires;
};

P3PPolicyRef *interpretPolicyRef(char *pszFileName, P3PContext *pContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\download.cpp ===
#include <wininetp.h>

#include "download.h"

static const int EntryInfoSize = 8192;

HINTERNET hDownload = NULL;

struct HandlePair {

   HANDLE hConnect;
   HANDLE hRequest;

   HandlePair(HANDLE hc=NULL, HANDLE hr=NULL) :
      hConnect(hc), hRequest(hr) { }
};

bool initialize() {

   if (!hDownload) {
      hDownload = InternetOpen(NULL,
                               INTERNET_OPEN_TYPE_PRECONFIG,
                               NULL, NULL,
                               0);
   }
   return (hDownload!=NULL);
}

/* Determine local file corresponding to request handle
   this is the file holding the data downloaded from the network.
   typically its an entry in the URL cache. for non-cacheable responses
   WININET creates a temporary file. */
int   getLocalFile(HANDLE hRequest, LPTSTR pLocalPath, unsigned long dwPathSize) {

   *pLocalPath = '\0';
   return InternetQueryOption(hRequest, INTERNET_OPTION_DATAFILE_NAME , pLocalPath, &dwPathSize);
}

/* Determine final URL (after redirects) */
int   getFinalURL(HANDLE hRequest, LPTSTR pszFinalURL, unsigned long cCharacters) {

   *pszFinalURL = '\0';
   return InternetQueryOption(hRequest, INTERNET_OPTION_URL, pszFinalURL, &cCharacters);
}

/* returns the Expiry: header from HTTP response */
FILETIME getExpiryHeader(HANDLE hRequest) {

   SYSTEMTIME st;
   FILETIME ft = {0x0, 0x0};
   DWORD dwIndex = 0;
   DWORD cbBuffer = sizeof(st);

   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME, 
                     &st, &cbBuffer, &dwIndex))
      SystemTimeToFileTime(&st, &ft);
   return ft;
}

HandlePair  createRequest(P3PCURL pszLocation) {

   /* P3P downloads are executed with this combination of flags. */
   const DWORD glDownloadFlags =                                
                     INTERNET_FLAG_NEED_FILE      |  // Require local copy of file for parsing
                     INTERNET_FLAG_KEEP_CONNECTION|  // No authentication-- policy looks up MUST be anonymous
                     INTERNET_FLAG_NO_COOKIES     |  // No cookies -- same reason.
                     INTERNET_FLAG_RESYNCHRONIZE  |  // Check for fresh content
                     INTERNET_FLAG_PRAGMA_NOCACHE;   // For intermediary HTTP caches

   char achCanonicalForm[URL_LIMIT];
   unsigned long cflen = sizeof(achCanonicalForm);

   InternetCanonicalizeUrl(pszLocation, achCanonicalForm, &cflen, 0);

   char achFilePath[URL_LIMIT] = "";
   char achServerName[INTERNET_MAX_HOST_NAME_LENGTH] = "";

   URL_COMPONENTS uc = { sizeof(uc) };

   uc.lpszHostName = achServerName;
   uc.dwHostNameLength = sizeof(achServerName);
   uc.lpszUrlPath = achFilePath;
   uc.dwUrlPathLength = sizeof(achFilePath);

   if (!InternetCrackUrl(achCanonicalForm, 0, 0, &uc))
      return NULL; 
      
   HINTERNET hConnect, hRequest;

   hConnect = InternetConnect(hDownload,
                              achServerName,
                              uc.nPort,
                              NULL, NULL,
                              INTERNET_SERVICE_HTTP,
                              0, 0);

   DWORD dwFlags = glDownloadFlags;

   if (uc.nScheme==INTERNET_SCHEME_HTTPS)
      dwFlags |= INTERNET_FLAG_SECURE;

   hRequest =  HttpOpenRequest(hConnect, NULL, 
                               achFilePath,
                               NULL, NULL, NULL,
                               dwFlags,
                               0);

   return HandlePair(hConnect, hRequest);
}

unsigned long beginDownload(HANDLE hRequest) {

   BOOL fSuccess = HttpSendRequest(hRequest, NULL, 0, NULL, 0); 
   
   if (!fSuccess)
      return HTTP_STATUS_NOT_FOUND;

   /* determine HTTP status code */
   unsigned long dwStatusCode = HTTP_STATUS_NOT_FOUND;
   unsigned long dwIndex = 0;
   unsigned long dwSpace = sizeof(dwStatusCode);

   HttpQueryInfo(hRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                 (void*) &dwStatusCode, &dwSpace, &dwIndex);

   return dwStatusCode;
}

int  readResponse(HANDLE hRequest) {

   int  total = 0;
   unsigned long bytesRead;
   char buffer[256];

   /* This loop downloads the file to HTTP cache.
      Because of WININET specs the loop needs to continue until "bytesRead" is zero,
      at which point the file will be committed to the cache */
   do {
      bytesRead = 0;
      InternetReadFile(hRequest, buffer, sizeof(buffer), &bytesRead);
      total += bytesRead;
   }
   while (bytesRead);

   return total;
}

void  endDownload(HANDLE hConnect) {

   if (hConnect)
      InternetCloseHandle(hConnect);
}

// Download given URL into local file
int   downloadToCache(P3PCURL pszLocation, ResourceInfo *pInfo,
                      HANDLE *phConnect,
                      P3PRequest *pRequest) {

   static bool fReady = initialize();

   HandlePair hndpair = createRequest(pszLocation);
   
   HINTERNET hConnect = hndpair.hConnect;
   HINTERNET hRequest = hndpair.hRequest;

   /* Give the connect handle back to client.
      WININET closes all derived handles when a parent handle is closed.
      Client calls endDownload() when done processing the file, which causes
      connect handle to be closed, which in turn closes actual request handle */
   if (phConnect)
      *phConnect = hConnect;

   if (!hConnect || !hRequest)
      return -1;

   if (pRequest)
      pRequest->enterIOBoundState();

   int total = -1;
   
   unsigned long dwStatusCode = beginDownload(hRequest);

   /* status code different from 200-OK is failure */
   if (dwStatusCode==HTTP_STATUS_OK) {

      total = readResponse(hRequest);

      if (total>0 && pInfo) {

         getFinalURL(hRequest, pInfo->pszFinalURL, pInfo->cbURL);
         getLocalFile(hRequest, pInfo->pszLocalPath, pInfo->cbPath);
         pInfo->ftExpiryDate = getExpiryHeader(hRequest);
      }
   }

   if (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ) {
      DWORD dwRetval;
      DWORD dwError;
      DWORD dwStatusLength = sizeof(DWORD);
      DWORD dwIndex = 0;
      BOOL fDone;
      fDone = FALSE;
      while (!fDone)
      {
         dwRetval = InternetErrorDlg(GetDesktopWindow(),
                                     hRequest,
                                     ERROR_INTERNET_INCORRECT_PASSWORD,
                                     0L,
                                     NULL);
         if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
         {   // Resend request, new credentials are cached and will be replayed by HSR()
             if (!HttpSendRequest(hRequest,NULL, 0L, NULL, NULL))
             {
             	dwError = GetLastError();
             	total = -1;
               	goto cleanup;
             }

             dwStatusCode = 0;

             if (!HttpQueryInfo(hRequest,
                        		  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                				  &dwStatusCode,
                				  &dwStatusLength,
                				  &dwIndex))
             {
              	dwError = GetLastError();
             	total = -1;
               	goto cleanup;
             }

             if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
             {
                fDone = TRUE;
             }
          }
          else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
          {
             fDone = TRUE;
          }
      }
   }

cleanup:   
   if (pRequest)
      pRequest->leaveIOBoundState();

   return total;
}

/*
Set relative/absolute expiration on given URL.
The expiration is derived from the string representation in 2nd parameter
and returned via the out parameter.
*/
int   setExpiration(P3PCURL pszResource, const char *pszExpDate, BOOL fRelative, FILETIME *pftExpires) {

   BOOL success;
   SYSTEMTIME st;

   if (fRelative) {

      union {
         FILETIME ftAbsExpiry;
         unsigned __int64 qwAbsExpiry;
      };

      int maxAgeSeconds = atoi(pszExpDate);

      INTERNET_CACHE_ENTRY_INFO *pInfo = (INTERNET_CACHE_ENTRY_INFO*) new char[EntryInfoSize];
      unsigned long cBytes = EntryInfoSize;

      memset(pInfo, 0, cBytes);
      pInfo->dwStructSize = cBytes;

      /* if we cant get last-sync time from the cache we will
         "fabricate" it by taking current client clock */
      if (GetUrlCacheEntryInfo(pszResource, pInfo, &cBytes))
         ftAbsExpiry = pInfo->LastSyncTime;
      else
         GetSystemTimeAsFileTime(&ftAbsExpiry);

      qwAbsExpiry += (unsigned __int64) maxAgeSeconds * 10000000;
      
      success = setExpiration(pszResource, ftAbsExpiry);
      *pftExpires = ftAbsExpiry;
      delete [] (char*) pInfo;
   }
   else if (InternetTimeToSystemTime(pszExpDate, &st, 0)) {

      SystemTimeToFileTime(&st, pftExpires);
      success = setExpiration(pszResource, *pftExpires);
   }
   return success;
}

/* Set absolute expiry on given URL */
int setExpiration(P3PCURL pszResource, FILETIME ftExpire) {

   INTERNET_CACHE_ENTRY_INFO ceInfo;

   memset(&ceInfo, 0, sizeof(ceInfo));
   ceInfo.dwStructSize = sizeof(ceInfo);
   ceInfo.ExpireTime = ftExpire;
   
   BOOL fRet = SetUrlCacheEntryInfo(pszResource, &ceInfo, CACHE_ENTRY_EXPTIME_FC);
   return fRet;
}

/* Comparison operator for FILETIME structures */
bool operator > (const FILETIME &ftA, const FILETIME &ftB) {

   return (ftA.dwHighDateTime>ftB.dwHighDateTime) ||
            (ftA.dwHighDateTime==ftB.dwHighDateTime && 
             ftA.dwLowDateTime>ftB.dwHighDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\p3pparser.cpp ===
#include <wininetp.h>

#include "p3pparser.h"
#include "policyref.h"
#include "xmlwrapper.h"
#include "download.h"

#include <shlwapi.h>


P3PReference *constructReference(TreeNode *pReference, P3PCURL pszOriginURL, P3PCURL pszReferrer) {

    P3PCURL pszPolicyURL = pReference->attribute("about");

    /* Element name must be "POLICY-REF" and the policy location
       must be present in the "about" attribute */
    if (!pszPolicyURL)
        return NULL;

    /* P3PReference object operates on absolute URLs */
    P3PCHAR achPolicy[URL_LIMIT];
    unsigned long dwSize = sizeof(achPolicy);

    UrlCombine(pszOriginURL, pszPolicyURL, achPolicy, &dwSize, 0);
    
    P3PReference *pResult = new P3PReference(achPolicy);
        
    for (TreeNode *pNode = pReference->child(); pNode; pNode=pNode->sibling()) {

        if (pNode->child()==NULL ||
            pNode->child()->text()==NULL)
            continue;

        int fInclude;           
        const char *pszTagName = pNode->tagname();

        if (!strcmp(pszTagName, "METHOD")) {
            pResult->addVerb(pNode->child()->text());
            continue;
        }
        else if (!strcmp(pszTagName, "INCLUDE"))
            fInclude = TRUE;
        else if (!strcmp(pszTagName, "EXCLUDE"))
            fInclude = FALSE;
        else
            continue;   /* Unrecognized tag */

        /* Create absolute path
           NOTE: we will accept absolute URLs in the INCLUDE/EXCLUDE elements,
           even though P3P spec mandates relative URIs. */
        P3PCURL pszSubtree = pNode->child()->text();

        P3PCHAR achAbsoluteURL[URL_LIMIT];
        DWORD dwLength = URL_LIMIT;

        /* Only spaces are to be escaped because the asterix characters 
           is used as wildcard according to P3P spec */
        UrlCombine(pszReferrer, pszSubtree, 
                   achAbsoluteURL, &dwLength,
                   URL_ESCAPE_SPACES_ONLY);

        if (fInclude)
            pResult->include(achAbsoluteURL);
        else
            pResult->exclude(achAbsoluteURL);
    }

    return pResult;
}

P3PPolicyRef *interpretPolicyRef(TreeNode *pXMLroot, P3PContext *pContext) {

    bool fHaveExpiry = false;
    
    TreeNode *prefRoot = pXMLroot->child();

    if (!prefRoot ||
        strcmp(prefRoot->tagname(), "POLICY-REFERENCES"))
        return NULL;

    P3PPolicyRef *pPolicyRef = new P3PPolicyRef();

    /* Loop over the individual references in this policy-ref */
    TreeNode *pCurrent = prefRoot->child();

    while (pCurrent) {

        if (!strcmp(pCurrent->tagname(), "EXPIRY")) {

            /* Check expiry time and update expiry of cache entry */
            FILETIME ftExpires = {0x0, 0x0}; /* initialized to past */

            /* expiry could be absolute HTTP date or relative max-age in seconds */
            if (const char *pszAbsExpiry = pCurrent->attribute("date"))
               setExpiration(pContext->pszOriginalLoc, pszAbsExpiry, FALSE, &ftExpires);
            else if (const char *pszRelExpiry = pCurrent->attribute("max-age"))
               setExpiration(pContext->pszOriginalLoc, pszRelExpiry, TRUE, &ftExpires);

            /* P3P-compliance: when expiration syntax is not recognized, user agent
               MUST assume the policy has expired.
               If both the conditionals above are false, or parse errors are
               encountered when interpreting the strings, the expiration is
               set to the zero-struct corresponding to a date in the past */               
            pPolicyRef->setExpiration(ftExpires);
            fHaveExpiry = true;
        }
        else if (!strcmp(pCurrent->tagname(), "POLICY-REF")) {
            
           P3PReference *pReference = constructReference(pCurrent, pContext->pszOriginalLoc, pContext->pszReferrer);

           if (pReference)
              pPolicyRef->addReference(pReference);
        }

        pCurrent = pCurrent->sibling();
    }

    /* When policy-ref contains no EXPIRY tag, 
       the default lifetime is assigned */
    if (!fHaveExpiry) {

      /* P3P spec states that default expiry for documents is 24 hours */ 
      const char DefRelativeExp[] = "86400";

      FILETIME ftHTTPexpiry;          
      setExpiration(pContext->pszOriginalLoc, DefRelativeExp, TRUE, &ftHTTPexpiry);
      pPolicyRef->setExpiration(ftHTTPexpiry);
   }

   return pPolicyRef;
}

P3PPolicyRef *interpretPolicyRef(char *pszFileName, P3PContext *pContext) {

   P3PPolicyRef *pObject = NULL;

   IXMLDOMDocument *pDocument = parseXMLDocument(pszFileName);

   if (!pDocument)
      return NULL;

   TreeNode *pParseTree = createXMLtree(pDocument);
   pDocument->Release();

   if (pParseTree && !strcmp(pParseTree->tagname(), "META"))
      pObject = interpretPolicyRef(pParseTree, pContext);

   delete pParseTree;

   return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\p3ppolicy.cpp ===
#include <wininetp.h>

#include "p3ppolicy.h"
#include "download.h"
#include "xmlwrapper.h"

#define  CheckAndRelease(p)    { if (p) p->Release(); }

INTERNETAPI_(int) GetP3PPolicy(P3PCURL pszPolicyURL, HANDLE hDestination, P3PCXSL pszXSLtransform, P3PSignal *pSignal) {

   Policy_Request *pRequest = new Policy_Request(pszPolicyURL, hDestination, pszXSLtransform, pSignal);
   int result = P3P_Error;

   if (pRequest) {
      if (pSignal) {
         DWORD dwThreadID;
         CreateThread(NULL, 0, P3PRequest::ExecRequest, (void*)pRequest, 0, &dwThreadID);
         result = P3P_InProgress;
         pSignal->hRequest = (P3PHANDLE) pRequest;
      }
      else {
         result = pRequest->execute();
         delete pRequest;
      }
   }

   return result;
}


/*
Implementation of Policy_Request object
*/
Policy_Request::Policy_Request(P3PCURL pszP3PPolicy, HANDLE hDest, P3PCXSL pszXSLtransform, P3PSignal *pSignal) 
: P3PRequest(pSignal) {

   this->pszPolicyID = strdup(pszP3PPolicy);
   this->pwszStyleSheet = pszXSLtransform;
   this->hDestination = hDest;

   pszInlineName = strchr(pszPolicyID, '#');
   if (pszInlineName)
      *pszInlineName++ = '\0';
}

Policy_Request::~Policy_Request() {

   free(pszPolicyID);
   endDownload(hPrimaryIO);
}

bool Policy_Request::policyExpired(IXMLDOMDocument *pDocument, const char *pszPolicyID) {

   /* If no expiration is given in the document,
      it defaults to 24hr lifetime (P3Pv1 spec) */
   bool fExpired = false;

   /* Find an EXPIRY element contained in a POLICIES element.
      Simply searching for EXPIRY will not work because in the case
      of inline policies, we can have more than one tag in a document */
   TreeNode *pTree = createXMLtree(pDocument),
            *pPolicies = pTree ?
                         pTree->find("POLICIES") :
                         NULL,
            *pExpiry = pPolicies ? 
                       pPolicies->find("EXPIRY", 1) :
                       NULL;

   if (pExpiry) {

      FILETIME ftExpires = { 0x0, 0x0 };

      if (const char *pszAbsExpiry = pExpiry->attribute("date"))
         setExpiration(pszPolicyID, pszAbsExpiry, FALSE, &ftExpires);
      else if (const char *pszRelExpiry = pExpiry->attribute("max-age"))
         setExpiration(pszPolicyID, pszRelExpiry, TRUE, &ftExpires);

      FILETIME ftNow;
      GetSystemTimeAsFileTime(&ftNow);
      if (ftNow>ftExpires)
         fExpired = true;
   }

   delete pTree;
   return fExpired;
}

int Policy_Request::execute() {

   IXMLDOMElement *pRootNode  = NULL;
   IXMLDOMNode *pPolicyElem   = NULL;
   IXMLDOMDocument *pDocument = NULL;
   
   int result = P3P_Failed;
   char achFinalLocation[URL_LIMIT];
   char achFilePath[MAX_PATH];

   ResourceInfo ri;

   ri.pszFinalURL = achFinalLocation;
   ri.cbURL = URL_LIMIT;
   ri.pszLocalPath = achFilePath;
   ri.cbPath = MAX_PATH;

   int docsize = downloadToCache(pszPolicyID, &ri, &hPrimaryIO, this);

   if (docsize<=0) {
      result = P3P_NotFound;
      goto EndRequest;
   }

   P3PCURL pszFinalURL = achFinalLocation;

   pDocument = parseXMLDocument(achFilePath);

   if (!pDocument) {
      result = P3P_FormatErr;
      goto EndRequest;
   }

   if (policyExpired(pDocument, pszPolicyID)) {
      result = P3P_Expired;
      goto EndRequest;
   }
   
   HRESULT hr;

   /* Inline policy? */
   if (pszInlineName) {

      /* YES-- use XPath query to locate correct name */
      char achXPathQuery[URL_LIMIT];
      
      wsprintf(achXPathQuery, "//POLICY[@name=\"%s\"]", pszInlineName);

      BSTR bsQuery = ASCII2unicode(achXPathQuery);
      hr = pDocument->selectSingleNode(bsQuery, &pPolicyElem);
      SysFreeString(bsQuery);
   }
   else {
      pDocument->get_documentElement(&pRootNode);
      if (pRootNode)
         pRootNode->QueryInterface(IID_IXMLDOMElement, (void**) &pPolicyElem);
   }   

   if (!pPolicyElem) {
      result = P3P_FormatErr;
      goto EndRequest;
   }

   BSTR bsPolicy = NULL;

   /* Apply optional XSL transform */
   if (pwszStyleSheet) {

      /* This XSL transformation only works on XMLDOMDocument objects, not
         fragments or individual XMLDOMNodes. */
      IXMLDOMDocument 
         *pXSLdoc = createXMLDocument(),
         *pPolicyDoc = createXMLDocument();

      if (!(pXSLdoc && pPolicyDoc))
         goto ReleaseXML;
      
      BSTR bsFragment = NULL;
      VARIANT_BOOL 
         fLoadPolicy = FALSE,
         fLoadXSL = FALSE;
      
      pPolicyElem->get_xml(&bsFragment);
      if (bsFragment) {
         pPolicyDoc->loadXML(bsFragment, &fLoadPolicy);
         SysFreeString(bsFragment);
      }
      else
         goto ReleaseXML;

      if (BSTR bsStyleSheet = (BSTR) pwszStyleSheet)
         pXSLdoc->loadXML(bsStyleSheet, &fLoadXSL);

      if (fLoadPolicy && fLoadXSL)
         pPolicyDoc->transformNode(pXSLdoc, &bsPolicy);
      else
         result = P3P_XMLError;

ReleaseXML:
      CheckAndRelease(pPolicyDoc);
      CheckAndRelease(pXSLdoc);
   }
   else if (pPolicyElem)
      pPolicyElem->get_xml(&bsPolicy);
      
   if (bsPolicy) {

      int cbBytes = SysStringByteLen(bsPolicy);

      unsigned long dwWritten;

      /* need BOM (byte order marker) for Unicode content.
         NOTE: this logic assumes we are writing at beggining of a file. */
      WriteFile(hDestination, "\xFF\xFE", 2, &dwWritten, NULL);

      WriteFile(hDestination, bsPolicy, cbBytes, &dwWritten, NULL);

      SysFreeString(bsPolicy);
      result = P3P_Success;
   }

EndRequest:
   /* release the DOM interfaces */
   CheckAndRelease(pPolicyElem);
   CheckAndRelease(pRootNode);
   CheckAndRelease(pDocument);

   /* close the primary-IO handle and set it to NULL */
   endDownload(hPrimaryIO);
   hPrimaryIO = NULL;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\p3ppolicy.h ===
#include "hierarchy.h"
#include "xmlwrapper.h"

class Policy_Request : public P3PRequest {

public:
   Policy_Request(P3PCURL pszPolicyID, HANDLE hDest, P3PCXSL pszXSLtransform=NULL, P3PSignal *pSignal=NULL);
   ~Policy_Request();

   virtual int execute();

private:
   // Request parameters
   P3PURL pszPolicyID;
   P3PCXSL pwszStyleSheet;
   HANDLE hDestination;
   
   // Derived from policy-ID
   P3PURL pszInlineName;

   // State of the request
   HANDLE   hPrimaryIO;

   /* Helper function */
   static bool policyExpired(IXMLDOMDocument *pDocument, const char *pszPolicyURL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\xmltree.cpp ===
#include <wininetp.h>

#include "p3pglobal.h"
#include "xmltree.h"

const char *EmptyString = "";

TreeNode::TreeNode() {

   pSibling = pDescendant = pParent = NULL;

   pAttribute = NULL;

   pszContents = NULL;
}

TreeNode::~TreeNode() {

   for (TreeNode *pn = pDescendant; pn; ) {

      TreeNode *temp = pn->pSibling;
      delete pn;
      pn = temp;
   }

   for (XMLAttribute *pa = pAttribute; pa; ) {

      XMLAttribute *temp = pa->pNext;

      free(pa->pszName);
      free(pa->pszValue);
      delete pa;
      pa = temp;
   }

   if (pszContents)
      free(pszContents);
}

void TreeNode::setContent(const char *pszData) {

   if (pszContents)
      free(pszContents);
   pszContents = pszData ? strdup(pszData) : NULL;
}

void TreeNode::defineAttribute(const char *pszName, const char *pszValue) {

    XMLAttribute *pNewAttribute = new XMLAttribute();

    pNewAttribute->pszName = strdup(pszName);
    pNewAttribute->pszValue = strdup(pszValue);

    pNewAttribute->pNext = pAttribute;

    /* Insert at beginning of attribute list */
    pAttribute = pNewAttribute;
}


const char *TreeNode::attribute(const char *pszAttrName) {

   for (XMLAttribute *pa = pAttribute; pa; pa=pa->pNext) {

      if (!strcmp(pa->pszName, pszAttrName))
         return pa->pszValue;
   }
   
   return NULL;
}

TreeNode *TreeNode::find(const char *pszElemName, unsigned int maxDepth) {

   /* fail search if the current node does not represent an XML tag... */
   if (nodetype!=NODE_ELEMENT)
      return NULL;
   else if (!strcmp(pszContents, pszElemName))
      return this;   /* this is the node we are looking for */
   else if (maxDepth>0) {
      /* otherwise recursively search descendants... */
      if (maxDepth!=INFINITE)
         maxDepth--;
         
      for (TreeNode *pn=pDescendant; pn; pn=pn->pSibling)
         if (TreeNode *pNode = pn->find(pszElemName))
            return pNode;
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\xmltree.h ===
#ifndef _XMLTREE_H_
#define _XMLTREE_H_

struct IXMLDOMNode;

struct XMLAttribute {

   char *pszName;
   char *pszValue;
   XMLAttribute *pNext;

   XMLAttribute() : pszName(NULL), 
                    pszValue(NULL), 
                    pNext(NULL) {}
};

extern const char *EmptyString;

class TreeNode {

public:
   TreeNode();
   
   const char *attribute(const char *pszAttrName);

   inline const char *text()     { return pszContents; }

   inline const char *tagname()  { return (nodetype==NODE_ELEMENT) ? 
                                   pszContents : 
                                   EmptyString; }

   inline TreeNode *sibling() { return pSibling; }
   inline TreeNode *child()   { return pDescendant; }

   ~TreeNode();

   /* find first node with given element name */
   TreeNode *find(const char *pszElemName, unsigned int maxDepth=INFINITE);

protected:
   void defineAttribute(const char *pszName, const char *pszValue);
   void setContent(const char *pszData);
   
private:
   TreeNode *pDescendant, *pSibling, *pParent;
   char *pszContents;
   int  nodetype;

   XMLAttribute *pAttribute;

   friend class XMLTree;
   friend TreeNode *createXMLtree(IXMLDOMNode *pXMLnode, TreeNode *pParent);
   friend int defineAttributes(TreeNode *pCurrent, IXMLDOMNode *pXMLnode);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\policyref.cpp ===
#include <wininetp.h>

#include "policyref.h"

#include <stdlib.h>
#include <string.h>

#pragma warning(disable:4800)

/*
Determine whether given string matches the pattern in second argument
The only wildcard allowed is "*" which stands for zero or more characters
(equivalent to the regular-expression construct "(.*)"

The algorithm here breaks up the pattern into a series of asteriks-seperated
literals and tries to locate each literal inside the search string.
There could be multiple occurences of any given literal but the
algorithm uses the first (eg earliest occurring) match.
*/
bool matchWildcardPattern(const char *str, const char *pattern) {

   if (!pattern || !str)
      return false;

   /* Degenerate case: empty pattern always matches */
   if (*pattern=='\0')
      return true;

   /* Duplicate the pattern because we will need to change it */
   char *ptrndup = strdup(pattern);

   int plen = strlen(ptrndup);
   char *ptrnend = ptrndup+plen; /* Points to nil-terminator at end of pattern */

   char *beginLiteral, *endLiteral;
   const char *marker;

   bool fMatch = false;

   beginLiteral = ptrndup;

   // We will scan the source string starting from the beginning
   marker = str;

   while (true) {

      endLiteral = strchr(beginLiteral,'*');
      if (!endLiteral)
         endLiteral = ptrnend;      

      // Overwrite asteriks with nil-character to terminate the substring
      *endLiteral = '\0';

      // Segment length does not include the nil-terminator
      size_t segmentLen = endLiteral-beginLiteral;
      
      // Search for current segment within the source string
      // Failure means that the pattern does not match-- BREAK the loop
      marker = strstr(marker, beginLiteral);
      if (!marker)
         break;

      // The first literal segment MUST appear at beginning of source string
      if (beginLiteral==ptrndup && marker!=str)
         break;

      // Found: advance pointer along the source string
      marker += segmentLen;

      // Restore the asterix in pattern
      *endLiteral = '*';

      // Move on to next literal in the pattern, which starts
      // after the asteriks in the current literal
      beginLiteral = endLiteral+1;

      // If we have matched all the literal sections in the pattern
      // then we have a match IFF 
      // 1. End of source string is reached   OR
      // 2. The pattern ends with an asterix
      if (beginLiteral>=ptrnend)
      {
         fMatch = (*marker=='\0') || (ptrnend[-1]=='*');
         break;
      }
   }

   free(ptrndup);
   return fMatch;
}


/*
Implementation of P3PReference class
*/
P3PReference::P3PReference(P3PCURL pszLocation) {

   pszPolicyAbout = strdup(pszLocation);
   pHead = NULL;
   fAllVerbs = true;
}

P3PReference::~P3PReference() {

   free(pszPolicyAbout);

   /* Free constraint list */
   Constraint *pc, *next=pHead;
   while (pc=next) {
      next = pc->pNext;
      delete pc;
   }
}

void P3PReference::addPathConstraint(P3PCURL pszSubtree, bool fInclude) {

   Constraint *pc = new Constraint();
   if (!pc)
      return;

   /* This is a path constraint */
   pc->fPath = TRUE;
   pc->pszPrefix = strdup(pszSubtree);
   pc->fInclude = fInclude ? TRUE : FALSE;

   addConstraint(pc);
}

void P3PReference::addConstraint(Constraint *pc) {

   /* Insert at beginning of linked list 
      (Constraint ordering is not significant because they are evaluated
      until one fails) */
   pc->pNext = pHead;
   pHead = pc;
}

void P3PReference::include(P3PCURL pszSubtree) {

   addPathConstraint(pszSubtree, true);
}

void P3PReference::exclude(P3PCURL pszSubtree) {

   addPathConstraint(pszSubtree, false);
}

void P3PReference::addVerb(const char *pszVerb) {

   Constraint *pc = new Constraint();
   if (!pc)
      return;

   /* This is a verb constraint */
   pc->fPath = FALSE;
   pc->pszVerb = strdup(pszVerb);

   addConstraint(pc);
   fAllVerbs = false;
}

bool P3PReference::applies(P3PCURL pszAbsoluteURL, const char *pszVerb) {

   bool fVerbMatch = this->fAllVerbs;
   bool fPathMatch = false;

   /* Scan through the constraint list */
   for (Constraint *pc = pHead; pc; pc=pc->pNext) {

      if (pc->fPath) {

         bool fMatch = matchWildcardPattern(pszAbsoluteURL, pc->pszPrefix);

         /* If the constraint requires the URL to be excluded from that subtree,
            the pattern match must fail. Otherwise the constraint is not satisfied.
            If one path constraint is violated, we can return immediately.
            Otherwise the loop continues.
          */
         if (pc->fInclude && fMatch)
            fPathMatch = true;
         else if (!pc->fInclude && fMatch)
             return false;
      }
      else  
          /* Otherwise this is a verb constraint */
         fVerbMatch = fVerbMatch || !stricmp(pc->pszVerb, pszVerb);
   }
   
   /* The reference applies only if the path constraint is satisfied
      (eg the given URL is included in at least one constraint and not
      excluded by any of the negative constraints) AND verb constraint
      is satisfied */
   return fPathMatch && fVerbMatch;
}


/*
Implementation of P3PPolicyRef class
*/
P3PPolicyRef::P3PPolicyRef() {

   pHead = pLast = NULL;
   ftExpires.dwLowDateTime = ftExpires.dwHighDateTime = 0x0;
}

P3PPolicyRef::~P3PPolicyRef() {

   for (P3PReference *temp, *pref = pHead; pref; ) {
      temp = pref->pNext;
      delete pref;
      pref = temp;
   }
}

void P3PPolicyRef::addReference(P3PReference *pref) {

   /* Order of references in a policy-ref files IS significant.
      The references must be added/evaluated in the same order as 
      they appear in the XML document */
   if (pHead==NULL)
      pHead = pLast = pref;
   else {

      pLast->pNext = pref;
      pLast = pref;
   }

   pref->pNext = NULL;
}

P3PCURL P3PPolicyRef::mapResourceToPolicy(P3PCURL pszResource, const P3PVERB pszVerb) {

   for (P3PReference *pref = pHead; pref; pref=pref->pNext)
      if (pref->applies(pszResource, pszVerb))
         return pref->about();

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\xmlwrapper.h ===
#ifndef _XMLWRAPPER_H_
#define _XMLWRAPPER_H_

#include "p3pglobal.h"
#include "xmltree.h"

#include <objbase.h>
#include <msxml.h>

typedef wchar_t XMLchar;

IXMLDOMDocument *createXMLDocument();
IXMLDOMDocument *parseXMLDocument(char *pszFileName);

TreeNode *createXMLtree(IXMLDOMDocument *pDocument);

char *unicode2ASCII(XMLchar *pwszSource);
BSTR ASCII2unicode(const char *pszSource);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\policyref.h ===
#ifndef _POLICYREF_H_
#define _POLICYREF_H_

#include "p3pglobal.h"
#include "hierarchy.h"

class P3PReference {

public:
   P3PReference(P3PCURL pszPolicy);
   ~P3PReference();
   
   void include(P3PCURL pszSubtree);
   void exclude(P3PCURL pszSubtree);
   void addVerb(const char *pszVerb);

   bool applies(P3PCURL pszAbsoluteURL, const char *pszVerb=NULL);

   inline P3PCURL about() { return pszPolicyAbout; }

private:
   struct Constraint {

      union {
         P3PURL   pszPrefix;     // URL prefix (including wildcards)
         char    *pszVerb;       // Allowed verb
       };

      int      fPath    :1;      // True if this is a path constraint
      int      fInclude :1;      // Switch determines whether this subtree is include/exclude

      Constraint *pNext;         // Pointer to next constraint
   };

   void  addPathConstraint(P3PCURL pszSubtree, bool fInclude);
   void  addConstraint(Constraint *pc);

   Constraint *pHead;
   
   P3PReference *pNext;
   bool fAllVerbs;
   P3PURL pszPolicyAbout;

   friend class P3PPolicyRef;
};

class P3PPolicyRef : public P3PObject {

public:
   P3PPolicyRef();
   ~P3PPolicyRef();

   void    addReference(P3PReference *pr);
   P3PCURL mapResourceToPolicy(P3PCURL pszResource, const P3PVERB pszVerb=NULL);

   void    setExpiration(FILETIME ft)  { ftExpires = ft; }
   FILETIME getExpiration() const      { return ftExpires; }

private:
   P3PReference *pHead, *pLast;
   FILETIME ftExpires;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\request.cpp ===
#include <wininetp.h>

#include "hierarchy.h"

P3PRequest::P3PRequest(P3PSignal *pSignal) {

   hComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
   status = P3P_NotStarted;

   if (pSignal)
      retSignal = *pSignal;
   else
      memset(&retSignal, 0, sizeof(retSignal));

   InitializeCriticalSection(&csRequest);
   fRunning = TRUE;
   fCancelled = FALSE;
   fIOBound = FALSE;
}

P3PRequest::~P3PRequest() {

   CloseHandle(hComplete);
   DeleteCriticalSection(&csRequest);
}

void P3PRequest::Free() {

   EnterCriticalSection(&csRequest);

   if (!fRunning) {
      /* Important: leave critical-section first...
         self-destruction ("delete this") will free the CS */
      LeaveCriticalSection(&csRequest);
      delete this;
      return;
   }

   fCancelled = TRUE;
   BOOL fBlocked = fIOBound;
   LeaveCriticalSection(&csRequest);

   /* If request is CPU-bound, wait until it completes or aborts.
      Returning before that point would mean that client can free
      parameters passed into the request, causing worker thread to
      access deallocated resources */
   if (!fBlocked)
      waitForCompletion();
}

/* block until the request is finished */
void P3PRequest::waitForCompletion() {

   WaitForSingleObject(hComplete, INFINITE);
}

/* this wrapper function calls execute and signals the completion event
   afterwards. its invoked by the static function ExecRequest  */
int P3PRequest::run() {

   CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

   status = P3P_InProgress;

   __try {
      status = execute();
   } __except (EXCEPTION_EXECUTE_HANDLER) {
      /* catch exception thrown from cancelled request */
      status = P3P_Cancelled;
   }
   ENDEXCEPT

   CoUninitialize();
   return status;
}

unsigned long __stdcall P3PRequest::ExecRequest(void *pv) {

   P3PRequest *pRequest = (P3PRequest*) pv;

   int status = pRequest->run();

   EnterCriticalSection(& pRequest->csRequest);

   /* modify state of the request */
   pRequest->fRunning = FALSE;

   /* remember whether the request is cancelled.
      we cannot examine pRequest object after leaving the critical
      section because of possible race condition where FreeP3PObject()
      can invoke the destructor. */
   BOOL fWasCancelled = pRequest->fCancelled;

   /* signal callers that request is complete */
   if (!fWasCancelled) {

      P3PSignal retSignal = pRequest->retSignal;

      if (retSignal.hEvent)
         SetEvent(retSignal.hEvent);
      if (retSignal.hwnd)
         PostMessage(retSignal.hwnd, retSignal.message, status, (WPARAM) retSignal.pContext);
   }

   SetEvent(pRequest->hComplete);

   LeaveCriticalSection(& pRequest->csRequest);

   /* A cancelled request will be freed on the same thread 
      that it executed on. All other threads get freed on the
      thread where FreeP3PObject() is invoked. */
   if (fWasCancelled)
      delete pRequest;

   return status;
}

void   P3PRequest::enterIOBoundState() {

   EnterCriticalSection(&csRequest);
   if (!fCancelled)
      fIOBound = TRUE;
   BOOL fWasCancelled = fCancelled;
   LeaveCriticalSection(&csRequest);

   /* throw exception if request has been cancelled */
   if (fWasCancelled)
      throw P3P_Cancelled;
}

void   P3PRequest::leaveIOBoundState() {

   EnterCriticalSection(&csRequest);
   fIOBound = FALSE;
   BOOL fWasCancelled = fCancelled;
   LeaveCriticalSection(&csRequest);

   /* throw exception if request has been cancelled */
   if (fWasCancelled)
      throw P3P_Cancelled;     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\socks\makefile.inc ===
!IFNDEF BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!ENDIF

!IFNDEF SDKINC
SDKINC=$(BASEDIR)\public\sdk\inc
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\perf\inetdown\inetdown.h ===
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Status Constants
#define CONNECTED       1
#define CONNECTING      2
#define REQUEST_OPENING 3
#define REQUEST_OPENED  4
#define LDG_STARTING    5
#define LDG_START       6
#define LDG_LDG         7
#define LDG_RDY         8 
#define LDG_DONE        9

// Priority Constants
#define LOW    1
#define MEDIUM 2
#define HIGH   3

#define BUF_SIZE 8192
#define BUF_NUM 16

#define URLMAX 4
#define TIMEOUT  60000

#define MAX_SCHEME_LENGTH 64

//MESSAGE ID'S
#define DOWNLOAD_DONE         WM_USER + 1
#define DOWNLOAD_OPEN_REQUEST WM_USER + 2
#define DOWNLOAD_SEND_REQUEST WM_USER + 3
#define DOWNLOAD_READ_FILE    WM_USER + 4


typedef struct
{
    TCHAR    *pURLName;     //The name of the URL
    TCHAR    szRHost[INTERNET_MAX_HOST_NAME_LENGTH]; //from crackUrl
    TCHAR    szRPath[INTERNET_MAX_PATH_LENGTH];      //from crackUrl
    TCHAR    szRScheme[MAX_SCHEME_LENGTH];           //from crackUrl
    INTERNET_PORT nPort;                             //from crackUrl
    INTERNET_SCHEME nScheme;                         //from crackUrl
    void *pNext;                                     //pointer to next element
} url_info;

typedef struct
{
    url_info *pHead;
} url_info_cache;

typedef struct
{
    url_info *pURLInfo;     //Url info struct
    INT      iStatus;       //the url's status
    INT      iPriority;     //the url's priority
                            // LOW, MEDIUM, or HIGH
    DWORD    lNumRead;   //number of bytes read in buffer
    void     *pNext;        //pointer to next element
    HINTERNET hInetCon;     //Internet connection
    HINTERNET hInetReq;     //Internet Request
} outQ;

//
void callOpenRequest(outQ *pOutQ);
void callSendRequest(outQ *pOutQ);
void callReadFile(outQ *pOutQ);
BOOL getServerName(outQ *pOutQ);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\p3p\xmlwrapper.cpp ===
#include <wininetp.h>

#include "xmlwrapper.h"


IXMLDOMDocument *createXMLDocument() {

   IXMLDOMDocument *pDocument = NULL;

   HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**) &pDocument);

   /* if COM library was not initialized, retry after init */
   if (hr==CO_E_NOTINITIALIZED) {
      CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
      hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**) &pDocument);
   }

   return pDocument;
}

IXMLDOMDocument *parseXMLDocument(char *pszFileName) {

   IXMLDOMDocument *document = createXMLDocument();

   if (!document)
      return NULL;

   /* Do not perform DTD or schema validation on P3P files */
   document->put_validateOnParse(FALSE);

   /* Open the file */
   HANDLE hf = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ,
                          NULL, OPEN_EXISTING, 0, NULL);

   if (hf!=INVALID_HANDLE_VALUE) {

      /* Obtain stream from the XML document and write out
         contents of the file to stream */
      IStream *pStream = NULL;

      HRESULT hr = document->QueryInterface(IID_IStream, (void**) &pStream);
   
      if (SUCCEEDED(hr))
      {
         unsigned char xmldata[1024];
         DWORD dwBytes, dwWritten;
 
         do {
             ReadFile(hf, xmldata, sizeof(xmldata), &dwBytes, NULL);
             pStream->Write(xmldata, dwBytes, &dwWritten);
             if (dwBytes!=dwWritten)
                 break;
         }
         while (dwBytes>0);
   
         pStream->Release();
      }

      CloseHandle(hf);
   }

   return document;
};

int defineAttributes(TreeNode *pCurrent, IXMLDOMNode *pXMLnode) {

   int cAttribute = 0;

   IXMLDOMNamedNodeMap *pAttributeMap = NULL;
   
   HRESULT hr = pXMLnode->get_attributes(&pAttributeMap);   

   if (SUCCEEDED(hr) && pAttributeMap) {

      long cItems;
      IXMLDOMNode *pNode;
      IXMLDOMAttribute *pAttribute;

      pAttributeMap->get_length(&cItems);

      for (int i=0; i<cItems; i++) {

         pNode = pAttribute = NULL;
         pAttributeMap->get_item(i, &pNode);

         if (pNode) {

            pNode->QueryInterface(IID_IXMLDOMAttribute, (void**) &pAttribute);

            if (pAttribute) {
            
               BSTR bsName = NULL;
               pAttribute->get_name(&bsName);

               VARIANT var;
               VariantInit(&var);
               pAttribute->get_value(&var);

               char *pszName = unicode2ASCII(bsName);
               char *pszValue = (var.vt==VT_BSTR) ? unicode2ASCII(var.bstrVal) : NULL;

               pCurrent->defineAttribute(pszName, pszValue);
   
               delete [] pszName;
               delete [] pszValue;

               SysFreeString(bsName);
               VariantClear(&var);

               pAttribute->Release();
               cAttribute++;
            }

            pNode->Release();
         }
      }

      pAttributeMap->Release();
   }

   return cAttribute;
}

TreeNode *createXMLtree(IXMLDOMNode *pXMLnode, TreeNode *pParent = NULL) {

   HRESULT hr;

   if (!pXMLnode)
      return NULL;
   
   DOMNodeType dt;
   pXMLnode->get_nodeType(&dt);

   if (dt!=NODE_ELEMENT &&
       dt!=NODE_TEXT    &&
       dt!=NODE_CDATA_SECTION)
      return NULL;
   
   TreeNode *pTree = new TreeNode();
   pTree->nodetype = dt;

   switch (dt) {

   case NODE_ELEMENT: {


         IXMLDOMElement *pElement;
         hr = pXMLnode->QueryInterface(IID_IXMLDOMElement, (void**) &pElement);

         if (SUCCEEDED(hr)) {

            BSTR bsName = NULL;
            pElement->get_tagName(&bsName);

            if (bsName) {
               char *pszTagName = unicode2ASCII(bsName);
               pTree->setContent(pszTagName);
               delete [] pszTagName;
               SysFreeString(bsName);
            }
            
            pElement->Release();
         }
         break;
      }
      
   case NODE_TEXT:
   case NODE_CDATA_SECTION: {

         IXMLDOMCharacterData *pCharData = NULL;
         hr = pXMLnode->QueryInterface(IID_IXMLDOMCharacterData, (void**) &pCharData);

         if (SUCCEEDED(hr)) {

             BSTR bsData = NULL;
             pCharData->get_data(&bsData);

             if (bsData) {
                 pTree->pszContents = unicode2ASCII(bsData);
                 SysFreeString(bsData);
             }
             pCharData->Release();
         }

         break;
      }
   }

   /* Enumerate attributes */
   defineAttributes(pTree, pXMLnode);

   /* Recursively create nodes for descendants */
   TreeNode *pLast = NULL;
   IXMLDOMNode *pChild = NULL;

   pXMLnode->get_firstChild(&pChild);

   while (pChild) {
       
      if (TreeNode *pDescendant = createXMLtree(pChild, pTree)) {

         if (pLast)
            pLast->pSibling = pDescendant;
         pLast = pDescendant;

         if (! pTree->pDescendant)
             pTree->pDescendant = pDescendant;
      }

      IXMLDOMNode *pTemp = pChild;
      hr = pChild->get_nextSibling(&pChild);
      pTemp->Release();
      if (!SUCCEEDED(hr))
         break;
   }

   return pTree;
}


TreeNode *createXMLtree(IXMLDOMDocument *pDocument) {

   IXMLDOMElement *pElement = NULL;
   TreeNode *pRoot = NULL;

   HRESULT hr = pDocument->get_documentElement(&pElement);

   if (pElement) {

      pRoot = createXMLtree(pElement);
      pElement->Release();
   }
   
   return pRoot;
}


/*
Utility functions
*/

char *unicode2ASCII(XMLchar *pwszSource) {

   if (!pwszSource)
      return NULL;

   char *pszDestination = NULL;

   int cRequired = WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, pszDestination, 0, NULL, NULL);

   if (cRequired>0 && (pszDestination = new char[cRequired]))
      WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, pszDestination, cRequired, NULL, NULL);
  
   return pszDestination;
}

BSTR ASCII2unicode(const char *pszSource) {

   int cRequired = MultiByteToWideChar(CP_ACP, 0, pszSource, -1, NULL, 0);

   if (cRequired==0)
      return NULL;

   BSTR bsResult = SysAllocStringLen(NULL, cRequired);

   if (bsResult)
      MultiByteToWideChar(CP_ACP, 0, pszSource, -1, bsResult, cRequired);      
   
   return bsResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\401imprt.cxx ===
#include <cache.hxx>

#include "401imprt.hxx"
#include "401inc.hxx"

#ifdef UNICODE
#error "401imprt.cxx doesn't support UNICODE compilation."
#endif

#define PRE5_CACHE_KEY  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache"
#define IE401_HIST_ROOT "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache"

//IE401_PER_USER_CACHE_LOCATION is in HKCU
#define IE401_PER_USER_CACHE_LOCATION \
        "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"
#define IE401_PER_USER_CACHE_KEY "Cache"
//IE401_ONE_USER_CACHE_LOCATION is in HKLM
#define IE401_ONE_USER_CACHE_LOCATION \
        "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Content"
#define IE401_ONE_USER_CACHE_KEY "CachePath"

#define MSHIST_DIR_SZ       "MSHIST011998020119980225"##FILENAME_SEPARATOR_STR
#define MSHIST_KEY_SZ       "MSHIST011998020119980225"
#define MSHIST_SZ           "MSHIST"
#define MSHIST_PREFIX_SZ    ":1998010119980101:"
#define VISITED_PREFIX_SZ   "Visited:"
#define INDEX_DAT_SZ        "index.dat"
#define CACHE_LIMIT_SZ      "CacheLimit"
#define CACHE_OPTIONS_SZ    "CacheOptions"
#define CACHE_PATH_SZ       "CachePath"
#define CACHE_PREFIX_SZ     "CachePrefix"

//----------------------------------------
//The following tructures and macro, _HISTDATA_V001 and SET_HISTORY_FLAG()
//allow us to notify members of the Visited: cache that they are to be
//listed in the History view.  The structure was cut'n'pasted from
//shdocvw\urlhist.cpp and any changes made to the original need
//to be reflected here as well.
#define PIDISF_HISTORY 0x10000000
#define PID_INTSITE_TITLE         16
//** BUGBUG

struct _HISTDATA_V001
{
    UINT  cbSize : 16;           // size of this header
    UINT  cbVer  : 16;           // version
    DWORD           dwFlags;    // PID_INTSITE_FLAGS (PIDISF_ flags)
    DWORD           dwWatch;    // PID_INTSITE_WATCH (PIDISM_ flags)
    DWORD           dwVisits;   // PID_INTSITE_VISITCOUNT
};

#define SET_HISTORY_FLAG(lpHeaderInfo) \
            (((_HISTDATA_V001*)lpHeaderInfo)->dwFlags |= PIDISF_HISTORY)

//
//  Right after HISTDATA (always at cbSize), we have optional (typically
// variable length) data which has following data structure. It may have
// more than one but always has a null-terimiator (cbExtra == 0).
//
//HISTEXTRA is also cut'n'pasted from shdocvw.
struct HISTEXTRA
{
    UINT cbExtra : 16;
    UINT idExtra : 8;   // PID_INTSITE_*
    UINT vtExtra : 8;   // VT_*
    BYTE abExtra[1];    // abExtra[cbExtra-4];
};

// HISTEXTRA without the abExtra  ==> (sizeof(HISTEXTRA) - sizeof(BYTE))
#define HISTEXTRA_HEAD_SIZE 4
//-----------------------------------------


BOOL IsPerUserCache();

namespace ie401
{


//--------------------------------------------------------

//  The code that enumerates through a IE401 index.dat file is provided
//by IE401IndexFile.  Classes derived from IE401IndexFile override HandleHashElement
//to handle each HASH_ELEMENT as the index file is enumerated.
//  IE401IndexFile::Import401Url is provided to import URLs without overwriting
//already existing entries.

class IE401IndexFile
{
public:
    //  EnumHashValues enumerates hash tables, calling HandleHashElement for each.
    virtual BOOL EnumHashValues();

protected:
    IE401IndexFile( LPCSTR szFilename);
    IE401IndexFile();
    virtual ~IE401IndexFile();

    //  given by derived class
    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry) = 0;

    //  probably useful to many, default URL import.  Not for REDIRs.
    virtual BOOL Import401Url( ie401::URL_FILEMAP_ENTRY* pEntry);

    BYTE* m_pBuf;
};


//--------------------------------------------------------

//  IE401Visited overrides HandleHashElement to import all URLs,
//translating CEI to its current format.
//  All the dependencies on the change in CEI format are
//contained in UpgradeHeaderData.

class IE401Visited : public IE401IndexFile
{
public:
    IE401Visited( LPCSTR szFilename);

protected:
    IE401Visited() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    virtual BOOL Import401UrlTranslatingCEI( ie401::URL_FILEMAP_ENTRY* pEntry);

    virtual BOOL UpgradeHeaderData(
            IN      const CHAR* pIn,
            OUT     CHAR* pOut,
            IN OUT  DWORD* pcbOutSize);
};


//--------------------------------------------------------

//  IE401History overrides HandleHashElement to import all URLs
//and mark them in the Visited: container.
//  All the dependencies on the format for the Visited mark
//are contained in MarkUrlAsVisited.
//(colliding items are not imported and associated data
//files are not copied.)

class IE401History : public IE401IndexFile
{
public:
    IE401History( LPCSTR szFilename);

protected:
    IE401History() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    static BOOL MarkUrlAsVisited( LPSTR szUrlName);
};


//--------------------------------------------------------


// pre-declaration included so IE401Redirects can be declared as a friend
class IE401Redirects;


//  IE401Content overrides HandleHashElement to import all URLs
//and also copy associated data files.
//(colliding items are not imported)
class IE401Content : public IE401IndexFile
{
public:
    IE401Content( LPCSTR szFilename);

    friend IE401Redirects;

protected:
    IE401Content() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    //  Extends the default to import files
    BOOL Import401UrlWithFile( ie401::URL_FILEMAP_ENTRY* pEntry);

    CHAR  m_szRootPath[MAX_PATH];
    DWORD m_cbRootPathLength;
    DWORD m_nDirs;
    CHAR  m_szDir[DEFAULT_MAX_DIRS][DIR_NAME_SIZE + 1];
};


//--------------------------------------------------------


//  IE401Redirects override HandleHashElement to import redirects.
//  This should be done to an index file after IE401Content has
//enumerated over it, so the constructor takes a IE401Content object
//rather than a filename.  This IE401Content represents a process
//that is finished, so its functionality is taken away.
//  Importing redirects is done with a separate enumerator than
//IE401Content since its less work then retooling IE401IndexFile
//to enumerate an arbitrary number of times.
class IE401Redirects : public IE401IndexFile
{
public:
    IE401Redirects( IE401Content* pContent);

protected:
    IE401Redirects() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    BOOL Import401Redirect( ie401::REDIR_FILEMAP_ENTRY* pEntry);
};


//******************************************************
//
// class OutputStream  - utility
//
//  outputs data to a buffer, tracking buffer used
//and checking for overflow.


class OutputStream
{
public:
    OutputStream( VOID* pBuffer, DWORD cbBufferSize)
    : m_pBuffer( (BYTE*)pBuffer), m_cbBufferSize( cbBufferSize), m_cbPosition(0)
    {
    }

    BOOL Memcpy( const VOID* pSource, DWORD cbSize)
    {
        if( cbSize + m_cbPosition <= m_cbBufferSize)
        {
            memcpy(&m_pBuffer[m_cbPosition], (BYTE*)pSource, cbSize);
            m_cbPosition += cbSize;
            return TRUE;
        }
        else
            return FALSE;
    }

    BOOL CopyAnsiToUnicode( const CHAR* pSource, DWORD cSize)
    {
        if( m_cbPosition + cSize * sizeof(WCHAR) / sizeof(CHAR)
            <= m_cbBufferSize)
        {
            DWORD dwSizeCopied;

            // the semantics of MultiByteToWideChar is different
            //if you give it a zero-length buffer.
            INET_ASSERT( m_cbBufferSize - m_cbPosition != 0);

            dwSizeCopied =
                MultiByteToWideChar( CP_ACP, 0, pSource, cSize,
                    (WCHAR*)&m_pBuffer[m_cbPosition],
                    (m_cbBufferSize - m_cbPosition) / sizeof(WCHAR));

            if( dwSizeCopied != 0)
            {
                m_cbPosition += dwSizeCopied * sizeof(WCHAR);
                return TRUE;
            }
            else
                return FALSE;
        }
        else
            return FALSE;
    }

    DWORD GetFinalLength()
    {
        return m_cbPosition;
    }

private:
    BYTE* m_pBuffer;

    DWORD m_cbBufferSize, m_cbPosition;
};


//*************************************************************************
//
//  IE401IndexFile
//

//  On creation, load the contents of the given file into memory.

IE401IndexFile::IE401IndexFile( LPCSTR szFilename)
{
    m_pBuf = NULL;

    //  load the file into the buffer
    DWORD cbBufSize;
    if( ReadFileToBuffer( szFilename, &m_pBuf, &cbBufSize) == FALSE)
    {
        if( m_pBuf != NULL)
        {
            delete [] m_pBuf;
            m_pBuf = NULL;
        }
    }
    else if( cbBufSize < sizeof(_MEMMAP_HEADER_SMALL)
        || strcmp((LPSTR) m_pBuf, "Client UrlCache MMF Ver 4.7"))
    {
        //  If this file doesn't even have a memmap header, forget it.
        //  Now all derived classes can assume they have at least a memmap header
        //if m_pBuf != NULL
        delete [] m_pBuf;
        m_pBuf = NULL;
    }
}


//  Default constructor made protected to prevent direct creation
IE401IndexFile::IE401IndexFile()
: m_pBuf(NULL)
{
}


IE401IndexFile::~IE401IndexFile()
{
    if( m_pBuf != NULL)
        delete [] m_pBuf;
}


//---------------------------------------------------
//

//  Enumerate through the entries in an ie401 index
//file, calling HandleHashElement on each entry.

BOOL IE401IndexFile::EnumHashValues()
{
    BOOL retVal = FALSE;

    if( m_pBuf == NULL)
        goto doneEnumHashValues;

    HASH_FILEMAP_ENTRY* pTable;
    HASH_ITEM* pItem;
    //  pTable is located by an offset which is located at dwHashTableOffset
    pTable = (HASH_FILEMAP_ENTRY*)(m_pBuf + (((_MEMMAP_HEADER_SMALL*)m_pBuf)->dwHashTableOffset));
    // The first location in the table follows immediately after the HASH_FILEMAP_ENTRY pTable
    pItem = (HASH_ITEM*)(pTable + 1);

    if (pTable->dwSig != SIG_HASH)
        goto doneEnumHashValues;

    do // Scan the list of tables.
    {
        // Scan the current table.
        for (; (LPBYTE)pItem < (LPBYTE)pTable + BYTES_PER_TABLE; pItem++)
        {
            //  call virtual entry handler
            if( HandleHashElement( pItem) == FALSE)
                goto doneEnumHashValues;
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
        {
            pTable = NULL;
        }
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock;
            nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (m_pBuf + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                goto doneEnumHashValues;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
    while (pTable);

    retVal = TRUE;

doneEnumHashValues:
    return retVal;
}


//---------------------------------------------------
//


//  Imports an URL entry without overwriting existing
//cache entries or copying any associated data files.

BOOL IE401IndexFile::Import401Url( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
        goto doneImport401Url;
    }

    if( pEntry->FileSize != 0)
    {
        INET_ASSERT(0);  // Are you importing URL cache entries with external data?
        goto doneImport401Url;
    }

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            pEntry->HeaderInfoOffset != NULL ?
                (BYTE*)((BYTE*)pEntry + pEntry->HeaderInfoOffset) : NULL,
            pEntry->HeaderInfoSize,
            pEntry->FileExtensionOffset != 0 ?
                (LPCSTR)((BYTE*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401Url;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
       goto doneImport401Url;

    retVal = TRUE;

doneImport401Url:
    return retVal;
}


//************************************************************************8
//
//  IE401Visited : public IE401IndexFile
//

IE401Visited::IE401Visited( LPCSTR szFilename) : IE401IndexFile( szFilename)
{
}


//  imports only URLs using Import401Url- nothing special
BOOL IE401Visited::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        Import401UrlTranslatingCEI( (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//----------------------------------------
//
//  IE401Visited::Import401UrlTranslatingCEI
//
//  Very much like Import401Url except it makes
//a call to UpgradeHeaderData before calling CommitCacheEntry.

BOOL IE401Visited::Import401UrlTranslatingCEI( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
        goto doneImport401UrlTranslatingCEI;
    }

    if( pEntry->FileSize != 0)
    {
        INET_ASSERT(0);  // Are you importing URL cache entries with external data?
        goto doneImport401UrlTranslatingCEI;
    }

    DWORD cbHeaderBufSize;
    //BUGBUG:  Does shdocvw still obey MAX_CACHE_ENTRY_INFO_SIZE
    //in the version being imported?
    CHAR szHeaderBuf[ MAX_CACHE_ENTRY_INFO_SIZE];
    cbHeaderBufSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if( pEntry->HeaderInfoOffset != 0)
    {
        if( UpgradeHeaderData(  (CHAR*)((BYTE*)pEntry + pEntry->HeaderInfoOffset),
                                szHeaderBuf, &cbHeaderBufSize) != TRUE)
        {
            goto doneImport401UrlTranslatingCEI;
        }
    }
    else
        cbHeaderBufSize = 0;

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            cbHeaderBufSize != 0 ?
                (BYTE*)szHeaderBuf : NULL,
            cbHeaderBufSize,
            pEntry->FileExtensionOffset != 0 ?
                ((CHAR*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401UrlTranslatingCEI;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
        goto doneImport401UrlTranslatingCEI;

    retVal = TRUE;

doneImport401UrlTranslatingCEI:
    return retVal;

}


BOOL IE401Visited::UpgradeHeaderData(
            IN      const CHAR* pIn,
            OUT     CHAR* pOut,
            IN OUT  DWORD* pcbOutSize)
{
    BOOL retVal = FALSE;

    OutputStream op( pOut, *pcbOutSize);

    //  The header info struct contains a HISTDATA followed by
    //a list of HISTEXTRAs..  Their sizes can vary but they should
    //be adjacent.  The last HISTEXTRA has a cbExtra of 0 and a sizeof(UINT).
    //  When we import a HISTEXTRA (idExtra = PID_INTSITE_TITLE) then
    //we must convert the attached string from ANSI to Unicode
    HISTEXTRA* pExtra = NULL;

    //first copy the HISTDATA
    if( op.Memcpy( pIn, ((_HISTDATA_V001*)pIn)->cbSize) == FALSE)
        goto doneUpgradeCEIData;

    for(pExtra = (HISTEXTRA*) (pIn + ((_HISTDATA_V001*)pIn)->cbSize);
        pExtra->cbExtra != 0;
        pExtra = (HISTEXTRA*)((BYTE*)pExtra + pExtra->cbExtra))
    {
        if( pExtra->idExtra != PID_INTSITE_TITLE)
        {
            if( op.Memcpy( pExtra, pExtra->cbExtra) == FALSE)
                goto doneUpgradeCEIData;
        }
        else
        {
            HISTEXTRA* pNew = (HISTEXTRA*)((BYTE*)pOut + op.GetFinalLength());

            // copy the HISTEXTRA head
            INET_ASSERT( pExtra->cbExtra >= HISTEXTRA_HEAD_SIZE);
            if( op.Memcpy( pExtra, HISTEXTRA_HEAD_SIZE) == FALSE)
                goto doneUpgradeCEIData;

            if( op.CopyAnsiToUnicode( (CHAR*)&(pExtra->abExtra),
                                      pExtra->cbExtra - HISTEXTRA_HEAD_SIZE)
                == FALSE)
                goto doneUpgradeCEIData;

            pNew->vtExtra = VT_LPWSTR;

            // cbExtra(size) is the change in position of the output stream.
            pNew->cbExtra = ((BYTE*)pOut + op.GetFinalLength()) - (BYTE*)pNew;
        }
    }

    // the final member in the list is just a DWORD, value == 0.
    // determined from assertions in Urlhist.cpp:
    //ASSERT( phext->cbExtra == 0); // terminator
    //ASSERT( (LPBYTE)phdNew+cbHeader == (LPBYTE)phext+SIZEOF(DWORD) );
    if( op.Memcpy( pExtra, sizeof(DWORD)) == FALSE)
        goto doneUpgradeCEIData;

    retVal = TRUE;

doneUpgradeCEIData:

    if( retVal == TRUE)
        *pcbOutSize = op.GetFinalLength();

    return retVal;
}


//************************************************************************8
//
//  IE401History : public IE401IndexFile
//

IE401History::IE401History( LPCSTR szFilename) : IE401IndexFile( szFilename)
{
}


//  imports only URLs using Import401Url then marks them
//as Visited
BOOL IE401History::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        ie401::URL_FILEMAP_ENTRY* pUrlToImport = (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset);

        if( Import401Url( pUrlToImport) == TRUE)
            MarkUrlAsVisited( (CHAR*)pUrlToImport + pUrlToImport->UrlNameOffset);
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Marks an Url given with a history prefix in the Visited container
BOOL IE401History::MarkUrlAsVisited( LPSTR szUrlName)
{
    BOOL retVal = FALSE;
    LPCACHE_ENTRY_INFO pCei = NULL;
    DWORD cbCei = 0;

    //I'm changing the string from "MSHIST_PREFIX_SZhttp:\\www.urlname"
    //to "VISITED_PREFIX_SZhttp:\\www.urlname" in order to locate/change
    //the cache entry.
    //This requires backing up the old prefix, and setting a new pointer
    //to the correct location to place the new prefix.  Once the modified
    //szUrlName is used the old prefix is always restored.

    // backup the old prefix
    CHAR szBackup[sizeof(MSHIST_PREFIX_SZ)];
    memcpy( szBackup, szUrlName, sizeof(MSHIST_PREFIX_SZ));

    //  Move the pointer to later in the string so that the new, smaller
    //prefix fits, and put the new prefix there.
    LPSTR szModifiedUrl = szUrlName + sizeof(MSHIST_PREFIX_SZ) - sizeof(VISITED_PREFIX_SZ);
    memcpy( szModifiedUrl, VISITED_PREFIX_SZ, sizeof(VISITED_PREFIX_SZ) - 1);

    //  Get the cei
    if( GetUrlCacheEntryInfo( szModifiedUrl, NULL, &cbCei) == TRUE)
        goto doneMarkUrlAsVisited;

    pCei = (CACHE_ENTRY_INFO*)(new BYTE[cbCei]);
    if( pCei == NULL)
        goto doneMarkUrlAsVisited;

    if( GetUrlCacheEntryInfo( szModifiedUrl, pCei, &cbCei) != TRUE)
        goto doneMarkUrlAsVisited;

    if( pCei->dwHeaderInfoSize < sizeof(_HISTDATA_V001))
        goto doneMarkUrlAsVisited;

    //  set the Visited flag
    SET_HISTORY_FLAG(pCei->lpHeaderInfo);

    CHAR* pStrStr;
    if( pCei->lpHeaderInfo != NULL
        && (pStrStr = StrStr( pCei->lpHeaderInfo, CACHE_CONTROL_SZ)) != NULL
        && (pStrStr = StrStr( pStrStr, MUST_REVALIDATE_SZ)) != NULL)
    {
        pCei->CacheEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
    }

    if( CommitUrlCacheEntry( szModifiedUrl, NULL, pCei->ExpireTime,
          pCei->LastModifiedTime, pCei->CacheEntryType, (BYTE*)pCei->lpHeaderInfo,
          pCei->dwHeaderInfoSize, pCei->lpszFileExtension, NULL) != TRUE)
        goto doneMarkUrlAsVisited;

    if( SetUrlCacheEntryInfo(
            szModifiedUrl,
            pCei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC | CACHE_ENTRY_EXPTIME_FC ) != TRUE)
        goto doneMarkUrlAsVisited;

    retVal = TRUE;

doneMarkUrlAsVisited:
    memcpy( szUrlName, szBackup, sizeof(MSHIST_PREFIX_SZ));

    if( pCei != NULL)
        delete [] pCei;

    return retVal;
}


//************************************************************************8
//
//  IE401Content : public IE401IndexFile
//


//  on the creation of a IE401Content object, we
//prepare for the enumeration of its entries by:
// - identifying the subdirectories of the old cache
// - register each subdirectory in the new cache
// - move each subdirectory into the new cache's location
IE401Content::IE401Content( LPCSTR szFilename)
: IE401IndexFile( szFilename)
{
    BOOL fConstructionSuccessful = FALSE;

    //  make sure the index file loaded alright.
    if( m_pBuf == NULL)
        goto exitIE401Construct;

    //  ConfigInfo is retrieved since it contains the path of the new cachefile.
    CACHE_CONFIG_INFO sConfigInfo;
    DWORD dwTemp;
    if( GetUrlCacheConfigInfo( &sConfigInfo,
                               &(dwTemp = sizeof(sConfigInfo)),
                               CACHE_CONFIG_CONTENT_PATHS_FC)
        == FALSE)
    {
        goto exitIE401Construct;
    }

    //  get the target path for subcontainer move
    m_cbRootPathLength = lstrlen( sConfigInfo.CachePath);
    memcpy( m_szRootPath, sConfigInfo.CachePath, m_cbRootPathLength + 1);
    //target path example: m_szRootPath = "c:\winnt\content.ie5"

    //  get the source path for the subcontainers from the given filename
    DWORD cbSourcePathLength;
    CHAR szSourcePath[MAX_PATH];
    cbSourcePathLength = lstrlen( szFilename);
    memcpy( szSourcePath, szFilename, cbSourcePathLength + 1);
    // clip off the filename so that we have just the path.
    while( cbSourcePathLength > 0 && szSourcePath[cbSourcePathLength] != FILENAME_SEPARATOR)
    {
        cbSourcePathLength--;
    }
    szSourcePath[ ++cbSourcePathLength] = '\0';
    //source path example:  szSourcePath = "c:\winnt\content\"

    //  enumerate through the subdirectories,
    //      attempt to register that directory in the new cache
    //      then move the old directory into the new cache.
    //  If the directory cannot be registered or moved, then
    //m_szDir contains "" for that directory index.
    m_nDirs = ((_MEMMAP_HEADER_SMALL*)m_pBuf)->nDirCount;
    DWORD index;
    for( index = 0; index < m_nDirs; index++)
    {
        //  get the name of the old subdirectory from the cache.
        memcpy( m_szDir[index],
                ((_MEMMAP_HEADER_SMALL*)m_pBuf)->DirArray[index].sDirName,
                DIR_NAME_SIZE);
        m_szDir[index][DIR_NAME_SIZE] = '\0';

        if( GlobalUrlContainers->CreateContentDirWithSecureName( m_szDir[index]) != TRUE)
        {
            // signal that the directory couldn't be imported and try the next.
            m_szDir[index][0] = '\0';
            continue;
        }

        //  append the subcontainer names to the appropiate destination and source
        //paths.
        memcpy( m_szRootPath + m_cbRootPathLength, m_szDir[index], DIR_NAME_SIZE + 1);
        memcpy( szSourcePath + cbSourcePathLength, m_szDir[index], DIR_NAME_SIZE + 1);

#ifndef UNIX
        if( MoveFile( szSourcePath, m_szRootPath) == 0)
#else
        if (!hConstructSubDirs(m_szRootPath) ||
            CopyDir(szSourcePath, m_szRootPath))
#endif /* UNIX */
        {

            // signal that the directory couldn't be imported and try the next.
            m_szDir[index][0] = '\0';
            continue;
        }
    }

    szSourcePath[ cbSourcePathLength] = '\0';
    m_szRootPath[ m_cbRootPathLength] = '\0';

#ifndef UNIX
    //  The old index file now is full of dead entries,
    //so we don't keep it around.
    DeleteFile( szFilename);
#endif /* UNIX */

    fConstructionSuccessful = TRUE;

exitIE401Construct:

    if( fConstructionSuccessful != TRUE)
    {
        if( m_pBuf != NULL)
            delete [] m_pBuf;

        m_pBuf = NULL;
    }
}


//  imports only URLs using Import401Url
BOOL IE401Content::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        Import401UrlWithFile( (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Extends the default to import files
BOOL IE401Content::Import401UrlWithFile( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
       goto doneImport401Url;
    }

    //  don't import an URL if its one of those weird registered files.
    if( (pEntry->DirIndex == IE401_NOT_A_CACHE_SUBDIRECTORY)
        || (pEntry->CacheEntryType & IE401_EDITED_CACHE_ENTRY))
    {
        goto doneImport401Url;
    }

    if( pEntry->FileSize != 0)
    {
        //  don't import Url if it's subdirectory didn't get created
        if( m_szDir[pEntry->DirIndex][0] == '\0')
            goto doneImport401Url;

        // store the new file path in m_szRoot
        memcpy( m_szRootPath + m_cbRootPathLength, m_szDir[pEntry->DirIndex], DIR_NAME_SIZE);
        m_szRootPath[ m_cbRootPathLength + DIR_NAME_SIZE] = FILENAME_SEPARATOR;
        m_szRootPath[ m_cbRootPathLength + DIR_NAME_SIZE + 1] = '\0';

        // This may result in truncation of the filename, when the 401 generated filename to
        // particularly long, causing the total path to exceed MAX_PATH.
        // We won't worry abou this.
        StrCatBuff(m_szRootPath,
                   (CHAR*)pEntry + pEntry->InternalFileNameOffset,
                   MAX_PATH);
    }

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            (pEntry->FileSize != 0)
              ? m_szRootPath : NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            pEntry->HeaderInfoOffset != NULL ?
                (BYTE*)((BYTE*)pEntry + pEntry->HeaderInfoOffset) : NULL,
            pEntry->HeaderInfoSize,
            pEntry->FileExtensionOffset != 0 ?
                (LPCSTR)((BYTE*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401Url;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
        goto doneImport401Url;

    retVal = TRUE;

doneImport401Url:

    //  Remove appended data
    m_szRootPath[m_cbRootPathLength] = '\0';

    return retVal;
}



//*************************************************************************
//
//  Import401Redirects()
//

IE401Redirects::IE401Redirects( IE401Content* pContent)
{
    INET_ASSERT( m_pBuf == NULL);

    m_pBuf = pContent->m_pBuf;
    pContent->m_pBuf = NULL;
}


//  import items that are redirects
BOOL IE401Redirects::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if((pEntry->dwOffset != HASH_END) && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_REDIR)
    {
        Import401Redirect( (ie401::REDIR_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Imports entries that are redirects
BOOL IE401Redirects::Import401Redirect( ie401::REDIR_FILEMAP_ENTRY* pEntry)
{
    LPSTR szTargetUrl = NULL;

    //** wrap this one in an exception block, because just one of these guys
    //might just try to reference into space.

    // pEntry is an entry to a redirect entry, which contains an offset to a hash entry.
    // That hash entry contains an offset to the filemap entry of the redirect target.
    FILEMAP_ENTRY* pRedirTarget =
        (FILEMAP_ENTRY*)(m_pBuf + ((HASH_ITEM*)(m_pBuf + pEntry->dwItemOffset))->dwOffset);
    //  The filemap entry of the redirect target could be a URL filmap entry or another
    //redirect filemap entry.  Either way extract the url of that entry as the target url.
    switch( pRedirTarget->dwSig)
    {
    case SIG_REDIR:
        szTargetUrl = ((REDIR_FILEMAP_ENTRY*)pRedirTarget)->szUrl;
        break;
    case SIG_URL:
        szTargetUrl = (CHAR*)pRedirTarget + ((URL_FILEMAP_ENTRY*)pRedirTarget)->UrlNameOffset;
        break;
    default:
        return FALSE;
    }

    return GlobalUrlContainers->CreateContentRedirect( szTargetUrl, pEntry->szUrl);
}


//*************************************************************************
//
//  Import401History()
//


//  Inside IE401_HIST_ROOT{hHistRoot}, there are some keys that list
//the history containers we want to import.  Before we can import those containers,
//we import the Visited: container.  This file will be found in the subdirectory of
//the location of the first history subcontainer.
//  When we reach a new container, we create it but don't worry about collisions.
//Existing Url entries are never overwritten by the import process.

BOOL Import401History()
{
    BOOL retVal = FALSE;

    HKEY hHistRoot = (HKEY) INVALID_HANDLE_VALUE;

    // get key to root of history information (which is the root of all extensible containers)
    if( REGOPENKEYEX( IsPerUserCache() ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
                      IE401_HIST_ROOT, 0, KEY_READ, &hHistRoot)
        != ERROR_SUCCESS)
    {
        hHistRoot = (HKEY) INVALID_HANDLE_VALUE;
        goto doneImport401History;
    }

    DWORD index; index = 0;
    CHAR szContainerName[MAX_PATH];
    DWORD cbContainerNameLength;
    DWORD dwCacheLimit;
    DWORD dwCacheOptions;
    CHAR szCachePath[MAX_PATH];
    DWORD cbCachePathSize;
    CHAR szCachePrefix[MAX_PATH];

    //  Enumerate through the extensible containers, if they are History containers import them.
    //  When the first history container is found, its path can be used to locate the Visited:
    //container which also must be imported.
    while( RegEnumKeyEx( hHistRoot, index++, szContainerName, &(cbContainerNameLength = MAX_PATH),
            NULL,NULL,NULL,NULL) == ERROR_SUCCESS)
    {
        static BOOL fFirstRun = TRUE;

        //  we can't be sure all the extended containers are history containers.
        //This check verifies we only import history containers.
        if( StrCmpNI( szContainerName, MSHIST_SZ, sizeof(MSHIST_SZ) - 1) != 0
            || cbContainerNameLength != sizeof(MSHIST_KEY_SZ) - 1)
        {
            continue;
        }

        HKEY hHistContainer = (HKEY) INVALID_HANDLE_VALUE;
        DWORD dwTemp;
        DWORD dwType;

        if( REGOPENKEYEX( hHistRoot, szContainerName, 0, KEY_READ, &hHistContainer) != ERROR_SUCCESS)
            goto doneImportHistContainer;

        if( RegQueryValueEx( hHistContainer, CACHE_LIMIT_SZ, 0, &dwType,
                            (BYTE*)&dwCacheLimit, &(dwTemp = sizeof(dwCacheLimit))) != ERROR_SUCCESS
            || dwType != REG_DWORD)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_OPTIONS_SZ, 0, &dwType,
                            (BYTE*)&dwCacheOptions, &(dwTemp = sizeof(dwCacheOptions))) != ERROR_SUCCESS
            || dwType != REG_DWORD)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_PATH_SZ, 0, &dwType,
                            (BYTE*)szCachePath, &(cbCachePathSize = sizeof(szCachePath))) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_PREFIX_SZ, 0, &dwType,
                            (BYTE*)&szCachePrefix, &(dwTemp = sizeof(szCachePrefix))) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            goto doneImportHistContainer;
        }

        //  After finding the first container, import the Visited: container.
        if( fFirstRun == TRUE)
        {
            //  Clip off the path of the history container, and substitute 'index.dat'
            //to identify the Visited container.  Import the visited container, and
            //restore the path to the history container.
            CHAR szBuf[sizeof(MSHIST_DIR_SZ)];
            LPSTR szMSHIST = szCachePath + cbCachePathSize - sizeof(MSHIST_DIR_SZ);
            // ex result: szCachePath:"c:\path\MSHIST011998020119980225\", szMSHIST:"MSHIST011998020119980225\"

            memcpy( szBuf, szMSHIST, sizeof(MSHIST_DIR_SZ));
            // szBuf:"MSHIST011998020119980225\"
            memcpy( szMSHIST, "index.dat", sizeof("index.dat"));
            //  szMSHIST:"index.dat"  --> szCachePath:"c:\path\index.dat"
            IE401Visited Visited(szCachePath);
            Visited.EnumHashValues();
            memcpy( szMSHIST, szBuf, sizeof(MSHIST_DIR_SZ));
            // szMSHIST:"MSHIST011998020119980225\"  --> szCachePath:"c:\path\MSHIST011998020119980225\"

            fFirstRun = FALSE;
        }

        //  we don't pass the old path so that the container is put in the new one.
        if( CreateUrlCacheContainer( szContainerName, szCachePrefix, NULL,
                                 dwCacheLimit, 0, dwCacheOptions, NULL, NULL) != TRUE
            && GetLastError() != ERROR_ALREADY_EXISTS)
        {
            goto doneImportHistContainer;
        }

        if( cbCachePathSize + (sizeof(INDEX_DAT_SZ) - 1) > MAX_PATH)
            goto doneImportHistContainer;

        memcpy( szCachePath + cbCachePathSize - 1, INDEX_DAT_SZ, sizeof(INDEX_DAT_SZ));

        {
            IE401History History( szCachePath);

            History.EnumHashValues();
        }

    doneImportHistContainer:

        if( hHistContainer != (HKEY) INVALID_HANDLE_VALUE)
            REGCLOSEKEY( hHistContainer);
    }

    retVal = TRUE;

doneImport401History:

    if( hHistRoot != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hHistRoot);

    return retVal;
}


//*************************************************************************
//
//  Import401Content()
//


BOOL Import401Content()
{
    BOOL retVal = FALSE;
    HKEY hContentKey = (HKEY) INVALID_HANDLE_VALUE;
    CHAR szContentFilename[MAX_PATH];
    LPSTR szKeyName = NULL;

    if( !GetIE5ContentPath(szContentFilename))
        goto doneImport401Content;

    //  we now have something like 'c:\..\content\content.ie5'
    //and we want something like 'c:\..\content\index.dat'
    LONG index;

    //  find the position of the last '\\'
    index = lstrlen( szContentFilename);
    while( index >= 0 && szContentFilename[index] != FILENAME_SEPARATOR)
        index--;

    // append an 'index.dat'
    memcpy( szContentFilename + index + 1, INDEX_DAT_SZ, sizeof(INDEX_DAT_SZ));

#ifdef UNIX
    {
       // HACK HACK
       //
       // we now have something like
       //        '/home/blah/.microsoft/ie5/TempInternetFiles/index.dat'
       // and we want something like
       //        /home/blah/.microsoft/TempInternetFiles/index.dat
       char szSearchStr[] = "ie5/";
       char *pszWhere = StrStr(szContentFilename, szSearchStr);
       if (pszWhere)
       {
          memmove(pszWhere, pszWhere+sizeof(szSearchStr)-1,
                  lstrlen(pszWhere+sizeof(szSearchStr)-1)+1);
       }
    }
#endif /* UNIX */

    {
        IE401Content Content(szContentFilename);
        if( Content.EnumHashValues() == TRUE)
        {
            IE401Redirects Redirects( &Content);
            Redirects.EnumHashValues();
        }
    }

doneImport401Content:

    if( hContentKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hContentKey);

    return retVal;
}


//-- end of namespace ie401
}
//--


//
//
//  Returns if caches are per user.
//
BOOL IsPerUserCache()
{
    BOOL fProfilesEnabled = FALSE;
    static BOOL fPerUser = FALSE;
#ifndef UNIX
    // Is the OS version Windows 95 or Windows NT?
    if (GlobalPlatformType == PLATFORM_TYPE_WIN95)
    {
        // Operating System is Windows 95.
        //  Look for special key indicating profiles are enables.  If its not found,
        //know that profiles aren't enabled.

        // Determine if profiles are enabled by OS.
        REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
        if (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
        {
            DWORD dwProfilesEnabled = 0;

            if( roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled) == ERROR_SUCCESS)
            {
                // Found the registry entry.
                fProfilesEnabled = (BOOL) dwProfilesEnabled;
            }
        }

    }
    else if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        // Profiles always enabled for NT.
        fProfilesEnabled = TRUE;
    }
#else
    fProfilesEnabled = TRUE;
#endif /* UNIX */

    // Determine if per user cache is allowed.
    REGISTRY_OBJ roProfilesAllowed(HKEY_LOCAL_MACHINE, PRE5_CACHE_KEY);
    if( fProfilesEnabled && roProfilesAllowed.GetStatus() == ERROR_SUCCESS)
    {
        DWORD dwPerUserCache = 0;

        if( roProfilesAllowed.GetValue(PROFILES_ENABLED,&dwPerUserCache) == ERROR_SUCCESS)
        {
            // Found the registry entry. Set g_fPerUserCache to
            // TRUE only if profiles are enabled.
            fPerUser = ((BOOL) dwPerUserCache);
        }
        else
        {
            // No entry. If profiles are enabled, assume they're allowed.
            fPerUser = fProfilesEnabled;
        }
    }
    else
    {
        fPerUser = fProfilesEnabled;
    }

    return fPerUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\perf\inetdown\inetdown.c ===
#include "inetdown.h"

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------
//#define TEST 1

HINTERNET hInternet;
HANDLE hDownloadThread;
HANDLE hMaxDownloadSem;
DWORD  dwThreadID;
LPSTR ppAccept[] = {"*/*",NULL};
DWORD dwBegin_Time = 0;
DWORD dwEnd_Time;
DWORD dwTot_Time;
DWORD dwNum_Opens = 1;
DWORD dwBuf_Size = BUF_SIZE;
DWORD dwBytes_Read = 0;
DWORD dwMax_Simul_Downloads = URLMAX;
DWORD dwInternet_Open_Flags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_EXISTING_CONNECT;
DWORD dwInternet_Connect_Flags = 0;
BOOL bDelim = FALSE;
BOOL g_bSingleThreaded = FALSE;
DWORD g_dwMainThreadID = 0;
DWORD g_iDownloads = 0;
char *pFilename = NULL;
char *pInFile = NULL;
char *g_pRunStr = NULL;
char *g_pTestName = NULL;
char g_CmdLine[1024];
BOOL g_bTimeFirstFile = TRUE;
url_info_cache g_pUrlInfoCache;
HANDLE g_hHeap;


#ifdef DBG
#define dprintf(args) _dprintf args
INT _dprintf(TCHAR *fmt, ... ) 
{
    INT      ret;
    va_list  marker;
    TCHAR     szBuffer[256];
    if(TRUE) {
        va_start(marker, fmt);
        ret = vsprintf(szBuffer, fmt, marker);
        OutputDebugString(szBuffer);
        printf(szBuffer);
    }
    return ret; 
}

#else

#define dprintf(args)

#endif



//----------------------------------------------------------------------------
//Procedure:   generateInfo
//Purpose:     init globals
//Arguments:   none
//RetVal:      void
//----------------------------------------------------------------------------

void generateInfo() 
{
    g_iDownloads = 0;
    g_dwMainThreadID = GetCurrentThreadId();

    return;
}




//----------------------------------------------------------------------------
// Procedure:  getCachedUrlInfo
// Purpose:    Finds existing url_info struct from the cache if it exists
// Arguments:  szUrl
// RetVal:     url_info* or NULL based on whether it's there
//----------------------------------------------------------------------------

url_info *getCachedUrlInfo(TCHAR *szUrl)
{
    url_info *temp = g_pUrlInfoCache.pHead;

    while(temp && (0 != lstrcmp(temp->pURLName,szUrl)))
    {
        temp = temp->pNext;
    }
	
    return temp;
}

//----------------------------------------------------------------------------
// Procedure:  getUrlInfo
// Purpose:    Sets pUrlInfo member of the outQ struct 
// Arguments:  outQ, szUrl
// RetVal:     TRUE or FALSE based on error
//----------------------------------------------------------------------------

BOOL getUrlInfo(outQ *pOutQ, TCHAR *szUrl) 
{
    URL_COMPONENTS urlc;
    BOOL fRet = FALSE;

    if(pOutQ->pURLInfo = getCachedUrlInfo(szUrl))
    {
        //Use existing url_info from cache
        return TRUE;
    }

    pOutQ->pURLInfo = HeapAlloc(g_hHeap,0,sizeof(url_info));
	
    if(!pOutQ->pURLInfo)
        return FALSE;

    pOutQ->pURLInfo->pURLName = HeapAlloc(g_hHeap,0,(1+lstrlen(szUrl))*sizeof(TCHAR));

    if(!pOutQ->pURLInfo->pURLName)
    {
        HeapFree(g_hHeap,0,pOutQ->pURLInfo);
        return FALSE;
    }

    lstrcpy(pOutQ->pURLInfo->pURLName,szUrl);

    //Add to head of url_info cache
    pOutQ->pURLInfo->pNext = g_pUrlInfoCache.pHead;
    g_pUrlInfoCache.pHead = pOutQ->pURLInfo;

    urlc.dwStructSize = sizeof(URL_COMPONENTS);
    urlc.lpszScheme=pOutQ->pURLInfo->szRScheme;
    urlc.dwSchemeLength=  MAX_SCHEME_LENGTH;
    urlc.nScheme = INTERNET_SCHEME_UNKNOWN;
    urlc.lpszHostName=pOutQ->pURLInfo->szRHost;
    urlc.dwHostNameLength=INTERNET_MAX_HOST_NAME_LENGTH;
    
    urlc.lpszUserName=NULL;
    urlc.dwUserNameLength=0;
    urlc.lpszPassword=NULL;
    urlc.dwPasswordLength=0;
    urlc.lpszExtraInfo = NULL;
    urlc.dwExtraInfoLength = 0;
    
    urlc.lpszUrlPath=pOutQ->pURLInfo->szRPath;
    urlc.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    urlc.nPort = 0;
    if (InternetCrackUrl(pOutQ->pURLInfo->pURLName,0,0,&urlc)) 
    {
        fRet = TRUE;
        pOutQ->pURLInfo->nScheme = urlc.nScheme;
        pOutQ->pURLInfo->nPort = urlc.nPort;
        // For now, we will only support HTTP
        if((pOutQ->pURLInfo->nScheme != INTERNET_SERVICE_HTTP) && (pOutQ->pURLInfo->nScheme != INTERNET_SCHEME_HTTPS))
        fRet = FALSE;
    }
    return fRet;
}


//----------------------------------------------------------------------------
// Procedure:  fillOutQ
// Purpose:    fills the OutQ will URLs to be downloaded
// Arguments:  OutQ to be filled
// RetVal:     the start of the Queue or NULL on error
//----------------------------------------------------------------------------

outQ* fillOutQ(outQ *pOutQ, TCHAR *URLName) 
{
    outQ *pStartOutQ;

    pStartOutQ = pOutQ;

    if(pOutQ) {
        //go to first free outQ as opposed to adding to front (not concerned w/time)
        while(pOutQ->pNext != NULL) 
        {
            pOutQ = pOutQ->pNext;
        }
        pOutQ->pNext = HeapAlloc(g_hHeap,0, sizeof(outQ));
        
        if (!pOutQ->pNext) 
        {
            dprintf(("HeapAlloc Failed!\n"));
            return NULL;
        }
        pOutQ = pOutQ->pNext;
        pOutQ->pNext = NULL;
    }
    else 
    {
        pStartOutQ = pOutQ = HeapAlloc(g_hHeap,0, sizeof(outQ));
     
        if (!pOutQ) 
        {
            dprintf(("HeapAlloc Failed!\n"));
            return NULL;   
        }
        pOutQ->pNext = NULL;
    }
    
    //keep track of the number of downloads
    g_iDownloads++;

    if(!getUrlInfo(pOutQ,URLName)) 
    {
        dprintf(("getUrlInfo failed!\n"));
        return NULL;
    }

    return pStartOutQ;
}

//----------------------------------------------------------------------------
// Procedure:  freeOutQMem
// Purpose:    frees the memory held in the given outQ
// Arguments:  outQ to be freed
// RetVal:     none
//----------------------------------------------------------------------------

void freeOutQMem(outQ *pOutQ) 
{
    outQ *pLastOutQ;

    while(pOutQ) 
    {                
        pLastOutQ = pOutQ;
        pOutQ = pOutQ->pNext;
        HeapFree(g_hHeap,0,pLastOutQ);
    }
    return;
}

//----------------------------------------------------------------------------
// Procedure:  callOpenRequest
// Purpose:    calls HttpOpenRequest
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callOpenRequest(outQ *pOutQ) 
{
    INT iError = 0;
    DWORD dwAdded_Connect_Flags = 0;

    if(lstrcmpi(pOutQ->pURLInfo->szRScheme, "https") == 0)
    {
        dwAdded_Connect_Flags = INTERNET_FLAG_SECURE;
    }

    if(pOutQ->hInetReq = HttpOpenRequest(
          pOutQ->hInetCon,                //connection
          NULL,                           //verb
          pOutQ->pURLInfo->szRPath,                 //object
          NULL,                           //version
          NULL,                           //referrer
          ppAccept,                       //accept headers
          dwInternet_Open_Flags | dwAdded_Connect_Flags, //flags
          (DWORD) pOutQ))                 //context
    {
        //it was synchronous (usual)
        dprintf(("callOpenRequest: Sync TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_STARTING));
        pOutQ->iStatus = LDG_STARTING;
        callSendRequest(pOutQ);
        return;
    }
    else
    {
        if((iError = GetLastError()) != ERROR_IO_PENDING){
            dprintf((" Error on HttpOpenRequest[%d]\n", iError));

            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                } 
            }
            return;     
        }
        
        dprintf(("callOpenRequest: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENED));
        pOutQ->iStatus = REQUEST_OPENED;
        return;
    }
}

//----------------------------------------------------------------------------
// Procedure:  callSendRequest
// Purpose:    calls HttpSendRequest
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callSendRequest(outQ *pOutQ) 
{
    INT iError = 0;
    
    if(HttpSendRequest(pOutQ->hInetReq, NULL, 0, NULL, 0))
    {
        //it was synchronous
        dprintf(("callSendRequest: Sync TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_START));
        pOutQ->iStatus = LDG_START;
        callReadFile(pOutQ);
        return;
    }
    else 
    {
        if((iError = GetLastError()) != ERROR_IO_PENDING)
        {
            dprintf((" Error on HttpSendRequest[%d]\n", iError));
            
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                } 
            }
            return;     
        }
        //it was async (usual)
        dprintf(("callSendRequest: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_START));
        pOutQ->iStatus = LDG_START;
        return;
    }
}

//----------------------------------------------------------------------------
// Procedure:  callReadFile
// Purpose:    calls InternetReadFile
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callReadFile(outQ *pOutQ) 
{
#ifndef TEST
    INT iError;
    INTERNET_BUFFERS IB;
    BOOL bRC;

    static TCHAR buf[BUF_SIZE];

    switch (pOutQ->iStatus) 
    {
	    case LDG_START:
	        dprintf(("callReadFile: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_LDG));
	        pOutQ->iStatus = LDG_LDG;
	        break;

	    case LDG_RDY:
	        if(pOutQ->lNumRead == 0) 
	        {
	            // should wait for 0 bytes read so data will cache.
	            dprintf(("callReadFile: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_DONE));
	            pOutQ->iStatus = LDG_DONE;

	            dprintf(("%s downloaded\n", pOutQ->pURLInfo->pURLName));

	            g_iDownloads--;
				//post msg if last download for exit
	            if(g_iDownloads == 0) 
	            {
	                 dwEnd_Time = GetTickCount();

	                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0))
	                {
	                    iError = GetLastError();
	                    dprintf(("error on PostThreadMessage[%d]\n", iError));
	                    return;
	                } 
	            }

	            InternetCloseHandle(pOutQ->hInetReq);
	            InternetCloseHandle(pOutQ->hInetCon);
	         
	            if(!ReleaseSemaphore(hMaxDownloadSem,1,NULL)) 
	            {
	                dprintf((" ReleaseSemaphore failed!\n"));
	                return;   
	            }
	            
	            return;   
	        }
	        
	        dprintf((" '%s':Rd = %d\n", pOutQ->pURLInfo->pURLName, pOutQ->lNumRead));
            dwBytes_Read += pOutQ->lNumRead;
            break;
    }
    
    //Should insert timing test here
    if(dwBegin_Time == 0)
    {
        if(!g_bTimeFirstFile)
            g_bTimeFirstFile = TRUE;
        else
            dwBegin_Time = GetTickCount();
    }

    IB.dwStructSize = sizeof (INTERNET_BUFFERS);
    IB.Next = 0;
    IB.lpcszHeader = 0;
    IB.dwHeadersLength = 0;
    IB.dwHeadersTotal = 0;
    IB.lpvBuffer = buf;
    IB.dwBufferLength = dwBuf_Size;
    IB.dwBufferTotal = 0;
    IB.dwOffsetLow = 0;
    IB.dwOffsetHigh = 0;
    
    bRC = InternetReadFileEx(pOutQ->hInetReq, &IB, IRF_NO_WAIT, 0);
    pOutQ->lNumRead = IB.dwBufferLength;
    
    if(bRC)
    {

        //it was synchronous
        dprintf(("callReadFile: Sync TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        pOutQ->iStatus = LDG_RDY;
        callReadFile(pOutQ); 
        return;
    }
    else 
    {
	    dprintf(("callReadFile: TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        if(GetLastError() != ERROR_IO_PENDING)
        {
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
            dprintf(("Error on InternetRead"));
            return;     
        }

        if((pOutQ->lNumRead == 0) && (pOutQ->iStatus == LDG_LDG))   //vmr
            pOutQ->iStatus = LDG_RDY;
    }

#else	// ifndef TEST =======================================================================

    INT iError;
    INTERNET_BUFFERS IB;
	BOOL bRC;
	BYTE Buf[8192];

	pOutQ->pBuf = Buf;
	
    //Should insert timing test here
    if(dwBegin_Time == 0)
    {
        if(!g_bTimeFirstFile)
            g_bTimeFirstFile = TRUE;
        else
            dwBegin_Time = GetTickCount();
    }

    IB.dwStructSize = sizeof (INTERNET_BUFFERS);
    IB.Next = 0;
    IB.lpcszHeader = 0;
    IB.dwHeadersLength = 0;
    IB.dwHeadersTotal = 0;
    IB.lpvBuffer = &Buf;
    IB.dwBufferLength = dwBuf_Size;
    IB.dwBufferTotal = 0;
    IB.dwOffsetLow = 0;
    IB.dwOffsetHigh = 0;
    
    bRC = InternetReadFileEx(pOutQ->hInetReq, &IB, IRF_NO_WAIT, 0);
    pOutQ->lNumRead = IB.dwBufferLength;
    
    if(bRC)
    {
        //it was synchronous
        dprintf(("callReadFile: Sync TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        pOutQ->iStatus = LDG_RDY;
        
        if(pOutQ->lNumRead == 0) 
        {
            pOutQ->iStatus = LDG_DONE;

            dprintf(("%s downloaded\n", pOutQ->pURLInfo->pURLName));

            InternetCloseHandle(pOutQ->hInetReq);
            InternetCloseHandle(pOutQ->hInetCon);
            
            //post msg if last download for exit
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                 dwEnd_Time = GetTickCount();

                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0))
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
     
            if(!ReleaseSemaphore(hMaxDownloadSem,1,NULL)) 
            {
                dprintf((" ReleaseSemaphore failed!\n"));
                return;   
            }
        }
	    else
	    {
	        dprintf((" '%s':Rd = %d\n", pOutQ->pURLInfo->pURLName, pOutQ->lNumRead));
            dwBytes_Read += pOutQ->lNumRead;
            callReadFile(pOutQ); 
        }
    }
    else 
    {
	    dprintf(("callReadFile: TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        if(GetLastError() != ERROR_IO_PENDING)
        {
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
            dprintf(("Error on InternetRead"));
            return;     
        }

        if((pOutQ->lNumRead == 0) && (pOutQ->iStatus == LDG_LDG))   //vmr
            pOutQ->iStatus = LDG_RDY;
    }

    return;
#endif	// ifndef TEST

}


//----------------------------------------------------------------------------
// Procedure:  inetCallBackFn
// Purpose:    callback function used for all the async wininet calls
//             simply makes calls to do the actual processing of this callback.
// Arguments:  hInet             HINTERNET for the callback
//             dwContext         the outQ
//             dwInternewStatus  Status of the callback
//             lpStatusInfo      Holds connection handle
//             dwStatusInfoLen   Not used
//----------------------------------------------------------------------------

VOID CALLBACK inetCallBackFn(HINTERNET hInet,
                    DWORD dwContext, 
                    DWORD dwInternetStatus,
                    LPVOID lpStatusInfo,
                    DWORD dwStatusInfoLen) {
    INT iError;
    outQ *pOutQ = (outQ *)(dwContext);
    
    //First check outQ's state
    //Should post messages to other thread to do calls

    switch(pOutQ->iStatus) 
    {
	    case CONNECTED:
	        //should not be called in normal async behavior
	        if(!pOutQ->hInetCon) 
	        {
	            pOutQ->hInetCon = *((HINTERNET *)(lpStatusInfo));
	        }
	        dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENING));
	        pOutQ->iStatus = REQUEST_OPENING;
	        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_OPEN_REQUEST, (WPARAM) pOutQ, 0)) 
	        {
	            iError = GetLastError();
	            dprintf(("error on PostThreadMessage[%d]\n", iError));
	            return;
	        }
	        break;
	    case REQUEST_OPENED:
	        //should not be called in normal async behavior
	        if(!pOutQ->hInetReq) 
	        {
	            pOutQ->hInetReq = *((HINTERNET *)(lpStatusInfo));
	        }
	        dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_STARTING));
	        pOutQ->iStatus = LDG_STARTING;
	        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_SEND_REQUEST, (WPARAM) pOutQ, 0))
	        {
	            iError = GetLastError();
	            dprintf(("error on PostThreadMessage[%d]\n", iError));
	            return;
	        }
	        break;

	    case LDG_LDG:
	///        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE)
	        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE && 
	            pOutQ->lNumRead != 0)
	        {
	            dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_RDY));
	            pOutQ->iStatus = LDG_RDY;
	        }
	        else
	            return;

	    case LDG_START:
	    case LDG_RDY:
	///        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE ||
	///           dwInternetStatus == INTERNET_STATUS_REQUEST_SENT)      // vmr
	        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE)
	        {
	            if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_READ_FILE, (WPARAM) pOutQ, 0)) 
	            {
	                iError = GetLastError();
	                dprintf(("error on PostThreadMessage[%d]\n", iError));
	                return;
	            }   
	        }
	        break;
	    case CONNECTING:
	    case REQUEST_OPENING:
	    case LDG_STARTING:
	    case LDG_DONE:
	        return;
	    default:
	        dprintf(("Bad iStatus=%d\n", pOutQ->iStatus));
	        return;
    }
    
    return;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL DoInit(void)
{
    hMaxDownloadSem = CreateSemaphore(NULL,dwMax_Simul_Downloads,dwMax_Simul_Downloads, NULL);
    if(!hMaxDownloadSem) {
        dprintf((" *** CreateSem failed!\n"));
        return FALSE;
    }

    hInternet = InternetOpen( 
        NULL,                       //referrer
        PRE_CONFIG_INTERNET_ACCESS, //access type
        NULL,                       //proxy
        0,                          //proxy bypass
#ifndef TEST        
        INTERNET_FLAG_ASYNC);       //flags
#else        
        0);
#endif        

    if(!hInternet) 
    {
        dprintf(("  *** InternetOpen failed!\n"));
        return FALSE;
    }

#ifndef TEST        
    if(InternetSetStatusCallback(hInternet, inetCallBackFn) < 0) 
    {
        dprintf(("  setCallback Failed!\n"));
        return FALSE;
    }
#endif

    return TRUE;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL DoConnect(outQ *pOutQ)
{
    INT iError;
    DWORD dwAdded_Connect_Flags = 0;

    if(lstrcmpi(pOutQ->pURLInfo->szRScheme, "https") == 0)
    {
        dwAdded_Connect_Flags = INTERNET_FLAG_SECURE;
    }
        
    pOutQ->hInetCon = InternetConnect(hInternet, //handle from internetOpen
        pOutQ->pURLInfo->szRHost,                 //name of the server
        pOutQ->pURLInfo->nPort,                   //name of the port
        NULL,                         //username 
        NULL,                         //password
        pOutQ->pURLInfo->nScheme,                //service
        dwInternet_Connect_Flags | dwAdded_Connect_Flags,           //service specific flags
        (DWORD) (pOutQ));               //context

    if(pOutQ->hInetCon) 
    {
        //it was synchronous (usually)
        dprintf(("DoConnect: Sync connect TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENING));
        pOutQ->iStatus = REQUEST_OPENING;  
        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_OPEN_REQUEST, (WPARAM) pOutQ, 0)) 
        {
            iError = GetLastError();
            dprintf(("error on PostThreadMessage[%d]\n", iError));
            return FALSE;
        }
    }
    else 
    {
        if(GetLastError() != ERROR_IO_PENDING)
        {
            dprintf(("  InternetConnect error\n"));
            return FALSE;
        }
        dprintf(("DoConnect: Async connect TID=%x pOutQ=%x iStatus=%ld  ->%ld->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, CONNECTED));
        pOutQ->iStatus = CONNECTED;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//  Procedure:   DownloadThread
//  Purpose:     Opens internet connection and downloads URL.  Saves
//               URL to pOutQ (one chunk at a time).
//  Arguments:   outQ
//  Return Val:  TRUE or FALSE based on error
//----------------------------------------------------------------------------

DWORD DownloadThread(LPDWORD lpdwParam) 
{
    outQ *pOutQ = (outQ *) lpdwParam;
    BOOL bRC = TRUE;

    if(bRC = DoInit())    // create throttle semaphore, do InternetOpen & InternetSetStatusCallback
    {
        while(pOutQ) 
        {
            //Only allow MAXURL downloads at one time
            if(WaitForSingleObject(hMaxDownloadSem, TIMEOUT) == WAIT_TIMEOUT) 
            {
                dprintf(("timeout on Sem\n"));
                printf("Error: timeout on throttle semaphore\n");
            }

            pOutQ->iStatus = CONNECTING;
            pOutQ->iPriority = LOW;

            dprintf(("DownloadThread: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, CONNECTING));
            
            if(!(bRC = DoConnect(pOutQ)))
                break;
                
            pOutQ = pOutQ->pNext;
        }
    }
    
    return((DWORD)bRC);
}

//==================================================================
void Display_Usage(char **argv)
{
    printf("\nUsage: %s -fURLname [options]\n", argv[0]);
    printf("\n          -iInputFileName [options]\n");
    printf("\n\t options:\n");
    printf("\t\t -c    - cache reads (flags ^= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE)\n");
    printf("\t\t -c1   - force reload and cache reads (flags ^= INTERNET_FLAG_DONT_CACHE)\n");
    printf("\t\t         (flags default = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_EXISTING_CONNECT\n");
    printf("\t\t -k    - keep alive (flags |= INTERNET_FLAG_KEEP_CONNECTION)\n");
    printf("\t\t -l    - read buffer length\n");
    printf("\t\t -m    - maximum number of simultaneous downloads\n");
    printf("\t\t -n##  - number of times to download\n");
    printf("\t\t -o    - set INTERNET_FLAG_NO_COOKIES\n");
    printf("\t\t -x    - don't time first download\n");
    printf("\t\t -s    - run test in single threaded mode\n");
    printf("\t\t -z    - comma delimited format\n");
    printf("\t\t -tStr - test name string (used on results output with -z)\n");
    printf("\t\t -rStr - run# string (used on results output with -z)\n");
}

//==================================================================
BOOL Process_Command_Line(int argcIn, char **argvIn)
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;
    DWORD dwLen = 0;

    *g_CmdLine = '\0';

    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
                if(argv[0][2] == '1')
                    dwInternet_Open_Flags ^= INTERNET_FLAG_DONT_CACHE;  // force reload & cache file
                else
                    dwInternet_Open_Flags ^= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE;  // cache file
                break;
            case 'k':
                dwInternet_Open_Flags |= INTERNET_FLAG_KEEP_CONNECTION;
                break;
            case 'f':
                pFilename = &argv[0][2];
                break;
            case 'i':
                pInFile = &argv[0][2];
                break;
            case 'n':
                dwNum_Opens = atoi(&argv[0][2]);
                break;
            case 'l':
                dwBuf_Size =  atoi(&argv[0][2]);
                break;
            case 'm':
                dwMax_Simul_Downloads = atoi(&argv[0][2]);
                break;
            case 'o':
                dwInternet_Open_Flags |= INTERNET_FLAG_NO_COOKIES;
                break;
            case 'r':
                g_pRunStr = &argv[0][2];
                break;
            case 's':
                g_bSingleThreaded = TRUE;
                break;
            case 't':
                g_pTestName = &argv[0][2];
                break;
            case 'x':
                g_bTimeFirstFile = FALSE;
                break;
            case 'z':
                bDelim = TRUE;
                break;
            default:
                Display_Usage(argvIn);
                bRC = FALSE;
        }

        if(bRC)
        {
            dwLen += lstrlen(argv[0]) + 1;   // length of arg and space
            if(dwLen < ((sizeof(g_CmdLine)/sizeof(g_CmdLine[0]))-1))
            {
                lstrcat(g_CmdLine, ",");
                lstrcat(g_CmdLine, argv[0]);
            }
        }

        argv++; argc--;
    }

    if(!pFilename && !pInFile)
    {
        Display_Usage(argvIn);
        bRC = FALSE;
    }

    return(bRC);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
outQ *FillURLQueue(void)
{
    outQ *pOutQ = NULL;
    DWORD dwCnt = 0;
    char szName[INTERNET_MAX_URL_LENGTH+1];
    
    if(pFilename)
    {
        while(dwCnt++ < dwNum_Opens) 
        {
            if((dwInternet_Open_Flags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE)) == (INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE))   // Not Cached
                lstrcpy(szName, pFilename);
            else
                wsprintf(szName, "%s.%d", pFilename, dwCnt);

            pOutQ = fillOutQ(pOutQ, szName);
    
            if(!pOutQ)
            {
                dprintf(("error filling outQ!\n"));
                return NULL;
            }
        }
    }
    else if(pInFile)    // Process input file
    {
        FILE *fp;

        while(dwCnt++ < dwNum_Opens) 
        {
            if((fp = fopen(pInFile, "r")) == NULL) 
            {
                dprintf(("error opening file\n"));
                return NULL;
            }

            while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL) 
            {
                if(szName[0] != '#') 
                {
                    szName[strlen(szName) - sizeof(char)] = '\0';
    
                    pOutQ = fillOutQ(pOutQ, szName);
    
                    if(!pOutQ)
                    {
                        dprintf(("error filling outQ!\n"));
                        return NULL;
                    }
                }
            }

            fclose(fp);
        }
    }
    return(pOutQ);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL ProcessMessage(MSG msg, outQ *pOutQ, outQ *pMsgOutQ)
{
    float fKB;
    float fSec;
    float fKBSec;
    
    switch(msg.message) 
    {
        case DOWNLOAD_DONE:
            dwTot_Time = dwEnd_Time - dwBegin_Time;
            if(dwTot_Time == 0)
                dwTot_Time = 1;
            fKB = ((float)dwBytes_Read)/1024;
            fSec = ((float)dwTot_Time)/1000;
            fKBSec = fKB / fSec;
            if(!bDelim)
            {
                dprintf(("TID=%X, %ld bytes in %ld real milliseconds = %2.0f KB/sec\r\n", GetCurrentThreadId(), dwBytes_Read, dwTot_Time, fKBSec));
                printf("\r\nDownloaded: %s\r\n", pOutQ->pURLInfo->pURLName);
                printf("%ld Reads, %ld Downloads, %ld Byte Read Buffer, %s, %s\r\n",
                    dwNum_Opens, dwMax_Simul_Downloads, dwBuf_Size, (dwInternet_Open_Flags & INTERNET_FLAG_DONT_CACHE) ?"Not Cached" :"Cached", (dwInternet_Open_Flags & INTERNET_FLAG_KEEP_CONNECTION) ?"KeepAlive" : "!KeepAlive");
                printf("Read %ld Bytes in %ld Milliseconds = %2.0f KB/Sec\r\n", dwBytes_Read, dwTot_Time, fKBSec);
            }
            else
            {
                printf("%s, %s, %ld, %ld, %2.0f %s\r\n",
                    g_pTestName ?g_pTestName :"wininet",
                    g_pRunStr ?g_pRunStr :"1",
                    dwTot_Time, 
                    dwBytes_Read, 
                    fKBSec,
                    g_CmdLine
                    );
            }

            InternetCloseHandle(hInternet);
            CloseHandle(hDownloadThread);
            freeOutQMem(pOutQ);
            return TRUE;
        case DOWNLOAD_OPEN_REQUEST:
            dprintf(("main: DOWNLOAD_OPEN_REQUEST msg\n"));
            callOpenRequest(pMsgOutQ);
            break;
        case DOWNLOAD_SEND_REQUEST:
            dprintf(("main: DOWNLOAD_SEND_REQUEST msg\n"));
            callSendRequest(pMsgOutQ);
            break;
        case DOWNLOAD_READ_FILE:
            dprintf(("main: DOWNLOAD_READ_FILE msg\n"));
            callReadFile(pMsgOutQ);
            break;
        default:
            dprintf(("no match for message\n"));
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// Function:  Main
// Purpose:   main entry procedure
// Args:      none
// RetVal:    TRUE or FALSE based on error
//----------------------------------------------------------------------------

__cdecl main(INT argc, TCHAR *argv[])
{
    outQ *pOutQ = NULL;
    outQ *pMsgOutQ = NULL;
    outQ *pQ = NULL;
    MSG msg;
    INT retVal;
    DWORD dwResult;
    HANDLE *pObjs = &hMaxDownloadSem;

    g_hHeap = HeapCreate(0,1000000,0);

    if(!g_hHeap)
        return(FALSE);

    if(!Process_Command_Line(argc, argv))
        return FALSE;

    generateInfo();

    g_pUrlInfoCache.pHead = NULL;

    if(!(pOutQ = FillURLQueue()))
        return(FALSE);
        
    if(g_bSingleThreaded)
    {
        if(!DoInit())    // create throttle semaphore, do InternetOpen & InternetSetStatusCallback
            return FALSE;

        pQ = pOutQ;
    }
    else
    {
        hDownloadThread = CreateThread(NULL,
            0,
            (LPTHREAD_START_ROUTINE)DownloadThread,
            (LPVOID)pOutQ,
            0,
            &dwThreadID );

        if (!hDownloadThread) {
            dprintf(("Could not create Thread\n"));
            return FALSE;
        }
    }

    while(TRUE) 
    {
        if(g_bSingleThreaded)
        {
            dwResult = MsgWaitForMultipleObjects(1, pObjs, FALSE, INFINITE, QS_ALLINPUT);
            if(dwResult == (WAIT_OBJECT_0 + 1))
            {
                MSG msg;
                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if(msg.message == WM_QUIT)
                        return(FALSE);
                        
                    pMsgOutQ = (outQ *) msg.wParam;
                    ProcessMessage(msg, pOutQ, pMsgOutQ);
                    if(msg.message == DOWNLOAD_DONE)
                        return(TRUE);
                }
            }
            else
            {
                // Semaphore is signaled so do next connect/download
                if(pQ != NULL)    // If there are still more downloads to do
                {
                    pQ->iStatus = CONNECTING;
                    pQ->iPriority = LOW;
                    dprintf(("Download Main: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pQ, pQ->iStatus, CONNECTING));
                
                    if(!DoConnect(pQ))
                        break;
                    pQ = pQ->pNext;
                }
            }
        }
        else
        {
            retVal = GetMessage(&msg, NULL, 0, 0);
            if(retVal == -1) 
            {
                dprintf(("error on GetMessage\n"));
                break;
            }
            if(retVal == FALSE) 
            {
                msg.message = DOWNLOAD_DONE;
            }
            pMsgOutQ = (outQ *) msg.wParam;
            ProcessMessage(msg, pOutQ, pMsgOutQ);
            if(msg.message == DOWNLOAD_DONE)
                return(TRUE);
        }
    }

    dprintf(("exiting abnormally\n"));
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cachapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapia.cxx

Abstract:

    contains the ANSI version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <cache.hxx>


/*-----------------------------------------------------------------------------
CreateContainer
----------------------------------------------------------------------------*/
URLCACHEAPI_(BOOL) CreateUrlCacheContainerA(
                 IN LPCSTR Name, 
                 IN LPCSTR CachePrefix, 
                 IN LPCSTR CachePath, 
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                 IN DWORD dwOptions,
                 IN OUT LPVOID pvBuffer,
                 IN OUT LPDWORD cbBuffer
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerA", "%q, %q, %q, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CreateContainer(
                        Name,
                        CachePrefix,
                        CachePath,
                        KBCacheLimit,
                        dwOptions);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) DeleteUrlCacheContainerA(
IN LPCSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerA", "%q, %d", Name, dwOptions));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteContainer(
                        Name,
                        0
                        );

    LEAVE_CACHE_API();
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerA",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpdwContainerInfoBufferSize,
        dwOptions
    ));

    DWORD Error;
    HANDLE hFind = NULL;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    hFind = GlobalUrlContainers->FindFirstContainer(pdwModified, 
        lpContainerInfo, lpdwContainerInfoBufferSize, dwOptions);

    if (hFind)
        Error = ERROR_SUCCESS;
    else
    {
        Error = GetLastError();
        // BUGBUG: Free hFind?
        // does the free take NULL?
    }

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError( Error );
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

    
URLCACHEAPI_(BOOL) FindNextUrlCacheContainerA(
IN HANDLE hFind, 
OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
IN OUT LPDWORD lpdwContainerInfoBufferSize
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerA",
        "%#x, %#x, %#x",
        hFind, 
        lpContainerInfo,
        lpdwContainerInfoBufferSize
    ));

    DWORD Error;
    DWORD i;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    if (GlobalUrlContainers->FindNextContainer(hFind, 
            lpContainerInfo, lpdwContainerInfoBufferSize))
        Error = ERROR_SUCCESS;
    else
        Error = GetLastError();

    LEAVE_CACHE_API();
}

#define GZIPHACK    8624

URLCACHEAPI_(BOOL) CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpszFileExtension: File extension for the saved data file

    dwExpectedFileSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileName : pointer to a buffer that receives the full path name of
        the the temp file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryA", "%q, %q, %d, %q, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) || IsBadWriteFileName( lpszFileName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Null first char in lpszFileName cues CreateUniqueFile
    // to generate a file name from scratch. Otherwise,
    // an attempt will be made to generate the filename
    // using the contents of the buffer.
    if(dwReserved != GZIPHACK)
    {
        *lpszFileName = '\0';
    }

    Error = GlobalUrlContainers->CreateUniqueFile(
                        lpszUrlName,
                        dwExpectedFileSize,
                        lpszFileExtension,
                        lpszFileName, 
                        NULL
                        );

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )

/*++

Routine Description:

    This API caches a specified URL in the internet service  cache
    storage. It creates a database entry of the URL info and moves the
    URL file to cache storage.

Arguments:

    lpszUrlName : name of the URL that is cached.

    lpszLocalFileName : name of the local file where the URL data is
        stored. This file will be moved to an another file in cache storage, so
        this name is invalid after this api successfully returns. The
        name should include full path.

    ExpireTime : Expire time (GMT) of the file being cached. If it is
        unknown set it to zero.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    CacheEntryType : type of this new entry.

    lpHeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    lpszFileExtension :  file extension used to create this file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryA",
        "%q, %q, <expires>, <last-mod>, %d, %#x, %d, %q, %q",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpHeaderInfo,
        dwHeaderSize,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadReadFileName( lpszLocalFileName ) : FALSE ) ) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( lpHeaderInfo != NULL ) 
    {
        if( IsBadReadPtr(lpHeaderInfo, dwHeaderSize) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if( lpszFileExtension != NULL ) 
    {
        if( IsBadReadPtr(lpszFileExtension, 3) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    FILETIME     ftPostCheck;
    ftPostCheck.dwLowDateTime = 0;
    ftPostCheck.dwHighDateTime = 0; 
  
    // Record args in structure.
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl      = lpszUrlName;
    Args.pszFilePath = lpszLocalFileName;
    Args.dwFileSize  = 0;
    Args.qwExpires   = FT2LL(ExpireTime);
    Args.qwLastMod   = FT2LL(LastModifiedTime);
    Args.qwPostCheck = FT2LL(ftPostCheck);
    Args.ftCreate = LastModifiedTime;
    Args.dwEntryType = CacheEntryType;
    Args.pbHeaders   = (LPSTR)lpHeaderInfo;
    Args.cbHeaders   = dwHeaderSize;
    Args.pszFileExt  = lpszFileExtension;
    Args.pszRedirect = lpszOriginalUrl ? (LPSTR) lpszOriginalUrl : NULL;
    Args.fImage      = FALSE;

    Error = UrlCacheCommitFile(&Args);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileA","%q, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved));
        
    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
            IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RetrieveUrl(
                        lpszUrlName,
                        (lpCacheEntryInfo ? &lpCacheEntryInfo : NULL),
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(HANDLE) RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    fRandomRead : if this flag is set to TRUE, then stream is open for
        random access.

    dwReserved: must pass 0

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamA",
        "%q, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpdwCacheEntryInfoBufferSize,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Error, dwFileSize;

    // Validate parameters.
    if(   IsBadUrl( lpszUrlName )
       || IsBadWriteUrlInfo(lpCacheEntryInfo, *lpdwCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->RetrieveUrl
        (lpszUrlName, &lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize,
            LOOKUP_URL_NOCREATE, RETRIEVE_WITHOUT_CHECKS);

    if( Error != ERROR_SUCCESS )
        goto Cleanup;
    fLocked = TRUE;        

    // Allocate a stream handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hStream)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hStream)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Open the file.
    hFile = CreateFile
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        Error = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto Cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    pStream->SourceUrlName = NewString(lpszUrlName);
    if( !pStream->SourceUrlName)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hStream)
        {
            HandleMgr.Free (hStream);
            hStream = NULL;
        }
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(lpszUrlName);
        SetLastError (Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hStream);
    return hStream;
}


URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This function retrieves the specified cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoA", "%q, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize));

    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        (lpCacheEntryInfo && !lpdwCacheEntryInfoBufferSize) ||
        (lpCacheEntryInfo && lpdwCacheEntryInfoBufferSize && IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_NOCREATE,
                        0);

    LEAVE_CACHE_API();
}


BOOLAPI GetUrlCacheEntryInfoExA(
    IN LPCSTR       lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCEI,
    IN OUT LPDWORD  lpcbCEI,
    OUT LPSTR       lpszOut,
    IN OUT LPDWORD  lpcbOut,
    LPVOID          lpReserved,
    DWORD           dwFlags
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x", lpszUrl, lpCEI, lpcbCEI, lpszOut, lpcbOut, lpReserved, dwFlags));

    DWORD Error;

    // Validate parameters
    // NOTE: once the following params change, edit GetUrlCacheEntryInfoExW accordingly.
    if (   IsBadUrl(lpszUrl)
        || lpszOut
        || lpcbOut 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // We allow mixing of INTERNET_CACHE_FLAG_ALLOW_COLLISIONS with lookup flags
    Error = GlobalUrlContainers->GetUrlInfo
        (lpszUrl, lpCEI, lpcbCEI, LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS), dwFlags);
        
    LEAVE_CACHE_API();
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the specified fields of the cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that has the url info to
        be set.

    dwFieldControl : Bitmask that specifies the fields to be set.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoA", "%q, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) ||
            IsBadReadUrlInfo( lpCacheEntryInfo )) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        dwFieldControl );

    LEAVE_CACHE_API();
}

URLCACHEAPI_(HANDLE) FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function starts the cache entries enumeration and returns
    the first entry in the cache.

Arguments:

    lpszUrlSearchPattern : pointer to a search pattern string. Currently
        it is not implemented.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryA",
        "%q, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpdwFirstCacheEntryInfoBufferSize
    ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if (IsBadWriteUrlInfo(lpFirstCacheEntryInfo,
                          *lpdwFirstCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               lpFirstCacheEntryInfo, 
                                               lpdwFirstCacheEntryInfoBufferSize, 
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        hFind = NULL;
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPCACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryA",
        "%#x, %#x, %#x",
        hFind, 
        lpNextCacheEntryInfo,
        lpdwNextCacheEntryInfoBufferSize
    ));

    DWORD Error = ERROR_SUCCESS;
    CACHE_FIND_FIRST_HANDLE* pFind;

    // Validate parameters.
    if (!hFind || IsBadWriteUrlInfo(lpNextCacheEntryInfo,
                                    *lpdwNextCacheEntryInfoBufferSize)) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               lpNextCacheEntryInfo, 
                                               lpdwNextCacheEntryInfoBufferSize,
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);



Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API(Error==ERROR_SUCCESS);
    return (Error == ERROR_SUCCESS );
}


INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;
    HANDLE hFind = NULL;

    // Validate parameters.
    if (IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               pEntryInfo, 
                                               pcbEntryInfo,
                                               dwFilter,
                                               GroupId,
                                               dwFlags);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hFind)
        {
            GlobalUrlContainers->FreeFindHandle(hFind);
            hFind = NULL;
        }
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;    
}

BOOLAPI FindNextUrlCacheEntryExA(
    IN     HANDLE    hFind,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExA",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hFind,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;

    // Validate parameters.
    if (!hFind || IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    

    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               pEntryInfo, 
                                               pcbEntryInfo, 
                                               NULL, 
                                               NULL,
                                               NULL);
    

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) FreeUrlCacheSpaceA(
    IN LPCSTR lpszCachePath,
    IN DWORD dwFactor,
    IN DWORD dwFilter
    )
/*++

Routine Description:

    This function cleans up the cache entries in the specified ccahe
    path to make space for future cache entries.

Arguments:

    dwFactor: % of free space

Return Value:

    TRUE if the cleanup is successful. Otherwise FALSE, GetLastError()
    returns the extended error.

--*/
{
    DWORD Error;
    
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpace", 
        "<path>,%d, %#x", dwFactor, dwFilter));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CleanupUrls(lpszCachePath, dwFactor, dwFilter);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileA(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
   
    DWORD Error;
    DWORD i;

    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFile",
        "%q, %#x", lpszUrlName, dwReserved));

    // validate parameters.
    if( IsBadUrl( lpszUrlName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->UnlockUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntry",
        "%q", lpszUrlName));


    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->DeleteUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

BOOLAPI SetUrlCacheEntryGroupA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupA", 
        "%q, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    DWORD Error;

    // Validate parameters.
    if (IsBadUrl(lpszUrlName)
        || !GroupId
        || pbGroupAttributes
        || cbGroupAttributes
        || lpReserved
        )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlGroup (lpszUrlName, dwFlags, GroupId);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(BOOL) GetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupInfo ||
        !lpdwGroupInfo ||
        IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOA) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetGroupAttributes(
                        gid,
                        dwAttributes,
                        lpGroupInfo,
                        lpdwGroupInfo );
    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) SetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    DWORD Error;

    // validate parameters.
    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOA) ) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetGroupAttributes(
            gid, dwAttributes, lpGroupInfo);

    LEAVE_CACHE_API();
}

BOOLAPI IsUrlCacheEntryExpiredA(
    IN      LPCSTR       lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    BOOL                        bRet = TRUE;
    CACHE_ENTRY_INFOEX*         pCEI = NULL;    
    DWORD                       cbCEI;
    DWORD                       dwError;
    BOOL                        bLazy = FALSE;
    BOOL                        fLocked = FALSE;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) || !pftLastModifiedTime ) {
        INET_ASSERT(FALSE); 
        return ERROR_INVALID_PARAMETER;
    }

    // set out LastModTime to 0
    pftLastModifiedTime->dwLowDateTime = 0 ;
    pftLastModifiedTime->dwHighDateTime = 0 ;


    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // BUGBUG
    // ideally, we should use GlobalUrlContainers->GetUrlInfo()
    // with NO_ALLOCATION and HEADONLY flag for perf.
    // however, there is a flag (lookup flag v.s entry flag) collision 
    // in that code path which prevents this working
    // so we use this anti-perf RetrieveUrl for now until that one
    // gets fixed 
    //                                           --DanpoZ, 98.09.09
    
    // Find the container and search the index.
    dwError = GlobalUrlContainers->RetrieveUrl(
                    lpszUrlName, 
                    (CACHE_ENTRY_INFO**) &pCEI, 
                    &cbCEI, 
                    (dwFlags & INTERNET_FLAG_FWD_BACK)?
                        LOOKUP_URL_TRANSLATE : LOOKUP_URL_NOCREATE,
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    
    // not found in cache
    if( dwError != ERROR_SUCCESS )
        goto Cleanup;    

    fLocked = TRUE;

    // found in cache, get the last modified time
    *pftLastModifiedTime = pCEI->LastModifiedTime;

    bRet = IsExpired(pCEI, dwFlags, &bLazy);
    if( bRet && bLazy )
    {
        //
        // the entry is not expired, however, we need to post-fetch
        // so we have to return EXPIRED back to trident to force them
        // issue a binding, on the new binding, urlmon-wininet returns
        // the cache content and queue a background update
        // (an alternative would be to ask trident to catch this case
        //  and call background update themself)
        // 
        bRet = FALSE;
    }

Cleanup:
    if( pCEI )
        FREE_MEMORY(pCEI);

    if (fLocked)
        GlobalUrlContainers->UnlockUrl(lpszUrlName);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\socks\wsock32.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
Copyright (c) 1996  Hummingbird Corporation of Canada


Module Name:

    wsock32.c

Abstract:

    Contains Socks V4 support, written by Hummingbird corporation.  Licensed from
    Hummingbird for ulimited use by Microsoft.  Ported to WININET code base.

    Contents:
        FindSocket
        closesocket
        connect
        getpeername
        ALL WSOCK32.DLL exports.

Author:

    Arthur L Bierer (arthurbi) 13-Dec-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Dec-1996 arthurbi
        Created, removed flagrent calls to CRTs, and unchecked memory allocations.

    29-Aug-1997 rfirth
        Further reduced from general-purpose SOCKS implementation to Wininet-
        specific SOCKS support

--*/


#define _WINSOCKAPI_
#include <windows.h>
#ifdef DO_FILE_CONFIG
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <malloc.h>
#include <ctype.h>
#include <stdlib.h>
#endif

#ifdef OLD_SOCKS

struct User {
    char *Name;
    struct User *Next;
};

struct Server {
    char *Name;
    struct Server *Next;
    unsigned short port;
};

struct Hosts {
    struct User *Users;
    struct Server *Servers;
    unsigned long dst;
    unsigned long mask;
    unsigned short port;
    unsigned char op;
    unsigned char type;
    struct Hosts *Next;
} *Head=NULL;

struct Sockets {
    int s;
    HWND hWnd;
    unsigned int wMsg;
    long lEvent;
    unsigned long Blocking;
    int type;
    unsigned long ip;
    unsigned short port;
    struct Sockets *Next;
    struct Sockets *Last;
    int Socked:1;
} *SHead=NULL;

HANDLE SMutex;

#define CREATE_MUTEX()  SMutex = CreateMutex(NULL, FALSE, NULL)
#define DELETE_MUTEX()  if (SMutex) CloseHandle(SMutex)
#define ENTER_MUTEX()   WaitForSingleObject(SMutex, INFINITE)
#define LEAVE_MUTEX()   ReleaseMutex(SMutex)

#else

struct Hosts {
    char * user;
    int userlen;
    unsigned long ip;
    unsigned short port;
} *Head = NULL;

struct Sockets {
    int s;
    int type;
    unsigned long ip;
    unsigned short port;
    struct Sockets * Next;
    struct Sockets * Last;
    int Socked : 1;
    int Blocking : 1;
} *SHead = NULL;

CRITICAL_SECTION    CritSec;

#define CREATE_MUTEX()  InitializeCriticalSection(&CritSec)
#define DELETE_MUTEX()  DeleteCriticalSection(&CritSec)
#define ENTER_MUTEX()   EnterCriticalSection(&CritSec)
#define LEAVE_MUTEX()   LeaveCriticalSection(&CritSec)

#endif

#define DENY    1
#define DIRECT  2
#define SOCKD   3

#define ANY 0
#define EQ  1
#define NEQ 2
#define LT  3
#define GT  4
#define LE  5
#define GE  6


/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { unsigned short s_w1,s_w2; } S_un_w;
                unsigned long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        unsigned short  sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

struct  servent {
        char    * s_name;           /* official service name */
        char    * * s_aliases;      /* alias list */
        short   s_port;             /* port # */
        char    * s_proto;          /* protocol to use */
};

struct  hostent {
        char    * h_name;           /* official name of host */
        char    * * h_aliases;      /* alias list */
        short   h_addrtype;         /* host address type */
        short   h_length;           /* length of address */
        char    * * h_addr_list;    /* list of addresses */
#define h_addr  h_addr_list[0]      /* address, for backward compat */
};


#define WSABASEERR              10000
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAENOBUFS              (WSABASEERR+55)


#define SOCKET_ERROR            (-1)
#define INVALID_SOCKET  (int)(~0)

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

#define SOCK_STREAM     1               /* stream socket */

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, unsigned long) /* set/clear async i/o */

#define SO_SET_SOCKS_FIREWALL   0xF0000


DWORD (WINAPI * VArecv)(int a,int b,int c, int d);
DWORD (WINAPI * VAsend)(int a,int b,int c, int d);
DWORD (WINAPI * VEnumProtocolsA)(int a,int b,int c);
DWORD (WINAPI * VEnumProtocolsW)(int a,int b,int c);
DWORD (WINAPI * VGetAddressByNameA)(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j);
DWORD (WINAPI * VGetAddressByNameW)(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j);
DWORD (WINAPI * VGetNameByTypeA)(int a,int b,int c);
DWORD (WINAPI * VGetNameByTypeW)(int a,int b,int c);
DWORD (WINAPI * VGetServiceA)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VGetServiceW)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VGetTypeByNameA)(int a,int b);
DWORD (WINAPI * VGetTypeByNameW)(int a,int b);
DWORD (WINAPI * VNPLoadNameSpaces)(int a,int b,int c);
DWORD (WINAPI * VSetServiceA)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VSetServiceW)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VTransmitFile)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VWSAAsyncGetHostByAddr)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VWSAAsyncGetHostByName)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetProtoByName)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetProtoByNumber)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetServByName)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VWSAAsyncGetServByPort)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VWSAAsyncSelect)(int s, HWND hWnd, unsigned int wMsg, long lEvent);
DWORD (WINAPI * VWSACancelAsyncRequest)(int a);
DWORD (WINAPI * VWSACancelBlockingCall)(void);
DWORD (WINAPI * VWSACleanup)(void);
DWORD (WINAPI * VWSAGetLastError)(void);
DWORD (WINAPI * VWSAIsBlocking)(void);
DWORD (WINAPI * VWSARecvEx)(int a,int b,int c,int d);
DWORD (WINAPI * VWSASetBlockingHook)(int a);
DWORD (WINAPI * VWSASetLastError)(int a);
DWORD (WINAPI * VWSAStartup)(int a,int b);
DWORD (WINAPI * VWSAUnhookBlockingHook)(void);
DWORD ( * VWSHEnumProtocols)(int a,int b,int c,int d);
DWORD (WINAPI * VWsControl)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * V__WSAFDIsSet)(int a,int b);
DWORD (WINAPI * Vaccept)(int a,int b,int c);
DWORD (WINAPI * Vbind)(int a,int b,int c);
DWORD (WINAPI * Vclosesocket)(int a);
DWORD (WINAPI * Vclosesockinfo)(int a);
DWORD (WINAPI * Vconnect)(int s, const struct sockaddr_in FAR *name, int namelen);
DWORD (WINAPI * Vdn_expand)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vgethostbyaddr)(int a,int b,int c);
struct hostent * (WINAPI * Vgethostbyname)(char *);
DWORD (WINAPI * Vgethostname)(int a,int b);
DWORD (WINAPI * Vgetnetbyname)(int a);
DWORD (WINAPI * Vgetpeername)(int s, struct sockaddr_in *name,int *namelen);
DWORD (WINAPI * Vgetprotobyname)(int a);
DWORD (WINAPI * Vgetprotobynumber)(int a);
struct servent * (WINAPI * Vgetservbyname)(const char FAR * name, const char FAR * proto);
DWORD (WINAPI * Vgetservbyport)(int a,int b);
DWORD (WINAPI * Vgetsockname)(int a,int b,int c);
DWORD (WINAPI * Vgetsockopt)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vhtonl)(int a);
DWORD (WINAPI * Vhtons)(int a);
DWORD (WINAPI * Vinet_addr)(char *p);
DWORD (WINAPI * Vinet_network)(int a);
DWORD (WINAPI * Vinet_ntoa)(int a);
DWORD (WINAPI * Vioctlsocket)(int s, long cmd, unsigned long *argp);
DWORD (WINAPI * Vlisten)(int a,int b);
DWORD (WINAPI * Vntohl)(int a);
DWORD (WINAPI * Vntohs)(int a);
DWORD (WINAPI * Vrcmd)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrecv)(int a,int b,int c,int d);
DWORD (WINAPI * Vrecvfrom)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrexec)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrresvport)(int a);
DWORD (WINAPI * Vs_perror)(int a,int b);
DWORD (WINAPI * Vselect)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vsend)(int a,int b,int c,int d);
DWORD (WINAPI * Vsendto)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vsethostname)(int a,int b);
DWORD (WINAPI * Vsetsockopt)(int s,int level,int optname,const char FAR * optval, int optlen);
DWORD (WINAPI * Vshutdown)(int a,int b);
DWORD (WINAPI * Vsocket)(int a,int b,int c);
DWORD (WINAPI * VWEP)(void);
DWORD (WINAPI * VAcceptEx)(int a,int b,int c,int d,int e,int f,int g,int h);
DWORD (WINAPI * VGetAcceptExSockaddrs)(int a,int b,int c,int d,int e,int f,int g,int h);
DWORD (WINAPI * VMigrateWinsockConfiguration)(int a,int b, int c);
DWORD (WINAPI * VWSApSetPostRoutine)(void *a);

BOOL (WINAPI * VPostMessage)(HWND hWnd, unsigned int wMsg, WPARAM wPAram, LPARAM lParam) = NULL;

BOOL MyPostMessage(HWND hWnd, unsigned int wMsg, WPARAM wParam, LPARAM lParam) {
    if ( VPostMessage)
        return(VPostMessage(hWnd,wMsg, wParam, lParam));
    PostMessage(hWnd,wMsg, wParam, lParam);
}

struct Sockets *
FindSocket(
    int s
    )

/*++

Routine Description:

    Find or create SOCKS socket object. Returns with MUTEX held

Arguments:

    s   - associated socket handle

Return Value:

    struct Sockets *
        Success - address of Sockets object

        Failure - NULL

--*/

{
    struct Sockets *So;

    ENTER_MUTEX();

    So = SHead;
    while (So) {
        if (s == So->s) {
            return So;
        }
        So = So->Next;
    }
    if (So = (struct Sockets *)LocalAlloc(LPTR, sizeof(struct Sockets))) {
        So->s = s;
        So->Next = SHead;
        SHead = So;
        if (So->Next) {
            (So->Next)->Last = So;
        }
    }
    return So;
}

//LPSTR
//NewString(
//    IN LPCSTR String
//    )
//
///*++
//
//Routine Description:
//
//    kind of version of strdup() but using LocalAlloc to allocate memory
//
//Arguments:
//
//    String  - pointer to string to make copy of
//
//Return Value:
//
//    LPSTR
//        Success - pointer to duplicated string
//        Failure - NULL
//
//--*/
//
//{
//    int len = strlen(String) + 1;
//    LPSTR string;
//
//    if (string = (LPSTR)LocalAlloc(LMEM_FIXED, len)) {
//        CopyMemory(string, String, len);
//    }
//    return string;
//}


DWORD WINAPI __WSAFDIsSet(int a,int b) {
    return(V__WSAFDIsSet(a, b));
}

DWORD WINAPI accept(int a,int b,int c) {
    return(Vaccept(a, b, c));
}

DWORD WINAPI Arecv(int a,int b,int c,int d) {
    return(VArecv(a,b,c,d));
}

DWORD WINAPI Asend(int a,int b,int c,int d) {

    return(VAsend(a,b,c,d));
}

DWORD WINAPI bind(int a,int b,int c) {
    return(Vbind(a, b, c));
}

DWORD WINAPI AcceptEx(int a,int b,int c,int d,int e,int f,int g,int h) {
    return(VAcceptEx(a,b,c,d,e,f,g,h));
}

DWORD WINAPI GetAcceptExSockaddrs(int a,int b,int c,int d,int e,int f,int g,int h) {
    return(VGetAcceptExSockaddrs(a,b,c,d,e,f,g,h));
}

DWORD WINAPI MigrateWinsockConfiguration(int a,int b, int c) {
    return(VMigrateWinsockConfiguration(a,b,c));
}

DWORD WINAPI WSApSetPostRoutine(void *a) {
    VPostMessage=a;
    return(VWSApSetPostRoutine(a));
}

DWORD
WINAPI
closesocket(
    int s
    )

/*++

Routine Description:

    Closes socket handle and destroys associated Sockets object if found

Arguments:

    s   - socket handle

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    struct Sockets * So = FindSocket(s);

    if (So == NULL) {
        VWSASetLastError(WSAENOBUFS);

        LEAVE_MUTEX();

        return SOCKET_ERROR;
    }
    if (So->Last == NULL) {
        SHead = So->Next;
    } else {
        (So->Last)->Next = So->Next;
    }
    if (So->Next) {
        (So->Next)->Last = So->Last;
    }

    LEAVE_MUTEX();

    LocalFree(So);
    return Vclosesocket(s);
}

DWORD WINAPI closesockinfo(int a) {
    return(Vclosesockinfo(a));
}

DWORD
WINAPI
connect(
    int s,
    const struct sockaddr_in FAR * name,
    int namelen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

Arguments:

    s       - socket to connect

    name    - sockaddr of remote host

    namelen - length of sockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    unsigned long ip;
    unsigned short port;
    struct Hosts * pHost;
    int serr;
    int blocking;
    struct Sockets * pSocket;
    struct sockaddr_in sin;
    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;
    int length;
    char response[256];
    int val;

    //
    // get IP address and port we want to connect to on other side of firewall
    //

    port = name->sin_port;
    ip = name->sin_addr.s_addr;

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = 2;

    //
    // initialize SOCKS request packet
    //

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = port;
    request.DSTIP = ip;

    pSocket = FindSocket(s);
    if (pSocket == NULL) {
        VWSASetLastError(WSAENOBUFS);

        LEAVE_MUTEX();

        return SOCKET_ERROR;
    }
    pHost = Head;
    if (!pHost || (pSocket->type != SOCK_STREAM) || (pSocket->Socked)) {

        LEAVE_MUTEX();

        return Vconnect(s, name, namelen);
    }

    //
    // get information from pSocket and pHost structures before releasing mutex
    //

    blocking = pSocket->Blocking;
    pSocket->port = port;
    pSocket->ip = ip;
    memcpy(request.UserId, pHost->user, pHost->userlen);
    length = pHost->userlen + 8; // 8 == sizeof fixed portion of request
    sin.sin_port = pHost->port;
    sin.sin_addr.s_addr = pHost->ip;

    //
    // from this point, we cannot touch pHost or pSocket until we take the mutex
    // again
    //

    LEAVE_MUTEX();

    //
    // put socket into blocking mode
    //

    val = 0;
    Vioctlsocket(s, FIONBIO, &val);

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    serr = Vconnect(s, &sin, sizeof(sin));
    if (serr != SOCKET_ERROR) {
        serr = Vsend(s, (int)&request, length, 0);
        if (serr == length) {
            serr = Vrecv(s, (int)response, sizeof(response), 0);
        }
    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (blocking) {
        Vioctlsocket(s, FIONBIO, &blocking);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if ((serr == SOCKET_ERROR) || (response[1] != 90)) {
        VWSASetLastError(WSAECONNREFUSED);
        serr = SOCKET_ERROR;
    } else {

        //
        // if we can't find/crea
        //

        pSocket = FindSocket(s);
        if (pSocket) {
            pSocket->Socked = 1;
            serr = 0;
        } else {
            VWSASetLastError(WSAENOBUFS);
            serr = SOCKET_ERROR;
        }

        LEAVE_MUTEX();

    }
    return serr;
}

DWORD WINAPI dn_expand(int a,int b,int c,int d,int e) {
    return(Vdn_expand(a, b, c, d, e));
}

DWORD WINAPI EnumProtocolsA(int a,int b,int c) {
    return(VEnumProtocolsA(a, b, c));
}

DWORD WINAPI EnumProtocolsW(int a,int b,int c) {
    return(VEnumProtocolsW(a, b, c));
}

DWORD WINAPI GetAddressByNameA(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j) {
    return(VGetAddressByNameA(a, b, c, d, e, f, g, h, i, j));
}

DWORD WINAPI GetAddressByNameW(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j) {
    return(VGetAddressByNameW(a, b, c, d, e, f, g, h, i, j));
}

DWORD WINAPI gethostbyaddr(int a,int b,int c) {
    return(Vgethostbyaddr(a, b, c));
}

struct hostent FAR * WINAPI gethostbyname(char *a) {
    return(Vgethostbyname(a));
}

DWORD WINAPI gethostname(int a,int b) {
    return(Vgethostname(a, b));
}

DWORD WINAPI GetNameByTypeA(int a,int b,int c) {
    return(VGetNameByTypeA(a, b, c));
}

DWORD WINAPI GetNameByTypeW(int a,int b,int c) {
    return(VGetNameByTypeW(a, b, c));
}

DWORD WINAPI getnetbyname(int a) {
    return(Vgetnetbyname(a));
}

DWORD
WINAPI
getpeername(
    int s,
    struct sockaddr_in * name,
    int *namelen
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    s       -

    name    -

    namelen -

Return Value:

    int

--*/

{
    DWORD ret;
    struct Sockets *So;

    ret = Vgetpeername(s, name, namelen);
    if (ret == 0) {
        So = FindSocket(s);
        if (So) {
            if (So->Socked) {
                if (*namelen >= sizeof(struct sockaddr_in)) {
                    name->sin_port = So->port;
                    name->sin_addr.s_addr = So->ip;
                }
            }
        } else {
            VWSASetLastError(WSAENOBUFS);
            ret = SOCKET_ERROR;
        }

        LEAVE_MUTEX();
    }
    return ret;
}

DWORD WINAPI getprotobyname(int a) {
    return(Vgetprotobyname(a));
}

DWORD WINAPI getprotobynumber(int a) {
    return(Vgetprotobynumber(a));
}

struct servent * WINAPI getservbyname(const char FAR * name, const char FAR * proto) {
    return(Vgetservbyname(name, proto));
}

DWORD WINAPI getservbyport(int a,int b) {
    return(Vgetservbyport(a, b));
}

DWORD WINAPI GetServiceA(int a,int b,int c,int d,int e,int f,int g) {
    return(VGetServiceA(a, b, c, d, e, f, g));
}

DWORD WINAPI GetServiceW(int a,int b,int c,int d,int e,int f,int g) {
    return(VGetServiceW(a, b, c, d, e, f, g));
}

DWORD WINAPI getsockname(int a,int b,int c) {
    return(Vgetsockname(a, b, c));
}

DWORD WINAPI getsockopt(int a,int b,int c,int d,int e) {
    return(Vgetsockopt(a, b, c, d, e));
}

DWORD WINAPI GetTypeByNameA(int a,int b) {
    return(VGetTypeByNameA(a, b));
}

DWORD WINAPI GetTypeByNameW(int a,int b) {
    return(VGetTypeByNameW(a, b));
}

DWORD WINAPI htonl(int a) {
    return(Vhtonl(a));
}

DWORD WINAPI htons(int a) {
    return(Vhtons(a));
}

DWORD WINAPI inet_addr(char *p) {
    return(Vinet_addr(p));
}

DWORD WINAPI inet_network(int a) {
    return(Vinet_network(a));
}

DWORD WINAPI inet_ntoa(int a) {
    return(Vinet_ntoa(a));
}

DWORD WINAPI ioctlsocket(int s, long cmd, unsigned long *argp) {
    if (cmd == FIONBIO) {

        struct Sockets * So = FindSocket(s);

        if (So == NULL) {
            VWSASetLastError(WSAENOBUFS);

            LEAVE_MUTEX();

            return SOCKET_ERROR;
        }
        So->Blocking = *argp ? 1 : 0;

        LEAVE_MUTEX();

    }
    return Vioctlsocket(s, cmd, argp);
}

DWORD WINAPI listen(int a,int b) {
    return(Vlisten(a, b));
}

DWORD WINAPI NPLoadNameSpaces(int a,int b,int c) {
    return(VNPLoadNameSpaces(a, b, c));
}

DWORD WINAPI ntohl(int a) {
    return(Vntohl(a));
}

DWORD WINAPI ntohs(int a) {
    return(Vntohs(a));
}

DWORD WINAPI rcmd(int a,int b,int c,int d,int e,int f) {
    return(Vrcmd(a, b, c, d, e, f));
}

DWORD WINAPI recv(int a,int b,int c,int d) {
    return(Vrecv(a, b, c, d));
}

DWORD WINAPI recvfrom(int a,int b,int c,int d,int e,int f) {
    return(Vrecvfrom(a, b, c, d, e, f));
}

DWORD WINAPI rexec(int a,int b,int c,int d,int e,int f) {
    return(Vrexec(a, b, c, d, e, f));
}

DWORD WINAPI rresvport(int a) {
    return(Vrresvport(a));
}

DWORD WINAPI s_perror(int a,int b) {
    return(Vs_perror(a, b));
}

DWORD WINAPI select(int a,int b,int c,int d,int e) {
    return(Vselect(a, b, c, d, e));
}

DWORD WINAPI send(int a,int b,int c,int d) {
    return(Vsend(a, b, c, d));
}

DWORD WINAPI sendto(int a,int b,int c,int d,int e,int f) {
    return(Vsendto(a, b, c, d, e, f));
}

DWORD WINAPI sethostname(int a,int b) {
    return(Vsethostname(a, b));
}

DWORD WINAPI SetServiceA(int a,int b,int c,int d,int e,int f) {
    return(VSetServiceA(a, b, c, d, e, f));
}

DWORD WINAPI SetServiceW(int a,int b,int c,int d,int e,int f) {
    return(VSetServiceW(a, b, c, d, e, f));
}

DWORD
WINAPI
setsockopt(
    int s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    )

/*++

Routine Description:

    If SO_SET_SOCKS_FIREWALL, create SOCKS information if it is new or changed
    from current, else pass on the request to wsock32!setsockopt()

Arguments:

    s       - socket on which to set option

    level   - option type parameter (SO_SET_SOCKS_FIREWALL)

    optname - option type sub-parameter (SOCKS firewall port # in host format)

    optval  - value to set (pointer to SOCKS information:
                DWORD ip address;
                LPSTR username
              )

    optlen  - length of value (8)

Return Value:

    DWORD
        Success - 0

        Failure - -1

--*/

{
    int rc;

    if (level != SO_SET_SOCKS_FIREWALL) {
        rc = Vsetsockopt(s, level, optname, optval, optlen);
    } else {

        struct Hosts * pHost;
        struct FirewallInfo {
            DWORD ipAddress;
            LPSTR userName;
        } * pInfo = (struct FirewallInfo *)optval;

        optname = Vhtons(optname);

        ENTER_MUTEX();

        if (pHost = Head) {
            if ((pHost->ip != pInfo->ipAddress)
            || (pHost->port != optname)
            || (pHost->user && lstrcmp(pHost->user, pInfo->userName))) {
//char buf[256];
//wsprintf(buf,
//         "throwing out: host: %d.%d.%d.%d:%d,%s; info: %d.%d.%d.%d:%d,%s\n",
//         pHost->ip & 0xff,
//         (pHost->ip >> 8) & 0xff,
//         (pHost->ip >> 16) & 0xff,
//         (pHost->ip >> 24) & 0xff,
//         Vhtons(pHost->port) & 0xffff,
//         pHost->user,
//         pInfo->ipAddress & 0xff,
//         (pInfo->ipAddress >> 8) & 0xff,
//         (pInfo->ipAddress >> 16) & 0xff,
//         (pInfo->ipAddress >> 24) & 0xff,
//         Vhtons(optname) & 0xffff,
//         pInfo->userName
//         );
//OutputDebugString(buf);
                LocalFree(pHost);
                pHost = NULL;
            }
        }
        if (!pHost) {

            int userlen = lstrlen(pInfo->userName) + 1;

            if (pHost = (struct Hosts *)LocalAlloc(LPTR,
                                                   sizeof(struct Hosts)
                                                   + userlen
                                                   )) {
                memcpy(pHost + 1, pInfo->userName, userlen);
                pHost->user = (LPSTR)(pHost + 1);
                pHost->userlen = userlen;
                pHost->ip = pInfo->ipAddress;
                pHost->port = (unsigned short)optname;
            }
        }
        Head = pHost;
        if (pHost) {
            rc = 0;
        } else {
            VWSASetLastError(WSAENOBUFS);
            rc = SOCKET_ERROR;
        }

        LEAVE_MUTEX();

    }
    return rc;
}

DWORD WINAPI shutdown(int a,int b) {
    return(Vshutdown(a, b));
}

DWORD WINAPI socket(int af,int type,int protocol) {

    struct Sockets * So;
    int s;

    s = Vsocket(af, type, protocol);
    if (s != INVALID_SOCKET) {
        So = FindSocket(s);
        if (So) {
            So->type = type;
        } else {
            Vclosesocket(s);
            VWSASetLastError(WSAENOBUFS);
            s = INVALID_SOCKET;
        }
        LEAVE_MUTEX();
    }
    return s;
}

DWORD WINAPI TransmitFile(int a,int b,int c,int d,int e,int f,int g) {
    return(VTransmitFile(a, b, c, d, e, f, g));
}

DWORD WINAPI WEP() {
    return(VWEP());
}

DWORD WINAPI WSAAsyncGetHostByAddr(int a,int b,int c,int d,int e,int f,int g) {
    return(VWSAAsyncGetHostByAddr(a, b, c, d, e, f, g));
}

DWORD WINAPI WSAAsyncGetHostByName(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetHostByName(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetProtoByName(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetProtoByName(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetProtoByNumber(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetProtoByNumber(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetServByName(int a,int b,int c,int d,int e,int f) {
    return(VWSAAsyncGetServByName(a, b, c, d, e, f));
}

DWORD WINAPI WSAAsyncGetServByPort(int a,int b,int c,int d,int e,int f) {
    return(VWSAAsyncGetServByPort(a, b, c, d, e, f));
}

DWORD WINAPI WSAAsyncSelect(int s, HWND hWnd, unsigned int wMsg, long lEvent) {
    return(VWSAAsyncSelect(s,hWnd,wMsg,lEvent));
}

DWORD WINAPI WSACancelAsyncRequest(int a) {
    return(VWSACancelAsyncRequest(a));
}

DWORD WINAPI WSACancelBlockingCall() {
    return(VWSACancelBlockingCall());
}

DWORD WINAPI WSACleanup() {
    return(VWSACleanup());
}

DWORD WINAPI WSAGetLastError() {
    return(VWSAGetLastError());
}

DWORD WINAPI WSAIsBlocking() {
    return(VWSAIsBlocking());
}

DWORD WINAPI WSARecvEx(int a,int b,int c,int d) {
    return(VWSARecvEx(a, b, c, d));
}

DWORD WINAPI WSASetBlockingHook(int a) {
    return(VWSASetBlockingHook(a));
}

DWORD WINAPI WSASetLastError(int a) {
    return(VWSASetLastError(a));
}

DWORD WINAPI WSAStartup(int a,int b) {
    return(VWSAStartup(a, b));
}

DWORD WINAPI WSAUnhookBlockingHook() {
    return(VWSAUnhookBlockingHook());
}

DWORD WINAPI WsControl(int a,int b,int c,int d,int e,int f) {
    return(VWsControl(a,b,c,d,e,f));
}

DWORD WSHEnumProtocols(int a,int b, int c,int d) {
    return(VWSHEnumProtocols(a,b,c,d));
}

//#ifdef DO_FILE_CONFIG
//
//void
//ParseList(char *List,struct Server **Head,int IsSvr) {
//
//    char *p;
//    char *p1;
//    char *pTok;
//    struct Server *tmp,*Current=NULL;
//
//    *Head = NULL;
//
//    if ( *(List+1) != '=')
//        return;
//    pTok = List+2;
//    List=StrTokEx(&pTok,"\t ");
//    p = StrTokEx(&List,",");
//    while ( p) {
//        if (IsSvr) {
//            tmp = (struct Server *)LocalAlloc(LPTR, (sizeof(struct Server)));
//            if ( tmp == NULL )
//                return;
//
//            p1 = strchr(p,':');
//            if (p1) {
//                *p1++ = 0;
//                tmp->port = atoi(p1);
//            }
//            else
//                tmp->port = 1080;
//        }
//        else {
//            tmp = (struct Server *)LocalAlloc(LPTR, (sizeof(struct Server)));
//            if ( tmp == NULL )
//                return;
//        }
//        tmp->Name = NewString(p);
//        tmp->Next = NULL;
//        if (Current == NULL) {
//            Current = *Head = tmp;
//        }
//        else {
//            Current->Next = tmp;
//            Current=tmp;
//        }
//        p = StrTokEx(&List,",");
//    }
//}
//
//
//void
//LoadConfig(void) {
//
//    struct Hosts *Current=NULL,*tmp;
//    char Buffer[1024];
//    FILE *f;
//    char *p;
//    char *ServerList;
//    char *UserList;
//    struct Server *Default=NULL;
//    HKEY Key;
//
//    GetSystemDirectory(Buffer,sizeof(Buffer));
//    strcat(Buffer, "\\socks.cnf");
//    f = fopen(Buffer,"rt");
//    if ( f == NULL)
//        return;
//    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\HummingBird", 0, KEY_QUERY_VALUE, &Key) == ERROR_SUCCESS) {
//    int Type, Length=sizeof(Buffer);
//        if ( RegQueryValueEx(Key, "SOCKS_SERVER", NULL, &Type, Buffer, &Length) == ERROR_SUCCESS) {
//            Buffer[Length] = '\0';
//            Default=LocalAlloc(LPTR, sizeof(struct Server));
//            if ( Default == NULL )
//                return;
//
//            p = strchr(Buffer,':');
//            if (p) {
//                *p++ = 0;
//                Default->port = atoi(p);
//            }
//            else
//                Default->port = 1080;
//            Default->Name = NewString(Buffer);
//            Default->Next = NULL;
//        }
//        RegCloseKey(Key);
//    }
//
//    while ( fgets(Buffer,sizeof(Buffer)-1,f) != NULL) {
//        Buffer[strlen(Buffer)-1]='\0';
//        if ( Buffer[0] == '#')
//            continue;
//        tmp = (struct Hosts *) LocalAlloc(LPTR, sizeof(struct Hosts));
//        if ( tmp == NULL )
//            return;
//
//        memset(tmp,0,sizeof(struct Hosts));
//        ServerList=NULL;
//        UserList=NULL;
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        if ( lstrcmpi(p,"DENY") == 0) {
//            tmp->type = DENY;
//        } else if (lstrcmpi(p,"DIRECT") == 0) {
//            tmp->type = DIRECT;
//        } else if (lstrcmpi(p,"SOCKD") == 0) {
//            tmp->type = SOCKD;
//        } else {
//            LocalFree(tmp);
//            continue;
//        }
//LookMore:
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        if (*p == '*') {
//            UserList=p;
//            goto LookMore;
//        }
//        if (*p == '@') {
//            ServerList=p;
//            goto LookMore;
//        }
//        tmp->dst = Vinet_addr(p);
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        tmp->mask = Vinet_addr(p);
//        p = StrTokEx(&Buffer,"\t ");
//        if (p) {
//            if ( lstrcmpi(p,"EQ") == 0)
//                tmp->op = EQ;
//            else if ( lstrcmpi(p,"NEQ") == 0)
//                tmp->op = NEQ;
//            else if ( lstrcmpi(p,"LT") == 0)
//                tmp->op = LT;
//            else if ( lstrcmpi(p,"GT") == 0)
//                tmp->op = GT;
//            else if ( lstrcmpi(p,"LE") == 0)
//                tmp->op = LE;
//            else if ( lstrcmpi(p,"GE") == 0)
//                tmp->op = GE;
//            else {
//                LocalFree(tmp);
//                continue;
//            }
//            p = StrTokEx(&Buffer,"\t ");
//            if ( p == NULL) {
//                LocalFree(tmp);
//                continue;
//            }
//            if ( isdigit(*p))
//                tmp->port = atoi(p);
//            else {
//            struct servent *se;
//                se=Vgetservbyname(p,"tcp");
//                if ( se == NULL) {
//                    LocalFree(tmp);
//                    continue;
//                }
//                tmp->port = se->s_port;
//            }
//        }
//        if ( UserList)
//            ParseList(UserList,(struct Server **)&tmp->Users,0);
//        if ( ServerList)
//            ParseList(ServerList,&tmp->Servers,1);
//        if ( (tmp->type == SOCKD) && (tmp->Servers == NULL))
//            tmp->Servers=Default;
//        if ( Current == NULL) {
//            Head = Current = tmp;
//        }
//        else {
//            Current->Next = tmp;
//            Current = tmp;
//        }
//    }
//    fclose(f);
//}
//
//#endif

HMODULE hModule = NULL;
int LoadCount = 0;

BOOL
WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD reason,
    IN LPVOID Reserved
    )
{
    HKEY hKey;
    TCHAR szRegBuf[MAX_PATH+1];
    DWORD dwRegBufSize = sizeof(szRegBuf);
    DWORD dwRegType;
    LONG lResult;

    switch(reason) {
    case DLL_PROCESS_DETACH:
        if (LoadCount == 0) {
            DELETE_MUTEX();
            return 1;
        }
        if (--LoadCount == 0) {
            FreeLibrary(hModule);
        }
        return 1;

    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
        if (++LoadCount == 1) {
            break;
        }

    default:
        return 1;
    }

    // Load an alternate Winsock DLL based on a registry value,
    // in the event that a customer wants to load a different wsock32.
    //
    if (ERROR_SUCCESS == (lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        0,
        KEY_QUERY_VALUE,
        &hKey
        )))
    {
        if (ERROR_SUCCESS == (lResult = RegQueryValueEx(
            hKey,
            TEXT("AlternateWinsock"),
            NULL,
            &dwRegType,
            (LPBYTE) szRegBuf,
            &dwRegBufSize
            )) && dwRegType == REG_SZ) // only allow type REG_SZ
        {
            // Found a string, so try to load it as the alternate Winsock DLL.
            hModule = LoadLibrary(szRegBuf);
        }
        RegCloseKey(hKey);
    }

    if (lResult != ERROR_SUCCESS)
    {
        hModule = LoadLibrary("WSOCK32.DLL");
    }

    if (hModule < (HMODULE) HINSTANCE_ERROR) {
        MessageBox(NULL,
                   "Unable to find old WSOCK32.DLL named \"WSOCK32.DLL\".",
                   "Microsoft/Hummingbird SOCKS Shim",
                   MB_OK
                   );
        LoadCount = 0;
        return 0;
    }

    (FARPROC) VArecv=GetProcAddress(hModule,"Arecv");
    (FARPROC) VAsend=GetProcAddress(hModule,"Asend");
    (FARPROC) VEnumProtocolsA=GetProcAddress(hModule,"EnumProtocolsA");
    (FARPROC) VEnumProtocolsW=GetProcAddress(hModule,"EnumProtocolsW");
    (FARPROC) VGetAddressByNameA=GetProcAddress(hModule,"GetAddressByNameA");
    (FARPROC) VGetAddressByNameW=GetProcAddress(hModule,"GetAddressByNameW");
    (FARPROC) VGetNameByTypeA=GetProcAddress(hModule,"GetNameByTypeA");
    (FARPROC) VGetNameByTypeW=GetProcAddress(hModule,"GetNameByTypeW");
    (FARPROC) VGetServiceA=GetProcAddress(hModule,"GetServiceA");
    (FARPROC) VGetServiceW=GetProcAddress(hModule,"GetServiceW");
    (FARPROC) VGetTypeByNameA=GetProcAddress(hModule,"GetTypeByNameA");
    (FARPROC) VGetTypeByNameW=GetProcAddress(hModule,"GetTypeByNameW");
    (FARPROC) VNPLoadNameSpaces=GetProcAddress(hModule,"NPLoadNameSpaces");
    (FARPROC) VSetServiceA=GetProcAddress(hModule,"SetServiceA");
    (FARPROC) VSetServiceW=GetProcAddress(hModule,"SetServiceW");
    (FARPROC) VTransmitFile=GetProcAddress(hModule,"TransmitFile");
    (FARPROC) VWSAAsyncGetHostByAddr=GetProcAddress(hModule,"WSAAsyncGetHostByAddr");
    (FARPROC) VWSAAsyncGetHostByName=GetProcAddress(hModule,"WSAAsyncGetHostByName");
    (FARPROC) VWSAAsyncGetProtoByName=GetProcAddress(hModule,"WSAAsyncGetProtoByName");
    (FARPROC) VWSAAsyncGetProtoByNumber=GetProcAddress(hModule,"WSAAsyncGetProtoByNumber");
    (FARPROC) VWSAAsyncGetServByName=GetProcAddress(hModule,"WSAAsyncGetServByName");
    (FARPROC) VWSAAsyncGetServByPort=GetProcAddress(hModule,"WSAAsyncGetServByPort");
    (FARPROC) VWSAAsyncSelect=GetProcAddress(hModule,"WSAAsyncSelect");
    (FARPROC) VWSACancelAsyncRequest=GetProcAddress(hModule,"WSACancelAsyncRequest");
    (FARPROC) VWSACancelBlockingCall=GetProcAddress(hModule,"WSACancelBlockingCall");
    (FARPROC) VWSACleanup=GetProcAddress(hModule,"WSACleanup");
    (FARPROC) VWSAGetLastError=GetProcAddress(hModule,"WSAGetLastError");
    (FARPROC) VWSAIsBlocking=GetProcAddress(hModule,"WSAIsBlocking");
    (FARPROC) VWSARecvEx=GetProcAddress(hModule,"WSARecvEx");
    (FARPROC) VWSASetBlockingHook=GetProcAddress(hModule,"WSASetBlockingHook");
    (FARPROC) VWSASetLastError=GetProcAddress(hModule,"WSASetLastError");
    (FARPROC) VWSAStartup=GetProcAddress(hModule,"WSAStartup");
    (FARPROC) VWSAUnhookBlockingHook=GetProcAddress(hModule,"WSAUnhookBlockingHook");
    (FARPROC) VWSHEnumProtocols=GetProcAddress(hModule,"WSHEnumProtocols");
    (FARPROC) VWsControl=GetProcAddress(hModule,"WsControl");
    (FARPROC) V__WSAFDIsSet=GetProcAddress(hModule,"__WSAFDIsSet");
    (FARPROC) Vaccept=GetProcAddress(hModule,"accept");
    (FARPROC) Vbind=GetProcAddress(hModule,"bind");
    (FARPROC) Vclosesocket=GetProcAddress(hModule,"closesocket");
    (FARPROC) Vclosesockinfo=GetProcAddress(hModule,"closesockinfo");
    (FARPROC) Vconnect=GetProcAddress(hModule,"connect");
    (FARPROC) Vdn_expand=GetProcAddress(hModule,"dn_expand");
    (FARPROC) Vgethostbyaddr=GetProcAddress(hModule,"gethostbyaddr");
    (FARPROC) Vgethostbyname=GetProcAddress(hModule,"gethostbyname");
    (FARPROC) Vgethostname=GetProcAddress(hModule,"gethostname");
    (FARPROC) Vgetnetbyname=GetProcAddress(hModule,"getnetbyname");
    (FARPROC) Vgetpeername=GetProcAddress(hModule,"getpeername");
    (FARPROC) Vgetprotobyname=GetProcAddress(hModule,"getprotobyname");
    (FARPROC) Vgetprotobynumber=GetProcAddress(hModule,"getprotobynumber");
    (FARPROC) Vgetservbyname=GetProcAddress(hModule,"getservbyname");
    (FARPROC) Vgetservbyport=GetProcAddress(hModule,"getservbyport");
    (FARPROC) Vgetsockname=GetProcAddress(hModule,"getsockname");
    (FARPROC) Vgetsockopt=GetProcAddress(hModule,"getsockopt");
    (FARPROC) Vhtonl=GetProcAddress(hModule,"htonl");
    (FARPROC) Vhtons=GetProcAddress(hModule,"htons");
    (FARPROC) Vinet_addr=GetProcAddress(hModule,"inet_addr");
    (FARPROC) Vinet_network=GetProcAddress(hModule,"inet_network");
    (FARPROC) Vinet_ntoa=GetProcAddress(hModule,"inet_ntoa");
    (FARPROC) Vioctlsocket=GetProcAddress(hModule,"ioctlsocket");
    (FARPROC) Vlisten=GetProcAddress(hModule,"listen");
    (FARPROC) Vntohl=GetProcAddress(hModule,"ntohl");
    (FARPROC) Vntohs=GetProcAddress(hModule,"ntohs");
    (FARPROC) Vrcmd=GetProcAddress(hModule,"rcmd");
    (FARPROC) Vrecv=GetProcAddress(hModule,"recv");
    (FARPROC) Vrecvfrom=GetProcAddress(hModule,"recvfrom");
    (FARPROC) Vrexec=GetProcAddress(hModule,"rexec");
    (FARPROC) Vrresvport=GetProcAddress(hModule,"rresvport");
    (FARPROC) Vs_perror=GetProcAddress(hModule,"s_perror");
    (FARPROC) Vselect=GetProcAddress(hModule,"select");
    (FARPROC) Vsend=GetProcAddress(hModule,"send");
    (FARPROC) Vsendto=GetProcAddress(hModule,"sendto");
    (FARPROC) Vsethostname=GetProcAddress(hModule,"sethostname");
    (FARPROC) Vsetsockopt=GetProcAddress(hModule,"setsockopt");
    (FARPROC) Vshutdown=GetProcAddress(hModule,"shutdown");
    (FARPROC) Vsocket=GetProcAddress(hModule,"socket");
    (FARPROC) VWEP=GetProcAddress(hModule,"WEP");
    (FARPROC) VAcceptEx = GetProcAddress(hModule,"AcceptEx");
    (FARPROC) VGetAcceptExSockaddrs = GetProcAddress(hModule,"GetAcceptExSockaddrs");
    (FARPROC) VMigrateWinsockConfiguration = GetProcAddress(hModule,"MigrateWinsockConfiguration");
    (FARPROC) VWSApSetPostRoutine = GetProcAddress(hModule,"WSApSetPostRoutine");

    CREATE_MUTEX();

#ifdef DO_FILE_CONFIG
    LoadConfig();
#endif

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cachapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapiw.cxx

Abstract:

    contains the UNICODE version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)   Dec-1997
--*/

#include <cache.hxx>
#include <w95wraps.h>

#define NUMBER_MEMBERS 4


const BYTE bOffsetTable[NUMBER_MEMBERS] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszSourceUrlName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszLocalFileName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpHeaderInfo),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszFileExtension)
    };
    
DWORD
TransformA2W(
    IN LPINTERNET_CACHE_ENTRY_INFOA pCEIA,
    IN DWORD cbCEIA,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pCEIW,
    OUT LPDWORD pcbCEIW
    )
{
    DWORD cbSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
    DWORD cc;

    if (!pCEIW || (*pcbCEIW<sizeof(INTERNET_CACHE_ENTRY_INFOW)))
    {
        *pcbCEIW = 0;
        cc = 0;
    }
    else
    {
        //
        // copy fixed portion.
        //
        memcpy((PBYTE)pCEIW, (PBYTE)pCEIA, sizeof(INTERNET_CACHE_ENTRY_INFOW) );
        pCEIW->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
        cc = (*pcbCEIW - sizeof(INTERNET_CACHE_ENTRY_INFOW))/sizeof(WCHAR);
    }

    // Destination for strings
    PWSTR pBuffer = (pCEIW ? (PWSTR)(pCEIW + 1) : NULL);
    // Convert strings
    for (int i=0; i < NUMBER_MEMBERS; i++)
    {
        PSTR *pBufferA = (PSTR*)((PBYTE)pCEIA + bOffsetTable[i]);

        if (*pBufferA)
        {
            DWORD dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, NULL, 0);
            if ((dwTmp<=cc) && pCEIW)
            {
                INET_ASSERT(pBuffer);

                PWSTR *pBufferW = (PWSTR*)((PBYTE)pCEIW + bOffsetTable[i]);
                *pBufferW = pBuffer;
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, *pBufferW, dwTmp);
                pBuffer += dwTmp;
                cc -= dwTmp;
            }
            cbSize += dwTmp*sizeof(WCHAR);
        }
    }

    DWORD dwErr = (*pcbCEIW>=cbSize) ? ERROR_SUCCESS : ERROR_INSUFFICIENT_BUFFER;
    *pcbCEIW = cbSize; // Tell how much space used/needed.
    return dwErr;
}


URLCACHEAPI_(BOOL) CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryW", "%wq, %wq, %d, %wq, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName, mpFileExtension, mpFileName;

    if (lpszUrlName)
    {
        ALLOC_MB(lpszUrlName,0,mpUrlName);
        if (!mpUrlName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    ALLOC_MB(NULL, MAX_PATH, mpFileName);
    if (!mpFileName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    fResult = CreateUrlCacheEntryA(
        mpUrlName.psStr,
        dwExpectedFileSize,
        mpFileExtension.psStr,
        mpFileName.psStr,
        dwReserved);
    if (fResult)
    {
        MultiByteToWideChar(CP_ACP, 0, mpFileName.psStr, -1, lpszFileName, MAX_PATH);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpszHeaderInfo,
    IN DWORD dwHeaders,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryW",
        "%wq, %wq, <expires>, <last-mod>, %d, %wq, %d, %wq, %wq",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpszHeaderInfo,
        dwHeaders,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName, mpLocalFileName, mpFileExtension, mpHeaders, mpOriginalUrl;

    if( IsBadUrlW( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadStringPtrW( lpszLocalFileName, MAX_PATH ) : FALSE ) ) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocalFileName)
    {
        ALLOC_MB(lpszLocalFileName,0,mpLocalFileName);
        if (!mpLocalFileName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszLocalFileName,mpLocalFileName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszHeaderInfo)
    {
        ALLOC_MB(lpszHeaderInfo,0,mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszHeaderInfo,mpHeaders, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

    }
    if (lpszOriginalUrl)
    {
        ALLOC_MB(lpszOriginalUrl,0,mpOriginalUrl);
        if (!mpOriginalUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszOriginalUrl,mpOriginalUrl, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    fResult = CommitUrlCacheEntryA(
            mpUrlName.psStr,
            mpLocalFileName.psStr,
            ExpireTime,
            LastModifiedTime,
            CacheEntryType,
            (LPBYTE)mpHeaders.psStr,
            mpHeaders.dwSize,
            mpFileExtension.psStr,
            mpOriginalUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
RetrieveUrlCacheEntryWCore(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved,
    IN DWORD dwLookupFlags,
    IN DWORD dwRetrievalFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD dwCEI = 0;
    
    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!(lpszUrlName && lpcbCacheEntryInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName, 0, mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName, mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    dwErr = GlobalUrlContainers->RetrieveUrl(
                        mpUrlName.psStr,
                        &pCEIA,
                        &dwCEI,
                        dwLookupFlags,
                        dwRetrievalFlags | RETRIEVE_WITH_ALLOCATION);

    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(
            pCEIA,
            dwCEI,
            lpCacheEntryInfo,
            lpcbCacheEntryInfo);

        if (dwErr!=ERROR_SUCCESS)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
    }

cleanup:
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr == ERROR_SUCCESS);
}


URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileW","%wq, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo, dwReserved));

    BOOL fResult = RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(HANDLE) RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamW",
        "%wq, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpcbCacheEntryInfo,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hInternet = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr = ERROR_SUCCESS, dwFileSize;
    CACHE_STREAM_CONTEXT_HANDLE* pStream;

    if (!RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_NOCREATE,
                        RETRIEVE_WITHOUT_CHECKS))
    {
        goto cleanup;
    }

    fLocked = TRUE;        

    // Allocate a stream handle.
    LOCK_CACHE();
    hInternet = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hInternet)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hInternet);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hInternet)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // Open the file.
    // Does CreateFileW exist on Win9x?

    hFile = CreateFileW
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        dwErr = GetLastError();
        goto cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    {
        MEMORYPACKET mpUrl;
        ALLOC_MB(lpszUrlName,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrlName,mpUrl);
        
        pStream->SourceUrlName = NewString(mpUrl.psStr);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        if (hInternet)
        {
            HandleMgr.Free(hInternet);
            hInternet = NULL;
        }
        if (hFile)
            CloseHandle (hFile);

        if (fLocked)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
        SetLastError (dwErr);
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GetUrlCacheEntryWCore(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        DWORD dwFlags,
        DWORD dwLookupFlags,
        BOOL fConvertHeaders)
{
    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;

    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }

    if (IsBadUrlW(lpszUrl))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrl,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrl,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpcbCacheEntryInfo)
    {
        dwErr = GlobalUrlContainers->GetUrlInfo(
            mpUrlName.psStr,
            &pCEIA,
            &cbCEIA,
            dwFlags,
            dwLookupFlags,
            RETRIEVE_WITH_ALLOCATION);
            
        // convert from ansi to unicode. 
        if (dwErr==ERROR_SUCCESS)
        {
            dwErr = TransformA2W(pCEIA, cbCEIA, lpCacheEntryInfo, lpcbCacheEntryInfo);
            if (dwErr==ERROR_SUCCESS)
            {
                fResult = TRUE;
            }
        }
    }
    else
    {
        fResult = GetUrlCacheEntryInfoExA(
                mpUrlName.psStr, 
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                dwFlags);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return fResult;
}


URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoW", "%wq, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo));

    BOOL fResult = GetUrlCacheEntryWCore(
                            lpszUrlName,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            0,
                            LOOKUP_URL_NOCREATE,
                            TRUE);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI GetUrlCacheEntryInfoExW(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        OUT LPWSTR lpszRedirectUrl,
        IN OUT LPDWORD lpcbRedirectUrl,
        LPVOID lpReserved,
        DWORD dwFlags
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExW",
        "%wq, %#x, %#x, %wq, %#x, %#x, %#x", 
        lpszUrl, lpCacheEntryInfo, lpcbCacheEntryInfo, lpszRedirectUrl, lpcbRedirectUrl, lpReserved, dwFlags));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    
    if (lpszRedirectUrl
        || lpcbRedirectUrl 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = GetUrlCacheEntryWCore(
                            lpszUrl,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            dwFlags,
                            LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS),
                            TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoW", "%wq, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName;
    INTERNET_CACHE_ENTRY_INFOA CacheEntryInfoA;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    memcpy( &CacheEntryInfoA, lpCacheEntryInfo, sizeof(CacheEntryInfoA) );

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryInfoA(
            mpUrlName.psStr,
            &CacheEntryInfoA,
            dwFieldControl );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL FindUrlCacheEntryWCore(
    IN OUT HANDLE     *phFind,
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    IN     BOOL      fConvertHeaders
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpSearchPattern;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;
    BOOL fFindFirst = *phFind==NULL;
    
    // DebugBreak();
    
    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!pcbEntryInfo)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszUrlSearchPattern)
    {
        ALLOC_MB(lpszUrlSearchPattern, 0, mpSearchPattern);
        if (!mpSearchPattern.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlSearchPattern, mpSearchPattern, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = GlobalUrlContainers->FindNextEntry(phFind, 
                                               mpSearchPattern.psStr, 
                                               &pCEIA, 
                                               &cbCEIA,
                                               dwFilter,
                                               GroupId,
                                               dwFlags,
                                               RETRIEVE_WITH_ALLOCATION);

    // TransformA2W will convert from ansi to unicode. ERROR_SUCCESS always means that
    // the cache entry has been returned.
    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(pCEIA,
            cbCEIA,
            pEntryInfo,
            pcbEntryInfo);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        if (fFindFirst && *phFind)
        {
            GlobalUrlContainers->FreeFindHandle(*phFind);
            *phFind = NULL;
        }
        
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr==ERROR_SUCCESS) ;
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryW",
        "%wq, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpcbCacheEntryInfo
    ));

    HANDLE hInternet = FindFirstUrlCacheEntryExW(
                        lpszUrlSearchPattern,
                        FIND_FLAGS_OLD_SEMANTICS,
                        URLCACHE_FIND_DEFAULT_FILTER,
                        NULL,
                        lpFirstCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        NULL,
                        NULL,
                        NULL);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPCACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryW",
       "%#x, %#x, %#x",
        hEnumHandle, 
        pEntryInfo,
        pcbEntryInfo
    ));

    BOOL fResult = FindNextUrlCacheEntryExW(
                    hEnumHandle,
                    pEntryInfo,
                    pcbEntryInfo,
                    NULL, 
                    NULL,
                    NULL);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExW",
        "%wq, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    HANDLE hInternet = NULL;

    FindUrlCacheEntryWCore(
            &hInternet,
            lpszUrlSearchPattern,
            dwFlags,
            dwFilter,
            GroupId,
            pEntryInfo,
            pcbEntryInfo,
            TRUE);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOLAPI FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExW",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hEnumHandle,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    
    if (!hEnumHandle)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = FindUrlCacheEntryWCore(
                        &hEnumHandle,
                        NULL,
                        0,
                        0,
                        0,
                        pEntryInfo,
                        pcbEntryInfo,
                        TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpaceW", 
        "<path>,%d, %#x", dwSize, dwReserved));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;

    MEMORYPACKET mpCachePath;
    if (lpszCachePath)
    {
        ALLOC_MB(lpszCachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszCachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    fResult = FreeUrlCacheSpaceA(
            mpCachePath.psStr,
            dwSize,
            dwReserved );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileW(
    LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFileW",
        "%wq, %#x", lpszUrlName, dwReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = UnlockUrlCacheEntryFileA(mpUrl.psStr, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntryW",
        "%wq", lpszUrlName));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = DeleteUrlCacheEntryA(mpUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UrlCacheEntryExpiredW", 
        "%wq, %#x", lpszUrlName, dwFlags));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = IsUrlCacheEntryExpiredA(
                    mpUrl.psStr,
                    dwFlags,
                    pftLastModifiedTime);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL CacheGroupInfoA2W(
    IN          LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN          DWORD                           dwAnsiGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN OUT      LPDWORD                         lpdwUnicodeGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);

    lpUnicodeGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOW);
    lpUnicodeGroupInfo->dwGroupFlags = lpAnsiGroupInfo->dwGroupFlags;
    lpUnicodeGroupInfo->dwGroupType = lpAnsiGroupInfo->dwGroupType;
    lpUnicodeGroupInfo->dwDiskUsage = lpAnsiGroupInfo->dwDiskUsage;
    lpUnicodeGroupInfo->dwDiskQuota = lpAnsiGroupInfo->dwDiskQuota;

    memcpy(lpUnicodeGroupInfo->dwOwnerStorage,
           lpAnsiGroupInfo->dwOwnerStorage,
           GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );


    BOOL fRet = MultiByteToWideChar(
               CP_ACP,
               MB_PRECOMPOSED,
               lpAnsiGroupInfo->szGroupName,
               -1,         // null terminated ansi string.
               lpUnicodeGroupInfo->szGroupName,
               GROUPNAME_MAX_LENGTH
    );

    if( fRet )
    {
        *lpdwUnicodeGroupInfoSize = lpUnicodeGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwUnicodeGroupInfoSize = 0;
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return fRet;
}

BOOL CacheGroupInfoW2A(
    IN          LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN          DWORD                           dwUnicodeGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN OUT      LPDWORD                         lpdwAnsiGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);
    BOOL fStrNotSafe = FALSE;

    lpAnsiGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    lpAnsiGroupInfo->dwGroupFlags = lpUnicodeGroupInfo->dwGroupFlags;
    lpAnsiGroupInfo->dwGroupType = lpUnicodeGroupInfo->dwGroupType;
    lpAnsiGroupInfo->dwDiskUsage = lpUnicodeGroupInfo->dwDiskUsage;
    lpAnsiGroupInfo->dwDiskQuota = lpUnicodeGroupInfo->dwDiskQuota;

    memcpy( lpAnsiGroupInfo->dwOwnerStorage,
            lpUnicodeGroupInfo->dwOwnerStorage,
            GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );

    BOOL fRet = WideCharToMultiByte(
                CP_ACP,
                0,              // no flags.
                lpUnicodeGroupInfo->szGroupName,
                -1,             // null terminated unicode string.
                lpAnsiGroupInfo->szGroupName,
                GROUPNAME_MAX_LENGTH,
                NULL,           // lpDefaultChar
                &fStrNotSafe    // lpUseDefaultChar
    );
    if (fStrNotSafe)
    {
        fRet = FALSE;
    }

    if( fRet )
    {
        *lpdwAnsiGroupInfoSize = lpAnsiGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwAnsiGroupInfoSize = 0;
    }
    return fRet;
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupW", 
        "%wq, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryGroupA(
                    mpUrl.psStr,
                    dwFlags,
                    GroupId,
                    pbGroupAttributes,
                    cbGroupAttributes,
                    lpReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) GetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeW",
        "%d, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( !lpGroupInfo || !lpdwGroupInfo )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOW) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    if( IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( GetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes,
            &AnsiGroupInfo, &dwAnsiGroupInfoSize, lpReserved ) )
    {
        fResult = CacheGroupInfoA2W( &AnsiGroupInfo, 
                                    dwAnsiGroupInfoSize,
                                    lpGroupInfo, 
                                    lpdwGroupInfo );
    }


Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) SetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW) ) )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else if( CacheGroupInfoW2A(
            lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW),
            &AnsiGroupInfo, &dwAnsiGroupInfoSize ) )
    {
        fResult = SetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes, &AnsiGroupInfo, lpReserved );
    }

    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// Convert all the ansi strings in a structure to unicode

/* How does this work?
    Take this structure for example:

    struct foo 
    {
        DWORD dwA;
        LPTSTR pszB;
        DWORD dwC;
        LPTSTR pszD;
    };
    where LPTSTR are embedded pointers
    
    The memory layout is thus:

    [DWORD][LPTSTR][DWORD][LPTSTR][embedded string pszB][embedded string pszD]
    ^                             ^
    |                             |
    |-struct beginning            |-beginning of embedded strings

    Assuming a 32-bit platform, we can construct pointers (relative to the struct beginning) to each element
    in the structure. In this case,

    { 0, sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Let's say we're interested in strings only, and we know that these strings are embedded. We can create a byte table thus:
    BYTE bFoo[] = { sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Alternatively:
    BYTE bFoo[] = 
    {
        (BYTE)&(((foo*)NULL)->pszB),
        (BYTE)&(((foo*)NULL)->pszD)
    };

    This layout is the same for both Ansi and Unicode versions of a struct, UNLESS the struct contains for example 
    a TCHAR szWhat[256] (in which case, we can't use the bulk converter).

    Pass BulkConverter the following parameters, to convert strings in one swoop.

    pbSrc       = casted pointer to the beginning of the ansi structure
    pbDest      = casted pointer to the beginning of the unicode structure
    cbAvail     = number of bytes available for embedded strings
    wSkip       = offset from the beginning of the structure, at which point embedded strings may be written
    cElements   = number of elements to convert from ansi to unicode

    If BulkConverter succeeds, it'll return the number of bytes used.
    If it fails, it will return the number of bytes needed to store all the unicode strings.

BUT HOW DOES THIS THING WORK?
Oh. 

1. Using the offset table, we figure out where the pointer to the string is in both the structures.
2. Then using magic, we decided where to place the unicode string. 
3. Figure how much space we'll need to store the unicode string
4. If that much is available, convert.
5. Keep track, either way.
6. Go to 1, if we have any other strings left.
*/

LONG BulkConverter(PBYTE pbSrc, PBYTE pbDest, LONG cbAvail, WORD wSkip, CONST BYTE abTable[], WORD cElements)
{
    PWSTR pBuffer = (PWSTR)(pbDest + wSkip);
    PSTR *pBufferA;
    PWSTR *pBufferW;

    for (DWORD i=0; i < cElements; i++)
    {
        pBufferA = (PSTR*)((PBYTE)pbSrc + abTable[i]);
        pBufferW = (PWSTR*)((PBYTE)pbDest + abTable[i]);

        if (*pBufferA)
        {
            *pBufferW = pBuffer;
            LONG dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, 0);
            if (dwTmp<cbAvail)
            {
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, cbAvail);
                pBuffer += dwTmp;
            }
            cbAvail -= dwTmp;
        }
    }
    return cbAvail;
}


const BYTE bOffsetTableContainer[] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszName),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszCachePrefix),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeLabel),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeTitle)
    };

BOOL
TransformCacheContainerInfoToW(
    IN BOOL fResult,
    IN LPINTERNET_CACHE_CONTAINER_INFOA pCCIA,
    IN DWORD cbCCIA,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW pCCIW,
    OUT LPDWORD pcbCCIW
)
{
    DWORD cbSize = *pcbCCIW;

    if (fResult)
    {
        // If we have pointers, try to convert from 

        LONG cc = *pcbCCIW - sizeof(INTERNET_CACHE_CONTAINER_INFOW);
        if (*pcbCCIW > sizeof(INTERNET_CACHE_CONTAINER_INFOW))
        {
            pCCIW->dwCacheVersion = pCCIA->dwCacheVersion;
        }
        cc /= sizeof(WCHAR);
        // Convert strings
        cc = BulkConverter((PBYTE)pCCIA, 
                (PBYTE)pCCIW, 
                cc, 
                sizeof(INTERNET_CACHE_CONTAINER_INFOW), 
                bOffsetTableContainer, 
                ARRAY_ELEMENTS(bOffsetTableContainer));


       // Tell how much space was actually used.
        *pcbCCIW -= cc*sizeof(WCHAR);

        if (*pcbCCIW>cbSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fResult = FALSE;
        }
    }
    else if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
    {
        *pcbCCIW = (cbCCIA - sizeof(INTERNET_CACHE_CONTAINER_INFOA))*sizeof(WCHAR) + sizeof(INTERNET_CACHE_CONTAINER_INFOW);
    }

    return fResult;
}

#define USE_ORIGINAL_CODE

URLCACHEAPI_(BOOL) CreateUrlCacheContainerW(
                 IN LPCWSTR Name,
                 IN LPCWSTR CachePrefix,
                 IN LPCWSTR CachePath,
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                     IN DWORD dwOptions,
                     IN OUT LPVOID pvBuffer,
                     IN OUT LPDWORD cbBuffer)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerW", "%wq, %wq, %wq, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    MEMORYPACKET mpName, mpCachePrefix, mpCachePath;
    BOOL fStrNotSafe = FALSE;

#ifdef USE_ORIGINAL_CODE
    if (Name)
    {
        ALLOC_MB(Name, 0, mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePrefix)
    {
        ALLOC_MB(CachePrefix, 0, mpCachePrefix);
        if (!mpCachePrefix.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePrefix, mpCachePrefix, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePath)
    {
        ALLOC_MB(CachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
#else
// Theoretically, the following fragment should be smaller than the above fragment. 
// Although the retail obj shows a function that's about 100 bytes shorter, the
// actual dll doesn't show this gain. Until I figure this out, we won't use it.

    DWORD c;
    do
    {
        MEMORYPACKET* mp;
        PCWSTR psz;

        switch (c)
        {
        case 0:
            psz = Name;
            mp = &mpName;
            break;
            
        case 1:
            psz = CachePrefix;
            mp = &mpCachePrefix;
            break;

        case 2:
            psz = CachePath;
            mp = &mpCachePath;
            break;
        }
        ALLOC_MB(psz, 0, (*mp));
        if (!mp->psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(psz, (*mp), &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        c++;
    }
    while (c<3);

#endif

    fResult = CreateUrlCacheContainerA(
                mpName.psStr,
                mpCachePrefix.psStr,
                mpCachePath.psStr,
                KBCacheLimit,
                dwContainerType,
                dwOptions,
                pvBuffer,
                cbBuffer);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) DeleteUrlCacheContainerW(
IN LPCWSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerW", "%wq, %#x", Name, dwOptions));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpName;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;

    ALLOC_MB(Name, 0, mpName);
    if (!mpName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    fResult = DeleteUrlCacheContainerA(mpName.psStr, dwOptions);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerW",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpcbContainerInfo,
        dwOptions
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    HANDLE hInternet = NULL;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    hInternet = FindFirstUrlCacheContainerA(pdwModified,
        (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, &mpCacheInfo.dwSize, dwOptions);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    if (!TransformCacheContainerInfoToW(
            hInternet ? TRUE : FALSE,
            (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
            mpCacheInfo.dwSize,
            lpContainerInfo,
            lpcbContainerInfo))
    {
        if (hInternet)
        {
            FindCloseUrlCache(hInternet);
            hInternet = NULL;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerW",
        "%#x, %#x, %#x",
        hEnumHandle, 
        lpContainerInfo,
        lpcbContainerInfo
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    BOOL fResult = FALSE;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    fResult = FindNextUrlCacheContainerA(
                    hEnumHandle,
                    (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, 
                    &mpCacheInfo.dwSize);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    fResult = TransformCacheContainerInfoToW(
                fResult,
                (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
                mpCacheInfo.dwSize,
                lpContainerInfo,
                lpcbContainerInfo);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

/* here's the struct referred to below 

typedef struct _INTERNET_CACHE_CONFIG_INFOA {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            CHAR   CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYA CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOA, * LPINTERNET_CACHE_CONFIG_INFOA;

*/

#define ICCIA_FIXED_PORTION_SIZE ((sizeof(DWORD)*6)+sizeof(BOOL))

URLCACHEAPI_(BOOL) GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoW", "%#x, %#x, %#x",
        pCacheConfigInfo, pcbCacheConfigInfo, dwFieldControl ));

    INTERNET_CACHE_CONFIG_INFOA iccia;
    
    iccia.dwContainer = pCacheConfigInfo->dwContainer;
    iccia.dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    DWORD dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fResult = GetUrlCacheConfigInfoA(&iccia, &dwSize, dwFieldControl);
    if (fResult)
    {
        memcpy(pCacheConfigInfo, &iccia, ICCIA_FIXED_PORTION_SIZE);

        // These are appended to the _end_ of the structure.
        pCacheConfigInfo->dwNormalUsage = iccia.dwNormalUsage;
        pCacheConfigInfo->dwExemptUsage = iccia.dwExemptUsage;
        pCacheConfigInfo->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOW);
        if (pCacheConfigInfo->dwContainer <= HISTORY)
        {
            MultiByteToWideChar(CP_ACP, 0, iccia.CachePath, -1, pCacheConfigInfo->CachePath, ARRAY_ELEMENTS(pCacheConfigInfo->CachePath));
        }
    }

    DEBUG_LEAVE_API (fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) SetUrlCacheConfigInfoW(
    LPCACHE_CONFIG_INFOW lpConfigConfigInfo,
    DWORD dwFieldControl
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cachecfg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cachecfg.cxx

Abstract:

    This module contains the functions to get and set disk cache
    configuration parameters.

    Contents:
        GetCacheConfigInfoA
        SetCacheConfigInfoA

Author:

    Sophia Chung (sophiac)  1-May-1995
    
Environment:

    User Mode - Win32

Revision History:
    Mucho rewritten by Akabir   1Q 98

    To understand how the new registration code works, it might be better for you to start with ConfigureCache, 
    GetCacheConfigInfo, etc. for a high level acquaintance; _then_ start poring over the actual registry sets code.
--*/

#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <shlobj.h>

#define CACHE_TAG           "Cache"

// Cache path keys.
CHAR* g_szSubKey[] = {CONTENT_PATH_KEY, COOKIE_PATH_KEY, HISTORY_PATH_KEY};
CHAR* g_szOldSubKey[] = {CACHE_TAG, COOKIE_PATH_KEY, HISTORY_PATH_KEY};

INT g_iContainerCSIDL[] = { CSIDL_INTERNET_CACHE, CSIDL_COOKIES, CSIDL_HISTORY };
                                
// Top level cache paths resource IDs
#ifndef UNIX
DWORD g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#else
DWORD g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR_UNIX, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#endif /* UNIX */

// Cache prefixes.
CHAR* g_szCachePrefix[] = {CONTENT_PREFIX, COOKIE_PREFIX, HISTORY_PREFIX};
CHAR* g_szVersionName[] = { CONTENT_VERSION_SUBDIR, "", "History.IE5" };

#define OLD_CACHE_PATH      "Path1"
#define OLD_CACHE_SUBKEY    DIR_SEPARATOR_STRING##"Cache1"

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

void FlushShellFolderCache()
{
    SHFlushSFCacheWrap( );
    return;
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

VOID CheckCacheLocationConsistency();

//#define DEBUG_CACHE_UPGRADE

#ifdef DEBUG_CACHE_UPGRADE
VOID LOG_UPGRADE_DATA(PTSTR pszData)
{
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\cacheupgrade\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (hResultsFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)pszData, lstrlenA(pszData), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}
#else
#define LOG_UPGRADE_DATA(x)
#endif

#undef SHGetFolderPath

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    HRESULT hr = E_POINTER;
    static PFNSHGETFOLDERPATH pfn = NULL;

    if (NULL == pfn)
    {
        if (NULL == g_HMODShell32)
            g_HMODShell32 = LoadLibrary("shell32.dll");
        if (NULL != g_HMODShell32)
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODShell32, "SHGetFolderPathA");

        if (NULL == pfn)
        {
            if (NULL == g_HMODSHFolder)
                g_HMODSHFolder = LoadLibrary("shfolder.dll");
            if (NULL != g_HMODSHFolder)
                pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODSHFolder, "SHGetFolderPathA");
        }
        
        if (NULL != pfn)
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
    }
    else
        hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);

    return hr;
}

#define CACHE_SIZE_CAP 32000000

DWORD 
GetDefaultCacheQuota(
    LPSTR pszCachePath, 
    DWORD dwFraction
    )
{ 
    DWORDLONG cKBLimit = 0, cbTotal;

    if (GetDiskInfo(pszCachePath, NULL, NULL, &cbTotal))
    {
        cKBLimit = (cbTotal / (DWORDLONG)(1024*dwFraction));
    }
    if (cKBLimit<1024)
    {
        cKBLimit = DEF_CACHE_LIMIT;
    }
    else if (cKBLimit > CACHE_SIZE_CAP)
    {
        cKBLimit = CACHE_SIZE_CAP;
    }

    return (DWORD)cKBLimit;
}
        
VOID CleanPath(PTSTR pszPath);

/*-----------------------------------------------------------------------------
NormalisePath
 (code swiped from shell32\folder.c: UnexpandEnvironmentstring)

  Collapses paths of the form C:\foobar\dir1\...\dirn to
  %FOOBAR%\dir1\...\dirn
  where %FOOBAR% = "C:\foobar".
  storing result in pszOut.

  If collapse is not possible, returns FALSE and path is unchanged.
  If the given environment variable exists as the first part of the path,
  then the environment variable is inserted into the output buffer.

  Returns TRUE if pszResult is filled in.
  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SystemRoot%
            Output -- %SystemRoot%\SYSTEM32\FOO.TXT

---------------------------------------------------------------------------*/


BOOL NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
//     DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)) - 1; // don't count the NULL
//    akabir: a curious bug? causes ExpandEnvironmentStrings to return twice the number of characters.

    ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1); // don't count the NULL
    DWORD dwEnvVar = lstrlen(szEnvVar);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) 
    {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
            strncpy(pszResult, pszEnvVar, MAX_PATH);
            strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
            return TRUE;
        }
    }
    return FALSE;
}

VOID CompressPath(LPTSTR pszSrc, LPTSTR pszDest)
{
    if (!NormalisePath(pszSrc, TEXT("%USERPROFILE%"), pszDest, MAX_PATH))
    {
        if (!NormalisePath(pszSrc, TEXT("%SystemRoot%"), pszDest, MAX_PATH))
        {
            strncpy(pszDest, pszSrc, MAX_PATH);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// IE 3, 4 and 5 have different registry settings. These classes help ensure they all stay in sync.


// -- IE5's registry set ------------------------------------------------------------------------------------------------
// *** If using multiple registry sets, use InitialiseKeys for IE5 first.***
// This is to ensure that profiles-capabilities are noted.

class IE5_REGISTRYSET
{
protected:
    REGISTRY_OBJ m_roHKLMCache, m_roHKCUCache, m_roShellFolder, m_roUserShellFolder, m_roWorking;
    BOOL m_fProfiles;
    BOOL m_fWorkingPerUser;
    TCHAR m_szSharedPath[MAX_PATH];
    TCHAR m_szProfilePath[MAX_PATH];
    DWORD cbP, cbS, m_dwWorking;
    BOOL m_fInitialised;
    
    DWORD InitCommonKeys(BOOL fProfilesCapable, LPSTR pszReg)
    {
        DWORD dwError, dwFlag = CREATE_KEY_IF_NOT_EXISTS;

        m_fProfiles = fProfilesCapable;
        // Shared item info are located in HKLM/[...]/Internet Settings/5.0/Cache/*
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag);
        if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
        {
            m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag, BASIC_ACCESS);
            if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roShellFolder.WorkWith(HKEY_CURRENT_USER, SHELL_FOLDER_KEY, dwFlag);
        if (dwError = m_roShellFolder.GetStatus()!=ERROR_SUCCESS)
                goto exit;

        if (fProfilesCapable)
        {
            m_roHKCUCache.WorkWith(HKEY_CURRENT_USER, pszReg, dwFlag);
            if (dwError = m_roHKCUCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roUserShellFolder.WorkWith(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY, dwFlag);
        dwError = m_roUserShellFolder.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            m_fInitialised = TRUE;
        }
        // Per-user items are located in HKCU/[...]/Explorer/Shell Folders and /Internet Settings/[5.0/]Cache/*
    exit:
        return dwError;
    }

    virtual BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        // Determine if this is a per-user item
        // HKCU overrides HKLM
        // If any of the following fail, for content, we'll default to shared.

        if (!m_fProfiles)
        {
            return FALSE;    
        }
        
        DWORD dwTemp;
        REGISTRY_OBJ roCUContainer(&m_roHKCUCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        if ((roCUContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roCUContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }
        
        REGISTRY_OBJ roLMContainer(&m_roHKLMCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        BOOL fPerUser = FALSE;

        if ((roLMContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roLMContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }  

        // On NT, the default will be a per-user container.
#ifndef UNIX
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : (dwWhich!=CONTENT);
#else
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_UNIX) ? TRUE : (dwWhich!=CONTENT);
#endif /* UNIX */

        roLMContainer.SetValue(PER_USER_KEY, &dwTemp);
        roCUContainer.SetValue(PER_USER_KEY, &dwTemp);
        return (BOOL)dwTemp;
    }


    // -- ValidatePath ------
    // We always assume we've been given a valid path, but we have to test that it's there
    // and available.
    BOOL ValidatePath(PSTR pszPath)
    {
        DWORD dwAttribute = GetFileAttributes(pszPath);
        if (dwAttribute==0xFFFFFFFF)
        {
            // We assume that the directory just isn't there. So we create it.
            hConstructSubDirs(pszPath);
            dwAttribute = GetFileAttributes(pszPath);
        }
        if ((dwAttribute==0xFFFFFFFF)
            ||
            (dwAttribute & FILE_ATTRIBUTE_READONLY)
            ||
            (!(dwAttribute & FILE_ATTRIBUTE_DIRECTORY)))
        {
            // BUG BUG BUG We probably want to make sure that the old path gets deleted on other machines....
            // We'll use the system path
            // BUG BUG BUG BUG BUG We are *NOT* recording this default location in the registry. Thus, on another
            // machine, the user might still be able to use the set cache location.
            memcpy(pszPath, m_szSharedPath, cbS);
            LoadString(GlobalDllHandle, g_dwCachePathResourceID[m_dwWorking], pszPath+cbS, MAX_PATH - cbS);
            SetPerUserStatus(FALSE);
        }
        return ERROR_SUCCESS;
    }
    
public:
    IE5_REGISTRYSET()
    {
        m_fInitialised = FALSE;
    }

    virtual DWORD InitialiseKeys(BOOL& fProfilesCapable)
    {
        if (m_fInitialised)
        {
            fProfilesCapable = m_fProfiles;
            return ERROR_SUCCESS;
        }

        DWORD dwError = ERROR_SUCCESS;

        fProfilesCapable = TRUE;
#ifndef UNIX
        cbS = GetWindowsDirectory(m_szSharedPath, sizeof(m_szSharedPath));
#else
        /* On Unix, GetWindowsDirectory points to <install dir>/common
         * And, we don't want to put the cache here.
         */
        lstrcpy(m_szSharedPath, UNIX_SHARED_CACHE_PATH);
        cbS = lstrlen(m_szSharedPath);
#endif /* UNIX */
        if (!cbS || (cbS>sizeof(m_szSharedPath)))
            return ERROR_PATH_NOT_FOUND;
            
        AppendSlashIfNecessary(m_szSharedPath, &cbS);

        cbP = 0;
        // We think that profiles are enabled, so we want to get some info before
        // proceeding. If any of this fails, though, we'll default to no profiles.
        switch (GlobalPlatformType)
        {
#ifndef UNIX
        case PLATFORM_TYPE_WIN95:
        {
            REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
            DWORD dwProfilesEnabled = 0;
            if (  (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
                && 
                  ((roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled))==ERROR_SUCCESS)
                &&
                  dwProfilesEnabled)
            {                        
                  // Windows 95 sets the profiles path in the registry.
                CHAR szProfilesRegValue[MAX_PATH];
                memcpy(szProfilesRegValue, PROFILES_PATH_VALUE, sizeof(PROFILES_PATH_VALUE)-1);
                cbP = sizeof(PROFILES_PATH_VALUE)-1;
                AppendSlashIfNecessary(szProfilesRegValue, &cbP);
                cbP = MAX_PATH-sizeof(PROFILES_PATH_VALUE);
                if (GetUserName(szProfilesRegValue + sizeof(PROFILES_PATH_VALUE), &cbP))
                {
                    cbP = MAX_PATH;
                    REGISTRY_OBJ roProfilesDirKey(HKEY_LOCAL_MACHINE, szProfilesRegValue);

                    if (!(((dwError = roProfilesDirKey.GetStatus()) != ERROR_SUCCESS)
                        || 
                        ((dwError = roProfilesDirKey.GetValue(PROFILES_PATH, (LPBYTE) m_szProfilePath, 
                                &cbP)) != ERROR_SUCCESS)))
                    {
                        m_szProfilePath[cbP-1] = DIR_SEPARATOR_CHAR;
                        m_szProfilePath[cbP] = '\0';
                        break;
                    }
                }
            }
            // Either
            // (a) Couldn't get the profiles path from the registry.
            // (b) Couldn't get the user name! 
            // Make the directory the windows directory
            fProfilesCapable = FALSE;
            break;
        }
            
        case PLATFORM_TYPE_WINNT:
            // Windows NT sets the USERPROFILE environment
            // string which contains the user's profile path
            if (cbP = GetEnvironmentVariable("USERPROFILE", m_szProfilePath, MAX_PATH))
            {
                m_szProfilePath[cbP++] = DIR_SEPARATOR_CHAR;
                m_szProfilePath[cbP] = '\0';
            }
            else
            {
                INET_ASSERT(FALSE);
                // Getting the user profiles dir from the environment
                // failed. Set the profiles directory to default.
                memcpy(m_szProfilePath, m_szSharedPath, cbS);
                memcpy(m_szProfilePath + cbS, DEFAULT_PROFILES_DIRECTORY, sizeof(DEFAULT_PROFILES_DIRECTORY));
                cbP = cbS + sizeof(DEFAULT_PROFILES_DIRECTORY) - 1;

                DWORD cbUser = MAX_PATH - cbP;;
                GetUserName(m_szProfilePath + cbP, &cbUser);
                cbP += cbUser;
            }
            break;

#else /* UNIX */
        case PLATFORM_TYPE_UNIX:
            lstrcpy(m_szProfilePath,TEXT("%USERPROFILE%"));
            lstrcat(m_szProfilePath,DIR_SEPARATOR_STRING);
            cbP = lstrlen(m_szProfilePath);
            break;
#endif /* UNIX */

        default:
            // This should never happen.
            INET_ASSERT(FALSE);
        }

        if (dwError==ERROR_SUCCESS)
        {
            dwError = InitCommonKeys(fProfilesCapable, CACHE5_KEY);
        }
        return dwError;
    }

    DWORD SetWorkingContainer(DWORD dwWhich)
    {
        m_dwWorking = dwWhich;
        m_fWorkingPerUser = DetermineKeyPlacing(dwWhich);
        return m_roWorking.WorkWith((m_fWorkingPerUser ? &m_roHKCUCache : &m_roHKLMCache), g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
    }

    VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit);

    // Path --------------------------------------------------------------------------
    virtual DWORD GetPath(PTSTR pszPath)
    {
        if ((S_OK==SHGetFolderPath(NULL, g_iContainerCSIDL[m_dwWorking] | CSIDL_FLAG_CREATE, NULL, 0, pszPath))
            && (*pszPath!='\0'))
        {
            DWORD dwErr = ValidatePath(pszPath);
            if (dwErr==ERROR_SUCCESS)
            {
                DWORD ccPath = lstrlen(pszPath);
                // We check the lengths of the strings only when we're moving the containers. No need to do the check every
                // time (assume a valid path)
                if (m_dwWorking!=COOKIE)
                {
                    EnableCacheVu(pszPath, m_dwWorking);
                }
                AppendSlashIfNecessary(pszPath, &ccPath);

#ifdef UNIX
               /* On Unix, it is possible that IE4 and IE5 co-exist on a user's
                * installation. So, we need to keep the IE4 cookies which are
                * different from the IE5 cookies. For IE5, we have the following
                * configuration for the caches -
                *
                * cookies - %HOME%/.microsoft/ie5/Cookies
                * content - %HOME%/.microsoft/ie5/TempInternetFiles/Content.IE5
                * history - %HOME%/.microsoft/ie5/History/History.IE5
                */
               CHAR szIE5Dir[] = "ie5/";
               int  index = ccPath-2; // skip the last slash
               int  lenIE5Dir = lstrlen(szIE5Dir);

               while(index >= 0 && pszPath[index] != FILENAME_SEPARATOR) 
                    index--;

               index++;
               memmove(&pszPath[index+lenIE5Dir],&pszPath[index],ccPath-index+2);
               memcpy(&pszPath[index],szIE5Dir,lenIE5Dir);
               ccPath += lenIE5Dir;
#endif /* UNIX */

                memcpy(pszPath+ccPath, g_szVersionName[m_dwWorking], lstrlen(g_szVersionName[m_dwWorking])+1);
                if (GlobalIdentity && (m_dwWorking!=CONTENT))
                {
                    if (!GenerateStringWithOrdinal(NULL, GlobalIdentity, pszPath, MAX_PATH))
                    {
                        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
                    }
                }
            }
            return dwErr;
        }
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    virtual DWORD SetPath(PTSTR pszPath)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        DWORD dwError;

        /* Try to preserve the environment variables on Unix */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));
        if (m_fProfiles)
        {
            CHAR szScratch[MAX_PATH];
            CompressPath(pszPath, szScratch);
            if ((dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szScratch, REG_EXPAND_SZ))==ERROR_SUCCESS)
            {
#ifndef UNIX
               DWORD dwType = REG_SZ;
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
#else
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
            }
            // Possible BUG: If we move from the profiled path to the shared path, we still record it as a peruseritem.
            SetPerUserStatus(TRUE);            
        }
        // Non-profiles-enabled machine
        // On Win9x machines, with profiles disabled, we need to write the path to the 
        // HKEY_USERS/.default/blah blah/Explorer/User Shell Folders to ensure that SHGetFolderPath returns
        // the proper value for other users. 
        else
        {
            REGISTRY_OBJ roProfilesLessPath(HKEY_USERS, PROFILELESS_USF_KEY);
            dwError = roProfilesLessPath.GetStatus();
            if (dwError==ERROR_SUCCESS)
            {
                if ((dwError = roProfilesLessPath.SetValue(g_szOldSubKey[m_dwWorking],pszPath, REG_EXPAND_SZ))==ERROR_SUCCESS)
                {
#ifndef UNIX
                    DWORD dwType = REG_SZ;
#else
                    DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */
                    dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
                }
            }
            // For IE4 compatibility, we might have to adjust the old cache location here, as well.
        }
        return dwError;
    }


    // Prefix ------------------------------------------------------------------------
    virtual DWORD GetPrefix(LPSTR szPrefix)
    {
        DWORD dwError, cbKeyLen = MAX_PATH;
        if ((dwError = m_roWorking.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szPrefix, &cbKeyLen))==ERROR_SUCCESS)
        {
            if (cbKeyLen > 0)
            {
                // Strip trailing whitespace.
                cbKeyLen--;
                StripTrailingWhiteSpace(szPrefix, &cbKeyLen);
            }
        }
        else
        {
            // If no prefix found in registry create via
            // defaults and write back to registry.
            strncpy(szPrefix, g_szCachePrefix[m_dwWorking], MAX_PATH);
            SetPrefix(szPrefix);
            dwError = ERROR_SUCCESS;
        }
        
        return dwError;
    }

    virtual DWORD SetPrefix(PTSTR pszPrefix)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        return m_roWorking.SetValue(CACHE_PREFIX_VALUE, (pszPrefix) ? pszPrefix : g_szCachePrefix[m_dwWorking], REG_SZ);
    }

    // Limit -------------------------------------------------------------------------
    virtual DWORD GetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        if ((m_roWorking.GetValue(CACHE_LIMIT_VALUE, &cbLimit)!=ERROR_SUCCESS) || (cbLimit < 512))
        {
            cbLimit = 0;
            return SetLimit(pszCachePath, cbLimit);
        }
        return ERROR_SUCCESS;
    }

    virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit);

    // Use IsFirstTime* to figure out if this is the first time for this install of wininet and for marking it so ------------
private:
    BOOL IsFirstTimeFor(HKEY hKey)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig(hKey, CACHE5_KEY);

        return roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS ? 
                        strcmp(szSigKey, CACHE_SIGNATURE) : TRUE;
    }

public:
    BOOL IsFirstTimeForUser()
    {
        return IsFirstTimeFor((m_fProfiles ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE));
    }

    BOOL IsFirstTimeForMachine()
    {
        return IsFirstTimeFor(HKEY_LOCAL_MACHINE);
    }

    VOID SetIfFirstTime()
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];

        // On a profiles-not-enabled machine, store the signature in HKLM so we don't have to research for values
        // On a profiles-enabled machine, store there to notify IE of previous installation of IE5.
        REGISTRY_OBJ roSig(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);

        // On profiles-enabled machines,  we store a signature in HKCU so that we don't have to do 
        // much hunting for registry values
        if (m_fProfiles)
        {
            REGISTRY_OBJ roSig(HKEY_CURRENT_USER, CACHE5_KEY);
            roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);
        }        
    }

    // PerUserItem ---------------------------------------------------------------------
    virtual VOID SetPerUserStatus(BOOL fState)
    {
        DWORD flState = fState;
        if (m_fProfiles && fState!=m_fWorkingPerUser)
        {
            REGISTRY_OBJ roTemp(&m_roHKCUCache, g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);            
            if (roTemp.GetStatus()==ERROR_SUCCESS)
            {
                roTemp.SetValue(PER_USER_KEY, &flState);
                m_roWorking.WorkWith((fState ? &m_roHKCUCache
                                             : &m_roHKLMCache), g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);
                m_fWorkingPerUser = fState;
            }
        }
    }

    virtual DWORD GetPerUserStatus()
    {
        return m_fWorkingPerUser;
    }

    DWORD UpdateContentPath(PSTR pszNewPath)
    {
        TCHAR szOldPath[MAX_PATH];
        DWORD dwError;

        dwError = ERROR_SUCCESS;

        if ((dwError=SetWorkingContainer(CONTENT))==ERROR_SUCCESS)
        {
            INTERNET_CACHE_CONFIG_INFOA icci;
            icci.dwContainer = CONTENT;
            GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
            strncpy(szOldPath, icci.CachePath, ARRAY_ELEMENTS(szOldPath));

            if (((dwError=MoveCachedFiles(szOldPath, pszNewPath))==ERROR_SUCCESS)
                &&
                ((dwError=SetPath(pszNewPath))==ERROR_SUCCESS))
            {
                EnableCacheVu(pszNewPath);

            // Right now, we're adding entries so that once we restart, we'll delete any
            // stray files.

            // BUT, there's a case that Move will be interrupted; in that case, we ought
            // to finish the move on start up -- pop up a dialog notifying user of such
            // and then delete.
            // Also, if the Move's interrupted, then this info never will get written. OTOH,
            // we can argue that the user can just move from the old location to the new.
    
                CHAR szRunOnce          [2 * MAX_PATH];
                CHAR szSystemPath       [MAX_PATH];

            // Add a RunOnce entry to be run on reboot.
                REGISTRY_OBJ roRunOnce((m_fWorkingPerUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), RUN_ONCE_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if ((dwError=roRunOnce.GetStatus())!=ERROR_SUCCESS)
                    return dwError;

            // create RunOnce string in the form:
            // "rundll32.exe <system dir>\wininet.dll,RunOnceUrlCache C:\Windows\NewCacheLocation"
                if (!GetSystemDirectory(szSystemPath, MAX_PATH))
                    return ERROR_INTERNAL_ERROR;
       
                DisableCacheVu(szOldPath);
                // Get rid of content.ie5.
                PathRemoveBackslash(szOldPath);
                PathRemoveFileSpec(szOldPath);
                DisableCacheVu(szOldPath);
                GetShortPathName(szOldPath, szOldPath, ARRAY_ELEMENTS(szOldPath));
                wnsprintf(szRunOnce, sizeof(szRunOnce),
                            "rundll32.exe %s\\wininet.dll,RunOnceUrlCache %s", 
                            szSystemPath, szOldPath);
                
            // Set the RunOnce command in registry for wininet.
                roRunOnce.SetValue(TEXT("MovingCacheA Wininet Settings"), (LPSTR)szRunOnce, REG_SZ);
            }
        }
        return dwError;
    }
};

#define m_roPaths           m_roShellFolder
#define m_roSpecialPaths    m_roHKCUCache

class IE3_REGISTRYSET : public IE5_REGISTRYSET
{
    // Registry keys shipped with IE 3:
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths\path1
    //                                                                        \path2
    //                                                                        \path3
    //                                                                        \path4
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths\Cookies
    //                                                                                \History
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Url History

private:
    REGISTRY_OBJ m_roPath[DEF_NUM_PATHS]; 
    
public:
    // Initialise the IE3 keys that we might work with.
    
    DWORD InitialiseKeys()
    {
        DWORD dwError, i;
        TCHAR szScratch[MAX_PATH];
        TCHAR pszBase[MAX_PATH];
        DWORD dwBaseLen;

        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, OLD_CACHE_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roHKLMCache.GetStatus())!=ERROR_SUCCESS)
                goto exit;

        m_roPaths.WorkWith(&m_roHKLMCache, CACHE_PATHS_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roPaths.GetStatus())!=ERROR_SUCCESS)
            goto exit;

        memcpy(pszBase, OLD_CACHE_PATH, sizeof(OLD_CACHE_PATH));
        dwBaseLen = sizeof(OLD_CACHE_PATH) - 1;
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            pszBase[dwBaseLen-1] = (TCHAR)('1' + i);
            m_roPath[i].WorkWith(&m_roPaths, pszBase, CREATE_KEY_IF_NOT_EXISTS);
            if ((dwError=m_roPath[i].GetStatus())!=ERROR_SUCCESS)
                goto exit;
        }

        m_roSpecialPaths.WorkWith(&m_roHKLMCache, CACHE_SPECIAL_PATHS_KEY);
        m_fInitialised = TRUE;
    exit:
        return dwError;
    }

    BOOL GetContentDetails(LPSTR szPath, DWORD& cbLimit)
    {
        DWORD cbKey = MAX_PATH;
        if (m_roPaths.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szPath, &cbKey)!=ERROR_SUCCESS)
            return FALSE;

        cbLimit = 0;
        for (int i=0; i<DEF_NUM_PATHS; i++)
        {
            if (m_roPath[i].GetValue(CACHE_LIMIT_VALUE, &cbKey)!=ERROR_SUCCESS)
            {
                cbLimit = GetDefaultCacheQuota(szPath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION);
                break;
            }
            cbLimit += cbKey;
        }
        return TRUE;
    }

    DWORD SetPath(PTSTR pszPath)
    {
        DWORD i, nPaths, dwError;
        DWORD cb = strlen((LPSTR)pszPath);
        TCHAR szBase[MAX_PATH];
#ifndef UNIX
        DWORD dwType = REG_SZ;
#else
        DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */

        /* On Unix, try to preserve the Environment variables if possible */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));


        // Cache content path.
        if ((dwError = m_roPaths.SetValue(CACHE_DIRECTORY_VALUE, (LPSTR)pszPath, dwType)) != ERROR_SUCCESS)
            goto exit;

        // Number of subdirectories (optional).
        nPaths = DEF_NUM_PATHS;
        if ((dwError = m_roPaths.SetValue(CACHE_PATHS_KEY, &nPaths)) != ERROR_SUCCESS)
            goto exit;
    
        memcpy(szBase, pszPath, cb);
        memcpy(szBase + cb, OLD_CACHE_SUBKEY, sizeof(OLD_CACHE_SUBKEY));
        cb += sizeof(OLD_CACHE_SUBKEY) - 2;
        // Subdirectories' paths and limits from CONTENT.
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            szBase[cb] = (TCHAR)('1' + i);
            if ((dwError = m_roPath[i].SetValue(CACHE_PATH_VALUE, szBase, REG_SZ)) != ERROR_SUCCESS)
                goto exit;    
        }

    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    DWORD SetLimit(DWORD dwLimit)
    {
        DWORD i, nPaths, dwError;

        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            DWORD cbCacheLimitPerSubCache = (DWORD) (dwLimit/ DEF_NUM_PATHS);
            if ((dwError = m_roPath[i].SetValue(CACHE_LIMIT_VALUE, &cbCacheLimitPerSubCache)) != ERROR_SUCCESS)
                goto exit;
        }
    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    // Restore key IE3 values. *snicker* --------------------------------------------
    VOID FixLegacySettings(PTSTR pszPath, DWORD cbLimit)
    {
        if (InitialiseKeys()==ERROR_SUCCESS)
        {
            SetPath(pszPath);
            SetLimit(cbLimit);
        }
    }
};

class IE4_REGISTRYSET : public IE5_REGISTRYSET
{
private:
    BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        DWORD dwValue;
        if (m_fProfiles && (dwWhich==CONTENT))
        {
            if (m_roHKLMCache.GetValue(PROFILES_ENABLED, &dwValue)==ERROR_SUCCESS)
            {
                return dwValue;
            }

#ifndef UNIX
            if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
            if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* !UNIX */
            {
               return m_fProfiles;
            }

            // On Win9x we have to go through the following contortions to decide whether or not the
            // user is using a per-user cache or a shared cache.
         
            TCHAR szPath[MAX_PATH];
            DWORD cbPath = sizeof(szPath);
            if (m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS)
            {
                cbPath = sizeof(szPath);
                return (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS);
            }
        }
        return m_fProfiles;
    }

public:
    DWORD InitialiseKeys(BOOL& fProfiles)
    {
        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        return InitCommonKeys(fProfiles, OLD_CACHE_KEY);
    }

    DWORD GetPath(PTSTR pszCachePath)
    {
        DWORD cbKeyLen = MAX_PATH;
        LOG_UPGRADE_DATA("Getting IE4 cache location...\n");

        DWORD dwError = m_fProfiles ? m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)pszCachePath, &cbKeyLen) 
                                          : m_roWorking.GetValue(CACHE_PATH_VALUE, (LPBYTE)pszCachePath, &cbKeyLen);
#ifndef UNIX
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_WINNT) && (dwError==ERROR_SUCCESS))
#else
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_UNIX) && (dwError==ERROR_SUCCESS))
#endif /* UNIX */
        {
           LOG_UPGRADE_DATA("Correcting IE4 cache location...\n");
           LOG_UPGRADE_DATA(pszCachePath);
           LOG_UPGRADE_DATA("\n");
           TCHAR szPath[MAX_PATH];
           DWORD cbPath = ARRAY_ELEMENTS(szPath);
            if (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)!=ERROR_SUCCESS)
            {
                CompressPath(pszCachePath, szPath);
                dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szPath, REG_EXPAND_SZ);
            }
        }
        return dwError;
    }

    BOOL WasIE4Present(BOOL& fProfilesCapable)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig((fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), OLD_CACHE_KEY);

        return (roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS);
    }

    DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        // If no limit found in registry create via
        // defaults and write back to registry.
        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (cbLimit==0)
        {
            cbLimit = (m_dwWorking==CONTENT) 
                            ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                            : DEF_CACHE_LIMIT;
        }

        // Dumb hack for back compat. *sigh*
        if (m_dwWorking==CONTENT)
        {
            REGISTRY_OBJ roLimit(&m_roHKLMCache, g_szSubKey[CONTENT]);
            if (roLimit.GetStatus()==ERROR_SUCCESS)
            {
                roLimit.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
            }
        }
        return m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    }
};


DWORD IE5_REGISTRYSET::SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
{
    INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
    // If no limit found in registry create via
    // defaults and write back to registry.
    // Cache limit - for the content cache we calculate the cache limit
    // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
    // are set to DEF_CACHE_LIMIT.
    if (cbLimit==0)
    {
        cbLimit = (m_dwWorking==CONTENT) 
                        ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                        : DEF_CACHE_LIMIT;
    }
    DWORD dwError = m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    if (dwError==ERROR_SUCCESS)
    {
        // Hack so that apps that read the cache quota from the registry are
        // still able to do so.
        IE4_REGISTRYSET ie4;
        dwError = ie4.InitialiseKeys(m_fProfiles);
        if (dwError==ERROR_SUCCESS)
        {
            ie4.SetWorkingContainer(m_dwWorking);
            ie4.SetLimit(pszCachePath, cbLimit);
        }
    }
    return dwError;
}


#define IsFieldSet(fc, bitFlag) (((fc) & (bitFlag)) != 0)

#define FAILSAFE_TIMEOUT (60000)
#define UNMAP_TIME (120000)

// ----------------------------------------------------------------------------
// The following functions deal with keeping the cache containers all up and ready

// -- ConfigureCache() --------------------------------------------------------
// Get the cache info from registry and try to init.

// In general, GetCacheConfigInfo should only rarely fail -- mostly whenever HKCU
// is expected but not available. In that case, we use the system root cache. 
// If _that_ fails, we panic.

DWORD CConMgr::ConfigureCache()
{
    for (DWORD iter = 0; ; iter++)
    {
        DWORD dwError;
        switch (iter)
        {
        case 0:
            dwError = GetCacheConfigInfo();
            break;

        case 1:
            dwError = GetSysRootCacheConfigInfo();
            break;

        default:
            INET_ASSERT(FALSE);
            return dwError;
        }

        if (dwError==ERROR_SUCCESS && (dwError=InitFixedContainers())==ERROR_SUCCESS)
            break;

        // If InitFixedContainers has failed, it is possible that the container list 
        // (ConList) is not empty. Make sure it has no entries.
        LOCK_CACHE();
        if (ConList.Size() != 0)
            ConList.Free();
        UNLOCK_CACHE();
    }

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetCacheConfigInfo
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetCacheConfigInfo()
{
    DWORD dwError, i;

    // Prepare and initialise a registry set for every version of IE available.
    // IE5 must be initialised first because it determines whether profiles are
    // enabled on this machine and set ConMgr's _fProfilesCapable for future
    // reference. Then IE4 and IE3 can be called in whatever order.
    IE5_REGISTRYSET ie5rs;
    if ((dwError=ie5rs.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
    {
        goto exit;
    }

#ifdef WININET6
    GlobalCacheHKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
#endif

    // Look for a signature to indicate that this cache has been placed before.
    if (ie5rs.IsFirstTimeForUser())
    {
        LOG_UPGRADE_DATA("Install 1st time for user\n");
        DiscoverRegistrySettings(&ie5rs);
    } else {
        // If the user is roaming across machines that include IE4,
        // then safeguard against IE4 writing REG_SZ values that
        // be REG_EXPAND_SZ.
        CheckCacheLocationConsistency();
    }

    // -----------------------------------------------------------------------------------
    // Get the container paths, prefixes (if any) and default limit values.
    for (i = CONTENT; i < NCONTAINERS; i++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        DWORD cbCacheLimit;
        BOOL fPerUser;
        // This should only rarely fail.

        if ((dwError=ie5rs.SetWorkingContainer(i))!=ERROR_SUCCESS)
        {
            goto exit;
        }
        
        fPerUser = ie5rs.GetPerUserStatus();
        dwError = ie5rs.GetPath(szCachePath);
        LOG_UPGRADE_DATA("GetCacheConfigInfo/ie5rs.GetPath for user: ");
        LOG_UPGRADE_DATA(szCachePath);
        LOG_UPGRADE_DATA("\n");

        if (dwError==ERROR_SUCCESS) 
        {
            ie5rs.GetPrefix(szCachePrefix);
            ie5rs.GetLimit(szCachePath, cbCacheLimit);
        }
        else
        {
            break;
        }

        // Got info, now create the container --------------------------------------
        _coContainer[i] = new URL_CONTAINER(g_szSubKey[i], 
                                            szCachePath, 
                                            szCachePrefix, 
                                            (LONGLONG)cbCacheLimit*1024,
                                            0);

        if (_coContainer[i])
        {
            dwError = _coContainer[i]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[i];
                break;
            }
            ConList.Add(_coContainer[i]);
            _coContainer[i]->SetPerUserItem(fPerUser);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Maintain values for backwards compatibility
        if (i==CONTENT)
        {
            // If repairing IE3's settings fails, well, who cares? IE5 is still going.
            IE3_REGISTRYSET ie3rs;
            ie3rs.FixLegacySettings(szCachePath, cbCacheLimit);
        }
    }

exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetSysRootCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetSysRootCacheConfigInfo()
{
    CHAR szParentPath[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szParentPath);

#ifndef UNIX
    {
        // In case of failure to create containers in the regular location,
        // we should put the cache in a user-specifiable location HKLM\* REG_EXPAND_SZ
        // Otherwise in the temp directory
        // Otherwise in the Windows directory
        REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        BOOL fResult = FALSE;
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];
            if (roCache.GetValue(TEXT("SystemCache"), (LPBYTE)szTemp, &cb)==ERROR_SUCCESS)
            {
                cb = ExpandEnvironmentStrings(szTemp,szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
                if (cb && (cb < ARRAY_ELEMENTS(szParentPath)))
                {
                    fResult = TRUE;
                }
            }
        }
        if (!fResult)
        {
            cb = ExpandEnvironmentStrings(TEXT("%TEMP%"),szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
            if (!cb || (cb > ARRAY_ELEMENTS(szParentPath)))
            {
                cb = GetWindowsDirectory(szParentPath, ARRAY_ELEMENTS(szParentPath));
            }
        }
    }
#else
    /* On Unix, GetWindowsDirectory will point to <install dir>/common
     * and the cache should not be created here in any case
     */
    lstrcpy(szParentPath,UNIX_SHARED_CACHE_PATH);
    cb = lstrlen(szParentPath);
#endif /* UNIX */
    if (!cb || (cb>sizeof(szParentPath)))
    {
        return ERROR_PATH_NOT_FOUND;
    }
    AppendSlashIfNecessary(szParentPath, &cb);
    
    for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        LONGLONG cbCacheLimit;

        // Get cache paths out of dll resource and form absolute
        // paths to top level cache directories.
        memcpy(szCachePath, szParentPath, cb);
        if (!LoadString(GlobalDllHandle, g_dwCachePathResourceID[idx], szCachePath + cb, MAX_PATH - cb))
        {
            return GetLastError();
        }

        DWORD ccPath = lstrlen(szCachePath);
        AppendSlashIfNecessary(szCachePath, &ccPath);
        memcpy(szCachePath+ccPath, g_szVersionName[idx], lstrlen(g_szVersionName[idx])+1);

        // Cache prefix.        
        memcpy(szCachePrefix, g_szCachePrefix[idx], strlen(g_szCachePrefix[idx]) + 1);

        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (idx == CONTENT)
        {
            
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY);
                fResult = FALSE;
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    DWORD cKBLimit;
                    if (roLimit.GetValue(CACHE_LIMIT_VALUE, &cKBLimit)==ERROR_SUCCESS)
                    {
                        cbCacheLimit = cKBLimit * (LONGLONG)1024;
                        fResult = TRUE;
                    }
                }
            }
            if (!fResult)
            {
                cbCacheLimit = 
                        (DWORDLONG)GetDefaultCacheQuota(szCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION) 
                        * (DWORDLONG)1024;
            }
        }
        else
        {
            // Non-CONTENT cache; use default.
            cbCacheLimit = DEF_CACHE_LIMIT * (LONGLONG)1024;
        }

        _coContainer[idx] = new URL_CONTAINER(g_szSubKey[idx], szCachePath, szCachePrefix, cbCacheLimit, 0);

        if (_coContainer[idx])
        {
            DWORD dwError = _coContainer[idx]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[idx];
                return dwError;
            }
            ConList.Add(_coContainer[idx]);
            _coContainer[idx]->SetPerUserItem(FALSE);
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    _fUsingBackupContainers = TRUE;
    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::GetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
BOOL CConMgr::GetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    LPDWORD lpdwCacheConfigInfoBufferSize, DWORD dwFieldControl)
{
    LOCK_CACHE();

    BOOL fIE5Struct = (lpCacheConfigInfo->dwStructSize == sizeof(INTERNET_CACHE_CONFIG_INFO));
    
    if(IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC))
    {
        lpCacheConfigInfo->dwSyncMode = GlobalUrlCacheSyncMode;
    }
    
    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_QUOTA_FC))
    {
        lpCacheConfigInfo->dwQuota = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit()/1024L);
    }

    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_USAGE_FC))
    {
        lpCacheConfigInfo->dwNormalUsage = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheSize()/1024L);
    }
    
    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_STICKY_CONTENT_USAGE_FC) && (lpCacheConfigInfo->dwContainer==CONTENT))
    {
        lpCacheConfigInfo->dwExemptUsage = (DWORD) (_coContainer[CONTENT]->GetExemptUsage()/1024L);
    }
    
    lpCacheConfigInfo->fPerUser = IsFieldSet( dwFieldControl, CACHE_CONFIG_USER_MODE_FC)
                                    ? _coContainer[lpCacheConfigInfo->dwContainer]->IsPerUserItem()
                                    : _coContent->IsPerUserItem();

    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = CONTENT;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = HISTORY;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = COOKIE;
    }
    // These are the actual field codes that should be sent for cache paths.
    // Note that the path returned *does not* contain subdirs (cache1..N).
    if (lpCacheConfigInfo->dwContainer <= HISTORY)
    {
        memcpy(lpCacheConfigInfo->CachePath, 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePath(), 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePathLen() + 1);
        lpCacheConfigInfo->dwQuota = (DWORD)
               (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit() / 1024);        

        lpCacheConfigInfo->dwNumCachePaths = (DWORD) 1;    
    }

    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::SetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
BOOL CConMgr::SetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO pConfig, 
                                              DWORD dwFieldControl)
{         
    DWORD i, dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);
    
    LOCK_CACHE();
    
    //  Check FieldControl bits and set the values for set fields
    if( IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC ))
    {

        INET_ASSERT(pConfig->dwSyncMode <= WININET_SYNC_MODE_AUTOMATIC);

        InternetWriteRegistryDword(vszSyncMode, pConfig->dwSyncMode);

        GlobalUrlCacheSyncMode = pConfig->dwSyncMode;

        // set a new version and simultaneously
        // increment copy for this process, so we don't
        // read registry for this process
        IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                            &GlobalSettingsVersion);
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_DISK_CACHE_PATHS_FC ))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_QUOTA_FC ) && pConfig->dwContainer==CONTENT)
    {
        DWORD cbSize = pConfig->dwQuota;
        INET_ASSERT(cbSize);

        if (!_fUsingBackupContainers)
        {
            IE5_REGISTRYSET ie5;
            IE3_REGISTRYSET ie3;
            
            if ((dwError=ie5.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
            {
                goto exit;
            }
            ie5.SetWorkingContainer(CONTENT);
            TCHAR szTemp[MAX_PATH];
            ie5.GetPath(szTemp);
            ie5.SetLimit(szTemp, cbSize);

            if (ie3.InitialiseKeys()==ERROR_SUCCESS)
            {
                ie3.FixLegacySettings(szTemp, cbSize);
            }
        }
        else
        {
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY, CREATE_KEY_IF_NOT_EXISTS);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    roLimit.SetValue(CACHE_LIMIT_VALUE, &cbSize);
                }
            }
        }

        if ((((LONGLONG)cbSize * 1024) < _coContent->GetCacheSize()))
            _coContent->CleanupUrls (DEFAULT_CLEANUP_FACTOR, 0);
        _coContent->SetCacheLimit(cbSize* (LONGLONG)1024);
    }

exit:
    UNLOCK_CACHE();
    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (!fRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    return fRet;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetContentPath

UpdateUrlCacheContentPath leads to this function.
This initiates the cache move. Should be called just before shutdown.

----------------------------------------------------------------------------*/
BOOL CConMgr::SetContentPath(PTSTR pszNewPath)
{
    IE5_REGISTRYSET ie5rs;
    DWORD dwError;
    BOOL fLock;

    if (_coContent->LockContainer(&fLock)
        && (dwError=ie5rs.InitialiseKeys(_fProfilesCapable))==ERROR_SUCCESS)
    {
        dwError = ie5rs.UpdateContentPath(pszNewPath);
    }
    
    if (fLock)
    {
        _coContent->UnlockContainer();
    }

    if (dwError==ERROR_SUCCESS)
    {
        return TRUE;
    }
    SetLastError(dwError);
    return FALSE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetExtensibleCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetExtensibleCacheConfigInfo(BOOL fAlways)
{
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    CHAR szPrefixMap[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    CHAR szVolumeTitle[MAX_PATH];

    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];

    URL_CONTAINER* pNewContainer;
    URL_CONTAINER* co;
    MUTEX_HOLDER mh;

    DWORD idx;
    DWORD idxPrefix;
    DWORD dwNow;
    DWORD dwOptions;
    BOOL fModified;
    BOOL fCDContainer;

    REGISTRY_OBJ* pro = NULL;

    LOCK_CACHE();
    fModified = WasModified(TRUE);

    hKey = _fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    //  WasModified MUST come first, so that we update our cached count!
    if (!fModified && !fAlways)
    {
         //  Unmap every container that hasn't be referenced in UNMAP_TIME
        dwNow = GetTickCountWrap();
        if ((dwNow - _dwLastUnmap) > UNMAP_TIME)
        {
            for (idx = ConList.Size()-1; idx >= NCONTAINERS; idx--)
            {
                co = ConList.Get(idx);
                if (co)
                {
                    if (co->GetDeletePending() ||
                        ((dwNow - co->GetLastReference()) > UNMAP_TIME))
                    {
                        co->TryToUnmap(1);    //  RefCount should be 1 == Us
                    }
                    co->Release(FALSE);
                }
            }

            _dwLastUnmap = dwNow;
        }
        goto exit;
    }

    // Create registry object and entry.
    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        for (idx = NCONTAINERS; idx < ConList.Size(); idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);
            if (co)
            {
                co->Mark(FALSE);
                co->Release(FALSE);
            }
        }

        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        idx = NCONTAINERS;
        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                    // Path.
                cbKeyLen = MAX_PATH;
                DWORD dwRepair = TRUE;
                CHAR szScratch[MAX_PATH];

                roVendor.GetValue(CACHE_PATCH_VALUE, &dwRepair);

                if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                    continue;

                if (!*szScratch)
                {
                    roExtensibleCache.DeleteKey(szVendorKey);
                    continue;
                }

                if (dwRepair)
                {
                    CompressPath(szScratch, szCachePath);
                    cbKeyLen = lstrlen(szCachePath)+1;
                    roVendor.SetValue(CACHE_PATH_VALUE, szCachePath, REG_EXPAND_SZ);
                    dwRepair = FALSE;
                    roVendor.SetValue(CACHE_PATCH_VALUE, &dwRepair);
                }
                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                    
                // Prefix.
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                    continue;
            
                // Limit.
                if (roVendor.GetValue(CACHE_LIMIT_VALUE, &cbKBLimit) != ERROR_SUCCESS)
                    continue;    

            // Options.
                if (roVendor.GetValue(CACHE_OPTIONS_VALUE, &dwOptions) != ERROR_SUCCESS)
                    continue;
            
                if (dwOptions & INTERNET_CACHE_CONTAINER_MAP_ENABLED)
                {
                    fCDContainer = TRUE;

                    // PrefixMap
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_PREFIX_MAP_VALUE, (LPBYTE) szPrefixMap, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szPrefixMap == '\0'))
                        continue;

                    // Volume label.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_LABLE_VALUE, (LPBYTE) szVolumeLabel, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeLabel == '\0'))
                        continue;
            
                    // Volume title.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_TITLE_VALUE, (LPBYTE) szVolumeTitle, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeTitle == '\0'))
                        continue;
                }
                else
                {
                    fCDContainer = FALSE;
                    *szPrefixMap = '\0';
                    dwOptions &= ~INTERNET_CACHE_CONTAINER_PREFIXMAP;
                }
    
                cbCacheLimit = ((LONGLONG) cbKBLimit) * 1024;
                
                idxPrefix = FindExtensibleContainer(szVendorKey);
                if (idxPrefix != NOT_AN_INDEX)
                {
                    co = ConList.Get(idxPrefix);

                    if (co)
                    {
                        //  what if the container has been added
                        //  with the same name but a different path, prefix, or options!
                        if (stricmp(co->GetCachePath(), szCachePath) ||
                            stricmp(co->GetCachePrefix(), szCachePrefix) ||
                            co->GetOptions() != dwOptions)
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else if (fCDContainer && stricmp(co->GetPrefixMap(), szPrefixMap))
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else
                        {
                            co->Mark(TRUE);
                        }
                        co->Release(FALSE);
                    }
                }
            
                if (idxPrefix == NOT_AN_INDEX)
                {
                    // Construct either a normal container, or a CD container.
                    if (!fCDContainer)                        
                    {
                        pNewContainer = new URL_CONTAINER(szVendorKey, szCachePath, szCachePrefix,
                                            cbCacheLimit, dwOptions);
                    }
                    else
                    {
                        pNewContainer = new CInstCon(szVendorKey, szVolumeLabel, szVolumeTitle,
                                             szCachePath, szCachePrefix, szPrefixMap, 
                                             cbCacheLimit, dwOptions);
                    }
                    if (pNewContainer)
                    {
                        dwError = pNewContainer->GetStatus();
                        if (dwError!=ERROR_SUCCESS)
                        {
                            delete pNewContainer;
                            pNewContainer = NULL;
                        }
                        else
                        {
                            pNewContainer->Mark(TRUE);
                            ConList.Add(pNewContainer);
                        }
                    }
                    else
                    {
                        dwError = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                 idx++;
            }
        }
    mh.Release();

    //  Mark every container that's no longer in the registry for pending delete
    //  Unmap every container that hasn't be referenced in UNMAP_TIME
    dwNow = GetTickCountWrap();

    idx = ConList.Size() - 1;

    while (idx >= NCONTAINERS)
    {
        co = ConList.Get(idx);
        if (co)
        {
            if (!co->GetMarked() && !co->GetDeleted())
            {
                co->SetDeletePending(TRUE);
            }
            if (co->GetDeletePending() ||
                ((dwNow - co->GetLastReference()) > UNMAP_TIME))
            {
                co->TryToUnmap(1);    //  RefCount should be 1 == Us, unless enumerator
                                      //  is still open
            }
            co->Release(FALSE);
        }
        idx--;
    }

    _dwLastUnmap = dwNow;
    }
    delete pro;
    
exit:  
    UNLOCK_CACHE();
    return dwError;
}


//
//  Mixed environment of IE4 and IE5 sharing a server causes HKCU keys to get resaved as REG_SZ incorrectly
//  so we repair it here
VOID CheckCacheLocationConsistency()
{
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ if necessary
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        DWORD ValueSize;
        DWORD ValueType;

        //  speed things up a bit by checking if we don't need to do this
        if (roUserShellFolders.GetValueSizeAndType(g_szOldSubKey[i], &ValueSize, &ValueType ) != SUCCESS 
            || ValueType != REG_SZ)
        {
            continue;
        }
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.

        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));

        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);
    }
}


VOID MakeCacheLocationsConsistent()
{
    // Delete any 5.0 cache signatures from previous installs
    REGISTRY_OBJ roHKCU(HKEY_CURRENT_USER, CACHE5_KEY);
    if (roHKCU.GetStatus()==ERROR_SUCCESS)
    {
        roHKCU.DeleteValue(CACHE_SIGNATURE_VALUE);
    }
    
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    roUserShellFolders.DeleteValue(TEXT("Content"));

    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.
        // i. Get rid of all the trailing content.ie5 (History.IE5)
        // ii. Get rid of any trailing Temporary Internet Files (History)
        // iii. Append Temporary Internet Files (History)

        // We want to skip this for cookies, though.

        // PROBLEM: When we have upgrade on top of 0901+, we started appending content.ie5
        // internally. Thus, files start getting misplaced. How do I work around this?

        // Idea: We append Content.ie5 to the USF path, and test for existence. If it's there,
        // then we'll use that. (We won't bother with anymore detective work. Though we could also
        // verify that the index dat there is newer than the index.dat in the parent directory.)
        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));
        DisableCacheVu(szRealPath);

        if (i!=1)
        {
        }
        
        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);

        // Then append Content.IE5 and move the files to this subdirectory
        // Ideally, we should rename this to an intermediate folder,
        // delete the old location (UNLESS THIS IS THE ROOT OR SYSTEM DIRECTORY),
        // and then move intermediate folder to its new location

    }

    FlushShellFolderCache();
}

// External hooks -------------------------------------------------------------------------------------------------------

// -- RunOnceUrlCache -------------------------
// This code is called on reboot to clean up moving the cache.
// If the shutdown was successful, this will move only the few files that were open
// at that point; we assume that we'll move quickly enough to prevent collisions.
// The old index.dat is erased.

DWORD
WINAPI
RunOnceUrlCache( HWND hwnd, HINSTANCE hinst, PSTR pszCmd, int nCmdShow)
{
    // This will clean up the move, especially important if the move was interrupted. (Not too likely.)
    if (pszCmd && *pszCmd)
    {
        CFileMgr::DeleteCache(pszCmd);
    }
    return ERROR_SUCCESS;
}
      
DWORD
WINAPI
DeleteIE3Cache( HWND hwnd, HINSTANCE hinst, PSTR lpszCmd, int nCmdShow)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()==ERROR_SUCCESS)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD cbLimit;
        
        // This fragment will look for a cache location, and test for its share-ability. If it is,
        // we'll use the location; otherwise, we'll use our own shared location.
        if (ie3rs.GetContentDetails(szTemp, cbLimit))
        {
            DWORD cb = lstrlen(szTemp);
            AppendSlashIfNecessary(szTemp, &cb);

            PTSTR psz = szTemp+cb-2;
            while (*psz!='\\' && psz>szTemp)
            {
                psz--;
            }
            if ((psz>szTemp) && !StrCmpNI(psz+1, TEXT("content."), ARRAY_ELEMENTS("content.")-1))
            {
                *(psz+1) = TEXT('\0');
            }
            StrCatBuff(szTemp, TEXT("cache1"), MAX_PATH);
            cb = lstrlen(szTemp) - 1;

            for (int i=0; i<4; i++)
            {
                szTemp[cb] = TEXT('1')+i;
                DeleteCachedFilesInDir(szTemp);
                RemoveDirectory(szTemp);
            }
        }
    }

    return ERROR_SUCCESS;
}
      

// -- Externally available apis

URLCACHEAPI_(BOOL) SetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO pConfig,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the cache configuration parameters.

Arguments:

    lpCacheConfigInfo - place holding cache configuration information to be set

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetUrlCacheConfigInfo(pConfig,dwFieldControl);
}

URLCACHEAPI_(BOOL) GetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function retrieves cache configuration values from globals

Arguments:

    pConfig - pointer to a location where configuration information
                  is stored on a successful return

    lpdwCacheConfigInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoA", "%#x, %#x, %#x",
        lpCacheConfigInfo, lpdwCacheConfigInfoBufferSize, dwFieldControl ));

    BOOL fError;
    
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        DEBUG_ERROR(API, ERROR_INTERNET_INTERNAL_ERROR);
        fError = FALSE;
    }
    else
    {
        fError = GlobalUrlContainers->GetUrlCacheConfigInfo(lpCacheConfigInfo,
            lpdwCacheConfigInfoBufferSize, dwFieldControl);
    }
    
    DEBUG_LEAVE_API (fError);
    return fError;
}


// declared in wininet\inc\urlcache.h
BOOL GetIE5ContentPath( LPSTR szPath)
{
    BOOL retVal = FALSE;
    
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesCapable;

    if( ie5rs.InitialiseKeys(fProfilesCapable) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.SetWorkingContainer(CONTENT) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.GetPath( szPath) != ERROR_SUCCESS)
        goto doneGetContentPath;

    retVal = TRUE;

doneGetContentPath:
    return retVal;
}

// SHDOCVW needs to know whether profiles are enabled, to determine whether
// or not it needs to filter out user names. This function will help keep things simple.
// And minimise perf impact.
STDAPI_(BOOL) IsProfilesEnabled()
{
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesEnabled;

    if (ie5rs.InitialiseKeys(fProfilesEnabled) != ERROR_SUCCESS)
    {
        fProfilesEnabled = FALSE;
    }
    return fProfilesEnabled;
}

BOOL CConMgr::DiscoverIE4Settings(IE5_REGISTRYSET* pie5rs)
{
    IE4_REGISTRYSET ie4rs;

    CHAR szTemp[MAX_PATH+1], szPrefix[MAX_PATH+1];
    DWORD cbLimit, dwTemp;
    BOOL fPerUser, fCaughtIE4;
        
    // Try to find IE4 settings. If any paths are found, we will not look for IE3 settings
    fCaughtIE4 = FALSE;

    if (ie4rs.WasIE4Present(_fProfilesCapable))
    {
        if (ie4rs.InitialiseKeys(_fProfilesCapable)!=ERROR_SUCCESS)
        {
           LOG_UPGRADE_DATA("IE4 initialisation failed...\n");
           return FALSE;
        }

        for (dwTemp=0;dwTemp < NCONTAINERS; dwTemp++)
        {
            ie4rs.SetWorkingContainer(dwTemp);
            if (ie4rs.GetPath(szTemp)!=ERROR_SUCCESS)
            {
                continue;
            }
            LOG_UPGRADE_DATA("DIE4Settings: ");
            LOG_UPGRADE_DATA(szTemp);
            LOG_UPGRADE_DATA("\n");
            DisableCacheVu(szTemp);

            pie5rs->SetWorkingContainer(dwTemp);

            // Because SHGetFolderPath uses shell folders to determine where the items are, we have to accomodate this
            // on no-profiles machines. 
            if (!_fProfilesCapable)
            {
                pie5rs->SetPath(szTemp);
            }
            else if (dwTemp==CONTENT)
            {
#ifndef UNIX
                if (ie4rs.GetPerUserStatus() || GlobalPlatformVersion5)
#else
                if (ie4rs.GetPerUserStatus() || GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
                {
                // If it's NT5, we want to go to a per-user, non-roaming location
                // which is the NT5 default anyway
                    LOG_UPGRADE_DATA("DIE4Settings: If NT5, ignore shared cache. Else this isn't shared anyway.");
                    pie5rs->SetPerUserStatus(TRUE);
                }
                else
                {
                // Because IE4 locates a shared cache differently from IE5, we need to
                // save the path and status.
                    LOG_UPGRADE_DATA("DIE4Settings: Will try to use shared cache");
                    pie5rs->AttemptToUseSharedCache(szTemp, 0);
                }
            }
        
            fCaughtIE4 = TRUE;

            // We don't need to check return values since we come up with
            // reasonable values on our own.
            ie4rs.GetLimit(szTemp, cbLimit);
            pie5rs->SetLimit(szTemp, cbLimit);

            ie4rs.GetPrefix(szPrefix);
            pie5rs->SetPrefix(szPrefix);
        }
    }
    if (!fCaughtIE4)
    {
        LOG_UPGRADE_DATA("No IE4 settings...\n");
    }
    else
    {
        FlushShellFolderCache();
    }
    return fCaughtIE4;
}

VOID CConMgr::DiscoverIE3Settings(IE5_REGISTRYSET* pie5rs)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()!=ERROR_SUCCESS)
    {
        return;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD cbLimit;
    
    // This fragment will look for a cache location, and test for its share-ability. If it is,
    // we'll use the location; otherwise, we'll use our own shared location.
    if (ie3rs.GetContentDetails(szTemp, cbLimit))
    {
        DeleteCachedFilesInDir(szTemp);
       // No IE4. Steal IE3's settings? We only care about content cache.
       // Is that a good idea? There's no UI for modifying the cookies/history path; 
       // if someone plumbs into the registry, do we want to support that? *sigh*
       // BUG? We're moving the cache one level deeper. We probably want to be a
       // bit more intelligent about this.
        CleanPath(szTemp);
        pie5rs->AttemptToUseSharedCache(szTemp, cbLimit);
    }

    // This fragment deletes the shared history. It should happen ONLY ONCE.
    DWORD cbKeyLen = ARRAY_ELEMENTS(szTemp);
    REGISTRY_OBJ roHist(HKEY_LOCAL_MACHINE, IE3_HISTORY_PATH_KEY);
    if ((roHist.GetStatus()==ERROR_SUCCESS)
        &&
        (roHist.GetValue(NULL,(LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
    {
        REGISTRY_OBJ roUrlHist(HKEY_LOCAL_MACHINE, szTemp);
        cbKeyLen = ARRAY_ELEMENTS(szTemp);
        if ((roUrlHist.GetStatus()==ERROR_SUCCESS)
            &&
            (roUrlHist.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
        {
            DeleteCachedFilesInDir(szTemp);
        }
    }
}


// Logic for determining the location of the cache -------------------------------------------------------------

// PROFILES ENABLED --------------------------
// [on logon]
// If profiles are enabled, look in HKCU/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature. 
// If a signature is present, [carry on]
// Look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is not present, jump to [over IE4 install]
// For history and cookies, the containers will be located in the profiles directory
// For content, 
//      if it's marked per user, 
//          and there isn't a shell folder/user shell folder value, construct and put it in
//      otherwise feed the HKLM shared location into (user) shell folder.
// Insert signature and [carry on].

// [over IE4 install]
// If a signature is not present in HKCU/Software/Microsoft/Windows/Internet Settings/Cache,
//      jump to [over IE3 install]
// Determine if the content cache is per-user or not.

// [over IE3 install]
// For history and cookies, the containers will be located in the profiles directory
// Examine HKLM/Software/Microsoft/Windows/Internet Settings/Cache/Paths
// If not present, go to [clean install]
// If the cache path is located in a user's profiles directory, ignore and [clean install]
// Otherwise, adopt the values and [carry on]

// [clean install]
// Set up history/cookies to be per user.
// Set up the content cache to be shared.
// Write in default values.

// PROFILES NOT ENABLED --------------------------

// * If profiles are _not_ enabled, we'll look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is present, go ahead and gather information for the paths

// [carry on]
// Get info from the registry, and create the container


// -- DiscoverAnyIE5Settings
// We're going to call this function if we haven't any IE4 settings to upgrade,
// but _before_ we check for IE3,

DWORD GetIEVersion();

BOOL CConMgr::DiscoverAnyIE5Settings(IE5_REGISTRYSET* pie5rs)
{
    // Let's consider the following scenario:
    // User A logs on to the machine with IE4 installed; installs IE5, and then shuts down
    // the machine. User B comes along, but IE5 hasn't been installed yet. If User B has 
    // admin privileges, install will continue, BUT still not have any IE4/5 settings.
    // Which resulted in skipping DiscoverIE4Settings. However, we don't want to look
    // at IE3's settings.

    // If we're installing over IE4/2/5, but we don't have any settings for this user, 
    // we must avoid an IE3 upgrade. Instead, short circuit to use last-minute info-gathering
    // For IE3, use a shared cache
    DWORD dwVer = GetIEVersion();
    
    // We're going to use a shared cache for IE3 and Win9x users.
    // Upgrading over IE4 and 5 -- for users who have logged in before,
    // their signatures shoudl be in place already. In those cases, we shouldn't
    // be in this function anyway. For other users, we'll use the shared cache.
    // This is the first time for the machine.
    if ((dwVer==3) && pie5rs->IsFirstTimeForMachine())
    {
        return FALSE;
    }

    pie5rs->AttemptToUseSharedCache(NULL, 0);
    return TRUE;
}


VOID CConMgr::DiscoverRegistrySettings(IE5_REGISTRYSET* pie5rs)
{
    LOG_UPGRADE_DATA("Attempting to discover IE4 settings...\n");

    if (DiscoverIE4Settings(pie5rs))
    {
        goto exit;
    }


#ifndef UNIX
    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
    if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
    {
        LOG_UPGRADE_DATA("This is NT. Fuhgedabout IE3 et al settings...\n");

        // This will override NT's default behaviour to use per-user containers.
        pie5rs->SetWorkingContainer(CONTENT);
        if (!pie5rs->GetPerUserStatus())
        {
            pie5rs->AttemptToUseSharedCache(NULL, 0);
        }

        // Suppose this is an install over NT. Each user should get a per-user, non-roaming
        // path by default. The values we'd pick up from SHFolderGetPath will be okay; but, we need to make
        // sure that we treat this as a per-user container.

        // Suppose we upgraded from some previous version of Win9x to NT5. There are eight scenarios:
        // nothing                  : in which case, we do as above
        // IE3                      : same; need to delete old cache
        // IE4 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : same as fresh install
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path
        // IE5 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : preserve shared path
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path

        // If an admin wants to use a shared cache under NT5, s/he will have to set
        // HKCU/Shell Folders and User Shell Folders to point to the common path
        // AND {HKCU|HKLM}/blah/PerUserItem to 0 (or delete the HKCU value).
        if ((GetIEVersion()==3) && pie5rs->IsFirstTimeForMachine())
        {
            IE3_REGISTRYSET ie3rs;
            TCHAR szTemp[MAX_PATH];
            DWORD cbLimit;
            if ((ie3rs.InitialiseKeys()==ERROR_SUCCESS)
                &&
                (ie3rs.GetContentDetails(szTemp, cbLimit)))
            {
                DeleteCachedFilesInDir(szTemp);
            }
        }
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE5 settings...\n");
    if (DiscoverAnyIE5Settings(pie5rs))
    {
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE3 settings...\n");
    DiscoverIE3Settings(pie5rs);

exit:
    LOG_UPGRADE_DATA("Flushing shell folders cache...\n");
    pie5rs->SetIfFirstTime();
    FlushShellFolderCache();
}

// -- AttemptToUseSharedCache
// Given a path (and limit) attempt to use the path for a shared location.
// If the path is null, then try to use any value if present, else invent one.

VOID IE5_REGISTRYSET::AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit)
{
    TCHAR szSharedPath[MAX_PATH];
    DWORD cc = ARRAY_ELEMENTS(szSharedPath);

    REGISTRY_OBJ roContent(&m_roHKLMCache, g_szSubKey[CONTENT], CREATE_KEY_IF_NOT_EXISTS);
    if ((roContent.GetStatus()==ERROR_SUCCESS)
        &&
        (roContent.GetValue(CACHE_PATH_VALUE, (LPBYTE)szSharedPath, &cc)==ERROR_SUCCESS))
    {
        LOG_UPGRADE_DATA("Found a shared cache location...\n");
        goto write_value;
    }

    if (pszPath!=NULL)
    {
        LOG_UPGRADE_DATA(pszPath);
        LOG_UPGRADE_DATA("\n is ");
        GetUserName(szSharedPath, &cc);

        // We're going to ignore just the user name, during this comparison. And
        // if it's in the profiles directory, fuhgedaboutit.
        if (m_fProfiles && !StrCmpNI(m_szProfilePath, pszPath, cbP-cc))
        {
            pszPath = NULL;
            LOG_UPGRADE_DATA("not okay \n");
            goto carryon;
        }
        LOG_UPGRADE_DATA("okay \n");
        strcpy(szSharedPath, pszPath);
    }

carryon:
    if (pszPath==NULL)
    {
        memcpy(szSharedPath, m_szSharedPath, (cbS+1)*sizeof(TCHAR));
        CleanPath(szSharedPath);
        LOG_UPGRADE_DATA("Using a constructed shared path\n");
    }

    // We've finally decided on the path. Now let's write the value into the registry.
    roContent.SetValue(CACHE_PATH_VALUE, szSharedPath, REG_SZ);
    SetWorkingContainer(CONTENT);
    SetPerUserStatus(FALSE);
    SetLimit(szSharedPath, ckbLimit);

write_value:
    LOG_UPGRADE_DATA("The shared cache will be located at ");
    LOG_UPGRADE_DATA(szSharedPath);
    LOG_UPGRADE_DATA("\n");
    
    // This will take care of HKCU
    CHAR szScratch[MAX_PATH];
#ifndef UNIX
    if (!NormalisePath(szSharedPath, TEXT("%SystemRoot%"), szScratch, sizeof(szScratch)))
#else
    if (!NormalisePath(szSharedPath, TEXT("%USERPROFILE%"), szScratch, sizeof(szScratch)))
#endif /* UNIX */
    {
        strncpy(szScratch, szSharedPath, MAX_PATH);
    }
    if (m_roUserShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ)==ERROR_SUCCESS)
    {
#ifndef UNIX
       DWORD dwType = REG_SZ;
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szSharedPath, dwType);
#else
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
    }
}


// -- CleanPath
// Given a path, strip away any trailing content.ie5's, and if necessary, add a trailing brand mark,
// i.e. "Temporary Internet Files" or localised version.

VOID CleanPath(PTSTR pszPath)
{
    DWORD ccPath = strlen(pszPath);
    PTSTR pszLastSep = pszPath + ccPath;

    // Now we're at the null terminator, but if the last character is also a separator, we want
    // to skip that too.
    if (*(pszLastSep-1)==DIR_SEPARATOR_CHAR)
    {
        pszLastSep--;
    }
    BOOL fSlash;
    // Strip away any "content.ie5"'s from the path
    for (;(fSlash = ScanToLastSeparator(pszPath, &pszLastSep));)
    {
        if (StrCmpNI((pszLastSep+1), TEXT("content.ie"), ARRAY_ELEMENTS(TEXT("content.ie"))-1))
        {
            break;
        }
        *pszLastSep = '\0';
    }

    // Load temp int files
    TCHAR szBrand[MAX_PATH];
    DWORD ccBrand = 0;

    ccBrand = LoadString(GlobalDllHandle, g_dwCachePathResourceID[CONTENT], szBrand, ARRAY_ELEMENTS(szBrand));

    // The following fragment should never happen, but just in case...
    if (!ccBrand)
    {
        ccBrand = sizeof(TEXT("Temporary Internet Files"));
        memcpy(szBrand, TEXT("Temporary Internet Files"), ccBrand);
        ccBrand /= sizeof(TCHAR);
        ccBrand--;
    }
    
    // If "Temporary Internet Files" doesn't trail the path, add it.
    if (!fSlash)
    {
        *pszLastSep++ = DIR_SEPARATOR_CHAR;
        *pszLastSep = '\0';
    }
    else
    {
        pszLastSep++;
    }
    if (StrCmpNI((pszLastSep), szBrand, ccBrand))
    {
        while (*pszLastSep && *pszLastSep!=DIR_SEPARATOR_CHAR)
        {
            pszLastSep++;
        }
        if (!*pszLastSep && (*(pszLastSep-1)!=DIR_SEPARATOR_CHAR))
        {
            *pszLastSep = DIR_SEPARATOR_CHAR;
            pszLastSep++;
        }
        else if (*pszLastSep)
        {
            pszLastSep++;
        }
        memcpy(pszLastSep, szBrand, ccBrand*sizeof(TCHAR));
    }
    *(pszLastSep+ccBrand)='\0';
}

DWORD GetIEVersion()
{
    DWORD dwVer = 0;

    REGISTRY_OBJ roVersion(HKEY_LOCAL_MACHINE, OLD_VERSION_KEY);
    TCHAR szKey[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szKey);

    if ((roVersion.GetStatus()!=ERROR_SUCCESS)
        ||
        (roVersion.GetValue(OLD_VERSION_VALUE, (LPBYTE)szKey, &cb)!=ERROR_SUCCESS))
    {
        // This should never happen during a proper setup.
        // In case it does, however, we'll just use construct IE5's default settings.
        return 0;
    }

    PTSTR psz = szKey;
    PTSTR pszFirst = szKey;
    // Get the major version number
    while (*psz!='.')
    {
        psz++;
    }
    *psz = '\0';
    dwVer = (DWORD)StrToInt(pszFirst);

    if (dwVer==4)
    {
        psz++;
        // Skip the second number
        while (*psz!='.')
        {
            psz++;
        }
        pszFirst = psz;
        psz++;
        while (*psz!='.')
        {
            psz++;
        }
        *psz = '\0';
        dwVer = ((DWORD)StrToInt(pszFirst))==0 ? 3 : 4;
    }

    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cachedef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CACHEDEF_
#define _CACHEDEF_

//
// C++ inline code definition for retail build only.
//

#if DBG
#undef CHECKLOCK_NORMAL
#undef CHECKLOCK_PARANOID
#define INLINE
#else
#define INLINE      inline
#endif

#define PAGE_SIZE                        4096            // Grow memory mapped file by 1 page.
#define ALLOC_PAGES                      4               // was 2
#define HEADER_ENTRY_SIZE                ALLOC_PAGES * PAGE_SIZE
#define NORMAL_ENTRY_SIZE                128

#define DEFAULT_CLEANUP_FACTOR           10  // % free goal once cache quota exceeded
#define MAX_EXEMPT_PERCENTAGE            70

#define MEMMAP_FILE_NAME                 TEXT("index.dat")
#define DESKTOPINI_FILE_NAME             TEXT("desktop.ini")

#define DEFAULT_FILE_EXTENSION           ""

// Cache configuration and signature.
#define CACHE_SIGNATURE_VALUE           TEXT("Signature")
#define CACHE_SIGNATURE                 TEXT("Client UrlCache MMF Ver 5.2")
#define NUM_HEADER_DATA_DWORDS          (CACHE_HEADER_DATA_LAST + 1)
#define MAX_SIG_SIZE                     (sizeof(CACHE_SIGNATURE) / sizeof(TCHAR))

// The following values parametrize the schema for URL entries.
#define ENTRY_COPYSIZE_IE5    \
    (sizeof(IE5_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE5               0
#define ENTRY_COPYSIZE_IE6    \
    (sizeof(IE6_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE6               0x10

#define ENTRY_COPYSIZE_CURRENT          ENTRY_COPYSIZE_IE6
#define ENTRY_VERSION_CURRENT           ENTRY_VERSION_IE6

// If IE5-IE? sees an entry with low bits of version set, it will be placed
// on async fixup list rather than being destroyed.
#define ENTRY_VERSION_NONCOMPAT_MASK    0x0F


// Roundup
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))
#define ROUNDUPBLOCKS(bytesize) ((bytesize + NORMAL_ENTRY_SIZE-1) & ~(NORMAL_ENTRY_SIZE-1))
#define ROUNDUPDWORD(bytesize) ((bytesize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1))
#define ROUNDUPPAGE(bytesize) ((bytesize + PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define NUMBLOCKS(bytesize) (bytesize / NORMAL_ENTRY_SIZE)

// Power of 2 macros
#define ISPOWEROF2(val) (!((val) & ((val)-1)))
#define ASSERT_ISPOWEROF2(val) INET_ASSERT(ISPOWEROF2(val))

#define URL_CACHE_VERSION_NUM  sizeof(CACHE_ENTRY_INFO);

// Default profiles directory under %SystemRoot%.
#define DEFAULT_PROFILES_DIRECTORY TEXT("Profiles")


//
// Registry key and value names for persistent URL management.
//

// BUGBUG - wasting space. 

#define MS_BASE TEXT("Software\\Microsoft")

#define CV_BASE MS_BASE TEXT("\\Windows\\CurrentVersion")

#define EX_BASE TEXT("\\Explorer")

#define IS_BASE TEXT("\\Internet Settings")

#define CACHE_T TEXT("\\Cache")

#define SHELL_FOLDER_KEY        CV_BASE EX_BASE TEXT("\\Shell Folders")
#define USER_SHELL_FOLDER_KEY   CV_BASE EX_BASE TEXT("\\User Shell Folders")
#define CACHE5_KEY              CV_BASE IS_BASE TEXT("\\5.0") CACHE_T
#define IDENTITIES_KEY          CV_BASE IS_BASE TEXT("\\5.0\\Identities") 
#define OLD_CACHE_KEY           CV_BASE IS_BASE CACHE_T
#define CACHE_PATHS_FULL_KEY    CV_BASE IS_BASE CACHE_T TEXT("\\Paths")
#define RUN_ONCE_KEY            CV_BASE TEXT("\\RunOnce")
#define PROFILELESS_USF_KEY     TEXT(".Default\\") USER_SHELL_FOLDER_KEY
#define CONTENT_CACHE_HARD_NAME TEXT("Content.IE5")
#define OLD_VERSION_KEY         MS_BASE TEXT("\\IE Setup\\SETUP")
#define OLD_VERSION_VALUE       TEXT("UpgradeFromIESysFile")


//
// Cache parameters
//
#ifndef unix
#define PATH_CONNECT_STRING                    TEXT("\\")
#define PATH_CONNECT_CHAR                      TEXT('\\')
#define ALLFILES_WILDCARD_STRING               TEXT("*.*")
#define UNIX_RETURN_IF_READONLY_CACHE 
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) 
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar)
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName)
#else
#define PATH_CONNECT_STRING                    TEXT("/")
#define PATH_CONNECT_CHAR                      TEXT('/')
#define ALLFILES_WILDCARD_STRING               TEXT("*")
#define UNIX_RETURN_IF_READONLY_CACHE   {                        \
                                           if (g_ReadOnlyCaches) \
                                              return;            \
                                        }
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) {                      \
                                                   if (g_ReadOnlyCaches)\
                                                      return (error);   \
                                               }
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar) \
                                        UnixNormalisePath(szOrigPath, szEnvVar);
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName) \
                      UnixNormaliseIfCachePath(szOrigPath, szEnvVar, szKeyName);

#define UNIX_SHARED_CACHE_PATH TEXT("%HOME%/.microsoft")
#endif /* !unix */

#define CACHE_PERSISTENT                TEXT("Persistent")

// Retrieval methods
#define RETRIEVE_WITHOUT_CHECKS     0
#define RETRIEVE_WITH_CHECKS        1
#define RETRIEVE_WITH_ALLOCATION    2
#define RETRIEVE_ONLY_FILENAME      4
#define RETRIEVE_ONLY_STRUCT_INFO   8
//
// Multiple URL containters can be configured under the above key such
// as :
//
//  Cache\Paths\Path1
//  Cache\Paths\Path2
//    ...
//
// Each containter will have the following two parameters.
//

// CConMgr related defines.
#define CACHE_PATHS_KEY                 TEXT("Paths")
#define CACHE_PATH_VALUE                TEXT("CachePath")
#define CACHE_PATH_VALUE_TYPE           REG_SZ
#define CACHE_LIMIT_VALUE               TEXT("CacheLimit")
#define CACHE_LIMIT_VALUE_TYPE          REG_DWORD
#define CACHE_OPTIONS_VALUE             TEXT("CacheOptions")
#define CACHE_OPTIONS_VALUE_TYPE        REG_DWORD
#define CACHE_PATCH_VALUE               TEXT("CacheRepair")
#define CACHE_PATCH_VALUE_TYPE          REG_DWORD

#define EXTENSIBLE_CACHE_PATH_KEY       "Extensible Cache"
#define CONTENT_PATH_KEY                "Content"
#define COOKIE_PATH_KEY                 "Cookies"
#define HISTORY_PATH_KEY                "History"
#define URL_HISTORY_KEY                 "Url History"

#define PER_USER_KEY                    "PerUserItem"
#define PROFILES_ENABLED_VALUE          "Network\\Logon"
#define PROFILES_ENABLED                "UserProfiles"
#define PROFILES_PATH_VALUE             CV_BASE "\\ProfileList"
#define PROFILES_PATH                   "ProfileImagePath"

#define CONTENT_PREFIX                  ""
#define COOKIE_PREFIX                   "Cookie:"
#define HISTORY_PREFIX                  "Visited:" 

#define CONTENT_VERSION_SUBDIR          "Content.IE5"
#define IE3_COOKIES_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\Cookies")
#define IE3_HISTORY_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\History")
#define IE3_PATCHED_USER_KEY            TEXT("Patched User")
#define CACHE_SPECIAL_PATHS_KEY         TEXT("Special Paths")
#define CACHE_DIRECTORY_VALUE           TEXT("Directory")
#define CACHE_DIRECTORY_TYPE            REG_EXPAND_SZ
#define CACHE_NEWDIR_VALUE              TEXT("NewDirectory")
#define CACHE_NEWDIR_TYPE               REG_EXPAND_SZ
#define CACHE_PREFIX_VALUE	            TEXT("CachePrefix")
#define CACHE_PREFIX_MAP_VALUE          "PrefixMap"
#define CACHE_VOLUME_LABLE_VALUE        "VolumeLabel"
#define CACHE_VOLUME_TITLE_VALUE        "VolumeTitle"
#define CACHE_PREFIX_TYPE               REG_SZ
#define NEW_DIR                         TEXT("NewDirectory")
#define USER_PROFILE_SZ                 "%USERPROFILE%"
#define USER_PROFILE_LEN                (sizeof(USER_PROFILE_SZ) - 1)

// URL_CONTAINER related defines.
#define DEF_NUM_PATHS                   4
#define DEF_CACHE_LIMIT                 (2048 * DEF_NUM_PATHS)
#define NO_SPECIAL_CONTAINER            0xffffffff
#define MAX_ENTRY_SIZE                  0xFFFF
#define LONGLONG_TO_FILETIME( _p_ )     ((FILETIME *)(_p_))

// Content limit defines.
#define OLD_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      64
#define NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      32
#define CONTENT_QUOTA_ADJUST_CHECK                   "QuotaAdjustCheck"

// CInstCon related defines.
#define INTERNET_CACHE_CONTAINER_PREFIXMAP INTERNET_CACHE_CONTAINER_RESERVED1
#define MAX_FILE_SIZE_TO_MIGRATE  50000
#define MAX_EXTENSION_LEN        3


// FileMgr related defines.
#define DEFAULT_DIR_TABLE_GROW_SIZE     4
#define DEFAULT_MAX_DIRS                32
#define MAX_FILES_PER_CACHE_DIRECTORY   1024
#define MAX_COLLISSION_ATTEMPTS         150
#define INSTALLED_DIRECTORY_KEY         0xFF
#define NOT_A_CACHE_SUBDIRECTORY        0XFE

#ifdef CHECKLOCK_PARANOID
void CheckEnterCritical(CRITICAL_SECTION *_cs);
void CheckLeaveCritical(CRITICAL_SECTION *_cs);
#define ENTERCRITICAL CheckEnterCritical
#define LEAVECRITICAL CheckLeaveCritical
#else
#define ENTERCRITICAL EnterCriticalSection
#define LEAVECRITICAL LeaveCriticalSection
#endif

// Cache global variable lock -- this should not be entered while holding
// lower-level locks like URL_CONTAINER::LockContainer cross-process mutex.
#define LOCK_CACHE()                    ENTERCRITICAL( &GlobalCacheCritSect )
#define UNLOCK_CACHE()                  LEAVECRITICAL( &GlobalCacheCritSect )

//
// parameter check macros.
//

#define IsBadUrl( _x_ )               IsBadStringPtrA( _x_, (DWORD) -1)
#define IsBadUrlW( _x_ )              IsBadStringPtrW( _x_, (DWORD) -1)
#define IsBadReadFileName( _x_ )      IsBadStringPtr( _x_, MAX_PATH )
#define IsBadWriteFileName( _x_ )     IsBadWritePtr( (PVOID)_x_, MAX_PATH)
#define IsBadWriteBoolPtr( _x_ )      IsBadWritePtr( _x_, sizeof(BOOL))
#define IsBadReadUrlInfo( _x_ )       IsBadReadPtr( _x_, sizeof(CACHE_ENTRY_INFO))
#define IsBadWriteUrlInfo( _x_, _y_ ) IsBadWritePtr( _x_, _y_ )

#define MAX_URL_ENTRIES                 (BIT_MAP_ARRAY_SIZE * sizeof(DWORD) * 8)

#define OFFSET_TO_POINTER( _ep_, _offset_) \
    (LPVOID)((LPBYTE)(_ep_) + (_offset_))


#define FIND_FLAGS_OLD_SEMANTICS                0x1
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2
#define FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME 0x04

//---------------- BUGBUG : for History Only -------------------------------
#define MAX_FILETIME   0x7fffffffffffffff
#define MAX_DOSTIME    -1
//---------------- END BUGBUG ----------------------------------------------


//
// ----------------- Allocation entry header -----------------------------//
//

#define SIG_FREE   0xbadf00d
#define SIG_ALLOC  0xdeadbeef

#define SIG_URL         ' LRU'   // URL_FILEMAP_ENTRY
#define SIG_REDIR       'RDER'   // REDR_FILEMAP_ENTRY
#define SIG_LEAK        'KAEL'   // URL_FILEMAP_ENTRY
#define SIG_GLIST       'GLST'   // LIST_GROUP_ENTRY

// signatures for entries placed on fixup list
#define SIG_UPDATE      ' DPU'   // URL_FILEMAP_ENTRY
#define SIG_DELETE      ' LED'   // URL_FILEMAP_ENTRY

enum MemMapStatus
{
    MEMMAP_STATUS_OPENED_EXISTING = 0,
    MEMMAP_STATUS_REINITIALIZED = 1
};

typedef struct FILEMAP_ENTRY
{
    DWORD dwSig;
    DWORD nBlocks;
}
    *LPFILEMAP_ENTRY;

struct LIST_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwNext; // offset to next element in list
    DWORD nBlock; // sequence number for this block
};

//
// URL entry
//

struct IE5_URL_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    LONGLONG LastModifiedTime;       // must be LONGLONG
    LONGLONG LastAccessedTime;       // should be DWORD
    DWORD    dostExpireTime;
    DWORD    dostPostCheckTime;

    DWORD    dwFileSize;
    DWORD    dwRedirHashItemOffset;  // ask DanpoZ

    DWORD    dwGroupOffset;

    union
    {
        DWORD  dwExemptDelta;   // for SIG_URL
        DWORD  dwNextLeak;      // for SIG_LEAK
    };
    
    DWORD    CopySize;               // should be WORD
    DWORD    UrlNameOffset;          // should be WORD
    
    BYTE     DirIndex;           // subdirectory bucket
    BYTE     bSyncState;         // automatic sync mode state
    BYTE     bVerCreate;         // cache version that created this entry
    BYTE     bVerUpdate;         // cache version last updated this entry (unused)
        
    DWORD    InternalFileNameOffset; // should be WORD
    DWORD    CacheEntryType;
    DWORD    HeaderInfoOffset;       // should be WORD
    DWORD    HeaderInfoSize;         // should be WORD
    DWORD    FileExtensionOffset;    // should be WORD
    DWORD    dostLastSyncTime;       
    DWORD    NumAccessed;            // should be WORD
    DWORD    NumReferences;          // should be WORD
    DWORD    dostFileCreationTime;   // should be LONGLONG?

// Do not extend this structure; use inheritance instead.
};

struct IE6_URL_FILEMAP_ENTRY : IE5_URL_FILEMAP_ENTRY 
{
    DWORD   dwIdentity;

    DWORD GetIdentity()
    {
        return (bVerCreate>=ENTRY_VERSION_IE6) ? dwIdentity : 0;
    }
};

typedef IE6_URL_FILEMAP_ENTRY URL_FILEMAP_ENTRY, *LPURL_FILEMAP_ENTRY;

// FILETIME is measured in 100-ns units.
#define FILETIME_SEC    ((LONGLONG) 10000000)
#define FILETIME_DAY    (FILETIME_SEC * 60 * 60 * 24)

// Possible values for bSyncState:
#define SYNCSTATE_VOLATILE   0 // once zero, stuck at zero
#define SYNCSTATE_IMAGE      1 // eligible to increment after MIN_AGESYNC
#define SYNCSTATE_STATIC     6 // max value

// Parameters controlling transition from _IMAGE to _VOLATILE.
// #define MIN_AGESYNC  ((LONGLONG) 5 * 60 * 10000000)  // 5 min in filetime
#define MIN_AGESYNC     (FILETIME_DAY * 7)

//
// Redirect Entry
//

struct REDIR_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwItemOffset;  // offset to hash table item of destination URL
    DWORD dwHashValue;   // destination URL hash value (BUGBUG: collisions?)
    char  szUrl[4];      // original URL, can occupy more bytes
};

//
// Group Record
//

typedef struct GROUP_ENTRY
{
    GROUPID  gid;
    DWORD    dwGroupFlags;
    DWORD    dwGroupType;
    LONGLONG llDiskUsage;       // in Bytes (Actual Usage)
    DWORD    dwDiskQuota;       // in KB
    DWORD    dwGroupNameOffset;
    DWORD    dwGroupStorageOffset;
}
    *LPGROUP_ENTRY;


#define PAGE_SIZE_FOR_GROUPS    (PAGE_SIZE - sizeof(FILEMAP_ENTRY))
#define GROUPS_PER_PAGE         PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_ENTRY)

typedef struct _GROUP_DATA_ENTRY
{
    CHAR    szName[GROUPNAME_MAX_LENGTH];
    DWORD   dwOwnerStorage[GROUP_OWNER_STORAGE_SIZE];
    DWORD   dwOffsetNext;
} GROUP_DATA_ENTRY, *LPGROUP_DATA_ENTRY;

#define GROUPS_DATA_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_DATA_ENTRY)

//
// so the sizeof(GROUPS_PAGE_FILEMAP_ENTRY) = PAGE_SIZE
// this is the allocation unit for groups entry
//
typedef struct _GROUPS_ALLOC_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    BYTE    pGroupBlock[PAGE_SIZE_FOR_GROUPS];    
} GROUPS_ALLOC_FILEMAP_ENTRY, *LPGROUPS_ALLOC_FILEMAP_ENTRY;


typedef struct _LIST_GROUP_ENTRY 
{
    DWORD   dwGroupOffset;
    DWORD   dwNext;

} LIST_GROUP_ENTRY, *LPLIST_GROUP_ENTRY;

#define LIST_GROUPS_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(LIST_GROUP_ENTRY)


#define SIGNATURE_CONTAINER_FIND 0xFAFAFAFA
#define SIG_CACHE_FIND 0XFBFBFBFB
#define SIG_GROUP_FIND 0XFCFCFCFC

typedef struct _CONTAINER_FIND_FIRST_HANDLE 
{
    DWORD dwSignature;
    DWORD dwNumContainers;
    DWORD dwContainer;
    LPSTR *ppNames;
    LPSTR *ppPrefixes;
    LPSTR *ppLabels;
    LPSTR *ppTitles;
    // DATA follows for Names, Prefixes, Volume labels and Volume titles.
} CONTAINER_FIND_FIRST_HANDLE, *LPCONTAINER_FIND_FIRST_HANDLE;

typedef struct _CACHE_FIND_FIRST_HANDLE 
{
    DWORD dwSig;
    BOOL  fFixed;
    DWORD nIdx;
    DWORD dwHandle;
    GROUPID GroupId;
    DWORD dwFilter;
    DWORD dwFlags;
} CACHE_FIND_FIRST_HANDLE, *LPCACHE_FIND_FIRST_HANDLE;

typedef struct _CACHE_STREAM_CONTEXT_HANDLE 
{
    HANDLE FileHandle;
    LPSTR SourceUrlName;
}  CACHE_STREAM_CONTEXT_HANDLE, *LPCACHE_STREAM_CONTEXT_HANDLE;

typedef struct _GROUP_FIND_FIRST_HANDLE : CACHE_FIND_FIRST_HANDLE
{
    DWORD dwLastItemOffset;
} GROUP_FIND_FIRST_HANDLE, *LPGROUP_FIND_FIRST_HANDLE;

#define OFFSET_NO_MORE_GROUP    -1
#define GID_INDEX_TO_NEXT_PAGE	-1
#define OFFSET_TO_NEXT_PAGE     -1

#define GID_MASK            0x0fffffffffffffff
#define GID_STICKY_BIT      0x1000000000000000

#define IsStickyGroup(gid)  (gid & GID_STICKY_BIT)
#define SetStickyBit(gid)   (gid | GID_STICKY_BIT)
#define IsInvalidGroup(gid) (gid & 0xE000000000000000)

//
// RealFileSize() - given the actual filesize,
// this macro computes the approximate real space that a file takes up
// on the disk. It only takes care of rounding to the cluster size
// It doesn't take into account any per-file overhead used in the filesystem
//

#define RealFileSize(fs)  ((LONGLONG) (fs + _ClusterSizeMinusOne) & _ClusterSizeMask)

#define MUTEX_DBG_TIMEOUT   5 * 1000    // 5 secs.

#define URLCACHE_OP_SET_STICKY   1
#define URLCACHE_OP_UNSET_STICKY 2

#ifdef unix
extern BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost);
extern BOOL DeleteAtomicCacheLockFile();
extern void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar);
extern void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,LPCTSTR szKeyName);
extern int  CopyDir(const char* src_dir, const char* dest_dir);
#endif /* unix */

extern VOID FileTime2DosTime(FILETIME, DWORD*);
extern VOID DosTime2FileTime(DWORD, FILETIME*);

#endif  // _CACHEDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cacheapi.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cacheapi.cxx

Abstract:

    contains the URL cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Prefixed containers for supporting cookies and history
    2) Default init, for distributing winint without setup
    3) Crossprocess versionchecking scheme to allow all wininets
       to know about registry change

--*/

#include <cache.hxx>
#include <time.h>
#include <resource.h>
    
URLCACHEAPI_(BOOL) UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    hStreamHandle : stream handle returned by a RetrieveUrlCacheEntryStream call.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryStream",
        "%#x, %#x", hStream, dwReserved))

    DWORD Error;


    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE *pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE *) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
    
        
    TcpsvcsDbgAssert(pStream->SourceUrlName != NULL );

    //
    // close file handle.
    //

    CloseHandle( pStream->FileHandle );

    //
    // unlock cache file.
    //

    if(!UnlockUrlCacheEntryFile(pStream->SourceUrlName, dwReserved) )
        Error = GetLastError();
    else
        Error = ERROR_SUCCESS;

    //
    // freeup url name data buffer.
    //

    FREE_MEMORY (pStream->SourceUrlName);

    //
    // free up context structure.
    //

    LOCK_CACHE();
    HandleMgr.Free (hStream);
    UNLOCK_CACHE();

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) ReadUrlCacheEntryStream(
    IN HANDLE hStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This API provides a method  of reading the cached data from a stream
    which has been opened using the RetrieveUrlCacheEntryStream API.

Arguments:

    hStream : Handle that was returned by the RetrieveCacheEntryStream API.

    dwLocation  : file offset to read from.

    lpBuffer : Pointer to a buffer where the data is read.

    lpdwLen : Pointer to a DWORD location where the length of the above buffer passed in, on return it contains the actual length of the data read.

    dwReserved : For future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "ReadUrlCacheEntryStream",
        "%#x, %d, %#x, %#x, %#x", hStream, dwLocation, lpBuffer, lpdwLen, Reserved));

    DWORD Error;

    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    TcpsvcsDbgAssert( pStream->SourceUrlName);

    // PERFPERF: should we remember position to avoid this call?
    if ((DWORD) -1L == SetFilePointer
        (pStream->FileHandle, dwLocation, NULL, FILE_BEGIN))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    if( !ReadFile
        (pStream->FileHandle, lpBuffer, *lpdwLen, lpdwLen, NULL ) )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    LEAVE_CACHE_API();
}


URLCACHEAPI_(BOOL) FindCloseUrlCache(
    IN HANDLE hFind
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindCloseUrlCache",
        "%#x", hFind));

    DWORD Error;
    
    Error = GlobalUrlContainers->FreeFindHandle(hFind);

    if (Error != ERROR_SUCCESS)
    {
        SetLastError( Error );
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);
    return (Error==ERROR_SUCCESS);
}


BOOL
GetCurrentSettingsVersion(LPDWORD   lpdwVer) {

    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                              lpdwVer);
}

BOOL
IncrementCurrentSettingsVersion(LPDWORD lpdwVer) {

    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                                    lpdwVer);
}


BOOL
GetUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(nIdx, lpdwData);
}

BOOL
SetUrlCacheHeaderData(IN DWORD nIdx, IN  DWORD  dwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetHeaderData(nIdx, dwData);
}

BOOL
IncrementUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(nIdx, lpdwData);
}


BOOL
LoadUrlCacheContent(VOID)
{
    DWORD dwError;
    if (!InitGlobals())
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->LoadContent();
    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}


BOOL
GetUrlCacheContainerInfo(
    IN LPSTR lpszUrlName,
	OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
	IN OUT LPDWORD lpdwContainerInfoBufferSize,
	IN DWORD dwOptions
)
{
    DWORD dwError;

    // Initialize globals.
    if (!InitGlobals())
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->GetContainerInfo(lpszUrlName,
            lpContainerInfo, lpdwContainerInfoBufferSize);

    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}

BOOL
UpdateUrlCacheContentPath(
    IN LPSTR lpszNewPath
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UpdateUrlCacheContentPath", "%q", lpszNewPath));
    INET_ASSERT(GlobalCacheInitialized);

    BOOL fResult = GlobalUrlContainers->SetContentPath(lpszNewPath);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}



INTERNETAPI_(GROUPID) CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheGroup", "%#x, %#x", dwFlags, lpReserved));
    GROUPID gid = 0;
    DWORD   Error; 

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->CreateGroup(dwFlags, &gid);

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(gid);    
    return gid;
}

BOOLAPI DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheGroup", "%#x, %#x, %#x", GroupId, dwFlags, lpReserved));
    DWORD   Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteGroup(GroupId, dwFlags);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(HANDLE) FindFirstUrlCacheGroup(
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwFilter,
    IN      LPVOID                          lpSearchCondition,
    IN      DWORD                           dwSearchCondition,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
) 
{
    ENTER_CACHE_API ((DBG_API, Handle, "FindFirstUrlCacheGroup",
        "%d, %d, %#x, %d, %#x, %#x", 
        dwFlags, dwFilter, lpSearchCondition, 
        dwSearchCondition, lpGroupId, lpReserved ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    // Get the first entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, dwFlags, lpGroupId);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
        hFind = NULL;
    }

    INET_ASSERT (hFind);
    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheGroup(
    IN HANDLE                               hFind,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
    )
{

    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheGroup",
        "%#x, %#x, %#x", hFind, lpGroupId, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, 0, lpGroupId);

    LEAVE_CACHE_API();
}



BOOL
AnyFindsInProgress(DWORD ContainerID)
{
    LOCK_CACHE();
    BOOL fInProgress = HandleMgr.InUse();
    UNLOCK_CACHE();
    return fInProgress;
}


BOOLAPI
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
)
{
    DWORD Error;
    ENTER_CACHE_API ((DBG_API, Bool, "RegisterUrlCacheNotification", 
        "%#x,,%#x, %#x, %#x, %#x", hWnd, uMsg, gid, dwFilter, dwReserve));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);

    LEAVE_CACHE_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

// Event tracking macros...
#define EVENTWRAP(API, h) {\
    BOOL ret = API(h);\
    if (ret) \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d)\n", h)); \
    else { \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d) failed err=%d\n",\
            h, GetLastError())); \
        TcpsvcsDbgAssert( FALSE ); \
    } \
}\

#define   SETEVENT(h)  EVENTWRAP(SetEvent,    h)
#define RESETEVENT(h)  EVENTWRAP(ResetEvent,  h)
#define CLOSEHANDLE(h) EVENTWRAP(CloseHandle, h)

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#define ENTER_CACHE_API(paramlist) \
{ DEBUG_ONLY(LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();) \
  DEBUG_ENTER_API(paramlist); \
}

#define LEAVE_CACHE_API() \
Cleanup:                         \
    if (Error != ERROR_SUCCESS)  \
    {                            \
        SetLastError( Error );   \
        DEBUG_ERROR(INET, Error); \
    }                            \
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);      \
    return (Error==ERROR_SUCCESS);                 \

#if DBG

///#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define TcpsvcsDbgAssert(Predicate) INET_ASSERT(Predicate)

#else

///#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\conmgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conmgr.cxx

Abstract:

    Manages list of containers (CConList)

Author:
    Adriaan Canter (adriaanc) 04-02-97

--*/

#include <cache.hxx>

#define FAILSAFE_TIMEOUT (60000)

/*---------------------  Private Functions -----------------------------------*/
/*-----------------------------------------------------------------------------
DWORD CConMgr::Init
----------------------------------------------------------------------------*/
DWORD CConMgr::Init()
{
    DWORD dwError = ConfigureCache();

    if (dwError==ERROR_SUCCESS)
    {
        // Get the extensible cache config info.
        // These containers are delay-initialized.
        dwError = GetExtensibleCacheConfigInfo(TRUE);
    }
    else
    {
        INET_ASSERT(FALSE);
    }
    return dwError;

}

#ifdef CHECKLOCK_PARANOID
void CConMgr::CheckNoLocks(DWORD dwThreadId)
{
    URL_CONTAINER *co;
    DWORD idx;

    LOCK_CACHE();
    for (idx = 0; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            co->CheckNoLocks(dwThreadId);
            co->Release(FALSE);
        }
    }
    UNLOCK_CACHE();
}
#endif

/*-----------------------------------------------------------------------------
BOOL CConMgr::WasModified
----------------------------------------------------------------------------*/
BOOL CConMgr::WasModified(BOOL fUpdateMemory)
{
    DWORD dwOldCount = _dwModifiedCount;
    return dwOldCount != ReadModifiedCount(fUpdateMemory);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::ReadModifiedCount
----------------------------------------------------------------------------*/
DWORD CConMgr::ReadModifiedCount(BOOL fUpdateMemory)
{
    DWORD dwChangeCount;
    DWORD *pdwChangeCount = fUpdateMemory ? &_dwModifiedCount : &dwChangeCount;

    _coContent->GetHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                             pdwChangeCount);
    return *pdwChangeCount;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::IncrementModifiedCount
----------------------------------------------------------------------------*/
void CConMgr::IncrementModifiedCount()
{
    DWORD dwLocModified;

    _coContent->IncrementHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                                   &dwLocModified);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::InitFixedContainers
----------------------------------------------------------------------------*/
DWORD CConMgr::InitFixedContainers()
{
    DWORD idx;
    DWORD dwError = ERROR_SUCCESS;
    BOOL fInitSucceeded = TRUE;

    //  Create and init
    _hMutexExtensible = OpenMutex(SYNCHRONIZE, FALSE, TEXT("_!MSFTHISTORY!_"));
    if (_hMutexExtensible == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _hMutexExtensible = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, TEXT("_!MSFTHISTORY!_"));
    }
    if (_hMutexExtensible == NULL)
    {
        dwError = GetLastError();
        fInitSucceeded = FALSE;
        goto exit;
    }
    _dwLastUnmap = GetTickCountWrap();

    LOCK_CACHE();
    // Containers are configured. Attempt to initialize.
    for (idx = CONTENT; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            dwError = co->Init();

            // NOTE - URL_CONTAINER::Init() returns ERROR_ALREADY_EXISTS
            // only if the the existing memory mapped file has been opened
            // successfully. If the memory mapped file was created, upgraded
            // or corrupted (in both cases the mem mapped file will be reinited)
            // the return value will be ERROR_SUCCESS.

            if(dwError != ERROR_SUCCESS && dwError != ERROR_ALREADY_EXISTS)
            {
                fInitSucceeded = FALSE;
                goto unlock_exit;
            }

            // Has the container been created, upgrade or corrupted?
            if (dwError == ERROR_SUCCESS)
            {
                if(idx==CONTENT)
                {
                    // Preload the content container.
                    LoadContent();
                }
                else if (idx==COOKIE)
                {
                    CCookieLoader cl;
                    cl.LoadCookies(co);
                }
            }
            co->Release(FALSE);
        }

    }

    // Enable cachevu for CONTENT and HISTORY.
    EnableCacheVu(_coContent->GetCachePath(), CONTENT);
    EnableCacheVu(_coHistory->GetCachePath(), HISTORY);

unlock_exit:

    UNLOCK_CACHE();

exit:
    dwError = (fInitSucceeded ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
    if (!fInitSucceeded && _hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
        _hMutexExtensible = NULL;
    }
    INET_ASSERT(dwError == ERROR_SUCCESS);
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::LoadContent()
----------------------------------------------------------------------------*/
DWORD CConMgr::LoadContent()
{
    DWORD cbFile, dwError = ERROR_FILE_NOT_FOUND;
    CHAR  szPreloadKey[MAX_PATH],
          szUrl[MAX_PATH],
          szFile[MAX_PATH];

    // Preload registry key string.
    memcpy(szPreloadKey, OLD_CACHE_KEY, sizeof(OLD_CACHE_KEY) - 1);
    szPreloadKey[sizeof(OLD_CACHE_KEY)-1] = '\\';
    memcpy(szPreloadKey + sizeof(OLD_CACHE_KEY), "Preload", sizeof("PreLoad"));

    // Construct preload registry object.
    REGISTRY_OBJ roPreload(HKEY_CURRENT_USER, szPreloadKey);
    REGISTRY_OBJ roIE5Preload;
    if (roPreload.GetStatus() != ERROR_SUCCESS)
        goto exit;

    // Get the storage directory (cdf preload) to compare against to determine if we
    // need to set EDITED_CACHE_ENTRY or not. We assume any preload entry not in the
    // store dir IS and ECE.
    DWORD cb;
    CHAR szStorePath[MAX_PATH];

    // Store dir is hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szStorePath, MAX_PATH)))
    {
        AppendSlashIfNecessary(szStorePath, &cb);
        memcpy(szStorePath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1; //cb now equals size of szStorePath.
    }


    // Enum the registry url/file values and commit them
    // to the cache.
    while (roPreload.FindNextValue(szUrl, MAX_PATH,
        (LPBYTE) szFile, &(cbFile = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Strip off any file:// off the file path/name.
        CHAR* ptr = szFile;

        if (!strnicmp(ptr, "file://", sizeof("file://") - 1))
            ptr += sizeof("file://") - 1;

        AddUrlArg Args;
        memset(&Args, 0, sizeof(Args));
        Args.pszUrl      = szUrl;
        Args.pszFilePath = ptr;

        // If this is a Store entry, set the type to 0 else ECE
        if (!strnicmp(ptr, szStorePath, cb))
            Args.dwEntryType = 0;
        else
            Args.dwEntryType = EDITED_CACHE_ENTRY;

        _coContent->AddUrl(&Args);
    }


    if (roIE5Preload.WorkWith(&roPreload, "IE5Preload")!=ERROR_SUCCESS)
        goto exit;
        
    DWORD cbMaxUrl, cbMaxEntry, cbEntry;
    LPSTR pszUrl;
    URL_FILEMAP_ENTRY *pEntry;
    KEY_QUERY_INFO QueryInfo;

    if (ERROR_SUCCESS != roIE5Preload.GetKeyInfo(&QueryInfo))
        goto exit;
                
    cbMaxUrl = QueryInfo.MaxValueNameLen + 1;
    cbMaxEntry = QueryInfo.MaxValueLen + 1;
    
    pszUrl = new CHAR[cbMaxUrl];
    pEntry = (URL_FILEMAP_ENTRY*) new CHAR[cbMaxEntry];

    if (!(pszUrl && pEntry))
        goto exit;


    __try
    {
        
        while ((dwError = roIE5Preload.FindNextValue(pszUrl, cbMaxUrl,
            (LPBYTE) pEntry, &(cbEntry = cbMaxEntry))) == ERROR_SUCCESS)
        {
            FILETIME ft;
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));

            // Url
            Args.pszUrl      = pEntry->UrlNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset) : NULL;
    
            // File path
            Args.pszFilePath = pEntry->InternalFileNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset) : NULL;

            // Header info
            Args.pbHeaders = pEntry->HeaderInfoOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset) : NULL;
            Args.cbHeaders = pEntry->HeaderInfoSize;

            // Last modified.
            Args.qwLastMod = pEntry->LastModifiedTime;

            // Expires time.
            DosTime2FileTime(pEntry->dostExpireTime, &ft);        
            Args.qwExpires = FT2LL(ft);

            // Post check time.
            DosTime2FileTime(pEntry->dostPostCheckTime, &ft);        
            Args.qwPostCheck = FT2LL(ft);

            // File creation time.
            DosTime2FileTime(pEntry->dostFileCreationTime, &ft);        
            Args.ftCreate = ft;
        
            // File extension.
            Args.pszFileExt = pEntry->FileExtensionOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset) : NULL;
 
            // Entry type.
            Args.dwEntryType = pEntry->CacheEntryType;

            // File size
            Args.dwFileSize = pEntry->dwFileSize;

            // Add the url.
            _coContent->AddUrl(&Args);
        }

    } // __try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = GetLastError();
    }
    ENDEXCEPT
     
    dwError = ERROR_SUCCESS;

    if (pszUrl)
        delete pszUrl;
    if (pEntry)
        delete pEntry;
        
exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
HANDLE CConMgr::FindFirstContainer
----------------------------------------------------------------------------*/
HANDLE CConMgr::FindFirstContainer(DWORD *pdwModified, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    CONTAINER_FIND_FIRST_HANDLE *pFind;
    DWORD dwContainers = 0;
    DWORD dwNames = 0;
    DWORD dwPrefixes = 0;
    DWORD dwLabels = 0;
    DWORD dwTitles = 0;
    DWORD dwTotal;
    HANDLE hFind = NULL;
    DWORD dwModified;

    GetExtensibleCacheConfigInfo(FALSE);

    LOCK_CACHE();
    dwModified = *pdwModified;
    *pdwModified = _dwModifiedCount;


    if ((CACHE_FIND_CONTAINER_RETURN_NOCHANGE & dwOptions) == 0 ||
        dwModified != *pdwModified)
    {
        for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
        {
            URL_CONTAINER *co = ConList.Get(i);
            if (co)
            {
                if (co->IsVisible())
                {
                    dwContainers++;
                    dwNames += strlen(co->GetCacheName()) + 1;
                    dwPrefixes += strlen(co->GetCachePrefix()) + 1;
                    dwLabels += strlen(co->GetVolumeLabel()) + 1;
                    dwTitles += strlen(co->GetVolumeTitle()) + 1;
                }
                co->Release(TRUE);
            }
        }

        dwTotal = sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                         dwContainers*(4 * sizeof(LPSTR)) +
                         (dwNames+dwPrefixes+dwLabels+dwTitles) * sizeof(char);

        hFind = HandleMgr.Alloc (dwTotal);
        if (hFind)
        {
            LPSTR ps;

            pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
            pFind->dwSignature = SIGNATURE_CONTAINER_FIND;
            pFind->dwContainer = 0;
            pFind->dwNumContainers = dwContainers;
            if (dwContainers)
            {
                pFind->ppNames = (LPTSTR *) (((LPBYTE) pFind) + sizeof(CONTAINER_FIND_FIRST_HANDLE));
                pFind->ppPrefixes = pFind->ppNames + dwContainers;
                pFind->ppLabels = pFind->ppPrefixes + dwContainers;
                pFind->ppTitles = pFind->ppLabels + dwContainers;
                ps = (LPSTR) (((LPBYTE) pFind) +
                                sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                                dwContainers*(4 * sizeof(LPSTR)));
                dwContainers = 0;

                for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
                {
                    URL_CONTAINER *co = ConList.Get(i);
                    if (co)
                    {
                        if (co->IsVisible())
                        {
                            pFind->ppNames[dwContainers] = ps;
                            strcpy(ps, co->GetCacheName());
                            ps += strlen(co->GetCacheName()) + 1;
                            pFind->ppPrefixes[dwContainers] = ps;
                            strcpy(ps, co->GetCachePrefix());
                            ps += strlen(co->GetCachePrefix()) + 1;
                            pFind->ppLabels[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeLabel());
                            ps += strlen(co->GetVolumeLabel()) + 1;
                            pFind->ppTitles[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeTitle());
                            ps += strlen(co->GetVolumeTitle()) + 1;

                            dwContainers++;
                        }
                        co->Release(TRUE);
                    }
                }

            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwError = ERROR_INTERNET_NO_NEW_CONTAINERS;
    }
    UNLOCK_CACHE();

    if (hFind)
    {
        if (FindNextContainer(hFind, lpContainerInfo, lpdwContainerInfoBufferSize))
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();
    }
    if( dwError != ERROR_SUCCESS )
    {
        FreeFindHandle(hFind);
        SetLastError(dwError);
        return NULL;
    }
    return hFind;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::FindNextContainer
----------------------------------------------------------------------------*/
BOOL CConMgr::FindNextContainer(HANDLE hFind, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize)
{
    // BUGBUG - this logic is borrowed from the original cachapia.cxx.

    DWORD                    dwError;
    CONTAINER_FIND_FIRST_HANDLE* pFind;

    // Map and validate the handle.
    LOCK_CACHE();
    pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
    UNLOCK_CACHE();
    if (!pFind || pFind->dwSignature != SIGNATURE_CONTAINER_FIND ||
        !lpContainerInfo ||
        *lpdwContainerInfoBufferSize < sizeof(INTERNET_CACHE_CONTAINER_INFOA))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Continue the enumeration.
    if (pFind->dwContainer < pFind->dwNumContainers)
    {
        DWORD cbName = strlen(pFind->ppNames[pFind->dwContainer])+1;
        DWORD cbPrefix = strlen(pFind->ppPrefixes[pFind->dwContainer])+1;
        DWORD cbLabel = strlen(pFind->ppLabels[pFind->dwContainer])+1;
        DWORD cbTitle = strlen(pFind->ppTitles[pFind->dwContainer])+1;

        DWORD cbTotal = cbName+cbPrefix+cbLabel+cbTitle+sizeof(INTERNET_CACHE_CONTAINER_INFOA);
        if (cbTotal > *lpdwContainerInfoBufferSize)
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            lpContainerInfo->lpszName = (LPSTR) (((LPBYTE) lpContainerInfo) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));
            lpContainerInfo->lpszCachePrefix = lpContainerInfo->lpszName + cbName;
            lpContainerInfo->lpszVolumeLabel = lpContainerInfo->lpszCachePrefix + cbPrefix;
            lpContainerInfo->lpszVolumeTitle = lpContainerInfo->lpszVolumeLabel + cbLabel;

            strcpy(lpContainerInfo->lpszName, pFind->ppNames[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszCachePrefix, pFind->ppPrefixes[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeLabel, pFind->ppLabels[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeTitle, pFind->ppTitles[pFind->dwContainer]);
            lpContainerInfo->dwCacheVersion = URL_CACHE_VERSION_NUM;
            pFind->dwContainer++;
            dwError = ERROR_SUCCESS;
        }
        *lpdwContainerInfoBufferSize = cbTotal;
    }
    else
    {
        dwError = ERROR_NO_MORE_ITEMS;
    }

exit:
    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetContainerInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetContainerInfo(LPSTR szUrl,
                               LPINTERNET_CACHE_CONTAINER_INFOA pCI,
                               LPDWORD pcbCI)
{
    URL_CONTAINER *co;
    DWORD dwError;

    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        DWORD cbName = strlen(co->GetCacheName()) + 1;
        DWORD cbPrefix = strlen(co->GetCachePrefix()) + 1;
        DWORD cbLabel = strlen(co->GetVolumeLabel()) + 1;
        DWORD cbTitle = strlen(co->GetVolumeTitle()) + 1;
        DWORD cbReq = cbName + cbPrefix + cbLabel + cbTitle;
        if (cbReq > *pcbCI)
        {
            *pcbCI = cbReq;
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            pCI->lpszName = (LPSTR) (((LPBYTE) pCI) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));

            pCI->lpszCachePrefix = pCI->lpszName + cbName;
            pCI->lpszVolumeLabel = pCI->lpszName + cbName + cbPrefix;
            pCI->lpszVolumeTitle = pCI->lpszName + cbName + cbPrefix + cbLabel;

            memcpy(pCI->lpszName, co->GetCacheName(), cbName);
            memcpy(pCI->lpszCachePrefix, co->GetCachePrefix(), cbPrefix);
            memcpy(pCI->lpszVolumeLabel, co->GetVolumeLabel(), cbLabel);
            memcpy(pCI->lpszVolumeTitle, co->GetVolumeTitle(), cbTitle);
            pCI->dwCacheVersion = URL_CACHE_VERSION_NUM;

            *pcbCI = cbReq;
            dwError = ERROR_SUCCESS;
        }

        co->Release(TRUE);
    }
    else
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    }

    UNLOCK_CACHE();

    return dwError;
}

VOID CompressPath(PTSTR pszPath, PTSTR pszScratch);

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateContainer(LPCSTR Name, LPCSTR CachePrefix, LPCSTR CachePath, DWORD KBCacheLimit, DWORD dwOptions)
{
    BOOL fInsertOk = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];
    CHAR szDefaultPath[MAX_PATH];
    CHAR szCachePath[MAX_PATH];
    LONGLONG CacheStartUpLimit;
    HKEY hKey;
    DWORD cbKeyLen;

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = NULL;
    MUTEX_HOLDER mh;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    if (!CachePath || !*CachePath)
    {
        LPSTR p = _coHistory->GetCachePath();
        int len = _coHistory->GetCachePathLen();
        int clen = lstrlen(Name);

        if (len + clen + sizeof(DIR_SEPARATOR_STRING) > sizeof(szDefaultPath)) 
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
        memcpy(szDefaultPath, p, len);

        memcpy(&szDefaultPath[len], Name, clen);
        memcpy(&szDefaultPath[len + clen], DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    }
    else 
    {
        INET_ASSERT((CachePrefix && *CachePrefix));

        // For non-history containers, we need to stuff into the appropriate subcontainer
        // Assumption: Content cache never falls here.
        if (!GenerateStringWithOrdinal(CachePath, 
                                       GlobalIdentity, 
                                       szDefaultPath, 
                                       ARRAY_ELEMENTS(szDefaultPath)))
        {
            INET_ASSERT(FALSE);
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
    }
    CachePath = szDefaultPath;
    
    if (KBCacheLimit == 0)
    {
        CacheStartUpLimit = _coHistory->GetCacheStartUpLimit();
        KBCacheLimit = (DWORD) (CacheStartUpLimit / 1024);
    }


    if (!CachePrefix || !*CachePrefix || !CachePath || !*CachePath)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }   
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                // Path.
                TCHAR szScratch[MAX_PATH];
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch,&cbKeyLen) != ERROR_SUCCESS)
                    continue;

                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                if (!stricmp(szVendorKey, Name) || !stricmp(CachePath, szCachePath))
                {
                    fInsertOk = FALSE;
                    break;
                }
            }
        }   

        if (fInsertOk)
        {
            REGISTRY_OBJ roNewVendor(&roExtensibleCache, (LPSTR)Name, CREATE_KEY_IF_NOT_EXISTS);
            if (roNewVendor.GetStatus() == ERROR_SUCCESS)
            {
                CHAR szScratch[MAX_PATH];
                CompressPath((LPTSTR)CachePath, szScratch);
                    // Path.
                if ((dwError = roNewVendor.SetValue(CACHE_PATH_VALUE, (LPSTR)szScratch, REG_EXPAND_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Prefix.
                if ((dwError = roNewVendor.SetValue(CACHE_PREFIX_VALUE, (LPSTR)CachePrefix, REG_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Limit.
                if ((dwError = roNewVendor.SetValue(CACHE_LIMIT_VALUE, &KBCacheLimit)) != ERROR_SUCCESS)
                        goto exit;

                    // Options.
                if ((dwError = roNewVendor.SetValue(CACHE_OPTIONS_VALUE, &dwOptions)) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        else
        {
            dwError = ERROR_ALREADY_EXISTS;
        }
    }

    if (fInsertOk)
    {
        IncrementModifiedCount();
    }

exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    if (fInsertOk)
    {
        GetExtensibleCacheConfigInfo(TRUE);
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::FindExtensibleContainer
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SECTION
DWORD CConMgr::FindExtensibleContainer(LPCSTR Name)
{
    DWORD n = NOT_AN_INDEX;
    DWORD i;
    URL_CONTAINER *co;

    for (i = NCONTAINERS; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (!stricmp(Name, co->GetCacheName()) && co->IsVisible())
            {
                // Found a match
                n = i;
                co->Release(FALSE);
                break;
            }
            co->Release(FALSE);
        }
    }

    return n;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteContainer(LPCSTR Name, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    URL_CONTAINER *co = NULL;
    DWORD n = NOT_AN_INDEX;
    HKEY hKey;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    LOCK_CACHE();
    n = FindExtensibleContainer(Name);
    if (n != NOT_AN_INDEX)
    {
        co = ConList.Get(n);

        if (co)
        {
            co->SetDeletePending(TRUE);
            //  Don't release here, hold it pending until we've updated registry
        }
    }
    UNLOCK_CACHE();

    if (n!= NOT_AN_INDEX)
    {
        hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);

        REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
        if (!pro)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto exit;
        }
        
        {
            REGISTRY_OBJ& roExtensibleCache = *pro;
            MUTEX_HOLDER mh;
            mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);
            dwError = roExtensibleCache.DeleteKey((LPSTR)Name);
            mh.Release();
            IncrementModifiedCount();
        }
        delete pro;
    }

exit:
    LOCK_CACHE();
    SAFERELEASE(co, TRUE);
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteFileIfNotRegistered
----------------------------------------------------------------------------*/
BOOL CConMgr::DeleteFileIfNotRegistered(URL_CONTAINER *coDelete)
{
    BOOL fDelete = TRUE;
    BOOL fFound = FALSE;
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    DWORD dwOptions;
    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError;
    CHAR szVendorKey[MAX_PATH];

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
    MUTEX_HOLDER mh;
    
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    if (!WasModified(FALSE))
    {
        //  If our internal cache is up to date, it can't
        //  have been deleted unless DeletePending or Deleted
        fFound = !(coDelete->GetDeletePending()||coDelete->GetDeleted());
        if (fFound)
        {
            goto exit;
        }
        //  If not found, need to look at registry to make sure we're not
        //  deleting a path that has been reused
    }

    mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

    {
    REGISTRY_OBJ& roExtensibleCache = *pro;

     // Get the container paths, prefixes.
    while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
    {
        BOOL fPathMatch;
        REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
        if (roVendor.GetStatus()==ERROR_SUCCESS)
        {
            // Path.
            TCHAR szScratch[MAX_PATH];
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL

            // Prefix.
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PREFIX_VALUE,(LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            // Options.
            if (roVendor.GetValue(CACHE_OPTIONS_VALUE,&dwOptions) != ERROR_SUCCESS)
                continue;

            fPathMatch = !stricmp(coDelete->GetCachePath(), szCachePath);
            if (!stricmp(coDelete->GetCacheName(), szVendorKey) && fPathMatch &&
                !stricmp(coDelete->GetCachePrefix(), szCachePrefix) &&
                coDelete->GetOptions() != dwOptions)
            {
                fFound = TRUE;
            }
            if (fPathMatch)
                fDelete = FALSE;
        }
    }
    }
    if (fDelete)
    {
        //  This will fail if another process still has the container mapped,
        //  that's ok.  They will check on exit if container needs to be
        //  deleted
        if (coDelete->GetOptions() & INTERNET_CACHE_CONTAINER_AUTODELETE)
        {
            CFileMgr::DeleteCache(coDelete->GetCachePath());
        }
    }
exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    
    return !fFound;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindIndexFromPrefix
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
DWORD CConMgr::FindIndexFromPrefix(LPCSTR szUrl)
{
    // Unless we find a matching prefix, CONTENT is the default.
    DWORD n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
    URL_CONTAINER *co = NULL;

    //  NOTE: if deleting a container is supported, ConList.Get(i) can
    //  return NULL, if list shrinks after getting size.
    //  NOTE: if deleting containers is supported, it is not safe to
    //  assume CONTENT if prefix is not found.  client may be trying to
    //  insert into a container that has been deleted, but once existed.
    //  proper response is to return an error.  the simplest way to do this
    //  is to insist that all Extensible cache prefixes start with an illegal
    //  URL character, EXTENSIBLE_FIRST

    GetExtensibleCacheConfigInfo(FALSE);
    for (DWORD i = COOKIE; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (co->PrefixMatch(szUrl))
            {
                // For content container, strnicmp (szUrl, "", 0) returns nonzero
                if (co->IsVisible())
                {
                    // Found a match
                    n = i;
                    if (!co->IsInitialized())
                    {
                        // Init the container. If this fails,
                        // Mark it as DELETED and return CONTENT.
                        switch (co->Init())
                        {
                        case ERROR_SUCCESS:
                        case ERROR_ALREADY_EXISTS:
                            if (!(co->GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                                EnableCacheVu(co->GetCachePath(), n);
                            break;
                        default:
                            INET_ASSERT(FALSE);
                            co->SetDeleted(TRUE);
                            n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
                            break;
                        }
                    }
                    co->Release(FALSE);
                    break;
                }
            }
            co->Release(FALSE);
        }
    }
    return n;
}



/*-----------------------------------------------------------------------------
BOOL CConMgr::PathPrefixMatch
----------------------------------------------------------------------------*/
BOOL CConMgr::PathPrefixMatch(LPCSTR szPath, LPCSTR szPathRef)
{
    // BUGBUG - logic borrowed from original cacheapi.cxx

    INT len;

    // TRUE if the passed in path is NULL
    if (!szPath)
        return TRUE;

    len = lstrlen(szPath);

    // TRUE if it is 0 length.
    if (!len)
        return TRUE;

    // stripout the trailing slash
    if (szPath[len-1] == DIR_SEPARATOR_CHAR)
        --len;

    // Compare paths.
    if (!strnicmp(szPath, szPathRef, len))
        if (szPathRef[len] == DIR_SEPARATOR_CHAR || szPathRef[len] == 0)
            return TRUE;

    return FALSE;
}

/*---------------------  Public Functions -----------------------------------*/

/*-----------------------------------------------------------------------------
CConMgr::CConMgr

  Default Constructor
  ----------------------------------------------------------------------------*/
CConMgr::CConMgr()
: ConList()
{
    _coContent = NULL;
    _coCookies = NULL;
    _coHistory = NULL;
    _hMutexExtensible = 0;

    // Assume this is a profiles-capable machine. Later on, we'll make sure this is
    // the case.
    _fProfilesCapable = TRUE;

    // Assume that we'll be using the regular containers, instead of the backup
    _fUsingBackupContainers = FALSE;
    _dwStatus = Init();
}


/*-----------------------------------------------------------------------------
CConMgr::~CConMgr

  Default Destructor
  ----------------------------------------------------------------------------*/
CConMgr::~CConMgr()
{
    ConList.Free();
    if (_hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
    }
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetStatus()
----------------------------------------------------------------------------*/
DWORD CConMgr::GetStatus()
{
    return _dwStatus;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::UnlockUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::UnlockUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call UnlockUrl on the appropriate container.
        dwError = co->UnlockUrl(szUrl); // may be expensive
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call DeleteUrl on the appropriate container.
        dwError = co->DeleteUrl(szUrl); // may be expensive.
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::GetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::GetHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    return _coContent->GetHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::SetHeaderData(DWORD nIdx, DWORD dwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->SetHeaderData(nIdx, dwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::IncrementHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::IncrementHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->IncrementHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlGroup(
    IN LPCSTR   szUrl,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId
    )
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call SetUrlInGroup on the appropriate container.
        dwError = co->SetUrlGroup
            (szUrl, dwFlags, GroupId);
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateUniqueFile
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedSize,
                                       LPCSTR szFileExtension, LPTSTR szFileName,
                                       HANDLE *phfHandle,
                                       BOOL   fCreatePerUser)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);


    if (co)
    {
        UNLOCK_CACHE();
        // Call CreateUniqueFile on the appropriate container.
        dwError = co->CreateUniqueFile(szUrl, dwExpectedSize,
            szFileExtension, szFileName, phfHandle, fCreatePerUser); // expensive call
        LOCK_CACHE();

        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::AddUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::AddUrl(AddUrlArg* pArgs)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    DWORD idx = FindIndexFromPrefix(pArgs->pszUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call AddUrl on the appropriate container.
        dwError = co->AddUrl(pArgs); // may be expensive
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::RetrieveUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::RetrieveUrl( LPCSTR               szUrl,
                            LPCACHE_ENTRY_INFOA* ppCacheEntryInfo,
                            LPDWORD              pcbCacheEntryInfoBufferSize,
                            DWORD                dwLookupFlags,
                            DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call RetrieveUrl on the appropriate container.
        dwError = co->RetrieveUrl(szUrl,
                                  ppCacheEntryInfo,
                                  pcbCacheEntryInfoBufferSize,
                                  dwLookupFlags, dwRetrievalFlags); // expensive?
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInfo( LPCSTR               szUrl,
                           LPCACHE_ENTRY_INFOA*  ppCacheEntryInfo,
                           LPDWORD              pcbCacheEntryInfoBufferSize,
                           DWORD                dwLookupFlags,
                           DWORD                dwEntryFlags,
                           DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call GetUrlInfo on the appropriate container.
        dwError = co->GetUrlInfo(szUrl,
                                 ppCacheEntryInfo,
                                 pcbCacheEntryInfoBufferSize,
                                 dwLookupFlags,
                                 dwEntryFlags,
                                 dwRetrievalFlags);

        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::GetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          LPDWORD              pcbCacheEntryInfoBufferSize,
                          DWORD                dwLookupFlags,
                          DWORD                dwEntryFlags)
{
    return GetUrlInfo(szUrl,
                     (pCacheEntryInfo) ? &pCacheEntryInfo : NULL,
                     pcbCacheEntryInfoBufferSize,
                     dwLookupFlags,
                     dwEntryFlags,
                     0);
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          DWORD                dwFieldControl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call SetUrlInfo on the appropriate container.
        dwError = co->SetUrlInfo(szUrl,
                                 pCacheEntryInfo,
                                 dwFieldControl);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::FreeFindHandle(HANDLE hFind)
{
    DWORD dwError = ERROR_INVALID_HANDLE;

    if (hFind)
    {
        LOCK_CACHE();

        LPCACHE_FIND_FIRST_HANDLE pFind;
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
        if (pFind)
        {
            //  NOTHING SPECIAL TO DO FOR SIGNATURE_CONTAINER_FIND
            if (pFind->dwSig == SIG_CACHE_FIND && !pFind->fFixed)
            {
                URL_CONTAINER *co = ConList.Get(pFind->nIdx);
                if (co)
                {
                    //  It now has 2 AddRefs to balance
                    co->Release(FALSE);
                    co->Release(TRUE);
                }
            }

            HandleMgr.Free (hFind);
            dwError = ERROR_SUCCESS;
        }

        UNLOCK_CACHE();
    }
    
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextEntry
----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA*  ppInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags,
      DWORD                dwRetrievalFlags)
{
    DWORD                      idx, dwError;
    URL_CONTAINER             *co    = NULL;
    LPCACHE_FIND_FIRST_HANDLE  pFind = NULL;

    LOCK_CACHE();

    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // Allocate a handle.
        //LOCK_CACHE();
        *phFind = HandleMgr.Alloc (sizeof(CACHE_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig     = SIG_CACHE_FIND;
        pFind->dwHandle  = 0;
        pFind->dwFlags   = dwFlags;

        // Find the associated container. NULL prefix
        // results in enumeration over fixed containers.
        if (!szPrefix)
        {
            pFind->fFixed = TRUE;
            pFind->nIdx   = CONTENT;

        }
        else
        {

            idx = FindIndexFromPrefix(szPrefix);
            if (idx == NOT_AN_INDEX)
            {
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }

            // Under old semantics prefix resolving to CONTENT
            // container implies that an enumeration over all
            // the fixed containers is desired. Enumeration then
            // begins with the CONTENT container. We do not keep
            // a refcount on any fixed containers in this case.
            if (idx == CONTENT && (dwFlags & FIND_FLAGS_OLD_SEMANTICS))
            {
                pFind->fFixed = TRUE;
                pFind->nIdx   = CONTENT;
            }
            else
            {
                // Otherwise only enumeration over the found container
                // is implied. Retrieve this container. Set fFixed to FALSE.
                //  NO RELEASE: hold RefCnt until handle is closed
                co = ConList.Get(idx);

                if (co)
                {
                    pFind->fFixed   = FALSE;
                    pFind->nIdx     = idx;
                    pFind->dwHandle = co->GetInitialFindHandle();
                }
                else
                {
                    dwError = ERROR_NO_MORE_ITEMS;
                    goto exit;
                }
            }

        }
        // Set filter and group id in handle.
        pFind->dwFilter = dwFilter;
        pFind->GroupId  = GroupId;
    }
    else
    {
        // Valid handle passed in - map it.
        //LOCK_CACHE();
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    // -------------------------------------------------------------------------
    // The handle is initialized or was created via a previous FindNextEntry.
    //--------------------------------------------------------------------------

    dwError = ERROR_NO_MORE_ITEMS;

    // Are we only enumerating over one container?
    if (!pFind->fFixed)
    {
        // Get the associated container.
        co = ConList.Get(pFind->nIdx);

        if (co)
        {
            // Enum on the container and release.
            dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
            co->Release(TRUE);
        }
        else
        {
            // Getting container failed.
            dwError = ERROR_NO_MORE_ITEMS;
            goto exit;
        }

    }
    else
    {
        // fFixed is TRUE - enumerate over the fixed containers.
        while (pFind->nIdx < NCONTAINERS)
        {
            // Get the associated container.
            co = ConList.Get(pFind->nIdx);

            if (co)
            {
                // Get the initial hash find handle if not already done so.
                if (!pFind->dwHandle)
                    pFind->dwHandle = co->GetInitialFindHandle();

                // Enum on the container and release.
                dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
                co->Release(TRUE);

                // Goto exit only if ERROR_NO_MORE_ITEMS.
                // This handles ERROR_SUCCESS correctly.
                if (dwError != ERROR_NO_MORE_ITEMS)
                    goto exit;

                // ERROR_NO_MORE_ITEMS: Go to next container
                // and begin enum anew.
                pFind->nIdx++;
                pFind->dwHandle = 0;
            }
            else
            {
                // Getting container failed.
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }
        }
    }

exit:

    UNLOCK_CACHE();

    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA  pInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags)
{
    return FindNextEntry(
                phFind,
                szPrefix,
                (pInfo ? &pInfo : NULL),
                pcbInfo,
                dwFilter,
                GroupId,
                dwFlags,
                0);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CleanupUrls
----------------------------------------------------------------------------*/
DWORD CConMgr::CleanupUrls
    (LPCTSTR szCachePath, DWORD dwFactor, DWORD dwFilter)
{
    DWORD dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    // Bad cleanup parameter.
    if (dwFactor <= 0 || dwFactor > 100)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // For null or empty path, clean up content container.
    if (!szCachePath || !*szCachePath)
    {
        _coContent->CleanupUrls(dwFactor, dwFilter);
    }
    else
    {
        LOCK_CACHE();

        // Find the container with the matching cache path and clean it up.
        for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);

            if (co)
            {
                if (PathPrefixMatch(szCachePath, co->GetCachePath()))
                {
                    UNLOCK_CACHE();
                    co->CleanupUrls(dwFactor, dwFilter); // expensive?
                    LOCK_CACHE();
                    co->Release(TRUE);
                    break;
                }
                co->Release(TRUE);
            }
        }

        UNLOCK_CACHE();
    }

exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInGroup(LPCSTR szUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call GetUrlInGroup on the appropriate container.
        dwError = co->GetUrlInGroup(szUrl, pGroupId, pdwExemptDelta);
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateGroup(dwFlags, pGID);
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateDefaultGroups()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateDefaultGroups()
{
    INET_ASSERT(_coContent); 

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateDefaultGroups();
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();
    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.DeleteGroup(gid, dwFlags);
    }

    UNLOCK_CACHE();

    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextGroup(
      HANDLE*                               phFind,
      DWORD                                 dwFlags,
      GROUPID*                              pGroupId
)
{
    DWORD                      dwError;
    GROUP_FIND_FIRST_HANDLE*   pFind = NULL;
    GroupMgr gm;

    INET_ASSERT(_coContent);
    LOCK_CACHE();


    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // BUGBUG currently only supports SEARCH_ALL option
        if( dwFlags )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }


        // Allocate a handle.
        *phFind = HandleMgr.Alloc (sizeof(GROUP_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);

        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig  = SIG_GROUP_FIND;
        pFind->fFixed = TRUE;
        pFind->nIdx = CONTENT;
        pFind->dwLastItemOffset = 0;
    }
    else
    {
        // Valid handle passed in - map it.
        pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    //
    // The handle is initialized or was created via a previous FindNextEntry.
    //

    dwError = ERROR_FILE_NOT_FOUND;

    // Enum on the container and release.
    if( gm.Init(_coContent) )
    {
        DWORD dwLastItemOffset = pFind->dwLastItemOffset;

        dwError = gm.GetNextGroup(&dwLastItemOffset, pGroupId);

        // update offset field of the find handle
        pFind->dwLastItemOffset = dwLastItemOffset;

    }

exit:

    UNLOCK_CACHE();
    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo,
    LPDWORD                             lpdwGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent) )
    {
        dwError = gm.GetGroup(gid, dwAttrib, lpGroupInfo, lpdwGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::SetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent))
    {
        dwError = gm.SetGroup(gid, dwAttrib, lpGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


DWORD CConMgr::RegisterCacheNotify(
    HWND    hWnd,
    UINT    uMsg,
    GROUPID gid,
    DWORD   dwFilter
    )
{
    DWORD dwError;
    INET_ASSERT(_coContent);
    dwError = _coContent->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);
    return dwError;
}

DWORD CConMgr::SendCacheNotification( DWORD  dwOp)
{
    DWORD dwError;

    INET_ASSERT(_coContent);
    _coContent->SendCacheNotification(dwOp);
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
VOID CConMgr::GetCacheInfo
----------------------------------------------------------------------------*/
VOID CConMgr::GetCacheInfo(LPCSTR szPrefix, LPSTR szCachePath, LONGLONG *cbLimit)
{
    URL_CONTAINER *co;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szPrefix);
    
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call GetCacheInfo on the appropriate container.
        co->GetCacheInfo(szCachePath, cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}



/*-----------------------------------------------------------------------------
VOID CConMgr::SetCacheLimit
----------------------------------------------------------------------------*/
VOID CConMgr::SetCacheLimit(LONGLONG cbLimit, DWORD idx)
{
    URL_CONTAINER *co;
    // Find the associated container.

    UNIX_RETURN_IF_READONLY_CACHE;
    
    LOCK_CACHE();
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call SetCacheLimit on the container.
        co->SetCacheLimit(cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\contain.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Abstract-for-module.

    Contents:

Author:

     16-Nov-1995

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

    16-Nov-1995
        Created

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Container allows any size file. The file is cleanedup at scavneging time
    2) Free 100% uses cleanupallurls, reinitializes memorymappedfile and cleansup
       all directories
    3) CurrentCacheSIze and Cache Limit in the memorymapped file itself
    4) FileCreation time and lastcheckedtime added
    5) friendly naming scheme

    25-Sep-1997

    Ahsan Kabir (akabir) made minor alterations to GetFileSizeAndTimeByName.

--*/

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Contains code that implements CONTAINER classes defined in
    contain.hxx.

Author:

    Madan Appiah (madana)  28-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#include <cache.hxx>

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; INET_ASSERT (IsContentContainer()); \
    IncrementHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif

// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
extern PFNGETFILEATTREX gpfnGetFileAttributesEx;


// private functions
DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    )
/*++

Routine Description:

    Get the size and creation time and file attributes of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    lpFindData : pointer to a WIN32_FIND_DATA structure where the size and time value is
        returned. On WinNT, only the size and time fields are valid.

Return Value:

    Windows Error Code.

--*/
{
    INET_ASSERT(lpFileAttrData != NULL);

    if (gpfnGetFileAttributesEx)
    {
        if(!gpfnGetFileAttributesEx(FileName, GetFileExInfoStandard, (LPVOID)lpFileAttrData))
            return( GetLastError() );
    }
    else
    {
        HANDLE hHandle;
        WIN32_FIND_DATA FindData;

        hHandle = FindFirstFile(FileName, &FindData);
        if( hHandle == INVALID_HANDLE_VALUE ) {
            return( GetLastError() );
        }
        memset(lpFileAttrData, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        lpFileAttrData->dwFileAttributes = FindData.dwFileAttributes;
        lpFileAttrData->nFileSizeLow = FindData.nFileSizeLow;
        lpFileAttrData->nFileSizeHigh = FindData.nFileSizeHigh;
        lpFileAttrData->ftCreationTime = FindData.ftCreationTime;

        FindClose(hHandle);
    }

    return(ERROR_SUCCESS);
}

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    )
/*++

Routine Description:

    Get the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : pointer to a longlong location where the size value is
        returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;

    // get the size of the file being cached.
    //  since we do not handle 4+gb files, we can safely ignore the high dword

    INET_ASSERT(pdwFileSize!=NULL);

    if (gpfnGetFileAttributesEx)
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
        if(!gpfnGetFileAttributesEx(pszFileName, GetFileExInfoStandard, &FileAttrData))
            return( GetLastError() );

        *pdwFileSize = FileAttrData.nFileSizeLow;
    }
    else
    {
        HANDLE hfFileHandle = CreateFile(
                        pszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( hfFileHandle == INVALID_HANDLE_VALUE )
            return(GetLastError());

        *pdwFileSize = GetFileSize( hfFileHandle, NULL);
        if(*pdwFileSize == 0xFFFFFFFF)
            dwError = GetLastError();

        CloseHandle( hfFileHandle );
    }
    return dwError;
}

// -------------------------------URL_CONTAINER----------------------------------- //

/*-----------------------------------------------------------------------------
URL_CONTAINER::URL_CONTAINER Sets path, prefix and limit.
-----------------------------------------------------------------------------*/
URL_CONTAINER::URL_CONTAINER(LPTSTR CacheName, LPTSTR CachePath,
                             LPTSTR CachePrefix, LONGLONG CacheStartUpLimit,
                             DWORD dwOptions)
{
    _fIsInitialized = FALSE;
    _fPerUserItem = TRUE;
    _dwLastReference = GetTickCountWrap();
    _fDeleted = FALSE;
    _fMarked = FALSE;
    _fDeletePending = FALSE;
    _fMustLaunchScavenger = FALSE;
//#ifdef CHECKLOCK_NORMAL
    _dwTaken = 0;
//#endif
    _dwRefCount = 0;
    _dwOptions = dwOptions;
    _dwBytesDownloaded = _dwItemsDownloaded = 0;
    _CacheEntryType = 0;
    _CacheName = NULL;
    _CachePath = NULL;
    _CachePrefix = NULL;


    if (!CachePath || !*CachePath || !CachePrefix || !CacheStartUpLimit)
    {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    _CacheName = NewString(CacheName == NULL ? TEXT(""):CacheName);

    _CachePathLen = strlen(CachePath);

    if (CachePath[_CachePathLen-1] != DIR_SEPARATOR_CHAR)
    {
        _CachePath = CatString(CachePath, DIR_SEPARATOR_STRING);
        _CachePathLen++;
    }
    else
        _CachePath = NewString(CachePath);

    _CachePrefix = NewString(CachePrefix);

    if (!_CachePath || !_CachePrefix || !_CacheName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _CachePrefixLen = strlen(_CachePrefix);

    _CacheStartUpLimit = CacheStartUpLimit;

    _UrlObjStorage = NULL;
    _FileManager = NULL;

    if (!memcmp(_CachePrefix, CONTENT_PREFIX, sizeof(CONTENT_PREFIX)))
        _CacheEntryType = NORMAL_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, COOKIE_PREFIX, sizeof(COOKIE_PREFIX)))
        _CacheEntryType = COOKIE_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, HISTORY_PREFIX, sizeof(HISTORY_PREFIX)))
        _CacheEntryType = URLHISTORY_CACHE_ENTRY;

    _Status = ERROR_SUCCESS;
}


#ifdef CHECKLOCK_PARANOID
void URL_CONTAINER::CheckNoLocks(DWORD dwThreadId)
{
    INET_ASSERT(_dwTaken == 0 || _dwThreadLocked != dwThreadId);
}
#endif

/*-----------------------------------------------------------------------------
URL_CONTAINER::Init
-----------------------------------------------------------------------------*/
DWORD URL_CONTAINER::Init()
{
    _Status = ERROR_SUCCESS;
    _FileMapEntrySize = NORMAL_ENTRY_SIZE;
    MemMapStatus eMMStatus;
    BOOL fMustUnlock = FALSE;
    DWORDLONG dlSize;

    // Generate the mutex name based on the cache path.
    DWORD i;
    LPSTR szPrefix;
    CHAR MutexName[MAX_PATH + 1];
    LPTSTR pCachePath, pMutexName;

    i = 0;
    pCachePath = _CachePath,
    pMutexName = (LPSTR) MutexName;
    while( *pCachePath != '\0'  && (i++ < MAX_PATH))
    {
        if( *pCachePath == DIR_SEPARATOR_CHAR )
            *pMutexName = '!';
        else
            *pMutexName = tolower(*pCachePath);

        pMutexName++;
        pCachePath++;
    }
    *pMutexName = '\0';

    // Open the existing mutex, or if first process, create a new one.
    BOOL fFirstProcess = FALSE;

    _MutexHandle = OpenMutex(SYNCHRONIZE, FALSE, (LPTSTR)MutexName);
    if (_MutexHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _MutexHandle = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, (LPTSTR)MutexName );
        if (_MutexHandle != NULL)
            fFirstProcess = TRUE;
    }

    if (_MutexHandle == NULL)
    {
        _Status = GetLastError();
        goto Cleanup;
    }

    // Lock the container.
    if (!LockContainer(&fMustUnlock))
    {
        if (fMustUnlock) ReleaseMutex(_MutexHandle);
        fMustUnlock = FALSE;
        _Status = GetLastError();
        if (_MutexHandle)
        {
            CloseHandle(_MutexHandle);
            _MutexHandle = NULL;
        }
        goto Cleanup;
    }
    if ((_CachePathLen > 1) && (_CachePath[_CachePathLen-1] != PATH_CONNECT_CHAR))
    {
        lstrcat( _CachePath, PATH_CONNECT_STRING );
        _CachePathLen++;
    }

    // Initialize _ClusterSizeMinusOne and _ClusterSizeMask
    if (!GetDiskInfo(_CachePath, &_ClusterSizeMinusOne, &dlSize, NULL))
    {
        _Status = GetLastError();
        goto Cleanup;
    }
    _ClusterSizeMinusOne--;
    _ClusterSizeMask = ~_ClusterSizeMinusOne;

    // Construct and initialize the memory mapped file object.
    _UrlObjStorage = new MEMMAP_FILE;
    if( _UrlObjStorage == NULL )
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    eMMStatus = _UrlObjStorage->Init(_CachePath, _FileMapEntrySize);

    if((_Status = _UrlObjStorage->GetStatus()) != ERROR_SUCCESS )
        goto Cleanup;

    // for first process attach, we need to clean up the notification
    // hwnd, msg, gid and filter
    if( fFirstProcess && (_CacheEntryType == NORMAL_CACHE_ENTRY ))
    {
        RegisterCacheNotify(0, 0, 0, 0);
    }

    _UrlObjStorage->SetCacheLimit(_CacheStartUpLimit);

    // Construct and initialize the file manager.
    // Cookies and history don't use random subdirs.
    // BUGBUG - move this off to container manager.
    szPrefix = GetCachePrefix();

    if (!strcmp(szPrefix, COOKIE_PREFIX)
        || !strcmp(szPrefix, HISTORY_PREFIX)
        || (_dwOptions & INTERNET_CACHE_CONTAINER_NOSUBDIRS))
    {
        // Insecure cache -no random cache subdirs.
        _FileManager = new CFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }
    else
    {
        // Secure cache - random cache subdirs.
        _FileManager = new CSecFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // If first process to attach, unlock any locked entries.
    if (fFirstProcess)
        UnlockAllItems();

    // If the memory mapped file was reinitialized
    // cleanup old files.
    if (eMMStatus == MEMMAP_STATUS_REINITIALIZED)
        _FileManager->Cleanup();
    else
        eMMStatus = MEMMAP_STATUS_OPENED_EXISTING;

    _fIsInitialized = TRUE;
    if (dlSize <= (DWORDLONG)(4*1024*1024))
    {
        // Yeah, this hurts start-up perf. We also have little room to maneuvre in, so we're going to try anyway.
        CleanupUrls(DEFAULT_CLEANUP_FACTOR, 0);
    }

Cleanup:

    if( _Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "URL_CONTAINER::URL_CONTAINER() failed, %ld\n", _Status ));
        SetLastError(_Status);
    }
    if (fMustUnlock) UnlockContainer();

    if (_Status == ERROR_SUCCESS)
        return (eMMStatus == MEMMAP_STATUS_OPENED_EXISTING ? ERROR_ALREADY_EXISTS : ERROR_SUCCESS);

    return _Status;
}

void URL_CONTAINER::CloseContainerFile()
{

    // Cleanup.
    // _Filemanager holds a pointer to _UrlObjStorage and
    // must be deleted before _UrlObjStorage.
    delete _FileManager;
    delete _UrlObjStorage;

    _FileManager = NULL;
    _UrlObjStorage = NULL;

    if (!_fDeleted)
    {
        // Keep fixed container files from being deleted.
        if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
        {
            _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
            if (_fDeleted) _fDeletePending = FALSE;
        }
    }
}

URL_CONTAINER::~URL_CONTAINER(
    VOID
    )
/*++

Routine Description:

    URL_CONTAINER destructor

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fMustUnlock;

    // If not initialized, only delete path and prefix.
    if (!IsInitialized())
    {
        //  Free pending deleted container, even if someone has
        //  a enum handle open on it.  This is our last chance as we handle process
        //  detach

        LOCK_CACHE();
        TryToUnmap(0xFFFFFFFF);
        UNLOCK_CACHE();

        if(_CacheName) delete _CacheName;
        if(_CachePath) delete _CachePath;
        if(_CachePrefix) delete _CachePrefix;
        return;
    }

    LockContainer(&fMustUnlock);

    // Otherwise, do a full destruct.
    CloseContainerFile();

    if (fMustUnlock) UnlockContainer();

    // Delete mutex.
    if( _MutexHandle != NULL )
        CloseHandle( _MutexHandle );

    if(_CacheName) delete _CacheName;
    if(_CachePath) delete _CachePath;
    if(_CachePrefix) delete _CachePrefix;
}

DWORD URL_CONTAINER::GetOptions()
{
    return _dwOptions;
}

DWORD URL_CONTAINER::GetLastReference()
{
    return _dwLastReference;
}

BOOL URL_CONTAINER::IsVisible()
{
    return !(_fDeletePending || _fDeleted);
}

void URL_CONTAINER::Mark(BOOL fMarked)
{
    _fMarked = fMarked;
}

BOOL URL_CONTAINER::GetMarked()
{
    return _fMarked;
}

BOOL URL_CONTAINER::GetDeleted()
{
    return _fDeleted;
}

void URL_CONTAINER::SetDeleted(BOOL fDeleted)
{
    if (!_fIsInitialized) _fDeleted = fDeleted;
}

BOOL URL_CONTAINER::GetDeletePending()
{
    return _fDeletePending;
}

void URL_CONTAINER::SetDeletePending(BOOL fDeletePending)
{
    _fDeletePending = fDeletePending;
}

void URL_CONTAINER::AddRef()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    _dwRefCount++;
}

void URL_CONTAINER::TryToUnmap(DWORD dwAcceptableRefCount)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    BOOL fMustUnlock;

    if (_dwRefCount <= dwAcceptableRefCount)
    {
        if (_fIsInitialized)
        {
            LockContainer(&fMustUnlock);

            CloseContainerFile();

            if (fMustUnlock) UnlockContainer();

            // Delete mutex.
            if( _MutexHandle != NULL )
            {
                CloseHandle( _MutexHandle );
                _MutexHandle = NULL;
            }
            _fIsInitialized = FALSE;
        }
        else
        {
            if (!_fDeleted)
            {
                //  Never CONTENT, COOKIES or HISTORY container.
                if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
                {
                    if(GlobalUrlContainers)
                    {
                        _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
                        if (_fDeleted) _fDeletePending = FALSE;
                    }
                }
            }
        }
    }
}

DWORD URL_CONTAINER::Release(BOOL fTryToUnmap)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    DWORD dwRefCount = 0;

    INET_ASSERT(_dwRefCount);
    if (_dwRefCount)
    {
        dwRefCount = --_dwRefCount;
        if (fTryToUnmap && _dwRefCount == 0)
        {
            //  Never CONTENT, COOKIES or HISTORY container.
            if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
            {
                if (_fDeletePending)
                {
                    TryToUnmap(0);
                }
            }
        }
    }
    return dwRefCount;
}


BOOL URL_CONTAINER::LockContainer(BOOL *fMustUnlock)
/*++

Routine Description:

    This function waits for the container to be free.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _dwLastReference = GetTickCountWrap();

    *fMustUnlock = FALSE;

    if( _MutexHandle == NULL )
    {
        // Bad mutex handle.
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Container Mutex Handle is NULL.\n" ));
        return FALSE;
    }

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "LockContainer called by thread %x\n", GetCurrentThreadId()));

    //
    // Wait the for the mutex to be signalled.
    //

    DWORD Result;

    #if DBG
        DWORD MutexTimeoutCount;
        MutexTimeoutCount = 0;

    Waitagain:

    #endif

    // Check the mutex.
    #if DBG
        Result = WaitForSingleObject(_MutexHandle, MUTEX_DBG_TIMEOUT);
    #else
        Result = WaitForSingleObject(_MutexHandle, INFINITE);
    #endif

    switch ( Result )
    {
        case WAIT_OBJECT_0:

            // Mutex is signalled (normal result). We now have ownership of the mutex.
            // Do a CheckSizeGrowAndRemapAddress.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                {
                    return (FALSE);
                }
            }
            return TRUE;

    #if DBG
        case WAIT_TIMEOUT:

            // Exceeded debug timeout count. Try again.
            MutexTimeoutCount++;
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait time-out (count = %ld).\n", MutexTimeoutCount ));
            goto Waitagain;
    #endif

        case WAIT_ABANDONED :

            // The thread owning the mutex failed to release it before it terminated.
            // We still get ownership of the mutex.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex ABANDONED.\n" ));
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                    return (FALSE);
            }

            return TRUE;

        case WAIT_FAILED :

            // Failed to obtain mutex.
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait failed (%ld).\n", GetLastError() ));
            return FALSE;

    }

    INET_ASSERT( FALSE );
    return FALSE;
}


VOID URL_CONTAINER::UnlockContainer(VOID)
/*++

Routine Description:

    This function frees the container to be used by someone else.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    BOOL fMustLaunchScavenger = FALSE;

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "UnlockContainer called by thread %x\n", GetCurrentThreadId()));
    _dwLastReference = GetTickCountWrap();

    _dwTaken--;

#ifdef CHECKLOCK_NORMAL
    if( _MutexHandle)
    {
        INET_ASSERT(_dwThreadLocked == GetCurrentThreadId());

        if (_dwTaken == 0)
            _dwThreadLocked = 0;
#endif
        if (_dwTaken == 0)
        {
            fMustLaunchScavenger = _fMustLaunchScavenger;
            _fMustLaunchScavenger = FALSE;
        }
        if (ReleaseMutex( _MutexHandle ) == FALSE )
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "ReleaseMutex failed (%ld).\n", GetLastError() ));
        }

        if (fMustLaunchScavenger)
            LaunchScavenger();

#ifdef CHECKLOCK_NORMAL
    }
#endif
    return;
}

BOOL URL_CONTAINER::UpdateOfflineRedirect
(
    DWORD dwUrlItemOffset, // offset to hash table item of URL entry
    LPCSTR pszUrl,         // URL string
    DWORD cbUrl,           // URL length
    LPCSTR pszRedir        // redirect string
)
/*++
Routine Description:
    Marks a hash table item as allowing a redirect to add trailing slash,
    or creates a new redirect hash table item and memory mapped file entry.

    Addendum: We keep track of redirects in the cache and simulate them when
    offline. Often the redirected URL is the same as the original URL plus
    trailing slash.

WARNING: this function has multiple calls which can grow and remap the
memory map file, invalidating any pointers into the file.  Be careful.

Return Value: TRUE if redirect was cached

--*/

{
    DWORD cbRedir = strlen (pszRedir);
    DWORD dwUrlHash;
    DWORD dwRedirItemOffset;

    // Ignore the redirect URL if same as original URL.
    if (cbRedir == cbUrl && !memcmp(pszUrl, pszRedir, cbRedir))
        return FALSE;

    { // limit scope of pUrlItem

        HASH_ITEM* pUrlItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + dwUrlItemOffset);

        // Special case trailing slash redirect.
        if (   cbRedir + 1 == cbUrl
            && pszUrl [cbRedir] == '/'
            && !memcmp (pszUrl, pszRedir, cbRedir)
           )
        {
            pUrlItem->SetSlash();
            return TRUE;
        }

        // Record high bits of target URL hash value.
        dwUrlHash = pUrlItem->GetValue();
    }

    //
    // BUGBUG: we do not handle the case of redirect that once added a
    // trailing slash to redirect to another URL altogether.  We should
    // scan the entire hash table slot and unset the trailing slash bit
    // if we find a match.
    //

    REDIR_FILEMAP_ENTRY* pEntry;

    { // limit scope of pRedirItem

        HASH_ITEM* pRedirItem = NULL;

        if (HashFindItem (pszRedir, LOOKUP_REDIR_CREATE, &pRedirItem))
        {
            // Found existing redirect entry; update it.
            pEntry = (REDIR_FILEMAP_ENTRY*) HashGetEntry (pRedirItem);
            INET_ASSERT (pEntry->dwSig == SIG_REDIR);
            pEntry->dwHashValue = dwUrlHash;
            pEntry->dwItemOffset = dwUrlItemOffset;
            INET_ASSERT (!lstrcmp (pEntry->szUrl, pszRedir));
            return TRUE;
        }

        if (!pRedirItem)
            return FALSE;

        dwRedirItemOffset = (DWORD) ((LPBYTE) pRedirItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

    // Created new hash table item so allocate a redir entry.
    DWORD cbEntry = sizeof(*pEntry) + cbRedir;
    pEntry = (REDIR_FILEMAP_ENTRY *) _UrlObjStorage->AllocateEntry (cbEntry);

    // Associate entry with hash table item.
    HASH_ITEM *pRedirItem =
        (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwRedirItemOffset);
    if (!pEntry)
    {
        pRedirItem->MarkFree();
        return FALSE;
    }
    HashSetEntry (pRedirItem, (LPBYTE) pEntry);
    pRedirItem->SetRedir();

    // Initialize the redirect entry.
    pEntry->dwSig        = SIG_REDIR;
    pEntry->dwHashValue  = dwUrlHash;
    pEntry->dwItemOffset = dwUrlItemOffset;
    memcpy (pEntry->szUrl, pszRedir, cbRedir + 1);

    return TRUE;
}

LPSTR URL_CONTAINER::GetPrefixMap()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeLabel()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeTitle()
{
    return TEXT("");
}

DWORD URL_CONTAINER::AddIdentityUrl (AddUrlArg* pArgs)
{
    DWORD dwError = ERROR_SUCCESS;
    pArgs->dwEntryType |= IDENTITY_CACHE_ENTRY;

    // Lookup or create a hash item for the 0-URL entry.
    HASH_ITEM *pItem;
    BOOL fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_DONT_FOLLOW, &pItem);

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
        if (pOld && !IsPerUserEntry(pOld))
        {
            DeleteUrlEntry(pOld, pItem, SIG_DELETE);
            fUpdate = FALSE;
        }
    }
    if (!fUpdate)
    {
        DWORD dwIdentity = pArgs->dwIdentity;
        PTSTR pszFilePath = (PTSTR)pArgs->pszFilePath;
        pArgs->pszFilePath = NULL;
        pArgs->dwIdentity = 0;
        
//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Calling AddUrl recursively may be hazardous to your health
// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        dwError = AddUrl(pArgs);
        pArgs->dwIdentity = dwIdentity;            
        pArgs->pszFilePath = pszFilePath;
    }
    else
    {            
        DWORD dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
        DWORD dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }
    
    return dwError;
}


DWORD URL_CONTAINER::AddUrl (AddUrlArg* pArgs)

/*++

Routine Description:

    This member functions adds an URL to the container and moves the
    cache file to cache path.

Arguments:

    UrlName : pointer to an URL string.

    lpszNewFileName : pointer to a cache file (full) name.

    ExpireTime : expire time of the file.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    dwCacheEntryType : type of this new entry.

    HeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    FileExtension : file extension used to create this file.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwReturn;
    BOOL fMustUnlock;
    DWORD dwCurrentOffset;
    DWORD dwUrlNameSize;
    LPTSTR FileName;
    DWORD dwFileNameSize;
    DWORD dwUrlFileExtSize;
    DWORD dwEntrySize;
    FILETIME ftCreate;
    DWORD dwFileSize;
    LONGLONG CacheSize, CacheLimit;
    DWORD dwItemOffset;
    BOOL fUpdate;
    LPURL_FILEMAP_ENTRY NewEntry;
    HASH_ITEM *pItem;
    GROUP_ENTRY* pGroupEntry;
    GroupMgr    gm;
    DWORD dwFileMapEntrySizeAligned;
    BOOL fPlaceAnyRedirect = TRUE;

    if (!LockContainer(&fMustUnlock))
    {
        dwReturn = GetLastError();
        goto exit;
    }

    // If this is an identity-specific entry, we need to setup an identity-0
    // referrer
    if (pArgs->dwIdentity)
    {
        dwReturn = AddIdentityUrl(pArgs);
        if (dwReturn!=ERROR_SUCCESS)
        {
            goto exit;
        }
        fPlaceAnyRedirect = FALSE;
    }
    
    // Calculate dwUrlNameSize.
    dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

    // FileName points to the filename sans cachepath.  Calculate dwFileNameSize.
    if(pArgs->pszFilePath)
    {

        // Is this an absolute path (edited)?
        if (!(pArgs->dwEntryType & EDITED_CACHE_ENTRY))
        // No, so find the last slash in the file name path.
        // This delimits the file name.

        {
            CHAR  *pSlash = NULL,
                  *ptr = (LPSTR) pArgs->pszFilePath;
            while (*ptr)
            {
                if (*ptr == DIR_SEPARATOR_CHAR)
                    pSlash = ptr;

                ptr=CharNext(ptr);
            }
            FileName = pSlash  + 1;
            dwFileNameSize = (DWORD) (ptr - FileName + 1); // 64BIT
        }
        // Have an absolute path so use the full path
        else
        {
            FileName = (char *)pArgs->pszFilePath;
            dwFileNameSize = lstrlen(FileName)+1;
        }
    }
    else
    {
        FileName = NULL;
        dwFileNameSize = 0;
    }

    // Calculate dwUrlFileExtSize
    if (FileName)
    {
        dwUrlFileExtSize =
            (pArgs->pszFileExt? (lstrlen(pArgs->pszFileExt) + 1) : sizeof("txt"));

    }
    else
    {
        dwUrlFileExtSize = 0;
    }

    // Get the file size.
    if (!pArgs->pszFilePath)
        dwFileSize = 0;
    else
    {
        if (!pArgs->dwFileSize)
        {
            WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

            dwReturn = GetFileSizeAndTimeByName(pArgs->pszFilePath, &FileAttrData);
            // If not succeed, return a uniform error.
            if ((ERROR_SUCCESS!=dwReturn) || FileAttrData.nFileSizeHigh) // Accept 0 length files too ...
            {
                // Reject files of length 0 or larger than 4 GB.
                dwReturn = ERROR_INVALID_DATA;
                goto exit;
            }
            dwFileSize = FileAttrData.nFileSizeLow;
            ftCreate = FileAttrData.ftCreationTime;
        }
        else
        {
            dwFileSize = pArgs->dwFileSize;
            ftCreate = pArgs->ftCreate;
        }
    }

    dwReturn = ERROR_SUCCESS;

    { // Open a new block to limit the scope of pointer variables.

        HASH_ITEM *pItem;

        // Lookup or create a hash item for the URL entry.

        fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_CREATE, &pItem);

//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

        if (fUpdate)
        {
            // Check existing entry for refcount.
            URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
            if (pOld->NumReferences)
            {
                dwReturn = ERROR_SHARING_VIOLATION;
                goto exit;
            }

            // Validate the size of data to be copied from existing entry.
            // If the entry version is IE5, the value could be random, so
            // force it to the correct value.  If the value is otherwise
            // bogus, also set it to the IE5 size for safety.
            if (    pOld->bVerCreate == ENTRY_VERSION_IE5
                ||  pOld->CopySize > pOld->nBlocks * NORMAL_ENTRY_SIZE
                ||  pOld->CopySize & 3 // should be dword aligned
               )
            {
                pOld->CopySize = ENTRY_COPYSIZE_IE5;
            }

            dwFileMapEntrySizeAligned = pOld->CopySize;
        }
        else if (!pItem)
        {
            // Item was not found but could not allocate another hash table.
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else // brand new entry
        {
           dwFileMapEntrySizeAligned = ENTRY_COPYSIZE_CURRENT;
        }

        // Save offsets in case the memmap file must be grown and remapped.
        dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

    // Create/update offline redirect as necessary.
    if (pArgs->pszRedirect && fPlaceAnyRedirect)
    {
        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }

    DWORD dwUrlNameSizeAligned;
    DWORD dwFileNameSizeAligned;
    DWORD dwHeaderSizeAligned;
    DWORD dwUrlFileExtSizeAligned;

    // Calculate the total size of the entry, rounding up for alignment.
    dwUrlNameSizeAligned        = ROUNDUPDWORD(dwUrlNameSize);
    dwFileNameSizeAligned       = ROUNDUPDWORD(dwFileNameSize);
    dwHeaderSizeAligned         = (pArgs->pbHeaders) ? ROUNDUPDWORD(pArgs->cbHeaders) : 0;
    dwUrlFileExtSizeAligned     = ROUNDUPDWORD(dwUrlFileExtSize);

    INET_ASSERT (dwFileMapEntrySizeAligned % sizeof(DWORD) == 0);
    INET_ASSERT (sizeof(FILEMAP_ENTRY) % sizeof(DWORD) == 0);
    dwFileMapEntrySizeAligned += sizeof(FILEMAP_ENTRY);

    dwEntrySize =         dwFileMapEntrySizeAligned
                        + dwUrlNameSizeAligned
                        + dwFileNameSizeAligned
                        + dwHeaderSizeAligned
                        + dwUrlFileExtSizeAligned;

    NewEntry = (LPURL_FILEMAP_ENTRY) _UrlObjStorage->AllocateEntry(dwEntrySize);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

    // Restore pointer to hash table item.
    pItem = (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwItemOffset);

    if (!NewEntry)
    {
        if (!fUpdate)
            pItem->MarkFree();
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


/*
    Handle any differences between cache entry versions.

    IE5 inits bVerUpdate to 0 when creating an entry, but incorrectly preserves 
    the value when updating instead of forcing it to 0.  Fortunately IE6 does 
    not care since IE5 will not be able to find an identity-specific entry in 
    order to update it.

    However, we should have a safety hatch for IE7+ to realize that a downlevel 
    urlcache updated its entry and just copied over the opaque data.  Of course 
    the solution will be a total ugly hack.  One possibility is for the uplevel 
    urlcache to set dwUrlNameOffset to be dwCopySizeAligned + 4.  This will 
    leave an uninitialized dword "hole" between the fixed fields and the 4 
    variable size fields.  Once this hack is used, by IE7 for example, it 
    should correctly set bVerUpdate2 so that IE8+ can detect both IE5-6 and IE7 
    updates without creating further holes.
*/

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);

        if ((pOld->dwSig != SIG_URL)
            || (pOld->CopySize > PAGE_SIZE))
        {
            INET_ASSERT(FALSE);
            pItem->MarkFree();
            _UrlObjStorage->FreeEntry(NewEntry);
            dwReturn = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
        
        CopyMemory (((LPBYTE) NewEntry) + sizeof(FILEMAP_ENTRY),
                    ((LPBYTE) pOld) + sizeof(FILEMAP_ENTRY),
                    pOld->CopySize);
        INET_ASSERT (NewEntry->CopySize == pOld->CopySize);
        if (NewEntry->CopySize == ENTRY_COPYSIZE_IE5)
            NewEntry->bVerCreate = ENTRY_VERSION_IE5;
        INET_ASSERT (NewEntry->bVerCreate == pOld->bVerCreate);
    }
    else
    {
        NewEntry->CopySize   = ENTRY_COPYSIZE_CURRENT;
        NewEntry->bVerCreate = ENTRY_VERSION_CURRENT;
        NewEntry->bVerUpdate = ENTRY_VERSION_CURRENT;
    }

    // Invalidate the signature during the update.
    NewEntry->dwSig = 0;

    // We must set entry type, file size, and exempt delta before
    // calling SetExemptDelta.  We leave the sticky bit out of the
    // entry type in case we have no more room for sticky items.
    NewEntry->CacheEntryType = _CacheEntryType
                                | (pArgs->dwEntryType & ~STICKY_CACHE_ENTRY);

    NewEntry->dwFileSize = dwFileSize;

    if (!fUpdate)
    {
        // This is a brand new entry.
        NewEntry->dwGroupOffset = 0;
        NewEntry->NumAccessed   = 1;

        if (pArgs->fImage)
        {
            NewEntry->bSyncState = SYNCSTATE_IMAGE;
            BETA_LOG (SYNCSTATE_IMAGE);
        }
        else
        {
            NewEntry->bSyncState = SYNCSTATE_VOLATILE;
            if (IsContentContainer())
                BETA_LOG (SYNCSTATE_VOLATILE);
        }

        NewEntry->dwExemptDelta = 0;
        if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
            SetExemptDelta (NewEntry, 24 * 60 * 60, dwItemOffset); // one day
    }
    else // if (fUpdate)
    {
        URL_FILEMAP_ENTRY* ExistingEntry = HashGetEntry (pItem);

        // This is an update of an existing entry.
        INET_ASSERT (NewEntry->dwGroupOffset == ExistingEntry->dwGroupOffset);

        NewEntry->NumAccessed++;  // BUGBUG: blowing off wraparound

        if (ExistingEntry->bSyncState == SYNCSTATE_STATIC)
            BETA_LOG (SYNCSTATE_STATIC_VOLATILE);

        NewEntry->bSyncState = SYNCSTATE_VOLATILE;


        if (ExistingEntry->dwExemptDelta ||
            ExistingEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            // If item was previously sticky, it is preserved upon update.
            NewEntry->dwExemptDelta = ExistingEntry->dwExemptDelta;
            INET_ASSERT (ExistingEntry->CacheEntryType | STICKY_CACHE_ENTRY);
            NewEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
        }
        else
        {
            // If the item wasn't previously sticky, it might be made so.
            NewEntry->dwExemptDelta = 0;
            if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
                SetExemptDelta (NewEntry, 24 * 60 * 60 * 1000, dwItemOffset); // one day
        }

        // if belongs to a group, adjust the group usage
        if( ExistingEntry->dwGroupOffset &&
            ExistingEntry->dwFileSize != NewEntry->dwFileSize )
        {
            LONGLONG llDelta = RealFileSize(NewEntry->dwFileSize) -
                               RealFileSize(ExistingEntry->dwFileSize);
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                if( gm.Init(this) )
                {
                    // dwGroupOffset is now offset to head of group list
                    gm.AdjustUsageOnList(ExistingEntry->dwGroupOffset, llDelta);
                }
            }
            else
            {
                // single group
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                    ExistingEntry->dwGroupOffset, pItem);

                // WARNING: quota can be reached by usage increase
                if( pGroupEntry )
                {
                    AdjustGroupUsage(pGroupEntry, llDelta);
                }
            }
        }

        // Delete the old entry if it's not an installed entry or an EDITED_CACHE_ENTRY
        // (Unless the new entry replacing it is also an EDITED_CACHE_ENTRY),
        // either way the hash table item is preserved. We also check the filesize if
        // we've determined the old entry was ECE but the new one is not, just in case
        // the client deletes the file but doesn't get around to deleting from the
        // cache index. The logic is optimized for the most likely case (want to del).
        if ((ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
            && (!(ExistingEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            // IDK=0 ECE=0 NECE=? FS=?
            DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
        }
        else if (ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        {
            // IDK=0 ECE=1 NECE=? FS=?
            if (NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)
            {
                // IDK=0 ECE=1 NECE=1 FS=?
                DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
            }
            else
            {
                // IDK=0 ECE=1 NECE=0 FS=?
                // Only want to go out to the FS to get filesize if absolutely necessary

                WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

                FileAttrData.nFileSizeLow = 0;
                dwReturn = GetFileSizeAndTimeByName(
                    (LPTSTR) OFFSET_TO_POINTER (ExistingEntry, ExistingEntry->InternalFileNameOffset),
                    &FileAttrData);
                if (!FileAttrData.nFileSizeLow)
                {
                    // IDK=0 ECE=1 NECE=0 FS=0 or not-exist
                    // if filesize is zero, might as well trounce it
                    DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
                }
                else if (dwReturn == ERROR_SUCCESS)
                {
                    // IDK=0 ECE=1 NECE=0 FS>0
                    // found a non-zero length file
                    _UrlObjStorage->FreeEntry(NewEntry);
                    pItem->MarkFree();
                    dwReturn = ERROR_SHARING_VIOLATION;
                    goto exit;
                }
            }
        }
        else
        {
            // IDK=1 ECE=? NECE=? FS=?
            // Installed directory item
            _UrlObjStorage->FreeEntry(NewEntry);
            pItem->MarkFree();
            dwReturn = ERROR_SHARING_VIOLATION;
            goto exit;
        }

    } // end else if (fUpdate)

    // Record the new offset in the hash table item.
    HashSetEntry (pItem, (LPBYTE) NewEntry);

    // Initialize NewEntry fields.
    NewEntry->dwRedirHashItemOffset = 0;
    NewEntry->NumReferences        = 0;
    NewEntry->HeaderInfoSize       = pArgs->cbHeaders;
    NewEntry->LastModifiedTime     = pArgs->qwLastMod;
    GetCurrentGmtTime ((FILETIME*) &NewEntry->LastAccessedTime);

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwExpires) ),
        &(NewEntry->dostExpireTime)   );

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwPostCheck) ),
        &(NewEntry->dostPostCheckTime)   );

    // GetDirIndex will fail if the entry is stored at an absolute path outside
    // the cache dir, This is valid for EDITED_CACHE_ENTRYs such as offline
    // Office9 docs. Even tho the call fails in this case, NewEntry->DirIndex
    // will be set to NOT_A_CACHE_SUBDIRECTORY

    DWORD dwIndex;
    if ((!_FileManager->GetDirIndex((LPSTR) pArgs->pszFilePath, &dwIndex))
        && !((pArgs->dwEntryType & EDITED_CACHE_ENTRY)
             || ((pArgs->dwEntryType & IDENTITY_CACHE_ENTRY) && !pArgs->dwIdentity)))
    {
        _UrlObjStorage->FreeEntry(NewEntry);
        pItem->MarkFree();
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    NewEntry->DirIndex = (BYTE) dwIndex;

    // If this entry points to the store directory, set
    // the INSTALLED_CACHE_ENTRY bit so that retrieval
    // from cache will not result in requests to the wire
    // from wininet except for refresh requests.

    if ((NewEntry->DirIndex == INSTALLED_DIRECTORY_KEY) ||
        (pArgs->dwEntryType & EDITED_CACHE_ENTRY))
    {
        NewEntry->CacheEntryType |= INSTALLED_CACHE_ENTRY;
    }

    FileTimeToDosDateTime( (FILETIME *)&(NewEntry->LastAccessedTime),
                           (LPWORD)&(NewEntry->dostLastSyncTime),
                           ((LPWORD)&(NewEntry->dostLastSyncTime)+1));

    // Specify identity.
    NewEntry->dwIdentity = pArgs->dwIdentity;
    if (pArgs->dwIdentity)
    {
        NewEntry->CacheEntryType |= IDENTITY_CACHE_ENTRY;
    }
    
    // The URL_FILEMAP_ENTRY will point to
    //
    // [URL_FILEMAP_ENTRY][UrlName][FileName][HeaderInfo][FileExtension]
    //                    ^        ^         ^           ^
    //                    |        |         |           FileExtensionOffset
    //                    |        |         |
    //                    |        |         HeaderInfoOffset
    //                    |        |
    //                    |        FileNameOffset
    //                    |
    //                    UrlNameOffset
    //


    dwCurrentOffset = dwFileMapEntrySizeAligned;
    NewEntry->UrlNameOffset = dwCurrentOffset;

    // Copy UrlName into NewEntry
    memcpy((LPSTR) OFFSET_TO_POINTER(NewEntry, NewEntry->UrlNameOffset),
        pArgs->pszUrl, dwUrlNameSize);

    dwCurrentOffset += dwUrlNameSizeAligned;

    // Copy FileName into NewEntry
    if(FileName)
    {
        NewEntry->InternalFileNameOffset = dwCurrentOffset;
        memcpy((LPTSTR) OFFSET_TO_POINTER (NewEntry,
            NewEntry->InternalFileNameOffset), FileName, dwFileNameSize);

        // Get file creation time of cache file.
        if (!pArgs->pszFilePath)
            NewEntry->dostFileCreationTime = 0;
        else
        {
            FileTimeToDosDateTime (&ftCreate,
                (LPWORD)&(NewEntry->dostFileCreationTime),
                ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
        }

        dwCurrentOffset += dwFileNameSizeAligned;
    }
    else
    {
        NewEntry->InternalFileNameOffset = 0;
        NewEntry->dostFileCreationTime = 0;
    }

    // Copy HeaderInfo into NewEntry
    if(pArgs->pbHeaders)
    {
        NewEntry->HeaderInfoOffset = dwCurrentOffset;
        memcpy((LPBYTE)NewEntry + NewEntry->HeaderInfoOffset,
            pArgs->pbHeaders, pArgs->cbHeaders);
        dwCurrentOffset += dwHeaderSizeAligned;
    }
    else
    {
        NewEntry->HeaderInfoOffset = 0;
    }

    // Copy FileExtension into NewEntry
    if(pArgs->pszFileExt)
    {
        NewEntry->FileExtensionOffset = dwCurrentOffset;
        memcpy ((LPTSTR) ((LPBYTE)NewEntry + NewEntry->FileExtensionOffset),
            pArgs->pszFileExt, dwUrlFileExtSize);
        dwCurrentOffset += dwUrlFileExtSizeAligned;
    }
    else
    {
        NewEntry->FileExtensionOffset = 0;
    }

    // Restore the signature.
    NewEntry->dwSig = SIG_URL;

    // Increment the FileManager's count
    if (FileName)
    {
        // This is a no-op for the COOKIES and HISTORY containers.
        _FileManager->NotifyCommit(NewEntry->DirIndex);

        // Adjust CacheSize if not an installed entry or stored outside of cache dir.
        // If disk quota is exceeded, initiate cleanup.
        // NOTE: this attempts to take the critical section, so we must defer it
        // until we have released the container mutex to avoid potential deadlock
        if ((NewEntry->DirIndex != INSTALLED_DIRECTORY_KEY) && (!(NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            _dwBytesDownloaded += (DWORD)RealFileSize(dwFileSize);
            _dwItemsDownloaded++;

            _UrlObjStorage->AdjustCacheSize(RealFileSize(dwFileSize));
            CacheSize = _UrlObjStorage->GetCacheSize();
            CacheLimit = _UrlObjStorage->GetCacheLimit();
            if (CacheSize > CacheLimit)
                _fMustLaunchScavenger = TRUE;

            // We also want to scavenge if, even though there's plenty of space available in the
            // cache, the amount of total disk space available falls below a certain threshold.
            // We'll arbitrarily set the threshold to be 4MB (below which, things are likely to get
            // painful.

            if (!_fMustLaunchScavenger && ((_dwBytesDownloaded>(1024*1024)) || (_dwItemsDownloaded>100)))
            {
                DWORDLONG dlSize = 0;

                _dwBytesDownloaded = _dwItemsDownloaded = 0;
                if (GetDiskInfo(_CachePath, NULL, &dlSize, NULL))
                {
                    _fMustLaunchScavenger = (BOOL)(dlSize <= (DWORDLONG)GlobalDiskUsageLowerBound);
                }
            }
        }
    }

    // Flush index if this is an edited document or Cookie to mitigate the risk of dirty shutdown losing changes a client
    // like Office9 might have made (they store edited docs in our cache).

    if (pArgs->dwEntryType & EDITED_CACHE_ENTRY )
    {
        FlushViewOfFile((LPCVOID)NewEntry, dwCurrentOffset);
    }

    if( pArgs->dwEntryType & COOKIE_CACHE_ENTRY )
    {
        FlushViewOfFile( (void*)(*_UrlObjStorage->GetHeapStart()), 0 );
    }


    // Notification
    // If item was previously sticky, it is preserved upon update.
    // only need to report non sticky -> sticky
    if( !fUpdate )
    {
        NotifyCacheChange(CACHE_NOTIFY_ADD_URL, dwItemOffset);
    }
    else
    {
        NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL, dwItemOffset);
    }

exit:

    if (fMustUnlock) UnlockContainer();
    return dwReturn;
}



DWORD URL_CONTAINER::AddLeakFile (LPCSTR pszFilePath)
{
    DWORD dwReturn;

    BOOL fUnlock;
    if (!LockContainer(&fUnlock))
    {
        if(fUnlock)
            ReleaseMutex(_MutexHandle);

        return GetLastError();
    }

    //
    // Calculate the size of the filename, after the last slash.
    //

    LPSTR pszSlash = NULL;
    LPSTR pszScan = (LPSTR) pszFilePath;
    while (*pszScan)
    {
        if (*pszScan == DIR_SEPARATOR_CHAR)
            pszSlash = pszScan;

        pszScan = CharNext(pszScan);
    }
    LPSTR pszFileName = pszSlash + 1;
    DWORD cbFileName = (DWORD) (pszScan - pszFileName + 1); // 64BIT

    //
    // Determine the directory bucket.
    //

    DWORD nDirIndex;
    if (!_FileManager->GetDirIndex((LPSTR) pszFilePath, &nDirIndex))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the file size and create time.
    //

    WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
    dwReturn = GetFileSizeAndTimeByName (pszFilePath, &FileAttrData);
    if (!FileAttrData.nFileSizeLow || FileAttrData.nFileSizeHigh)
    {
        // Reject files of length 0 or larger than 4 GB.
        dwReturn = ERROR_INVALID_DATA;
        goto exit;
    }

    //
    // Allocate a leaked file entry.
    //

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////


    URL_FILEMAP_ENTRY* NewEntry;
    NewEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->AllocateEntry
        (sizeof(URL_FILEMAP_ENTRY) + cbFileName);
    if (!NewEntry)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////


    //
    // Fill only the fields important to WalkLeakList method.
    //

    NewEntry->dwSig = SIG_LEAK;
    NewEntry->dwFileSize = FileAttrData.nFileSizeLow;
    NewEntry->InternalFileNameOffset = sizeof(URL_FILEMAP_ENTRY);
    memcpy ((LPBYTE) (NewEntry + 1), pszFileName, cbFileName);
    NewEntry->DirIndex = (BYTE) nDirIndex;
    FileTimeToDosDateTime( &FileAttrData.ftCreationTime,
                           (LPWORD)&(NewEntry->dostFileCreationTime),
                           ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
    NewEntry->NumReferences = 0;

    //
    // Add this entry on to the head of the scavenger leak list.
    //
    _UrlObjStorage->GetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &NewEntry->dwNextLeak);
    _UrlObjStorage->SetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
         OffsetFromPointer (NewEntry));

    //
    // Update the cache usage and directory count.
    //

    _UrlObjStorage->AdjustCacheSize(RealFileSize(NewEntry->dwFileSize));
    _FileManager->NotifyCommit(NewEntry->DirIndex);

    //
    // We could check here if usage exceeds quota then launch scavenger,
    // but it will probably happen soon enough anyway upon AddUrl.
    //

    dwReturn = ERROR_SUCCESS;

exit:
    if (fUnlock)
        UnlockContainer();

    return dwReturn;
}

DWORD URL_CONTAINER::RetrieveUrl
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppInfo,
    LPDWORD pcbInfo,
    DWORD dwLookupFlags, // e.g. redirect
    DWORD dwRetrievalFlags
)

/*++

Routine Description:

    This member function retrives an url from the cache. The url is marked
    as referenced, so that caller should call UnlockUrl when he is done
    using it.

Arguments:

    UrlName : pointer to the url name.

    ppInfo :  ptr to ptr to an entry info buffer, where the url entry info
        is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
        above buffer, on return it has the size of the buffer consumed or
        size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find the item.
    HASH_ITEM *pItem;

    if (!HashFindItem (UrlName, dwLookupFlags, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Get the hash entry.
    UrlEntry = HashGetEntry (pItem);
    if (UrlEntry->InternalFileNameOffset == 0)
    {
        Error = ERROR_INVALID_DATA;
        goto exit;
    }
    
    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = TRUE; IsCorrectUser() = %s \r\n",
            (IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))? "TRUE" : "FALSE"
            ));

        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }
    else
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = FALSE\r\n"));
    }
    // Hide sparse cache entries from non-wininet clients.

    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
            && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Found the entry. Copy URL info in the return buffer first.
    Error = CopyUrlInfoGuard( UrlEntry, ppInfo, pcbInfo, dwRetrievalFlags );
    if( Error != ERROR_SUCCESS )
        goto Cleanup;

    if ((*ppInfo)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // Delete the item and entry but not the file.
        UrlEntry->InternalFileNameOffset = 0;
        DeleteUrlEntry (UrlEntry, pItem, SIG_DELETE);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    // Verify the file size is what it is supposed to be.
    if (dwRetrievalFlags & RETRIEVE_WITH_CHECKS)
    {
        DWORD dwFileSize;
        Error = GetFileSizeByName
            ((LPCSTR)((*ppInfo)->lpszLocalFileName), &dwFileSize);
        if (Error != ERROR_SUCCESS)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if (dwFileSize != UrlEntry->dwFileSize)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }
    }

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount++;

    // Increment the reference count before returning.
    if (UrlEntry->NumReferences)
    {
        if( !pItem->IsLocked() )
        {
            //
            // corrupted index file
            // entry says it's locked, hash table say it's not
            // believe the hash table by fixing up the entry
            //
            INET_ASSERT (FALSE);
            UrlEntry->NumReferences = 0;
        }
    }
    else
        pItem->SetLocked();

    UrlEntry->NumReferences++;

    // Update last accessed time.
    GetCurrentGmtTime ((FILETIME*) &UrlEntry->LastAccessedTime);
 
    // And the number of times this was accessed
    UrlEntry->NumAccessed++;

Cleanup:

    if (Error != ERROR_SUCCESS)
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "RetrieveUrl call failed, %ld.\n",
            Error ));
        SetLastError(Error);
    }
exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


DWORD URL_CONTAINER::DeleteUrl(LPCSTR  UrlName)
/*++

Routine Description:

    This member function deletes the specified url from the cache.

Arguments:

    UrlName : pointer to the url name.

Return Value:

    Windows Error Code.

--*/
{
    BOOL fMustUnlock;
    DWORD Error;
    URL_FILEMAP_ENTRY *pEntry;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find (and validate) the entry.
    if (!HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    pEntry = HashGetEntry(pItem);

    // Delete the hash table item and entry from the index.
    Error = DeleteUrlEntry (pEntry, pItem, SIG_DELETE);

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "DeleteUrl: RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    // Notify
    NotifyCacheChange(
        CACHE_NOTIFY_DELETE_URL,
        (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
    );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


/*++
Routine Description:
    This member functions deletes an URL from the container and also
    deletes the cache file from cache path.

    dwSig - if we must put an uplevel entry on the async fixup list,
       this param distinguishes between updates and deletions.

Return Value:
    Windows Error Code.
--*/

DWORD URL_CONTAINER::DeleteUrlEntry
    (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM *pItem, DWORD dwSig)
{
    INET_ASSERT (pItem? dwSig == SIG_DELETE : dwSig == SIG_UPDATE);

    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Error;
    GROUP_ENTRY* pGroupEntry = NULL;
    GroupMgr     gm;

    // Check for locked entry.
    if (pEntry->NumReferences)
    {
        // Mark the entry for pending delete.
        pEntry->CacheEntryType |= PENDING_DELETE_CACHE_ENTRY;
        Error = ERROR_SHARING_VIOLATION;
        goto Cleanup;
    }

    // If the entry version is beyond our understanding...
    if (pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK)
    {
        INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));

        pEntry->dwSig = dwSig; // mark as either updated or deleted

        // Add entry to head of fixup list.
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET, &pEntry->dwNextLeak);
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET,
             OffsetFromPointer (pEntry));

        // Increment count of items on fixup list, maybe trigger fixup.
        DWORD dwCount, dwTrigger;
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, &dwCount);
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_TRIGGER, &dwTrigger);
        if (++dwCount > dwTrigger)
            _fMustLaunchScavenger = TRUE;
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, dwCount);

        goto delete_hash_item;
    }

    // If group associated, Adjust Group's disk Usage
    // if pItem == NULL, we should perserve all the group info
    if( pEntry->dwGroupOffset && pItem )
    {
        if( pItem->HasMultiGroup() )
        {
            // multiple group
            if( gm.Init(this) )
            {
                // dwGroupOffset now offset to head of group list
                gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
            }
        }
        else
        {
            // single group
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);

            if( pGroupEntry )
            {
                AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize) );
            }
        }
    }

    // Delete any associated file.
    if (pEntry->InternalFileNameOffset
        && (pEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        && (!(pEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
    {
        // Reduce the exempt usage for sticky item (could be an update)
        if ( pEntry->dwExemptDelta ||
             (pEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));

        // Get the absolute path to the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];
        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            && _FileManager->DeleteOneCachedFile
            (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));
            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // Link the entry at the head of leaked files list.
            INET_ASSERT(pEntry->NumReferences==0);

            pEntry->dwSig = SIG_LEAK;
            _UrlObjStorage->GetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &pEntry->dwNextLeak);
            _UrlObjStorage->SetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                 OffsetFromPointer (pEntry));
        }
    }
    else
    {
        // NOTE: In the case that the entry is in a store (INSTALLED_DIRECTORY_KEY)
        // we do allow the cache entry to be deleted, but we do NOT allow the associated
        // file to be deleted. This at least allows us to delete these entries from
        // the cache without affecting their (permanent) backing store files.

        _UrlObjStorage->FreeEntry(pEntry);
    }

delete_hash_item:

    // Delete this item from the hash table.
    if (pItem)
        pItem->MarkFree();

    Error = ERROR_SUCCESS;

Cleanup:

    TcpsvcsDbgPrint ((DEBUG_ERRORS,
        "URL_CONTAINER::DeleteUrlEntry() returning %ld\n", Error));
    return Error;
}


DWORD URL_CONTAINER::UnlockUrl(LPCSTR UrlName)
/*++

Routine Description:

    This member function unreferences the url entry, so that it can be
    freed up when used no one.

Arguments:

    Url : pointer to an URL name.

Return Value:

    Windows Error Code.

--*/
 {
    DWORD Error;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    HASH_ITEM* pItem;
    URL_FILEMAP_ENTRY* pEntry;

    // Look up the entry.
    if (HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
        pEntry = HashGetEntry (pItem);
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    UnlockItem (pEntry, pItem);

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount--;
    Error = ERROR_SUCCESS;

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

DWORD URL_CONTAINER::GetUrlInfo
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppUrlInfo,
    LPDWORD UrlInfoLength,
    DWORD dwLookupFlags,
    DWORD dwEntryFlags,
    DWORD dwRetrievalFlags
)
/*++

Routine Description:

    This member function retrieves the url info.

Arguments:

    UrlName : name of the url file (unused now).

    ppUrlInfo : pointer to the pointer to the url info structure that receives the url
        info.

    UrlInfoLength : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwLookupFlags: flags, e.g. translate through redirects

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY UrlEntry;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Look up the entry.
    UrlEntry = HashFindEntry (UrlName, dwLookupFlags);
    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }

    // Hide sparse cache entries from non-wininet clients.
    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
        && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Find only installed entry types.
    if ((dwEntryFlags & INTERNET_CACHE_FLAG_INSTALLED_ENTRY)
        && (!(UrlEntry->CacheEntryType & INSTALLED_CACHE_ENTRY)))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if (UrlInfoLength)
    {
        if (!ppUrlInfo || !*ppUrlInfo)
            *UrlInfoLength = 0;

       Error = CopyUrlInfoGuard( UrlEntry, ppUrlInfo, UrlInfoLength,
                            (dwEntryFlags & INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY ?
                                RETRIEVE_ONLY_FILENAME : 0) |
                            (dwEntryFlags & INTERNET_CACHE_FLAG_GET_STRUCT_ONLY ? 
                                RETRIEVE_ONLY_STRUCT_INFO : 0) |
                            dwRetrievalFlags);
    }
    else
       Error = ERROR_SUCCESS;

exit:
   if (fMustUnlock) UnlockContainer();
   return( Error );
}


DWORD URL_CONTAINER::SetExemptDelta
    (URL_FILEMAP_ENTRY* UrlEntry, DWORD dwExemptDelta, DWORD dwItemOffset)
{
    // Expanded history calls with STICKY_CACHE_ENTRY for no good reason.
    // INET_ASSERT (UrlEntry->FileSize);

    DWORD dwError = ERROR_SUCCESS;

    if (dwExemptDelta)
    {
        if (!UrlEntry->dwExemptDelta)
        {
            // Entry is changing from non-exempt to exempt.
            // (exempt limit check should be done at UpdateStickness
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_SET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }
    else // if (!dwExemptDelta)
    {
        if (UrlEntry->dwExemptDelta)
        {
            // Entry is changing from exempt to non-exempt.
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_UNSET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }

    UrlEntry->dwExemptDelta = dwExemptDelta;
End:
    return dwError;
}



DWORD URL_CONTAINER::SetUrlInfo(LPCSTR UrlName,
                                LPCACHE_ENTRY_INFO UrlInfo, DWORD FieldControl)
/*++

Routine Description:

Arguments:

    UrlName : name of the url file (unused now).

    UrlInfo : pointer to the url info structure that has the url info to
        be set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    // Look up the entry.
    if (HashFindItem (UrlName, 0, &pItem))
    {
        UrlEntry = HashGetEntry (pItem);
    }
    else
    {
        UrlEntry = NULL;
    }

    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // Set cache entry ATTRIBUTE.
    if(FieldControl & CACHE_ENTRY_ATTRIBUTE_FC)
    {
        // We must preserve IDENTITY_CACHE_ENTRY bits, if they set
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType 
                                   | (UrlEntry->CacheEntryType & IDENTITY_CACHE_ENTRY);
    }
    
    // Reset cache entry HITRATE.
    if(FieldControl & CACHE_ENTRY_HITRATE_FC)
        UrlEntry->NumAccessed = UrlInfo->dwHitRate;

    // Set last modified time.
    if(FieldControl & CACHE_ENTRY_MODTIME_FC)
         UrlEntry->LastModifiedTime = FT2LL(UrlInfo->LastModifiedTime);

    // Set expire time.
    if( FieldControl & CACHE_ENTRY_EXPTIME_FC)
    {
        FileTime2DosTime(UrlInfo->ExpireTime, &(UrlEntry->dostExpireTime) );
    }

    // Set last access time.
    if(FieldControl & CACHE_ENTRY_ACCTIME_FC)
        UrlEntry->LastAccessedTime = FT2LL(UrlInfo->LastAccessTime);

    // Set last sync time.
    if(FieldControl & CACHE_ENTRY_SYNCTIME_FC)
    {
        FileTimeToDosDateTime( &(UrlInfo->LastSyncTime),
                                (LPWORD)&(UrlEntry->dostLastSyncTime),
                               ((LPWORD)&(UrlEntry->dostLastSyncTime)+1));

        if (   UrlEntry->bSyncState != SYNCSTATE_VOLATILE
            && UrlEntry->bSyncState < SYNCSTATE_STATIC)
        {
            // See if we should transition to SYNCSTATE_STATIC.
            if (UrlEntry->bSyncState == SYNCSTATE_IMAGE)
            {
                // We have not had the image long enough to
                // conclude it is static.  See if it is older
                // than MIN_AGESYNC.

                LONGLONG qwCreate;
                INET_ASSERT (UrlEntry->dostFileCreationTime);
                DosDateTimeToFileTime(
                    * (LPWORD)&(UrlEntry->dostFileCreationTime),
                    *((LPWORD)&(UrlEntry->dostFileCreationTime)+1),
                    (FILETIME*) &qwCreate);

                if (FT2LL(UrlInfo->LastSyncTime) > qwCreate + MIN_AGESYNC)
                {
                    UrlEntry->bSyncState++;
                }
            }
            else
            {
                if (++UrlEntry->bSyncState == SYNCSTATE_STATIC)
                    BETA_LOG (SYNCSTATE_IMAGE_STATIC);
            }

        }
    }

    if (FieldControl & CACHE_ENTRY_TYPE_FC)
    {
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType;
    }
    
    // Set exemption delta.
    if (FieldControl & CACHE_ENTRY_EXEMPT_DELTA_FC)
    {
        Error = SetExemptDelta (
            UrlEntry,
            UrlInfo->dwExemptDelta,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

        if (Error != ERROR_SUCCESS)
            goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Adds or removes a URL from a group.  If adding, may set exemption time.
--*/
DWORD URL_CONTAINER::SetUrlGroup (LPCSTR lpszUrl, DWORD dwFlags, GROUPID GroupId)
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY pEntry;
    GROUP_ENTRY* pGroupEntry = NULL;
    GROUP_ENTRY* pOldGroupEntry = NULL;
    GROUPID      gid = 0;
    HASH_ITEM    *pItem = NULL;
    GroupMgr gm;

    if (dwFlags & INTERNET_CACHE_GROUP_NONE)
        return ERROR_SUCCESS;

    if (!GroupId)
        return ERROR_INVALID_PARAMETER;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    //
    // HashFindEntry will do the same thing, however, we need pItem
    // here so that we can set/clear the group bit
    //
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if( !gm.Init(this) )
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;
    }

    if (dwFlags & INTERNET_CACHE_GROUP_REMOVE)
    {
        // offset to GROUP_ENTRY*
        DWORD dwGEOffset = 0;

        // find the group via GroupOffset
        if( !pEntry->dwGroupOffset )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Get GroupEntry Offset
        if( pItem->HasMultiGroup() )
        {
            // multiple group, get from list
            Error = gm.GetOffsetFromList(
                pEntry->dwGroupOffset, GroupId, &dwGEOffset);
            if( Error != ERROR_SUCCESS )
                goto exit;
        }
        else
        {
            dwGEOffset = pEntry->dwGroupOffset;
        }

        // get group entry from the offset
        pGroupEntry = _UrlObjStorage->ValidateGroupOffset(dwGEOffset, pItem);

        if( !pGroupEntry )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Remove the group from list
        if( pItem->HasMultiGroup() )
        {
            // remove it from list
            DWORD dwNewHeaderOffset = pEntry->dwGroupOffset;

            Error = gm.RemoveFromGroupList(
                pEntry->dwGroupOffset, dwGEOffset, &dwNewHeaderOffset );

            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            //
            // header may have been changed (if head is the one we want)
            // newHeaderOffset = 0 means last group has been removed
            //
            // NOTE: even we may have one item left on the list, we
            //       are not changing the multiGroup flag on this
            //       entry, so the dwGroupOffset are still points to
            //       the list
            pEntry->dwGroupOffset = dwNewHeaderOffset;

        }
        else
        {
            // set offset to 0 (single group)
            pEntry->dwGroupOffset = 0;

        }

        // if dwExamptDelta is set, we should leave the stick bit
        if(!pEntry->dwExemptDelta)
        {
            //
            // if the unassociated group is sticky, we are remove
            // the sticky bit of this url
            //
            // For multiple groups, we will have to make sure all
            // the remaining groups are non-sticky
            //

            if( IsStickyGroup(pGroupEntry->gid ) &&
                ( !pItem->HasMultiGroup()  ||
                  gm.NoMoreStickyEntryOnList(pEntry->dwGroupOffset) )
            )
            {
                Error = UpdateStickness(
                    pEntry,
                    URLCACHE_OP_UNSET_STICKY,
                    (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
                );
                if( Error != ERROR_SUCCESS )
                    goto exit;
            }
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize));
        }

        //
        // update hash bit indicating no group associate with this url
        // we won't clear the multiple group flag even if there is single
        // group left on the group list.
        //
        if( !pEntry->dwGroupOffset )
        {
            pItem->ClearGroup();
            pItem->ClearMultGroup();
        }

    }
    else
    {

        // Find Group via gid
        Error = gm.FindEntry(GroupId, &pGroupEntry, FALSE);
        if( Error != ERROR_SUCCESS )
        {
            goto exit;
        }

        if( pItem->HasGroup() )
        {
            // multiple group

            LPBYTE  lpBase;
            DWORD dwGroupEntryOffset = 0;

            lpBase = *_UrlObjStorage->GetHeapStart();
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            DWORD dwListEntryOffset = 0;
            DWORD dwEntryOffset = 0;
            DWORD dwItemOffset = 0;
            DWORD dwOldGroupEntryOffset = 0;

            if( !pItem->HasMultiGroup() )
            {
                //
                // switch from a single group to multiple
                // group, need to
                //  1) create a new group list
                //  2) add the existing single group to the newly created list
                //


//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                //
                // get a new List (memfile may grown)
                //
                Error = gm.CreateNewGroupList(&dwListEntryOffset);
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                // restore pointers based on (possible) new base addr
                lpBase = *_UrlObjStorage->GetHeapStart();

                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

                //
                // add the original group (whose offset is indicated
                // with dwGroupOffset of the url entry)
                // to the newly created list
                //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                Error = gm.AddToGroupList(
                        dwListEntryOffset, pEntry->dwGroupOffset);

                // restore offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }


                
//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                //
                // the dwGroupOffset of the url entry now
                // points the the head of a group list
                //
                pEntry->dwGroupOffset = dwListEntryOffset;
                pItem->MarkMultGroup();

            }

            //
            // Multiple group, just add the new group to the list
            //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
            // save offset
            lpBase = *_UrlObjStorage->GetHeapStart();
            dwEntryOffset = PtrDiff32(pEntry, lpBase);
            dwItemOffset = PtrDiff32(pItem, lpBase);
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            Error = gm.AddToGroupList(
                pEntry->dwGroupOffset, dwGroupEntryOffset);


            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            // remap since multiple group may cause memfile grow
            lpBase = *_UrlObjStorage->GetHeapStart();
            pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
            pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
            pItem = (HASH_ITEM*) (lpBase + dwItemOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
        }
        else
        {
            // single group, dwGroupOffset points the real group
            pEntry->dwGroupOffset = PtrDiff32(pGroupEntry, *_UrlObjStorage->GetHeapStart());
        }



        // update hash bit indicating group associate with this url
        pItem->MarkGroup();

        // if group is sticky, mark the entry to sticky as well
        if( IsStickyGroup(pGroupEntry->gid) )
        {
            Error = UpdateStickness(
                pEntry,
                URLCACHE_OP_SET_STICKY,
                (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
            );
            if( Error != ERROR_SUCCESS )
                goto exit;
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, RealFileSize(pEntry->dwFileSize) );
        }

        //
        // track the usage and quota
        // NOTE: we still allow this url to be added to the group
        //       even if usage > quota, DISK_FULL error will be
        //       returned, so the client is responsible to take
        //       futher action
        //
        if( pGroupEntry->llDiskUsage > (pGroupEntry->dwDiskQuota * 1024) )
        {
            Error = ERROR_NOT_ENOUGH_QUOTA;
            goto  exit;
        }
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Gets group ID and exemption time for a particular URL.
--*/
DWORD URL_CONTAINER::GetUrlInGroup
    (LPCSTR lpszUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    DWORD dwError;
    BOOL fMustUnlock;
    URL_FILEMAP_ENTRY* pEntry;
    GROUP_ENTRY*       pGroupEntry = NULL;
    HASH_ITEM*          pItem = NULL;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }


    // Look up the entry.
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
        dwError = ERROR_FILE_NOT_FOUND;
    else
    {
        if( pEntry->dwGroupOffset )
        {
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);
            if( pGroupEntry )
            {

                INET_ASSERT(pGroupEntry->gid);
                *((LONGLONG*) pGroupId) = pGroupEntry->gid;
            }
            else
            {
                dwError = ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            *((LONGLONG*) pGroupId) = 0;
        }

        *pdwExemptDelta = pEntry->dwExemptDelta;
        dwError = ERROR_SUCCESS;
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}


DWORD URL_CONTAINER::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedSize,
                                   LPCSTR lpszFileExtension, LPTSTR FileName,
                                   HANDLE *phfHandle, BOOL fCreatePerUser)
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    UrlName : name of the url file (unused now).

    ExpectedSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileExtension: extension for the filename created

    FileName : pointer to a buffer that receives the full path name of the
        the temp file.

    phfHandle : pointer to a handle that receives the handle of the file
        being create; pass null if we don't care (the file will be closed).

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;

    // BUGBUG - adding LockContainer here.
    if (!LockContainer(&fMustUnlock))
    {
        Error = (GetLastError());
        goto exit;
    }

    Error = _FileManager->CreateUniqueFile((LPSTR) UrlName, (LPSTR) FileName,
        (LPSTR) lpszFileExtension, (HANDLE*) phfHandle, (BOOL)fCreatePerUser);

exit:
    if (fMustUnlock) UnlockContainer();
    return( Error );
}



DWORD URL_CONTAINER::FindNextEntry
    (LPDWORD lpdwEnum, LPCACHE_ENTRY_INFO *ppCEI, LPDWORD lpdwCEI, DWORD dwFilter, GROUPID GroupId, DWORD dwFlags, DWORD dwRetrievalFlags)
{

    DWORD Error;
    URL_FILEMAP_ENTRY* pEntry;
    DWORD dwEnumSave;
    BOOL fMustUnlock;
    DWORD dwCopyFlags;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    BOOL fCheckUser;
    fCheckUser = IsContentContainer() && !(dwFilter & OTHER_USER_CACHE_ENTRY);
    dwCopyFlags = 0;
    if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO)
    {
        dwCopyFlags = RETRIEVE_ONLY_STRUCT_INFO;
    }
    else if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME)
    {
        dwCopyFlags = RETRIEVE_ONLY_FILENAME;
    }
    dwCopyFlags |= dwRetrievalFlags;
    while (1)
    {
        dwEnumSave = *lpdwEnum;
        pEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->FindNextEntry(lpdwEnum, dwFilter, GroupId);

        if(!pEntry)
        {
            Error = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        // For content container, skip items marked for another user.
        if (fCheckUser)
        {
            LPSTR pszHeaders = ((LPSTR) pEntry) + pEntry->HeaderInfoOffset;
            if (!IsCorrectUser(pszHeaders, pEntry->HeaderInfoSize))
                continue;
        }

        // Copy the data
        Error = CopyUrlInfoGuard(pEntry, ppCEI, lpdwCEI, dwCopyFlags);
        switch (Error)
        {
            case ERROR_INSUFFICIENT_BUFFER:
                // Restore current enum position.
                *lpdwEnum = dwEnumSave;
                goto Cleanup;

            case ERROR_FILE_NOT_FOUND:
                continue;

            default:
                INET_ASSERT (FALSE);
            // intentional fall through
            case ERROR_SUCCESS:
                goto Cleanup;
        }
    } // end while(1)

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}



/*------------------------------------------------------------------------------
    CopyUrlInfo

Routine Description:

    Copy URL info data from an URL_FILEMAP_ENTRY in the memory mapped file
    to CACHE_ENTRY_INFO output buffer. If the buffer given is sufficient,
    it returns ERROR_INSUFFICIENT_BUFFER, and pcbInfo will contain
    buffer size required.

Arguments:

    pEntry     : pointer to the source of the URL info.

    ppInfo   : ptr to ptr to an entry info buffer, where the url entry info
               is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
               above buffer, on return it has the size of the buffer consumed or
               size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

------------------------------------------------------------------------------*/
DWORD URL_CONTAINER::CopyUrlInfo(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD cbRequired;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSourceUrlName;
    DWORD cbLocalFileName;
    DWORD cbHeaderInfo;
    DWORD cbFileExt;

    INET_ASSERT(!((dwFlags & RETRIEVE_WITH_ALLOCATION) &&
                  (dwFlags & RETRIEVE_ONLY_FILENAME
                    || dwFlags & RETRIEVE_ONLY_STRUCT_INFO)));
    // Check signature
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Verify url string exists.
    if (!pEntry->UrlNameOffset)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Hate using goto's but, don't want to clutter anymore than I have to.
    // We assume that anything functions that pass these flags will have allocated
    // enough memory before hand.
    if ((dwFlags & RETRIEVE_ONLY_FILENAME) || (dwFlags & RETRIEVE_ONLY_STRUCT_INFO))
    {
        if (ppInfo && *ppInfo)
        {
            memset(*ppInfo, 0, sizeof(INTERNET_CACHE_ENTRY_INFO));
        }
        goto ShortCircuit;
    }

    // -----------------  Calculate embedded data sizes ------------------------
    // All byte counts are sizes.

    // SourceUrlName length;
    cbSourceUrlName = strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset)) + 1;

    // LocalFileName length.
    if(pEntry->InternalFileNameOffset)
    {
        cbLocalFileName =
            _FileManager->GetDirLen(pEntry->DirIndex)
            + strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset))
            + 1;
    }
    else
        cbLocalFileName = 0;

    // HeaderInfo length.
    cbHeaderInfo = (pEntry->HeaderInfoOffset) ? pEntry->HeaderInfoSize + 1 : 0;

    // File extension length.
    if (pEntry->FileExtensionOffset)
    {
        cbFileExt =
              strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset)) + 1;
    }
    else
        cbFileExt = 0;

    // Alignment - these quantities are already aligned in
    // URL_FILEMAP_ENTRY and should be reflected in its size.
    cbSourceUrlName  = ROUNDUPDWORD(cbSourceUrlName);
    cbLocalFileName  = ROUNDUPDWORD(cbLocalFileName);
    cbHeaderInfo     = ROUNDUPDWORD(cbHeaderInfo);
    cbFileExt        = ROUNDUPDWORD(cbFileExt);

    cbRequired = *pcbInfo;
    *pcbInfo = sizeof(CACHE_ENTRY_INFO)
                   + cbSourceUrlName
                   + cbLocalFileName
                   + cbHeaderInfo
                   + cbFileExt;

    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are allocating entry info, use the ex version.
        *pcbInfo += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
        *ppInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbInfo);
        if (!*ppInfo)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        // Second check for required buffer size.
        if (cbRequired < *pcbInfo )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
    }

    // ----------------------  Copy embedded data --------------------------------

    // A Typical CACHE_ENTRY_INFO will look like
    //
    // [CACHE_ENTRY_INFO][UrlName][FileName][Headers][FileExtension]
    //
    //                   ^        ^         ^        ^
    //                   |        |         |        |
    //                   |        |         |        lpszFileExtension
    //                   |        |         |
    //                   |        |         lpHeaderInfo
    //                   |        |
    //                   |        lpszLocalFileName
    //                   |
    //                   lpszSourceUrlName
    //

    // Pointer walks through CACHE_ENTRY_INFO appended data.
    LPBYTE pCur;
    pCur = (LPBYTE) *ppInfo + sizeof(CACHE_ENTRY_INFO);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are creating the -ex version, skip over those fields.
        pCur += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
    }

    // UrlName.
    memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset), cbSourceUrlName);
    (*ppInfo)->lpszSourceUrlName = (LPSTR) pCur;
    pCur += cbSourceUrlName;

    // FileName
    if (cbLocalFileName)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) pCur, &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        
        (*ppInfo)->lpszLocalFileName = (LPTSTR) pCur;
        pCur += cbLocalFileName;
    }
    else
        (*ppInfo)->lpszLocalFileName = NULL;


    // HeaderInfo
    if (cbHeaderInfo)
    {
        memcpy (pCur, OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset),
            pEntry->HeaderInfoSize);
        pCur[pEntry->HeaderInfoSize] = 0;
        (*ppInfo)->lpHeaderInfo = (LPTSTR)pCur;
        pCur += cbHeaderInfo;
    }
    else
        (*ppInfo)->lpHeaderInfo = NULL;


    // FileExt
    if (cbFileExt)
    {
        memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset), cbFileExt);
        (*ppInfo)->lpszFileExtension = (LPTSTR) pCur;
        pCur += cbFileExt;
    }
    else
        (*ppInfo)->lpszFileExtension = NULL;


    // ------------  Set remaining CACHE_ENTRY_INFO members -------------
ShortCircuit:
    // Struct size, entry type, use count and hit rate.
    (*ppInfo)->dwStructSize = URL_CACHE_VERSION_NUM;
    (*ppInfo)->CacheEntryType = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
    if (pEntry->bSyncState == SYNCSTATE_STATIC)
        (*ppInfo)->CacheEntryType |= STATIC_CACHE_ENTRY;
    (*ppInfo)->dwUseCount     = pEntry->NumReferences;
    (*ppInfo)->dwHitRate      = pEntry->NumAccessed;

    // File size.
    (*ppInfo)->dwSizeLow      = pEntry->dwFileSize;
    (*ppInfo)->dwSizeHigh     = 0;

    // Last modified, expire, last access and last sync times, maybe download time.
    (*ppInfo)->LastModifiedTime   = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    // expire time may be 0

    DosTime2FileTime(pEntry->dostExpireTime, &((*ppInfo)->ExpireTime));

    (*ppInfo)->LastAccessTime     = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        CACHE_ENTRY_INFOEX* pCEI = (CACHE_ENTRY_INFOEX*) *ppInfo;
        DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostFileCreationTime),
                             *((LPWORD)&(pEntry->dostFileCreationTime)+1),
                             &pCEI->ftDownload);

        DosTime2FileTime(pEntry->dostPostCheckTime, &pCEI->ftPostCheck);

    }

    DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostLastSyncTime),
                          *((LPWORD)&(pEntry->dostLastSyncTime)+1),
                          &((*ppInfo)->LastSyncTime));


    // Header info size and exempt delta.
    (*ppInfo)->dwHeaderInfoSize   = pEntry->HeaderInfoSize;
    (*ppInfo)->dwExemptDelta      = pEntry->dwExemptDelta;

    // If we want only struct info and filename, we'll assume that we've preallocated
    // enough memory.
    if (dwFlags & RETRIEVE_ONLY_FILENAME)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO),
            &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        (*ppInfo)->lpszLocalFileName = (LPTSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO);
    }

exit:
    return dwError;
}


// CopyUrlInfoGuard puts an exception handler around CopyUrlInfo
// for those case when we don't get a chance to flush the memory-mapped
// file, thus corrupting the cache.

// We put the try in this function, rather than in CopyUrlInfo, to
// avoid affecting the perf characteristics.
DWORD URL_CONTAINER::CopyUrlInfoGuard(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD dwError;
    
    __try
    {
        dwError = CopyUrlInfo(pEntry, ppInfo, pcbInfo, dwFlags);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
    }
    ENDEXCEPT
    return dwError;
}


void URL_CONTAINER::UnlockItem (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM* pItem)
{
    // Possibly a bogus assert due to using lazy-write mappings?
    //INET_ASSERT (pEntry->NumReferences);


    if (pEntry->NumReferences)
    {
        if (--pEntry->NumReferences)
        {
            if( !pItem->IsLocked() )
            {
                // corrupted index file, we have to believe the hash table
                // to fixup the cache entry
                INET_ASSERT (FALSE);
                pEntry->NumReferences = 0;
            }
        }
        else
        {
            pItem->ClearLocked();

            // If the item is marked for pending delete, do it now.
            if (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)
                DeleteUrlEntry (pEntry, pItem, SIG_DELETE);
        }
    }
}


void URL_CONTAINER::UnlockAllItems (void)
{
    DWORD dwEnum = *(_UrlObjStorage->GetPtrToHashTableOffset());

    // Enumerate hash table items.
    while (dwEnum)
    {
        HASH_ITEM *pItem = HashGetNextItem
            (_UrlObjStorage, *(_UrlObjStorage->GetHeapStart()), &dwEnum, 0);

        if (pItem && (pItem->IsLocked()))
        {
            // Validate and unlock the entry.
            URL_FILEMAP_ENTRY *pEntry =
                _UrlObjStorage->ValidateUrlOffset (pItem->dwOffset);
            if (!pEntry)
                pItem->MarkFree(); // invalid item
            else
            {
                // Clear the lockcount.
                pEntry->NumReferences = 1;
                UnlockItem (pEntry, pItem);
            }
        }
    }
}


DWORD URL_CONTAINER::RegisterCacheNotify( HWND      hWnd,
                                          UINT      uMsg,
                                          GROUPID   gid,
                                          DWORD     dwFilter)
{
    BOOL fUnlock;
    LockContainer(&fUnlock);

    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_HWND,    GuardedCast((DWORD_PTR)hWnd));
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_MESG,    (DWORD)uMsg);
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER,  (DWORD)dwFilter);

    if (fUnlock) UnlockContainer();

    return ERROR_SUCCESS;
}


// update stickness will do:
//      1. flip the bit
//      2. update the exempt usage
//      3. send notification
DWORD URL_CONTAINER::UpdateStickness( URL_FILEMAP_ENTRY* pEntry,
                                      DWORD              dwOp,
                                      DWORD              dwItemOffset)
{
    DWORD dwError = ERROR_SUCCESS;

    if( dwOp == URLCACHE_OP_SET_STICKY )
    {
        if( !( pEntry->CacheEntryType & STICKY_CACHE_ENTRY ) )
        {
            // Ensure that exempt items do not crowd the cache.
            LONGLONG FileUsage = RealFileSize(pEntry->dwFileSize);
            LONGLONG ExemptUsage = _UrlObjStorage->GetExemptUsage();
            LONGLONG CacheLimit  = _UrlObjStorage->GetCacheLimit();
            LONGLONG MaxExempt = (CacheLimit * MAX_EXEMPT_PERCENTAGE) / 100;
            if (ExemptUsage + FileUsage > MaxExempt)
                return ERROR_DISK_FULL;

            pEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_SET_STICKY, dwItemOffset);
        }
    }

    else
    if( dwOp == URLCACHE_OP_UNSET_STICKY )
    {
        if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            pEntry->CacheEntryType &= ~STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_UNSET_STICKY, dwItemOffset);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}

VOID FileTime2DosTime(FILETIME ft, DWORD* pdt)
{
    INET_ASSERT(pdt);

    *pdt = 0;
    if( FT2LL(ft) != LONGLONG_ZERO )
    {
        if( FT2LL(ft) == MAX_FILETIME)
        {
            *pdt = MAX_DOSTIME;
        }
        else
        {
            FileTimeToDosDateTime(
                &ft,
                ((LPWORD)(pdt)    ),
                ((LPWORD)(pdt) + 1)
            );
        }
    }
}

VOID DosTime2FileTime(DWORD dt, FILETIME* pft)
{
    INET_ASSERT(pft);

    LONGLONG llZero = LONGLONG_ZERO;
    LONGLONG llMax = MAX_FILETIME;
    if( dt )
    {
        if( dt == MAX_DOSTIME )
        {
            *pft = *LONGLONG_TO_FILETIME(&llMax);
        }
        else
        {
            DosDateTimeToFileTime(
                *((LPWORD)&(dt)    ),
                *((LPWORD)&(dt) + 1),
                pft
            );
        }
    }
    else
    {
        *pft = *LONGLONG_TO_FILETIME(&llZero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\conlist.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conlist.cxx

Abstract:

    Linked list of URL_CONTAINERs
    
Author:
    Adriaan Canter (adriaanc) 04-02-97
    
--*/

#include <cache.hxx>

/*------------------------ CConElem -----------------------------------------*/

/*-----------------------------------------------------------------------------
CConElem constructor
  ---------------------------------------------------------------------------*/
CConElem::CConElem(URL_CONTAINER* pUrlCon)
{
    _pUrlCon = pUrlCon;
    _pNext = NULL;
}

/*-----------------------------------------------------------------------------
CConElem destructor. Destructs URL_CONTAINER* member.
  ---------------------------------------------------------------------------*/
CConElem::~CConElem()
{
    delete _pUrlCon;
}


/*------------------------ CConList Private Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList::Seek      Sets current pointer to element of index nElem.
  ---------------------------------------------------------------------------*/
BOOL CConList::Seek(DWORD nElem)
{   
    // Bad list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Seek to element from current.
    if (nElem > _nCur)        
    {
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

//
// BUGBUG: VC5 optimizer assumes if (a < b), then (b > a), so check (a != b) instead
//
    else if (nElem != _nCur) // if (nElem < _nCur)
    {
        // Seek to element from head.
        _nCur = 0;
        _pCur = _pHead;
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

    INET_ASSERT(_nCur != 0 || (_pCur == _pHead));

    return TRUE;
}


/*------------------------ CConList Public Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList constructor.
  ---------------------------------------------------------------------------*/
CConList::CConList()
: _n(0), _nCur(0), _pCur(NULL), _pHead(NULL)
{
}

/*-----------------------------------------------------------------------------
CConList destructor.
  ---------------------------------------------------------------------------*/
CConList::~CConList()
{
}

/*-----------------------------------------------------------------------------
CConList::Size      Returns number of elements in list.
  ---------------------------------------------------------------------------*/
DWORD CConList::Size()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD n = (_pHead ? _n+1 : 0);
    return n;
}

/*-----------------------------------------------------------------------------
CConList::Free      Removes and destructs each element in list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Free()
{
    LOCK_CACHE();

    DWORD i = Size();

    //  Delete CONTENT last, as we reference fields of it's header (dwChangeCount)
    //  in destructors of extensible containers
    while (i)
    {
        Remove(--i);
    }
    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
CConList::Add      Appends new element to list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Add(URL_CONTAINER * pUrlCon)
{
    LOCK_CACHE();
    BOOL bSuccess = FALSE;
    CConElem *pNew;
    DWORD i;
    
    // Bad pointer.
    if (!pUrlCon)
    {
        INET_ASSERT(FALSE);
        goto exit;        
    }

    if (_pHead)
    {
        //  try to reuse a Container which has been deleted
        for (i = 0; i <= _n; i++)
        {
            if (Seek(i))
            {
                if (_pCur->_pUrlCon->GetDeleted())
                {
                    delete _pCur->_pUrlCon;
                    _pCur->_pUrlCon = pUrlCon;
                    bSuccess = TRUE;
                    goto exit;
                }
            }
        }
    }

    // Construct new element.
    pNew = new CConElem(pUrlCon);

    if (!pNew)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // If valid list, seek to last element and add element.
    if (_pHead)
    {
        if (_n == LARGEST_INDEX)
        {
            delete pNew;
            INET_ASSERT(FALSE);
            goto exit;        
        }
        Seek(_n);
        _pCur->_pNext = pNew;
        pNew->_pNext = _pHead;
        _n++;
    }
    // If empty list, set head and current to new element.
    else
    {
        _pHead = _pCur = pNew;
        pNew->_pNext = _pHead;
        _n = _nCur = 0;
    }
    
    bSuccess = TRUE;
exit:
    
    UNLOCK_CACHE();
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::Remove      Removes nElem'th element from list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Remove(DWORD nElem)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD     nPrev;
    CConElem *pElem;
    BOOL bSuccess = FALSE;

    // Empty list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // Seek to previous element, or last if removing head.
    nPrev = (nElem == 0 ? _n : nElem - 1);
    Seek(nPrev);

    // Save pointer to element, update prevous' next pointer.
    pElem = _pCur->_pNext;
    _pCur->_pNext = _pCur->_pNext->_pNext;

    // Update head if necessary.
    if (nElem == 0)
        _pHead = _pHead->_pNext;

    // Decrement index of last, zero out values if empty.
    if (_n > 0)
        _n--;
    else
    {
        _pHead = _pCur = NULL;
        _n = _nCur = 0;
    }    
    
    // Destruct element.
    delete pElem;
    
    bSuccess = TRUE;
exit:
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::operator Get Returns Addref'ed reference to URL_CONTAINER* of index nElem.
  ---------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
URL_CONTAINER* CConList::Get (DWORD nElem)
{
    URL_CONTAINER* pUrlCon;
    if (Seek(nElem))
        pUrlCon = _pCur->_pUrlCon;
    else
        pUrlCon = NULL;
        
    if (pUrlCon) pUrlCon->AddRef();
    return pUrlCon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\cookies.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  cookies.cxx

Abstract:

  Cookie upgrade object implementation

  Upgrades cookies to new format by parsing existing cookies
  files and adding them to the newly created cookie cache index.

  Currently upgrades v3.2 to v4.0.


Author:
    Adriaan Canter (adriaanc) 01-Nov-1996.

Modification history:
    Ahsan Kabir (akabir) 25-Sep-1997 made a few minor alterations.
-------------------------------------------------------------------------------*/
#include <cache.hxx>

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory

  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    DWORD dwError;
    REGISTRY_OBJ roCookiePath(HKEY_LOCAL_MACHINE, IE3_COOKIES_PATH_KEY);
    DWORD cbKeyLen = MAX_PATH;

    if ((dwError=roCookiePath.GetStatus())==ERROR_SUCCESS)
    {
        dwError = roCookiePath.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szCookiesDirectory,  &cbKeyLen);
    }

    return dwError;

}
/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;

    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokEx(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokEx(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokEx(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokEx(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokEx(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokEx(&ptr, "\n");
        pszLastTimeLow    = StrTokEx(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokEx(&ptr, "\n");
        pszDelimiter      = StrTokEx(&ptr, "\n");      // Delimiter should be "*"


        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            TcpsvcsDbgAssert(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);

        pszNextCookie = pszDelimiter+2;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TcpsvcsDbgAssert(FALSE);
        pszNextCookie = 0;
        goto exit;
    }
    ENDEXCEPT

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(URL_CONTAINER *UrlContainer)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szOldMemMapFilePath     [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];

    CHAR               *pszHash, *ptr,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE *abCacheEntryInfoBuffer = NULL;
    LPCACHE_ENTRY_INFO pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer = 2 * PAGE_SIZE;
    DWORD dwDIR_SEP_STRING = strlen(DIR_SEPARATOR_STRING);
    DWORD dwLen;
    REGISTRY_OBJ roCachePath(HKEY_CURRENT_USER, OLD_CACHE_KEY);
    DWORD cbKeyLen = MAX_PATH;

    szBuffer = 0;

    abCacheEntryInfoBuffer = new BYTE[cbCacheEntryInfoBuffer];
    if (abCacheEntryInfoBuffer == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    __try
    {

        if (!UrlContainer)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        TCHAR szSigKey[MAX_PATH];
        
        // Check to see if we are upgrading cookies
        // from local machine to per user.
        // If IE4's signature isn't present, then we'll guess that IE3 might have been.
        if (UrlContainer->IsPerUserItem()
            &&
            ((roCachePath.GetStatus()!=ERROR_SUCCESS)
             ||  
             (roCachePath.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cbKeyLen)!=ERROR_SUCCESS)))
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            dwLen = strlen(szHKLMCookiesPath) +
                    strlen(szUserName) +
                    dwDIR_SEP_STRING   +
                    7;        // strlen("@*.txt" + '\0';

            if( dwLen > MAX_PATH )
            {
                dwError =  ERROR_INSUFFICIENT_BUFFER;
                goto exit;
            }

            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, DIR_SEPARATOR_STRING);
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");

            // Enumerate the users cache files
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // One or more cookie files exist.
                do
                {
                    // Construct absolute path from HKLM to cookies file.
                    dwLen = strlen(szHKLMCookiesPath) +
                            strlen(FindData.cFileName) +
                            dwDIR_SEP_STRING +
                            1;
                    if( dwLen > MAX_PATH )
                    {
                        dwError =  ERROR_INSUFFICIENT_BUFFER;
                        goto exit;
                    }
                    strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                    strcat(szHKLMCookieFileName, DIR_SEPARATOR_STRING);
                    strcat(szHKLMCookieFileName, FindData.cFileName);

                    // Construct absolute path from HKCU to cookies file.
                    dwLen = strlen(UrlContainer->GetCachePath()) +
                            strlen(FindData.cFileName) +
                            1;
    
                    // We should rescue as many cookies as we can.
                    if( dwLen <= MAX_PATH )
                    {
                        strcpy(szHKCUCookieFileName, UrlContainer->GetCachePath());
                        strcat(szHKCUCookieFileName, FindData.cFileName);
                        // Move the file to the per-user directory.
                        CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);
                    }
                } while (FindNextFile(hFind, &FindData));

                // Close the Find handle.
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    FindClose(hFind);
                    hFind = INVALID_HANDLE_VALUE;
                }
            } // Per-user upgrade.
        }

        // No per-user upgrade. szCookieFileNamePattern will look like
        // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
        dwLen = strlen(UrlContainer->GetCachePath()) + 8;        // strlen("*@*.txt" + '\0';

        if( dwLen > MAX_PATH )
        {
            dwError =  ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
        strcpy(szCookieFileNamePattern, UrlContainer->GetCachePath());
        strcat(szCookieFileNamePattern, "*@*.txt");

        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            dwLen = strlen(UrlContainer->GetCachePath()) +
                    strlen(FindData.cFileName) +
                    1;
            if( dwLen > MAX_PATH )
            {
                continue;
            }

            strcpy(szCookieFileName, UrlContainer->GetCachePath());
            strcat(szCookieFileName, FindData.cFileName);

            // Get the WIN32_FILE_ATTRIBUTE for the call to AddUrl
            // This wrapper works for Win95 and WinNT.

            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );

            // File handle must be valid.
            TcpsvcsDbgAssert(hFile != INVALID_HANDLE_VALUE);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? ->
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                TcpsvcsDbgAssert(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie,
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);

                        ptr = strstr(szCookieName, "@");

                        // Downcase the username portion of the file.
                        CHAR* tptr = ptr;
                        while (*--tptr != ':')
                            *tptr = tolower(*tptr);

                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (LPCACHE_ENTRY_INFO) abCacheEntryInfoBuffer;

                        dwError = UrlContainer->GetUrlInfo(szCookieName, &pCacheEntryInfo,
                            &cbCacheEntryInfoBuffer, 0, 0, 0);

#ifndef UNIX
                        if (dwError == ERROR_SUCCESS
                            && CompareFileTime(pCacheEntryInfo->LastModifiedTime, ftLast) > 0)
#else
                        /* There is a problem with multiple cookies in a single
                         * cookie file. When adding the second cookie, we will
                         * try to delete the existing cookie (the first one that
                         * was added), and thus try to delete the cookie file
                         * itself. But, deletion of the cookie file will fail on
                         * Win32 because the file is already open above for
                         * parsing. On Unix, the deletion will succeed.
                         * So, the work-around is to not add the second cookie
                         * which is from the same site. The entry will remain
                         * in the cookie file anyway.
                         */
                        if (dwError == ERROR_SUCCESS)
#endif /* UNIX */
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or
                            // it was found and the last modified time on it is
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.

                            // Add it to the cookie container.
                            // BUGBUG - besides assert, what to do if this fails?

                            AddUrlArg Args;
                            memset(&Args, 0, sizeof(Args));
                            Args.pszUrl      = szCookieName;  // user@foobar.com
                            Args.pszFilePath = szCookieFileName; // c:\winnt\cookies\user@foobar.txt
                            Args.qwExpires   = FT2LL(ftExpire); // Expire time.
                            Args.qwLastMod   = FT2LL(ftLast); // Last modified time.
                            Args.dwEntryType |= COOKIE_CACHE_ENTRY;
                            dwError = UrlContainer->AddUrl(&Args);

                            TcpsvcsDbgAssert(dwError == ERROR_SUCCESS);
                        }

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.

        } while (FindNextFile(hFind, &FindData));


        // No more cookie files or an error occured.
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);


    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        TcpsvcsDbgAssert(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
    }

    ENDEXCEPT

Cleanup:

    if (abCacheEntryInfoBuffer)
        delete [] abCacheEntryInfoBuffer;

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\filemap.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    filemap.cxx

Abstract:

    contains implementation of MEMMAP_FILE class.

Author:

    Madan Appiah (madana)  28-April-1995

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of (7/6/96)

    1) Fix crossproces problems on win95 in checksizegrowandremap
    2) Exception handling to deal with badsector being memorymapped
    3) More robust validation at init time
    4) Reinitialization code to really clear the cache
    5) Bug fixes in GrowMap while growing partially filled dword

--*/

#include <cache.hxx>


#define FILE_SIZE_MAX_DIGITS 16


DWORD
ValidateAndCreatePath(
    LPTSTR PathName
    )
{
    DWORD Error, len;
    DWORD FileAttribute;
    LPTSTR PathDelimit;

    //
    // check to see the path specified is there.
    //

    FileAttribute = GetFileAttributes( PathName );

    if( FileAttribute != 0xFFFFFFFF ) {

        //
        // check to see the attribute says it is a dir.
        //

        if( !(FileAttribute & FILE_ATTRIBUTE_DIRECTORY) ) {
            
            return( ERROR_INVALID_PARAMETER );
        }

        // We found the file and it is a dir.
        // Set the system attribute just in case
        // it has been unset.
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( (Error != ERROR_FILE_NOT_FOUND) &&
        (Error != ERROR_PATH_NOT_FOUND) ) {

        return( Error );
    }

    //
    // we did not find the path, so create it.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( Error != ERROR_PATH_NOT_FOUND ) {

        return( Error );
    }

    //
    // sub-path is not found, create it first.
    //

    len = lstrlen( PathName );

    if (len < 5) {

        SetLastError(ERROR_INVALID_NAME);

        return (ERROR_INVALID_NAME);
    }

    PathDelimit = PathName + len -1 ;

    // step back from the trailing backslash

    if( *PathDelimit == PATH_CONNECT_CHAR ) {
        PathDelimit--;
    }

    //
    // find the last path delimiter.
    //

    while( PathDelimit >  PathName ) {
        if( *PathDelimit == PATH_CONNECT_CHAR ) {
            break;
        }

        PathDelimit--;
    }

    if( PathDelimit == PathName ) {
        return( ERROR_INVALID_PARAMETER );
    }

    *PathDelimit = TEXT('\0');

    //
    // validate sub-path now.
    //

    Error = ValidateAndCreatePath( PathName ) ;

    //
    // replace the connect char anyway.
    //

    *PathDelimit = PATH_CONNECT_CHAR;

    if( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // try to create one more time.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //

        return( ERROR_SUCCESS );
    }

    Error = GetLastError();
    return( Error );
}


DWORD
MEMMAP_FILE::CheckSizeGrowAndRemapAddress(
    VOID
    )
{
    DWORD dwNewFileSize;

#ifdef WIN95_BUG
    if( _FileSize == (dwNewFileSize = _HeaderInfo->FileSize )) {
        return( ERROR_SUCCESS );
    }
#endif //WIN95_BUG

    // ideally we would have liked to do as in the above two lines
    // this works right on NT but doesn't on win95.

    // This is because the filesize is a part of the mapname
    // In the initial state the index file size is 8192. So the
    // memorymap name is c:_windows_temporaray internet files_8192.
    // Both the processes have this map in their address space.
    // Process B starts pumping in the data, and at some point the index
    // file needs to be grown. Process B, increases the index file to 16384,
    // updates the filesize in the header "while it is still mapped in the
    // map corresponding to the old filesize" and then remaps to the new map
    // with the name c:_windows_temporaray internet files_16384.
    // Any subsequent growth is now recorded in this map.
    // The old map c:_windows_temporaray internet files_8192 still has only
    // the first transition.


    // the work around is to actually get the filesize from the filesystem
    // This works correctly on win95 and NT both. Optimally, we would
    // check for a transition and then get the real size, but we will do that
    // after IE30 ships.



    //NB!!!!!!! The check below is the basis of our cross process
    // cache. All APIs finally make this call before touching the memory
    // mapped file. If there is a chneg, they remap it to the new size
    // with the sizename as part of the mapping, so they get the latest
    // stuff.
    // When anyone gets here, they are protected by a crossprocess mutex


    if( _FileSize == (dwNewFileSize = GetFileSize(_FileHandle, NULL))) {
        return( ERROR_SUCCESS );
    }

    //
    // so other user of the memmap file has increased the file size,
    // let's remap our address space so that the new portion is
    // visible to us too.
    //

    DWORD Error;
    DWORD OldFileSize;
    DWORD OldNumBitMapDWords;

   //
   // set our internal file size and num bit map entries.
   //

    OldFileSize = _FileSize;
    OldNumBitMapDWords = _NumBitMapDWords;


    _FileSize = dwNewFileSize;

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        //
        // reset the file size.
        //

        _FileSize = OldFileSize;
        _NumBitMapDWords = OldNumBitMapDWords;
    }
    else {

#if INET_DEBUG
        if ((GetFileSize(_FileHandle, NULL)) != (_HeaderInfo->FileSize)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);

        }
#endif //INET_DEBG

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

    return( Error );
}

BOOL
MEMMAP_FILE::ValidateCache(
    VOID
    )
/*++

    This private member function validates the cache file content.

Arguments:

    NONE.

Return Value:

    TRUE - if the cache is valid.
     FALSE - otherwise.

--*/
{
    BOOL ReturnCode = FALSE;
    int i, k;
    DWORD BitPosition, TotalAlloced, MaxAllocedPosition, RunningCounter;


    __try {

        // validate signatue.
        if( memcmp(
                _HeaderInfo->FileSignature,
                CACHE_SIGNATURE,
                MAX_SIG_SIZE * sizeof(TCHAR) ) != 0 ) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "File signature does not match.\n" ));
            goto Cleanup;
        }

        // Also check the index does not contain entries with a higher
        // version than the current machine can handle.  This can happen
        // due to Windows kludgy concept of roaming, which replicates 
        // parts of the file system and registry hkcu.
        
        LPSTR pszHighVer = (LPSTR) (_HeaderInfo->dwHeaderData
            + CACHE_HEADER_DATA_HIGH_VERSION_STRING);
        if (pszHighVer[0] != 'V' || pszHighVer[3] != 0)
            memset (pszHighVer, 0, sizeof(DWORD));
        else if (!g_szFixup[0] || strcmp (g_szFixup, pszHighVer) < 0)
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Cannot handle uplevel index file.\n" ));
            goto Cleanup;
        }

        // check the hash table root offset is valid
        if( _HeaderInfo->dwHashTableOffset != 0 ) {

            if( _HeaderInfo->dwHashTableOffset > _FileSize ) {
                TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "invalid b-tree root offset.\n" ));
                goto Cleanup;
            }
        }

        // check file size.
        if( _HeaderInfo->FileSize != _FileSize ) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "invalid file size.\n" ));
            goto Cleanup;
        }

        // one more file size check.
        DWORD ExpectedFileSize;
        ExpectedFileSize =
            HEADER_ENTRY_SIZE +
                _HeaderInfo->NumUrlInternalEntries * _EntrySize;

        // cell the size to GlobalMapFileGrowSize.
        if( ExpectedFileSize % GlobalMapFileGrowSize ) {
                ExpectedFileSize =
                ((ExpectedFileSize /  GlobalMapFileGrowSize) + 1) *
                        GlobalMapFileGrowSize;
        }

        if( _FileSize != ExpectedFileSize ) {

            // it is ok if the file size is one block bigger.
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid file size.\n" ));
            goto Cleanup;
        }


        if(_HeaderInfo->NumUrlInternalEntries < _HeaderInfo->NumUrlEntriesAlloced) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc entires.\n" ));
            goto Cleanup;
        }


        TotalAlloced = 0;
        MaxAllocedPosition = 0;
        RunningCounter = 0;

        // scan the enire bitmap and do some consistency check for allocated bits

        for(i=0; i<BIT_MAP_ARRAY_SIZE; ++i) {
            // k goes from 0 to 31
            // BitPosition goes from 0x00000001 to 0x80000000

            for(BitPosition=1, k=0; k<NUM_BITS_IN_DWORD; ++k, BitPosition <<=1) {

                ++RunningCounter;
                if(_HeaderInfo->AllocationBitMap[i] & BitPosition) {

                    ++TotalAlloced;

                    MaxAllocedPosition = RunningCounter;

                }

            }
        }

        // if the max allocated bit is greter than the number of
        // possible entries for this filesize,
        // or the total allocated bits are greater (the above condition subsumes
        // this one, but it is OK to be paranoid)
        // or totalbits alloced don't match the count
        // there this header is not OK

        if ((MaxAllocedPosition > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced != _HeaderInfo->NumUrlEntriesAlloced)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc bitmap\n" ));
            goto Cleanup;

        }
        //
        // every thing is fine.
        //

        ReturnCode = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        ReturnCode = FALSE;

        _Status = ERROR_WRITE_FAULT;
    }
    ENDEXCEPT

Cleanup:

    if( ReturnCode == FALSE ) {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE, "Invalid Cache, or bad disk\n" ));
    }

    return( ReturnCode );
}

void MEMMAP_FILE::CloseMapping (void)
{
    if (_BaseAddr) // view
    {
        UnmapViewOfFile(_BaseAddr);
        _BaseAddr = NULL;
    }
    if (_FileMappingHandle) // mapping
    {
        CloseHandle (_FileMappingHandle);
        _FileMappingHandle = NULL;
    }
    if (_FileHandle) // file
    {
        CloseHandle (_FileHandle);
        _FileHandle = NULL;
    }
}


DWORD
MEMMAP_FILE::RemapAddress(
    VOID
    )
/*++

    This private member function remaps the memory mapped file just after
    the file size has been modified.

    Container must be locked when this function is called.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PVOID OldBaseAddr;
    DWORD OldViewSize;
    PVOID VirtualBase;
    BOOL BoolError;
    LPTSTR MapName = NULL;

    CloseMapping();
    
    //
    // Create/Open memory mapped file.
    //

    _FileHandle =
        CreateFile(
            _FileName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
                // share this file with others while it is being used.
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_FLAG_RANDOM_ACCESS,
            NULL );


    if( _FileHandle ==  INVALID_HANDLE_VALUE ) {

        Error = _Status = GetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:File open failed, %ld.\n",_Status));

        TcpsvcsDbgAssert( FALSE );

        _FileHandle = NULL;
        goto Cleanup;
    }


#ifndef unix
    /*******
     * UNIX:
     *       Mainwin does not support MapName in CreateFileMapping API
     *       Let us leave the MapName as NULL till this functionality
     *       is available.
     */

    //
    // make a map name.
    //

    DWORD MapNameSize;

    MapNameSize =
        (lstrlen(_FullPathName) +
            lstrlen( _FileName) +
                1 +
                FILE_SIZE_MAX_DIGITS ) * sizeof(TCHAR) ;

    MapName = (LPTSTR) CacheHeap->Alloc( MapNameSize );

    if( MapName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memcpy(MapName, _FileName, _FullPathNameLen + sizeof(MEMMAP_FILE_NAME));
    memcpy(MapName + _FullPathNameLen + sizeof(MEMMAP_FILE_NAME) - 1, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    wsprintf(MapName + lstrlen(MapName), "%u", _FileSize);

#ifndef unix
#define BACKSLASH_CHAR          TEXT('\\')
#else
#define BACKSLASH_CHAR          TEXT('/')
#endif /* unix */
#define UNDERSCORE_CHAR         TEXT('_')
#define TERMINATING_CHAR        TEXT('\0')

    LPTSTR ScanMapName;

    //
    // Replace '\' with '_'.
    //

    ScanMapName = MapName;

    while( *ScanMapName != TERMINATING_CHAR ) {

        if( *ScanMapName == BACKSLASH_CHAR ) {
            *ScanMapName = UNDERSCORE_CHAR;
        }

        ScanMapName++;
    }
#endif /* !unix */



    //
    // re-create memory mapping.
    //
    _FileMappingHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, MapName);

    if (_FileMappingHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _FileMappingHandle =
            CreateFileMapping(
                _FileHandle,
                CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
                PAGE_READWRITE,
                0, // high dword of max memory mapped file size.
    #if defined(UNIX) && defined(ux10)
                1024 * 1024, // map entire file.
    #else
                0, // map entire file.
    #endif
                MapName);
    }

    if( _FileMappingHandle == NULL ) {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    //
    // remap view region.
    //

    _BaseAddr =
        MapViewOfFileEx(
            _FileMappingHandle,
            FILE_MAP_WRITE,
            0,
            0,
#if defined(UNIX) && defined(ux10)
            1024 * 1024,   // MAP entire file.
#else
            0,   // MAP entire file.
#endif
            NULL );

#if defined(UNIX) && defined(ux10)
    DWORD FilePointer = SetFilePointer(
                            _FileHandle,
                            _FileSize,
                            NULL,
                            FILE_BEGIN );
    if (FilePointer == 0xFFFFFFFF)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if (BoolError == FALSE)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }
#endif

    if( _BaseAddr == NULL ) 
    {
        Error = _Status = GetLastError();
        TcpsvcsDbgAssert( FALSE );

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MapViewOfFile failed to extend address space, %ld.\n",
                Error ));

       goto Cleanup;
    }

    //
    // reset other pointers.
    //

    _HeaderInfo = (LPMEMMAP_HEADER)_BaseAddr;
    _EntryArray = ((LPBYTE)_BaseAddr + HEADER_ENTRY_SIZE );

    _Status = Error = ERROR_SUCCESS;

Cleanup:


    if( MapName != NULL ) {
        CacheHeap->Free( MapName );
    }

        return( Error );
}

DWORD
MEMMAP_FILE::GrowMapFile(DWORD dwMapFileGrowSize)
/*++

    This private member function extends the memory mapped file and
    creates more free url store entries.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error, i;
    BOOL BoolError;
    DWORD FilePointer;
    DWORD OldNumUrlInternalEntries;

    //
    // check to see that we have reached the limit.
    // we can hold only MAX_URL_ENTRIES url entries.
    // so the file size can grow more than
    //
    //  HEADER_ENTRY_SIZE + MAX_URL_ENTRIES * _EntrySize
    //

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif //INET_DEBG

    //BUGBUG - need to fix this
    if( (_FileSize + dwMapFileGrowSize) >=
            (HEADER_ENTRY_SIZE +
                MAX_URL_ENTRIES * _EntrySize) ) {

        //
        // best matching error code.
        //

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    FilePointer = SetFilePointer(
                            _FileHandle,
                            dwMapFileGrowSize,
                            NULL,
                            FILE_END );


    if (FilePointer != (_FileSize + dwMapFileGrowSize))
    {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "FilePointer != (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);
        
        _Status = GetLastError();
        Error = _Status;

        goto Cleanup;
    }

    if( FilePointer == 0xFFFFFFFF ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if( BoolError != TRUE ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize + dwMapFileGrowSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif

    //
    // adjust internal size parameters.
    //

    _FileSize += dwMapFileGrowSize;

    //
    // also set the new file size in the memory mapped file so that
    // other user will remap their address space and view the new portion.
    //

    _HeaderInfo->FileSize = _FileSize;

    OldNumUrlInternalEntries = _HeaderInfo->NumUrlInternalEntries;
    _HeaderInfo->NumUrlInternalEntries +=
        dwMapFileGrowSize / _EntrySize;

    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; // cell

    //
    // remap
    //

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    memset(
          (_EntryArray + _EntrySize * OldNumUrlInternalEntries),
           0,
          dwMapFileGrowSize );

    Error = ERROR_SUCCESS;


Cleanup:

    return( Error );
}

BOOL MEMMAP_FILE::CheckNextNBits(DWORD& nArrayIndex, DWORD &dwStartMask, 
                                DWORD nBitsRequired, DWORD& nBitsFound)
{
/*++
    Determines if the next N bits are unset.

Arguments:
    [IN/OUT]
    DWORD &nArrayIndex, DWORD &dwMask

    [IN]
    DWORD nBitsRequired

    [OUT]
    DWORD &nBitsFound

Return Value:

    TRUE if the next N bits were found unset.
    FALSE otherwise.

Notes:
    This function assumes that the range of bits to be checked lie
    within a valid area of the bit map. 
--*/
    DWORD i, j;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index 
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}
 

BOOL MEMMAP_FILE::SetNextNBits(DWORD nIdx, DWORD dwMask, 
                                DWORD nBitsRequired)
/*++
    Given an array index and bit mask, sets the next N bits.

Arguments:
    [IN]
    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired

Return Value:

    TRUE if the next N bits were found unset, and successfully set.
    FALSE if unable to set all the required bits.

Notes:
    This function assumes that the range of bits to be set lie
    within a valid area of the bit map. If the function returns
    false, no bits are set.
 --*/
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];
    BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {    
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            INET_ASSERT(FALSE);

            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                INET_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_HeaderInfo->AllocationBitMap[--nIdx];
                }                        
                *BitMap &= ~dwMask;
            }             
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;
    
        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }                        
    
    }

    // Success.
    return TRUE;
}


DWORD
MEMMAP_FILE::GetAndSetNextFreeEntry(
    DWORD nBitsRequired
    )
/*++
    This private member function computes the first available free entry
    index.

Arguments:

    DWORD nBitsRequired

Return Value:

    Next available free entry Index.
--*/
{
    DWORD i, nReturnBit = 0xFFFFFFFF;
    
    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);            
    
    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _NumBitMapDWords)
    {
        // Process starting from this DWORD if alignment is not required 
        // and there are free bits, or alignment is required and all bits
        // are free. 
        if (_HeaderInfo->AllocationBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _HeaderInfo->AllocationBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;
          
                    // Don't exceed the number of internal entries.
                    if (nLeadingBit + nBitsRequired > _HeaderInfo->NumUrlInternalEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _HeaderInfo->NumUrlEntriesAlloced += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _HeaderInfo->NumUrlEntriesAlloced += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits. 
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else                
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
	exit:
    return nReturnBit;
}


MemMapStatus MEMMAP_FILE::Init(LPTSTR PathName, DWORD EntrySize)
/*++

    MEMMAP_FILE object constructor.

Arguments:

    PathName : full path name of the memory mapped file.

    EntrySize : size of the each entry in this container.

Return Value:

    NONE.

--*/
{
    DWORD cb;

    _EntrySize =  EntrySize;
    _FullPathName = NULL;
    _FileName = NULL;
    _FileSize = 0;
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _BaseAddr = NULL;
    _HeaderInfo = NULL;
    _EntryArray = NULL;
    _NumBitMapDWords = 0;

    // Validate the path and create the path if it is not already there.
    _Status = ValidateAndCreatePath( PathName );
    if( _Status != ERROR_SUCCESS ) 
        goto Cleanup;

    // Path to memory mapped file.
    cb = strlen(PathName);
    _FullPathName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(DIR_SEPARATOR_STRING));

    if( _FullPathName == NULL ) 
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }

    memcpy(_FullPathName, PathName, cb + 1);
    AppendSlashIfNecessary(_FullPathName, &cb);
    
    _FullPathNameLen = cb;

    // Construct memory mapped file name.
    _FileName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(MEMMAP_FILE_NAME));
    if (!_FileName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }
    memcpy(_FileName, _FullPathName, cb);
    memcpy(_FileName + cb, 
        MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    
    // Create/Open memory mapped file.
    _FileHandle =
        CreateFile(
            _FileName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_FLAG_RANDOM_ACCESS,
            NULL );

    _Status = GetLastError();

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) 
    {
        _FileHandle = NULL;
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }
    else
    {
        SetFileTime(_FileHandle, NULL, NULL, (LPFILETIME)&dwdwSessionStartTime);
    }

    // Check to this file is new.
    if ( _Status == ERROR_ALREADY_EXISTS ) 
    {

        // Old file.

        _Status = ERROR_SUCCESS;
       _NewFile = FALSE;

       _FileSize = GetFileSize( _FileHandle, NULL );

       if( _FileSize == 0xFFFFFFFF ) 
       {
           _Status = GetLastError();
           TcpsvcsDbgAssert(FALSE);
           goto Cleanup;
       }

       if ((_FileSize < GlobalMapFileGrowSize) || ((_FileSize %GlobalMapFileGrowSize) != 0)) 
       {
            TcpsvcsDbgAssert(FALSE);
            if(!Reinitialize()) 
            {
                TcpsvcsDbgAssert(FALSE);
                SetLastError(_Status);
                goto Cleanup;
            }
            // Reinitialization results in new file.
            _NewFile = TRUE;
       }
    }
    else if( _Status == ERROR_SUCCESS) 
    {
        BOOL BoolError;
        DWORD FilePointer;

        // New file.
        _NewFile = TRUE;

        // Set initial file size.
        _FileSize = GlobalMapFileGrowSize;
        FilePointer = SetFilePointer( _FileHandle, _FileSize, NULL, FILE_BEGIN );

        if( FilePointer == 0xFFFFFFFF ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }

        if (FilePointer != _FileSize )
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "FilePointer != (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);
        }

        BoolError = SetEndOfFile( _FileHandle );

        if( BoolError != TRUE ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }
    }
    else 
    {
        // We should not reach here.
        TcpsvcsDbgAssert(FALSE);
    }
    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Header Size, %ld.\n",
                    HEADER_ENTRY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Size of elements, %ld.\n",
                        sizeof(MEMMAP_HEADER_SMALL)));


    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Bit Array size, %ld.\n",
                    BIT_MAP_ARRAY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Memmap Header Size, %ld.\n",
                    sizeof(MEMMAP_HEADER)));

    TcpsvcsDbgAssert( HEADER_ENTRY_SIZE >= sizeof(MEMMAP_HEADER) );

    // validate the file content if the file is not new.
    if( _NewFile != TRUE ) 
    {
        if( ValidateCache() == FALSE) 
        {
            if (!Reinitialize()) 
            {
                _Status = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;
            }

            // Succeeded in re-initializing the file, we 
            // treat this as if we created a new file.
            _NewFile = TRUE;
        }
    }
    else
    {
        // It is a brand new file. Initialize file header.
        if(!InitHeaderInfo()) 
        {
            // This can happen if there is an exception while
            // initializing headers
            _Status = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;

        }
    }

    // Compute number of bitmap DWORDs used.
    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; //cell

    // We are done.
    _Status = ERROR_SUCCESS;

Cleanup:

    if( _Status != ERROR_SUCCESS ) 
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MEMMAP_FILE::Initfailed, %ld\n", _Status ));
        
        SetLastError(_Status);
    }

    if (_NewFile)
        return MEMMAP_STATUS_REINITIALIZED;
    else
        return MEMMAP_STATUS_OPENED_EXISTING;
}

MEMMAP_FILE::~MEMMAP_FILE(
    VOID
    )
/*++

Routine Description:

    MEMMAP_FILE object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CloseMapping();
    CacheHeap->Free( _FileName );
    CacheHeap->Free( _FullPathName );
}


BOOL MEMMAP_FILE::ReAllocateEntry(LPFILEMAP_ENTRY pEntry, DWORD cbBytes)
/*++

Routine Description:

    Attempts to reallocate an entry at the location given.

Arguments:

    LPFILEMAP_ENTRY pEntry: Pointer to location in file map.
    DWORD cbBytes : Number of bytes requested

Return Value:

    Original value of pEntry if successful. pEntry->nBlocks is set to the new
    value, but all other fields in the entry are unmodified. If insufficient contiguous 
    bits are found at the end of the original entry, NULL is returned, indicating failure.
    In this case the entry remains unmodified. 

Notes:
    
    The Map file should *not* be grown if insufficient additional bits are not found.

--*/
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD) PtrDifference(pEntry, _EntryArray);
    if (IsBadOffset(cbEntryOffset))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    
    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {           
        // Determine if additional free bits are 
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _EntrySize + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired 
            > _HeaderInfo->NumUrlInternalEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the 
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask, 
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _HeaderInfo->NumUrlEntriesAlloced += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}

LPFILEMAP_ENTRY MEMMAP_FILE::AllocateEntry(DWORD cbBytes)
/*++

Routine Description:

    Member function that returns an free entry from the cache list. If
    none is available free, it grows the map file, makes more free
    entries.

Arguments:

    DWORD cbBytes : Number of bytes requested
    DWORD cbOffset: Offset from beginning of bit map where allocation is requested.

Return Value:

    If NULL, GetStatus() will return actual error code.

--*/
{
    LPFILEMAP_ENTRY NewEntry;

    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return 0;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF ) 
    {
        // Map file is full, grow it now.
        _Status = GrowMapFile(cbBytes <= GlobalMapFileGrowSize ?
            GlobalMapFileGrowSize : ROUNDUPTOPOWEROF2(cbBytes, ALLOC_PAGES * PAGE_SIZE) );

        // Failed to grow map file.
        if( _Status != ERROR_SUCCESS ) 
        {
            return NULL;
        }

        // Retry with enlarged map file.
        FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

        TcpsvcsDbgAssert( FreeEntryIndex != 0xFFFFFFFF );

        // Failed to allocate bytes after enlarging map file.
        if( FreeEntryIndex == 0xFFFFFFFF ) 
        {
            return NULL;
        }
    }

    INET_ASSERT(  (cbBytes < PAGE_SIZE) 
        || ( (cbBytes >= PAGE_SIZE) && !((_EntrySize * FreeEntryIndex) % PAGE_SIZE)) );
    
    // Cast the memory.
    NewEntry = (LPFILEMAP_ENTRY)
        (_EntryArray + _EntrySize * FreeEntryIndex);
    
    // Mark the allocated space.
    #ifdef DBG
        ResetEntryData(NewEntry, SIG_ALLOC, nBlocksRequired);
    #else
        NewEntry->dwSig = SIG_ALLOC;
    #endif // DBG

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;
        
    return NewEntry;
}


BOOL MEMMAP_FILE::FreeEntry(LPFILEMAP_ENTRY Entry)
/*++

    This public member function frees up a file cache entry.

Arguments:

    UrlEntry : pointer to the entry that being freed.

Return Value:

    TRUE - if the entry is successfully removed from the cache.
    FALSE - otherwise.

--*/
{
    DWORD nIndex, nArrayIndex, 
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    //
    // Validate the pointer passed in.
    //
    if( ((LPBYTE)Entry < _EntryArray) 
        || ((LPBYTE)Entry >=
           (_EntryArray + _EntrySize *
           _HeaderInfo->NumUrlInternalEntries) ) ) 
    {
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD) PtrDifference(Entry, _EntryArray);
    if( nOffset % _EntrySize ) 
    {
        // Pointer does not point to a valid entry.
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }
    
    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / NORMAL_ENTRY_SIZE))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _EntrySize;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    //
    // Unmark the index bits in the map.
    //

    BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Attempted to free unset bits. Ignoring...\n"));
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    TcpsvcsDbgAssert(_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _HeaderInfo->NumUrlEntriesAlloced -= nBlocks;

return TRUE;
}


BOOL
MEMMAP_FILE::Reinitialize(void)
/*++

    This  member function reinitializes a cache index file

Arguments:



Return Value:

    Windows error code


--*/
{
    TcpsvcsDbgAssert( _FileHandle != NULL );

    // Close view, mapping, and file.
    CloseMapping();
    
    BOOL BoolError, fReinited = FALSE;
    DWORD FilePointer;

    // If we're re-initialising, that means we're losing all our cached data. 
    // Time to delete all the old stuff

    // But wait -- we only want to do this for the content cache, since we can regen
    // the index from the cookies, and history stores all its info in index file
    // We'll check for "content.ie5" in the path

    if (StrStrI(_FullPathName, "content.ie5"))
    {
        DeleteCachedFilesInDir(_FullPathName);
    }

    // check for exclusive access, we do this by opening the
    // file in exclsive mode, if we succeed we are the only one
    _FileHandle = CreateFile
        (
            _FileName,
            GENERIC_WRITE,
            0,    // no read/write sharing
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

    if (_FileHandle == INVALID_HANDLE_VALUE)
        _FileHandle = NULL;
    else
    {
        DWORD FilePointer = SetFilePointer
            ( _FileHandle, GlobalMapFileGrowSize, NULL, FILE_BEGIN);
    
        if( FilePointer != 0xFFFFFFFF)
        {
            if (SetEndOfFile (_FileHandle))
            {
                // Success!
                _FileSize = GlobalMapFileGrowSize;
                fReinited = TRUE;
            }
            else
            {
                TcpsvcsDbgPrint(( DEBUG_ERRORS, "SetEndOfFile failed: %u\n",
                    GetLastError()));
            }
        }            

        // Following will be done by RemapAddress calling CloseMapping
        // CloseHandle (_FileHandle);
        // _FileHandle = NULL
    }

    // Re-attach to the file.

    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS )
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:Remap failed, %ld.\n",_Status));
        TcpsvcsDbgAssert( FALSE );
        goto Cleanup;
    }

    if (fReinited)
    {
        // if there is an exception due to bad sector, this will set
        // _status to something other than ERROR_SUCCESS
        if(!InitHeaderInfo()) 
            goto Cleanup;

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

Cleanup:

    return fReinited;
}

BOOL
MEMMAP_FILE::InitHeaderInfo()
/*++

    This  member function intializes the memorymapped headerinfo
    structure

Arguments:



Return Value:

    None

--*/
{
    //
    // initialize file header.
    //
    BOOL fSuccess = TRUE;

    __try {
        TcpsvcsDbgAssert( _HeaderInfo != NULL );

        memcpy(_HeaderInfo->FileSignature, CACHE_SIGNATURE, sizeof(CACHE_SIGNATURE));

        _HeaderInfo->FileSize = _FileSize; // set file size in the memmap file.
        _HeaderInfo->dwHashTableOffset = 0;
        _HeaderInfo->CacheSize = (LONGLONG)0;
        _HeaderInfo->CacheLimit = (LONGLONG)0;
        _HeaderInfo->ExemptUsage = (LONGLONG)0;
        _HeaderInfo->nDirCount = 0;
        
        for (int i = 0; i < DEFAULT_MAX_DIRS; i++)
        {
            _HeaderInfo->DirArray[i].nFileCount = 0;
            _HeaderInfo->DirArray[i].sDirName[0] = '\0';
        }
        
        _HeaderInfo->NumUrlInternalEntries =
            ((_FileSize - HEADER_ENTRY_SIZE ) /
                _EntrySize );

        _HeaderInfo->NumUrlEntriesAlloced = 0;

        memset( _HeaderInfo->AllocationBitMap, 0,  sizeof(_HeaderInfo->AllocationBitMap) );
        memset( _EntryArray, 0, (_FileSize - HEADER_ENTRY_SIZE) );
        memset( _HeaderInfo->dwHeaderData, 0, sizeof(DWORD) * NUM_HEADER_DATA_DWORDS);

        _Status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        _Status = ERROR_WRITE_FAULT;
        fSuccess = FALSE;
    }
    ENDEXCEPT

    return (fSuccess);
}

LPFILEMAP_ENTRY MEMMAP_FILE::FindNextEntry (DWORD* pdwEnum, DWORD dwFilter, GROUPID GroupId, DWORD dwMatch)
{
    while (1)
    {
        // Get the next item in the hash table.
        HASH_ITEM *pItem = HashGetNextItem (this, (LPBYTE)_BaseAddr, pdwEnum, 0);
        if (!pItem)
            return NULL;

        // continue if search entry within group but hash bit says no group 
        // (may avoid unnecessary page hit by pulling non-relevent pEntry)
        if( GroupId && !pItem->HasGroup() )
            continue;

            
        // Get the entry from the item.
        URL_FILEMAP_ENTRY* pEntry = ValidateUrlOffset (pItem->dwOffset);
        if (!pEntry)
        {
            pItem->MarkFree();
            continue;
        }
        
        // No filter - continue enum until ERROR_NO_MORE_ITEMS.
        if (!dwFilter)
            continue;

        // IDENTITY_CACHE_ENTRY is an identity-specific entry.
        // We don't want these to be shown inappropriately to a client.
        // We may want to be able to display all of these for debug, though.
        if ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY)
            && ((pEntry->dwIdentity != dwMatch)
                || (!pEntry->dwIdentity)))
            continue;

        DWORD cet = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
        
        // Temporary hack to always show 1.1 entries 
        // until we have a better way of dealing with them.
        dwFilter |= INCLUDE_BY_DEFAULT_CACHE_ENTRY;

        // Continue enum if no match on cache entry type.
        if ((dwFilter & cet) != cet)
            continue;

        // Continue enum if no match on group.
        if (GroupId ) 
        {
            if( pItem->HasMultiGroup() )
            {
                // need to search the list
                LIST_GROUP_ENTRY*   pListGroup = NULL;
                pListGroup = ValidateListGroupOffset(pEntry->dwGroupOffset);
                if( !pListGroup )
                    continue;

                BOOL fFoundOnList = FALSE;
                while( pListGroup && pListGroup->dwGroupOffset )
                {
                    GROUP_ENTRY* pGroup = NULL;
                    pGroup = ValidateGroupOffset( 
                                pListGroup->dwGroupOffset, pItem); 
                    if( !pGroup )
                    {
                        break;
                    }

                    if( GroupId ==  pGroup->gid )
                    {
                        fFoundOnList = TRUE;
                        break;
                    }

                    if( !pListGroup->dwNext )
                    {
                        break;
                    }

                    // next group on list
                    pListGroup = ValidateListGroupOffset(pListGroup->dwNext);
                }
               
                if( !fFoundOnList )
                    continue; 

            }
            else if( GroupId != 
                        ((GROUP_ENTRY*)( (LPBYTE)_BaseAddr + 
                                 pEntry->dwGroupOffset))->gid ) 
            { 
                continue;
            }

        }

        return (LPFILEMAP_ENTRY) (((LPBYTE)_BaseAddr) + pItem->dwOffset);
    }
}

BOOL MEMMAP_FILE::IsBadOffset (DWORD dwOffset)
{

    ASSERT_ISPOWEROF2 (_EntrySize);
    return (dwOffset == 0
        || (dwOffset & (_EntrySize-1))
        || (dwOffset >= _FileSize));

    return FALSE;

}


BOOL MEMMAP_FILE::IsBadGroupOffset (DWORD dwOffset)
{
    return (dwOffset == 0 || (dwOffset >= _FileSize));
    return FALSE;
}


GROUP_ENTRY* MEMMAP_FILE::ValidateGroupOffset (DWORD dwOffset, HASH_ITEM* hItem)
{
    GROUP_ENTRY *pEntry = NULL;

    // if hash item is available, check the group bit first.
    if( hItem && !hItem->HasGroup())
    {
        return NULL;
    }

    // check the offset 
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    
    // Get the Group.
    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (GROUP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}



URL_FILEMAP_ENTRY* MEMMAP_FILE::ValidateUrlOffset (DWORD dwOffset)
{
    // Validate offset.
    if (IsBadOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    // Validate signature.
    URL_FILEMAP_ENTRY *pEntry =
        (URL_FILEMAP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    if (pEntry->dwSig != SIG_URL)
    {
        //INET_ASSERT (FALSE);    //  commented out for RAID item 33684
        return NULL;
    }
    
    // TODO: validate entry offsets, string terminations etc.
    return pEntry;
}


LIST_GROUP_ENTRY* MEMMAP_FILE::ValidateListGroupOffset (DWORD dwOffset)
{
    LIST_GROUP_ENTRY *pEntry = NULL;

    // Validate offset.
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL ;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    

    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (LIST_GROUP_ENTRY*) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG


#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>



VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    );

extern BOOL UrlcacheDebugEnabled;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    if (!UrlcacheDebugEnabled) {

        return;

    }

    va_start(arglist, Format);

    InternetDebugPrintValist(Format, arglist);

    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\filemgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  filemgr.cxx

Abstract:

    Manages cache file & directory creation/deletion.

Author:
    Adriaan Canter (adriaanc) 04-02-97

Modifications:
    Ahsan Kabir (akabir) 25-Sept-97 made minor alterations.
    
--*/


#include <cache.hxx>
#define WWW_DOT "www."

#define MAP_KEY_TO_PATH    0
#define MAP_PATH_TO_KEY    1


//
//==================== CFileMgr Public Functions =============================
//


/*-----------------------------------------------------------------------------
CFileMgr::CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::CFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : _mmFile(mmFile), _dwOptions(dwOptions)
{
    INET_ASSERT(_mmFile);

    // GetFullPathNameLen includes trailing backslash.
    _cbBasePathLen = _mmFile->GetFullPathNameLen();
}


/*-----------------------------------------------------------------------------
CFileMgr::~CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::~CFileMgr()
{}


/*-----------------------------------------------------------------------------
virtual CFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CFileMgr::Init()
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual GetDirLen
Returns length of cache dir path.
----------------------------------------------------------------------------*/
DWORD CFileMgr::GetDirLen(DWORD nKey)
{
    return _cbBasePathLen;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::CreateUniqueFile
Generates cache files.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR szUrl, LPTSTR szFileName,
                                LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    return CreateUniqueFile((LPCSTR) szUrl, (LPTSTR) _mmFile->GetFullPathName(),
        (LPTSTR) szFileName, (LPTSTR) szFileExtension, (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::NotifyCommit
No-op.
----------------------------------------------------------------------------*/
BOOL CFileMgr::NotifyCommit(DWORD nDirIndex)
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
CFileMgr::DeleteCache
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteCache(LPSTR szRoot)
{
    BOOL fHasCacheVu = IsValidCacheSubDir(szRoot);

    if ( fHasCacheVu)
        DisableCacheVu(szRoot);
        
    if (DeleteCachedFilesInDir(szRoot) == ERROR_SUCCESS)
    {
        SetFileAttributes(szRoot, FILE_ATTRIBUTE_DIRECTORY);
        RemoveDirectory(szRoot);
    }

    if( fHasCacheVu)
        EnableCacheVu( szRoot);
    
    return TRUE;
}

/*-----------------------------------------------------------------------------
CFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CFileMgr::Cleanup()
{
    return TRUE;
}

/*-----------------------------------------------------------------------------
virtual CFileMgr::GetDirIndex
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetDirIndex(LPSTR szFilePath, LPDWORD pnIndex)
{
    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                    LPSTR szSubDirPath, LPDWORD pcb)
{
    INET_ASSERT(pEntry && szSubDirPath && pcb && *pcb);

    // "anyuser@msn.txt"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);

    // Lengths of path and file.
    DWORD cbFile = strlen(szFile);
    DWORD cbPath = _mmFile->GetFullPathNameLen();

    // Don't overflow output buffer.
    DWORD cbSubDirPath = cbPath + cbFile;
    if (cbSubDirPath + 1 > *pcb)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // "C:\Windows\Profiles\anyuser\Cookies\"
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cbPath);

    // "C:\Windows\Profiles\anyuser\Cookies\anyuser@msn.txt"
    memcpy(szSubDirPath + cbPath, szFile, cbFile + 1);

    *pcb = cbSubDirPath;

    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::DeleteOneCachedFile
Deletes a single cache file given the absolute path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                                   DWORD dostEntry, DWORD nIndex)
{
    return ::DeleteOneCachedFile(lpszFileName, dostEntry);
}


/*-----------------------------------------------------------------------------
    virtual BOOL  CreateDirWithSecureName( LPSTR);

Creates a cache directory with a given name to allow existing directories
to be copied into another cache file.  Just the eight letters of the new
directory are given.
----------------------------------------------------------------------------*/
BOOL CFileMgr::CreateDirWithSecureName( LPSTR szDirName)
{
    return _mmFile->CreateDirWithSecureName( szDirName);
}


//
//================== CFileMgr Protected Functions =============================
//

/*-----------------------------------------------------------------------------
CFileMgr::GetStoreDirectory
    Returns "%windir%\web\" - ie "C:\Windows\Web\" and length. There
    is currently only ONE store directory and this is it.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetStoreDirectory(LPSTR szPath, LPDWORD pcbPath)
{
    DWORD cb;

    // Hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szPath, MAX_PATH)) && cb<=MAX_PATH)
    {
        AppendSlashIfNecessary(szPath, &cb);
        memcpy(szPath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1;
        *pcbPath = cb;
        return TRUE;
    }
    INET_ASSERT(FALSE);
    return FALSE;
}

/*-----------------------------------------------------------------------------
CFileMgr::MapStoreKey
    Maps path to storage directory key (stored in the FILEMAP_ENTRY::DirIndex)
    or storage directory key to path (ie C:\Windows\Web\). There is currently
    only one key and it is INSTALLED_DIRECTORY_KEY. Mapping depends on dwFlag.
----------------------------------------------------------------------------*/
BOOL CFileMgr::MapStoreKey(LPSTR szPath, LPDWORD pcbPath, 
                           LPDWORD dwKey, DWORD dwFlag)
{
    DWORD cb;
    BOOL fReturn = FALSE;
    CHAR szStoreDir[MAX_PATH];

    // Must be able to get store dir in any case.
    if (GetStoreDirectory(szStoreDir, &cb))
    {
        // Mapping a path to a key requested.
        if (dwFlag == MAP_PATH_TO_KEY)
        {
            // Path matches?
            if ((*pcbPath == cb) 
                && !strnicmp(szStoreDir, szPath, cb))
            {
                // We only map one directory for now.
                *dwKey = INSTALLED_DIRECTORY_KEY;
                fReturn = TRUE;
            }
        }

        // Mapping a key to a path requested.    
        else if (dwFlag == MAP_KEY_TO_PATH)
        {
            if (*dwKey == INSTALLED_DIRECTORY_KEY)
            {
                memcpy(szPath, szStoreDir, cb+1);
                *pcbPath = cb;
                fReturn = TRUE;
            }
        }
    }
    //INET_ASSERT(fReturn);
    return fReturn;
}

/*-----------------------------------------------------------------------------
CreateUniqueFile

Routine Description:

Arguments:

    UrlName : pointer to url name.

    Path : pointer to cache path.

    FileName : pointer to a buffer that receives the full path name of the
        newly created file.

    Extension : if specified the extension is used to make random file.

Return Value:

    Windows Error Code.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR UrlName, LPTSTR Path, 
                                 LPTSTR FileName, LPTSTR Extension, 
                                 HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD cbPath, cbName, cbFull;
    cbPath = strlen(Path);

    DWORD Error=ERROR_SUCCESS, len, lenExt=0;

    TCHAR RandomFileName[MAX_PATH];

    TCHAR FullFileName[MAX_PATH];

    HANDLE FileHandle;

    DWORD dwCollision = 0, dwTotalCollissionCount;
    char szHost[MAX_PATH], szExtraInfo[MAX_PATH];
    URL_COMPONENTS sUrl;
    char *pszUrlPath = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_PATH_LENGTH);

    LPTSTR FileNamePtr = FileName, lpT;
    
    BOOL fUseFileName = FALSE, fPrettyName = FALSE;

    DWORD cbFileName;
    CHAR szExt[MAX_PATH];
    *szExt = '\0';  

    if (phfHandle)
        *phfHandle = INVALID_HANDLE_VALUE;
    
    if (pszUrlPath == NULL)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // If a filename has been passed in attempt to use it.
    if (FileName[0] != '\0')
    {
        // Various checks to determine validity of name.

        // First strip any trailing whitespace.
        cbFileName = strlen(FileName);
        StripTrailingWhiteSpace(FileName, &cbFileName);

        // Check length.
        if (cbFileName < MAX_PATH)
        {            

            // '.' and '..' are illegal.
            if (memcmp(FileName, ".", sizeof("."))
                && memcmp(FileName, "..", sizeof("..")))
            {
                // slashes and backslashes are illegal.
                LPTSTR ptr = FileName;
                while (*ptr != '\0')
                {
                    if (IsDBCSLeadByte(*ptr))
                        ++ptr;
                    else
                    if (*ptr == '\\' || *ptr == '/')
                        break;
                    ptr++;
                }
                

                // Filename has no slashes in it.
                if (!*ptr)
                {
                    // Preliminary judgment. Creating
                    // this file could possibly fail,
                    // depending on further tests.
                    fUseFileName = TRUE;
                }
            }
        }
    }

    // Preliminary checks indicate valid filename.
    if (fUseFileName)
    {
        // Attempt to parse a file extension.

        CHAR* pExt = StrChr(FileName, '.');

        // Found a file extension delimiter.
        if (pExt)
        {
            // '.' but no extension (eg "foo.")
            if (*(pExt + 1) == '\0')
            {
                *pExt = '\0';
                len = cbFileName - 1;
            }

            // '.' at beginning (eg ".foo") Valid file, no extension.
            else if (pExt == FileName)
            {
                len = cbFileName;
            }

            // Common case (eg foo.bar)
            else
            {
                // Separate out the file extension w/o '.'
                lenExt = (DWORD) (cbFileName - (pExt - FileName) - 1);  // 64BIT
                memcpy(szExt, pExt+1, lenExt + 1);

                // Filename without extension.
                *pExt = '\0';
                len = (DWORD) (pExt - FileName);     // 64BIT
            }
        }     

        // No file extension found
        else
        {
            len = cbFileName;
        }
        fPrettyName = TRUE;
        goto have_file_name;
    }

    // No or bad filename passed in.
    else
    {
        // Copy over any extension passed in,
        // limiting the length as necessary.
        if (Extension)
        {
            lenExt = strlen(Extension);
            if (lenExt >= MAX_PATH)
            {
                lenExt = MAX_PATH - 1;
            }
            memcpy(szExt, Extension, lenExt);
            szExt[lenExt] = '\0';
        }
        else
        {
            *szExt = '\0';
            lenExt = 3;
        }
    }

    memset(&sUrl, 0, sizeof(sUrl));

    sUrl.dwStructSize = sizeof(sUrl);

    sUrl.lpszHostName = szHost;
    sUrl.dwHostNameLength = sizeof(szHost);

    sUrl.lpszUrlPath = pszUrlPath;
    sUrl.dwUrlPathLength = INTERNET_MAX_PATH_LENGTH;


    sUrl.lpszExtraInfo = szExtraInfo;
    sUrl.dwExtraInfoLength = sizeof(szExtraInfo);



    if (InternetCrackUrl(UrlName, lstrlen(UrlName), 0, &sUrl)) {
        fPrettyName = TRUE;

        if ((sUrl.dwUrlPathLength == 1) && (pszUrlPath[0] == '/')) {

            FileNamePtr = szHost;
            len = sUrl.dwHostNameLength;

            // strip out www., this info is redundant

            if (!strnicmp(FileNamePtr, WWW_DOT, sizeof(WWW_DOT)-1)) {

                len -= (sizeof(WWW_DOT)-1);

                // copy the NULL terminator too

                memmove(FileNamePtr, FileNamePtr+sizeof(WWW_DOT)-1,len+1);

            }
        }
        else {

            FileNamePtr = pszUrlPath;
            len = sUrl.dwUrlPathLength;

            // if there is a terminating slash let us fix it.
            // len-1 wont' break because we know the url is more than 1 char
            // Above assumption not valid.
            if (len && (FileNamePtr[len-1] == '/')) 
            {
                FileNamePtr[len-1] = 0;
                --len;
            }

            // get the tail
            if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '/'))
            {
                ++lpT;

                len = len - (DWORD)PtrDifference(lpT, FileNamePtr);

                //
                // truncate the FileNamePtr if it is too long -
                //   the "fudge-factor" number is to allow room for stuff like "[%d]"
                //    in the URL -- this number doesn't have to be accurate since
                //    the worst-case scenario is us using a random (ugly) filename.
                //
                unsigned int newlen;
						
                if(GlobalTruncateFileName)
                    newlen = /*excel limit*/218 - (cbPath + lenExt + 2 + /*fudge-factor*/5);
                else
                    newlen = MAX_PATH - (cbPath + lenExt + 2 + /*fudge-factor*/5);

                if ((newlen > 2) && (newlen < len))
                {
                    // For UTF-8, we don't want to chop in the middle of a %XX
                    if (lpT[newlen - 2] == '%')
                        newlen -= 2;
                    else if (lpT[newlen - 1] == '%')
                        newlen -= 1;

                    len      = newlen;
                    lpT[len] = '\0';
                }

                // copy the NULL terminator as well
                memmove(FileNamePtr, lpT, len+1);
            }
		
            // Special hack for cookies: Ensure that the username is
            // prepended on to the filename. The preceding filename
            // generation code does not generate this for cookies
            // which specify paths in addition to domains.      
            if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
            {                
                // This is a cookie url of the form Cookie:username@domain/path
                if (GetWininetUserName())
                {
                    DWORD cb = vdwCurrentUserLen;
                    if (len + cb + 1 < MAX_PATH)
                    {
                        if (memcmp(FileNamePtr, vszCurrentUser, cb) 
                            || FileNamePtr[cb] != '@'
                            || FileNamePtr[cb+1] == '\0')
                        {
                            memmove(FileNamePtr + cb + 1, FileNamePtr, len+1);
                            FileNamePtr[cb] = '@';
                            memcpy(FileNamePtr, vszCurrentUser, cb);
                            len += cb + 1;
                        }
                    }
                }
            }
        
        }

        
        if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '.'))
        {
            *lpT = 0;
            len = (DWORD) PtrDifference(lpT, FileNamePtr);
        }

        // convert all invalid char (including '%') to '_'
        for(lpT = FileNamePtr; *lpT; ++lpT) 
        {
            if (IsDBCSLeadByte(*lpT))
                ++lpT;
            else if ((strchr(vszInvalidFilenameChars, *lpT))) 
                *lpT = '_';
        }

        if ((cbPath+len+lenExt+2) > MAX_PATH) {

            fPrettyName = FALSE;

        }
    }
    else {

        fPrettyName = FALSE;
    }


have_file_name:


    for(dwTotalCollissionCount = 0;
        dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS;
        dwTotalCollissionCount++) {


        //
        // make a random file name.
        //
        if (!fPrettyName) 
        {
            // If fUseFileName is TRUE, it means we've attempted to create
            // a file using the filename passed in and failed. We still want 
            // to create a cache file, but since the extension parsed from the
            // filename is also suspect, we want to create a cache filename
            // without any passed in extension, or NULL.
            if (fUseFileName)
            {
                if (Extension)
                {
                    lenExt = strlen(Extension);
                    memcpy(szExt, Extension, lenExt+1);
                }
                else
                {
                    lenExt = 0;
                    *szExt = '\0';
                }
            }

            Error = MakeRandomFileName(UrlName, RandomFileName, szExt);

        }
        else {

            DWORD digit;
            DWORD cb = strlen(FileNamePtr);
            memcpy(RandomFileName, FileNamePtr, cb+1);

            lpT = RandomFileName+len;

            // Always decorate the cache file name with [1-99]
            // We use square brackets instead of parens because
            // NT cmd shell barfs on parens.
            
            if (++dwCollision > 99)
            {
                fPrettyName = FALSE;
                continue;
            }

#ifndef UNIX
            if (fCreatePerUser && GlobalIdentity)
            {
                lpT += wsprintf (lpT, "[%d][%d]", GlobalIdentity, dwCollision);
            }
            else
            {
                lpT += wsprintf (lpT, "[%d]", dwCollision);
            }
#else
            /* Square brackets cause problems on UNIX */
            lpT += wsprintf (lpT, "(%d)", dwCollision);
#endif /* UNIX */
                
            if (*szExt)
            {
                *lpT++ = '.';
                memcpy(lpT, szExt, lenExt + 1);
            }
            
            Error = ERROR_SUCCESS;

        }

        if (Error != ERROR_SUCCESS) {
            INET_ASSERT(FALSE);
            goto Cleanup;

        }

        cbName = strlen(RandomFileName);
        cbFull = cbPath + cbName + 1;

        if (cbFull > MAX_PATH)
        {
            INET_ASSERT(FALSE);
            Error = ERROR_FILENAME_EXCED_RANGE;
            goto Cleanup;
        }
#ifndef UNIX
        // Hack for special DOS filenames:
        // aux.*, com[0-9].*, con.*, lpt[0-9].*, 
        // nul.* and prn.* on non-NT platforms.
        if (!IsPlatformWinNT())
        {
            DWORD cbMajor = cbName - lenExt;
            if (cbMajor == 4 || cbMajor == 5)
            {
                switch(tolower(*RandomFileName))
                {
                    // Test for aux.*
                    case 'a':
                    if (!strnicmp(RandomFileName + 1, "ux.", 3))
                    {
                        continue;
                    }
                    break;

                    // Test for com[0-9].* and con.*
                    case 'c':
                    if (tolower(RandomFileName[1]) == 'o')
                    {
                        CHAR c = tolower(RandomFileName[2]);
                        if (c == 'm')
                        {
                            if (isdigit(RandomFileName[3])
                                && RandomFileName[4] == '.')
                            {
                                continue;
                            }
                        }
                        else if (c == 'n')
                        {
                            if (RandomFileName[3] == '.')
                            {
                                continue;
                            }
                        }
                    }
                    break;
    
                    // Test for lpt[0-9].*
                    case 'l':
                    {
                        if (!strnicmp(RandomFileName + 1, "pt", 2)
                            && isdigit(RandomFileName[3])
                            && RandomFileName[4] == '.')
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for nul.*
                    case 'n':
                    {
                        if (!strnicmp(RandomFileName + 1, "ul.", 3))
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for prn.*
                    case 'p':
                    {
                        if (!strnicmp(RandomFileName + 1, "rn.", 3))
                        {
                            continue;
                        }
                        break;
                    }
                }
            }
        }
#endif /* !UNIX */

        // Make full path name.
        memcpy(FullFileName, Path, cbPath);
        memcpy(FullFileName + cbPath, RandomFileName, cbName + 1);

        // Check if this file exists.
        if (GetFileAttributes(FullFileName)!=0xffffffff) 
        {
            // A file or dir by this name exists.
            // This will also take care of special DOS filenames
            // on NT, which return !0xffffffff.
            continue;
        }



        FileHandle = CreateFile(
                        FullFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( FileHandle != INVALID_HANDLE_VALUE ) 
        {
            // successfully create a new file either return handle or close it and return.
            if ( phfHandle )
                *phfHandle = FileHandle;
            else
                CloseHandle( FileHandle );

            break;
        }
        else
        {
            // Couldn't create the file. This is possibly due to the file
            // already existing or to the fact that the directory was deleted.

            // Check for the existance of the directory:
            if (GetFileAttributes(Path) == 0xffffffff)
            {
                // Directory was deleted. Create one and then
                // create the file.
                if (CreateDirectory(Path, NULL))
                {
                    // Set system attribute.
                    SetFileAttributes(Path, FILE_ATTRIBUTE_SYSTEM);

                    // Enable cachevu in this directory
                    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                        EnableCacheVu(Path);

                    FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                    // We just created the directory and the
                    // child file, so the file handle should
                    // be valid.
                    if( FileHandle != INVALID_HANDLE_VALUE ) 
                    {
                        // successfully create a new file either return handle or close it and return.
                        if ( phfHandle )
                            *phfHandle = FileHandle;
                        else
                            CloseHandle( FileHandle );

                        break;
                    }
                }
            }
        }

        Error = GetLastError();

        if( Error != ERROR_FILE_EXISTS )
        {
            if (!fPrettyName)
            {
                INET_ASSERT(FALSE);
                goto Cleanup;
            }
            else
            {
                fPrettyName = FALSE;
                Error = ERROR_SUCCESS;
            }
        }
        else {

            // We found that the file exists
            // if it is zero size, let us just use it.
            // this in itself is an unlikely occurrence
            // but we any way try to work around the IBM virus software

            // ACHTUNG!!! this is a special hack for IBM antivirus software

            FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

            if (FileHandle != INVALID_HANDLE_VALUE) {

                // this looks usable
                if (GetFileSize(FileHandle, NULL) == 0)
                {
                    if (phfHandle)
                        *phfHandle = FileHandle;
                    else
                        CloseHandle( FileHandle );
                    break;
                }
                    
                CloseHandle( FileHandle );
                INET_ASSERT(FALSE);
            }
            Error = ERROR_DISK_FULL;
            goto Cleanup;
        }

        //
        // try another random file.
        //
    } // end of the for loop

    if (dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS) {

        memcpy(FileName, FullFileName, cbFull);
        Error = ERROR_SUCCESS;

    }
    else {
        INET_ASSERT(FALSE);
        Error = ERROR_DISK_OPERATION_FAILED;

    }
Cleanup:
    if (pszUrlPath)
        FREE_MEMORY(pszUrlPath);

    return Error;
}

/*-----------------------------------------------------------------------------
MakeRandomFileName

  Routine Description:

    Creates a random 8.3 file name. The format of the name will be as
    below:

        ca(0-99999).(0-999)

    Ex ca19200.340
    Ex ca19354.tmp - if an extension (tmp) is specified.

Arguments:

    UrlName : pointer to an URL string

    FileName : pointer to a string buffer where the random file name is
        returned. The buffer length must be atleast 8+3+1+1= 13 wchars.

    Extension : pointer to an extension string. if this is non-NULL, then
        the specified extension is used otherwise random extension as
        explained above is used.

Return Value:

    none.
----------------------------------------------------------------------------*/
DWORD CFileMgr::MakeRandomFileName(LPCSTR UrlName,
                                      LPTSTR FileName, LPTSTR Extension)
{
    DWORD RandNum;
    LPTSTR FileNamePtr = FileName;
    static Counter;
    DWORD i;
    DWORD cbExtension = 0;

    if (Extension)
        cbExtension = lstrlen(Extension) + 1;

    if (cbExtension > (MAX_PATH-(8+1)))
    {
        return(ERROR_FILENAME_EXCED_RANGE);
    }

    // Additional special hack for cookie urls.
    if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
    {                
        // This is a cookie url of the form Cookie:username@domain/path
        if (GetWininetUserName())
        {
          DWORD cb = vdwCurrentUserLen;
          
          if (cb + 8 + cbExtension + 1 < MAX_PATH)
          {
              memcpy(FileName, vszCurrentUser, cb);
              FileName[cb] = '@';
              FileNamePtr += (cb + 1);
          }
        }
    }
    
    // Check that the total name doesn't exceed MAX_PATH
    // Our total name is 8 chars basename + a dot + the extension + 0


    *FileNamePtr++ = L'C';
    *FileNamePtr++ = L'A';

    //
    // generate a six digits random string;
    //

    //
    // We can't use rand() alone to generate a random number because it will
    // repeat the same sequence for each new thread that comes in.  We can't
    // use the TickCount alone because it is a little too predicable.  But
    // the two combined should be nice.  Adding in Counter will take care of
    // the case of two brand-new threads coming in at the same time.
    //


    for ( i = 0; i < 6; i++) {
        UINT digit;

        RandNum = (GetTickCount() * rand()) + Counter++;

        digit = RandNum % 36; // 10 digits + 26 letters

        *FileNamePtr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *FileNamePtr++ = L'.';
  
    
    //
    // if an extension is specified, use it.
    //
    if( Extension != NULL )
    {
        // if a 0 extension if provided, we will create a
        // file with no extension
        memcpy(FileNamePtr, Extension, cbExtension);
        return ERROR_SUCCESS;
    }

    // Append default file extension.
    memcpy(FileNamePtr, DEFAULT_FILE_EXTENSION, sizeof(DEFAULT_FILE_EXTENSION));
    return ERROR_SUCCESS;
}






//
//===================== CSecFileMgr Public Functions ==========================
//


/*-----------------------------------------------------------------------------
CSecFileMgr::CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::CSecFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : CFileMgr(mmFile, dwOptions)
{
    INET_ASSERT(_mmFile);

    // BUGBUG - have to guard against getting out of sync with dirs.
    if (_mmFile->GetDirCount() == 0)
        Init();
}


/*-----------------------------------------------------------------------------
CSecFileMgr::~CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::~CSecFileMgr()
{}


/*-----------------------------------------------------------------------------
CSecFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Init()
{
    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(_mmFile->GetFullPathName());

    return CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
}


/*-----------------------------------------------------------------------------
GetDirLen()
Returns cache dir path length.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::GetDirLen(DWORD nKey)
{
    DWORD cb = 0;

    if (nKey < DEFAULT_MAX_DIRS)
    {    
        // + 1 to account for trailing backslash.
        cb = _cbBasePathLen + DIR_NAME_SIZE + 1;
    }
    else
    {
        CHAR szStoreDir[MAX_PATH];
        GetStoreDirectory(szStoreDir, &cb);
    }
    INET_ASSERT(cb);
    return cb;
}

/*-----------------------------------------------------------------------------
CSecFileMgr::CreateUniqueFile
Creates a cache file.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::CreateUniqueFile(LPCSTR szUrl, LPTSTR szFileName,
                                   LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD nDir, nFiles;
    DWORD nDirCount = _mmFile->GetDirCount();

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    FindMinFilesSubDir(nDir, nFiles);

    if (nFiles >= MAX_FILES_PER_CACHE_DIRECTORY
        && nDirCount < DEFAULT_MAX_DIRS)
    {
        if (CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE))
            nDir++;
    }

    // Get the cache path and subdirectory
    // from the memory mapped file
    CHAR szSubDirPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cb);

    _mmFile->GetDirName(nDir, szSubDirPath + cb);
    memcpy(szSubDirPath + cb + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    return CFileMgr::CreateUniqueFile((LPCSTR) szUrl, (LPTSTR) szSubDirPath,
                                      (LPTSTR) szFileName, (LPTSTR) szFileExtension,
                                      (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
CSecFileMgr::NotifyCommit
Tracks committed cache file counts.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::NotifyCommit(DWORD nDirIndex)
{
    INET_ASSERT(_mmFile->GetDirCount() <= DEFAULT_MAX_DIRS);

    // Regular random subdir
    if (nDirIndex < _mmFile->GetDirCount())
    {
        _mmFile->IncrementFileCount(nDirIndex);
        return TRUE;
    }
    // Not a directory.
    else if (nDirIndex == NOT_A_CACHE_SUBDIRECTORY)
    {
        //INET_ASSERT(FALSE);
        //return FALSE;
        // May be an absolute path EDITED_CACHE_ENTRY so pass
        return TRUE;
    }

    // Otherwise this had better be an installed directory.
    INET_ASSERT(nDirIndex == INSTALLED_DIRECTORY_KEY);
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Cleanup()
{

    CHAR szPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szPath, _mmFile->GetFullPathName(), cb+1);

    if (!AppendSlashIfNecessary(szPath, &cb))
        return FALSE;

    memcpy(szPath + cb, "*.*", sizeof("*.*"));

    WIN32_FIND_DATA fd;

    HANDLE handle = FindFirstFile(szPath, &fd);

    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            && (strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..")))
        {
            memcpy(szPath + cb, fd.cFileName, strlen(fd.cFileName) + 1);

            // Only delete directory if it is a valid subdirectory.
            if (IsValidCacheSubDir(szPath))
            {
                if (_mmFile->GetDirIndex(szPath) == NOT_A_CACHE_SUBDIRECTORY)
                {
                    DisableCacheVu(szPath);
                    if (DeleteCachedFilesInDir(szPath) == ERROR_SUCCESS)
                    {
                        SetFileAttributes(szPath, FILE_ATTRIBUTE_DIRECTORY);
                        RemoveDirectory(szPath);
                    }
                }
            }
        }
    } while (FindNextFile(handle, &fd));


    FindClose(handle);

  return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::GetDirIndex
Returns index of random cache subdirectory from an absolute file path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetDirIndex(LPSTR szAbsPath, LPDWORD pnIndex)
{
    BOOL fReturn = FALSE;
    DWORD idx;

    INET_ASSERT(pnIndex);

    if (szAbsPath && *szAbsPath)
    {
        // First look in mem map file for regular dir.
        idx = _mmFile->GetDirIndex(szAbsPath);

        // If didn't find it in the mem map file,
        // check if it is the storage directory.
        if (idx == NOT_A_CACHE_SUBDIRECTORY)
        {
            // First we need to find the path to the file sans \filename.ext
            DWORD cbAbsPath = strlen(szAbsPath);
            LPSTR ptr = StrRChr(szAbsPath, szAbsPath + cbAbsPath, DIR_SEPARATOR_CHAR);
            if (ptr)
            {
                // Separate path from filename and attempt to map.
                // Note - trailing slash is included in path mapped.
                DWORD cbPath = (DWORD) (ptr - szAbsPath + 1);   // 64BIT
                if (MapStoreKey(szAbsPath, &cbPath, &idx, MAP_PATH_TO_KEY))
                {
                    *pnIndex = idx;
                    fReturn = TRUE;
                }
                // Must be an EDITED_CACHE_ENTRY set at an absolute path so just update the idx and fail
                else
                {
                    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
                }
            }
        }

        // Otherwise, this should be a valid cache subdirectory.
        else
        {
            *pnIndex = idx;
            fReturn = TRUE;
        }
    }
    else
    {
        *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    }
    
    return fReturn;
}



/*-----------------------------------------------------------------------------
CSecFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                       LPSTR szAbsPath, LPDWORD pcb)
{
    DWORD cbSubDirPath, cbFile;

    INET_ASSERT(pEntry && szAbsPath && pcb && *pcb);
    
    // Get file name and length - eg "default.html"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);
    cbFile = strlen(szFile);
    
    // Make real time check?
    if (cbFile && (cbFile < MAX_PATH))
    {
        // Does entry reside in on of the random subdirs?
        if (pEntry->DirIndex != NOT_A_CACHE_SUBDIRECTORY 
            && pEntry->DirIndex < DEFAULT_MAX_DIRS)
        {
            // Path length.
            DWORD cbFull = _mmFile->GetFullPathNameLen();

            // Don't overflow output buffer.
            cbSubDirPath =
                  cbFull
                + DIR_NAME_SIZE
                + sizeof(DIR_SEPARATOR_STRING) - 1
                + cbFile;

            if (cbSubDirPath + 1 > *pcb)
            {
                // INET_ASSERT(FALSE);
                return FALSE;
            }

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\"
            memcpy(szAbsPath, _mmFile->GetFullPathName(), cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7"
            _mmFile->GetDirName(pEntry->DirIndex, szAbsPath + cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof (DIR_SEPARATOR_STRING));

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\default.htm"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE + sizeof(DIR_SEPARATOR_STRING) - 1, szFile, cbFile + 1);
        }
     
        // There is no cache subdirectory which has been can be mapped
        // from the index. See if there is an existing store mapping.
        else
        {

            if (pEntry->DirIndex == NOT_A_CACHE_SUBDIRECTORY) 
            // Assume an ECE absolute path item as AddURL only writes NACS entries with ECE set
            {
                cbSubDirPath = cbFile + 1;  // Add terminator to size
                if (cbSubDirPath > *pcb)
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
                memcpy(szAbsPath, szFile, cbSubDirPath);
            }
            else
            {

                INET_ASSERT(pEntry->DirIndex == INSTALLED_DIRECTORY_KEY);
        
                DWORD cbPath = 0;
                DWORD dwIndex = INSTALLED_DIRECTORY_KEY;
                if (MapStoreKey(szAbsPath, &cbPath, &dwIndex, MAP_KEY_TO_PATH))
                {
                    // "C:\Winnt\Web\"
                    cbSubDirPath = cbPath + cbFile;
                    if (cbSubDirPath + 1 > *pcb)
                    {
                        INET_ASSERT(FALSE);                
                        return FALSE;
                    }
                    // "C:\Winnt\Web\default.html"
                    memcpy(szAbsPath + cbPath, szFile, cbFile + 1);
                }
                else
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
            }            
            
        }

        // Hand out the absolute path to the file.
        *pcb = cbSubDirPath;
        
        return TRUE;
    }

    INET_ASSERT(FALSE);
    return FALSE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::DeleteOneCachedFile
Deletes one cache file and decrements the file count.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                         DWORD dostEntry, DWORD nDirIndex)
{
    if (!::DeleteOneCachedFile(lpszFileName, dostEntry))
        return FALSE;

    INET_ASSERT(nDirIndex != NOT_A_CACHE_SUBDIRECTORY);
    _mmFile->DecrementFileCount(nDirIndex);

    return TRUE;
}



//
//==================== CSecFileMgr Protected Functions =======================
//



/*-----------------------------------------------------------------------------
CSecFileMgr::CreateRandomDirName
Creates a random subdirectory name under the root container path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateRandomDirName(LPSTR szDirName)
{
    DWORD RandNum;
    LPSTR ptr = szDirName;
    static Counter;

    INET_ASSERT(szDirName);

    // Stolen from MakeRandomFileName.
    for (DWORD i = 0; i < DIR_NAME_SIZE; i++)
    {
        UINT digit;
        RandNum = (GetTickCount() * rand()) + Counter++;

        // 10 digits + 26 letters
        digit = RandNum % 36;
        *ptr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *ptr = '\0';

    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateAdditionalSubDirectories
Creates nAdditionalDirs random subdirectories, up to DEFAULT_MAX_DIRS.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateAdditionalSubDirectories(DWORD nAdditionalDirs)
{
    DWORD nTotalDirs;
    DWORD nDirCount = _mmFile->GetDirCount();
    BOOL bSuccess = TRUE;

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    // Don't create more than the max allowed dirs.
    nTotalDirs = nAdditionalDirs + nDirCount;
    INET_ASSERT(nTotalDirs <= DEFAULT_MAX_DIRS);

    // Create the dir and set the file count to 0.
    DWORD i = nDirCount;
    DWORD nTotalTries = 0;
    do
    {
        if (CreateSubDirectory(i))
        {
            _mmFile->SetFileCount(i, 0);
            _mmFile->IncrementDirCount();
            i++;
        }
        else
        {
            INET_ASSERT(FALSE);
            bSuccess = FALSE;
        }

        if (nTotalTries++ > 100)
        {
            bSuccess = FALSE;
            break;
        }

    } while (i < nTotalDirs);

    return bSuccess;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateSubDirectory(DWORD nIdx)
Actual creation of subdirectory.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateSubDirectory(DWORD nIdx)
{
    CHAR szCacheDir[MAX_PATH];
    CHAR szSubDir[DIR_NAME_SIZE + 1];

    // Generate full path to random dir.
    CreateRandomDirName(szSubDir);
    DWORD cb = _mmFile->GetFullPathNameLen();

    memcpy(szCacheDir, _mmFile->GetFullPathName(), cb);
    memcpy(szCacheDir + cb, szSubDir, DIR_NAME_SIZE + 1);

    // Create the directory and add it to
    // the list of directories in the index.
    if (CreateDirectory(szCacheDir, NULL))
    {
        _mmFile->SetDirName(nIdx, szSubDir);

        // For cachevu must be hidden and system.
        // BUGBUG - sure it must be hidden?
        SetFileAttributes(szCacheDir, FILE_ATTRIBUTE_SYSTEM);

        if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
           EnableCacheVu(szCacheDir);

    }
    else
    {
        // Couldn't create the directory.
        INET_ASSERT(FALSE);
        return FALSE;
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::FindMinFilesSubDir
Determines the cache subdirectory with the minimum file count for load balancing.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::FindMinFilesSubDir(DWORD& nMinFileDir, DWORD& nFiles)
{
    DWORD nDirCount = _mmFile->GetDirCount();

    if (nDirCount == 0 || nDirCount > DEFAULT_MAX_DIRS)
    {
        INET_ASSERT(FALSE);
        _mmFile->SetDirCount(0);
        CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
        nDirCount = _mmFile->GetDirCount();
    }

    nMinFileDir = 0;
    DWORD nMinFiles = _mmFile->GetFileCount(0);

    for (DWORD i = 1; i < nDirCount; i++)
    {
        if (_mmFile->GetFileCount(i) < nMinFiles)
        {
            nMinFiles = _mmFile->GetFileCount(i);
            nMinFileDir = i;
        }

    }
    nFiles = _mmFile->GetFileCount(nMinFileDir);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\downsize.cxx ===
/*++
Copyright (c) 1997  Microsoft Corp.

Module Name: downsize.cxx

Abstract:

    Implementation of heuristic pruning and wholesale purge of cache index.

Author:

    Rajeev Dujari (rajeevd) 15-Apr-97

    RajeevD rewrote scoring and pruning algo, Aug-98.

--*/

#include <cache.hxx>

#ifdef BETA_LOGGING
#define SCAVENGER_TRACE
#define TRACE_FACTOR 99
#endif


BOOL // whether memory mapped index file was deleted
URL_CONTAINER::DeleteIndex (void)
{                                        
    BOOL fRetVal = FALSE;
    BOOL fMustUnlock;

    // Get the full path name of the cache directory.
    if (!LockContainer(&fMustUnlock))
        goto exit;

    CHAR szFullPath[MAX_PATH];
    memcpy(szFullPath, _UrlObjStorage->GetFullPathName(),
        _UrlObjStorage->GetFullPathNameLen() + 1);

    if (fMustUnlock)
    {
        UnlockContainer();
        fMustUnlock = FALSE;
    }

    // Delete the cache files not in use (index.dat is open by us)
    CFileMgr::DeleteCache (szFullPath);

    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(szFullPath);


    if (!LockContainer(&fMustUnlock))
        goto exit;

#ifdef NUKE_CACHE_INDEX_FILE

    // If no handles are actively in use by this process,
    // attempt to shrink the index file.
    if (!AnyFindsInProgress(0) && !GlobalRetrieveUrlCacheEntryFileCount)
    {

        LONGLONG qwLimit = _UrlObjStorage->GetCacheLimit();
        fRetVal = _UrlObjStorage->Reinitialize();
        if (fRetVal)
        {
            _UrlObjStorage->SetCacheLimit (qwLimit);
            _FileManager->Init();
            // BUGBUG: call SetCacheSize with total not deleted by DeleteCache.

        }
    }

#endif

exit:
    if (fMustUnlock)
        UnlockContainer();
    return fRetVal;
}

// Weightings of various score components...
#define IDLETIME_WEIGHT     (60000)
#define EXPIRY_WEIGHT       ( 3000)
#define NUMACCESS_WEIGHT    ( 3000)

/*=======================================================================
ScoreEntry computes the score for the given url entry.

    The lower the score the more likely is an entry to be
    removed from the cache. Entries with higher scores are
    considered more useful.  Only the relative values matter.

    The components that contribute to the score are as follows...
        idle time since last access
        number of times accessed
        expiry, last-modified, and other sync factors
    They are weighted so that idle time predominates if the
    item has been accessed recently while older items are
    more easily influenced by the other factors.

    IDLE TIME is measured as number of days since last access,
    not rounded to an integer but including a fraction.  Then
    the score decays as 1/(days+1).  To illustrate:

        Elapsed Time    Rel. Score
        ============    ==========
        0                   60
        12 hours            40
        1 day               30
        1.5 days            24
        2 days              20
        5 days              10
        9 days               6
        29 days              2
        30-59 days           1
        60+ days             0

    NUMBER OF TIMES ACCESSED is a predictor of both the likelihood
    the item will ever be accessed again and the frequency of future
    access.  This subscore is scaled by (1 - 1/num).  For example:

        Num         Rel. Score
        ===         ==========
         1               0
         2              10
         4              15
        10              18
        20+             20

    EXPIRY in the future is worth full credit because we need
    not issue if-modified-since requests (except upon refresh.)

    Similarly, an item which is approaching SYNCSTATE_VOLATILE
    gets checked rarely and gets nearly full credit.  Items on
    the way to approaching this state get pro-rated credit.

    An expiry in the past is treated same has no expiry at all.

    An item gets half credit if last-modified-time is set.
    Otherwise any net hit would download  new content so the
    cache entry is of limited value.

    To summarize:

        Expiry  LastMod SyncState   Rel. Score
        ======  ======= =========   ==========
        future  n/a     n/a             14
        other   present static          13
        other   present image            8
        other   present volatile         7
        other   none    n/a              0

    We are agnostic about file size.  Pruning a larger file means
    we reclaim a lot of disk space, but it takes longer to download.
    Small files often waste a lot of disk space on a FAT partition,
    but incur the same fixed cost as downloading a large file.

Arguments:
    pEntry :  pointer to the Url entry.
    CurrentGmtTime : Current GMT time.

Return Value: DWORD score.
=======================================================================*/
DWORD ScoreEntry
(
    URL_FILEMAP_ENTRY* pEntry,
    LONGLONG CurrentGmtTime
)
{
    INET_ASSERT(pEntry->dwSig == SIG_URL);

    // Compute scored based on days since last access.

    // We're adding 15 minutes to the CurrentGmtTime to account for the continual 
    // readjustments to the pc's internal clock; this will handle occasional blips
    // (cases when the gmt is suddenly earlier than the LastAccessedTime, for example)
    CurrentGmtTime += (15*60*FILETIME_SEC);

    LONGLONG IdleTime = CurrentGmtTime - pEntry->LastAccessedTime;

    // In case the Last Accessed Time is later than the GMT, we want to protect against
    // a negative time
    if (IdleTime < 0)
    {
        IdleTime = 0;
    }

    DWORD dwScore = (DWORD) (((LONGLONG) IDLETIME_WEIGHT * FILETIME_DAY)
        / (IdleTime + FILETIME_DAY));

#ifdef UNIX
    {
       /* We don't want to delete items that were just created.
        * On Win32, because the InternetLockRequestFile will hold onto
        * the entries. This will not work on Unix because they use
        * InternetLockRequestFile uses CreateFile, which does not really
        * lock the file on unix, because of the lack of file handles.
        * 
        * So, just like in IE4, we will give a grace period for the cache
        * item.
        */
       #define UNIX_STICKY_SCORE 0L
       if (IdleTime < (1 * 60 * (LONGLONG)10000000))
          return UNIX_STICKY_SCORE;
    }
#endif /* UNIX */

    // Add to score based on number of times accessed.
    DWORD dwAccess = pEntry->NumAccessed;
    if (!dwAccess)
    {
        INET_ASSERT (pEntry->NumAccessed);
        dwAccess = 1;
    }
    dwScore += NUMACCESS_WEIGHT - NUMACCESS_WEIGHT/dwAccess;

    // Add to score based on expiry and syncstate.
    FILETIME ftExpireTime;
    DosTime2FileTime(pEntry->dostExpireTime, &ftExpireTime);
    if (FT2LL(ftExpireTime) > CurrentGmtTime)
        dwScore += EXPIRY_WEIGHT;
    else if (pEntry->LastModifiedTime)
    {
        // Add a bonus for having a last-modified time.
        dwScore += EXPIRY_WEIGHT / 2;

        // Add more as the item approaches auto sync mode.
        INET_ASSERT (pEntry->bSyncState <= SYNCSTATE_STATIC);
        dwScore += (EXPIRY_WEIGHT * pEntry->bSyncState)
            / (2 * (SYNCSTATE_STATIC + 1));
    }

    INET_ASSERT (dwScore <=
        IDLETIME_WEIGHT + EXPIRY_WEIGHT + NUMACCESS_WEIGHT);
    return dwScore;
}


/*=======================================================================
WalkLeakList attempts to delete files that we couldn't delete earlier.
========================================================================*/
BOOL URL_CONTAINER::WalkLeakList (void)
{
    BOOL fMustUnlock;
    LockContainer(&fMustUnlock);

    // Set loop variables to head of list.
    DWORD dwPrevOffset = OffsetFromPointer(_UrlObjStorage->GetPtrToLeakListOffset());
    DWORD dwCurrOffset, dwFirstItemOffset;
    _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwCurrOffset);

    // Validate offset and block signature.
    URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
    if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
        || pEntry->dwSig != SIG_LEAK)
    {
        INET_ASSERT(dwCurrOffset==0);
        
        // Replace the bad link with a terminator.
        _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, 
                                      0);
        return fMustUnlock;
    }
    dwFirstItemOffset = dwCurrOffset;
    
    while (1)
    {
        // Extract full path of the file.
        // and attempt to delete the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];

        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            &&
            (!pEntry->NumReferences)
            &&
            (_FileManager->DeleteOneCachedFile
                (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex)))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));

            // Remove this item from the list.
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = pEntry->dwNextLeak;

            if (dwFirstItemOffset==dwCurrOffset)
            {
                _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  pEntry->dwNextLeak);
            }
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }

            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // We don't have permission to delete this entry
            dwPrevOffset = OffsetFromPointer (&pEntry->dwNextLeak);
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }
        }
    
        // If the shutdown event signalled, call it quits.
        // Also, if we've reached the end of the list, quit
        if (GlobalPleaseQuitWhatYouAreDoing || (dwCurrOffset==0))
            break;

        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
            || pEntry->dwSig != SIG_LEAK)
        {
            // Replace the bad link with a terminator.
            INET_ASSERT (FALSE);
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = 0;
            break;
        }
        pEntry->NumReferences++;

        // Relinquish the lock and time slice so other threads don't get starved.
        if (fMustUnlock)
        {
            UnlockContainer();
            fMustUnlock = FALSE;
        }

        SuspendCAP();
        Sleep (0);
        ResumeCAP();

        LockContainer(&fMustUnlock);
        _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwFirstItemOffset);
        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        pEntry->NumReferences--;
    }

    return fMustUnlock;
}

/*=======================================================================
IsUrlEntryExemptFromScavenging filters out items exempt from scavenging.

Returns BOOL: TRUE indicating the item should not be scavenged.
========================================================================*/
BOOL URL_CONTAINER::IsUrlEntryExemptFromScavenging
(
    HASH_ITEM* pItem,
    URL_FILEMAP_ENTRY* pEntry,
    DWORD dwFilter,
    LONGLONG qwGmtTime,
    GroupMgr* pgm
)
{
    // If entry points to a store directory, ignore it.
    if ((pEntry->DirIndex == INSTALLED_DIRECTORY_KEY)
    || (pEntry->CacheEntryType & EDITED_CACHE_ENTRY))
    {
        return TRUE;
    }

    // If filter==0, trash everything, son.
    if (dwFilter==0)
    {
        return FALSE;
    }
    
    // If entry type excluded by filter, ignore it.
    if (pEntry->CacheEntryType & dwFilter)
        return TRUE;

    // If not deleting all entries, check for exemption from scavenging.
    if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY)
    {
        // sticky + exemptDelta == 0 means sticky forever
        // because item must belong to non-purgeable group
        // or the cache entry type would not have sticky bit.
        if( !(pEntry->dwExemptDelta) )
            return TRUE;

        // sticky group == sticky forever! no exempt delta
        // needs to be looked.

        if( pEntry->dwGroupOffset )
        {
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                // if there are other sticky groups attached to
                // this url entry, leave this entry alone
                if(!pgm->NoMoreStickyEntryOnList(pEntry->dwGroupOffset))
                    return TRUE;
            }
            else
            {
                // single group
                // if the group attached to this url entry is
                // sticky, leave this entry alone
                GROUP_ENTRY* pGroupEntry = NULL;
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset
                    (pEntry->dwGroupOffset, pItem);
                if(pGroupEntry && IsStickyGroup(pGroupEntry->gid) )
                    return TRUE;
            }
        }

        // Skip over the item if it's within its exemption period.
        // FILETIME units are 100-ns ticks, exempt delta in seconds.

        LONGLONG qwExemptDelta = FILETIME_SEC * pEntry->dwExemptDelta;
        if (qwGmtTime < pEntry->LastAccessedTime + qwExemptDelta)
            return TRUE;
    }

    return FALSE;
}

/*=======================================================================
ScavengeItem deletes a cache entry and yields with the lock unowned.

Returns BOOL: FALSE if dll shutdown has been signalled.
========================================================================*/
BOOL URL_CONTAINER::ScavengeItem (HASH_ITEM* pItem, BOOL* pfMustUnlock)
{
    DeleteUrlEntry (HashGetEntry (pItem), pItem, SIG_DELETE);

    // If the shutdown event signalled, call it quits.
    if (GlobalPleaseQuitWhatYouAreDoing)
        return FALSE;

    // Relinquish the lock and time slice so other threads don't get starved.
    if (*pfMustUnlock)
    {
        UnlockContainer();
        *pfMustUnlock = FALSE;
    }

    SuspendCAP();
    Sleep (0);
    ResumeCAP();

    LockContainer(pfMustUnlock);
    return TRUE;
}


#define NUM_SCORE_ITEMS 100

//=======================================================================
#define FIND_MIN 1
#define FIND_MAX 0

PRIVATE SCORE_ITEM* FindMinOrMaxScoreItem
    (SCORE_ITEM* pScore, DWORD cScore, DWORD MinOrMax)
{
    INET_ASSERT (cScore);
    INET_ASSERT (MinOrMax == FIND_MIN || MinOrMax == FIND_MAX);

    SCORE_ITEM* pRet = pScore;
    DWORD dwScore = pScore->dwScore;

    for (DWORD iScore=1; iScore<cScore; iScore++)
    {
        pScore++;
        if ((dwScore < pScore->dwScore ? TRUE : FALSE) ^ MinOrMax)
        {
            pRet = pScore;
            dwScore = pScore->dwScore;
        }
    }

    return pRet;
}

//=======================================================================
PRIVATE void SwapScoreItems (SCORE_ITEM *p1, SCORE_ITEM *p2)
{
    SCORE_ITEM t;
    memcpy (&t, p1, sizeof(SCORE_ITEM));
    memcpy (p1, p2, sizeof(SCORE_ITEM));
    memcpy (p2, &t, sizeof(SCORE_ITEM));
}

//=======================================================================
PRIVATE void SortScoreItems (SCORE_ITEM* pScore, DWORD cScore)
{

    while (cScore > 1)
    {
        SCORE_ITEM *pMax =
            FindMinOrMaxScoreItem (pScore, cScore--, FIND_MAX);
        SwapScoreItems (pScore + cScore, pMax);
    }
}

//=======================================================================
void URL_CONTAINER::ScavengerDebugSpew
    (SCORE_ITEM* pScoreItem, LONGLONG* pqwDeleted)
{
    HASH_ITEM* pItem = (HASH_ITEM*)
        (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
    if (pScoreItem->dwHashValue == pItem->GetValue()
        && pScoreItem->dwHashOffset == pItem->dwOffset)
    {
        URL_FILEMAP_ENTRY* pEntry = HashGetEntry (pItem);
        char szBuf[1024];
        LPSTR pszOp;

        if (!pqwDeleted)
            pszOp = "IGNORE";
        else
        {
            pszOp = "DELETE";
            *pqwDeleted += RealFileSize (pEntry->dwFileSize);
        }

        wsprintf (szBuf, "%s %05d ", pszOp, pScoreItem->dwScore);
        OutputDebugString (szBuf);
        if (pqwDeleted)
        {
            wsprintf (szBuf, "%02d%% ", (*pqwDeleted * 100) / GetCacheLimit());
            OutputDebugString (szBuf);
        }
        PrintFileTimeInInternetFormat ((FILETIME*)
            &pEntry->LastAccessedTime , szBuf, sizeof(szBuf));
        OutputDebugString (szBuf);
        wsprintf (szBuf, " %s\n", ((LPSTR) pEntry) + pEntry->UrlNameOffset);
        OutputDebugString (szBuf);
    }
}


#ifndef SCAVENGER_TRACE
#define ScavengerTrace(x,y,z) { }
#else
#define ScavengerTrace(dwFactor, pScoreItem, pdwDel) \
    if (dwFactor==TRACE_FACTOR) {ScavengerDebugSpew(pScoreItem, pdwDel);}
#endif

/*========================================================================*/
DWORD URL_CONTAINER::FixupHandler (DWORD dwFactor, DWORD dwFilter)
{
    LOCK_CACHE();
    
    if (!g_pfnFixup)
    {
        // This is the first time we needed the handler; initialize.
        char szDll[MAX_PATH + 80];
        DWORD cbDll = sizeof(szDll);
        
        // Look up the fixup handler for the highest cache version installed.
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);
        if (ERROR_SUCCESS != roCache.GetStatus())
            goto err;
        if (ERROR_SUCCESS != roCache.GetValue (g_szFixup, (LPBYTE) szDll, &cbDll))
            goto err;
            
        LPSTR pszEntryPoint;

        // The dll name and entry point are delimited by a comma; tokenize.
        pszEntryPoint = StrChr (szDll, TEXT(','));
        if (!pszEntryPoint)
            goto err;
        *pszEntryPoint++ = 0;
        
        g_hFixup = LoadLibrary (szDll);
        if (!g_hFixup)
            goto err;
                
        g_pfnFixup = (PFN_FIXUP) GetProcAddress (g_hFixup, pszEntryPoint);
        if (!g_pfnFixup)
        {
            FreeLibrary (g_hFixup);
            goto err;
        }
    }

    UNLOCK_CACHE();
    
    return (*g_pfnFixup)
        (ENTRY_VERSION_CURRENT, _CachePath, _CachePrefix, 
        &GlobalPleaseQuitWhatYouAreDoing, dwFactor, dwFilter, NULL);

err:
    // We couldn't locate async fixup handler; fail gracefully.
    g_szFixup[0] = 0;
    UNLOCK_CACHE();
    return ERROR_INTERNET_INTERNAL_ERROR;
}


/*=======================================================================
Routine Description:

Arguments:
    Factor : amount of free space to make. Factor of 25 means delete
        sufficient files to make CacheSize <= .75 * CacheLimit.

The index does not maintain a list of items sorted by score because the cost
of scavenging would be amortized across update operations, which are
performed on a foreground thread.  Such a list would be doubly linked because
updating an item would change its score and probably change its rank.  If the
items were directly linked together, this would likely result in touching two
other random pages on update.  A lookaside list would be a better approach
but would still require hitting another page on update or increasing the size
of the lookup hash table.  Furthermore, the ranking would need to be strictly
LRU, or else we would have to a 16-bit score in the entry and an updated item
might not go to the head of the list and require some traversal.

The scavenger thread scores items on the fly.  It attempts to avoid a full
enumeration of the cache and sorting of the scores.  Instead, it attempts to
track items that fall below a cutoff score and delete the lowest-scoring
among this set, possibly before completing the enumeration.  Specifically, it
starts by enumerating 100 items and sorting them.  Since the rank of the
items is uniformly distributed, by definition, the score of the 10th lowest
item is an estimate of the 10th percentile.  Of course, deleting 10% of the
items in the cache is no guarantee 10% of disk usage will be reclaimed.
However hitting the low-water mark of 90% of cache quota is not a strict goal
and will probably get the cache under the quota.  Even if not, the scavenger
will be invoked again on the next update and establish a higher cutoff.

If this cutoff score proves to be too low, then it's possible the scavenger
will enumerate the entire cache without bringing it below quota, in which
case it will be restarted by the next cache update, probably with a higher
threshhold.  On the other hand, if the cutoff score is too high, then we
might end the enumeration early and delete some items in the 20th or even
30th percentiles.  The latter outcome seems better since we never promised to
be perfect anyway, so we bias the algorithm by picking the 20th lowest
item for the threshhold score.

Once the cutoff score is established, the enumeration continues.  The list is
not kept sorted.  If all of the items in the 100-item list are below the
cutoff, then the lowest-scoring one is deleted.  Otherwise the highest-scoring
item is merely removed from the list and forgotten.  The the next item in the
enumeration is added to the list.  If the enumeration completes without
reaching the target usage, then the lowest-scoring item is deleted until the
list is empty, even those items that fall above the cutoff, which after all was
too low.

After each file deletion, the scavenger thread yields without holding the
container lock.  Otherwise another thread wanting to acquire the lock would
block, wake up the scavenger thread, and switch back after the scavenger
unlocked.

Return Value: ERROR_SUCCESS
========================================================================*/
DWORD URL_CONTAINER::CleanupUrls(DWORD dwFactor, DWORD dwFilter)
{
    DWORD Error = ERROR_SUCCESS;

    // dwFactor must be between 1 and 100 inclusive.
    INET_ASSERT (dwFactor >= 1 && dwFactor <= 100);

    // If an uplevel fixup handler is installed, delegate.

    if (g_szFixup[0])
        return FixupHandler (dwFactor, dwFilter);
    
    // Special case purging entire container.
    BOOL fPurge = (dwFactor == 100 && dwFilter == 0);
    if (fPurge && DeleteIndex())
        return ERROR_SUCCESS;

    // First loop through the leaked files and try to delete them.
    BOOL fMustUnlock = WalkLeakList();

    // before index get nuked, we need to send out last notification
    // about the whole cache gets deleted
    DWORD dwHWnd = 0;
    DWORD dwUMsg = 0;
    DWORD dwNotifFilter = 0;

    GroupMgr gm;
    if( !gm.Init(this) )
    {
        INET_ASSERT(FALSE);
    }

    BOOL fLowDiskSpace = FALSE;
    
    _UrlObjStorage->GetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER, &dwNotifFilter);
    if( dwNotifFilter & CACHE_NOTIFY_DELETE_ALL)
    {
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_HWND, &dwHWnd);
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_MESG, &dwUMsg);
    }

    // Calculate usage goal.
    LONGLONG qwQuota = _UrlObjStorage->GetCacheLimit();
    LONGLONG qwGoal = (qwQuota * (100 - dwFactor)) / 100;
    LONGLONG qwGmtTime;
    GetCurrentGmtTime ((FILETIME*) &qwGmtTime);

    DWORDLONG dlAvail = 0;
    if (GetDiskInfo(_CachePath, NULL, &dlAvail, NULL)
        &&
        (BOOL)(dlAvail <= (DWORDLONG)GlobalDiskUsageLowerBound))
    {
        fLowDiskSpace = TRUE;
        // We'll set the goal even lower, if the disk space falls below the 4 GIG threshold
        // qwResult contains how much disk space would be available with the current goal
        LONGLONG qwResult = dlAvail + (_UrlObjStorage->GetCacheSize() - qwGoal);
        if (qwResult < (LONGLONG)GlobalDiskUsageLowerBound)
        {
            qwGoal = _UrlObjStorage->GetCacheSize() - ((LONGLONG)(GlobalDiskUsageLowerBound - dlAvail));

            // At the very least, we'll preserve 128K (about three pages)
            if (qwGoal<(LONGLONG)(128*1024))
            {
                qwGoal = (LONGLONG)(128*1024);
            }
        }
    }

#ifdef SCAVENGER_TRACE

    // If we are simulating a scavenging, we accumulate the number
    // of bytes, adjusted for cluster slop, that would be reclaimed
    // if this were for real.  By setting the usage target to 0, we
    // also stress the scavenger to see how well it selects items
    // in edge cases where we just can't seem to delete enough.

    LONGLONG qwDeleted = 0;
    if (dwFactor == TRACE_FACTOR)
        qwGoal = 0;

#endif

    SCORE_ITEM ScoreList[NUM_SCORE_ITEMS];
    DWORD cScore = 0;  // number of valid entries in score list

    DWORD dwCutoffScore = 0;

    DWORD dwEnum = GetInitialFindHandle();

    // The loop code below is organized in two parts.
    // Part 1 - enum the cache to add another item to the list.
    // Part 2 - remove an item from a list, by throwing out a
    //   a high-scoring item or deleting a low-scoring item.

    // The looping occurs in 3 phases.
    // A. Do part 1 only until there are 100 items or enum is complete.
    // B. Do part 1 and part 2 until the enum is complete.
    // C. Do part 2 only until the list is empty.
    // Note that it's possible to skip directly from phase A to C.

    while (1) // until goal is met or score list is empty
    {

        // PART 1 OF LOOP: Enumerate another item from the cache.

        HASH_ITEM* pItem = HashGetNextItem
            (_UrlObjStorage, *_UrlObjStorage->GetHeapStart(), &dwEnum, fPurge);

        if (pItem)
        {
            // Validate offset.
            if (_UrlObjStorage->IsBadOffset (pItem->dwOffset))
            {
                pItem->MarkFree();
                continue;
            }

            // Get the signature.
            FILEMAP_ENTRY* pBlock = (FILEMAP_ENTRY*)
                (((LPBYTE) *_UrlObjStorage->GetHeapStart()) + pItem->dwOffset);

            if (pBlock->dwSig != SIG_URL)
            {
                if (fPurge && (pBlock->dwSig == SIG_REDIR))
                    _UrlObjStorage->FreeEntry (pBlock);
                else
                {
                //INET_ASSERT (pBlock->dwSig == SIG_LEAK );  //commented for RAID item 33669
                }
                
                pItem->MarkFree();
                continue;
            }

            // Filter out items exempt from scavenging.
            URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) pBlock;

            // The entry should not be from an uplevel cache, or
            // we ought to be deferring to its scavenger.
            INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));
            
            if (IsUrlEntryExemptFromScavenging
                (pItem, pEntry, dwFilter, qwGmtTime, &gm))
            {
#ifdef SCAVENGER_TRACE
                if (dwFactor == TRACE_FACTOR)
                {
                    char szBuf[1024];
                    wsprintf (szBuf, "EXEMPT %s\n",
                        ((LPSTR) pEntry) + pEntry->UrlNameOffset);
                    OutputDebugString (szBuf);
                }
#endif
                continue;
            }

            // If we are deleting all items, no need to score.
            if (dwFactor==100)
            {
                if (ScavengeItem (pItem, &fMustUnlock))
                    continue;
                else
                    goto done;
            }

            // If we've fallen below the 4MB threshold, we won't exempt anything from 
            // scavenging.

            // Otherwise, we look at the size of the item. If its size is greater than
            // whatever 90% of the cache quota is (arbitrary), then we won't scavenge it
            // for this session. 

            // For all other instances, we won't scavenge items we've seen in the past
            // ten minutes.

            if (!fLowDiskSpace)
            {
                if (((LONGLONG)pEntry->dwFileSize > (LONGLONG)((LONGLONG)(qwQuota * (LONGLONG)9)/(LONGLONG)10))
                    && (dwdwSessionStartTime < pEntry->LastAccessedTime))
                    continue;
                
                if (qwGmtTime < (pEntry->LastAccessedTime + (LONGLONG)(GlobalScavengeFileLifeTime*FILETIME_SEC)))
                    continue;
            }
            
            // Otherwise score the entry.
            SCORE_ITEM* pScoreItem = ScoreList + cScore;

            pScoreItem->dwScore = ScoreEntry (pEntry, qwGmtTime);

#ifdef UNIX
            if (!pScoreItem->dwScore)
               continue;
#endif /* UNIX */

            // Add to the list.
            pScoreItem->dwItemOffset =          // 64BIT
                (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart());
            pScoreItem->dwHashValue  = pItem->GetValue();
            pScoreItem->dwHashOffset = pItem->dwOffset;

             // Check if list is full.
            if (++cScore != NUM_SCORE_ITEMS)
                continue;

            if (!dwCutoffScore)
            {
                // Establish a cutoff score.
                SortScoreItems (ScoreList, cScore);
                DWORD nIndex; // of item used as cutoff

                switch (dwFactor)
                {
                    case DEFAULT_CLEANUP_FACTOR:
#ifdef SCAVENGER_TRACE
                    case TRACE_FACTOR:
#endif
                        nIndex = NUM_SCORE_ITEMS / 5;
                        break;

                    default:
                        nIndex = (NUM_SCORE_ITEMS * dwFactor) / 100;
                        break;
                }

                dwCutoffScore = ScoreList[nIndex].dwScore;
            }
        } // end if (pItem)

        // PART 2 OF LOOP: remove an item from the list

        // If enumeration complete and list is empty, then
        // break out of the infinite loop.
        if (!cScore)
            break;

        SCORE_ITEM *pScoreItem;

        // Is the score list full?
        if (cScore == NUM_SCORE_ITEMS)
        {
            // Find the highest scoring item.
            pScoreItem = FindMinOrMaxScoreItem
                (ScoreList, NUM_SCORE_ITEMS, FIND_MAX);
            if (pScoreItem->dwScore > dwCutoffScore)
            {
                ScavengerTrace (dwFactor, pScoreItem, NULL);

                // Some of the items are above the cutoff score.
                // Remove the highest-scoring item from the list
                // by swapping it to the end and reducing count.
                cScore--;
                SwapScoreItems (pScoreItem, ScoreList + cScore);
                continue;
            }
        }

        // Either the score list isn't full or all of the items
        // are below the cutoff score.  Delete lowest scoring item.
        pScoreItem = FindMinOrMaxScoreItem (ScoreList, cScore, FIND_MIN);

        // We yield the lock between deletes, so do some sanity
        // checking before attemptint to delete the item.
        pItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
        if (pScoreItem->dwHashValue == pItem->GetValue()
            && pScoreItem->dwHashOffset == pItem->dwOffset)
        {
            ScavengerTrace (dwFactor, pScoreItem, &qwDeleted);

            if (!ScavengeItem (pItem, &fMustUnlock))
                goto done;

            // If we met our goal, call it quits.
            if (dwFactor != 100 && _UrlObjStorage->GetCacheSize() < qwGoal)
                break;
        }

        // Remove the lowest-scoring item from the list.
        cScore--;
        SwapScoreItems (pScoreItem, ScoreList + cScore);

    } // end while (1)

    if( dwHWnd && dwUMsg && IsWindow((HWND)DWORD_PTR(dwHWnd)) )
    {
        PostMessage(
            (HWND)DWORD_PTR(dwHWnd),
            (UINT)dwUMsg,
            (WPARAM)CACHE_NOTIFY_DELETE_ALL,
            (LPARAM)0
        );
    }

done:
    if (fMustUnlock)
        UnlockContainer();
    return ERROR_SUCCESS;
}

VOID CacheScavenger(LPVOID Parameter)
/*++

Routine Description:

    This function is the main  function for the cache management scavenger
    thread. This function performs verious time critical operations.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    DWORD Error;
    DWORD WaitStatus;

    //StartCAP();

    // Set a global to indicate the thread is no longer suspended.
    LOCK_CACHE();
    if (!GlobalPleaseQuitWhatYouAreDoing)
    {
        UNLOCK_CACHE();

        // Why aren't we locking in this case?
        
        // Attempt to reduce the cache usage below the quota.
        GlobalUrlContainers->CleanupUrls (NULL, DEFAULT_CLEANUP_FACTOR, 0);

        // Clear a global to indicate the scavenger thread has exited.
        InterlockedDecrement(&GlobalScavengerRunning);

        LOCK_CACHE();
    }
    UNLOCK_CACHE();

    //StopCAP();
}


void LaunchScavenger (void)
{
#ifdef unix
    INET_ASSERT(!g_ReadOnlyCaches);
#endif /* unix */

    LOCK_CACHE(); 

    // only if scavenger is not already running.
    if (!InterlockedIncrement(&GlobalScavengerRunning))
    {
        // don't fire off new thread. Just queue scavenger as work item for
        // thread pool
        SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)CacheScavenger,
                            NULL,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0
                            );
    }
    else
    {
        InterlockedDecrement(&GlobalScavengerRunning);
    }
    
    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\flock.cxx ===
#include "flock.hxx"
#include <resource.h>
#include <cache.hxx>

#undef inet_ntoa
#undef inet_addr
#undef gethostname
#undef gethostbyname
#undef gethostbyaddr

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#ifdef sunos5
extern "C" int gethostname(char*,int);
#endif

extern HANDLE MwOpenProcess(pid_t, BOOL);
extern "C" MwAtExit(void (*f)(void));

//locally used functions
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len);

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400


// lock region relative to whence starting at offset upto len bytes
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK     
  lock.l_start = offset;    //byte offset, relative to l_whence
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = len;     //#bytes (0 means to EOF)

  return( fcntl(fd, cmd, &lock) );
}

// test region for locks relative to whence starting at offset for len bytes
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK 
  lock.l_start = *offset;   //byte offset, relative to l_whence     
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = *len;        // #bytes (0 means to EOF)      

  if (fcntl(fd, F_GETLK, &lock) < 0)
    return(-1);

  if (lock.l_type == F_UNLCK)
    return(0);          // nobody has lock in this region
  else if (lock.l_type == F_RDLCK) {
    *offset = lock.l_start;
    *len = lock.l_len;
    return(lock.l_start);   // byte offset of host with read lock
  } else {          // dont support extended semantics of
    return(-1);         // write lock yet
  }
}


extern "C" void unixCleanupWininetCacheLockFile()
{
//    if(!g_ReadOnlyCaches)
        //unlink(szLockDBName);
}

BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost)
{
    int fdlockdbf, fdlock, envLen, hostbynameerr;
    off_t IPOffset=0, IPLen=0, ownIPOffset, ownIPLen;
    char *hostname, hostbynamebuf[512];
    char szLockFileName[MAX_PATH+1], szLockDBName[MAX_PATH+1];
    struct hostent hostbynameresult;
#ifdef ux10
    struct hostent_data hostentdata;
#endif

    char *pEnv = getenv("MWUSER_DIRECTORY");

    /* Don't process the ielock file for Mainwin Lite programs */
    if (MwIsInitLite())
       goto Cleanup;

    if (pEnv == 0)
    return FALSE;

    envLen = strlen(pEnv);
    if (envLen > MAX_PATH-256)
        return FALSE;

    strcpy(szLockFileName, pEnv);
    if (szLockFileName[envLen-1] != '/') {
      szLockFileName[envLen] = '/';
      szLockFileName[envLen+1] = 0x00;
    }
    strcpy(szLockDBName, pEnv);
    if (szLockDBName[envLen-1] != '/') {
      szLockDBName[envLen] = '/';
      szLockDBName[envLen+1] = 0x00;
    }
    strcat(szLockFileName, LF);
    strcat(szLockDBName, LOCKDBF);

    hostname = (char *)malloc(256*sizeof(char));
    if ((hostname == NULL) || (gethostname(hostname, 256) == -1)) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

#ifdef sunos5
    if (!(gethostbyname_r(hostname, &hostbynameresult, hostbynamebuf,
                 sizeof(hostbynamebuf), &hostbynameerr))) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
#ifdef ux10
    if (gethostbyname_r(hostname, &hostbynameresult, &hostentdata) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
    struct in_addr *ptr = (struct in_addr *)*hostbynameresult.h_addr_list;
    ownIPOffset = inet_netof(*ptr);
    ownIPLen = inet_lnaof(*ptr);

    if ((fdlock = open(szLockFileName, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlock = open(szLockFileName, O_WRONLY)) < 0) {
          *pfReadOnlyCaches = TRUE;
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        return FALSE;
      }
    }

    if (writew_lock(fdlock, 0, SEEK_SET, 0) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

    /*under this lock, now do all the examination of szLockDBName*/
    if ((fdlockdbf = open(szLockDBName, O_RDWR|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlockdbf = open(szLockDBName, O_RDWR)) < 0) {
          *pfReadOnlyCaches = TRUE;
          un_lock(fdlock, 0, SEEK_SET, 0);
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return FALSE;
      }
    }

    /* check entire file for locking */
    if ((can_writelock(fdlockdbf, &IPOffset, SEEK_SET, &IPLen)) >= 0) {
      if ((IPOffset == 0) || ((IPOffset == ownIPOffset) && (IPLen == ownIPLen))){
    // either no IE writing to cache or IE on own host writing to cache
    // (IP address is identical)..either way we have write access
    *pfReadOnlyCaches = FALSE;
    *pszLockingHost = hostname;
    //lock at "network part" position for "host part" bytes
    read_lock(fdlockdbf, ownIPOffset, SEEK_SET, ownIPLen);
    un_lock(fdlock, 0, SEEK_SET, 0);
    return TRUE;
      } else {
    //some other host writing to cache
        *pfReadOnlyCaches = TRUE;
        u_long addr = inet_addr(inet_ntoa(inet_makeaddr(IPOffset, IPLen)));
        struct hostent * hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);
        if (!hp)
          ;       //cant find hostname from offset & length of locked bytes..
        else
          *pszLockingHost = hp->h_name;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return TRUE;
      }
    } else {
      //can_writelock returned -1 with some fcntl error
      *pfReadOnlyCaches = TRUE;
      un_lock(fdlock, 0, SEEK_SET, 0);
      return FALSE;
    }

Cleanup:
    return TRUE;
}

BOOL DeleteAtomicCacheLockFile()
{
    /* Don't process for MainWin Lite programs */
    /* Right now, the code below does not make sense because all
     * we do is return TRUE. So, commenting out this code for now.
     */
#if 0
    if (MwIsInitLite())
       goto Cleanup;

Cleanup:
#endif /* 0 */
    //unlink(szLockDBName);
    return TRUE;
}

#if 0 // Back out till we get a consensus on this

BOOL CALLBACK ReadOnlyCache_DlgProc(HWND   hDlg,
                                    UINT   uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam) {
     switch (uMsg) {
            case WM_INITDIALOG:
            {
                 LPTSTR lpszMessageStr = (LPTSTR)lParam;
                 TCHAR  pszText[MAX_PATH];
                 TCHAR  pszFormattedText[MAX_PATH];

                 if (lpszMessageStr)
                 {
                    if (LoadString(GlobalDllHandle,
                                   IDS_READONLYCACHE,
                                   pszText,
                                   ARRAYSIZE(pszText))) {
                       wsprintf(pszFormattedText,pszText, lpszMessageStr);
                       SetDlgItemText(hDlg, IDC_READONLYCACHE, pszFormattedText);
                    }
                 }

                 SetFocus(GetDlgItem(hDlg, IDOK));
            }
            break;

            case WM_COMMAND:
                 switch (LOWORD(wParam))
                 {
                        case IDOK:
                        {
                             if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                                EndDialog(hDlg, 1);
                             else
                                EndDialog(hDlg, 0);
                             break;
                        }

                        default:
                             return FALSE;
                 }
                 return TRUE;
            case WM_CLOSE:
            {
                 if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                    EndDialog(hDlg, 1);
                 else
                    EndDialog(hDlg, 0);
            }
            return TRUE;
     }

     return FALSE;
}

void ShowReadOnlyCacheDialog(char* pszHostName) {
     DWORD dwError = E_FAIL;
     HKEY  hKey = NULL;
     DWORD dwValue = 0;
     DWORD dwValueType;
     DWORD dwValueSize = sizeof(DWORD);

     if ((dwError = REGOPENKEYEX(HKEY_CURRENT_USER,
                            REG_READONLYCACHE,
                            0,
                            KEY_READ|KEY_WRITE,
                            &hKey)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if ((dwError = RegQueryValueEx(hKey,
                               REG_READONLYCACHEKEY,
                               0,
                               &dwValueType,
                               (LPBYTE)&dwValue,
                               &dwValueSize)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if (dwValue)
     {
        int fRet = 0;

        if ((fRet = DialogBoxParam(GlobalDllHandle,
                              MAKEINTRESOURCE(IDD_READONLYCACHE),
                              NULL,
                              ReadOnlyCache_DlgProc,
                              (LPARAM)pszHostName)) < 0)
        {
           goto Cleanup;
        }

        /*
         * we are here, because the registry told us to show this dialog.
         * now, we check if fRet == TRUE, in which case we don't show this
     * dialog in the future. And, we update the registry.
         */

        if (fRet == 1) {
           /* ShowCacheWarning will be set to False in the registry */
           dwValue = 0;

           /*
            * we don't check for the error here, because we close the key next
            * and if we did not save successfully, we will show this dialog again
            */

           RegSetValueEx(hKey,
                         REG_READONLYCACHEKEY,
                         0,
                         dwValueType,
                         (LPBYTE)&dwValue,
                         dwValueSize);
        }
     }

Cleanup:

     if (hKey)
        REGCLOSEKEY(hKey);

     return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif

// Prototype for async fixup callback.
typedef DWORD (CALLBACK* PFN_FIXUP) 
(
    DWORD   dwVer,      // version of cache
    LPSTR   pszPath,    // directory containing index file
    LPSTR   pszPrefix,  // protocol prefix
    BOOL*   pfDetach,   // ptr. to global indicating dll shutdown
    DWORD   dwFactor,   // as passed to CleanupUrls
    DWORD   dwFilter,   // as passed to CleanupUrls
    LPVOID  lpvReserved // reserved: pass null
);

//
// global variables.
//

extern CRITICAL_SECTION GlobalCacheCritSect;
extern BOOL GlobalCacheInitialized;
extern CConMgr *GlobalUrlContainers;
#define GlobalMapFileGrowSize (PAGE_SIZE * ALLOC_PAGES)
extern LONG GlobalScavengerRunning;
extern MEMORY *CacheHeap;
extern HNDLMGR HandleMgr;
extern DWORD GlobalRetrieveUrlCacheEntryFileCount;

// globals for async fixup handler
extern char       g_szFixup[sizeof(DWORD)];
                                 // regkey to lookup fixup dll,entry point
extern HINSTANCE  g_hFixup;      // dll containing fixup handler
extern PFN_FIXUP  g_pfnFixup;    // entry point of fixup handler


#ifdef unix
extern BOOL g_ReadOnlyCaches;
extern char* gszLockingHost;
#endif /* unix */

#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\group.cxx ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:  group.hxx

Abstract:

    Manages cache group.
    
Author:
    Danpo Zhang (DanpoZ) 02-08-98
--*/

#include <cache.hxx>

GroupMgr::GroupMgr()
{
    _pContainer = NULL;
}

GroupMgr::~GroupMgr()
{
    if( _pContainer )
    {
        _pContainer->Release(FALSE);
    }
}

BOOL
GroupMgr::Init(URL_CONTAINER* pCont)
{
    BOOL fRet = TRUE;

    if( pCont )
    {
        _pContainer = pCont;
        _pContainer->AddRef();
    }
    else
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        fRet = FALSE;
    }

    return fRet;
}

DWORD
GroupMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGID);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    *pGID = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }

    if( dwFlags & CACHEGROUP_FLAG_GIDONLY )
    {
        // only needs to return GID, no group needs to be created
        *pGID = ObtainNewGID();
        if( *pGID )
            dwError = ERROR_SUCCESS;
        else
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            

        goto exit;
    }

    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // get a new gid
    *pGID = ObtainNewGID();

    if( *pGID )
    {
        // insert gid into the first available entry
        
        // set the sticky bit for non purgable group
        if( dwFlags & CACHEGROUP_FLAG_NONPURGEABLE )
        {
            *pGID = SetStickyBit(*pGID);
        }

        pGroupEntry->gid = *pGID;
        pGroupEntry->dwGroupFlags = dwFlags;
        dwError = ERROR_SUCCESS;
    } 
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::CreateDefaultGroups()
{
    
    INET_ASSERT(_pContainer);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwOffsetHead = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }

    if(    GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetHead)
        && dwOffsetHead )
    {
        BOOL fBadHead = FALSE;

        // dwOffsetHead may point to a page which has not actually mapped in
        if( _pContainer->_UrlObjStorage->IsBadGroupOffset(dwOffsetHead) ) 
        {
            fBadHead = TRUE;
        }
        else
        {
            
            // if offset is too big, invalid
            FILEMAP_ENTRY* pFM = NULL;

            pFM = (FILEMAP_ENTRY*) 
                    (*_pContainer->_UrlObjStorage->GetHeapStart() + 
                    dwOffsetHead - sizeof(FILEMAP_ENTRY) );                                   
            if(pFM->dwSig != SIG_ALLOC || !pFM->nBlocks )
            {
                fBadHead = TRUE;
            }
        }
            
        if( fBadHead )
        {
            // dwOffsetHead is invalid, reset!
            SetHeaderData(CACHE_HEADER_DATA_ROOTGROUP_OFFSET, 0);
        }
    }

    // if already created, just return success
    dwError = FindEntry(CACHEGROUP_ID_BUILTIN_STICKY, &pGroupEntry, FALSE);
    if( dwError == ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // not found, need to create new default groups
    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // set the sticky bit for non purgable group
    pGroupEntry->gid = CACHEGROUP_ID_BUILTIN_STICKY;
    pGroupEntry->dwGroupFlags = CACHEGROUP_FLAG_NONPURGEABLE;
    dwError = ERROR_SUCCESS;
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid);

    BOOL                fMustUnlock;
    DWORD               dwError;
    GROUP_ENTRY*        pGroupEntry = NULL;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               hUrlFindHandle = 0;
    URL_FILEMAP_ENTRY*  pUrlEntry = 0;
    DWORD               dwFindFilter;
    HASH_ITEM*          pItem = NULL; 


    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }


    // find the first available entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }
     

    // Look for all the url associated with this group
    // mark the groupid to 0
    hUrlFindHandle = _pContainer->GetInitialFindHandle();       

    // set up find filter (do not care about cookie/history)
    dwFindFilter = URLCACHE_FIND_DEFAULT_FILTER 
                    & ~COOKIE_CACHE_ENTRY 
                    & ~URLHISTORY_CACHE_ENTRY;
    
    //
    // loop find all url belongs to this group
    // WARNING: this can be slow!
    //
    do 
    {
        // next url in this group
        pUrlEntry = (URL_FILEMAP_ENTRY*)
                        _pContainer->_UrlObjStorage->FindNextEntry( 
                                &hUrlFindHandle, dwFindFilter, gid); 

        if( pUrlEntry )
        {
            INET_ASSERT(hUrlFindHandle);
            pItem = (HASH_ITEM*)(
                    (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart() +
                    hUrlFindHandle );

            if( pItem->HasMultiGroup() )
            {
                //
                // examing the group list and remove this group
                // from the list
                //
                DWORD       dwNewHeaderOffset       = pUrlEntry->dwGroupOffset;
                DWORD       dwGroupEntryOffset      = PtrDiff32(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                //
                // find the to be deleted group entry in the list
                // of groups associated with this url, we need to
                // fix this by removing the to be dead group from 
                // the list
                //
                DWORD Error = RemoveFromGroupList(
                    pUrlEntry->dwGroupOffset, 
                    dwGroupEntryOffset,
                    &dwNewHeaderOffset 
                );
                    
            
                //
                // found the entry and head offset has been changed
                //
                if( Error == ERROR_SUCCESS && 
                    dwNewHeaderOffset != pUrlEntry->dwGroupOffset )
                {
                    pUrlEntry->dwGroupOffset = dwNewHeaderOffset;
               
                    // 
                    // no more group associated with this url 
                    // let's update the hash flags 
                    //
                    if( !dwNewHeaderOffset )
                    {
                        pItem->ClearMultGroup();
                        pItem->ClearGroup();
                    }
                }

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {
                    //
                    // unset sticky bit for this url IFF 
                    // 1) we are about to delete the last group of this url
                    // 2) there is no more sticky group associated with this
                    //    url other than the to be deleted group
                    //
                    if( !pUrlEntry->dwGroupOffset ||
                        (  pUrlEntry->dwGroupOffset &&
                           NoMoreStickyEntryOnList(pUrlEntry->dwGroupOffset)))
                    {
                    
                        _pContainer->UpdateStickness(
                            pUrlEntry,
                            URLCACHE_OP_UNSET_STICKY,
                            hUrlFindHandle        
                        );
                    }
                }
            }
            else
            {
                //
                // do not move the url entry now, so we just
                // need to reset the GroupOffset and re-exam the
                // stick bit
                //
                pUrlEntry->dwGroupOffset = 0;

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {

                    _pContainer->UpdateStickness(
                        pUrlEntry,
                        URLCACHE_OP_UNSET_STICKY,
                        hUrlFindHandle        
                    );
                }

            }


            if( dwFlags & CACHEGROUP_FLAG_FLUSHURL_ONDELETE)
            {
                //
                // Container's DeleteUrlEntry method takes two 
                // param, the url entry and hash item.
                // The hUrlFindHandle actually contains the
                // offset of the Hash Item, so we can get 
                // the hash item from there. 
                //

                // if this url belongs to other groups, 
                // do not delete it
                if( !pItem->HasMultiGroup() )
                {
                    _pContainer->DeleteUrlEntry(pUrlEntry, pItem, SIG_DELETE);
                }
            }

        } // find next url
    } while( pUrlEntry);
                    
    // if data entry exists, we should free them as well 
    if( pGroupEntry->dwGroupNameOffset )
    {
        dwError = FindDataEntry(pGroupEntry, &pData, FALSE); 
        if( dwError == ERROR_SUCCESS )
        {
            FreeDataEntry(pData);
        }
    }

    memset(pGroupEntry, 0, sizeof(GROUP_ENTRY) );
    dwError = ERROR_SUCCESS;

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}



DWORD
GroupMgr::GetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pOutGroupInfo, 
    DWORD*                              pdwOutGroupInfoSize
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid && pOutGroupInfo && pdwOutGroupInfoSize);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR; 
        goto exit;    
    }

    
    *pdwOutGroupInfoSize = 0;

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE); 
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // init out param
    memset(pOutGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );

    // copy over GROUP_ENTRY -> GROUP_INFO
    Translate(
            dwAttrib,
            pOutGroupInfo, 
            pGroupEntry, 
            GROUP_ENTRY_TO_INFO, 
            pdwOutGroupInfoSize 
    ); 
    dwError = ERROR_SUCCESS; 

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::SetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pGroupInfo 
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupInfo && gid);

    BOOL  fMustUnlock;
    DWORD dwError;
    GROUP_ENTRY* pGroupEntry;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = GetLastError();
        goto Cleanup;    
    }

    pGroupEntry = NULL;

    INET_ASSERT(pGroupInfo);

    if( dwAttrib & ~(CACHEGROUP_READWRITE_MASK) ) 
    {
        //
        // read only fields are being requested
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) &&
        (strlen(pGroupInfo->szGroupName) >= GROUPNAME_MAX_LENGTH ) ) 
    {
        //
        // name too long, exceed the buffer limit 
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // copy over GROUP_INFO -> GROUP_ENTRY
    Translate(
            dwAttrib,
            pGroupInfo, 
            pGroupEntry, 
            GROUP_INFO_TO_ENTRY, 
            0 
    ); 
    dwError = ERROR_SUCCESS;
    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError; 
}


DWORD
GroupMgr::GetNextGroup(
    DWORD*                          pdwLastItemOffset, 
    GROUPID*                        pOutGroupId
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pOutGroupId);

    BOOL            fMustUnlock;
    BOOL            fEndOfGroups;
    GROUP_ENTRY*    pGroupEntry;
    DWORD           dwNewOffset;
    DWORD           dwError;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        fEndOfGroups = TRUE;
        goto Cleanup;    
    }

    pGroupEntry = NULL;
    dwNewOffset = 0;
    fEndOfGroups = FALSE;

    if( *pdwLastItemOffset == 0 )
    {
        // get root
        dwError = FindRootEntry(&pGroupEntry, FALSE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // new find and we can not get the root entry
            // this means there are no group at all. 
            //
            fEndOfGroups = TRUE;
            goto Cleanup;
        }
    } // IF: no previous offset, this is a new Find 

    else if( *pdwLastItemOffset == OFFSET_NO_MORE_GROUP )
    {
        // this group of search has completed already
        fEndOfGroups = TRUE;
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } // ELSE IF: previous FindNext has already reached the end of the groups 

    else
    {
        //
        // use the offset to jump to the last returned item's entry  
        //
        pGroupEntry = (GROUP_ENTRY*) 
            (*_pContainer->_UrlObjStorage->GetHeapStart() + *pdwLastItemOffset);                                   
        //
        // one step forward 
        //
        INET_ASSERT(pGroupEntry);                      // can't be null
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) ); // can't be index item
        pGroupEntry++;

    } // ELSE: walk to the item which has been returned by previous FindNext()


    // loop for next entry 
    while(pGroupEntry)
    {
        //
        // if this entry is the last one of the page
        // it contains offset pointing to the next page
        //
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use dwFlags to indicating if
            // this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                //
                // walk to next page
                //
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart() 
                          + pGroupEntry->dwGroupFlags );                                   
            } // IF: index entry point to next page

            else
            {
                //
                // we are done 
                //
                fEndOfGroups = TRUE;
                dwError = ERROR_FILE_NOT_FOUND;
                break; 

            } // ELSE: index page contains nothing (this is the last page)

        } // special case: current entry is the index(point to next page)


        // 
        // using gid to test if the entry is empty, if not, 
        // walk to the next entry  
        //
        if( !pGroupEntry->gid )
        {
            pGroupEntry++;
        } 
        else
        {
            break;    
        }

    } // while(pGroupEntry)
    

Cleanup:
    // update LastItemOffset
    if (!fEndOfGroups
        && pGroupEntry)
    {
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        dwNewOffset = PtrDiff32(pGroupEntry, lpbBase);
        *pdwLastItemOffset = dwNewOffset;

        // copy over GROUP_ENTRY -> GROUP_INFO
        *pOutGroupId = pGroupEntry->gid;
        dwError = ERROR_SUCCESS;

    } // IF:  find the item

    else
    {
        *pdwLastItemOffset = OFFSET_NO_MORE_GROUP;
        dwError = ERROR_FILE_NOT_FOUND;
    } // ELSE: not find 

    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::FindRootEntry(
    GROUP_ENTRY** ppOut,        // OUT: first empty entry
    BOOL fCreate                // allocate new page if needed
)
{
    INET_ASSERT(ppOut);
    *ppOut = NULL;
    
    GROUPS_ALLOC_FILEMAP_ENTRY* pPage = NULL;
    DWORD                       dwError;
    DWORD                       dwOffsetToRootEntry = 0;

    // get base offset 
    if( GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetToRootEntry))
    {
        if( !dwOffsetToRootEntry && fCreate )
        {
            dwError = CreateNewPage(&dwOffsetToRootEntry, TRUE);

            if( dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        } 
        else if( !dwOffsetToRootEntry && !fCreate )
        {
            //
            // there is no offset infomation on the mem file 
            // however, the flag says do not create a new page
            // failure is the only option here
            //
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        } 

    } // IF: retrieve base offset

    else
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 

    } // ELSE: failed to get base offset
    

    // 
    // At this point, we should either:
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetToRootEntry );
    *ppOut =  (GROUP_ENTRY*) 
        ( *_pContainer->_UrlObjStorage->GetHeapStart() + dwOffsetToRootEntry);                                   
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError; 
}



DWORD
GroupMgr::FindEntry(
    GROUPID         gid,          // gid, 0 means find first empty seat
    GROUP_ENTRY**   ppOut,        // OUT: entry with gid specified
    BOOL            fCreate       // allocate new page if needed 
                                  // (applied for searching empty seat only)
)
{
    INET_ASSERT(ppOut);

    // fCreate can only be associated with gid == 0
    INET_ASSERT( (fCreate && !gid ) || (!fCreate && gid ) );

    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwError;

    // get Root Entry
    dwError = FindRootEntry(&pGroupEntry, fCreate);
    if( dwError != ERROR_SUCCESS )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    } // failed to get the root entry


    INET_ASSERT(pGroupEntry); // pGroupEntry should be available now

    while(1)
    {
        // special case for end of this page
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use the dwFlags to indicating
            // if this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                // walk to next page
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pGroupEntry->dwGroupFlags );

            } // IF: index entry points to next page
    
            else if( fCreate)
            {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                DWORD dwOffsetToFirstEntry = 0;
                LPBYTE  lpbBase = NULL;

                // remember the old offset for pGroupEntry
                DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                // create new page!
                dwError = CreateNewPage(&dwOffsetToFirstEntry, FALSE);
                if( dwError != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                // recalculate pGroupEntry using the offset remembered 
                lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                //
                // pGroupEntry currently is the index item, insert 
                // the offset of the first item to the newly created page
                //
                pGroupEntry->dwGroupFlags = dwOffsetToFirstEntry;

                // walk to the new page 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwOffsetToFirstEntry);


            } // ELSE IF: index entry not point to new page, fCreate is
              //          set, a new page is being created  

            else
            {
                // this is the end of all groups, item still not found, 
                dwError = ERROR_FILE_NOT_FOUND;
                break;

            } // ELSE: index entry not point to new page, fCreate not set

        } // IF: this entry is an index entry


        //
        // now pGroupEntry must point to a normal group entry 
        //
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) );

        if( pGroupEntry->gid != gid )
        {
            // not found, walk to next entry
            pGroupEntry++;
        } 
        else
        {
            // found entry
            dwError = ERROR_SUCCESS;
            break;    
        }

    } // WHILE: (loop over all page)

    
Cleanup:
    if( dwError == ERROR_SUCCESS )
    {
        *ppOut = pGroupEntry;
    }
    else
    {
        *ppOut = NULL;
    }

    return dwError;
}

DWORD
GroupMgr::CreateNewPage(DWORD* dwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *dwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // mark the last entry as index to next page
        // (gid == GID_INDEX_TO_NEXT_PAGE) is the mark, 
        // the actual offset is stored at dwGroupFlags field
        //
        GROUP_ENTRY*    pEnd = (GROUP_ENTRY*) pPage->pGroupBlock;
        pEnd = pEnd + (GROUPS_PER_PAGE - 1);
        pEnd->gid = GID_INDEX_TO_NEXT_PAGE;

        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOTGROUP_OFFSET, *dwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *dwOffsetToFirstEntry = 0;
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }

        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



GROUPID
GroupMgr::ObtainNewGID()
{
    SYSTEMTIME  st;
    DWORD   dwC[2] = {0, 0};
    GROUPID gid = 0;

    // get counter from index file
    if( GetHeaderData(CACHE_HEADER_DATA_GID_LOW,  &dwC[0]) &&
        GetHeaderData(CACHE_HEADER_DATA_GID_HIGH, &dwC[1]) )
    {
        if( !dwC[0] && !dwC[1] )
        {
            // need to get the current system time
            GetSystemTime( &st );
            SystemTimeToFileTime(&st, (FILETIME*)dwC);

        } // IF: counter not initialized 

        else
        {
            // increment
            if( dwC[0] != 0xffffffff )
            {
                dwC[0] ++;
            }
            else
            {
                dwC[0] = 0;
                dwC[1] ++;
            }
        } // ELSE: counter initialized

        // send data back to cache
        if( SetHeaderData(CACHE_HEADER_DATA_GID_LOW,  dwC[0] ) &&
            SetHeaderData(CACHE_HEADER_DATA_GID_HIGH, dwC[1] ) ) 
        {
            //memcpy(&gid, dwC, sizeof(GROUPID) );
            gid = *((GROUPID *)dwC); 
        } 
    } 
    
    // apply the mask to newly created gid
    // the first 4 bits are reserved (one bit is used for stickness)  
    return (gid & GID_MASK); 
}


BOOL
GroupMgr::Translate(
    DWORD                           dwAttrib,
    INTERNET_CACHE_GROUP_INFOA*     pGroupInfo,
    GROUP_ENTRY*                    pGroupEntry, 
    DWORD                           dwFlag,
    DWORD*                          pdwSize                           
) 
{
    INET_ASSERT(pGroupInfo && pGroupEntry);
    BOOL fRet = TRUE;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               dwError;

    if( dwFlag == GROUP_ENTRY_TO_INFO )
    {
        INET_ASSERT(pdwSize);

        // clear
        memset(pGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );
        *pdwSize = 0;

        // basic entries 
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_BASIC )
        {
            pGroupInfo->dwGroupSize  = sizeof(INTERNET_CACHE_GROUP_INFOA);
            pGroupInfo->dwGroupFlags = pGroupEntry->dwGroupFlags;
            pGroupInfo->dwGroupType  = pGroupEntry->dwGroupType;
            pGroupInfo->dwDiskUsage  = (DWORD)(pGroupEntry->llDiskUsage / 1024);
            pGroupInfo->dwDiskQuota  = pGroupEntry->dwDiskQuota;
        }
        
        // user friendly name
        if( ( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
              (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  ) &&
              pGroupEntry->dwGroupNameOffset ) 
        {
            dwError = FindDataEntry(pGroupEntry, &pData, FALSE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                DWORD dwLen = strlen(pData->szName) + 1;
                INET_ASSERT( dwLen > GROUPNAME_MAX_LENGTH );

                memcpy( pGroupInfo->szGroupName, 
                        pData->szName, 
                        dwLen );

                memcpy( pGroupInfo->dwOwnerStorage,
                        pData->dwOwnerStorage, 
                        sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
            }
        }

        // set size
        *pdwSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    }

    else 
    if( dwFlag == GROUP_INFO_TO_ENTRY )
    {
        // copy
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_FLAG )
        {
            pGroupEntry->dwGroupFlags = pGroupInfo->dwGroupFlags;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_TYPE )
        {
            pGroupEntry->dwGroupType = pGroupInfo->dwGroupType;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_QUOTA )
        {
            pGroupEntry->dwDiskQuota = pGroupInfo->dwDiskQuota;
        }

        if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
            (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  )
        {

            dwError = FindDataEntry(pGroupEntry, &pData, TRUE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                
                if( dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME )  
                {
                    DWORD dwLen = strlen(pGroupInfo->szGroupName) + 1;
                    INET_ASSERT(dwLen > GROUPNAME_MAX_LENGTH);

                    memcpy( pData->szName, 
                            pGroupInfo->szGroupName, 
                            dwLen );
                }

                if( dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE ) 
                {
                    memcpy( pData->dwOwnerStorage, 
                            pGroupInfo->dwOwnerStorage,
                            sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
                }


                // BUGBUG
                // if both fields are set to be empty, we should free
                // the allocated data itam 
            }
        }
    }

    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

BOOL
GroupMgr::IsPageEmpty(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY* pGroupEntry = pHead;
    for( int i = 0; i < (GROUPS_PER_PAGE - 1); i ++)
    {
        if( pGroupEntry->gid )
        {
            break;
        }
        else
        {
            pGroupEntry++;
        }
    }

    // there is no item found on this page
    if( !pGroupEntry->gid && i == GROUPS_PER_PAGE - 1 )
    {
        fRet = TRUE; 
    }


    return fRet;
}

BOOL
GroupMgr::IsLastPage(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY*    pEnd = NULL;

    // jump to last item
    pEnd = pHead + GROUPS_PER_PAGE;

    //
    // the gid has to be marked as GID_INDEX_TO_NEXT_PAGE 
    // for index entry, and if the dwGroupFlags is 0, 
    // that means we are not pointing to any
    // other page, this is the last page indeed.
    //
    if( pEnd->gid == GID_INDEX_TO_NEXT_PAGE && !pEnd->dwGroupFlags )
    {
        fRet = TRUE;
    }

    return fRet;
}


BOOL
GroupMgr::FreeEmptyPages(DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    BOOL            fMustUnlock;

    BOOL            fRet = TRUE;
    GROUP_ENTRY*    pHead = NULL;
    GROUP_ENTRY*    pPrevHead = NULL;
    GROUP_ENTRY*    pEnd  = NULL;
    GROUP_ENTRY*    pTobeDeleted = NULL;
    BOOL            fFirstPage = TRUE;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        fRet = FALSE;
        goto Cleanup;    
    }

    // BUGBUG FindRootEntry changed the return code, check for dwError
    if( FindRootEntry(&pHead, FALSE ) )
    {
        pPrevHead = pHead; 
        while(pHead)
        {
            pTobeDeleted = NULL;

            if( IsPageEmpty(pHead) )
            {
                pTobeDeleted = pHead;

                //
                // find the offset of the next page
                // 0 which means the current page is the last one
                //
                DWORD dwOffsetNextPage = 0;
                pEnd = pHead + GROUPS_PER_PAGE;
                dwOffsetNextPage = pEnd->dwGroupFlags;

                //     
                // if the first page is to be deleted, we have to 
                // update the offset which points to the next page
                //
                if( fFirstPage)
                {
                    if( !SetHeaderData(
                        CACHE_HEADER_DATA_ROOTGROUP_OFFSET, dwOffsetNextPage))
                    {
                        fRet = FALSE;
                        goto Cleanup;
                    }
                } 
                else
                {
                
                    // 
                    // Link Prev page to Next page
                    //
                    GROUP_ENTRY* pPrevEnd = pPrevHead + GROUPS_PER_PAGE;
                    pPrevEnd->dwGroupFlags = dwOffsetNextPage;  
                }
            } 
        

            //
            // update pHead make it point to the next page 
            //
            if( !IsLastPage(pHead) )
            {
                // remember pPrev
                pPrevHead = pHead;

                // walk to next page
                pEnd = pHead + GROUPS_PER_PAGE;
                pHead = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                          + pEnd->dwGroupFlags );

                // not first page anymore
                fFirstPage = FALSE;
            }
            else
            {
                // this is the last page
                pHead = NULL;
            }

            // 
            // free the tobe deleted page
            //
            if( pTobeDeleted )
            {
                GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
                pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*) ((LPBYTE)pTobeDeleted - sizeof(FILEMAP_ENTRY));

                _pContainer->_UrlObjStorage->FreeEntry(pPage);
            }
        }
    }

    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }
    return fRet;
}


DWORD
GroupMgr::FindDataEntry(
    GROUP_ENTRY*        pGroupEntry, 
    GROUP_DATA_ENTRY**  pOutData,
    BOOL                fCreate
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupEntry && pOutData );
    *pOutData = NULL;

    BOOL            fMustUnlock;
    DWORD           dwError;
    LPBYTE          lpbBase = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR; 
        goto exit;    
    }

    if( pGroupEntry->dwGroupNameOffset )
    {
        lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
        *pOutData = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);
        dwError = ERROR_SUCCESS;
    }

    else if( fCreate)
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pGroupEntry
        DWORD_PTR   dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create new data entry
        *pOutData = GetHeadDataEntry(TRUE);
        if( *pOutData )
        {
            //
            // re-calc pGroupEntry
            //
            lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
            pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

            //
            // set entry's filename offset field 
            //
            pGroupEntry->dwGroupNameOffset = PtrDiff32(*pOutData, lpbBase);

            // succeed
            dwError = ERROR_SUCCESS;
            
        }
        else
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
        }
//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    if( fCreate && (dwError == ERROR_SUCCESS) )
    {
        // for new item, it's nice to mark the next link to 0
        (*pOutData)->dwOffsetNext = 0;
    }
    return dwError;
}


VOID
GroupMgr::FreeDataEntry(GROUP_DATA_ENTRY* pDataEntry)
{
    // get the head entry 
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        return;
    }

    //
    // walk to the index item whose dwGroupNameOffset 
    // contains offset the the head of free list
    //
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // memset the freed data entry
    memset(pDataEntry, 0, sizeof(GROUP_DATA_ENTRY) );

    // make data item's next link points to current head
    pDataEntry->dwOffsetNext = pGroupEntry->dwGroupNameOffset;

    // make the current head to be the just freed item's offset 
    LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
    pGroupEntry->dwGroupNameOffset = PtrDiff32(pDataEntry, lpbBase);
}


LPGROUP_DATA_ENTRY
GroupMgr::GetHeadDataEntry(BOOL fCreate)
{
    GROUP_DATA_ENTRY*   pDataEntry = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;         
    LPBYTE              lpbBase = NULL;

    // get the head entry 
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // walk to the index item
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // the dwGroupNameOffset contains offset the the head of free list
    if( pGroupEntry->dwGroupNameOffset)
    {
        // get the head
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pDataEntry = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);

        // reset head to next one
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;
    }   

    else if( fCreate )
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

        // remember the old offset for pGroupEntry
        DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create a new page
        GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
        DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

        pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
                _pContainer->_UrlObjStorage->AllocateEntry(cbSize);

        if( !pPage )
        {
            goto exit;
        }
    
        // memset
        memset(pPage->pGroupBlock, 0, PAGE_SIZE_FOR_GROUPS);

        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 
        GROUP_DATA_ENTRY*   pHead = (GROUP_DATA_ENTRY*)pPage->pGroupBlock;
        pDataEntry = pHead;

        // init list on the newly created page
        for(int i = 0; i < GROUPS_DATA_PER_PAGE - 1; i++)
        {
            // point to next offset 
            GROUP_DATA_ENTRY* pNext = pHead + 1;
            pHead->dwOffsetNext =  PtrDiff32(pNext, lpbBase);
            pHead = pNext;
        }

        //
        // pGroupEntry needs to be re-calc! 
        //
        pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

        // 
        // pGroupEntry currently is the index entry of the first 
        // page, it's dwGroupNameOffset field points the head of 
        // the list of a free group data entry
        //
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        goto exit;
    }
    
exit:
    return pDataEntry;
}

DWORD
GroupMgr::GetOffsetFromList(DWORD dwHeadOffset, GROUPID gid, DWORD* pdwOffset)
{
    DWORD dwError;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;
    
    *pdwOffset = 0;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    while(1)
    {
        
        if(!_pContainer->_UrlObjStorage->IsBadGroupOffset(pListGroup->dwGroupOffset))
        {
            pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pListGroup->dwGroupOffset );
        }
        else
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;
        }

        if( pGroupEntry && pGroupEntry->gid == gid )
        {
            *pdwOffset = pListGroup->dwGroupOffset;
            break;
        }     

        // end of list, not found 
        if( !pListGroup->dwNext )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        }

        // walk to next
        pListGroup = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                pListGroup->dwNext); 

        if( !pListGroup )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }   
    } 

    if( *pdwOffset )    
    {
        dwError = ERROR_SUCCESS;
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

Cleanup:
    return dwError;
}


DWORD   
GroupMgr::CreateNewGroupList(DWORD* pdwHeadOffset)
{
    DWORD               dwError;
    
    // Find empty slot
    *pdwHeadOffset = 0;
    dwError = FindEmptySlotInListPage(pdwHeadOffset);
    if( ERROR_SUCCESS != dwError )
    {
        goto Cleanup;
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::AddToGroupList(DWORD dwHeadOffset, DWORD dwOffset)
{
    DWORD               dwError;
    DWORD               dwEmptySlot;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    // if the item already on the list, return success
    if( IsGroupOnList(dwHeadOffset, dwOffset) )
    {
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    if( !pListGroup->dwGroupOffset )
    {
        // list is empty, just need to fill up the Head
        pListGroup->dwGroupOffset = dwOffset;
    }
    else
    {
        // List is not empty, we have to walk to end of the list
        // also need to get another empty slot

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pListGroup
        DWORD_PTR dwpListGroupOffset = PtrDifference(pListGroup, *_pContainer->_UrlObjStorage->GetHeapStart());

        // find empty slot
        dwError = FindEmptySlotInListPage(&dwEmptySlot);
        if( ERROR_SUCCESS != dwError )
        {
            goto Cleanup;
        }


        // recalculate pListGroup using the offset remembered 
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        pListGroup = (LIST_GROUP_ENTRY*)(lpbBase + dwpListGroupOffset);

//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        
        // walk to end of list
        while( pListGroup->dwNext )
        {
            pListGroup = 
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 
            if( !pListGroup )
            {
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;
            }
        }

        // Get ListGroupEmpty Object from the empty slot
        pListGroupEmpty = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwEmptySlot); 
        if( !pListGroupEmpty )
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;
        }

        // assign the new offset
        pListGroupEmpty->dwGroupOffset = dwOffset;

        // append empty slot at the end of the list
        // this need to be done at last to prevent some invalid
        // object get on the list
        pListGroup->dwNext = dwEmptySlot;
    }


    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}

DWORD   
GroupMgr::RemoveFromGroupList(
    DWORD      dwHeadOffset, 
    DWORD      dwOffset, 
    LPDWORD    pdwNewHeadOffset
)
{
    DWORD dwError = ERROR_SUCCESS;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupPrev = NULL;
    LPBYTE              lpbBase = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

    // header is the one we need, we will have to assign new header
    if( pListGroup->dwGroupOffset == dwOffset )
    {
        // new head
        *pdwNewHeadOffset = pListGroup->dwNext;

        // empty removed head and added to free list
        pListGroup->dwGroupOffset = 0;
        pListGroup->dwNext= 0;
        AddToFreeList(pListGroup);

        // done
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( !pListGroup->dwNext )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    pListGroupPrev = pListGroup;
    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
    if( !pListGroup)
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

      
    while( pListGroup )
    {
        INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwOffset )
        {
            pListGroupPrev->dwNext = pListGroup->dwNext;

            // empty removed item and added it to free list
            pListGroup->dwGroupOffset = 0;
            pListGroup->dwNext= 0;
            AddToFreeList(pListGroup);

            dwError = ERROR_SUCCESS;
            break;
        }

        if( pListGroup->dwNext )
        {
            pListGroupPrev = pListGroup;
            pListGroup =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
        }
        else
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;

        }
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::FindEmptySlotInListPage(DWORD* pdwOffsetToSlot)
{

    DWORD   dwError;
    DWORD   dwOffsetRoot = 0;
    LPBYTE  lpbBase = NULL;
    LIST_GROUP_ENTRY*   pListGroupFreeHead = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    if( !GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 
    } 

    if( !dwOffsetRoot)
    {
        // new page needs to be created
        dwError = CreateNewListPage(&dwOffsetRoot, TRUE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;
    } 

    // 
    // At this point, we've got the root entry 
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetRoot);

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
    pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwOffsetRoot);                                   
    if( !pListGroupFreeHead )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    // get the next free item from the list
    if( !pListGroupFreeHead->dwNext )
    {
        // no free slot left!, let's create a new page!

        // remember the old offset free list head entry
        DWORD_PTR dwpFreeHeadOffset = PtrDifference(pListGroupFreeHead, lpbBase);

        // create a new page
        DWORD  dwNewList;
        dwError = CreateNewListPage(&dwNewList, FALSE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;

        // restore
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwpFreeHeadOffset);                                   
        //
        // add the newly created page contains a list of empty
        // slot (already chained together), now update the head 
        // of free list pointing to the head of the newly created
        // list
        //
        pListGroupFreeHead->dwNext = dwNewList;
    }
//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

     
    // get the empty slot offset
    *pdwOffsetToSlot = pListGroupFreeHead->dwNext;

    // update the free list to point to the next slot
    pListGroupEmpty = (LIST_GROUP_ENTRY*)(lpbBase + pListGroupFreeHead->dwNext);
    pListGroupFreeHead->dwNext = pListGroupEmpty->dwNext;
    
    memset(pListGroupEmpty, 0, sizeof(LIST_GROUP_ENTRY) );
    
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}


DWORD
GroupMgr::CreateNewListPage(DWORD* pdwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *pdwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // chain all items together  
        // (Last item will have dwNext == 0 since we have alredy memset 
        //  the whole page ) 
        //
        LIST_GROUP_ENTRY*    pList = (LIST_GROUP_ENTRY*) pPage->pGroupBlock;

        for( DWORD dwi = 0; dwi < (LIST_GROUPS_PER_PAGE -1); dwi++)
        {
            pList->dwNext = PtrDiff32(pList+1, lpbBase);
            pList++ ;
        }


        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, 
                    *pdwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *pdwOffsetToFirstEntry = 0;
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }
        
        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



BOOL    
GroupMgr::IsGroupOnList(DWORD dwHeadOffset, DWORD dwGrpOffset)
{
    BOOL    fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;

    LIST_GROUP_ENTRY   *pMilestone  = NULL; // used for detecting cycles
    unsigned long       dwNodeCount = 1;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwGrpOffset )
        {
            fRet = TRUE;
            break;
        }

        if( pListGroup->dwNext )
        {
            LIST_GROUP_ENTRY*   plgTemp =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 

            // Sometimes the list is corrupted and contains a cycle
            // This is detected by comparing against the saved pointer
            // (Revisiting an earlier milestone indicates a cycle)
            if (plgTemp==pMilestone)
                break;

            // Also check (and fix) simple self-loops
            if (plgTemp==pListGroup) 
            {
                pListGroup->dwNext = 0;
                break;
            }

            // Advance to next node
            pListGroup = plgTemp;

            // Choose new milestone when node count is power of 2
            dwNodeCount++;

            if ((dwNodeCount & (dwNodeCount-1)) == 0)
                pMilestone = pListGroup;
        }
        else
        {
            break;
        }
    }

Cleanup:
    return fRet;
}


BOOL    
GroupMgr::NoMoreStickyEntryOnList(DWORD dwHeadOffset)
{
    BOOL                fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // IsSticky?
            if( IsStickyGroup(pGroupEntry->gid) )
            {
                goto Cleanup;
            }
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            break;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

    //
    // reach here means we are at end of the list and can not find
    // any sticky group, return TRUE
    //
    fRet = TRUE;

Cleanup:
    return fRet;


}


void
GroupMgr::AdjustUsageOnList(DWORD dwHeadOffset, LONGLONG llDelta)
{
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        // INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // AdjustUsage
            _pContainer->AdjustGroupUsage(pGroupEntry, llDelta);
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            goto Cleanup;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

Cleanup:
    return;

}

void
GroupMgr::AddToFreeList(LIST_GROUP_ENTRY* pFreeListGroup)
{
    DWORD dwOffsetRoot  = 0;
    LIST_GROUP_ENTRY*   pFreeListHead = NULL;
    
    if( GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {

        pFreeListHead = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwOffsetRoot); 
   
        if( pFreeListHead && pFreeListGroup )
        {
            pFreeListGroup->dwNext = pFreeListHead->dwNext;

            pFreeListHead->dwNext = PtrDiff32(pFreeListGroup,
                                              *_pContainer->_UrlObjStorage->GetHeapStart());
        } 
    } 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains proto type definitions of several functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

extern "C"
{
    VOID CacheScavenger(LPVOID Parameter);
}

LONGLONG GetGmtTime(VOID);

DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    );

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    );

BOOL InitGlobals (void);

void LaunchScavenger (void);

DWORD
CreateUniqueFile(
    LPCSTR UrlName,
    LPTSTR Path,
    LPTSTR FileName,
    LPTSTR Extension,
    HANDLE *phfHandle
    );

#endif  // _PROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\ids.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    ids.cxx

Abstract:

    Contains functions responsible for managing identities in wininet
    
    Contents:

Author:

    July - September 1999. akabir

Environment:

    Win32 user-mode DLL

Revision History:


--*/


#include <cache.hxx>
#include <hlink.h>
#include <urlmon.h>
#include <shlobj.h>
#define HMONITOR_DECLARED    1
#include <shlobjp.h>



// -- whatever -----------------------------------------------------------------------------------------------
#undef SHGetFolderPath
HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHGETDESKTOPFOLDER)(IShellFolder**);

HRESULT _SHGetDesktopFolder(IShellFolder **psfDesktop)
{
    HMODULE h = LoadLibrary("shell32.dll");
    HRESULT hr = E_POINTER;
    if (h) 
    {
        PFNSHGETDESKTOPFOLDER pfn = (PFNSHGETDESKTOPFOLDER)GetProcAddress(h, "SHGetDesktopFolder");
        if (pfn)
        {
            hr = pfn(psfDesktop);
        }
        FreeLibrary(h);
    }
    return hr;
}

typedef VOID (*PFNILFREE)(LPITEMIDLIST);

VOID _ILFree(LPITEMIDLIST pidl)
{
    HMODULE h = LoadLibrary("shell32.dll");
    if (h) 
    {
        PFNILFREE pfn = (PFNILFREE)GetProcAddress(h, "ILFree");
        if (pfn)
        {
            pfn(pidl);
        }
        FreeLibrary(h);
    }
}


const GUID  DefaultGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const GUID  IID_IHistSFPrivate = { 0x62e1261L, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38 };


// -- Utility functions --------------------------------------------------------------------------------------

// Create an ansi representation of a guid.
VOID GuidToAnsiStr(GUID* pGuid, PSTR psz, DWORD dwSize)
{
    WCHAR   wszUid[MAX_PATH];
    StringFromGUID2(*pGuid, wszUid, ARRAY_ELEMENTS(wszUid));
    SHUnicodeToAnsi(wszUid, psz, dwSize);
}


REGISTRY_OBJ* CreateExtensiRegObjFor(HKEY hKey, GUID* pguid)
{
    REGISTRY_OBJ *pro = NULL;

    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(pguid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s\\%s", 
                              IDENTITIES_KEY, 
                              sz, 
                              EXTENSIBLE_CACHE_PATH_KEY) >= 0)
    {
        pro = new REGISTRY_OBJ(hKey, szBranches, CREATE_KEY_IF_NOT_EXISTS);
    }

    return pro;
}

#ifdef WININET6
DWORD IDRegDwordCore(LPCTSTR psz, PDWORD pdw, BOOL fSet)
{
    INET_ASSERT(GlobalIdentity);
    
    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(&GlobalIdentityGuid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    DWORD dwError = ERROR_INVALID_PARAMETER;
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s", 
                              IDENTITIES_KEY, 
                              sz) >= 0)
    {
        REGISTRY_OBJ ro(GlobalCacheHKey, szBranches);
        dwError = ro.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            dwError = fSet ? ro.SetValue((LPTSTR)psz, pdw)
                           : ro.GetValue((LPTSTR)psz, pdw);
        }
    }
    return dwError;
}

DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw)
{
    return IDRegDwordCore(psz, pdw, FALSE);
}

DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw)
{
    return IDRegDwordCore(psz, &dw, TRUE);
}
#endif


VOID CreateCurrentHistory()
{
    INTERNET_CACHE_CONFIG_INFO icci;
    icci.dwStructSize = sizeof(icci);
    if (GlobalUrlContainers->GetUrlCacheConfigInfo(&icci, NULL, CACHE_CONFIG_HISTORY_PATHS_FC)
        && SUCCEEDED(CoInitialize(NULL)))
    {
        // We want to ensure that the history is valid for this user.
        IShellFolder *psfDesktop;
        if (SUCCEEDED(_SHGetDesktopFolder(&psfDesktop)))
        {
            WCHAR wszPath[MAX_PATH];
            LPITEMIDLIST pidlHistory;
            IShellFolder *psfHistory;
            MultiByteToWideChar(CP_ACP, 0, icci.CachePath, -1, wszPath, ARRAY_ELEMENTS(wszPath));
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // trim the "content.ie5" junk
            if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL, wszPath, NULL, &pidlHistory, NULL)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pidlHistory, NULL, IID_IShellFolder, (VOID**)&psfHistory)))
                {
                    IHistSFPrivate *phsf;
                    if (SUCCEEDED(psfHistory->QueryInterface(IID_IHistSFPrivate, (void**)&phsf)))
                    {
                        FILETIME ftBogus = { 0 };
                        // This forces the validation in shdocvw
                        phsf->WriteHistory(L"", ftBogus, ftBogus, NULL);
                        phsf->Release();
                    }
                    psfHistory->Release();
                }
                _ILFree(pidlHistory);
            }
            psfDesktop->Release();
        }
        CoUninitialize();
    }
}


CONST TCHAR c_szIdentityOrdinal[] = "Identity Ordinal";

DWORD MapGuidToOrdinal(GUID* lpGUID)
{
    DWORD dwOrdinal = 0;
    HKEY    hSourceSubKey;

    if (!memcmp(lpGUID, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return 0;
    }

    if (RegCreateKey(HKEY_CURRENT_USER, IDENTITIES_KEY, &hSourceSubKey) == ERROR_SUCCESS)
    {        
        CHAR    szUid[MAX_PATH];
        GuidToAnsiStr(lpGUID, szUid, ARRAY_ELEMENTS(szUid));

        DWORD   dwSize, dwType;
        DWORD   dwIdentityOrdinal = 1;

        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        HKEY    hkUserKey;
        if (RegCreateKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                }
            }            
            RegCloseKey(hkUserKey); 
        }
        RegCloseKey(hSourceSubKey);
    }

    INET_ASSERT(dwOrdinal);
    return dwOrdinal;
}


DWORD AlterIdentity(DWORD dwFlags)
{
    if (!GlobalIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
    switch (dwFlags)
    {
    case INTERNET_IDENTITY_FLAG_PRIVATE_CACHE:
    case INTERNET_IDENTITY_FLAG_SHARED_CACHE:
    case INTERNET_IDENTITY_FLAG_CLEAR_DATA:
    case INTERNET_IDENTITY_FLAG_CLEAR_COOKIES:
    case INTERNET_IDENTITY_FLAG_CLEAR_HISTORY:
    case INTERNET_IDENTITY_FLAG_CLEAR_CONTENT:
        break;
    }    
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD RemoveIdentity(GUID* pguidIdentity)
{
    if (!pguidIdentity 
        || !memcmp(pguidIdentity, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CHAR    szUid[MAX_PATH];
    GuidToAnsiStr(pguidIdentity, szUid, ARRAY_ELEMENTS(szUid));
    DWORD dwIdentity = MapGuidToOrdinal(pguidIdentity);
    if (dwIdentity==GlobalIdentity)
    {
        DWORD dwErr = SwitchIdentity(NULL);
        if (dwErr!=ERROR_SUCCESS)
            return dwErr;
    }

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    REGISTRY_OBJ roIds(HKEY_CURRENT_USER, IDENTITIES_KEY);
    if (roIds.GetStatus()==ERROR_SUCCESS)
    {        
        // We want to delete the containers before we delete the reg keys.
        // First the extensible containers
        REGISTRY_OBJ* pro = CreateExtensiRegObjFor(HKEY_CURRENT_USER, pguidIdentity);
        if (pro && (pro->GetStatus()==ERROR_SUCCESS))
        {
            CHAR szVendorKey[MAX_PATH];
            while (pro->FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
            {
                REGISTRY_OBJ roVendor(pro, szVendorKey);
                if (roVendor.GetStatus()==ERROR_SUCCESS)
                {
                    TCHAR szPath[MAX_PATH];
                    DWORD ccKeyLen = ARRAY_ELEMENTS(szPath);
                    if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szPath, &ccKeyLen)==ERROR_SUCCESS)
                    {
                        TCHAR szScratch[MAX_PATH+1];
                        ExpandEnvironmentStrings(szPath, szScratch, ARRAY_ELEMENTS(szScratch)-1); // don't count the NULL
                        DeleteCachedFilesInDir(szScratch);
                        RemoveDirectory(szScratch);
                    }
                }
            }
        }
        if (pro)
        {
            delete pro;
        }
        TCHAR szPath[MAX_PATH];
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_COOKIES | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            StrCatBuff(szPath, "\\History.IE5", ARRAY_ELEMENTS(szPath));
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }

        // We'll leave the content; it'll be scavenged anyway.        
        if (roIds.DeleteKey(szUid)==ERROR_SUCCESS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    return dwErr;
}


DWORD SwitchIdentity(GUID* pguidIdentity)
{
    DWORD dwIdentity = pguidIdentity ? MapGuidToOrdinal(pguidIdentity) : 0;
    if (dwIdentity==GlobalIdentity)
        return ERROR_SUCCESS;

    DWORD dwErr = ERROR_SUCCESS;
    
    LOCK_CACHE();
    INET_ASSERT(dwIdentity!=GlobalIdentity);

    CloseTheCookieJar();

    DWORD dwTemp = GlobalIdentity;
    GUID guidTemp;
    GlobalIdentity = dwIdentity;
    GlobalCacheInitialized = FALSE;
    memcpy(&guidTemp, &GlobalIdentityGuid, sizeof(GlobalIdentityGuid));
    if (dwIdentity==0)
    {
        memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));
    }
    else
    {
        memcpy(&GlobalIdentityGuid, pguidIdentity, sizeof(*pguidIdentity));
    }

    CConMgr* NewGUC = new CConMgr();

    if (!NewGUC 
        || (NewGUC->GetStatus()!=ERROR_SUCCESS)
        || (!InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0)))
    {
        INET_ASSERT(FALSE);
        if (NewGUC)
            delete NewGUC;
        
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        GlobalCacheInitialized = TRUE;
        GlobalIdentity = dwTemp;
        memcpy(&GlobalIdentityGuid, &guidTemp, sizeof(GlobalIdentityGuid));
        goto exit;
    }

    // We need to stop the scavenger
    GlobalPleaseQuitWhatYouAreDoing = TRUE;
    while (GlobalScavengerRunning!=-1)
    {
        Sleep(0);
    }
    
    delete GlobalUrlContainers;
    GlobalUrlContainers = NewGUC;
    GlobalCacheInitialized = TRUE;

    // It's safe now, you can scavenge
    GlobalPleaseQuitWhatYouAreDoing = FALSE;

    if (AnyFindsInProgress(0))
    {
        HandleMgr.InvalidateAll();
    }

    CreateCurrentHistory();
    
    // Note to ASK: check what this call does, if it affects identities
    if ((dwErr = GlobalUrlContainers->CreateDefaultGroups())!=ERROR_SUCCESS)
        goto exit;
        
    if (!OpenTheCookieJar()) 
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

#ifdef WININET6
    // Set warnings appropriately.
    GlobalWarnOnPost = FALSE;
    GlobalWarnAlways = FALSE;
    GlobalWarnOnZoneCrossing = TRUE;
    GlobalWarnOnBadCertSending = FALSE;
    GlobalWarnOnBadCertRecving = TRUE;
    GlobalWarnOnPostRedirect = TRUE;
    GlobalDataReadWarningUIFlags();
#endif

exit:
    UNLOCK_CACHE();
    INET_ASSERT((dwErr==ERROR_SUCCESS));
    return dwErr;
}

// CreateExtensiRegObj ----------------
// Create an identity-appropriate registry object
// for extensible cache containers.

REGISTRY_OBJ* CreateExtensiRegObj(HKEY hKey)
{
    REGISTRY_OBJ *pro = NULL;
    
    if (GlobalIdentity)
    {
        pro = CreateExtensiRegObjFor(hKey, &GlobalIdentityGuid);
    }
    else
    {
        REGISTRY_OBJ roCache(hKey, CACHE5_KEY);
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            pro = new REGISTRY_OBJ(&roCache, EXTENSIBLE_CACHE_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
        }
    }

    if (pro && pro->GetStatus()!=ERROR_SUCCESS)
    {
        delete pro;
        pro = NULL;
    }

    return pro;
}


// GenerateStringWithOrdinal ------------
// We want to append the identity ordinal to a string
// If psz is null, then pszBuffer better contain a 0-terminated string that we can
//      append the ordinal to.
// Otherwise, we copy psz to pszBuffer and append to that.
BOOL GenerateStringWithOrdinal(PCTSTR psz, DWORD dwOrdinal, PTSTR pszBuffer, DWORD dwMax)
{
    DWORD cc = psz ? lstrlen(psz) : lstrlen(pszBuffer);

    if (cc>dwMax)
        return FALSE;

    if (psz)
    {
        memcpy(pszBuffer, psz, cc*sizeof(*pszBuffer));
    }
    
    if (dwOrdinal)
    {
        if (!AppendSlashIfNecessary(pszBuffer, &cc))
            return FALSE;   

        if (wnsprintf(pszBuffer+cc, dwMax-cc,
                                "%d", 
                                dwOrdinal) < 0)
            return FALSE;
    }
    else
    {
        pszBuffer[cc] = TEXT('\0');
    }
    
    return TRUE;
}

// IsPerUserEntry
// Examine the headers of a cache entry to determine whether or 
// not it is user-specific

BOOL IsPerUserEntry(LPURL_FILEMAP_ENTRY pfe)
{
    INET_ASSERT(pfe);
    
    BOOL fRet = FALSE;
    PTSTR lpszHeaderInfo = (PTSTR)pfe + pfe->HeaderInfoOffset;
    DWORD dwHeaderSize = pfe->HeaderInfoSize;

    if (!lpszHeaderInfo || !dwHeaderSize)
    {
        return FALSE;
    }
    
    LPSTR lpTemp = lpszHeaderInfo+dwHeaderSize-1;
    LPSTR lpTemp2;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) 
    {
        if (*lpTemp ==':') 
        {
                   // compare with "~U:"
            fRet = (!strnicmp(lpTemp-2, vszUserNameHeader, sizeof(vszUserNameHeader)-1))
                   // guarantee that this is the beginning of a header
                   && (((lpTemp-2)==lpszHeaderInfo)
                       || isspace(*(lpTemp-3)));
            break;
        }
        --lpTemp;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\unxcache.cxx ===
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <unistd.h>

#include <errno.h>


extern int errno;

/* Code swiped from cachecfg.cxx */
static BOOL _NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar,
                           LPTSTR pszResult, UINT cbResult)
{
     TCHAR szEnvVar[MAX_PATH];

     // don't count the NULL
     ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1);
     DWORD dwEnvVar = lstrlen(szEnvVar);

     if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar,
                       dwEnvVar, pszPath, dwEnvVar) == 2)
     {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
           strncpy(pszResult, pszEnvVar, MAX_PATH);
           strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
           return TRUE;
         }
     }

     return FALSE;
}

void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar)
{
     TCHAR szScratch[MAX_PATH];
    
     if (_NormalisePath(pszOrigPath,pszEnvVar,szScratch,sizeof(szScratch)))
        strncpy(pszOrigPath,szScratch,MAX_PATH);
}

void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,
                              LPCTSTR pszKeyName)
{
     if (!strncmp(pszKeyName,CACHE_PATH_VALUE,lstrlen(CACHE_PATH_VALUE)))
        UnixNormalisePath(pszOrigPath,pszEnvVar);
}

int UnixPathExists(LPCTSTR pszPath)
{
     struct stat statbuf;

     if (stat(pszPath, &statbuf) < 0)
     {
        /* If path does not exist */
        if (errno == ENOENT)
           return 0;
        else
           return -1;
     }
     
     /* TODO */
     /* Make sure path points to a directory */

     return 1;
}

void UnixGetValidParentPath(LPTSTR szDevice)
{
     TCHAR szDeviceExists[MAX_PATH];
     PTSTR pszDeviceExists = NULL;
     PTSTR pszEnd          = NULL;
 
     if (!szDevice)
        return;

     lstrcpy(szDeviceExists, szDevice);
 
     pszDeviceExists = szDeviceExists;
     pszEnd          = szDeviceExists + lstrlen(szDeviceExists);
 
     for(;;)
     {
        int   fPathExists;
 
        if (pszEnd == pszDeviceExists)
           break;
 
        fPathExists = UnixPathExists(pszDeviceExists);
        if (fPathExists == -1)
        {
           /* Error */
           break;
        }
        else
        if (fPathExists == 0)
        {
           /* Path does not exist */
           while (*pszEnd != DIR_SEPARATOR_CHAR &&
                  pszEnd != pszDeviceExists)
                 pszEnd--;
 
           *pszEnd = '\0';

           continue;
        }
        else
        {
           /* Path exists */
           lstrcpy(szDevice, pszDeviceExists);
           break;
        }
    }
}

/* CopyDir */

static int DoCopy();

static int UnixCopyCacheFile(const char* file_src,
                         const char* file_dest,
                         mode_t fmode);

static int UnixCreateCacheFolder( const char* dir_dest, mode_t fmode);

#ifndef BUFSIZ
#define BUFSIZ 4096
#endif /* BUFSIZ */

#define CUR_DIR  "."
#define PREV_DIR ".."

static char* pathdir1 = NULL;
static char* pathdir2 = NULL;

int CopyDir(const char* dirname1, const char* dirname2)
{
    int Error = 0;
    struct stat statdir1, statdir2;

    if (!dirname1 || !dirname2)
    {
       goto Cleanup;
    }

    /* We are assuming that dirname1 and dirname2 are absolute paths */
    if (stat(dirname1, &statdir1) < 0)
    {
       Error = errno;
       goto Cleanup;
    }
    else
    if (!S_ISDIR(statdir1.st_mode))
    {
       Error = -1; /* source is not directory */
       goto Cleanup;
    }

    if (stat(dirname2, &statdir2) < 0)
    {
       if (errno != ENOENT)
       {
          Error = errno;
          goto Cleanup;
       }
       /* It is fine if the destination dir does not exist
        * provided all directories above the leaf dir exist
        */
    }
    else
    if (!S_ISDIR(statdir2.st_mode))
    {
       Error = -1; /* destination is not directory */
       goto Cleanup; 
    }

    pathdir1 = (char*)malloc((MAX_PATH+1)*sizeof(char));
    pathdir2 = (char*)malloc((MAX_PATH+1)*sizeof(char));

    lstrcpy(pathdir1, dirname1);
    lstrcpy(pathdir2, dirname2);

    Error = DoCopy();

Cleanup:

    if (pathdir1)
       free(pathdir1);

    if (pathdir2)
       free(pathdir2);

    pathdir1 = pathdir2 = NULL;

    return Error;
}

int DoCopy()
{
    struct stat statbuf;
    struct dirent *dirp;
    DIR           *dp;
    int           Error;
    char          *ptr1, *ptr2;

    if (stat(pathdir1, &statbuf) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    /* Check if this is a regular file */
    if ((statbuf.st_mode & S_IFMT) == S_IFREG)
    {
       Error = UnixCopyCacheFile(pathdir1, pathdir2, statbuf.st_mode);
       goto Cleanup;
    }

    /* Now, we are dealing with a directory */
    if ((Error = UnixCreateCacheFolder(pathdir2, statbuf.st_mode)))
       goto Cleanup;

    ptr1 = pathdir1 + lstrlen(pathdir1);
    *ptr1++ = '/';
    *ptr1   = 0;

    ptr2 = pathdir2 + lstrlen(pathdir2);
    *ptr2++ = '/';
    *ptr2 = 0;

    if ((dp = opendir(pathdir1)) == NULL)
    {
       Error = errno;
       goto Cleanup;
    }

    while ((dirp = readdir(dp)) != NULL)
    {
          if (!lstrcmp(dirp->d_name, CUR_DIR) ||
              !lstrcmp(dirp->d_name, PREV_DIR))
             continue;

          lstrcpy(ptr1, dirp->d_name);
          lstrcpy(ptr2, dirp->d_name);

          if ((Error = DoCopy()))
             break;
    }
    ptr1[-1] = 0;
    ptr2[-1] = 0;

    /* If this fails, ignore this error */
    closedir(dp);

Cleanup:

    return Error;
}

static int UnixCreateCacheFolder( const char* path_dest, mode_t mode_src)
{
    int Error = 0;
    struct stat statbuf2;

    if (stat(path_dest, &statbuf2) < 0)
    {
       if (errno == ENOENT)
       {
          if (mkdir(path_dest, mode_src) < 0)
          {
             Error = errno;
             goto Cleanup;
          }
       }
       else
       {
          Error = errno;
          goto Cleanup;
       }
    }
    else
    if (!S_ISDIR(statbuf2.st_mode))
       Error = -1; /* we are expecting a directory */

Cleanup:
    return Error;
}

int UnixCopyCacheFile(const char* file_src, const char* file_dest, mode_t fmode)
{
    int Error = 0;
    int fd1, fd2;
    char buf[BUFSIZ];
    int  nread, nwrite;

    if ((fd1 = open(file_src, O_RDONLY)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    if ((fd2 = open(file_dest, O_CREAT|O_TRUNC|O_WRONLY, fmode)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    while((nread = read(fd1, buf, BUFSIZ)) > 0)
    {
         if ((nwrite = write(fd2, buf, nread)) != nread)
         {
            Error = errno;
            goto Cleanup;
         }
    }

    Error = 0;

Cleanup:

    if (fd1 > 0)
       close(fd1);

    if (fd2 > 0)
       close(fd2);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\initglob.cxx ===
#include <cache.hxx>


// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
#ifdef unix
#include <flock.hxx>
#endif /* unix */

//
// global variables definition.
//

CRITICAL_SECTION GlobalCacheCritSect;
BOOL GlobalCacheInitialized = FALSE;
CConMgr *GlobalUrlContainers = NULL;
LONG GlobalScavengerRunning = -1;
DWORD GlobalRetrieveUrlCacheEntryFileCount = 0;
PFNGETFILEATTREX gpfnGetFileAttributesEx = 0;

char       g_szFixup[sizeof(DWORD)];
HINSTANCE  g_hFixup;
PFN_FIXUP  g_pfnFixup;

MEMORY *CacheHeap = NULL;
HNDLMGR HandleMgr;

#ifdef unix
/***********************
 * ReadOnlyCache on Unix
 * *********************
 * When the cache resides on a file system which is shared over NFS
 * and the user can access the same cache from different work-stations,
 * it causes a problem. The fix is made so that, the first process has
 * write access to the cache and any subsequent browser process which
 * is started from a different host will receive a read-only version
 * of the cache and will not be able to get cookies etc. A symbolic
 * link is created in $HOME/.microsoft named ielock. Creation and
 * deletion of this symbolic link should be atomic. The functions
 * CreateAtomicCacheLockFile and DeleteAtomicCacheLockFile implement
 * this behavior. When a readonly cache is used, cache deletion is
 * not allowed (Scavenger thread need not be launched).
 *
 * g_ReadOnlyCaches denotes if a readonly cache is being used.
 * gszLockingHost denotes the host that holds the cache lock.
 */

BOOL g_ReadOnlyCaches = FALSE;
char *gszLockingHost = 0;

extern "C" void unixGetWininetCacheLockStatus(BOOL *pBool, char **pszLockingHost)
{
    if(pBool)
        *pBool = g_ReadOnlyCaches;
    if(pszLockingHost)
        *pszLockingHost = gszLockingHost;
}
#endif /* unix */

#ifdef CHECKLOCK_PARANOID

//  Code to enforce strict ordering on resources to prevent deadlock
//  One cannot attempt to take the critical section for the first time
//  if one holds a container lock
DWORD dwThreadLocked;
DWORD dwLockLevel;

void CheckEnterCritical(CRITICAL_SECTION *_cs)
{
    EnterCriticalSection(_cs);
    if (_cs == &GlobalCacheCritSect && dwLockLevel++ == 0)
    {
        dwThreadLocked = GetCurrentThreadId();
        if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
    }
}

void CheckLeaveCritical(CRITICAL_SECTION *_cs)
{
    if (_cs == &GlobalCacheCritSect)
    {
        INET_ASSERT(dwLockLevel);
        if (dwLockLevel == 1)
        {
            if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
            dwThreadLocked = 0;
        }
        dwLockLevel--;
    }
    LeaveCriticalSection(_cs);
}
#endif

//

/*++

--*/

BOOL InitGlobals (void)
{
    if (GlobalCacheInitialized)
        return TRUE;

    LOCK_CACHE();

    if (GlobalCacheInitialized)
        goto done;

    GetWininetUserName();

    // Read registry settings.
    EnsureInternetSettingsKeyCached();
    InternetReadRegistryDword(vszSyncMode, &GlobalUrlCacheSyncMode);

    { // Detect a fixup handler.  Open scope to avoid compiler complaint.
    
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);

        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD cbFixup = sizeof(g_szFixup);
            if (ERROR_SUCCESS != roCache.GetValue
                ("FixupKey", (LPBYTE) g_szFixup, &cbFixup))
            {
                g_szFixup[0] = 0;
            }

            if (g_szFixup[0] != 'V' || g_szFixup[3] != 0)
            {
                g_szFixup[0] = 0;
            }                  
        }
    }
    {
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, CACHE5_KEY);
        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD dwDefTime;
            if (ERROR_SUCCESS == roCache.GetValue("SessionStartTimeDefaultDeltaSecs", &dwDefTime))
            {
                dwdwSessionStartTimeDefaultDelta = dwDefTime * (LONGLONG)10000000;
                dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
            }
        }
    }
    
    // Seed the random number generator for random file name generation.
    srand(GetTickCount());

    GlobalUrlContainers = new CConMgr();
    GlobalCacheInitialized =
        GlobalUrlContainers && (GlobalUrlContainers->GetStatus() == ERROR_SUCCESS);

    if( GlobalCacheInitialized )
    {
        DWORD dwError = GlobalUrlContainers->CreateDefaultGroups();
        INET_ASSERT(dwError == ERROR_SUCCESS);
    }
    else
    {
        delete GlobalUrlContainers;
        GlobalUrlContainers = NULL;
    }

done:
    UNLOCK_CACHE();
    return GlobalCacheInitialized;
}


BOOL
DLLUrlCacheEntry(
    IN DWORD Reason
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    HMODULE ModuleHandleKernel;

    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
#ifdef CHECKLOCK_PARANOID
            dwThreadLocked = 0;
            dwLockLevel = 0;
#endif
            ModuleHandleKernel = GetModuleHandle("KERNEL32");
            if (ModuleHandleKernel)
            {
                gpfnGetFileAttributesEx = (PFNGETFILEATTREX)
                    GetProcAddress(ModuleHandleKernel, "GetFileAttributesExA");
            }

            InitializeCriticalSection (&GlobalCacheCritSect);
            // RunOnceUrlCache (NULL, NULL, NULL, 0); // test stub
#ifdef unix
            if(CreateAtomicCacheLockFile(&g_ReadOnlyCaches,&gszLockingHost) == FALSE)
                return FALSE;
#endif /* unix */
            break;

        case DLL_PROCESS_DETACH:

            // Clean up containers list.
            if (GlobalUrlContainers != NULL)
            {
                delete GlobalUrlContainers;
                GlobalUrlContainers = NULL;
            }
            
            // Unload fixup handler.
            if (g_hFixup)
                FreeLibrary (g_hFixup);
                
            HandleMgr.Destroy();
            
#ifdef unix
        DeleteAtomicCacheLockFile();
#endif /* unix */
        DeleteCriticalSection (&GlobalCacheCritSect);
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hndlmgr.cxx ===
#include <cache.hxx>

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include "hndlmgr.hxx"

#define ALLOCATE_FIXED_MEMORY(size) malloc(size)
#define REALLOCATE_MEMORY(ptr, size, flags) realloc(ptr, size)
#define FREE_MEMORY(ptr) free(ptr)

int main ()
{
    HNDLMGR HandleMgr;
    HANDLE h[10];
    HANDLE hBad = (HANDLE) 5150;

    // Test alloc and realloc of handle heap.
    for (int i=9; i>=0; i--)
    {
        h[i] = HandleMgr.Alloc (54);
        printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    }

    // Test invalid, valid, and double free.
    printf ("Free(%d) returns %d\n", NULL, HandleMgr.Free(NULL));
    printf ("Free(%d) returns %d\n", hBad, HandleMgr.Free(hBad));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[9], HandleMgr.Free(h[9]));

    // Test mapping of invalid, free, and valid handles.
    printf ("Map(%d) = %d\n", NULL, HandleMgr.Map(NULL));
    printf ("Map(%d) = %d\n", hBad, HandleMgr.Map(hBad));
    printf ("Map(%d) = %d\n", h[3], HandleMgr.Map(h[3]));
    printf ("Map(%d) = %d\n", h[5], HandleMgr.Map(h[5]));

    // Test recycling of handles from free list.
    i = 3;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    i = 9;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);

    return 1;
}

#endif // TEST

#define INC_GROW 8

//=========================================================================
void HNDLMGR::Destroy (void)
{
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if ((DWORD_PTR) pHeap->pvHandles[iHandle] >= pHeap->dwMaxHandles)
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
        }
        FREE_MEMORY (pHeap);
    }        
}

//=========================================================================
BOOL HNDLMGR::IsValidOffset (DWORD_PTR dwp)
{
    return (pHeap && (dwp < pHeap->dwNumHandles) && 
        ((DWORD_PTR) pHeap->pvHandles[dwp]) >= pHeap->dwMaxHandles);
}

//=========================================================================
HANDLE HNDLMGR::Alloc (DWORD cbAlloc)
{
    PVOID pTemp;

    if (!pHeap)
    {
        // Allocate the heap.
        pHeap = (HNDLHEAP*) ALLOCATE_FIXED_MEMORY
            (sizeof(HNDLHEAP) + INC_GROW * sizeof(LPVOID));
        if (!pHeap)
            return NULL;

        // Initialize the heap.
        pHeap->dwNumHandles = 0;
        pHeap->dwNumInUse = 0;
        pHeap->dwMaxHandles = 0xFFFFFFFF;
        pHeap->dwFirstFree = 0;
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    else if (pHeap->dwFirstFree == pHeap->dwNumHandles)
    {
        // Reallocate the heap.
        if (pHeap->dwNumHandles + INC_GROW >= pHeap->dwMaxHandles)
        {
            // Uh oh, heap is hit the lower bound set by the allocator.
            return NULL; 
        }
        pTemp = REALLOCATE_MEMORY (pHeap, sizeof(HNDLHEAP)
            + (pHeap->dwNumHandles + INC_GROW) * sizeof(LPVOID), LMEM_MOVEABLE);
        if (!pTemp)
            return NULL;
        pHeap = (HNDLHEAP*) pTemp;

        // Extend the free list.
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    // Allocate a handle.
    pTemp = ALLOCATE_FIXED_MEMORY (cbAlloc);
    if (!pTemp)
        return NULL;
    if ((DWORD_PTR) pTemp < pHeap->dwNumHandles)
    {
        // Uh oh, allocator returned a low value!
        FREE_MEMORY (pTemp);
        return NULL;
    }
    if (pHeap->dwMaxHandles >= ((DWORD_PTR) pTemp))
        pHeap->dwMaxHandles = ((DWORD_PTR) pTemp);

    INET_ASSERT(pHeap->dwFirstFree < pHeap->dwNumHandles);
    // Pop the handle off the top of the free list.
    DWORD_PTR dwOffset = pHeap->dwFirstFree;
    pHeap->dwFirstFree = (DWORD_PTR) pHeap->pvHandles[pHeap->dwFirstFree];
    pHeap->pvHandles[dwOffset] = pTemp;
    pHeap->dwNumInUse++;
    return (HANDLE) (dwOffset + 1);
}

//=========================================================================
LPVOID HNDLMGR::Map (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;
    if (!IsValidOffset (dwOffset) || (((DWORD_PTR) pHeap->pvHandles[dwOffset]) == -1))
    {
        return NULL;
    }
    else
        return pHeap->pvHandles[dwOffset];
}

//=========================================================================
BOOL HNDLMGR::Free (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;

    if (!IsValidOffset (dwOffset))
        return FALSE;

    if (((DWORD_PTR) pHeap->pvHandles[dwOffset]) != -1)
    {
        // Push the handle on the top of the free list.
        FREE_MEMORY (pHeap->pvHandles[dwOffset]);
    }

    INET_ASSERT(pHeap->dwFirstFree <= pHeap->dwNumHandles);
    pHeap->pvHandles[dwOffset] = (LPVOID) pHeap->dwFirstFree;
    pHeap->dwFirstFree = dwOffset;
    pHeap->dwNumInUse--;
    return TRUE;
}

//=========================================================================
VOID HNDLMGR::InvalidateAll()
{
    // We're in the process of switching identities; all cache handles
    // should be invalidated so that they can no longer be used.
    
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if (((DWORD_PTR) pHeap->pvHandles[iHandle] > pHeap->dwNumHandles)
                && ((DWORD_PTR) pHeap->pvHandles[iHandle] != -1))
            {
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
                pHeap->pvHandles[iHandle] = (HANDLE)-1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\instcon.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  instcon.cxx

Abstract:

    Installed container class derived from URL_CONTAINER
    
Author:
    Adriaan Canter (adriaanc) 04-10-97
    
--*/

#include <cache.hxx>

#define HTTP_OK "HTTP/1.0 200 OK\r\n\r\n"



/*--------------------- CInstCon Public Functions-----------------------------*/


/*-----------------------------------------------------------------------------
    CInstCon::CInstCon
-----------------------------------------------------------------------------*/
CInstCon::CInstCon(LPSTR CacheName, LPSTR VolumeLabel, LPSTR VolumeTitle,
                   LPSTR CachePath, LPSTR CachePrefix, LPSTR PrefixMap, 
                   LONGLONG CacheLimit, DWORD dwOptions)

    : URL_CONTAINER(CacheName, CachePath, CachePrefix, CacheLimit, dwOptions)
{
    if (_Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        return;
    }
        
    _szVolumeLabel = NewString(VolumeLabel);
    _szVolumeTitle = NewString(VolumeTitle);
    _szPrefixMap   = NewString(PrefixMap);    
    
    if (!(_szVolumeLabel && _szVolumeTitle && _szPrefixMap))
    {
        INET_ASSERT(FALSE);
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _cbPrefixMap = strlen(PrefixMap);
    _cbMaxFileSize = MAX_FILE_SIZE_TO_MIGRATE;
    _Status = ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    CInstCon::~CInstCon
-----------------------------------------------------------------------------*/
CInstCon::~CInstCon()
{
    delete _szPrefixMap;
    delete _szVolumeLabel;
    delete _szVolumeTitle;
}


/*------------------ URL_CONTAINER virtual overrides-------------------------*/

/*-----------------------------------------------------------------------------
    CInstCon::GetPrefixMap
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetPrefixMap()
{
    return _szPrefixMap;
}

/*-----------------------------------------------------------------------------
    CInstCon::GetVolumeLabel
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetVolumeLabel()
{
    return _szVolumeLabel;
}

/*-----------------------------------------------------------------------------
    CInstCon::GetVolumeTitle
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetVolumeTitle()
{
    return _szVolumeTitle;
}


/*-----------------------------------------------------------------------------
    CInstCon::AddUrl
-----------------------------------------------------------------------------*/
DWORD CInstCon::AddUrl (AddUrlArg* pArgs)
{
    pArgs->dwEntryType |= INSTALLED_CACHE_ENTRY;
    return URL_CONTAINER::AddUrl(pArgs);
}


/*-----------------------------------------------------------------------------
    CInstCon::RetrieveUrl
-----------------------------------------------------------------------------*/
DWORD CInstCon::RetrieveUrl(LPCSTR  UrlName, LPCACHE_ENTRY_INFO EntryInfo, 
                            LPDWORD EntryInfoSize, DWORD dwLookupFlags, 
                            DWORD dwRetrievalFlags)    
{
    DWORD dwError;
    BOOL fMustUnlock;

    INET_ASSERT(EntryInfo && EntryInfoSize);

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }

    dwError = GetEntry(UrlName, EntryInfo, EntryInfoSize, dwLookupFlags);

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}



/*-----------------------------------------------------------------------------
    CInstCon::GetUrlInfo
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetUrlInfo(LPCSTR  szUrlName, LPCACHE_ENTRY_INFO pei, 
                           LPDWORD pcbei, DWORD dwLookupFlags, DWORD dwEntryFlags)    
{
    DWORD dwError;
    DWORD cbeiTemp = 0x256;
    BYTE bTemp[0x256];
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }

    // Zero buffer case.
    if (pei && pcbei)
    {
        dwError = GetEntry(szUrlName, pei, pcbei, dwLookupFlags);
        goto exit;
    }

    // Zero buffer case.
    if (dwEntryFlags & INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING)
    {
        // Return success to indicate that a mapping exists. 
        // We wouldn't have gotten here otherwise.
        dwError = ERROR_SUCCESS;
    }
    else
    {
        // Otherwise, no flag passed in. Only return
        // success if the entry has been successfully found.
        dwError = GetEntry(szUrlName, (LPCACHE_ENTRY_INFO) bTemp, 
            &cbeiTemp, dwLookupFlags);
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}
    

/*--------------------- CInstCon Private Functions-----------------------------*/



/*-----------------------------------------------------------------------------
    CInstCon::GetEntry
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetEntry(LPCSTR  UrlName, LPCACHE_ENTRY_INFO EntryInfo, 
                         LPDWORD EntryInfoSize, DWORD dwLookupFlags)
{    
    INT cbOld, cbNew, cbDiff;
    DWORD cbOriginalInfoSize = *EntryInfoSize;
    DWORD dwError = ERROR_SUCCESS, dwCDStatus;

    DWORD cb;
    LPSTR ptr;
        

    // Try to get it from the CD.
    dwCDStatus = GetEntryFromCD(UrlName, EntryInfo, EntryInfoSize);

    switch(dwCDStatus)
    {
        // Couldn't find it on the CD.
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
 
            // Not on CD. Look in memory mapped file.
            dwError = URL_CONTAINER::RetrieveUrl(UrlName, (EntryInfo ? &EntryInfo : NULL), 
                                                 EntryInfoSize, dwLookupFlags,
                                                 RETRIEVE_WITH_CHECKS);
            break;
        
        // CD not in drive.        
        case ERROR_INVALID_DRIVE:
        case ERROR_NOT_READY:
        case ERROR_WRONG_DISK:
                
            dwError = ERROR_INTERNET_INSERT_CDROM;
            break;

        // Found it on the CD.
        case ERROR_SUCCESS:

            dwError = ERROR_SUCCESS;
            break;

        default:

            // Some other error.
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
    }            

    return dwError;
}
    



/*-----------------------------------------------------------------------------
    CInstCon::MapUrlToAbsPath
-----------------------------------------------------------------------------*/
VOID CInstCon::MapUrlToAbsPath(LPSTR UrlName, 
                               LPSTR szAbsPath, LPDWORD pcbAbsPath)
{
    // Construct the absolute path to the file.
    memcpy(szAbsPath, _szPrefixMap, _cbPrefixMap + 1);

    LPSTR ptr = UrlName + _CachePrefixLen;
    DWORD cbSuffix = strlen(ptr);
 
    *pcbAbsPath = _cbPrefixMap + cbSuffix;
    memcpy(szAbsPath + _cbPrefixMap, ptr, cbSuffix + 1);
    
    // Convert all forward slashes to back slashes,
    // including any that were inadvertently placed
    // in the prefix map. This path might be returned 
    // to the caller.
    ptr = szAbsPath;
    while (*ptr++)
    {
#ifndef unix
        if (*ptr == '/')
            *ptr = '\\';
#else
        if (*ptr == '\\')
            *ptr = '/';
#endif /* unix */
    }

    // Unescape - final length may be less than
    // pcbAbsPath, but is always null terminated.
    UrlUnescapeInPlace(szAbsPath, NULL);
}


/*-----------------------------------------------------------------------------
    CInstCon::GetEntryFromCD
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetEntryFromCD(LPCSTR UrlName, 
                               LPCACHE_ENTRY_INFO EntryInfo, 
                               LPDWORD EntryInfoSize)
{
    LPBYTE pb;
    CHAR szAbsPath[MAX_PATH], *ptr;
  
    DWORD cbUrl, cbSuffix, cbAbsPath, cbSizeRequired, cbExt, i,
          dwError = ERROR_SUCCESS;

    LONGLONG llZero        = (LONGLONG) 0;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributes;

    CHAR szVolumeLabel[MAX_PATH];

    CHAR szVolRoot[4];
    memcpy(szVolRoot, _szPrefixMap, 2);
    memcpy(szVolRoot + 2, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    // First check that the correct CD is inserted.
    if (GetVolumeInformation(szVolRoot, szVolumeLabel, MAX_PATH, 
                             NULL, NULL, NULL, NULL, 0))
    {
        if (strcmp(_szVolumeLabel, szVolumeLabel))
        {
            dwError = ERROR_WRONG_DISK;
            goto exit;
        }
    }
    else
    {
        dwError = ERROR_INVALID_DRIVE;
        goto exit;
    }

    // ---- Find the file and file info from the url -----


    cbUrl = strlen(UrlName);

    // Formulate path to file.
    MapUrlToAbsPath((LPSTR) UrlName, szAbsPath, &cbAbsPath);

    // Determine required CACHE_ENTRY_INFO buffer size.
    cbSizeRequired = sizeof(CACHE_ENTRY_INFO)
        + cbUrl + 1 + cbAbsPath + 1 + MAX_EXTENSION_LEN + 1 + sizeof(HTTP_OK);
    if (cbSizeRequired > *EntryInfoSize)
    {
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }
    
    // Get the file information. Shouldn't be a directory.
    dwError = GetFileSizeAndTimeByName(szAbsPath, &FileAttributes);
    if (dwError != ERROR_SUCCESS)
    {
        if (FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            dwError = ERROR_FILE_NOT_FOUND;
        }
        goto exit;
    }


    // ---- Assemble the CACHE_ENTRY_INFO structure to return ----   
    
    
    // Urlname.
    pb = (LPBYTE) EntryInfo + sizeof(CACHE_ENTRY_INFO);
    memcpy(pb, UrlName, cbUrl + 1);
    EntryInfo->lpszSourceUrlName = (LPSTR) pb;
    
    // Filename.
    pb += cbUrl + 1;
    strcpy((LPSTR) pb, szAbsPath);
    EntryInfo->lpszLocalFileName = (LPSTR) pb;
    
    // Header.
    pb += cbAbsPath + 1;
    memcpy(pb, HTTP_OK, sizeof(HTTP_OK));
    EntryInfo->lpHeaderInfo = (LPSTR)pb;    
        
    // File extension
    cbExt = 0;
    ptr = (LPSTR) UrlName + cbUrl;
    for (i = 0; i < MAX_EXTENSION_LEN+1; i++)
    {
        if (*(--ptr) == '.')
        {            
            cbExt = i+1;
            break;
        }
    }
    if (cbExt)
    {
        pb += sizeof(HTTP_OK);
        memcpy(pb, ptr+1, cbExt + 1);
        EntryInfo->lpszFileExtension = (LPSTR) pb;    
    }
    else
        EntryInfo->lpszFileExtension = NULL;

    pb += cbExt +1;

    INET_ASSERT((DWORD) ((LPCACHE_ENTRY_INFO) pb - EntryInfo) < cbSizeRequired);
    
    // Version , type, count, hit rate, file size.
    EntryInfo->dwStructSize = URL_CACHE_VERSION_NUM;
    EntryInfo->CacheEntryType = INSTALLED_CACHE_ENTRY;
    EntryInfo->dwUseCount = 0;
    EntryInfo->dwHitRate = 0;
    EntryInfo->dwSizeHigh = FileAttributes.nFileSizeHigh;
    EntryInfo->dwSizeLow = FileAttributes.nFileSizeLow;    

    // Times: modified, expired, accessed, synced.
    EntryInfo->LastModifiedTime = FileAttributes.ftCreationTime;
    EntryInfo->ExpireTime = *(FILETIME*) &llZero;

    // BUGBUG - getcurrent time for both.
    EntryInfo->LastAccessTime = FileAttributes.ftLastAccessTime;
    EntryInfo->LastSyncTime = *(FILETIME*) &llZero;

    // Header size, file extension, exempt delta.
    EntryInfo->dwHeaderInfoSize = sizeof(HTTP_OK);
    EntryInfo->dwExemptDelta = 0;
    
    // Buffer consumed.
    *EntryInfoSize = cbSizeRequired - sizeof(CACHE_ENTRY_INFO);


exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
    CInstCon::AddEntryToIndex
-----------------------------------------------------------------------------*/
DWORD CInstCon::AddEntryToIndex(LPCACHE_ENTRY_INFO EntryInfo, 
                                LPDWORD EntryInfoSize) 
{
    DWORD dwError;
    AddUrlArg args;
    CHAR szFileName[MAX_PATH];

    // Create a local file name for the hard disk.
    *szFileName = '\0';
    dwError = URL_CONTAINER::CreateUniqueFile(EntryInfo->lpszSourceUrlName, 
        NULL, EntryInfo->lpszFileExtension, szFileName, NULL);
    if (dwError != ERROR_SUCCESS)
        goto exit;

    // Copy the file from the CD.
    // CreateUniqueFile has already created a file of 0 bytes.
    if (!CopyFile(EntryInfo->lpszLocalFileName, szFileName, FALSE))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;
    }

    // Add the entry to the index.

    // Url, filename, file size and extension.
    memset(&args, 0, sizeof(args));
    args.pszUrl = EntryInfo->lpszSourceUrlName;
    args.pszFilePath = szFileName;
    args.dwFileSize = EntryInfo->dwSizeLow;
    args.pszFileExt = EntryInfo->lpszFileExtension;
    args.dwEntryType = EntryInfo->CacheEntryType;    
    // Headers.
    args.pbHeaders = EntryInfo->lpHeaderInfo;
    args.cbHeaders = EntryInfo->dwHeaderInfoSize;

    // Times: last modified and expired.
    args.qwLastMod = FT2LL(EntryInfo->LastModifiedTime);
    args.qwExpires = FT2LL(EntryInfo->ExpireTime);

    // Redirect.    
    args.pszRedirect = NULL;

    args.fImage      = FALSE;
    
    // Add the url to the index.
    dwError = AddUrl(&args);
    if (dwError != ERROR_SUCCESS)
        goto exit;
                   
    // Retrieve the entry from the index. We do this because the EntryInfo
    // structure returned from the CD references the CD filename.
    // PERFPERF - we could optimize this by fixing up the EntryInfo
    // structure to reference the CD filename.
    dwError = URL_CONTAINER::RetrieveUrl(EntryInfo->lpszSourceUrlName, 
        (EntryInfo ? &EntryInfo : NULL), EntryInfoSize, NULL, RETRIEVE_WITH_CHECKS);

exit:
    return dwError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hashutil.cxx ===
/*++
Copyright (c) 1996  Microsoft Corp.

Module Name: hashutil.cxx

Abstract:

    Implementation of linked list of hash tables for cache index lookup.

Author:
    Rajeev Dujari (rajeevd) 22-Oct-96

--*/

#include <cache.hxx>

#define SIG_HASH ('H'|('A'<<8)|('S'<<16)|('H'<<24))

typedef LIST_FILEMAP_ENTRY HASH_FILEMAP_ENTRY;

// hash table parameters
#define BYTES_PER_PAGE 4096

#define ITEMS_PER_BUCKET ((BYTES_PER_PAGE - sizeof(HASH_FILEMAP_ENTRY))\
    / (SLOT_COUNT * sizeof(HASH_ITEM)))
#define BYTES_PER_TABLE (sizeof(HASH_FILEMAP_ENTRY) \
    + SLOT_COUNT * ITEMS_PER_BUCKET * sizeof(HASH_ITEM))


//
// Hash Function: Pearson's method
//

PRIVATE DWORD HashKey (LPCSTR lpsz, DWORD dwAddedHash)
{
    union
    {
        DWORD dw;
        BYTE c[4];
    }
    Hash, Hash2;
        
    const static BYTE bTranslate[256] =
    {
        1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
        87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
        49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
        12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
        176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
        178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
        102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
        166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
        121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
        193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
        6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
        84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
        249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
        230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
        44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
        163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
    };

    // Seed the hash values based on the first character.
    Hash.c[0] = bTranslate[ *lpsz];
    Hash.c[1] = bTranslate[(*lpsz+1) & 255];
    Hash.c[2] = bTranslate[(*lpsz+2) & 255];
    Hash.c[3] = bTranslate[(*lpsz+3) & 255];
    Hash.dw += dwAddedHash;
    
    while (*++lpsz)
    {
        // Allow URLs differing only by trailing slash to collide.
        if (lpsz[0] == '/' && lpsz[1] == 0)
            break;

        Hash2.c[0] = Hash.c[0] ^ *lpsz;
        Hash2.c[1] = Hash.c[1] ^ *lpsz;
        Hash2.c[2] = Hash.c[2] ^ *lpsz;
        Hash2.c[3] = Hash.c[3] ^ *lpsz;
            
        Hash.c[0] = bTranslate[Hash2.c[0]];
        Hash.c[1] = bTranslate[Hash2.c[1]];
        Hash.c[2] = bTranslate[Hash2.c[2]];
        Hash.c[3] = bTranslate[Hash2.c[3]];
    }

    return Hash.dw;
}
    
//
// HashLookupItem support functions specific to urlcache:
//      AllocTable
//      IsMatch
//


PRIVATE HASH_FILEMAP_ENTRY* AllocTable
    (LPVOID pAllocObj, LPBYTE* ppBase, LPDWORD* ppdwOffset)
{
    // Save the offset to the table offset.
    DWORD_PTR dpOffsetToTableOffset = (LPBYTE)*ppdwOffset - *ppBase;  // 64BIT
    
    // Ask for BYTES_PER_PAGE instead of BYTES_PER_TABLE
    // so the allocator knows to align on a page boundary.
    INET_ASSERT (BYTES_PER_PAGE >= BYTES_PER_TABLE);
    MEMMAP_FILE* pmmf = (MEMMAP_FILE*) pAllocObj;
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY *) pmmf->AllocateEntry (BYTES_PER_PAGE);
    if (!pTable)
        return NULL;  
    INET_ASSERT (! (((LPBYTE) pTable - *pmmf->GetHeapStart()) & (BYTES_PER_PAGE-1)) );

    // Chain new table to previous table.
    *ppBase = *pmmf->GetHeapStart();
    *ppdwOffset = (DWORD*) (*ppBase + dpOffsetToTableOffset);
    **ppdwOffset = (DWORD) ((LPBYTE)pTable - *ppBase);             // 64BIT
    
    // Initialize the header.
    pTable->dwSig = SIG_HASH;
    pTable->dwNext = 0;
    
    // Fill the rest of the entry with HASH_END
    DWORD* pdw = (DWORD *) (pTable + 1);
    DWORD cdw = SLOT_COUNT * ITEMS_PER_BUCKET * (sizeof(HASH_ITEM)/sizeof(DWORD));
    INET_ASSERT (!(sizeof(HASH_ITEM) % sizeof(DWORD)));
    while (cdw--)
        *pdw++ = HASH_END;

    // Return the new table.
    return pTable;
}

//
// IsMatch: determine if hash table item with a matching 32-bit hash value
// is an actual match or return NULL if a collision.
//

PRIVATE HASH_ITEM* URL_CONTAINER::IsMatch
    (HASH_ITEM *pItem, LPCSTR pszKey, DWORD dwFlags)
{
    MEMMAP_FILE* pmmf = _UrlObjStorage;

    dwFlags &= (LOOKUP_BIT_REDIR | LOOKUP_BIT_CREATE);

    if (pmmf->IsBadOffset (pItem->dwOffset))
    {
        // Fix up a bad hash table item.  This could happen if a thread
        // died between allocating a hash table item and setting the offset.
        pItem->MarkFree();
        return NULL;
    }

    FILEMAP_ENTRY* pEntry = (FILEMAP_ENTRY*)
        (*pmmf->GetHeapStart() + pItem->dwOffset);

    switch (pEntry->dwSig)
    {
        case SIG_URL:
        {        
            // Fail if lookup flags are inconsistent with url entry type.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_NOTURL));

            // Get pointer to URL.
            URL_FILEMAP_ENTRY *pUrlEntry = (URL_FILEMAP_ENTRY *) pEntry;
            LPSTR pszUrl = ((LPSTR) pUrlEntry) + pUrlEntry->UrlNameOffset;
            LPCSTR pszKey2 = pszKey, pszUrl2 = pszUrl;
            
            while ( *pszKey2 && *pszUrl2 && *pszKey2 == *pszUrl2 )
            {
                pszKey2++;
                pszUrl2++;
            }

            if (!*pszKey2 && ! *pszUrl2)
            {
                // Found exact match.

                if (dwFlags == LOOKUP_REDIR_CREATE)
                {
                    // We are have a cache entry for a URL which is now
                    // redirecting.  Delete the cache entry.
                    DeleteUrlEntry (pUrlEntry, pItem, SIG_DELETE);
                    return NULL;
                }

                return pItem;
            }

            // If redirects allowed, check for trailing slash match.
            if ((dwFlags == LOOKUP_URL_TRANSLATE)
                && (pItem->dwHash & HASH_BIT_REDIR))
            {
                DWORD cbUrl = strlen (pszUrl);
                DWORD cbKey = strlen (pszKey);
                INET_ASSERT (cbUrl && pszUrl[cbUrl - 1] == '/');
                if (cbUrl == (cbKey + 1) && !memcmp (pszUrl, pszKey, cbKey))
                    return pItem;
            }
                
            return NULL;
        }
        
        case SIG_REDIR:
        {
            // When online, filter out offline redirect entries.
            if (dwFlags == LOOKUP_URL_NOCREATE)
                return NULL;

            // Check that redirect URL matches exactly.
            REDIR_FILEMAP_ENTRY* pRedir = (REDIR_FILEMAP_ENTRY *) pEntry;
            if (lstrcmp (pszKey, pRedir->szUrl))
                return NULL;

            switch (dwFlags)
            {
                case LOOKUP_URL_CREATE:

                    // We are creating a new entry for a URL that once
                    // redirected.  Delete the stale redirect entry.
                    pmmf->FreeEntry (pRedir);
                    pItem->MarkFree();
                    return NULL;

                case LOOKUP_REDIR_CREATE:
                
                    // Return the redirect item if we're looking for it.
                    return pItem;

                case LOOKUP_URL_TRANSLATE:

                    // Otherwise, translate through the redirect item.
                    pItem = (HASH_ITEM *)
                        (*pmmf->GetHeapStart() + pRedir->dwItemOffset);

                    // Perform some consistency checks.
                    if (pItem->dwHash & HASH_BIT_NOTURL)
                        return NULL; // not an URL entry
                    if ((pItem->dwHash & ~SLOT_MASK) != pRedir->dwHashValue)
                        return NULL; // not a matching URL entry
                    return pItem;

                default:
                    INET_ASSERT (FALSE);                
            }
        }
        
        default:
        {
            // Fix up a bad hash table entry.  This can happen if a thread
            // died between allocating a hash table item and setting the offset.
            pItem->MarkFree();
            return NULL;
        }            
    }
}


//
// HashFindItem: finds a matching entry or else the first free slot
//

BOOL URL_CONTAINER::HashFindItem
    (LPCSTR pszKey, DWORD dwFlags, HASH_ITEM** ppItem)
{    
    INET_ASSERT(!((dwFlags & LOOKUP_URL_DONT_FOLLOW) && (dwFlags & LOOKUP_BIT_CREATE)));
    DWORD dwFind = 0;
    BOOL fLookAgain = !(dwFlags & LOOKUP_URL_DONT_FOLLOW) && GlobalIdentity;
again:
    LPVOID pAllocObj = (LPVOID) _UrlObjStorage;
    LPBYTE pBase = *_UrlObjStorage->GetHeapStart();
    LPDWORD pdwTableOffset = _UrlObjStorage->GetPtrToHashTableOffset();
    
    // Scan flags.
    BOOL fCreate = dwFlags & LOOKUP_BIT_CREATE;

    HASH_ITEM* pFree = NULL;
    DWORD nBlock = 0;
    
    // Hash the URL and calculate the slot.
    DWORD dwHash = HashKey(pszKey, dwFind);
    DWORD iSlot = dwHash & SLOT_MASK;
    dwHash &= ~SLOT_MASK;

    // Walk through the list of hash tables.
    while (*pdwTableOffset && !_UrlObjStorage->IsBadOffset(*pdwTableOffset))
    {
        // Calculate offset to next hash table and validate signature.
        HASH_FILEMAP_ENTRY* pTable =
            (HASH_FILEMAP_ENTRY*) (pBase + *pdwTableOffset);
        if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock++)
            break;

        // Calculate offset to bucket in this table.
        HASH_ITEM* pItem = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;

        // Scan the bucket.
        for (DWORD iSeat=0; iSeat<ITEMS_PER_BUCKET; iSeat++, pItem++)
        {
            // No reserved bits should ever be set on an item.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));

            switch (pItem->dwHash)
            {
                case HASH_FREE: // free item but more items might follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    // If caller wants a free item, record the first one we find.
                    if (!pFree && fCreate)
                        pFree = pItem;
                }                        
                    continue;

                case HASH_END: // first previously unused free item; no more to follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    if (!fCreate)
                        *ppItem = NULL;
                    else
                    {
                        // Hand out the first free slot.
                        if (pFree)
                        {
                            // Invalidate offset in case caller neglects to set it.
                            pFree->dwOffset = HASH_END;
                            *ppItem = pFree;
                        }
                        else
                        {
                            // The first free slot has never been used before.
                            INET_ASSERT (pItem->dwOffset == HASH_END);
                            *ppItem = pItem;
                        }
                        (*ppItem)->dwHash = dwHash;
                    }
                }
                    return FALSE;

                default:
                {
                    // Check if the key matches.
                    if (dwHash == (pItem->dwHash & ~SLOT_MASK))
                    {
                        if (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS)
                        {
                            *ppItem = pItem;
                            return TRUE;
                        }
                        
                        HASH_ITEM* pItem2 = IsMatch(pItem, pszKey, dwFlags);
                        if (pItem2)
                        {
                            LPURL_FILEMAP_ENTRY pEntry = 
                                (URL_FILEMAP_ENTRY*)(*(((MEMMAP_FILE*)_UrlObjStorage)->GetHeapStart())
                                                + pItem2->dwOffset);

                            // This will check for a ~U: header or IDENTITY_CACHE_ENTRY
                            // We use the first for compatibility with Wininet5
                            // We use IDENTITY_CACHE_ENTRY for entries we wish to hide from Wininet5
                            if ((pEntry->dwSig==SIG_URL)
                                && (!(dwFlags & LOOKUP_URL_DONT_FOLLOW) 
                                   && ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY) 
                                       || IsPerUserEntry(pEntry))))
                            {
                                // We'll search again for an entry corresponding to GlobalIdentity
                                if (fLookAgain)
                                {
                                    fLookAgain = FALSE;
                                    dwFind = GlobalIdentity;
                                    goto again;
                                }

                                // Guarantee that this is what we want
                                if (pEntry->GetIdentity()!=GlobalIdentity)
                                {
                                    continue;
                                }
                                // If we're looking for an identity-0 cache entry
                                // and there is no filename, we need to do the following:
                                // 1. if we're trying to create an entry, then return this
                                // 2. otherwise, say No, the entry is not present
                                if (!pEntry->InternalFileNameOffset && !fCreate)
                                {
                                    *ppItem = NULL;
                                    return FALSE;
                                }
                            }
                            *ppItem = pItem2;
                            return TRUE;
                        }
                    }                    
                }
                    continue;
                    
            } // end switch
          
        } // end for loop to scan seats in bucket
        
        // Follow the link to the next table.
        pdwTableOffset = &pTable->dwNext;

    } // end while (*pdwTableOffset)

    // If we've encountered a corrupt table, we'll have to recover
    if (*pdwTableOffset)
    {
        INET_ASSERT(FALSE);
        *pdwTableOffset = 0;
    }
   
    // We are out a buckets, so an item hasn't been found.

    if (fCreate && !pFree)
    {
        // Caller wanted a free item but we didn't find one.
       
        HASH_FILEMAP_ENTRY* pTable = AllocTable
            (pAllocObj, &pBase, &pdwTableOffset);

//////////////////////////////////////////////////////////////////////
// WARNING: the file might have grown and remapped, so any pointers //
// hereafter must be recalculated by offsets from the new base.     //
//////////////////////////////////////////////////////////////////////

        if (pTable)
        {
            pTable->nBlock = nBlock;
            // Calculate next free slot.
            pFree = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;
            INET_ASSERT (pFree->dwHash   == HASH_END);
            INET_ASSERT (pFree->dwOffset == HASH_END);
        }
    }

    // Return free item if desired and indicate no item found.
    if (pFree)
    {
        INET_ASSERT (fCreate);
        pFree->dwHash   = dwHash;
        pFree->dwOffset = HASH_END; // invalid in case caller neglects to set it
    }
    *ppItem = pFree;
    return FALSE;
}

//
// HashFindNextItem: scans the table for the next valid URL item
//

PUBLIC
HASH_ITEM*
HashGetNextItem
(
    IN     LPVOID       pAllocObj,      // allocator object
    IN     LPBYTE       pBase,          // base for all offsets
    IN OUT LPDWORD      pdwItemOffset,  // current item offset
    IN     DWORD        dwFlags         // include redirects?
)
{
    INET_ASSERT (!(dwFlags & ~LOOKUP_BIT_REDIR));
    
    // Check if there if the hash table is empty (or we are at the end already.)
    if (!*pdwItemOffset)
        return NULL;

    HASH_ITEM* pItem = (HASH_ITEM*) (pBase + *pdwItemOffset);

    // Calculate current table offset, assuming it's the previous page boundary.
    INET_ASSERT (BYTES_PER_TABLE <= BYTES_PER_PAGE);
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY*) (((DWORD_PTR)pItem) & ~(BYTES_PER_PAGE - 1));

    // Advance item pointer to next location.
    if (pItem == (HASH_ITEM*) pTable)
        pItem = (HASH_ITEM*) (pTable + 1); // first location in table
    else
        pItem++; // next location in table

    do // Scan the list of tables.
    {
        if (pTable->dwSig != SIG_HASH)
            break;
            
        // Scan the current table.
        for (; (LPBYTE) pItem < ((LPBYTE) pTable) + BYTES_PER_TABLE; pItem++)
        {
            // No reserved bits should be set.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));
            
            if (!(pItem->dwHash & HASH_BIT_NOTURL)
                ||      (dwFlags /* & LOOKUP_BIT_REDIR */)
                    &&  ((pItem->dwHash & HASH_FLAG_MASK) == HASH_REDIR))
            {
                // Found a valid entry.
                *pdwItemOffset = (DWORD) ((LPBYTE)pItem - pBase);  // 64BIT
                return pItem;
            }
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
            pTable = NULL;
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (pBase + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                pTable = NULL;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
        while (pTable);

    // We reached the end of the last table.
    *pdwItemOffset = 0;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\makefile.inc ===
..\inc\urlcache.h: urlcache.w
    wcshdr < urlcache.w > $@

!IF "$(PROCESSOR_ARCHITECTURE)" == "x86"

urlcache.sym: urlcache.map
    ..\win32s\tools\mapsympe -o urlcache.sym urlcache.map
    binplace urlcache.map
    binplace urlcache.sym

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <cache.hxx>

REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;

    // Don't allow keys or values to be written to current user during
    // GUI mode setup because they will get slammed into all profiles.
    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
        _dwAccess = BASIC_ACCESS;
    else
        _dwAccess = DEFAULT_KEY_ACCESS;
    return;
};


DWORD REGISTRY_OBJ::WorkWith(
    HKEY ParentHandle,
    LPTSTR KeyName,
    DWORD dwFlags,
    DWORD dwAccess
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = dwAccess;
    
    if (ParentHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        // Don't allow anything other than query and enumerate
        // when working with HKCU hive during GUI mode setup
        _dwAccess &= BASIC_ACCESS;
    }

    _Status = REGOPENKEYEX(
                ParentHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        REGISTRY_OBJ roTemp(ParentHandle, (LPSTR)NULL);
        _Status = roTemp.GetStatus();
        if (_Status==ERROR_SUCCESS)
        {
            _Status = roTemp.Create(KeyName, &_RegHandle);
        }
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD REGISTRY_OBJ::WorkWith(
    REGISTRY_OBJ *ParentObj,
    LPTSTR KeyName,
    DWORD dwFlags
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = ParentObj->GetAccessFlags();
    _Status = REGOPENKEYEX(
                ParentObj->_RegHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        _Status = ParentObj->Create(KeyName, &_RegHandle);
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    HKEY* pChildHandle
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        _Status = ERROR_ACCESS_DENIED;
        return _Status;
    }

    _Status = REGCREATEKEYEX(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               (pChildHandle) ? pChildHandle : &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS )
    {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
#else
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
    }

    //
    // close the child handle before return.
    //

    if (!pChildHandle)
    {
        REGCLOSEKEY( ChildHandle );
    }

    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        return ERROR_ACCESS_DENIED;
    }

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        return ERROR_ACCESS_DENIED;
    }

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

//    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
//    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPTSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

#ifdef unix
    if (Error == ERROR_SUCCESS) {
       CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)StringData,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           CacheHeap->Free(StringData);
           return (Error);
        }

        CacheHeap->Free(StringData);
        StringData = (LPBYTE)CacheHeap->Alloc( Length );
        if(StringData == NULL){
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        memcpy(StringData,szExpand,Length+1);
    }
#endif /* unix */

    *Data = (LPTSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPTSTR StrPtr = (LPTSTR)StringData;
        DWORD Len;

        while( (Len = lstrlen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

#ifdef unix
    {
    CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)Data,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           return (Error);
        }
        memcpy(Data,szExpand,Length+1);
    }
#endif /* unix */
    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPTSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    UNIX_NORMALIZE_IF_CACHE_PATH((LPTSTR)Data,TEXT("%USERPROFILE%"),ValueName);

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(TCHAR) * (lstrlen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPTSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(TCHAR);
    Error = RegEnumKeyEx(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPTSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPTSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPTSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPTSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPTSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKey( _RegHandle, (LPTSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::DeleteValue(
    LPTSTR ValueName
    )
{
    DWORD Error;
    Error = RegDeleteValue(
                _RegHandle,
                ValueName
                );


    return( Error );
}


DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\urlcache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corp.

Module Name: urlcache.cxx

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:
    Rajeev Dujari (rajeevd) 10-Apr-97

--*/

#include <cache.hxx>

DWORD
UrlCacheRetrieve
(
        IN  LPSTR                pszUrl,
        IN  BOOL                 fOffline,
        OUT HANDLE*              phStream,
        OUT CACHE_ENTRY_INFOEX** ppCEI
)
{
    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr;

    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    DWORD dwLookupFlags = fOffline? LOOKUP_URL_TRANSLATE
        : (LOOKUP_BIT_SPARSE | LOOKUP_URL_NOCREATE);

    DWORD cbCEI;
    
    // Find the container and search the index.
    dwErr = GlobalUrlContainers->RetrieveUrl(
                    pszUrl, 
                    (CACHE_ENTRY_INFO **) ppCEI, 
                    &cbCEI, 
                    dwLookupFlags, 
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    fLocked = TRUE;
    if ((*ppCEI)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {    
        *phStream = NULL;    
    }
    else
    {
        // Allocate a stream handle.
        CACHE_STREAM_CONTEXT_HANDLE* pStream;
        LOCK_CACHE();
        hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
        if (hStream)
        {
            pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
            INET_ASSERT (pStream);
        }
        UNLOCK_CACHE();
        if (!hStream)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        // Open the file.
        hFile = CreateFile
        (
            (*ppCEI)->lpszLocalFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
        );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError();
            goto Cleanup;
        }

        DWORD dwFileSize = GetFileSize(hFile, NULL);

        if (dwFileSize != (*ppCEI)->dwSizeLow) 
        {
            dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
            goto Cleanup;
        }

        pStream->FileHandle = hFile;

        // Copy URL name storage.
        pStream->SourceUrlName = NewString(pszUrl);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        *phStream = hStream;
    }
    
    dwErr = ERROR_SUCCESS;

Cleanup:

    if( dwErr != ERROR_SUCCESS )
    {
        if (*ppCEI)
        {
            FREE_MEMORY (*ppCEI);
            *ppCEI = NULL;
        }
        if (hStream)
            HandleMgr.Free (hStream);
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(pszUrl);
    }
    return dwErr;
}


void UrlCacheFlush (void)
{
    DWORD fPersist;
    
    REGISTRY_OBJ regCache (HKEY_CURRENT_USER, OLD_CACHE_KEY);
    
    if (    ERROR_SUCCESS == regCache.GetStatus()
        &&  ERROR_SUCCESS == regCache.GetValue (CACHE_PERSISTENT, &fPersist)
        &&  !fPersist
       )
    {
        FreeUrlCacheSpace (NULL, 100, STICKY_CACHE_ENTRY);
    }
}

DWORD UrlCacheCreateFile(LPCSTR szUrl, LPTSTR szExt, LPTSTR szFile, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->CreateUniqueFile(szUrl, 0, szExt, szFile, phfHandle, fCreatePerUser);
}

DWORD UrlCacheCommitFile(AddUrlArg* pArgs)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else        
        return GlobalUrlContainers->AddUrl(pArgs);
}

DWORD UrlCacheSendNotification(DWORD   dwOp)
{
    DWORD Error;

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
        
    Error = GlobalUrlContainers->SendCacheNotification(dwOp);

Cleanup:
    return Error;
}

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->AddLeakFile (pszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)    24-Nov-1997

--*/


#include <cache.hxx>

typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

static char vszDot[] = ".";
static char vszDotDot[] = "..";
#ifdef UNIX
static char vszIndexFile[] = "index.dat";
#endif /* UNIX */

static char vszSHClassInfo[]=".ShellClassInfo";

static char vszCLSIDKey[]="CLSID";
static char vszCLSID[]="{FF393560-C2A7-11CF-BFF4-444553540000}";

static char vszUICLSIDKey[]="UICLSID";
static char vszUICLSID[]="{7BD29E00-76C1-11CF-9DD0-00A0C9034933}";

typedef HRESULT (*PFNSHFLUSHCACHE)(VOID);

#ifdef UNIX
extern void UnixGetValidParentPath(LPTSTR szDevice);
#endif /* UNIX */

/*-----------------------------------------------------------------------------
DeleteOneCachedFile

    Deletes a file belonging to the cache.

Arguments:

    lpszFileName: Fully qualified filename

Return Value:

    TRUE if successful. If FALSE, GetLastError() returns the error code.

Comments:

  ---------------------------------------------------------------------------*/
BOOL
DeleteOneCachedFile(
    LPSTR   lpszFileName,
    DWORD   dostEntry)
{

    if (dostEntry)
    {
        DWORD dostCreate = 0;
        LPWORD pwCreate = (LPWORD) &dostCreate;
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        switch (GetFileSizeAndTimeByName(lpszFileName, &FileAttrData))
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }                    
    
        FileTimeToDosDateTime(&FileAttrData.ftCreationTime, pwCreate, pwCreate+1);

        if (dostCreate != dostEntry)
           return TRUE; // not our file, so consider it done!
    }


    if(!DeleteFile(lpszFileName))
    {
        TcpsvcsDbgPrint (( DEBUG_ERRORS, "DeleteFile failed on %s, Error=%ld\n",
            lpszFileName, GetLastError()));

        switch (GetLastError())
        {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }
    }
    else
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Deleted %s\n", lpszFileName ));
        return TRUE;
    }
}


/*-----------------------------------------------------------------------------
DeleteCachedFilesInDir
  ---------------------------------------------------------------------------*/
DWORD DeleteCachedFilesInDir(
    LPSTR   lpszPath,
    DWORD   dwLevel
    )
{
    TCHAR PathFiles[MAX_PATH+1];
    TCHAR FullFileName[MAX_PATH+1];
    LPTSTR FullFileNamePtr;
    WIN32_FIND_DATA FindData;

    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    // Since this has become a recursive call, we don't want to go more than 6 levels.
    if (dwLevel>5)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    DWORD Error, len, cbUsed;
    BOOL fFindSuccess;

    DWORD cb = strlen(lpszPath);
    memcpy(PathFiles, lpszPath, cb + 1);

    if(!AppendSlashIfNecessary(PathFiles, &cb)) 
    {
        Error = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    memcpy(FullFileName, PathFiles, cb + 1);
    memcpy(PathFiles + cb, ALLFILES_WILDCARD_STRING, sizeof(ALLFILES_WILDCARD_STRING));

    FullFileNamePtr = FullFileName + lstrlen( (LPTSTR)FullFileName );

    if ( IsValidCacheSubDir( lpszPath))
        DisableCacheVu( lpszPath);

    FindHandle = FindFirstFile( (LPTSTR)PathFiles, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE ) 
    {
        Error = GetLastError();
        goto Cleanup;
    }

    cbUsed = (unsigned int)(FullFileNamePtr-FullFileName);
    FullFileName[MAX_PATH] = '\0';
    do
    {
        cb = strlen(FindData.cFileName);
        if (cb+cbUsed+1 > MAX_PATH)
        {
            // Subtracting 1 extra so that the null terminator doesn't get overwritten
            cb = MAX_PATH - cbUsed - 2;
        }
        memcpy(FullFileNamePtr, FindData.cFileName, cb+1);

#ifndef UNIX
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#else
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszIndexFile, sizeof(vszIndexFile)-1) || 
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#endif /* UNIX */
        {
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                Error = DeleteCachedFilesInDir(FullFileName, dwLevel + 1);
                if (Error!=ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
                SetFileAttributes(FullFileName, FILE_ATTRIBUTE_DIRECTORY);
                RemoveDirectory(FullFileName);
            }
            else
            {
                DeleteOneCachedFile( (LPTSTR)FullFileName, 0);
            }
        }

        //
        // find next file.
        //

    } while (FindNextFile( FindHandle, &FindData ));

    Error = GetLastError();
    if( Error == ERROR_NO_MORE_FILES) 
    {
        Error = ERROR_SUCCESS;
    }

Cleanup:

    if( FindHandle != INVALID_HANDLE_VALUE ) 
    {
        FindClose( FindHandle );
    }

    if( Error != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "DeleteCachedFilesInDir failed, %ld.\n",
                Error ));
    }

    return( Error );
}


/*-----------------------------------------------------------------------------
AppendSlashIfNecessary
  ---------------------------------------------------------------------------*/
BOOL AppendSlashIfNecessary(LPSTR szPath, DWORD* pcbPath)
{
    if (*pcbPath > (MAX_PATH-2)) 
        return FALSE;
    if (szPath[*pcbPath-1] != DIR_SEPARATOR_CHAR)
    {
        szPath[*pcbPath] = DIR_SEPARATOR_CHAR;
        (*pcbPath)++;
        szPath[*pcbPath] = '\0';
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
EnableCachevu
  ---------------------------------------------------------------------------*/
BOOL EnableCacheVu(LPSTR szPath, DWORD dwContainer)
{       
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];
    DWORD dwFileAttributes;

    HMODULE hInstShell32 = 0;
    PFNSHFLUSHCACHE pfnShFlushCache = NULL;

#define DESIRED_ATTR (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

    // Calls with non-existant directory allowed and return false.
    dwFileAttributes = GetFileAttributes(szPath);
    if (dwFileAttributes == 0xFFFFFFFF)
        return FALSE;
    
    // Always be set to enable cachevu.
    SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM);
    
    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    if (dwFileAttributes == 0xFFFFFFFF)
    {
        dwFileAttributes = 0;

        // Always write out the UICLSID
        WritePrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  vszUICLSID,  szDesktopIni);    

        // HISTORY requires an additional CLSID.
        if (dwContainer == HISTORY)
            WritePrivateProfileString(vszSHClassInfo,  vszCLSIDKey,  vszCLSID,  szDesktopIni);    

        // Flush buffer - problems on Win95 if you don't.
        WritePrivateProfileString(NULL, NULL, NULL,  szDesktopIni);
    }

    if ((dwFileAttributes & DESIRED_ATTR) != DESIRED_ATTR)
    {
        // Should be hidden, read-only and system for cachevu to work correctly.
        SetFileAttributes(szDesktopIni, DESIRED_ATTR);
    }
/*
    BUGBUG - taking this code out for raid # 45710.
    // We now need to notify the shell that a new desktop.ini has been created.
    hInstShell32 = GetModuleHandle("shell32.dll");
    if (hInstShell32)
    {    
        pfnShFlushCache = (PFNSHFLUSHCACHE) GetProcAddress(hInstShell32, (LPSTR) 526);
        if (pfnShFlushCache)
        {
            __try
            {
                (*pfnShFlushCache)();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            ENDEXCEPT
        }
    }
*/
    return TRUE;

}

/*-----------------------------------------------------------------------------
IsValidCacheSubDir
  ---------------------------------------------------------------------------*/
BOOL IsValidCacheSubDir(LPSTR szPath)
{
    DWORD dwFileAttributes, cb, cbPath;
    CHAR szDesktopIni[MAX_PATH];
    CHAR szCLSID     [MAX_PATH];
    CHAR szWindowsDir[MAX_PATH];
    CHAR szSystemDir [MAX_PATH];

    cbPath = strlen(szPath);
            
    // Root, Windows or System directories
    // are decidedly not cache subdirectories.
    cb = GetWindowsDirectory(szWindowsDir, MAX_PATH);
    if (!cb || cb>MAX_PATH)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    AppendSlashIfNecessary(szWindowsDir, &cb);

    cb = GetSystemDirectory(szSystemDir, MAX_PATH);
    AppendSlashIfNecessary(szSystemDir, &cb);

    if (cbPath < 4 
        || !strnicmp(szPath, szWindowsDir, cbPath)
        || !strnicmp(szPath, szSystemDir, cbPath))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
    
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    // No desktop.ini found or system attribute not set.
    if (dwFileAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // Found UICLSID (CONTENT cachevu) ?
    if (GetPrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  
                                "", szCLSID, MAX_PATH, szDesktopIni)
        && !strcmp(szCLSID, vszUICLSID)) 
    {
        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
DisableCachevu
  ---------------------------------------------------------------------------*/
BOOL DisableCacheVu(LPSTR szPath)
{
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szDesktopIni);
    return TRUE;
}

/*-----------------------------------------------------------------------------
StripTrailingWhiteSpace
  ---------------------------------------------------------------------------*/
VOID StripTrailingWhiteSpace(LPSTR szString, LPDWORD pcb)
{
    INET_ASSERT(szString);

    if (*pcb == 0)
        return;

    CHAR* ptr = szString + *pcb - 1;

    while (*ptr == ' ')
    {
        ptr--;
        if (--(*pcb) == 0)
            break;
    }
    *(ptr+1) = '\0';
}


/* PerformOperationOverUrlCache-----------------------

The purpose of this function is to iterate through the content cache and perform the same action (here, called
an operation) on each entry in the cache.

This function takes all the parameters that FindFirstUrlCacheEntryEx accepts, 
plus two more:

op              -- This is of type CACHE_OPERATOR, discussed below
pOperatorData   -- a pointer to an array of data that the calling process and op use to collect/maintain info
 */

/* CACHE_OPERATOR
    is a pointer to function, that takes three arguments(pointer to a cache entry, cache entry size, and a pointer to 
    state data.

    The operator can perform whatever operation (move/copy/data collection) it wishes on the supplied cache entry.
    It must return TRUE if the operation has succeeded and PerformOperationOverUrlCache can continue to iterate through
    the cache, FALSE otherwise.

    pOpData can be null, or a cast pointer to whatever structure the operator will use to maintain state information.
        
    PerformOperationOverUrlCache guarantees that each cache entry will have sufficient space for its information.
*/ 

typedef BOOL (*CACHE_OPERATOR)(INTERNET_CACHE_ENTRY_INFO* pcei, PDWORD pcbcei, PVOID pOpData);


// hAdjustMemory is a helper function
// that ensures that the buffer used by PerformOperationOverUrlCache
// is large enough to hold all of a cache entry's info

BOOL hAdjustMemory(LPINTERNET_CACHE_ENTRY_INFO* pbBuffer, PDWORD pcbAvail, PDWORD pcbNeeded)
{
    if (*pbBuffer)
    {
        FREE_MEMORY(*pbBuffer);
    }
    do
    {
        *pcbAvail += 1024;
    } 
    while (*pcbAvail < *pcbNeeded);
    *pcbNeeded = *pcbAvail;
    *pbBuffer = (LPINTERNET_CACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbAvail);
    return (*pbBuffer!=NULL);
}


// PerformOperationOverUrlCache
// described above
// uses FindFirstUrlCacheEntryEx and FindNext as any other wininet client would.
// and passes a complete cache entry to the operator for processing

BOOL PerformOperationOverUrlCacheA(
    IN     PCSTR     pszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    PVOID     pReserved1,
    IN OUT PDWORD    pdwReserved2,
    IN     PVOID     pReserved3,
    IN       CACHE_OPERATOR op, 
    IN OUT PVOID     pOperatorData
    )
{
    BOOL fResult = FALSE;

    DWORD cbAvail = sizeof(INTERNET_CACHE_ENTRY_INFO) + 1024;
    DWORD cbCEI = cbAvail;
    LPINTERNET_CACHE_ENTRY_INFO pCEI = (LPINTERNET_CACHE_ENTRY_INFO) ALLOCATE_FIXED_MEMORY(cbAvail);
    HANDLE hFind = NULL;

    if (pCEI == NULL)
        goto Cleanup;

    hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    if (!hFind && (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(&pCEI, &cbAvail, &cbCEI))
    {
        hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    }

    if (hFind!=NULL)
    {
        do
        {
            fResult = op(pCEI, &cbCEI, pOperatorData);
            if (fResult)
            {
                cbCEI = cbAvail;
                fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                if (!fResult && (GetLastError()==ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(&pCEI, &cbAvail, &cbCEI))
                {
                    fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                }
            } 
        }
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = TRUE;
        } 
    }

Cleanup:
    if (pCEI)
    {
        FREE_MEMORY(pCEI);
    }
    return fResult;
}

// ------ MoveCachedFiles ---------------------------------------------------------------------------------------
// Purpose: Moves as many files as possible from the current Temporary Internet Files to the new location


// State information required for the move operation
struct MOVE_OP_STATE
{
    TCHAR szNewPath[MAX_PATH];
    TCHAR szOldPath[MAX_PATH];
    DWORD ccNewPath;
    DWORD ccOldPath;
    DWORDLONG dlCacheSize;
    DWORD dwClusterSizeMinusOne;
    DWORD dwClusterSizeMask;
};

// Helper function that, 
// given a string pointer, 
// returns the next occurrence of DIR_SEPARATOR_CHAR ('/' || '\\')
PTSTR hScanPastSeparator(PTSTR pszPath)
{
    while (*pszPath && *pszPath!=DIR_SEPARATOR_CHAR)
    {
        pszPath++;
    }
    if (*pszPath)
    {
        return pszPath+1;
    }
    return NULL;
}

// Helper function that,
// given a path,
// ensures that all the directories in the path exist
BOOL hConstructSubDirs(PTSTR pszBase)
{
    PTSTR pszLast = hScanPastSeparator(pszBase);

    if (NULL == pszLast)
        return TRUE;    // returning TRUE on purpose

    PTSTR pszNext = pszLast;
    while ((pszNext=hScanPastSeparator(pszNext))!=NULL)
    {
        *(pszNext-1) = '\0';
        CreateDirectory(pszBase, NULL);
        *(pszNext-1) = DIR_SEPARATOR_CHAR;
        pszLast = pszNext;
    }
    return TRUE;
}

// MoveOperation
// actually moves a cached file to the new location

BOOL MoveOperation(LPINTERNET_CACHE_ENTRY_INFO pCEI, PDWORD pcbCEI, PVOID pOpData)
{
    MOVE_OP_STATE* pmos = (MOVE_OP_STATE*)pOpData;
    BOOL fResult = TRUE;

    if (pCEI->lpszLocalFileName)
    {
        if (!strnicmp(pCEI->lpszLocalFileName, pmos->szOldPath, pmos->ccOldPath))
        {
            // Copy the file
            lstrcpy(pmos->szNewPath + pmos->ccNewPath, pCEI->lpszLocalFileName + pmos->ccOldPath);        
            fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
            if (!fResult && GetLastError()==ERROR_PATH_NOT_FOUND)
            {
                if (hConstructSubDirs(pmos->szNewPath))
                {
                    fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
                }
            }
            // If the move was successful, we need to adjust the size of the new cache
            if (fResult)
            {
                fResult = FALSE;
                
                HANDLE h1 = CreateFile(pCEI->lpszLocalFileName, 
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

                // If we can't open the original file, then the new file will never
                // get scavenged because we'll never be able to match creation times
                if (h1!=INVALID_HANDLE_VALUE)
                {
                    HANDLE h2 = CreateFile(pmos->szNewPath, 
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
                    if (h2!=INVALID_HANDLE_VALUE)
                    {
                        FILETIME ft;
                        if (GetFileTime(h1, &ft, NULL, NULL))
                        {
                            fResult = SetFileTime(h2, &ft, NULL, NULL);
                        }
                        CloseHandle(h2);
                    }
                    CloseHandle(h1);
                }
            }

            // If we haven't been able to set the create time, then we've got a problem
            // we'd sooner not deal with.
            if (!fResult)
            {
                DeleteUrlCacheEntry(pCEI->lpszSourceUrlName);
                DeleteFile(pmos->szNewPath);
            }
            else
            {
                pmos->dlCacheSize += ((LONGLONG) (pCEI->dwSizeLow + pmos->dwClusterSizeMinusOne) 
                                        & pmos->dwClusterSizeMask);
            }

            // Delete the old one
            DeleteFile(pCEI->lpszLocalFileName);
        }
    }
    return TRUE;
}


DWORD
MoveCachedFiles(
    LPSTR     pszOldPath,
    LPSTR     pszNewPath
)
{
    MOVE_OP_STATE mos;
    INET_ASSERT(pszOldPath && pszNewPath);

    mos.ccNewPath = lstrlen(pszNewPath);
    memcpy(mos.szNewPath, pszNewPath, mos.ccNewPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);
    memcpy(mos.szNewPath + mos.ccNewPath, CONTENT_VERSION_SUBDIR, sizeof(CONTENT_VERSION_SUBDIR));
    mos.ccNewPath += sizeof(CONTENT_VERSION_SUBDIR)-1;
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);

    mos.ccOldPath = lstrlen(pszOldPath);
    memcpy(mos.szOldPath, pszOldPath, mos.ccOldPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szOldPath, &mos.ccOldPath);

    mos.dlCacheSize = 0;
    GetDiskInfo(mos.szNewPath, &mos.dwClusterSizeMinusOne, NULL, NULL);
    mos.dwClusterSizeMinusOne--;
    mos.dwClusterSizeMask = ~mos.dwClusterSizeMinusOne;
    
    GlobalUrlContainers->WalkLeakList(CONTENT);

    // We don't need to get all the information about each and every entry.
    PerformOperationOverUrlCacheA(
        NULL, 
        FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME,
        NORMAL_CACHE_ENTRY | STICKY_CACHE_ENTRY | SPARSE_CACHE_ENTRY,
        NULL,
        NULL,
        NULL,
        NULL,
        MoveOperation, 
        (PVOID)&mos);

    GlobalUrlContainers->SetCacheSize(CONTENT, mos.dlCacheSize);
    
    // Copy desktop.ini and index.dat, since these aren't cached
    TCHAR szFile[MAX_PATH];
    DWORD ccOldPath = lstrlen(pszOldPath);
    memcpy(szFile, pszOldPath, ccOldPath);
    AppendSlashIfNecessary(szFile, &ccOldPath);
    memcpy(szFile + ccOldPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    memcpy(szFile + ccOldPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
IsCorrectUser

Routine Description:

    checks to see from the headers whether there is any username in there and
    whether it matches the currently logged on user. If no one is logged on a
    default username string is used

Arguments:

    lpszHeaderInfo: headers to check

    dwheaderSize:   size of the headers buffer

Return Value:

    BOOL


---------------------------------------------------------------------------*/
BOOL
IsCorrectUserPrivate(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    LPSTR lpTemp, lpTemp2;

    INET_ASSERT (lpszHeaderInfo);

    lpTemp = lpszHeaderInfo+dwHeaderSize-1;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) {

        if (*lpTemp ==':') {
            // If this is less than the expected header:
            // then we know that there is no such usernameheader 
            // <MH> i.e. it's not a peruseritem so allow access</MH>

            if ((DWORD)PtrDifference((lpTemp+1), lpszHeaderInfo) < (sizeof(vszUserNameHeader)-1)) {
                TcpsvcsDbgPrint((DEBUG_CONTAINER,
                    "IsCorrectUser (Util.cxx): Didn't find header <lpTemp = 0x%x %s> <lpszHeaderInfo = 0x%x %s> <vszCurrentUser = %s> <PtrDifference = %d> <sizeof(vszUserNameHeader)-1) = %d>\r\n",
                    lpTemp,
                    lpTemp,
                    lpszHeaderInfo,
                    lpszHeaderInfo,
                    vszCurrentUser,
                    PtrDifference(lpTemp, lpszHeaderInfo),
                    (sizeof(vszUserNameHeader)-1)
                    ));
                return (TRUE); // No such header. just ay it is OK
            }

            // point this puppy to the expected header start
            lpTemp2 = lpTemp - (sizeof(vszUserNameHeader)-2);

            // if the earlier char is not a white space [0x9-0xd or 0x20]
            // then this is not the beginning of the header
            // <MH> Also need to check for the first header which would not 
            // have whitespace preceding it. Want to first check lpTemp2 ==
            // lpszheaderInfo to prevent underflowing when dereferencing.</MH>

            if (((lpTemp2) == lpszHeaderInfo) || isspace(*(lpTemp2-1))) {

                // we have the beginning of a header
                if (!strnicmp(lpTemp2
                                , vszUserNameHeader
                                , sizeof(vszUserNameHeader)-1)) {

                    // right header, let us see whether this is the right person
                    if(!strnicmp(lpTemp+1, vszCurrentUser, vdwCurrentUserLen)) {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): Match!! %s header == %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));
                    
                        return (TRUE); // right guy
                    }
                    else {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): No match!! %s header != %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));

                    }

                    return(FALSE); // wrong guy
                }
            }
        }
        --lpTemp;
    }

    return (TRUE); // there was no UserName header, just say it is OK
}


BOOL
IsCorrectUser(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    BOOL fRet = FALSE;
    
    __try
    {
        fRet = IsCorrectUserPrivate(lpszHeaderInfo, dwHeaderSize);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        fRet = FALSE;
    }
    ENDEXCEPT
    return fRet;
}



#ifndef UNICODE
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExA"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionA"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionA"
#else
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExW"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionW"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionW"
#endif

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef BOOL (WINAPI *PFNWNETUSECONNECTION)(HWND, LPNETRESOURCE, PSTR, PSTR, DWORD, PSTR, PDWORD, PDWORD);
typedef BOOL (WINAPI *PFNWNETCANCELCONNECTION)(LPCTSTR, BOOL);

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn)
{
    if (*pfn==(PFN)-1)
    {
        *pfn = NULL;
        HMODULE ModuleHandle = GetModuleHandle(pszModule);
        if (ModuleHandle)
        {
            *pfn = (PFN)GetProcAddress(ModuleHandle, pszFunction);
        }
    }        

    return (*pfn!=NULL);
}


// GetPartitionClusterSize

// GetDiskFreeSpace has the annoying habit of lying about the layout
// of the drive; thus we've been ending up with bogus sizes for the cluster size.
// You can't imagine how annoying it is to think you've a 200 MB cache, but it
// starts scavenging at 20MB.

// This function will, if given reason to doubt the veracity of GDFS, go straight 
// to the hardware and get the information for itself, otherwise return the passed-in
// value.

// The code that follows is heavily doctored from msdn sample code. Copyright violation? I think not.

static PFNGETDISKFREESPACEEX pfnGetDiskFreeSpaceEx = (PFNGETDISKFREESPACEEX)-1;
#define VWIN32_DIOC_DOS_DRIVEINFO   6

typedef struct _DIOC_REGISTERS 
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} 
DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 

typedef struct 
_DPB {
    BYTE    dpb_drive;          // Drive number (1-indexed)
    BYTE    dpb_unit;           // Unit number
    WORD    dpb_sector_size;    // Size of sector in bytes
    BYTE    dpb_cluster_mask;   // Number of sectors per cluster, minus 1
    BYTE    dpb_cluster_shift;  // The stuff after this, we don't really care about. 
    WORD    dpb_first_fat;
    BYTE    dpb_fat_count;
    WORD    dpb_root_entries;
    WORD    dpb_first_sector;
    WORD    dpb_max_cluster;
    WORD    dpb_fat_size;
    WORD    dpb_dir_sector;
    DWORD   dpb_reserved2;
    BYTE    dpb_media;
    BYTE    dpb_first_access;
    DWORD   dpb_reserved3;
    WORD    dpb_next_free;
    WORD    dpb_free_cnt;
    WORD    extdpb_free_cnt_hi;
    WORD    extdpb_flags;
    WORD    extdpb_FSInfoSec;
    WORD    extdpb_BkUpBootSec;
    DWORD   extdpb_first_sector;
    DWORD   extdpb_max_cluster;
    DWORD   extdpb_fat_size;
    DWORD   extdpb_root_clus;
    DWORD   extdpb_next_free;
} 
DPB, *PDPB;

#pragma pack()

DWORD GetPartitionClusterSize(PTSTR szDevice, DWORD dwClusterSize)
{
    switch (GlobalPlatformType)
    {
    case PLATFORM_TYPE_WIN95:
        // If GetDiskFreeSpaceEx is present _and_ we're running Win9x, this implies
        // that we must be doing OSR2 or later. We can trust earlier versions 
        // of the GDFS (we think; this assumption may be invalid.)

        // Since Win95 can't read NTFS drives, we'll freely assume we're reading a FAT drive.
        // Basically, we're performing an MSDOS INT21 call to get the drive partition record. Joy.
        
        if (pfnGetDiskFreeSpaceEx)
        {
            HANDLE hDevice;
            DIOC_REGISTERS reg;
            BYTE buffer[sizeof(WORD)+sizeof(DPB)];
            PDPB pdpb = (PDPB)(buffer + sizeof(WORD));
    
            BOOL fResult;
            DWORD cb;

            // We must always have a drive letter in this case
            int nDrive = *szDevice - TEXT('A') + 1;  // Drive number, 1-indexed

            hDevice = CreateFile("\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if (hDevice!=INVALID_HANDLE_VALUE)
            {
                reg.reg_EDI = PtrToUlong(buffer);
                reg.reg_EAX = 0x7302;        
                reg.reg_ECX = sizeof(buffer);
                reg.reg_EDX = (DWORD) nDrive; // drive number (1-based) 
                reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

                fResult = DeviceIoControl(hDevice, 
                                          VWIN32_DIOC_DOS_DRIVEINFO,
                                          &reg, sizeof(reg), 
                                          &reg, sizeof(reg), 
                                          &cb, 0);

                if (fResult && !(reg.reg_Flags & 0x0001))
                {
                    // no error if carry flag is clear
                    dwClusterSize = DWORD((pdpb->dpb_cluster_mask+1)*pdpb->dpb_sector_size);
                }
                CloseHandle(hDevice);
            }
        }
        break;

    default:
        // Do nothing. Trust the value we've been passed.
        // UNIX guys will have to treat this separately.

        // For NT, however, this might be another issue. We can't use the DOS INT21.
        // Questions:
        // NT5 (but not NT4) supports FAT32; will we get honest answers? Apparently, yes.
        // NT4/5: NTFS drives and other FAT drives -- do we still get honest answers? Investigation
        // so far says, Yes. 
        break;
    }
    
    return dwClusterSize;
}


/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfoA(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal)
{
    static PFNWNETUSECONNECTION pfnWNetUseConnection = (PFNWNETUSECONNECTION)-1;
    static PFNWNETCANCELCONNECTION pfnWNetCancelConnection = (PFNWNETCANCELCONNECTION)-1;

    if (!pszPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    INET_ASSERT(pdwClusterSize || pdlAvail || pdlTotal);
    // If GetDiskFreeSpaceExA is available, we can be confident we're running W95OSR2+ || NT4
    EstablishFunction(TEXT("KERNEL32"), SZ_GETDISKFREESPACEEX, (PFN*)&pfnGetDiskFreeSpaceEx);
  
    BOOL fRet = FALSE;
    TCHAR szDevice[MAX_PATH];
    PTSTR pszGDFSEX = NULL;
   
    if (*pszPath==DIR_SEPARATOR_CHAR)
    {
        // If we're dealing with a cache that's actually located on a network share, 
        // that's fine so long as we have GetDiskFreeSpaceEx at our disposal.
        // _However_, if we need the cluster size on Win9x, we'll need to use
        // INT21 stuff (see above), even if we have GDFSEX available, so we need to map
        // the share to a local drive.
        
        if (pfnGetDiskFreeSpaceEx 
            && !((GlobalPlatformType==PLATFORM_TYPE_WIN95) && pdwClusterSize))
        {
            DWORD cbPath = lstrlen(pszPath);
            cbPath -= ((pszPath[cbPath-1]==DIR_SEPARATOR_CHAR) ? 1 : 0);
            if (cbPath>MAX_PATH-2)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            memcpy(szDevice, pszPath, cbPath);
            szDevice[cbPath] = DIR_SEPARATOR_CHAR;
            cbPath++;
            szDevice[cbPath] = '\0';
            pszGDFSEX = szDevice;
        }
        else
        {
            if (!(EstablishFunction(TEXT("MPR"), SZ_WNETUSECONNECTION, (PFN*)&pfnWNetUseConnection)
                &&
               EstablishFunction(TEXT("MPR"), SZ_WNETCANCELCONNECTION, (PFN*)&pfnWNetCancelConnection)))
            {
                return FALSE;
            }

           // If it's a UNC, map it to a local drive for backwards compatibility
            NETRESOURCE nr = { 0, RESOURCETYPE_DISK, 0, 0, szDevice, pszPath, NULL, NULL };
            DWORD cbLD = sizeof(szDevice);
            DWORD dwNull;
            if (pfnWNetUseConnection(NULL, 
                          &nr, 
                          NULL, 
                          NULL, 
                          CONNECT_INTERACTIVE | CONNECT_REDIRECT, 
                          szDevice,
                          &cbLD,
                          &dwNull)!=ERROR_SUCCESS)
            {
                SetLastError(ERROR_NO_MORE_DEVICES);        
                return FALSE;
            }
        }
    }
    else
    {
        memcpy(szDevice, pszPath, sizeof(TEXT("?:\\")));
        szDevice[3] = '\0';
        pszGDFSEX = pszPath;
    }
    if (*szDevice!=DIR_SEPARATOR_CHAR)
    {
        *szDevice = (TCHAR)CharUpper((LPTSTR)*szDevice);
    }

#ifdef UNIX
    /* On Unix, GetDiskFreeSpace and GetDiskFreeSpaceEx will work successfully
     * only if the path exists. So, let us pass a path that exists
     */
    UnixGetValidParentPath(szDevice);
#endif /* UNIX */

    // I hate goto's, and this is a way to avoid them...
    for (;;)
    {
        DWORDLONG cbFree = 0, cbTotal = 0;
    
        if (pfnGetDiskFreeSpaceEx && (pdlTotal || pdlAvail))
        {
            ULARGE_INTEGER ulFree, ulTotal;

            // BUG BUG BUG Is the following problematic? Also, we'll need to add checks to make sure that 
            // the  cKBlimit fits a DWORD (in the obscene if unlikely case drive spaces grow that large)
            // For instance, if this is a per user system with a non-shared cache, we might want to change
            // the ratios.
            INET_ASSERT(pszGDFSEX);
            fRet = pfnGetDiskFreeSpaceEx(pszGDFSEX, &ulFree, &ulTotal, NULL);

            // HACK Some versions of GetDiskFreeSpaceEx don't accept the whole directory; they
            // take only the drive letter. Pfft.
            if (!fRet)
            {
                fRet = pfnGetDiskFreeSpaceEx(szDevice, &ulFree, &ulTotal, NULL);
            }

            if (fRet)
            {
                cbFree = ulFree.QuadPart;
                cbTotal = ulTotal.QuadPart;
            }
        }

        if ((!fRet) || pdwClusterSize)
        {
            DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwClusters, dwClusterSize;
            if (!GetDiskFreeSpace(szDevice, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
            {
                fRet = FALSE;
                break;
            }
            
            dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;

            if (!fRet)
            {
                cbFree = (DWORDLONG)dwClusterSize * (DWORDLONG)dwFreeClusters;
                cbTotal = (DWORDLONG)dwClusterSize * (DWORDLONG)dwClusters;
            }
            
            if (pdwClusterSize)
            {
                *pdwClusterSize = GetPartitionClusterSize(szDevice, dwClusterSize);
            }
        }

        if (pdlTotal)
        {
             *pdlTotal = cbTotal;
        }
        if (pdlAvail)
        {
             *pdlAvail = cbFree;
        }
        fRet = TRUE;
        break;
    };
    
    // We've got the characteristics. Now delete local device connection, if any.
    if (*pszPath==DIR_SEPARATOR_CHAR && !pfnGetDiskFreeSpaceEx)
    {
        pfnWNetCancelConnection(szDevice, FALSE);
    }

    return fRet;
}


// -- ScanToLastSeparator
// Given a path, and a pointer within the path, discover where the path separator prior to the path
// is located and return the pointer to it. If there is none, return NULL.

BOOL ScanToLastSeparator(PTSTR pszPath, PTSTR* ppszCurrent)
{
    PTSTR pszActual = *ppszCurrent;
    pszActual--;
    while ((pszActual>(pszPath+1)) && (*pszActual!=DIR_SEPARATOR_CHAR))
    {
        pszActual--;
    }
    if ((*pszActual==DIR_SEPARATOR_CHAR) && (pszActual!=*ppszCurrent))
    {
        *ppszCurrent = pszActual;
        return TRUE;
    }

    return FALSE;
}

// -- Centralised method of tracking mutexes
// class MUTEX_HOLDER

MUTEX_HOLDER::MUTEX_HOLDER()
{
    _hHandle = NULL;
    _dwState = WAIT_FAILED;
}

MUTEX_HOLDER::~MUTEX_HOLDER()
{
    if (_hHandle)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "ERROR: Releasing ownership of mutex %d\r\n",
            _hHandle));
        ReleaseMutex(_hHandle);
    }
}

VOID MUTEX_HOLDER::Grab(HANDLE hHandle, DWORD dwTime)
{
    INET_ASSERT(hHandle);
    _hHandle = hHandle;
    _dwState = WaitForSingleObject(_hHandle, dwTime);
    if (_dwState==WAIT_ABANDONED)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of abandoned mutex %d\r\n",
            hHandle));
    }
    else if (_dwState==WAIT_OBJECT_0)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of mutex %d\r\n",
            hHandle));
    }
    else
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Unable to gain ownership of mutex %d\r\n",
            hHandle));
    }
}

VOID MUTEX_HOLDER::Release()
{
    if (_hHandle)
    {
        if (_dwState==WAIT_ABANDONED || _dwState==WAIT_OBJECT_0)
        {
            ReleaseMutex(_hHandle);
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Released ownership of mutex %d\r\n",
                _hHandle));
        }
        else
        {
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Would release ownership of mutex %d, except we don't own it\r\n",
                _hHandle));
        }
    }
    _hHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hist\histapi.h ===
// history.
#ifndef _HISTAPI_
#define _HISTEAPI_

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_HISTORYAPI_)
#define HISTORYAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define HISTORYAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define HISTORYAPI          EXTERN_C HRESULT STDAPICALLTYPE
#define HISTORYAPI_(type)   EXTERN_C type STDAPICALLTYPE
#endif

typedef struct _HISTORY_ITEM_INFO {
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;


HISTORYAPI_(BOOL)
FindCloseHistory (
    IN HANDLE hEnumHandle
    );


HISTORYAPI_(BOOL)
FindNextHistoryItem(
    IN HANDLE hEnumHandle,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    );



HISTORYAPI_(HANDLE)
FindFirstHistoryItem(
    IN LPCTSTR  lpszUrlSearchPattern,
    OUT LPHISTORY_ITEM_INFO lpFirstHistoryItemInfo,
    IN OUT LPDWORD lpdwFirstHistoryItemInfoBufferSize
    );

HISTORYAPI_(BOOL)
GetHistoryItemInfo (
    IN LPCTSTR lpszUrlName,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    );


HISTORYAPI_(BOOL)
RemoveHistoryItem (
    IN LPCTSTR lpszUrlName,
    IN DWORD dwReserved
    );


HISTORYAPI_(BOOL)
IsHistorical(
    IN LPCTSTR lpszUrlName
    );

HISTORYAPI_(BOOL)
AddHistoryItem(
    IN LPCTSTR lpszUrlName,		//direct correspondence in URLCACHE
    IN LPCTSTR lpszHistoryTitle,		// this needs to be added to lpHeaderInfo
	IN LPCTSTR lpszDependancies,
	IN DWORD dwFlags,
    IN DWORD dwReserved
    );




#ifdef __cplusplus
}
#endif


#endif  // _HISTAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\ckcnv\ckcnv.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  ckcnv.cxx

Abstract:
  Upgrades cookies to present urlcache format by enumerating cookie files in the
  cache cookies directory and creates cookie cache index entries in the format of 
  the current wininet.dll. 
    
Author:
    Adriaan Canter (adriaanc) 09-Jan-1997
        Created

    Adriaan Canter (adriaanc) 01-Feb-1997    
        Modified for per-user caches. The class CCookieLoader definition 
        can now be pasted into the urlcache build without re-definition
        and work correctly, as long as the HKLM and HKCU cache keys are
        not modified. BUGBUG - do this.

-----------------------------------------------------------------------------*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wininet.h>
#include "cachedef.h"

#define INET_ASSERT(condition) Assert(condition)

/*-----------------------------------------------------------------------------
    class CCookieLoader

    Class used to perform cookie conversion
  ----------------------------------------------------------------------------*/
class CCookieLoader
{
private:
    DWORD GetHKLMCookiesDirectory(CHAR*);
    DWORD GetHKCUCookiesDirectory(CHAR*);
    CHAR* ParseNextCookie(CHAR*, CHAR**, FILETIME*, FILETIME*);
    
public:
    DWORD LoadCookies(BOOL);
};


// Debug assert code.
#if DBG
#define Assert(Predicate) \
    { \
        if (!(Predicate)) \
            AssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
AssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else
#define Assert(_x_)
#endif // DBG

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, CACHE_SPECIAL_PATHS_KEY);
    strcat(szCookiesDirRegKey, "\\");    
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKCUCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKCUCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;
    
    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER,
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}


/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0 
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;
   
    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokEx(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokEx(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokEx(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokEx(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokEx(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokEx(&ptr, "\n");             
        pszLastTimeLow    = StrTokEx(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokEx(&ptr, "\n");
        pszDelimiter      = StrTokEx(&ptr, "\n");      // Delimiter should be "*"

    
        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            INET_ASSERT(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);        

        pszNextCookie = pszDelimiter+2;
    }
    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        pszNextCookie = 0;
        goto exit;
    }

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(BOOL fConvertToPerUser)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szHKCUCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],    
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];
                    
    CHAR               *pszHash, *ptr, *pszCookiesPath,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;

    __try
    {   
        szBuffer = 0;

        // Check to see if we are upgrading cookies
        // from local machine to per user.
        if (fConvertToPerUser)
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.            
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            if (dwError = GetHKLMCookiesDirectory(szHKLMCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);

            // Get the cookies directory as specified by HKCU.
            if (dwError = GetHKCUCookiesDirectory(szHKCUCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            strcat(szCookieFileNamePattern, "\\");
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");
        
            // Enumerate the users cache files        
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind == INVALID_HANDLE_VALUE)
            {
                // OK, No cookie files to upgrade.
                dwError = ERROR_SUCCESS;
                goto exit;
            }    
        
            // One or more cookie files exist.
            do
            {
                // Construct absolute path from HKLM to cookies file.
                strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                strcat(szHKLMCookieFileName, "\\");
                strcat(szHKLMCookieFileName, FindData.cFileName);
                
                // Construct absolute path from HKCU to cookies file.
                strcpy(szHKCUCookieFileName, szHKCUCookiesPath);
                strcat(szHKCUCookieFileName, "\\");
                strcat(szHKCUCookieFileName, FindData.cFileName);
            
                // Copy the file to the per-user directory.
                CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);

            } while (FindNextFile(hFind, &FindData)); 
        
            // Close the Find handle.
            if (hFind != INVALID_HANDLE_VALUE)
            {
                FindClose(hFind);        
                hFind = INVALID_HANDLE_VALUE;
            }

        } // Per-user upgrade.
        else
        {
            // No per-user upgrade. szCookieFileNamePattern will look like
            // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, "\\*@*.txt");
        }

        // We now have the appropriate cookie filename pattern, also need a copy
        // of the cookies directory associated with the current user.
        pszCookiesPath = (fConvertToPerUser ? szHKCUCookiesPath : szHKLMCookiesPath);
        
        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }    

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            strcpy(szCookieFileName, pszCookiesPath);
            strcat(szCookieFileName, "\\");
            strcat(szCookieFileName, FindData.cFileName);
            
            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );                   

            // File handle must be valid.
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? -> 
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                INET_ASSERT(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie, 
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"            
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);
                        ptr = strstr(szCookieName, "@");
                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO*) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = GetUrlCacheEntryInfo(szCookieName, pCacheEntryInfo, 
                            &cbCacheEntryInfoBuffer);

                        if (dwError == ERROR_SUCCESS 
                            && CompareFileTime(&pCacheEntryInfo->LastModifiedTime, &ftLast) > 0)
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or 
                            // it was found and the last modified time on it is 
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.
                            BOOL bCommit;
                            bCommit = CommitUrlCacheEntry(
                                szCookieName,           // cookie:user@foobar.com.
                                szCookieFileName,       // c:\winnt\cookies\user@foobar.txt.
                                ftExpire,               // Expire time.
                                ftLast,                 // Last modified time.
                                0,                      // CacheEntryType.
                                0,                      // HeaderInfo.
                                0,                      // HeaderSize.
                                0,                      // FileExtension.
                                0);                     // Reserved.

                            INET_ASSERT(bCommit);
                        } 

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.
                    
        } while (FindNextFile(hFind, &FindData)); 

        
        // No more cookie files or an error occured.        
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);

        return dwError;

    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
                
        INET_ASSERT(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

}


int WINAPI WinMain(HINSTANCE hInstance,	HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DWORD dwError;
    CHAR szFilename[MAX_PATH];
    CCookieLoader cc;

    __try
    {
    
        // Convert cookies.
        dwError = cc.LoadCookies(FALSE);

        // See if we're supposed to delete this
        // executable after the user reboots.
        if (!_strnicmp(lpCmdLine, "/D", sizeof("/D")))
        {

            // Got this filename?
            if (GetModuleFileName(NULL, szFilename, MAX_PATH))
            {
                OSVERSIONINFO osVersionInfo;
                osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
                if (GetVersionEx(&osVersionInfo))
                {
                    // Two different methods of deleting this file
                    // depending on the platform ID.
                    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    {
                        // Platform is Windows NT.
                        MoveFileEx(szFilename, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    else
                    {
                        // Platform is Windows 95
                        WriteProfileSection("NUL", szFilename);
                    }

                }
            }
        }
    }
    

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_EXTENDED_ERROR;
    }

    return (dwError == ERROR_SUCCESS ? 0 : 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hist\generic.h ===
//generic.h

BOOL
ParseArgsDyn(
    LPSTR InBuffer,
    LPSTR **pArgv,
    LPDWORD pArgc
    );

DWORD 
AddArgvDyn (LPTSTR **pArgv, DWORD *pArgc, LPTSTR szNew);

LPBYTE
MemFind (LPBYTE lpB, DWORD cbB, LPBYTE lpP, DWORD cbP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hist\histapi.c ===
#include <windows.h>
#include <stdio.h>
#include <urlcache.h>
#include <histapi.h>

//#include "cache.hxx"

//#include "history.h"
#include "generic.h"

#define DEFAULT_CEI_BUFFER_SIZE		512
	// 1k ~> sizeof (CEI) + lpszSourceUrlName + lpHeaderInfo(~<255) + lpszLocalFileName(<255)

#define ASSERT(x) if (!(x)) DebugBreak();

LPCTSTR lpszHistoryPrefix = "Hist:";
DWORD cbHistoryPrefix = sizeof("Hist:") -1;

LPCTSTR lpszTitleHeader = "Title: ";
DWORD cbTitleHeader = sizeof("Title: ") -1;

LPCTSTR lpszFragmentHeader = "Frags: ";
DWORD cbFragmentHeader = sizeof("Frags: ") -1;

LPCTSTR lpszHistoryFileExtension = "HSD";

LPTSTR szCRLF = "\r\n";
DWORD cbCRLF = sizeof("\r\n") -1;
LPTSTR szSPC = " ";
LPTSTR szPND = "#";
LPTSTR szFRAGB = " (#";
LPTSTR szFRAGE = ")";

typedef struct _HISTORY_SEARCH_OBJ 
{
	HANDLE hEnum;
	LPTSTR lpszPrefixedUrl;
	LPTSTR lpszFragment;
	LPCACHE_ENTRY_INFO lpCEI;
	LPTSTR *aFrags;
	DWORD cFrags;
	DWORD iFrags;
} HISTORY_SEARCH_OBJ, *LPHISTORY_SEARCH_OBJ;

typedef struct _HISTORY_ITEM_INFO 
{
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;



LPTSTR
GetDependanciesFromCEI (LPCACHE_ENTRY_INFO lpCEI)
{
	LPTSTR buf = NULL;
	HANDLE file = NULL;
	DWORD size = 0;
	LPTSTR pch = NULL;

	ASSERT (lpCEI);

	file = CreateFile(lpCEI->lpszLocalFileName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (file == INVALID_HANDLE_VALUE)
		return NULL;

	size = GetFileSize(file, NULL);

	buf = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!buf)
	{
		CloseHandle(file);
		return NULL;
	}

	buf[size] = '\0';

//  we are going to store these as URL\nURL\nURL\n so just look for \n and replace with space

	for (pch = buf; *pch; pch++)
	{
		if (*pch == '\n')
			*pch = ' ';
	}

	CloseHandle (file);
	return buf;
}

LPTSTR
MakeDependanciesFile (LPCTSTR lpszDeps)
{
	HANDLE file = NULL;
	LPTSTR pch = NULL;
	LPTSTR path = NULL;
	LPTSTR temp = NULL;
	DWORD size = 0;

	path = _tempnam (NULL, "HS");
	if (!path)
		return NULL;

	file = CreateFile(path,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (file == INVALID_HANDLE_VALUE)
	{
		LocalFree (path);
		return NULL;
	}

//  we are going to store these as URL\nURL\nURL\n 
	
	if(lpszDeps)
	{
		size = lstrlen (lpszDeps);

		temp = LocalAlloc (LPTR, size + 1);
		if (!temp)
		{
			LocalFree (path);
			CloseHandle (file);
			return NULL;
		}

		lstrcpy (temp, lpszDeps);

		for (pch = temp; *pch; pch++)
		{
			if (*pch == ' ')
				*pch = '\n';
		}

		WriteFile (file, temp, size, &size, NULL);
	}

	CloseHandle (file);
	return path;
}

LPTSTR
ConvertToUnprefixedUrl (
						LPCTSTR lpszPrefixedUrl,
						LPCTSTR lpszFragment
						)
{
	DWORD size = 0;
	LPTSTR lpszUrl = NULL;
	LPTSTR temp = NULL;

	temp = (LPTSTR) (lpszPrefixedUrl + cbHistoryPrefix) ;

	size = lstrlen(temp);

	if (lpszFragment)
	{
		size += lstrlen (lpszFragment);
		size += 1;	// for the fragment '#'
	}

	lpszUrl = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!lpszUrl)
		return NULL;

	lstrcpy (lpszUrl, temp);

	if (lpszFragment)
	{
		lstrcat (lpszUrl, szPND);
		lstrcat (lpszUrl, lpszFragment);
	}

	return lpszUrl;
}

BOOL
ConvertToPrefixedUrl (IN LPCTSTR lpszUrlName, 
					  OUT LPTSTR *lplpszPrefixedUrl, 
					  OUT LPTSTR *lplpszFragment)
{
	if (!lpszUrlName || !*lpszUrlName)
	{
		*lplpszPrefixedUrl = (LPTSTR) LocalAlloc (LPTR, cbHistoryPrefix + 1);
		if (!*lplpszPrefixedUrl)
			return FALSE;

		lstrcpy (*lplpszPrefixedUrl, lpszHistoryPrefix);
		return TRUE;
	}

	*lplpszPrefixedUrl = (LPTSTR) LocalAlloc (LPTR, cbHistoryPrefix + strlen (lpszUrlName) + 1);
	if (!*lplpszPrefixedUrl)
		return FALSE;

	lstrcpy (*lplpszPrefixedUrl, lpszHistoryPrefix);
	lstrcat (*lplpszPrefixedUrl, lpszUrlName);

	*lplpszFragment = strchr (*lplpszPrefixedUrl, '#');
	if(*lplpszFragment)
		*((*lplpszFragment)++) = '\0';

	return TRUE;
}

LPCACHE_ENTRY_INFO
RetrievePrefixedUrl (IN LPTSTR lpszUrl)
/*++

  The CEI returned must be freed and the lpszUrl unlocked
  
--*/
{
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
		return NULL;

	cbCEI = DEFAULT_CEI_BUFFER_SIZE;

	while (!RetrieveUrlCacheEntryFile (lpszUrl, 
								lpCEI,
								&cbCEI,
								0))
	{
		if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY)
		{
			LocalFree (lpCEI);

			lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
			if (!lpCEI)
				return NULL;

		}
		else 
			return NULL;
	}

	return lpCEI;
}


LPCACHE_ENTRY_INFO
RetrievePrefixedUrlInfo (IN LPTSTR lpszUrl)
/*++

  The CEI returned must be freed and the lpszUrl unlocked
  
--*/
{
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
		return NULL;

	cbCEI = DEFAULT_CEI_BUFFER_SIZE;

	while (!GetUrlCacheEntryInfo (lpszUrl, 
								lpCEI,
								&cbCEI
								))
	{
		if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY)
		{
			LocalFree (lpCEI);

			lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
			if (!lpCEI)
				return NULL;

		}
		else 
			return NULL;
	}

	return lpCEI;
}

LPTSTR
GetTitleFromCEI (IN LPCACHE_ENTRY_INFO lpCEI, LPCTSTR lpszFragment)
{
	LPTSTR pHeader, pCurr;
	DWORD size = 0;

	pHeader = (LPTSTR) MemFind ((LPVOID) lpCEI->lpHeaderInfo, 
		lpCEI->dwHeaderInfoSize, 
		(LPVOID) lpszTitleHeader, 
		cbTitleHeader);
	if (!pHeader)
	{
		SetLastError (ERROR_FILE_NOT_FOUND);
		return NULL;
	}

	//Header was found

		
	pCurr = (LPTSTR) MemFind ( (LPVOID) pHeader,
		(lpCEI->dwHeaderInfoSize) - ((DWORD) (pHeader - (LPTSTR)lpCEI->lpHeaderInfo)), 
		(LPVOID) szCRLF, 
		cbCRLF);
	if (!pCurr)
	{
		// BUGBUG do what now?? found the header, but the title is not in a recognized
		// format.  lets bail with a internal prob
		ASSERT (FALSE);
		SetLastError (ERROR_FILE_NOT_FOUND);
		return NULL;
	}

	*pCurr = '\0';

	pCurr = pHeader + cbTitleHeader;
	while (*pCurr == ' ')
		pCurr++;

	size = lstrlen (pCurr) ;

	if (lpszFragment)	//must also include the fragment in Title
		size += lstrlen (lpszFragment) + 4;

	pHeader = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!pHeader)
		return NULL;
	
	lstrcpy (pHeader, pCurr);

	if (lpszFragment)
	{
		lstrcat (pHeader, szFRAGB);
		lstrcat (pHeader, lpszFragment);
		lstrcat (pHeader, szFRAGE);
	}

	return pHeader;
		
}


DWORD
GetFragmentsFromCEI(IN LPCACHE_ENTRY_INFO lpCEI, 
						  OUT LPTSTR **paFrags, 
						  OUT DWORD *pcFrags)
{
	LPTSTR pHeader, pCurr;

	//need to get the string from the CEI, then parse into args
	pHeader = (LPTSTR) MemFind (lpCEI->lpHeaderInfo, 
		lpCEI->dwHeaderInfoSize, 
		(LPVOID) lpszFragmentHeader, 
		cbFragmentHeader);
	if (!pHeader)
		return ERROR_FILE_NOT_FOUND;

	//Header was found

		
	pCurr = (LPTSTR) MemFind ( (LPVOID) pHeader,
		lpCEI->dwHeaderInfoSize - (pHeader - lpCEI->lpHeaderInfo), 
		(LPVOID) szCRLF, 
		cbCRLF);
	if (!pCurr)
	{
		//this is a corrupted Entry
		ASSERT (FALSE);
		return ERROR_FILE_NOT_FOUND;
	}

	*pCurr = '\0';

	//
	//	pHeader is now  zero terminated string
	//	we want to parse the args of that string
	//
	if (!ParseArgsDyn(pHeader + cbFragmentHeader, paFrags, pcFrags))
		return ERROR_NOT_ENOUGH_MEMORY;

	return ERROR_SUCCESS;

}

LPBYTE
GenerateHeaderInfo(LPCTSTR lpszTitle, LPCTSTR *aFrags, DWORD cFrags)
{
	DWORD size = 0;
	LPBYTE hi = NULL;
	LPTSTR curr;
	DWORD i;

	//first need to find the size required of HeaderInfo
	if (lpszTitle)
	{
		size += lstrlen (lpszTitle);
		size += cbTitleHeader;
		size += cbCRLF;
	}

	if (cFrags)
	{
		size += cbFragmentHeader;
		size += cFrags;

		for (i = 0; i < cFrags; i++)
			size += lstrlen(aFrags[i]);

		size += cbCRLF;
	}
	
	hi = (LPBYTE) LocalAlloc (LPTR, ++size);
	if (!hi)
		return NULL;

	curr = (LPTSTR) hi;
	*curr = '\0';


	if (lpszTitle)
	{
		lstrcat (curr, lpszTitleHeader);
		lstrcat (curr, lpszTitle);
		lstrcat (curr, szCRLF);
	}

	if (cFrags)
	{
		lstrcat (curr, lpszFragmentHeader);

		for(i = 0; i < cFrags; i++)
		{
			if (!*(aFrags[i]))
				continue;

			lstrcat(curr, szSPC);
			lstrcat(curr, aFrags[i]);
		}
		lstrcat (curr, szCRLF);
	}

	return hi;
}

DWORD
CopyCEItoHII (
			  LPCTSTR lpszFragment,
			  LPHISTORY_ITEM_INFO lpHII,
			  LPDWORD lpcbHII,
			  LPCACHE_ENTRY_INFO lpCEI
			  )
{
	DWORD Error = ERROR_SUCCESS;
	DWORD cbNeeded = sizeof (HISTORY_ITEM_INFO);
	DWORD cbUsed = cbNeeded;
	LPTSTR lpszUrl = NULL;
	DWORD cbUrl  = 0;
	LPTSTR lpszTitle = NULL;
	DWORD cbTitle = 0;
	LPTSTR lpszDependancies = NULL;
	DWORD cbDependancies = 0;


	ASSERT (lpCEI->lpszSourceUrlName);
//
//	need to determine the necessary size
//

	// need the unprefixed name

	lpszUrl = ConvertToUnprefixedUrl (lpCEI->lpszSourceUrlName, (LPCTSTR) lpszFragment);
	if (!lpszUrl)
	{
		Error = ERROR_INTERNAL_ERROR;
		goto quit;
	}
	cbUrl = lstrlen (lpszUrl);

	cbNeeded += cbUrl + 1;
	
	
	lpszTitle = GetTitleFromCEI (lpCEI, (LPCTSTR) lpszFragment);
	if (lpszTitle)
	{
		cbTitle = lstrlen (lpszTitle);
		cbNeeded += cbTitle + 1;
	}

	lpszDependancies = GetDependanciesFromCEI (lpCEI);
	if (lpszDependancies)
	{
		cbDependancies = lstrlen (lpszDependancies);
		cbNeeded += cbDependancies + 1;
	}

	if (cbNeeded > *lpcbHII)
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		*lpcbHII = cbNeeded;
		goto quit;
	}
	
//
//	Add the other pieces
//

	lpHII->lpszSourceUrlName = (LPTSTR) (lpHII + cbUsed + 1);
	lstrcpy (lpHII->lpszSourceUrlName, lpszUrl);
	cbUsed += cbUrl + 1;

	if (lpszTitle)
	{
		lpHII->lpszTitle = (LPTSTR) (lpHII + cbUsed + 1);
		lstrcpy (lpHII->lpszTitle, lpszTitle);
		cbUsed += cbTitle + 1;
	}
	else 
		lpHII->lpszTitle = NULL;

	if (lpszDependancies)
	{
		lpHII->lpszDependancies = (LPTSTR) (lpHII + cbUsed + 1);
		lstrcpy (lpHII->lpszDependancies, lpszDependancies);
		cbUsed += cbDependancies + 1;
	}
	else 
		lpHII->lpszDependancies = NULL;

	lpHII->dwVersion = lpCEI->dwVersion;
	lpHII->HistoryItemType = lpCEI->CacheEntryType;
	lpHII->LastAccessTime.dwLowDateTime = lpCEI->LastAccessTime.dwLowDateTime;
	lpHII->LastAccessTime.dwHighDateTime = lpCEI->LastAccessTime.dwHighDateTime;
	lpHII->dwReserved = lpCEI->dwReserved;

quit:

	if (lpszUrl)
		LocalFree(lpszUrl);

	if (lpszTitle)
		LocalFree(lpszTitle);

	if (lpszDependancies)
		LocalFree(lpszDependancies);

	if (Error == ERROR_SUCCESS)
		*lpcbHII = cbUsed;
	
	return Error;
}




HISTORYAPI_(BOOL)
AddHistoryItem(
    IN LPCTSTR lpszUrlName,		//direct correspondence in URLCACHE
    IN LPCTSTR lpszHistoryTitle,		// this needs to be added to lpHeaderInfo
	IN LPCTSTR lpszDependancies,
	IN DWORD dwFlags,
    IN DWORD dwReserved
    )		
/*++

Routine Description:
	
	Places the specified URL into the history.
	
	If it does not exist, then it is created.  If it does exist it is overwritten.

Arguments:

    lpszUrlName			- The URL in question.

    lpszHistoryTitle	- pointer to the friendly title that should be associated
						with this URL. If NULL, no title will be added.

    Reserved			- Unused, for future implementations

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Extended error can be retrieved from GetLastError()

--*/


{
	LPBYTE NewHeaderInfo = NULL;
	DWORD cbNHI = 0;
	BOOL New = FALSE;
	
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	FILETIME ftExpires;
	FILETIME ftModified;
	SYSTEMTIME st;
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;
	BOOL found = FALSE;
	LPTSTR lpszDepsPath = NULL;
	DWORD type = NORMAL_CACHE_ENTRY;
	LPTSTR lpszOldTitle = NULL;


	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}

	lpCEI = RetrievePrefixedUrl (lpszPrefixedUrl);
	if (!lpCEI)
		New = TRUE;

	
	//  Buffer filled with data now
	//  BUGBUG must handle fragments

	if (!New)
	{
		type = lpCEI->CacheEntryType;
		GetFragmentsFromCEI (lpCEI, &aFrags, &cFrags);
		lpszOldTitle = GetTitleFromCEI (lpCEI, NULL);
	}

//	if (Error != ERROR_SUCCESS)

	if (lpszFragment)
	{
		for (i = 0; i < cFrags; i++)
		{
			if (lstrcmp (aFrags[i], lpszFragment) == 0)
			{
				found = TRUE;
				break;
			}
		}
		if (!found)
			AddArgvDyn (&aFrags, &cFrags, lpszFragment);
	}

	NewHeaderInfo = GenerateHeaderInfo (lpszHistoryTitle ? lpszHistoryTitle : lpszOldTitle, aFrags, cFrags);	
	cbNHI = lstrlen (NewHeaderInfo);

	lpszDepsPath = MakeDependanciesFile (lpszDependancies);
	if (!lpszDepsPath)
	{
		ASSERT(FALSE);
		Error = ERROR_INTERNAL_ERROR;
		goto quit;
	}

	GetLocalTime (&st);
	SystemTimeToFileTime(&st, &ftModified);

	st.wDay += 7;	//BUGBUG must get this setting from registry
	if(!SystemTimeToFileTime(&st, &ftExpires))
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
		lpCEI = NULL;
	}

	if (!CommitUrlCacheEntry(
		lpszPrefixedUrl,
		lpszDepsPath,	
		ftExpires,	
		ftModified,								//we dont care about last modified time
		type,	//this is set from dwFlags i think
		NewHeaderInfo,
		cbNHI ,
		lpszHistoryFileExtension,
		0))
	{
		Error = GetLastError ();
		goto quit;
	}
	// if we made it to here, we win!

quit:

	if (aFrags)
		LocalFree (aFrags);

	if (lpszDepsPath)
		LocalFree (lpszDepsPath);

	if (lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
	}

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (NewHeaderInfo)
		LocalFree (NewHeaderInfo);

	if (lpszOldTitle)
		LocalFree (lpszOldTitle);

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}

	

HISTORYAPI_(BOOL)
IsHistorical(
    IN LPCTSTR lpszUrlName
    )

/*++

Routine Description:
	
	Checks to see if Url is a valid History item

Arguments:

    lpszUrlName			- The URL in question.

Return Value:

    BOOL
        Success		- TRUE.  Item is in History

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_FILE_NOT_FOUND indicates the URL is not available
					

--*/

{
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrlInfo (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpszFragment)
	{

//
//	Need to check for IntraDocFrags
//

		Error = GetFragmentsFromCEI(lpCEI, & aFrags, & cFrags);
		if (Error != ERROR_SUCCESS)
			goto quit;

		for (i = 0; i < cFrags; i++)
		{
			if (strcmp(aFrags[i], lpszFragment) == 0)
				goto quit;
		}
		
		Error = ERROR_FILE_NOT_FOUND;
	}

quit:
	
	if (aFrags)
		LocalFree (aFrags);

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}



HISTORYAPI_(BOOL)
RemoveHistoryItem (
    IN LPCTSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:
	
	Changes an entry from an History Item to a normal cache entry.  Removing
	the Title at the same time.

Arguments:

    lpszUrlName			- The URL in question.

    dwReserved			- Unused.  for future usage

Return Value:

    BOOL
        Success		- TRUE.  Item found and removed

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_FILE_NOT_FOUND indicates the URL is not available
					

--*/
{
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;
	LPTSTR lpszTitle = NULL;
	LPBYTE NewHeaderInfo = NULL;
	
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrl (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpszFragment)
	{
		BOOL found = FALSE;
//
//	Need to check for IntraDocFrags
//

		Error = GetFragmentsFromCEI(lpCEI, & aFrags, & cFrags);
		if (Error != ERROR_SUCCESS)
			goto quit;

		for (i = 0; i < cFrags; i++)
		{
			if (strcmp(aFrags[i], lpszFragment) == 0)
			{
				//we need to delete this and reinsert

				*(aFrags[i]) = '\0';
				found = TRUE;
				break;
			}
		}	

		if (cFrags - 1 && found)
		{
			lpszTitle = GetTitleFromCEI (lpCEI, NULL);
			
			NewHeaderInfo = GenerateHeaderInfo (lpszTitle, aFrags, cFrags);

			if(!NewHeaderInfo)
			{
				Error = ERROR_NOT_ENOUGH_MEMORY;
				goto quit;
			}

			UnlockUrlCacheEntryFile(lpCEI->lpszSourceUrlName, 0);

			if (!CommitUrlCacheEntry(
				lpszPrefixedUrl,
				lpCEI->lpszLocalFileName,
				lpCEI->ExpireTime,
				lpCEI->LastModifiedTime,
				lpCEI->CacheEntryType ,		// only changes
				NewHeaderInfo,	// 
				lstrlen (NewHeaderInfo),
				lpCEI->lpszFileExtension,
				0))
			{
				Error = GetLastError ();
			}
			goto quit;
		}

		if (!found)
		{
			Error = ERROR_FILE_NOT_FOUND;
			goto quit;
		}
	}
//BUGBUG  looks like this will always delete a history item if there is only fragment
	//problem is we could have a frag and a unfragged Item
	UnlockUrlCacheEntryFile(lpCEI->lpszSourceUrlName, 0);

	if (!DeleteUrlCacheEntry(lpszPrefixedUrl))
	{
		Error = GetLastError ();
		goto quit;
	}



quit:
	if (aFrags)
		LocalFree (aFrags);

	if (lpszTitle)
		LocalFree (lpszTitle);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (NewHeaderInfo)
		LocalFree (NewHeaderInfo);

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(BOOL)
GetHistoryItemInfo (
    IN LPCTSTR lpszUrlName,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    )
/*++

Routine Description:
	
	Fills a buffer with a HISTORY_ITEM_INFO struct.

Arguments:

    lpszUrlName			- The URL in question.

    lpHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    BOOL
        Success		- TRUE.  

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/


{
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrlInfo (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}
	

	Error = CopyCEItoHII (lpszFragment, lpHistoryItemInfo, lpdwHistoryItemInfoBufferSize, lpCEI);

	

quit:

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(HANDLE)
FindFirstHistoryItem(
    IN LPCTSTR  lpszUrlSearchPattern,
    OUT LPHISTORY_ITEM_INFO lpFirstHistoryItemInfo,
    IN OUT LPDWORD lpdwFirstHistoryItemInfoBufferSize
    )

/*++

Routine Description:
	
	Searches through the History looking for URLs that match the search pattern,
	and copies the HISTORY_ITEM_INFO into the buffer.

Arguments:

    lpszUrlSearchPattern	- The URL in question.

    lpFirstHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwFirstHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    HANDLE
        Success		- Valid enumeration handle to pass into subsequent calls to
					FindNextHistoryItem ().

        Failure		- NULL. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/

{
	LPHISTORY_SEARCH_OBJ hso = NULL;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;
	LPTSTR lpszFoundFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	BOOL found = FALSE;

	hso = (LPHISTORY_SEARCH_OBJ) LocalAlloc (LPTR, sizeof (HISTORY_SEARCH_OBJ));
	if (!hso)
	{
		Error = GetLastError ();
		goto quit;
	}

	hso->aFrags = NULL;
	hso->cFrags = 0;
	hso->iFrags = 0;
	hso->lpszPrefixedUrl = NULL;
	hso->lpszFragment = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlSearchPattern, &(hso->lpszPrefixedUrl), &(hso->lpszFragment)))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	while (TRUE)
	{
		hso->hEnum = FindFirstUrlCacheEntry (hso->lpszPrefixedUrl,
			lpCEI,
			&cbCEI);

		if (!hso->hEnum)
		{
			Error = GetLastError ();
			if (Error == ERROR_NOT_ENOUGH_MEMORY)
			{
				LocalFree (lpCEI);

				lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
				if (!lpCEI)
				{
					Error = ERROR_INTERNAL_ERROR;
					goto quit;
				}
			}
			else 
				goto quit;
		}
		else break;
	}
	
	found = TRUE;	

	//BUGBUG have to handle enum of fragments
	Error = GetFragmentsFromCEI (lpCEI, &(hso->aFrags), &(hso->cFrags));
	switch (Error)
	{
	case ERROR_FILE_NOT_FOUND:	//only the default URL is used
		Error = ERROR_SUCCESS;
		break;

	case ERROR_SUCCESS:			//first return the default URL next call will get frags
		hso->lpCEI = lpCEI;
		break;

	default:
		goto quit;
		break;
	}

	if (hso->lpszFragment)
	{
		found = FALSE;

		for (; hso->iFrags < hso->cFrags; hso->iFrags++)
		{
			if (strncmp (hso->aFrags[hso->iFrags], hso->lpszFragment, lstrlen (hso->lpszFragment)) == 0)
			{
				found = TRUE;
				lpszFoundFragment = hso->aFrags[hso->iFrags];
				break;
			}
		}
	}

	if (!found)
	{
		Error = ERROR_FILE_NOT_FOUND;
		goto quit;
	}

	Error = CopyCEItoHII (
		lpszFoundFragment,
		lpFirstHistoryItemInfo,
		lpdwFirstHistoryItemInfoBufferSize,
		lpCEI);

quit:

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		
		if (hso->lpszPrefixedUrl)
			LocalFree (hso->lpszPrefixedUrl);

		if (hso->aFrags)
			LocalFree (hso->aFrags);

		if (hso->lpCEI)
		{
			UnlockUrlCacheEntryFile (hso->lpCEI->lpszSourceUrlName, 0);
			LocalFree(hso->lpCEI);
		}

		if (hso)
			LocalFree (hso);

		return NULL;
	}
	
	if (lpCEI && !hso->lpCEI)
		LocalFree (lpCEI);

	return (HANDLE) hso;

}



HISTORYAPI_(BOOL)
FindNextHistoryItem(
    IN HANDLE hEnumHandle,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    )

/*++

Routine Description:
	
	Searches through the History looking for URLs that match the search pattern,
	and copies the HISTORY_ITEM_INFO into the buffer.

Arguments:

    lpszUrlSearchPattern	- The URL in question.

    lpFirstHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwFirstHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    HANDLE
        Success		- Valid enumeration handle to pass into subsequent calls to
					FindNextHistoryItem ().

        Failure		- NULL. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/

{
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;
	LPHISTORY_SEARCH_OBJ hso = NULL;
	BOOL found = FALSE;
	LPTSTR lpszFoundFragment;

	if (!hEnumHandle)
	{
		SetLastError (ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	hso = (LPHISTORY_SEARCH_OBJ) hEnumHandle;
	
	while (!found)
	{
		if (hso->aFrags)
		{
			//this means that there are only fragments to find
			for (lpszFoundFragment = NULL; hso->iFrags < hso->cFrags; hso->iFrags++)
			{
				if (hso->lpszFragment)
				{
					if (strncmp (hso->aFrags[hso->iFrags], hso->lpszFragment, lstrlen (hso->lpszFragment)) == 0)
					{
						found = TRUE;
						lpCEI = hso->lpCEI;
						break;
					}
				}
				else
				{
					found = TRUE;
					break;
				}
			}
			if (!found)
			{
				if (hso->lpszFragment)
				{
					Error = ERROR_FILE_NOT_FOUND;
					goto quit;
				}
				else 
				{
					//this means that we went through all the frags
					//we need to drop through and find the Cache Entry that matches
					Error = ERROR_SUCCESS;
					
					ASSERT (hso->lpCEI);
					ASSERT (hso->aFrags);
					
					lpCEI = hso->lpCEI;		//reuse the buffer if possible
					LocalFree (hso->aFrags);

					hso->lpCEI = NULL;
					hso->aFrags = NULL;
				}
			}
			else
			{
				lpszFoundFragment = hso->aFrags[hso->iFrags];
				lpCEI = hso->lpCEI;
			}
		}
		
		else
		{
			if (!lpCEI)
				lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);

			if (!lpCEI)
			{
				Error = ERROR_INTERNAL_ERROR;
				goto quit;
			}

			while (TRUE)
			{
				if (!FindNextUrlCacheEntry (hso->hEnum,
					lpCEI,
					&cbCEI))
				{
					Error = GetLastError ();
					if (Error == ERROR_NOT_ENOUGH_MEMORY)
					{
						LocalFree (lpCEI);

						lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
						if (!lpCEI)
						{
							Error = ERROR_INTERNAL_ERROR;
							goto quit;
						}
					}
					else 
						goto quit;
				}
				else 
					break;
			}

			Error = GetFragmentsFromCEI (lpCEI, &(hso->aFrags), &(hso->cFrags));
			switch (Error)
			{
			case ERROR_FILE_NOT_FOUND:	//only the default URL is used
				found = TRUE;
				Error = ERROR_SUCCESS;
				break;

			case ERROR_SUCCESS:			//first return the default URL next call will get frags
				hso->lpCEI = lpCEI;
				found = TRUE;
				break;

			default:
				goto quit;
				break;
			}
		}
	}

	Error = CopyCEItoHII(
		lpszFoundFragment,
		lpHistoryItemInfo,
		lpdwHistoryItemInfoBufferSize,
		lpCEI);

quit:


	if (lpCEI && !hso->lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
	}


	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(BOOL)
FindCloseHistory (
    IN HANDLE hEnumHandle
    )

{
	LPHISTORY_SEARCH_OBJ hso;
	HANDLE hEnum;

	//possibly we should be keeping track of valid hso's i dunno
	if (!hEnumHandle)
	{
		SetLastError (ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	hso = (LPHISTORY_SEARCH_OBJ) hEnumHandle;

	hEnum = hso->hEnum;

	if (hso->aFrags)
		LocalFree (hso->aFrags);

	if (hso->lpszPrefixedUrl)
		LocalFree(hso->lpszPrefixedUrl);

	if (hso->lpCEI)
	{
		LocalFree (hso->lpCEI);
	}


	LocalFree (hso);

	return FindCloseUrlCache (hEnum);
}

BOOL
DLLHistoryEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    BOOL ok;
    DWORD error;

//    UNREFERENCED_PARAMETER(DllHandle);

    //
    // perform global dll initialization, if any.
    //

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

//        error = DllProcessAttachDiskCache();


        //
        // we switch off thread library calls to avoid taking a hit for every
        // thread creation/termination that happens in this process, regardless
        // of whether Internet APIs are called in the thread.
        //
        // If a new thread does make Internet API calls that require a per-thread
        // structure then the individual API will create one
        //

//        DisableThreadLibraryCalls(DllHandle);
        break;

    case DLL_PROCESS_DETACH:

        if (Reserved != NULL) {
                //
                //  Only Cleanup if there is a FreeLibrary() call.
                //
            break;
        }

//        DllProcessDetachDiskCache();

        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hist\generic.c ===
#include <windows.h>

#define ASSERT(x) if (!(x)) DebugBreak();


LPBYTE
MemFind (LPBYTE lpB, DWORD cbB, LPBYTE lpP, DWORD cbP)

{
	DWORD i, j;
	LPBYTE lpF = NULL;
//	LPBYTE lpB = (LPBYTE) lp1, lpP = (LPBYTE) lp2;
	
	if ( (!lpB) || (!cbB) || (!lpP) || (!cbP) )
		return NULL;
	
	for (i = 0; i < cbB ; i++)
	{
		for (j = 0; i < cbB, j < cbP ; i++, j++)
		{
			if (lpB[i] != lpP[j])
			{	
				lpF = NULL;
				break;
			}
			if (!j)  //the first letter
				lpF = &(lpB[i]);
		}
		if (lpF)
			return lpF;
	}
	return NULL;
}


BOOL
ParseArgsDyn(
    LPTSTR InBuffer,
    LPTSTR **pArgv,
    LPDWORD pArgc
    )

#define DEFAULT_ARGV_SIZE 16

{
    LPTSTR CurrentPtr = InBuffer;
    DWORD cArgv = DEFAULT_ARGV_SIZE;
	LPTSTR *temp = NULL;

	*pArgv = (LPTSTR *) LocalAlloc (LPTR, cArgv * sizeof(LPTSTR));
	if (!*pArgv)
		return FALSE;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        (*pArgv)[*pArgc] = CurrentPtr;
		(*pArgc)++;

        //
        // go to next space.
        //

        while( (*CurrentPtr != ' ') &&
                (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
		
		ASSERT(*pArgc <= cArgv);

		if (*pArgc == cArgv)  //grow the array
		{
			temp = *pArgv;

			*pArgv = (LPTSTR *) LocalAlloc (LPTR, (cArgv + DEFAULT_ARGV_SIZE) * sizeof (LPTSTR));
			if (!*pArgv)
			{
				LocalFree (temp);
				return FALSE;
			}

			memcpy (*pArgv, temp, cArgv * sizeof(LPTSTR));

			LocalFree (temp);
			
			cArgv += DEFAULT_ARGV_SIZE;
		}
    }
    return TRUE;
}


DWORD 
AddArgvDyn (LPTSTR **pArgv, DWORD *pArgc, LPTSTR szNew)
{
	DWORD cArgv = (*pArgc / DEFAULT_ARGV_SIZE + ( *pArgc % DEFAULT_ARGV_SIZE ? 1 : 0 )) * DEFAULT_ARGV_SIZE;
	LPTSTR *temp = NULL;

	if (cArgv <= *pArgc)
	{
		temp = *pArgv;
		*pArgv = (LPTSTR *) LocalAlloc (LPTR, (cArgv + DEFAULT_ARGV_SIZE) * sizeof (LPTSTR));
		if (!*pArgv)
		{
			*pArgv = temp;
			return ERROR_NOT_ENOUGH_MEMORY;
		}
		

		memcpy (*pArgv, temp, cArgv * sizeof(LPTSTR));
		if (temp)
			LocalFree (temp);

		cArgv += DEFAULT_ARGV_SIZE;

		ASSERT (*pArgc < cArgv);
	}


	//this means there is room for another LPTSTR
	(*pArgv)[*pArgc] = szNew;	//NOTE this is volatile memory not alloc by us
	(*pArgc)++;
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\hist\history.h ===
// history.

typedef struct _zHISTORY_ITEM_INFO {
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\test\creatcon\creatcon.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <winineti.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR name = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!name) {
            name = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!name) {
        usage();
    }

    char buffer[1024];
    DWORD buflen = sizeof(buffer);
    BOOL ok = CreateUrlCacheContainer(name,
                                      "CreatConTest",
                                      "",
                                      10,
                                      INTERNET_CACHE_CONTAINER_AUTODELETE,
                                      0,
                                      (LPVOID)buffer,
                                      &buflen
                                      );

    if (!ok) {
        printf("CreateUrlCacheContainer() returns %d\n", GetLastError());
    }
    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: creatcon <cache container name>\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\utils\cdcache\cdcache.h ===
#define IDM_NEW            100
#define IDM_OPEN           101
#define IDM_SAVE           102
#define IDM_SAVEAS         103
#define IDM_PRINT          104
#define IDM_PRINTSETUP     105
#define IDM_EXIT           106
#define IDM_UNDO           200
#define IDM_CUT            201
#define IDM_COPY           202
#define IDM_PASTE          203
#define IDM_LINK           204
#define IDM_LINKS          205
#define IDM_HELPCONTENTS   300
#define IDM_HELPSEARCH     301
#define IDM_HELPHELP       302
#define IDM_ABOUT          303
#define IDM_HELPTOPICS     304
#define IDM_INSTALL        305
#define IDM_UNINSTALL	   306
#define IDM_SUCCESS		   307
#define IDM_SUCCESS_REMOVE 308
#define IDM_HEADER		   309
#define IDM_FAILED	310
#define IDM_FAILED_REMOVE	311
#define IDM_NEEDIE4WININET 312
#define IDM_ERR_IE4REQFORUNINSTALL	313

#define IDD_MAINAPP			1000
#define IDC_LIST			1001
#define IDC_HEADER			1002
#define IDC_QUESTION		1003

#define IDC_STATIC -1

#define DLG_VERFIRST        400
#define IDC_COMPANY			DLG_VERFIRST
#define IDC_FILEDESC       	DLG_VERFIRST+1
#define IDC_PRODVER         DLG_VERFIRST+2
#define IDC_COPYRIGHT       DLG_VERFIRST+3
#define IDC_OSVERSION       DLG_VERFIRST+4
#define IDC_TRADEMARK       DLG_VERFIRST+5
#define DLG_VERLAST         DLG_VERFIRST+5

#define IDC_LABEL           DLG_VERLAST+1

#define ID_COMPANY			1
#define ID_INFNAME			2
#define ID_APPNAME			3
#define ID_CMDLINE			4

// ============ VALUES ============
#define INI_YES			_T("Yes")
#define INI_NO                 _T("No")
#define INI_TRUE               _T("TRUE")
#define INI_FALSE              _T("FALSE")
#define INI_ON                 _T("ON")
#define INI_OFF                _T("OFF")

typedef struct _INTERNET_CACHE_CONTAINER_INFO_MAX {
    DWORD dwCacheVersion;       // version of software
    LPSTR lpszName;             // embedded pointer to the container name string.
    LPSTR lpszCachePrefix;      // embedded pointer to the container URL prefix
	LPSTR lpszPrefixMap;		// embedded pointer to the container data location
	DWORD dwKBCacheLimit;
	DWORD dwContainerType;
	DWORD dwOptions;
} INTERNET_CACHE_CONTAINER_INFO_MAX, * LPINTERNET_CACHE_CONTAINER_INFO_MAX;


/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor()
	{
		m_hWait = LoadCursor(NULL, IDC_WAIT);
		m_hSave = SetCursor(m_hWait);
	};

	~CWaitCursor()
	{
		SetCursor(m_hSave);	
	};

	HCURSOR	m_hSave;
	HCURSOR m_hWait;

// Operations
public:
	void Restore()
	{
		SetCursor(m_hSave);
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\utils\cdcache\stdhdr.h ===
// stdhdr.h
//

// Only include this stuff once
#ifndef __STDHDR_H
#define __STDHDR_H

// Windows Header Files:
#include <windows.h>
#include <tchar.h>
#include <wininet.h>
#include <winineti.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>

// Local Header Files
#include "cdcache.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\test\cachetst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachetst.c

Abstract:

    Test program to test cache apis.

Author:

    Madan Appiah (madana)  26-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#define IE5

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <wininet.h>
#include <winineti.h>
#include <intlgent.hxx>


#define MAX_STRING_LENGTH   128

HMODULE hModule;

//---------------------------------------------------------------------------
// Call this exported function to enable/disable logging to "intlstr.log"
//	-disabled by default
//---------------------------------------------------------------------------
FNStringLogging fnStringLogging;

//typedef void FAR PASCAL (*FNStringLogging)(BOOL bActiveState);

FNGetRandIntlString fnGetRandIntlString;

FNGetIntlString fnGetIntlString;

FNGetProbCharString fnGetProbCharString;
                    
FNGetTop20String fnGetTop20String;

FNGetProbURTCString fnGetProbURTCString;

FNGetUniStrRandAnsi fnGetUniStrRandAnsi;

FNGetUniStrInvalidAnsi fnGetUniStrInvalidAnsi;

FNGetUniStrMappedAnsi fnGetUniStrMappedAnsi;

#pragma optimize("y",off)

#define PRINTF(s) printf s;

HMODULE hModule;

#define GET_PROC_ADDRESS(x) (FN ## x) GetProcAddress(hModule, #x );
/*
int 
_CRTAPI1 
_tmain( int, TCHAR ** );
*/

//#ifdef UNICODE
#define LSTRCMPI _tcsicmp
#define LSTRLEN _tcslen
//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
#define URL_NAME_SIZE   (16 + 1)
#define URL_NAME_LENGTH     2*URL_NAME_SIZE

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define CACHE_DATA_BUFFER_SIZE 1024

#define CACHE_HEADER_INFO_SIZE  2048
#define CACHE_HEADER_INFO_SIZE_NORMAL_MAX   256
#define CACHE_HEADER_INFO_SIZE_BIG_MAX      512

#define RESET_TIMER TRUE
#define ACCUM_TIMER FALSE

#define GENERIC_0 0
#define FILE_SHARE_NONE 0
//=================================================================================
typedef struct _PERF_INFO {
    DWORD ElapsedTime;
    DWORD TotalElapsedTime;
    DWORD TickCount;
    BOOL PrintResults;
} PERF_INFO, *LPPERF_INFO;

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdCreateUrlCacheEntry,
    CmdCommitUrlCacheEntry,
    CmdUpdateUrlCacheEntry,
    CmdRetrieveUrlCacheEntryFile,
    CmdRetrieveUrlCacheEntryStream,
#ifdef IE5
    CmdUnlockUrlCacheEntryFile,
#endif
    CmdGetUrlCacheEntryInfo,
    CmdSetUrlCacheEntryInfo,
#ifdef IE5
    CmdSetUrlCacheEntryGroup,
#endif
    CmdSetExempt,
#ifdef IE5
    CmdDeleteUrlCacheEntry,
#endif
    CmdEnumUrlCacheEntries,
    CmdEnumGroup,
    CmdSimulateCache,
    CmdCreateFile,
    CmdFreeCacheSpace,
    CmdUseFile,
    CmdShowTime,
    CmdLoopCnt,
    CmdCmdLoopCnt,
    CmdSetFileSize,
    CmdSetDiskCache1,
    CmdSetDiskCache2,
    CmdSetQuietMode,
    CmdSetPerfMode,
    CmdWriteFile,
    CmdCreateGroup,
    CmdDeleteGroup,
    CmdGetExQ,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPTSTR CommandName;
    LPTSTR AltCommandName;
    LPTSTR CommandParams;
    COMMAND_CODE CommandCode;
    PERF_INFO PerfInfo;
} COMMAND_INFO, *LPCOMMAND_INFO;

typedef struct _CREATE_FILE_INFO
{
    LPTSTR lpszVal;
    DWORD dwVal;
    DWORD *pdwArg;
    BOOL bExclusive;    // TRUE = Only one value can be used, FALSE - Any combination of values for given argument
} CREATE_FILE_INFO, *LPCREATE_FILE_INFO;

DWORD
CreateRandomString(
                    DWORD Size,
                    LPTSTR  szString);

VOID
MakeRandomUrlName(
    LPTSTR UrlName
    );
//=================================================================================
DWORD g_dwCreate_File_Access_Mode = GENERIC_0;
DWORD g_dwCreate_File_Share_Mode = FILE_SHARE_NONE;
DWORD g_dwCreate_File_Creation = OPEN_EXISTING;
DWORD g_dwCreate_File_Flags = FILE_ATTRIBUTE_NORMAL;
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];
BYTE GlobalCacheDataBuffer[CACHE_DATA_BUFFER_SIZE];
BYTE GlobalCacheHeaderInfo[CACHE_HEADER_INFO_SIZE];
FILE *UrlList = NULL;
TCHAR UrlBuffer[DEFAULT_BUFFER_SIZE];
LPTSTR UrlListKey = _T( "url:" );
LPTSTR g_lpWriteFileBuf = NULL;
FILE *DumpUrlList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;
PERF_INFO AppTimer;

COMMAND_INFO GlobalCommandInfo[] = {
    {_T( "Create" ),          _T( "cr" ), _T( "( UrlName | \"<rand>\" ) <ExpectedSize>\n " ), CmdCreateUrlCacheEntry, {0, 0, 0} },
    {_T( "Commit" ),          _T( "co" ), _T( "( UrlName | \"<rand>\" ) ( LocalFileName | \"<rand>\" ) <ExpireTime (in hours from now)>" ), CmdCommitUrlCacheEntry, {0, 0, 0} },
    {_T( "Update" ),          _T( "co" ), _T( "( UrlName | \"<rand>\" )" ), CmdUpdateUrlCacheEntry, {0, 0, 0} },
    {_T( "GetFile" ),         _T( "gf" ), _T( "( UrlName | \"<rand>\" )" ), CmdRetrieveUrlCacheEntryFile, {0, 0, 0} },
    {_T( "GetStream" ),       _T( "gs" ), _T( "( UrlName | \"<rand>\" ) [NoRead]"), CmdRetrieveUrlCacheEntryStream, {0, 0, 0} },
#ifdef IE5
    {_T( "UnlockFile" ),      _T( "uf" ), _T( "( UrlName | \"<rand>\" )" ), CmdUnlockUrlCacheEntryFile, {0, 0, 0} },
#endif
    {_T( "GetInfo" ),         _T( "gi" ), _T( "( UrlName | \"<rand>\" )" ), CmdGetUrlCacheEntryInfo, {0, 0, 0} },
    {_T( "SetInfo" ),         _T( "si" ), _T( "( UrlName | \"<rand>\" ) <ExpireTime (in hours from now)>" ), CmdSetUrlCacheEntryInfo, {0, 0, 0} },
#ifdef IE5
    {_T( "SetGroup" ),        _T( "sg" ), _T( "( UrlName | \"<rand>\" ) Flags GroupId" ), CmdSetUrlCacheEntryGroup, {0, 0, 0} },
#endif
    {_T( "SetExempt" ),       _T( "se" ), _T( "( UrlName | \"<rand>\" ) Exempt-Seconds"), CmdSetExempt, {0, 0, 0}},
#ifdef IE5
    {_T( "Delete" ),          _T( "d" ),  _T( "( UrlName | \"<rand>\" )" ), CmdDeleteUrlCacheEntry, {0, 0, 0} },
#endif
    {_T( "Enum" ),            _T( "e" ),  _T( "<q (quiet mode)>" ), CmdEnumUrlCacheEntries, {0, 0, 0} },
    {_T( "EnumGroup" ),       _T( "eg" ), _T( "GroupId" ), CmdEnumGroup, {0, 0, 0} },
    {_T( "SimCache" ),        _T( "sc" ), _T( "NumUrls <q (quiet mode)>" ), CmdSimulateCache, {0, 0, 0} },
    {_T( "CreateFile" ),      _T( "cf" ), _T( "FileName AccessMode ShareMode Creation FlagsAttrs" ), CmdCreateFile, {0, 0, 0} },
    {_T( "Free" ),            _T( "f" ),  _T( "CachePercent (0 to 100, history, cookies)"), CmdFreeCacheSpace, {0, 0, 0} },
    {_T( "UseFile" ),         _T( "use" ),_T( "FilePath (text file with one command per line)" ), CmdUseFile, {0, 0, 0} },
    {_T( "ShowTime" ),        _T( "st" ), _T( "HHHHHHHH LLLLLLLL (Hex HighDateTime and LowDateTime)" ), CmdShowTime, {0, 0, 0} },
    {_T( "SetLoopCnt" ),      _T( "slc" ),_T( "NumInterations" ), CmdLoopCnt, {0, 0, 0} },
    {_T( "SetCmdLoopCnt" ),   _T( "scc" ),_T( "NumInterations" ), CmdCmdLoopCnt, {0, 0, 0} },
    {_T( "SetFileSize" ),     _T( "sfs" ),_T( "NumBytes (0 = random size)" ), CmdSetFileSize, {0, 0, 0} },
    {_T( "SetNoBuffering" ),  _T( "snb" ),_T( "On|Off"), CmdSetDiskCache1, {0, 0, 0} },
    {_T( "SetWriteThrough" ), _T( "swt" ),_T( "On|Off"), CmdSetDiskCache2, {0, 0, 0} },
    {_T( "SetQuietMode" ),    _T( "sqm" ),_T( "On|Off"), CmdSetQuietMode, {0, 0, 0} },
    {_T( "SetPerfMode" ),     _T( "spm" ),_T( "On|Off"), CmdSetPerfMode, {0, 0, 0} },
    {_T( "SetWriteFile" ),    _T( "swf" ),_T( "On|Off (On=write a FileSize data blk, Off=garbage data)"), CmdWriteFile, {0, 0, 0} },

    {_T( "CreateGroup" ),    _T( "cg" ),_T( "Flags" ), CmdCreateGroup, {0, 0, 0} },
    {_T( "DeleteGroup" ),    _T( "dg" ),_T("GroupID, Flags"), CmdDeleteGroup, {0, 0, 0} },
    {_T( "GetExemptQuota" ), _T( "eq" ),  _T(""), CmdGetExQ, {0, 0, 0} },
    {_T( "Help" ),            _T("?"),  _T(""), CmdHelp, {0, 0, 0} },
    {_T( "Quit" ),            _T( "q" ),  _T(""), CmdQuit, {0, 0, 0} }
};

CREATE_FILE_INFO Create_File_Table[] =
{
    {_T( "FILE_FLAG_WRITE_THROUGH" ), FILE_FLAG_WRITE_THROUGH, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_OVERLAPPED" ), FILE_FLAG_OVERLAPPED, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_NO_BUFFERING" ), FILE_FLAG_NO_BUFFERING, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_RANDOM_ACCESS" ), FILE_FLAG_RANDOM_ACCESS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_SEQUENTIAL_SCAN" ), FILE_FLAG_SEQUENTIAL_SCAN, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_DELETE_ON_CLOSE" ), FILE_FLAG_DELETE_ON_CLOSE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_BACKUP_SEMANTICS" ), FILE_FLAG_BACKUP_SEMANTICS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_POSIX_SEMANTICS" ), FILE_FLAG_POSIX_SEMANTICS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_ARCHIVE" ), FILE_ATTRIBUTE_ARCHIVE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_COMPRESSED" ), FILE_ATTRIBUTE_COMPRESSED, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_HIDDEN" ), FILE_ATTRIBUTE_HIDDEN, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_NORMAL" ), FILE_ATTRIBUTE_NORMAL, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_OFFLINE" ), FILE_ATTRIBUTE_OFFLINE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_READONLY" ), FILE_ATTRIBUTE_READONLY, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_SYSTEM" ), FILE_ATTRIBUTE_SYSTEM, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_TEMPORARY" ), FILE_ATTRIBUTE_TEMPORARY, &g_dwCreate_File_Flags, FALSE},
    {_T( "CREATE_NEW" ), CREATE_NEW, &g_dwCreate_File_Creation, TRUE},
    {_T( "CREATE_ALWAYS" ), CREATE_ALWAYS, &g_dwCreate_File_Creation, TRUE},
    {_T( "OPEN_EXISTING" ), OPEN_EXISTING, &g_dwCreate_File_Creation, TRUE},
    {_T( "OPEN_ALWAYS" ), OPEN_ALWAYS, &g_dwCreate_File_Creation, TRUE},
    {_T( "TRUNCATE_EXISTING" ), TRUNCATE_EXISTING, &g_dwCreate_File_Creation, TRUE},
    {_T( "FILE_SHARE_DELETE" ), FILE_SHARE_DELETE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_READ" ), FILE_SHARE_READ, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_WRITE" ), FILE_SHARE_WRITE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_NONE" ), FILE_SHARE_NONE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "GENERIC_READ" ), GENERIC_READ, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "GENERIC_WRITE" ), GENERIC_WRITE, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "GENERIC_0" ), GENERIC_0, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "" ), 0, NULL, FALSE}
};

DWORD WINAPIV Format_String(LPTSTR *plpsz, LPTSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPTSTR *plpsz);
DWORD WINAPI Format_StringV(LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);

#define RAND_INTL_STRING    _T("<rand>")

DWORD
CreateRandomString(
                    DWORD Size,
                    LPTSTR  szString)
{
    DWORD cbRet = 0;

#ifdef INTERNATIONAL
    cbRet = fnGetRandIntlString(
                            Size, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 

                            szString); // string to be returned

    _tprintf(_T("\n\nGetRandIntlString returns %s\n\n"), szString );
#else
    //
    // IF this is not an international supported version,
    // we go back to MakeRandomUrlName()
    //
    MakeRandomUrlName( szString );
#endif

	return cbRet;
}

//===========================================================================================
// borrowed from MSDN
//===========================================================================================
DWORD WINAPI GetPerfTime(VOID)
{
    static DWORD freq;            // timer frequency
    LARGE_INTEGER curtime;

    if (!freq)
    {                          // determine timer frequency
        QueryPerformanceFrequency(&curtime);
#if STOPWATCH_DEBUG
        if (curtime.HighPart)
        {                       // timer is too fast
            if(g_dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(TEXT("High resolution timer counts too quickly for single-width arithmetic.\r\n"));
            freq = 1;
        }                       // timer is too fast
        else
#endif
            freq = curtime.LowPart / 1000; // i.e., ticks per millisecond
    }                          // determine timer frequency
    QueryPerformanceCounter(&curtime);
    return (DWORD)(curtime.QuadPart / (LONGLONG)freq);
}

//=================================================================================
void StartPerfTimer(LPPERF_INFO pInfo, BOOL ResetFlag)
{
    pInfo->TickCount = GetPerfTime();
    if(ResetFlag)
    {
        pInfo->ElapsedTime = 0;
        pInfo->TotalElapsedTime = 0;
    }
}

//=================================================================================
void StopPerfTimer(LPPERF_INFO pInfo)
{   
    DWORD BegCount = pInfo->TickCount;

    pInfo->TickCount = GetPerfTime();
    
    pInfo->ElapsedTime += pInfo->TickCount - BegCount;
    pInfo->TotalElapsedTime += pInfo->ElapsedTime;
}

//=================================================================================
void DisplayGlobalSettings(void)
{
    _tprintf("Interations = %ld, CmdIterations = %ld, FileSize = %ld, CreateFlags = %x (%s%s%s), WriteFile = %s, QuietMode = %s, PerfMode = %s\n",
        g_dwNumIterations, g_dwNumCmdIterations,
        g_dwFileSize,
        g_dwDiskCache,
        g_dwDiskCache & (FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH) ?_T( "" ) :_T( "None" ),
        g_dwDiskCache & FILE_FLAG_NO_BUFFERING ?_T( "NoBuf " ) :_T( "" ),
        g_dwDiskCache & FILE_FLAG_WRITE_THROUGH ?_T( "WriteThru" ) :_T( "" ),
        g_bWriteFile ?_T( "On" ): _T( "Off" ),
        g_bQuietMode ?_T(  "On"  ): _T( "Off" ),
        g_bPerfMode ?_T(  "On"  ): _T( "Off" ));
}

//=================================================================================
DWORD WINAPIV DisplayPerfResults(LPPERF_INFO pInfo, LPTSTR lpszFmt, ...)
{
    LPTSTR lpsz = NULL;
    DWORD dwRet;
    DWORD dwCnt = (g_dwIteration <= g_dwNumIterations) ?(g_dwIteration ?g_dwIteration :1) :g_dwNumIterations;
    DWORD dwCmdCnt = (g_dwCmdIteration <= g_dwNumCmdIterations) ?(g_dwCmdIteration ?g_dwCmdIteration :1) :g_dwNumCmdIterations;
    va_list vArgs;

    if(lpszFmt != NULL)
    {
        va_start (vArgs, lpszFmt);
        dwRet = Format_StringV(&lpsz, lpszFmt, &vArgs);
        va_end (vArgs);
    }

    _tprintf(_T( "%s, " ), lpsz ?lpsz :_T( "" ));
    _tprintf(_T( "Time(ms) = %ld, MS/Iter = %ld, Iteration = %ld, CmdIteration = %ld, " ),
        pInfo->ElapsedTime,
        pInfo->ElapsedTime/dwCmdCnt,
        dwCnt,
        dwCmdCnt);
    DisplayGlobalSettings();

    if(lpsz)
        LocalFree(lpsz);
    return(dwRet);
}

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPTSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPTSTR   lpszPath
    );


//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPTSTR FailedAssertion,
    LPTSTR FileName,
    DWORD LineNumber,
    LPTSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    _tprintf(_T( "Assert @ %s \n" ), FailedAssertion );
    _tprintf(_T( "Assert Filename, %s \n" ), FileName );
    _tprintf(_T( "Line Num. = %ld.\n" ), LineNumber );
    _tprintf(_T( "Message is %s\n" ), Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPTSTR InBuffer,
    LPTSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPTSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr ==_T(  ' '  )) {
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != _T( '\0' )) &&
                (*CurrentPtr != _T( '\n' )) ) {
            if( *CurrentPtr ==_T(  '"'  )) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = _T( '\0' );     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == _T( ' ' )) ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == _T( '\0' )) )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        *CurrentPtr++ = _T( '\0' );
    }

    *CArgc = i;
    return;
}

//=================================================================================
LPTSTR
GetUrlFromFile ()
{
    if (!UrlList)
    {
        UrlList = _tfopen (_T( "urllist" ), _T( "r" ));
        if (UrlList == NULL)
            return NULL;
    }
    if (fgets( UrlBuffer, DEFAULT_BUFFER_SIZE, UrlList))
    {
        UrlBuffer[_tcslen(UrlBuffer) -1] = _T( '\0' );  //kill line feed for no param cmds
        return UrlBuffer;
    }
    else
    {
        fclose (UrlList);
        UrlList = NULL;
        return GetUrlFromFile();
    }
}


//=================================================================================
VOID
MakeRandomUrlName(
    LPTSTR UrlName
    )
/*++

Routine Description:

    Creates a random url name. The format of the name will be as
    below:

        url(00000-99999)

    Ex ca00123

Arguments:

    UrlName : pointer to an URL name buffer

Return Value:

    none.

--*/
{
    DWORD RandNum;
    LPTSTR UrlNamePtr = UrlName;
    DWORD i;
    DWORD Size;

    Size = URL_NAME_SIZE;

    *UrlNamePtr++ = _T( 'U' );
    *UrlNamePtr++ = _T( 'R' );
    *UrlNamePtr++ = _T( 'L' );
    Size -=3*sizeof(TCHAR);

    //
    // generate a_T(  "Size"  )digits random string;
    //
#if 0

#define MAX_STRING_LENGTH   URL_NAME_SIZE

    i = fnGetRandIntlString(
                            Size, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 
                            UrlNamePtr); // string to be returned


    _tprintf(_T("\n\n *** GetRandIntlString() returns %s ***\n\n"), UrlNamePtr );
#else
    for ( i = 0; i < Size; i++) {
        RandNum = rand() % 36;
        *UrlNamePtr++  =
            ( RandNum < 10 ) ? (CHAR)(_T( '0' ) + RandNum) : (CHAR)(_T( 'A' ) + (RandNum - 10));
    }

    *UrlNamePtr = _T( '\0' );
#endif

    return;
}

//=================================================================================
VOID
TestMakeRandomUrlName(
    VOID
    )
{
#define MAX_BUFFERS 32
#define MAX_NAMES   (10 * 1024)
#define NAME_BUFFER_SIZE    (10 * 1024)

    CHAR UrlName[URL_NAME_SIZE];
    DWORD i;

    LPBYTE NameBuffers[MAX_BUFFERS];
    DWORD NumNameBuffer;

    LPTSTR *Names;
    DWORD NumNames;

    LPBYTE NextName;
    LPBYTE EndOfBuffer;

    DWORD NumRepeat;

    NumNames = 0;
    NumNameBuffer = 0;
    NumRepeat = 0;

    //
    // allocate names array.
    //

    Names = (LPTSTR *)  LocalAlloc(
                            LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof(LPTSTR) * MAX_NAMES );

    if( Names == NULL ) {
        _tprintf(_T( "local alloc failed.\n" ));
        return;
    }

    //
    // allocate name buffer.
    //

    NextName = (LPBYTE) LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                NAME_BUFFER_SIZE );

    if( NextName == NULL ) {
        _tprintf(_T( "local alloc failed.\n" ));
        return;
    }

    EndOfBuffer = NextName + NAME_BUFFER_SIZE;

    NameBuffers[NumNameBuffer++] = NextName;

    for( i = 0; i < MAX_NAMES; i++ ) {

        DWORD j;

        MakeRandomUrlName( UrlName );

        // _tprintf( "%d : %s\n", i, UrlName );
        // _tprintf(".");


        //
        // look to see this name is already created.
        //

        for( j = 0; j < NumNames; j++ ) {

            if( _tcscmp( Names[j], UrlName ) == 0 ) {

                // _tprintf("%ld :%ld.\n",  ++NumRepeat, NumNames );
                break;
            }
        }

        if( j < NumNames ) {

            //
            // repeated name.
            //

            continue;
        }

        //
        // add this name to the list.
        //

        if( (NextName + _tcslen(UrlName) + 1) > EndOfBuffer ) {

            if( NumNameBuffer >= MAX_BUFFERS ) {
                _tprintf(_T( "too many buffers\n" ));
                return;
            }

            //
            // allocate another name buffer.
            //

            NextName = (LPBYTE) LocalAlloc(
                                        LMEM_FIXED | LMEM_ZEROINIT,
                                        NAME_BUFFER_SIZE );

            if( NextName == NULL ) {
                _tprintf(_T( "local alloc failed.\n" ));
                return;
            }

            EndOfBuffer = NextName + NAME_BUFFER_SIZE;

            NameBuffers[NumNameBuffer++] = NextName;

            _tprintf(_T( "Another buffer alloted.\n" ));

            if( (NextName + _tcslen(UrlName) + 1) > EndOfBuffer ) {
                _tprintf(_T( "Fatal error.\n" ));
                return;
            }
        }

        _tcscpy( NextName, UrlName );
        Names[NumNames++] = NextName;

        NextName += _tcslen(UrlName) + 1;
    }

    //
    // free buffers.
    //

    LocalFree( Names );

    for( i = 0; i < NumNameBuffer; i++ ) {
        LocalFree( NameBuffers[i] );
    }

    _tprintf(_T( "%ld unique names generated successfully.\n" ), NumNames );

    return;
}

//=================================================================================
DWORD
SetFileSizeByName(
    LPCTSTR FileName,
    DWORD FileSize
    )
/*++

Routine Description:

    Set the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : new size of the file.

Return Value:

    Windows Error Code.

--*/
{
    HANDLE FileHandle;
    DWORD FilePointer;
    DWORD Error = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    DWORD dwCreate;
    BOOL BoolError;

    //
    // get the size of the file being cached.
    //
    dwFlags = g_dwDiskCache;

    if(g_bWriteFile)
        dwCreate = CREATE_ALWAYS;
    else
        dwCreate = OPEN_EXISTING;

    FileHandle = CreateFile(
                    FileName,
                    GENERIC_WRITE,
                    0,   //FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreate,
                    FILE_ATTRIBUTE_NORMAL | dwFlags,
                    NULL );

    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( GetLastError() );
    }

    if(g_bWriteFile)
    {
        DWORD dwBytesWritten;
        if(!WriteFile(FileHandle, g_lpWriteFileBuf, FileSize, &dwBytesWritten, NULL))
            Error = GetLastError();

        TestDbgAssert(FileSize == dwBytesWritten);
    }
    else
    {
        FilePointer = SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN );

        if( FilePointer != 0xFFFFFFFF )
        {
            TestDbgAssert( FilePointer == FileSize );

            if(!SetEndOfFile( FileHandle ))
                Error = GetLastError();
        }
        else
        {
            Error = GetLastError();
        }
    }

    CloseHandle( FileHandle );
    return( Error );
}

//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPTSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( _tcsicmp( CommandName, GlobalCommandInfo[i].CommandName ) == 0 ) ||
           ( _tcsicmp( CommandName, GlobalCommandInfo[i].AltCommandName ) == 0 )) {
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        _ftprintf(stderr, _T( "    %s (%s) %s\n" ),
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].AltCommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    _ftprintf(stderr,_T( "Usage: command <command parameters>\n" ));

    _ftprintf(stderr, _T( "Commands : \n" ));
    PrintCommands();
    DisplayGlobalSettings();
    return;
}

//=================================================================================
VOID
DisplayExemptQuota()
{



    _ftprintf(stderr, _T( "Exempt Usage = \n" ));
    return;
}


FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================
LPTSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPTSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};
    
    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        _stprintf (OutputBuffer, _T( "<none>" ));
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        _stprintf( OutputBuffer,
                    _T( "%02u/%02u/%04u %02u:%02u:%02u " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    
    return( OutputBuffer );
}

//=================================================================================
VOID
PrintUrlInfo(
    LPINTERNET_CACHE_ENTRY_INFO CacheEntryInfo,
    DWORD Index
    )
{
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

    if( Index != (DWORD)(-1) ) {
        _tprintf( _T( "Index = %ld\n" ), Index);
        Tab = _T( "\t" );
    }

    _tprintf( _T( "%sUrlName = %s\n" ), Tab, CacheEntryInfo->lpszSourceUrlName );

#if UNICODE
    _tprintf( _T( "%sLocalFileName = %ws\n" ),
        Tab, CacheEntryInfo->lpszLocalFileName );
#else
    _tprintf( _T( "%sLocalFileName = %s\n" ),
        Tab, CacheEntryInfo->lpszLocalFileName );
#endif

    _tprintf( _T( "%sdwStructSize = %lx\n" ),
        Tab, CacheEntryInfo->dwStructSize );

    _tprintf( _T( "%sCacheEntryType = %lx\n" ),
        Tab, CacheEntryInfo->CacheEntryType );

    _tprintf( _T( "%sUseCount = %ld\n" ),
        Tab, CacheEntryInfo->dwUseCount );

    _tprintf( _T( "%sHitRate = %ld\n" ),
        Tab, CacheEntryInfo->dwHitRate );

    _tprintf( _T( "%sSize = %ld:%ld\n" ),
        Tab, CacheEntryInfo->dwSizeLow, CacheEntryInfo->dwSizeHigh );

    _tprintf( _T( "%sLastModifiedTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastModifiedTime, TimeBuffer) );

    _tprintf( _T( "%sExpireTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->ExpireTime, TimeBuffer) );

    _tprintf( _T( "%sLastAccessTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastAccessTime, TimeBuffer) );

    _tprintf( _T( "%sLastSyncTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastSyncTime, TimeBuffer) );

#if 1
    _tprintf( _T( "%sHeaderInfo = %s\n" ),
        Tab, CacheEntryInfo->lpHeaderInfo );
#endif

    _tprintf( _T( "%sHeaderInfoSize = %ld\n" ),
        Tab, CacheEntryInfo->dwHeaderInfoSize );

#if UNICODE
    _tprintf( _T( "%sFileExtension = %ws\n" ),
        Tab, CacheEntryInfo->lpszFileExtension );
#else
    _tprintf( _T( "%sFileExtension = %s\n" ),
        Tab, CacheEntryInfo->lpszFileExtension );
#endif

    _tprintf (_T( "%sExemptDelta = %d\n" ),
        Tab, CacheEntryInfo->dwExemptDelta);
}

#ifdef IE5
VOID
PrintGroupInfo(
    GROUPID gid
    )
{
    LPTSTR Tab = _T( "\t" );
    HANDLE EnumHandle = NULL; 
    DWORD BufferSize;

    INTERNET_CACHE_GROUP_INFOA  pInfo;
    DWORD                       dwInfo = sizeof(INTERNET_CACHE_GROUP_INFOA);
    if(GetUrlCacheGroupAttribute(gid, 0, 0xffffffff, &pInfo, &dwInfo, NULL))
    {
        _tprintf( _T( "%sdwGroupSize = %lx\n" ), Tab, pInfo.dwGroupSize);
        _tprintf( _T( "%sdwGroupFlags = %lx\n" ), Tab, pInfo.dwGroupFlags);
        _tprintf( _T( "%sdwGroupType  = %lx\n" ), Tab, pInfo.dwGroupType);
        _tprintf( _T( "%sdwDiskUsage  = %lx\n" ), Tab, pInfo.dwDiskUsage);
        _tprintf( _T( "%sdwDiskQuota  = %lx\n" ), Tab, pInfo.dwDiskQuota);

        _tprintf( _T( "%s%s======== URLS ========\n" ), Tab, Tab);
        

        // looking for all url associated with this group
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        EnumHandle = FindFirstUrlCacheEntryEx (
            NULL,         // search pattern
            0,            // flags
            0xffffffff,   // filter
            gid,          // groupid
            (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
            &BufferSize,
            NULL,
            NULL,
            NULL
        );

        if (EnumHandle) 
        {
            _tprintf(_T( "\t\t %s\n" ), 
                ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        } 


        // get more entries.
        for ( ;; )
        {
            memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
            BufferSize = CACHE_ENTRY_BUFFER_SIZE;
            if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
            {
                break;
            }

            _tprintf(_T( "\t\t %s\n" ), 
                ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        }


        FindCloseUrlCache(EnumHandle);
    
    }
    else
    {
        _tprintf(_T( "Failed to retrieve attribute for this group\n" ));
    }


}
#endif

//=================================================================================
DWORD
ProcessFreeCacheSpace (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD dwSize = 0;
    TCHAR szCachePath[MAX_PATH+1];
    TCHAR szWinDir[MAX_PATH+1];

    if (argc < 1)
    {
        _ftprintf(stderr, _T( "Usage: %s %s\n" ),
            GlobalCommandInfo[CmdFreeCacheSpace].CommandName,
            GlobalCommandInfo[CmdFreeCacheSpace].CommandParams);
        return ERROR_INVALID_PARAMETER;
    }

    if((LSTRCMPI(argv[0], _T( "history" )) == 0) || (LSTRCMPI(argv[0], _T( "cookies" )) == 0))
    {
        dwSize = 100;
        GetWindowsDirectory(szWinDir, MAX_PATH);
        _stprintf(szCachePath, _T( "%s\\%s" ), szWinDir, argv[0]);
    }
    else
    {
        *szCachePath = _T( '\0' );
        dwSize = _tcstoul(argv[0], NULL, 0);
    }

    StartPerfTimer(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo, RESET_TIMER);

    if (!FreeUrlCacheSpace (szCachePath, dwSize, 0))
        Error = GetLastError();

    StopPerfTimer(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo);
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo, _T( "Free %1 %2!ld!" ), szCachePath, dwSize);

    return Error;
}

//=================================================================================
DWORD
CreateUCEHelper(
    DWORD argc,
    LPTSTR *argv,
    TCHAR* LocalFileName
    )
{
    DWORD Error;
    LPTSTR UrlName;
    DWORD ExpectedSize = 0;
    TCHAR *lpFileExtension = NULL;
    TCHAR   szIntlString1[2 * URL_NAME_LENGTH];
    TCHAR   szIntlString2[2 * URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: CreateUrlCacheEntry UrlName " )
                _T( "<ExpectedSize> <filextension (no dot)>\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szIntlString1 );
        UrlName = szIntlString1;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;
#if 0
    if (_tcsicmp (LocalFileName, RAND_INTL_STRING) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szIntlString2 );
        LocalFileName = szIntlString2;
    }
#endif

    if( argc > 1 ) {
        ExpectedSize = _tcstoul( argv[1], NULL, 0 );
    } else {
        ExpectedSize = 2000;
    }
    
    if (argc > 2) {
        lpFileExtension = argv[2];
    }

    if( !CreateUrlCacheEntry(
                UrlName,
                ExpectedSize,
                lpFileExtension,
                LocalFileName,
                0 )  ) {

        return( GetLastError() );
    }

    //
    // set file size.
    //
    Error = SetFileSizeByName (LocalFileName, ExpectedSize );
    if( Error != ERROR_SUCCESS )
    {
        _tprintf( _T( "SetFileSizeByName call failed, %ld.\n" ), Error );
        return( Error );
    }


#if UNICODE
    _tprintf( _T( "LocalFile Name : %ws \n" ), LocalFileName );
#else
    _tprintf( _T( "LocalFile Name : %s \n" ), LocalFileName );
#endif

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
CommitUCEHelper(
    DWORD argc,
    LPTSTR *argv,
    LPTSTR LocalFileName
    )
{
    DWORD Error;
    BOOL fSetEdited = FALSE;
    LPTSTR UrlName;
    FILETIME ExpireTime = {0, 0};
    FILETIME ZeroFileTime = {0, 0};
    TCHAR   szIntlString[2 * URL_NAME_LENGTH];
    TCHAR   szIntlString2[2 * URL_NAME_LENGTH];

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0) {
        UrlName = GetUrlFromFile ();
    } else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (_tcsicmp (LocalFileName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString2);
        LocalFileName = szIntlString2;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    if( argc > 2 ) {

		unsigned int edt;
        DWORD UrlLife;

        UrlLife = _tcstoul( argv[2], NULL, 0 );

        if( UrlLife != 0 ) {

            LONGLONG NewTime;

            ExpireTime = GetGmtTime();

            NewTime =
                *(LONGLONG *)(&ExpireTime) +
                (LONGLONG)UrlLife * (LONGLONG)36000000000;
                    // in 100 of nano seconds.

            ExpireTime = *((FILETIME *)(&NewTime)) ;
        }

		// See if user wants to set EDITED_CACHE_ENTRY
		for (edt = 2; edt < argc; edt++)
		{
		    if (_tcsicmp (argv[edt], _T( "edited" )) == 0)
		    {
		    	fSetEdited = TRUE;
	    	}
    	}

    }

    if( !CommitUrlCacheEntry(
                UrlName,
                LocalFileName,
                ExpireTime,
                ZeroFileTime,
                fSetEdited ? (NORMAL_CACHE_ENTRY | EDITED_CACHE_ENTRY) : NORMAL_CACHE_ENTRY,
                (LPBYTE)GlobalCacheHeaderInfo,
                (rand() % CACHE_HEADER_INFO_SIZE_NORMAL_MAX),
                TEXT("tst"),
                0
                ) ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}


//=================================================================================
DWORD ProcessCreateUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    TCHAR szPath[MAX_PATH];

    return CreateUCEHelper (argc, argv, szPath);
}

//=================================================================================
DWORD ProcessCommitUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    if( argc < 2 ) {
        _ftprintf(stderr, _T( "Usage: CommitUrlCacheEntry UrlName LocalFileName " )
               _T(  "<ExpireTime (in hours from now)>\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    return CommitUCEHelper (argc, argv, argv[1]);
}

//=================================================================================
DWORD ProcessUpdateUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    TCHAR szPath[MAX_PATH];

    DWORD dwRet = CreateUCEHelper (argc, argv, szPath);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;
    return CommitUCEHelper (argc, argv, szPath);
}
    

//=================================================================================
DWORD
ProcessRetrieveUrlCacheEntryFile(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize;
    DWORD Error = ERROR_SUCCESS;
    TCHAR szIntlString[2 * URL_NAME_LENGTH ];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: RetrieveUrlCacheEntryFile UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
    
    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    StartPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo, RESET_TIMER);

    g_dwCmdIteration = 0;
    while(g_dwCmdIteration++ < g_dwNumCmdIterations)
    {
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !RetrieveUrlCacheEntryFile(
                    UrlName,
                    lpCacheEntryInfo,
                    &CacheEntryInfoBufferSize,
                    0 ) ) {

            if(Error == ERROR_SUCCESS)  // GetLastError on the first error to save a little time since we might be timing non existant files
                Error = GetLastError();
        }
    }

    StopPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo);

    if(!g_bQuietMode)
        PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo, _T( "%1 %2" ),
                GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].CommandName, argv[0]);

    return( Error );
}

//=================================================================================
DWORD
ProcessRetrieveUrlCacheEntryStream(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error = ERROR_SUCCESS;
    LPTSTR UrlName;
    HANDLE StreamHandle;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize;
    DWORD BufferSize;
    DWORD Offset;
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    TCHAR szIntlString[2*URL_NAME_LENGTH];

///    PERF_INFO piRead;
///    PERF_INFO piUnlock;

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: RetrieveUrlCacheEntryStream UrlName [NoRead]\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);


    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return( ERROR_INTERNET_INVALID_URL);

    StartPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo, RESET_TIMER);

    g_dwCmdIteration = 0;
    while(g_dwCmdIteration++ < g_dwNumCmdIterations)
    {
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;

        StreamHandle =
            RetrieveUrlCacheEntryStream(
                UrlName,
                lpCacheEntryInfo,
                &CacheEntryInfoBufferSize,
                FALSE,
                0 );

        if( StreamHandle != NULL )
        {
            if((argc == 1) || ((argc == 2) && (_tcsicmp(argv[1], _T( "noread" )) != 0)))
            {
                //
                // read file data.
                //

                Offset = 0;
                for(;;) {

                    BufferSize = CACHE_DATA_BUFFER_SIZE;
                    memset( GlobalCacheDataBuffer, 0x0, CACHE_DATA_BUFFER_SIZE );

                    if( !ReadUrlCacheEntryStream(
                            StreamHandle,
                            Offset,
                            GlobalCacheDataBuffer,
                            &BufferSize,
                            0
                            ) ) {

                        Error = GetLastError();
                        break;
                    }
                    Offset += BufferSize;

                    if( BufferSize != CACHE_DATA_BUFFER_SIZE ) {

                        TestDbgAssert(  BufferSize < CACHE_DATA_BUFFER_SIZE );
                        Error = ERROR_SUCCESS;
                        break;
                    }
                }
            }
            //
            // unlock the file.
            //

            if( !UnlockUrlCacheEntryStream( StreamHandle, 0 ) ) {
                TestDbgAssert(  FALSE );
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    StopPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo);

    if(!g_bQuietMode)
        PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );

    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo, _T( "%1 %2 %3 = Retrieve" ),
            GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].CommandName,
            argc >= 1 ?argv[0] :_T( "" ),
            argc >= 2 ?argv[1] :_T( "" ));

    return( Error );
}

//=================================================================================
#ifdef IE5
DWORD
ProcessUnlockUrlCacheEntryFile(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: UnlockUrlCacheEntryFile UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    if( !UnlockUrlCacheEntryFile( UrlName, 0 ) ) {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
#endif

//=================================================================================
DWORD
ProcessGetUrlCacheEntryInfo(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;


    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: GetUrlCacheEntryInfo UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);


    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    StartPerfTimer(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo, RESET_TIMER);

    if( !GetUrlCacheEntryInfo(
        UrlName,
        lpCacheEntryInfo,
        &CacheEntryInfoBufferSize ) ) {

        return( GetLastError() );
    }

    StopPerfTimer(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo);

    PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo, NULL);

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
ProcessSetUrlCacheEntryInfo(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    FILETIME ExpireTime = {0, 0};
    INTERNET_CACHE_ENTRY_INFO UrlInfo;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: SetUrlCacheEntryInfo UrlName " )
               _T(  "<ExpireTime (in hours from now)>\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset( &UrlInfo, 0x0, sizeof(INTERNET_CACHE_ENTRY_INFO) );

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    UrlInfo.LastModifiedTime = GetGmtTime();

    if( argc > 1 ) {

        DWORD UrlLife;

        UrlLife = _tcstoul( argv[1], NULL, 0 );

        if( UrlLife != 0 ) {

            LONGLONG NewTime;

            ExpireTime = UrlInfo.LastModifiedTime;

            NewTime =
                *(LONGLONG *)(&ExpireTime) +
                (LONGLONG)UrlLife * (LONGLONG)3600 * (LONGLONG)10000000;
                    // in 100 of nano seconds.

            ExpireTime = *((FILETIME *)(&NewTime)) ;
        }
    }

    UrlInfo.ExpireTime = ExpireTime;

    StartPerfTimer(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo, RESET_TIMER);


    if( !SetUrlCacheEntryInfo(
        UrlName,
        &UrlInfo,
        CACHE_ENTRY_MODTIME_FC  | CACHE_ENTRY_EXPTIME_FC
                ) ) {
        return( GetLastError() );
    }

    StopPerfTimer(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo);

    PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo, NULL);

    return( ERROR_SUCCESS );
}

//=================================================================================
#ifdef IE5
DWORD
ProcessSetUrlCacheEntryGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    DWORD dwFlags;
    GROUPID GroupId;
    LONGLONG ExemptTime;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if (argc < 3)
    {
        _ftprintf(stderr, _T( "Usage: SetUrlCacheEntryGroup UrlName " )
               _T(  "Flags GroupId\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    dwFlags = atoi(argv[1]);
    GroupId = atoi(argv[2]);
    if( !SetUrlCacheEntryGroup
        (UrlName, dwFlags, GroupId, NULL, 0, NULL))
    {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}
#endif

//=================================================================================
DWORD ProcessSetExempt (DWORD argc, LPTSTR *argv)
{
    LPTSTR UrlName;
    INTERNET_CACHE_ENTRY_INFO cei;
    TCHAR szIntlString[2*URL_NAME_LENGTH];
    
    if (argc < 2)
    {
        _ftprintf (stderr, _T( "Usage: SetGroup UrlName ExemptDelta\n" ));
        return ERROR_INVALID_PARAMETER;
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    cei.dwStructSize = sizeof(cei);
    cei.dwExemptDelta = atoi(argv[1]);

    if (!SetUrlCacheEntryInfo (UrlName, &cei, CACHE_ENTRY_EXEMPT_DELTA_FC))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

//=================================================================================
#ifdef IE5

DWORD
ProcessDeleteUrlCacheEntry(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    DWORD BufferSize;
    HANDLE EnumHandle;
    DWORD Index = 0;
    DWORD dwTotal = 0;
    BOOL QuietMode = g_bQuietMode;
    TCHAR szInternationalString[ URL_NAME_LENGTH ];
    TCHAR Str[256];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: DeleteUrlCacheEntry UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    if((argc == 2) && (argv[1][0] == _T( 'q' )))
        QuietMode = TRUE;

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING ) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szInternationalString );
        UrlName = szInternationalString;
    }
        

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;
    if (_tcsicmp (UrlName, _T( "all" )) == 0)
    {
        StartPerfTimer(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo, RESET_TIMER);
        for ( ;; )
        {
            memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
            BufferSize = CACHE_ENTRY_BUFFER_SIZE;
            if( Index++ == 0)
            {
                EnumHandle = FindFirstUrlCacheEntryEx (
                    NULL,         // search pattern
                    0,            // flags
                    0xffffffff,   // filter
                    0,            // groupid
                    (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                    &BufferSize,
                    NULL,
                    NULL,
                    NULL
                );

                if( EnumHandle == NULL ) {
                    return( GetLastError() );
                }
            }
            else
            {
                if( !FindNextUrlCacheEntryEx(
                        EnumHandle,
                        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                        &BufferSize, NULL, NULL, NULL))
                {
                    DWORD Error;

                    Error = GetLastError();
                    if( Error != ERROR_NO_MORE_ITEMS ) {
                        return( Error );
                    }

                    break;
                }
            }
            
            if( !QuietMode )
                _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
                
            if( !DeleteUrlCacheEntry( ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName ) ) {
                DWORD dwGLE = GetLastError();
                _tprintf(_T( "DeleteUrlCacheEntry failed for %s. GLE=%d\r\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName, dwGLE);
                return( dwGLE );
            }
            dwTotal++;
        }
        StopPerfTimer(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo);
        if(g_bPerfMode)
        {
            _stprintf(Str, _T( "Deleted %d" ), dwTotal);
            DisplayPerfResults(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo, Str);
        }
        
        return( ERROR_SUCCESS);
    }   // if UrlName == all

    if( !DeleteUrlCacheEntry( UrlName ) ) {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
#endif

//=================================================================================
DWORD
ProcessEnumUrlCacheEntries(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD BufferSize, dwSmall=0, dwLarge=0, dwTotal = 0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD ActualSize;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    BOOL QuietMode = g_bQuietMode;
    BOOL bRC;
    TCHAR Str[256];
    BOOL EnumUrlOnly = FALSE;

    if (argc)
    {
        if (LSTRCMPI(*argv, _T( "q" )) == 0)
            QuietMode = TRUE;
        else if (LSTRCMPI(*argv, _T( "u" )) == 0)
            EnumUrlOnly = TRUE;
    }

    //
    // start enum.
    //
    StartPerfTimer(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo, RESET_TIMER);

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx (
        NULL,         // search pattern
        0,            // flags
        0xffffffff,   // filter
        0,            // groupid
        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
        &BufferSize,
        NULL,
        NULL,
        NULL
    );

    if( EnumHandle == NULL ) {
        return( GetLastError() );
    }

    ++dwTotal;

///    ActualSize = BufferSize
///                    - LSTRLEN(lpCEI->lpszLocalFileName)
///                    + GetLeafLenFromPath(lpCEI->lpszLocalFileName);
    if(!QuietMode)
        if (EnumUrlOnly) {
            _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        } else {
            PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
        }

    //
    // get more entries.
    //

    for ( ;; )
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;

        if(!QuietMode)
        {
///            ActualSize = BufferSize - GetLeafLenFromPath(lpCEI->lpszLocalFileName);
            if (EnumUrlOnly) {
                _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
            } else {
                PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
            }
        }
    }

    StopPerfTimer(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo);
    if(g_bPerfMode)
    {
        _stprintf(Str, _T( "Enum %d" ), dwTotal);
        DisplayPerfResults(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo, Str);
    }
    else
    {
        _tprintf(_T( "\r\nTotal = %d\n" ), dwTotal);
    }

    FindCloseUrlCache(EnumHandle);

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
ProcessEnumGroup(
    DWORD argc,
    LPTSTR *argv
    )
{

#ifdef IE5
    HANDLE h = NULL;
    GROUPID gid = 0;
    h = FindFirstUrlCacheGroup(0, 0, NULL, 0, &gid, NULL);

    if( h )
    {
        _tprintf(_T( "GID = %x\n" ), gid);
        PrintGroupInfo(gid);
        while( FindNextUrlCacheGroup(h, &gid, NULL) )
        {
            _tprintf(_T( "GID = %x\n" ), gid);
            PrintGroupInfo(gid);
        }
    }
    else
    {
        _tprintf(_T( "no group found\n" ));
    }

    FindCloseUrlCache(h);
    return( ERROR_SUCCESS );

#else
    DWORD BufferSize, dwTotal = 0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD ActualSize;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI =
        (LPINTERNET_CACHE_ENTRY_INFO) GlobalCacheEntryInfoBuffer;
    GROUPID GroupId;
    FILETIME ftExempt;
    TCHAR Str[256];

    //
    // start enum.
    //

    if (argc != 1)
    {
        _ftprintf (stderr, "Usage: EnumGroup GroupId");
        return ERROR_INVALID_PARAMETER;
    }

    GroupId = atoi(argv[0]);

    StartPerfTimer(&GlobalCommandInfo[CmdEnumGroup].PerfInfo, RESET_TIMER);

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx
        (NULL, 0, 0, GroupId, lpCEI, &BufferSize, NULL, 0, NULL);

    if( EnumHandle == NULL ) {
        return( GetLastError() );
    }


    ++dwTotal;

///    ActualSize = BufferSize
///                    - LSTRLEN(lpCEI->lpszLocalFileName)
///                    + GetLeafLenFromPath(lpCEI->lpszLocalFileName);

    if(!g_bQuietMode)
        PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );

    //
    // get more entries.
    //

    for ( ;; ) {

        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx
            (EnumHandle, lpCEI, &BufferSize, NULL, 0, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;

///        ActualSize = BufferSize - GetLeafLenFromPath(lpCEI->lpszLocalFileName);
        if(!g_bQuietMode)
            PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
    }

    FindCloseUrlCache (EnumHandle);

    StopPerfTimer(&GlobalCommandInfo[CmdEnumGroup].PerfInfo);
    if(g_bPerfMode)
    {
        _stprintf(Str, _T( "EnumGrp %d" ), dwTotal);
        DisplayPerfResults(&GlobalCommandInfo[CmdEnumGroup].PerfInfo, Str);
    }
    else
    {
        _tprintf(_T( "\r\nTotal = %d\n" ), dwTotal);
    }

    return( ERROR_SUCCESS );
#endif // IE5
}

//=================================================================================
DWORD
ProcessSimulateCache(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error;
    DWORD i, j;
    TCHAR szUrlName[ URL_NAME_SIZE ];
    TCHAR *UrlName = NULL;
    TCHAR LocalFileName[MAX_PATH];
    DWORD FileSize;
    LONGLONG ExpireTime;
    FILETIME LastModTime;
    TCHAR TimeBuffer[MAX_PATH];
    DWORD NumUrls;
    DWORD UrlLife;
    DWORD BufferSize;
    DWORD CacheHeaderInfoSize;
    DWORD CacheHeaderInfoSizeMax;
    BOOL QuietMode = g_bQuietMode;
    BOOL bRandomInternational = TRUE;
    TCHAR szInternationalString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessSimulateCache NumUrls <s (silent mode)>\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    NumUrls = _tcstoul( argv[0], NULL, 0 );

    while ( argc-- )
    {
        if(LSTRCMPI(argv[argc], _T( "q" )) == 0)
            QuietMode = TRUE;
        else if (!_tcsicmp(argv[argc], _T( "dump" )))
        {
            DumpUrlList = _tfopen (_T( "urllist.sim" ), _T( "a+" ));
            _ftprintf(stderr, _T("Dumping Urls to \"urllist.sim\"\n"));
        }
        else if (!_tcsicmp(argv[argc], RAND_INTL_STRING))
        {
            bRandomInternational= TRUE;
            _ftprintf(stderr, _T("Creating random international strings\n"));
        }
    }

    StartPerfTimer(&GlobalCommandInfo[CmdSimulateCache].PerfInfo, RESET_TIMER);

#ifdef TEST
    for (j=0; j<2; ++j) {
#endif //TEST
        for( i = 0; i < NumUrls; i++ ) {

            //
            // make a new url name.
            //
            if(!g_bPerfMode) {
                MakeRandomUrlName( szUrlName );
                UrlName = szUrlName;
            } else
            if( bRandomInternational ) {
                CreateRandomString( URL_NAME_LENGTH, szInternationalString );
                UrlName = szInternationalString;
            } else
                _stprintf(szUrlName, _T( "http://serv/URL%ld" ), i);

            
            //
            // create url file.
            //
            if( !CreateUrlCacheEntry(
                            UrlName,
                            0,
                            _T( "tmp" ),
                            LocalFileName,
                            0 ) ) {

                Error = GetLastError();
                _tprintf( _T( "CreateUrlFile call failed, %ld.\n" ), Error );
                return( Error );
            }

            //
            // create random file size.
            //
            if(g_dwFileSize == 0)
                FileSize = ((rand() % 10) + 1) * 1024 ;
            else
                FileSize = g_dwFileSize;

            //
            // set file size.
            //
            Error = SetFileSizeByName(
                            LocalFileName,
                            FileSize );
            if( Error != ERROR_SUCCESS ) {
                _tprintf( _T( "SetFileSizeByName call failed, %ld.\n" ), Error );
                return( Error );
            }

            UrlLife = rand() % 48;

            ExpireTime = (LONGLONG)UrlLife * (LONGLONG)36000000000;
            // in 100 of nano seconds.

            LastModTime = GetGmtTime();
            ExpireTime += *((LONGLONG *)&LastModTime);

            //
            // 90% of the time the header info will be less than 256 bytes.
            //
            CacheHeaderInfoSizeMax =
                ((rand() % 100) > 90) ?
                    CACHE_HEADER_INFO_SIZE_BIG_MAX :
                        CACHE_HEADER_INFO_SIZE_NORMAL_MAX;

            CacheHeaderInfoSize = rand() % CacheHeaderInfoSizeMax;

            //
            // cache this file.
            //
            if( !CommitUrlCacheEntry(
                            UrlName,
                            LocalFileName,
                            *((FILETIME *)&ExpireTime),
                            LastModTime,
                            NORMAL_CACHE_ENTRY,
                            (LPBYTE)GlobalCacheHeaderInfo,
                            CacheHeaderInfoSize,
                            TEXT("tst"),
                            0 ) ) {
                Error = GetLastError();
                _tprintf( _T( "CreateUrlFile call failed, %ld.\n" ), Error );
                return( Error );
            }

            if(!QuietMode)
            {
                //
                // GET and PRINT url info, we just added.
                //
                BufferSize = CACHE_ENTRY_BUFFER_SIZE;
                if( !GetUrlCacheEntryInfo(
                        UrlName,
                        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                        &BufferSize ) ) {

                    Error = GetLastError();
                    _tprintf( _T( "GetUrlCacheEntryInfoA call failed, %ld.\n" ), Error );
                    return( Error );
                }
                if (DumpUrlList)
                    _ftprintf(DumpUrlList,_T( "%s\n" ), UrlName);

                // PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, (DWORD)(-1) );

                // Display info
                _tprintf(_T( "%d : %s\n" ), i, UrlName );
#if UNICODE
                _tprintf(_T( "\tTempFileName: %ws\n" ), LocalFileName );
#else
                _tprintf(_T( "\tTempFileName: %s\n" ), LocalFileName );
#endif
                _tprintf(_T( "\tSize : %ld\n" ), FileSize );
                _tprintf(_T( "\tExpires at : %s\n" ),
                    ConvertGmtTimeToString( *((FILETIME *)&ExpireTime), TimeBuffer ) );
                _tprintf(_T( "HeaderInfoSize=%d\n" ), CacheHeaderInfoSize);
            }
        }
#ifdef TEST
        if (j==0) {
            _tprintf(_T( "Freeingcache, OK?" ));
            gets(LocalFileName);
            FreeUrlCacheSpace (NULL, 100, 0);
            _tprintf(_T( "Freed cache, OK?" ));
            gets(LocalFileName);
        }
    }
#endif //TEST

    StopPerfTimer(&GlobalCommandInfo[CmdSimulateCache].PerfInfo);
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdSimulateCache].PerfInfo, _T( "Create %1!ld!" ), NumUrls);

    return( ERROR_SUCCESS );
}

//=================================================================================

DWORD ProcessCreateFile(DWORD argc, LPTSTR *argv)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD dwCnt;
    LPCREATE_FILE_INFO lpcfi;
    HANDLE hFile = NULL;
    TCHAR szResultStr[1024];

    if(argc >= 1)
    {
        _stprintf(szResultStr, _T( "%s %s " ), GlobalCommandInfo[CmdCreateFile].CommandName, argv[0]);

        // Process arguments
        for(dwCnt = 1; dwCnt < argc; dwCnt++)
        {
            lpcfi = Create_File_Table;
            lstrcat(szResultStr, argv[dwCnt]);
            lstrcat(szResultStr, _T( " " ));
            while(*lpcfi->lpszVal)
            {
                if(LSTRCMPI(lpcfi->lpszVal, argv[dwCnt]) == 0)
                {
                    if(lpcfi->bExclusive)
                        *lpcfi->pdwArg = lpcfi->dwVal;
                    else
                        *lpcfi->pdwArg |= lpcfi->dwVal;
                    break;
                }
                lpcfi++;
            }
        }

        StartPerfTimer(&GlobalCommandInfo[CmdCreateFile].PerfInfo, RESET_TIMER);

        g_dwCmdIteration = 0;
        while(g_dwCmdIteration++ < g_dwNumCmdIterations)
        {
            // Create the file
            hFile = CreateFile(
                        argv[0],
                        g_dwCreate_File_Access_Mode,
                        g_dwCreate_File_Share_Mode,
                        NULL,
                        g_dwCreate_File_Creation,
                        g_dwCreate_File_Flags,
                        NULL );

            if(Error == ERROR_SUCCESS && hFile == INVALID_HANDLE_VALUE)
            {
                Error = GetLastError();
            }

            if(g_bWriteFile)
            {
                DWORD dwBytesWritten;
                if(!WriteFile(hFile, g_lpWriteFileBuf, g_dwFileSize, &dwBytesWritten, NULL))
                    Error = GetLastError();
            }

            CloseHandle(hFile);
        }
        StopPerfTimer(&GlobalCommandInfo[CmdCreateFile].PerfInfo);

        if(g_bPerfMode)
            DisplayPerfResults(&GlobalCommandInfo[CmdCreateFile].PerfInfo, szResultStr);
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
    }

    return(Error);
}
//=================================================================================
DWORD
ProcessLoopCnt(
    DWORD argc,
    LPTSTR *argv
    )
{
    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessLoopCnt NumIterations\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    if(g_dwNumIterations == 1)
    {
        g_dwNumIterations = _tcstoul( argv[0], NULL, 0 );
        if(g_dwNumIterations < 1)
            g_dwNumIterations = 1;
    }

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessCmdLoopCnt(
    DWORD argc,
    LPTSTR *argv
    )
{
    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessCmdLoopCnt NumIterations\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    g_dwNumCmdIterations = _tcstoul( argv[0], NULL, 0 );
    if(g_dwNumCmdIterations < 1)
        g_dwNumCmdIterations = 1;

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return ERROR_SUCCESS;
}

//=================================================================================
BOOL
ProcessUseFile (
    DWORD argc,
    LPTSTR *argv
    )
{
    FILE *BatchFile = NULL;
    DWORD Error;
    DWORD i;
    COMMAND_CODE CommandCode;
    TCHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPTSTR CArgv[MAX_COMMAND_ARGS];

    DWORD CommandArgc;
    LPTSTR *CommandArgv;

    if(argc != 1)
        return FALSE;

    AppTimer.ElapsedTime = 0;

    g_bUseFile = TRUE;
    g_dwNumIterations  = 1;
    g_dwIteration = 0;
    while(g_dwIteration++ < g_dwNumIterations)
    {
        if((BatchFile = _tfopen (argv[0], _T( "r" ))) == NULL)
            return FALSE;
        while (fgets( InBuffer, DEFAULT_BUFFER_SIZE, BatchFile ))
        {
            InBuffer[_tcslen(InBuffer) -1] = 0;  //kill line feed for no param cmds

            CArgc = 0;
            ParseArguments( InBuffer, CArgv, &CArgc );

            if( CArgc < 1 ) {
                continue;
            }

            //
            // decode command.
            //
            CommandCode = DecodeCommand( CArgv[0] );
            if( CommandCode == UnknownCommand ) {
                _ftprintf(stderr, _T( "Unknown Command '%s'.\n" ), CArgv[0]);
                continue;
            }

            CommandArgc = CArgc - 1;
            CommandArgv = &CArgv[1];

///            _tprintf(_T( "%s " ), CArgv[0]);
///            for(i = 0; i < CommandArgc; i++)
///                _tprintf(_T( "%s " ), CommandArgv[i]);
///            _tprintf(_T( ", " ));

            StartPerfTimer(&AppTimer, ACCUM_TIMER);
            Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);
            StopPerfTimer(&AppTimer);
        }
///        _tprintf(_T( "===================[ End processing file ]===================\n" ));
        fclose (BatchFile);
    }

    _tprintf(_T( "UseFile, " ));
    if(g_bPerfMode)
        DisplayPerfResults(&AppTimer, NULL);

return TRUE;
}

//=================================================================================
DWORD
ProcessShowTime (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error, dwSize;
    FILETIME ftTemp;
    SYSTEMTIME SystemTime;

#ifdef CONFIGTEST
    TCHAR buff[4096];
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO)buff;

    dwSize = sizeof(buff);

    if (GetUrlCacheConfigInfo(lpCCI, &dwSize, CACHE_CONFIG_DISK_CACHE_PATHS_FC)) {

        int i;

        for (i=0; i<lpCCI->dwNumCachePaths; ++i) {

            lpCCI->CachePaths[i].dwCacheSize++;
        }

        SetUrlCacheConfigInfo(lpCCI, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
    }

#endif //CONFIGTEST

    if(argc != 2)
        return 0xffffffff;

    sscanf(argv[0], _T( "%x" ), &(ftTemp.dwHighDateTime));
    sscanf(argv[1], _T( "%x" ), &(ftTemp.dwLowDateTime));

    if(FileTimeToSystemTime( &ftTemp, &SystemTime )) {
        _tprintf(_T( "%02u/%02u/%04u %02u:%02u:%02u\n " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );

    }
    else {
        _tprintf(_T( "Wrong Times \n" ));
    }

    return ERROR_SUCCESS;
}

//=================================================================================
DWORD AllocWriteFileBuf(void)
{
    DWORD dwRC = ERROR_SUCCESS;

     if(g_lpWriteFileBuf != NULL)
        LocalFree(g_lpWriteFileBuf);

     if((g_lpWriteFileBuf = LocalAlloc(LPTR, g_dwFileSize * sizeof(TCHAR))) != NULL)
     {
         DWORD dwCnt;
         for(dwCnt = 0; dwCnt < g_dwFileSize; dwCnt++)
             *(g_lpWriteFileBuf + dwCnt) = (TCHAR)dwCnt % 256;
     }
     else
     {
         dwRC = GetLastError();
     }

     return(dwRC);
}

//=================================================================================
DWORD
ProcessSetFileSize (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwOldSize = g_dwFileSize;
    DWORD dwRC = ERROR_SUCCESS;

    g_dwFileSize = _tcstoul( argv[0], NULL, 0 );
                   
    if((g_dwFileSize > 0) && (g_dwFileSize != dwOldSize) && g_bWriteFile)
        dwRC = AllocWriteFileBuf();

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return(dwRC);
}

//=================================================================================
DWORD
ProcessSetDiskCache1 (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_dwDiskCache = ((argc == 0) || (LSTRCMPI(argv[0], _T( "on" )) == 0)) ?(g_dwDiskCache | FILE_FLAG_NO_BUFFERING) :(g_dwDiskCache & ~FILE_FLAG_NO_BUFFERING);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetDiskCache2 (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_dwDiskCache = ((argc == 0) || (LSTRCMPI(argv[0], _T( "on" )) == 0)) ?(g_dwDiskCache | FILE_FLAG_WRITE_THROUGH) :(g_dwDiskCache & ~FILE_FLAG_WRITE_THROUGH);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetQuietMode (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_bQuietMode = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetPerfMode (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_bPerfMode = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessWriteFile (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;

    if(g_dwFileSize == 0)
    {
        _tprintf(_T( "You must specify a FileSize in order to turn WriteFile On.\n" ));
        dwRC = ERROR_INVALID_FUNCTION;
    }
    else
    {
        g_bWriteFile = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);

        if(g_bWriteFile && g_dwFileSize)
            dwRC = AllocWriteFileBuf();
    }

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return(dwRC);
}

//=================================================================================
DWORD
ProcessCreateGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;
    _tprintf(_T( "CreateGroup...\n" ));
    return dwRC;
}
     
DWORD
ProcessDeleteGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;
    _tprintf(_T( "DeleteGroup...\n" ));
    return dwRC;
}


//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPTSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
        case CmdCreateUrlCacheEntry :
            Error = ProcessCreateUrlCacheEntry( CommandArgc, CommandArgv );
            break;

        case CmdCommitUrlCacheEntry :
            Error = ProcessCommitUrlCacheEntry( CommandArgc, CommandArgv );
            break;
            
        case CmdUpdateUrlCacheEntry :
            Error = ProcessUpdateUrlCacheEntry( CommandArgc, CommandArgv );
            break;

        case CmdRetrieveUrlCacheEntryFile :
            Error = ProcessRetrieveUrlCacheEntryFile( CommandArgc, CommandArgv );
            break;

        case CmdRetrieveUrlCacheEntryStream :
            Error = ProcessRetrieveUrlCacheEntryStream( CommandArgc, CommandArgv );
            break;
#ifdef IE5
        case CmdUnlockUrlCacheEntryFile :
            Error = ProcessUnlockUrlCacheEntryFile( CommandArgc, CommandArgv );
            break;
#endif
        case CmdGetUrlCacheEntryInfo :
            Error = ProcessGetUrlCacheEntryInfo( CommandArgc, CommandArgv );
            break;

        case CmdSetUrlCacheEntryInfo :
            Error = ProcessSetUrlCacheEntryInfo( CommandArgc, CommandArgv );
            break;

        case CmdSetExempt:
            Error = ProcessSetExempt (CommandArgc, CommandArgv);
            break;

#ifdef IE5
        case CmdSetUrlCacheEntryGroup:
            Error = ProcessSetUrlCacheEntryGroup (CommandArgc, CommandArgv );
            break;

        case CmdDeleteUrlCacheEntry :
            Error = ProcessDeleteUrlCacheEntry( CommandArgc, CommandArgv );
            break;
#endif

        case CmdEnumUrlCacheEntries :
            Error = ProcessEnumUrlCacheEntries( CommandArgc, CommandArgv );
            break;

        case CmdEnumGroup :
            Error = ProcessEnumGroup( CommandArgc, CommandArgv );
            break;

        case CmdSimulateCache :
            Error = ProcessSimulateCache( CommandArgc, CommandArgv );
            break;

        case CmdCreateFile :
            Error = ProcessCreateFile( CommandArgc, CommandArgv );
            break;

        case CmdLoopCnt :
            Error = ProcessLoopCnt( CommandArgc, CommandArgv );
            break;

        case CmdCmdLoopCnt :
            Error = ProcessCmdLoopCnt( CommandArgc, CommandArgv );
            break;

        case CmdFreeCacheSpace :
            Error = ProcessFreeCacheSpace( CommandArgc, CommandArgv );
            break;

        case CmdShowTime:
            Error = ProcessShowTime( CommandArgc, CommandArgv );
            break;

        case CmdSetFileSize:
            Error = ProcessSetFileSize( CommandArgc, CommandArgv );
            break;

        case CmdSetDiskCache1:
            Error = ProcessSetDiskCache1( CommandArgc, CommandArgv );
            break;

        case CmdSetDiskCache2:
            Error = ProcessSetDiskCache2( CommandArgc, CommandArgv );
            break;

        case CmdSetQuietMode:
            Error = ProcessSetQuietMode( CommandArgc, CommandArgv );
            break;

        case CmdSetPerfMode:
            Error = ProcessSetPerfMode( CommandArgc, CommandArgv );
            break;

        case CmdWriteFile:
            Error = ProcessWriteFile( CommandArgc, CommandArgv );
            break;

        case CmdCreateGroup:
            Error = ProcessCreateGroup( CommandArgc, CommandArgv );
            break;

        case CmdDeleteGroup:
            Error = ProcessDeleteGroup( CommandArgc, CommandArgv );
            break;

        case CmdHelp :
            DisplayUsage();
            break;

        case CmdGetExQ :
            DisplayExemptQuota();
            break;

        case CmdQuit :

            _tprintf( _T( "---Results---\n" )
                _T( "Total Commands:    %d\n" )
                _T( "Failed Commands:   %d\n" )
                _T( "Bye Bye..\n" ),
                cCommands, cFails);
            if (DumpUrlList)
                fclose(DumpUrlList);
            if (UrlList)
                fclose(UrlList);

            exit (0);

        case CmdUseFile:
            if (!ProcessUseFile (CommandArgc, CommandArgv))
            {
                Error = ERROR_FILE_NOT_FOUND;
                _tprintf(_T( "File Not Found\n" ));
            }
            break;

        default:
            TestDbgAssert( FALSE );
            _ftprintf(stderr, _T( "Unknown Command Specified.\n" ));
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPTSTR LPTSTR;

            cFails++;
            Format_Error(Error, &LPTSTR);
            _tprintf(_T( "FAILED (%s), %ld-%s.\n" ),
                GlobalCommandInfo[CommandCode].CommandName, Error, LPTSTR );
            LocalFree(LPTSTR);
        }
        else {
            if(!g_bQuietMode)
                _tprintf(_T( "Command (%s) successfully completed.\n" ), GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
int __cdecl // _CRTAPI1
_tmain(
    int argc,
    TCHAR *argv[],
	TCHAR **envp
    )
{
    TCHAR szInternational[32];
    DWORD cbRet;

    DWORD Error;
    DWORD i;
    COMMAND_CODE CommandCode;
    TCHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPTSTR CArgv[MAX_COMMAND_ARGS];

    DWORD CommandArgc;
    LPTSTR *CommandArgv;

#ifdef INTERNATIONAL
    //
    // THis is code for testing international strings.
    // intlgent.dll is a module which implements "GetRandomIntlString"
    // You need to install an international langpack 
    // for this to work. Also, switch your default codepage
    // or locale to that of the intl pack
    //
    hModule = LoadLibrary(_T("intlgent.dll"));

    if( hModule == NULL ) {
        _tprintf(_T("Unable to Load Library Intlgent.dll , GLE=%d\n"), GetLastError() );
        return 0;
    }

    fnGetRandIntlString = (FNGetRandIntlString)GetProcAddress(hModule,"GetRandIntlString");

    if(!fnGetRandIntlString) {
        _tprintf(_T("Did not find GetRandIntlString\n") );
    	return 0;
    }

    cbRet = fnGetRandIntlString(
                            32, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 
                            szInternational); // string to be returned


    _tprintf(_T("GetRandIntlString() returns %s\n"), szInternational );
#endif

#if 0
    //
    // other tests.
    //
    time_t Seed;

    Seed = time(NULL);
    _tprintf(_T( "RAND_MAX = %ld\n" ), RAND_MAX);
    _tprintf(_T( "Seed Random gen. w/ %ld\n" ), Seed);
    srand( Seed );

    TestMakeRandomUrlName();
#else // 0
    //
    // init GlobalCacheHeaderInfo buffer.
    //

	memset(GlobalCacheHeaderInfo, 0, sizeof(GlobalCacheHeaderInfo));
    //for( i = 0; i < CACHE_HEADER_INFO_SIZE; i++) {
    //    GlobalCacheHeaderInfo[i] = (BYTE)((DWORD)_T( '0' ) + i % 10);
    //}
    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            _tprintf(_T( "Unknown Command Specified.\n" ));
            return -1;
        }

        Sleep(2000);    // Allow wininet's worker thread to finish so we get good timing

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUrlList)
            fclose(DumpUrlList);
        if (UrlList)
            fclose(UrlList);

        return 0;
    }

    DisplayUsage();

    for(;;) {
        _ftprintf(stderr, _T( "[" ));

#ifdef INTERNATIONAL
        _ftprintf(stderr, _T( "INTL " ));
#endif

#ifdef UNICODE
        _ftprintf(stderr, _T( "UNICODE" ));
#else
        _ftprintf(stderr, _T( "ANSI" ));
#endif

        _ftprintf(stderr, _T( "] Command : "));

        _getts( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            _ftprintf(stderr, _T( "Unknown Command Specified.\n" ));
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }
#endif // 0

    FreeLibrary( hModule );

    return 0;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPTSTR   lpszPath
    )
{
    DWORD len, i;
    LPTSTR   lpT;

    if(!lpszPath)
        return(0);

    len = LSTRLEN(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT ==_T( '\\' )) {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == _T( '\\' )) {
            break;
        }
    }
    return (LSTRLEN(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPTSTR *plpsz, LPTSTR lpszFmt, ...)
{
    const TCHAR c_Func_Name[] = _T( "[Format_String] " );
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPTSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const TCHAR szMsg[] = _T( "No Error" );
        Format_String(plpsz, (LPTSTR)szMsg);
        dwRet = LSTRLEN(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const TCHAR c_Func_Name[] = _T( "[Format_MessageV]" );

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPTSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        _tprintf(_T( "%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n" ), c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\utils\cdcache\cdcache.cpp ===
/******************************************************************************\
*
*	CDCACHE.EXE
*
*	Synopsis:
*		An AutoRun EXE to enable easy addition of CD-ROM content
*		into the Internet Explorer (WININET) Persistent URL Cache.
*
*	Usage:
*		Place an AUTORUN.INF at the root of the CD-ROM which has content
*		that you want to register with the WININET Persistent URL Cache.
*		Contents of AUTORUN.INF:
*
*			[autorun]
*			open=cdcache.exe
*			icon=cdcache.exe, 1
*
*		Additionally create a CDCACHE.INF at the root of the CD-ROM.
*		Typical contents:
*
*			[Add.CacheContainer]
*			<Friendly Unique Vendor Name>=<INF Section Name>
*
*			[INF Section Name]
*			CachePrefix=<string>
*			CacheRoot=<relative path on CD-ROM of data>
*			KBCacheLimit=<numerical amount in KB>
*			AutoDelete=Yes|No (default)
*			IncludeSubDirs=Yes (default) |No
*			NoDesktopInit=Yes|No (default)
*
*
*		CMD Line Options:
*		/Silent		Install Cache Container without showing UI
*		/Remove     Uninstall the cache container
*		/Uninstall  same as /Remove
*
*	History
*		23June97	robgil				created
*		06Aug97		robgil				add IE4 wininet.dll checks
*		26Aug97		robgil				manual register if no IE4
*
*	Copyright (C) 1994-1997 Microsoft Corporation.
*	All rights reserved.
*
\******************************************************************************/
#include "stdhdr.h"

/////////////////////////////////////////////////////////////////////////
// Defines and Type Declarations

#define STRING_BUFFER_SIZE		256

#define CACHE_ACTION_INSTALL			0
#define CACHE_ACTION_REMOVE				1
#define CACHE_ACTION_FILL_LB			2
#define CACHE_ACTION_MAKE_REG_ENTRIES	3

typedef BOOL (CALLBACK* LPFNCREATEURLCACHECONTAINER)(LPCSTR,LPCSTR,LPCSTR,DWORD,DWORD,DWORD,LPVOID,LPDWORD);
typedef BOOL (CALLBACK* LPFNDELETEURLCACHECONTAINER)(LPCSTR,DWORD);
typedef HANDLE (CALLBACK* LPFNFINDFIRSTURLCACHECONTAINER)(LPDWORD,LPINTERNET_CACHE_CONTAINER_INFO,LPDWORD,DWORD);
typedef BOOL (CALLBACK* LPFNFINDNEXTURLCACHECONTAINER)(HANDLE,LPINTERNET_CACHE_CONTAINER_INFO,LPDWORD);
typedef BOOL (CALLBACK* LPFNFINDCLOSEURLCACHE)(HANDLE);
typedef BOOL (CALLBACK* LPFNGETURLCACHECONFIGINFO)(LPINTERNET_CACHE_CONFIG_INFO,LPDWORD,DWORD);

/////////////////////////////////////////////////////////////////////////
// Global Variables:

HINSTANCE g_hInst;			// current instance
BOOL g_fRunSilent = FALSE;	// True = show no UI
BOOL g_fRemove    = FALSE;	// True = remove the cache containers in INF
//BOOL g_fNoIE4Msg  = FALSE;	// True = do not show UI saying IE4 WININET is required
BOOL g_fNoIE4	  = FALSE;	// IE4 WININET is not available

TCHAR  gszIniValTrue[]			= INI_TRUE ;
TCHAR  gszIniValFalse[]			= INI_FALSE ;
TCHAR  gszIniValOn[]			= INI_ON ;
TCHAR  gszIniValOff[]			= INI_OFF ;

TCHAR  gszIniValYes[]			= INI_YES ;
TCHAR  gszIniValNo[]			= INI_NO ;

LPFNCREATEURLCACHECONTAINER		lpfnCreateUrlCacheContainer		= NULL;
LPFNDELETEURLCACHECONTAINER		lpfnDeleteUrlCacheContainer		= NULL;
LPFNFINDFIRSTURLCACHECONTAINER	lpfnFindFirstUrlCacheContainer	= NULL;
LPFNFINDNEXTURLCACHECONTAINER	lpfnFindNextUrlCacheContainer	= NULL;
LPFNFINDCLOSEURLCACHE			lpfnFindCloseUrlCache			= NULL;
LPFNGETURLCACHECONFIGINFO		lpfnGetUrlCacheConfigInfo		= NULL;

/////////////////////////////////////////////////////////////////////////
// Foward declarations of functions included in this code module:

INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CenterWindow (HWND, HWND);
int OnInitDialog(HWND hDlg);

BOOL LoadWininet(void);
BOOL WininetLoaded(void);
BOOL CacheContainer(DWORD *dwTotal, DWORD *dwInstalled, DWORD dwAction, HWND hListBox);

HRESULT	ExpandEntry(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[]);

HRESULT ExpandVar(
        LPSTR& pchSrc,          // passed by ref!
        LPSTR& pchOut,          // passed by ref!
        DWORD& cbLen,           // passed by ref!
        DWORD cbBuffer,         // size of out buffer
        const char * szVars[],  // array of variable names eg. %EXE_ROOT%
        const char * szValues[]);// corresponding values to expand of vars

LPSTR GetINFDir(LPSTR lpBuffer, int nBuffSize);
LPSTR GetINFDrive(LPSTR lpBuffer, int nBuffSize);
WORD GetProfileBooleanWord(LPCTSTR szIniSection, LPCTSTR szKeyName, LPCTSTR szIniFile);
DWORD CreateAdditionalEntries(LPCSTR lpszUniqueVendorName, LPCSTR lpszVolumeTitle, LPCSTR lpszVolumeLabel, LPCSTR lpszPrefixMap);
DWORD GetPrefixMapEntry(LPCSTR lpszUniqueVendorName, LPSTR lpszPrefixMap, DWORD cbPrefixMap);
BOOL UrlCacheContainerExists(LPCSTR lpszUniqueVendorName, LPCSTR lpszCachePrefix, LPCSTR lpszPrefixMap);

// WININET CreateUrlCacheContainer WRAPPER
// Wraps up the hacks in one spot - see f() header for details
BOOL _CreateUrlCacheContainer(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
     IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
     IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,         // New - part of Wrapper.
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,
     IN DWORD dwOptions
     );


/************************************************************************\
 *    FUNCTION: WinMain
\************************************************************************/

int APIENTRY WinMain(HINSTANCE g_hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	LPSTR   lpszCmd = NULL;
	DWORD	dwTotal = 0;
	DWORD	dwInstalled = 0;

	g_hInst = g_hInstance;

	// Parse lpCmdLine looking for options we understand
    TCHAR szTokens[] = _T("-/ ");
    LPTSTR lpszToken = _tcstok(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (_tcsicmp(lpszToken, _T("Silent"))==0)
            g_fRunSilent = TRUE;
        else if (_tcsicmp(lpszToken, _T("Remove"))==0)
			g_fRemove = TRUE;
		else if (_tcsicmp(lpszToken, _T("Uninstall"))==0)
			g_fRemove = TRUE;
//		else if (_tcsicmp(lpszToken, _T("NoIE4Msg"))==0)
//			g_fNoIE4Msg = TRUE;

        lpszToken = _tcstok(NULL, szTokens);
    }

	
	// Check for IE4 or higher WININET.DLL version
	// and dynamically load it and init global function pointers
	// to WININET f() used in this application
	// This will avoid Undefined Dynalink errors when run on a
	// system without IE4
	if (!LoadWininet())
	{
		g_fNoIE4 = TRUE;

		// Put up message about requiring IE4 WININET

		/* Since we workaround not having IE4 - no need for message
		 
		if (!g_fNoIE4Msg)
		{
			char szString[128];		// Keep string 70% larger for localization
			char szCaption[128];	// Keep string 70% larger for localization

			LoadString (g_hInst, ID_APPNAME, szCaption, sizeof(szCaption));
			LoadString (g_hInst, IDM_NEEDIE4WININET, szString, sizeof(szString));
			MessageBox(NULL, szString, szCaption, MB_OK);
		}
		*/

		// Can't call WININET
		// Need to make registry entries to install cache containers
		//
		if (!CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_FILL_LB, NULL))
		{
            if (g_fRunSilent)
            {
                // Create cache entries in silent mode.
                CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_MAKE_REG_ENTRIES, NULL);

            }
            else
            {
                // Otherwise run app.
                DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
            }
            return(FALSE);
		}

		return 0;	// Quit and go home
	}


	if (!g_fRunSilent)
	{
		// Only want to put up UI if any of the containers are NOT installed
		// (this includes those containers that are installed but the
		//  PrefixMap entry is incorrect - i.e. wrong drive)

		if (!CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_FILL_LB, NULL))
		{
			DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
			return(FALSE);
		}
		else
		{
			// All the CacheContainers are already installed or there is no INF
			// so check if we want to uninstall
			// OnInitDialog checks the g_fRemove flags and POST's a msg
			// to dialog to initiate the Uninstall steps
			if (g_fRemove)
				DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
		}
	}
	else
	{
		DWORD	dwAction = CACHE_ACTION_INSTALL;	// default action is INSTALL

		// We're running silent and deep - all quiet on board
		// we don't need no stinkin window

		if (g_fRemove)
			dwAction = CACHE_ACTION_REMOVE;

		if (!CacheContainer(&dwTotal, &dwInstalled, dwAction, NULL))
		{
			// BUGBUG: Since we're running silent what
			// should we do on failure?
		}

		return 0;
	}
	
	return 0;
}

/************************************************************************\
 *    FUNCTION: DlgProc
\************************************************************************/

INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message)
	{

		case WM_INITDIALOG:
			return OnInitDialog(hDlg);

		case WM_COMMAND:
			wmId    = LOWORD(wParam); // Remember, these are...
			wmEvent = HIWORD(wParam); // ...different for Win32!
		
			switch (wmId)
			{
				case IDM_INSTALL:
				{
					DWORD	dwError = 0;
					DWORD	dwTotal = 0;
					DWORD	dwInstalled = 0;
					DWORD	dwAction = 0;

					if (g_fNoIE4)
						dwAction = CACHE_ACTION_MAKE_REG_ENTRIES;
					else
						dwAction = CACHE_ACTION_INSTALL;

					if (!CacheContainer(&dwTotal, &dwInstalled, dwAction, NULL))
					{
						dwError = GetLastError();
					}

					if (dwInstalled > 0)
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Successfully installed a cache container
						// though not necessarily all of them.
						LoadString (g_hInst, IDM_SUCCESS, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwInstalled, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);

						// We're done close this app
						PostMessage (hDlg, WM_CLOSE, 0, 0);
					}
					else
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Unable to install any of the cache containers successfully
						LoadString (g_hInst, IDM_FAILED, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);
					}
					break;
				}

				case IDM_UNINSTALL:
				{
					DWORD	dwError = 0;
					DWORD	dwTotal = 0;
					DWORD	dwRemoved = 0;

					if (g_fNoIE4)
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Uninstall of cache containers requires IE4
						LoadString (g_hInst, IDM_ERR_IE4REQFORUNINSTALL, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwRemoved, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);
					}
					else
					{

						if (!CacheContainer(&dwTotal, &dwRemoved, CACHE_ACTION_REMOVE, NULL))
						{
							dwError = GetLastError();
						}

						if (dwRemoved > 0)
						{
							char szString[128];	// Keep string 70% larger for localization
							char szBuffer[256];

							// Successfully UnInstalled a cache container
							// though not necessarily all of them.
							LoadString (g_hInst, IDM_SUCCESS_REMOVE, szString, sizeof(szString));
							wsprintf(szBuffer, szString, dwRemoved, dwTotal);
							LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
							MessageBox(hDlg, szBuffer, szString, MB_OK);
						}
						else
						{
							char szString[128];	// Keep string 70% larger for localization
							char szBuffer[256];

							// Unable to install any of the cache containers successfully
							LoadString (g_hInst, IDM_FAILED_REMOVE, szString, sizeof(szString));
							wsprintf(szBuffer, szString, dwTotal);
							LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
							MessageBox(hDlg, szBuffer, szString, MB_OK);
						}
					}

					if (g_fRemove)
					{
						// We're done close this app
						PostMessage (hDlg, WM_CLOSE, 0, 0);
					}

					break;
				}

				case IDCANCEL:
					EndDialog(hDlg, TRUE);
					break;

				default:
					return (FALSE);
			}
			break;

		default:
			return (FALSE);
	}
	return (TRUE);
}


/************************************************************************\
 *    FUNCTION: CenterWindow
\************************************************************************/
// This is a 'utility' function I find usefull. It will center one
// window over another. It also makes sure that the placement is within
// the 'working area', meaning that it is both within the display limits
// of the screen, -and- not obscured by the tray or other frameing
// elements of the desktop.
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent, rWorkArea = {0,0,0,0};
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xScreen, yScreen, xNew, yNew;
	BOOL bResult;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the limits of the 'workarea'
#if !defined(SPI_GETWORKAREA)
#define SPI_GETWORKAREA 48
#endif
	bResult = SystemParametersInfo(
    	SPI_GETWORKAREA,	// system parameter to query or set
    	sizeof(RECT),	// depends on action to be taken
    	&rWorkArea,	// depends on action to be taken
    	0);	

	wScreen = rWorkArea.right - rWorkArea.left;
	hScreen = rWorkArea.bottom - rWorkArea.top;
	xScreen = rWorkArea.left;
	yScreen = rWorkArea.top;

	// On Windows NT, the above metrics aren't valid (yet), so they all return
	// '0'. Lets deal with that situation properly:
	if (wScreen==0 && hScreen==0) {
		wScreen = GetSystemMetrics(SM_CXSCREEN);
		hScreen = GetSystemMetrics(SM_CYSCREEN);
		xScreen = 0; // These values should already be '0', but just in case
		yScreen = 0;
	}

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < xScreen) {
		xNew = xScreen;
	} else if ((xNew+wChild) > wScreen) {
		xNew = (xScreen + wScreen) - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < yScreen) {
		yNew = yScreen;
	} else if ((yNew+hChild) > hScreen) {
		yNew = (yScreen + hScreen) - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

int OnInitDialog(HWND hDlg)
{
	HWND	hListBox;
	DWORD	dwRemoved = 0;
	DWORD	dwTotal = 0;

	CenterWindow (hDlg, GetDesktopWindow ());

	hListBox = GetDlgItem(hDlg, IDC_LIST);

	// Populate list box with Cache Container list
	CacheContainer(&dwTotal, &dwRemoved, CACHE_ACTION_FILL_LB, hListBox);

	// #57353 - after adding don't show UI if already installed
	// we forgot to account for /uninstall on cmd line
	if (g_fRemove)
		PostMessage(hDlg, WM_COMMAND, IDM_UNINSTALL, 0L);

	return FALSE;
}

/************************************************************************\
*   FUNCTION: LoadWininet()
*
*	If IE4 or greater version of WININET then load it up and establish
*	function pointers to use in rest of application.
*
*	returns BOOL
*		TRUE  - Sufficient version of WININET.DLL is available
*		FALSE - WININET.DLL is not new enough for our purposes
*
\************************************************************************/
BOOL LoadWininet()
{
	HINSTANCE	hDll;

	hDll = LoadLibrary("WININET.DLL");

	if (hDll != NULL)
	{
		lpfnCreateUrlCacheContainer = (LPFNCREATEURLCACHECONTAINER)GetProcAddress(hDll, "CreateUrlCacheContainerA");
		lpfnDeleteUrlCacheContainer = (LPFNDELETEURLCACHECONTAINER)GetProcAddress(hDll, "DeleteUrlCacheContainerA");
		lpfnFindFirstUrlCacheContainer = (LPFNFINDFIRSTURLCACHECONTAINER)GetProcAddress(hDll, "FindFirstUrlCacheContainerA");
		lpfnFindNextUrlCacheContainer = (LPFNFINDNEXTURLCACHECONTAINER)GetProcAddress(hDll, "FindNextUrlCacheContainerA");
		lpfnFindCloseUrlCache = (LPFNFINDCLOSEURLCACHE)GetProcAddress(hDll, "FindCloseUrlCache");
		lpfnGetUrlCacheConfigInfo = (LPFNGETURLCACHECONFIGINFO)GetProcAddress(hDll, "GetUrlCacheConfigInfoA");

		if ( (!lpfnCreateUrlCacheContainer) ||
			 (!lpfnDeleteUrlCacheContainer) ||
			 (!lpfnFindFirstUrlCacheContainer) ||
			 (!lpfnFindNextUrlCacheContainer) ||
			 (!lpfnFindCloseUrlCache) ||
			 (!lpfnGetUrlCacheConfigInfo) )
		{
			
			lpfnCreateUrlCacheContainer = NULL;
			lpfnDeleteUrlCacheContainer = NULL;
			lpfnFindFirstUrlCacheContainer = NULL;
			lpfnFindNextUrlCacheContainer = NULL;
			lpfnFindCloseUrlCache = NULL;
			lpfnGetUrlCacheConfigInfo = NULL;

			FreeLibrary(hDll);

			return FALSE;
		}
	}
	else
		return FALSE;

	return TRUE;
}

/************************************************************************\
*   FUNCTION: WininetLoaded()
*
*	returns BOOL
*		TRUE  - Sufficient version of WININET.DLL is available
*		FALSE - WININET.DLL is not new enough for our purposes
*
\************************************************************************/
BOOL WininetLoaded()
{
	if (lpfnCreateUrlCacheContainer)
		return TRUE;

	return FALSE;
}

/************************************************************************\
*   FUNCTION: UrlCacheContainerExists()
*
*
*	returns BOOL
*		TRUE  - This cache container is already installed and PrefixMap
*				location is correct
*		FALSE - Cache container is not installed or it's PrefixMap
*				location is different
*
\************************************************************************/

BOOL UrlCacheContainerExists(LPCSTR lpszUniqueVendorName, LPCSTR lpszCachePrefix, LPCSTR lpszPrefixMap)
{
	BYTE	bBuf[4096];
	LPINTERNET_CACHE_CONTAINER_INFO lpCCI = (LPINTERNET_CACHE_CONTAINER_INFO) bBuf;
	DWORD	cbCEI = sizeof(bBuf);
	DWORD	dwModified = 0;
	HANDLE	hEnum = NULL;
	BOOL	bFound = FALSE;

	BOOL	bReturn = FALSE;

	if (!WininetLoaded())
		return FALSE;

	// Look for our cache container, then determine if it already exists
	// also need to make sure PrefixMap entry is correct
	// for situation when CD is placed into a different drive
	// after it's already been installed
	hEnum = lpfnFindFirstUrlCacheContainer(&dwModified, lpCCI, &cbCEI, 0);

	if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
		bFound = TRUE;
	else
	{
		while (hEnum && lpfnFindNextUrlCacheContainer(hEnum, lpCCI, &cbCEI))
		{
			if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound)
	{
		// Now check if URL CachePrefix pattern is the same
		if (0 == lstrcmpi(lpszCachePrefix, lpCCI->lpszCachePrefix))
		{
			char	lpBuffer[256];
			DWORD	cbBuffer = sizeof(lpBuffer);

			// Now check if PrefixMap entry is OK
			GetPrefixMapEntry(lpszUniqueVendorName, lpBuffer, cbBuffer);
			
			if (0 == lstrcmpi(lpBuffer, lpszPrefixMap))
				bReturn = TRUE;
			else
				bReturn = FALSE;

			// If both CachePrefix and PrefixMap match
			// then we consider this entry to already exist
			// and is correctly installed.
		}
	}

	if (hEnum)
		lpfnFindCloseUrlCache(hEnum);

	return bReturn;
}

/************************************************************************\
*   FUNCTION: _CreateUrlCacheContainer()
*
*	Wrapper around WININET CreateUrlCacheContainer()
*
*	Parameters:
*
*	REMOVED
*   lpszUserLocalCachePath
*					Don't need to pass it in since can figure it out
*					using GetUrlCacheConfigInfo()
*
*   ADDED
*	lpszPrefixMap	Param added to wrapper, is missing from WININET f()
*					Specifies the location root path of the data
*					provided by the cache container.
*
*	Workaround #1 - Pre-poplulate registry with PrefixMap
*	-----------------------------------------------------
*	In order to work properly must pre-populate registry
*	with the PrefixMap entry. Otherwise WININET CreateUrlCacheContainer()
*	will not install the cache container.
*
*	STEP #1:
*	========
*	Must setup registry entry in
*	HKCU\Software\Microsoft\Windows\CurrentVersion\
*		Internet Settings\Cache\Extensible Cache
*
*	For PrefixMap
*	Key = <Unique Vendor Name>
*		PrefixMap		= <string>
*
*
*	Other Entries include:
*		CacheLimit		= <DWORD>
*		CacheOptions	= <DWORD>
*		CachePath		= <string>
*		CachePrefix		= <string>
*	These should be put there by the call to CreateUrlCacheContainer()
*
*	STEP #2
*	=======
*	Call CreateUrlCacheContainer()
*
*	Locates all the 'workarounds' to one function.
\************************************************************************/
BOOL _CreateUrlCacheContainer(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
	 IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
	 IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,         // New - part of WRAPPER
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,			// Not used by WININET currently
     IN DWORD dwOptions
     )
{
	// Enough size to get our info first time without having to realloc
    BYTE bBuf[4096];
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) bBuf;
    DWORD cbCEI = sizeof(bBuf);

	DWORD dwError = 0;
	char szCachePath[MAX_PATH];

    DWORD	dwResult = ERROR_SUCCESS;

	if (!WininetLoaded())
		return FALSE;
    
    
    // Figure out local user cache location directory
	if (!lpfnGetUrlCacheConfigInfo(lpCCI, &cbCEI, CACHE_CONFIG_CONTENT_PATHS_FC))
	{
		// Look for ERROR_INSUFFICIENT_BUFFER and allocate enough
		if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
			// BUGBUG: TODO: Handle insufficient buffer case
			// Try again using required size returned in cbCEI
			//lpCCI = new INTERNET_CACHE_CONFIG_INFO[cbCEI];
		}
		else
			dwError = GetLastError();
	}
	else
	{
		if (lpCCI->dwNumCachePaths > 0)
			lstrcpy(szCachePath, lpCCI->CachePaths[0].CachePath);
	}

	// Add Cache Container Unique Vendor Name to CachePath
	// All container content will be stored in this location
	if(lstrlen(szCachePath) + lstrlen(lpszUniqueVendorName) >= sizeof(szCachePath) / sizeof(szCachePath[0]))
	{
		return FALSE;
	}

	lstrcat(szCachePath, lpszUniqueVendorName);

	// Manually put PrefixMap into Registry
	// HKCU\Software\Microsoft\Windows\CurrentVersion\
	//		Internet Settings\Cache\Extensible Cache
	CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

	// BUGBUG: Currently CreateUrlCacheContainer() fails if the entry
	// already exists. The returned GetLastError() is ERROR_INVALID_PARAM
	// Need to workaround this for now by enumerating the existing
	// cache containers and if found remove it and then re-add it.

	if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
				szCachePath, KBCacheLimit, dwContainerType,
				dwOptions, NULL, 0))
	{
		BYTE	bBuf[4096];
		LPINTERNET_CACHE_CONTAINER_INFO lpCCI = (LPINTERNET_CACHE_CONTAINER_INFO) bBuf;
		DWORD	cbCEI = sizeof(bBuf);
		DWORD	dwModified = 0;
		HANDLE	hEnum = NULL;
		int		nCount = 0;

		// Assume we failed because cache container already exists
		// Look for our cache container, delete it, and re-create it
		hEnum = lpfnFindFirstUrlCacheContainer(&dwModified, lpCCI, &cbCEI, 0);

		if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
		{
			// BUGBUG: Need to specify any options?
			if (!lpfnDeleteUrlCacheContainer(lpszUniqueVendorName, 0))
			{
				dwResult = GetLastError();
			}
			else
			{
				CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

				if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
							szCachePath, KBCacheLimit, dwContainerType,
							dwOptions, NULL, 0))
				{
					dwResult = GetLastError();
				}
			}
		}
		else
		{
			while (hEnum && lpfnFindNextUrlCacheContainer(hEnum, lpCCI, &cbCEI))
			{
				if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
				{
					if (!lpfnDeleteUrlCacheContainer(lpszUniqueVendorName, 0))
					{
						dwResult = GetLastError();
					}
					else
					{
						CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

						if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
									szCachePath, KBCacheLimit, dwContainerType,
									dwOptions, NULL, 0))
						{
							dwResult = GetLastError();
						}

						break;
					}
				}

				nCount++;
			}
		}

		if (hEnum)
			lpfnFindCloseUrlCache(hEnum);

	}

	if (dwResult != ERROR_SUCCESS)
		return (FALSE);
	else
		return (TRUE);

//	return lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
//				szCachePath, KBCacheLimit, dwContainerType,
//				dwOptions, NULL, 0);
}

/************************************************************************\
*   FUNCTION: CreateAdditionalEntries()
*
*	Add the PrefixMap registry entry to the correct location in the
*	registry. A requirement to workaround this param missing from
*	the CreateUrlCacheContainer() WININET API.
*
\************************************************************************/

DWORD CreateAdditionalEntries(LPCSTR lpszUniqueVendorName, LPCSTR lpszVolumeTitle, 
                              LPCSTR lpszVolumeLabel, LPCSTR lpszPrefixMap)
{
    const static char *szKeyPrefixMap   = "PrefixMap";
    const static char *szKeyVolumeLabel	= "VolumeLabel";
    const static char *szKeyVolumeTitle	= "VolumeTitle";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";
    
	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	DWORD	dwResult = ERROR_SUCCESS;
    CHAR szCurDir[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];

	// Manually put PrefixMap into Registry
	//
	// BUGBUG: cache containers are per user if user profiles are enabled
	// so on NT they are always per user, on Win95 however 
	// Need to use HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE below
	// depending on what's enabled.
	//
	// Hack on top of a Hack for Win95 ONLY
	// Since this entire function is to workaround the lack of a param
	// for PrefixMap in CreateUrlCacheContainer() another hack shouldn't
	// matter since it's only temporary
	// On Win95 need to check this entry
	// HKEY_LOCAL_MACHINE\Network\Logon
	//		UserProfiles=DWORD:00000001
	// which says if UserProfiles are turned on
	// If they are turned on we use HKEY_CURRENT_USER
	// otherwise use HKEY_LOCAL_MACHINE
	
	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist

			// Let's try to create it
			dwResult = RegCreateKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
				NULL, &hKeyVendor, &dwDisposition);

        }    
    
    }

    if (dwResult == ERROR_SUCCESS)
    {
        RegSetValueEx(hKeyVendor, szKeyPrefixMap, 0, REG_SZ,
            (CONST UCHAR *) lpszPrefixMap, lstrlen(lpszPrefixMap)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeLabel, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeLabel, lstrlen(lpszVolumeLabel)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeTitle, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeTitle, lstrlen(lpszVolumeTitle)+1);
    }        
    
    
        
	return dwResult;
}

/************************************************************************\
*   FUNCTION: GetPrefixMapEntry()
*
*	Get the PrefixMap registry entry from the correct location in the
*	registry.
*
*	Returns: PrefixMap entry in lpszPrefixMap
*			 or NULL if no enty is found.
*
\************************************************************************/

DWORD GetPrefixMapEntry(LPCSTR lpszUniqueVendorName, LPSTR lpszPrefixMap, DWORD cbPrefixMap)
{
    const static char *szKeyPrefixMap = "PrefixMap";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";

	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	unsigned long	ulVal = 0;
	DWORD	dwResult = ERROR_SUCCESS;

	// Manually put PrefixMap into Registry
	//
	// BUGBUG: cache containers are per user if user profiles are enabled
	// so on NT they are always per user, on Win95 however 
	// Need to use HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE below
	// depending on what's enabled.
	//
	// Hack on top of a Hack for Win95 ONLY
	// Since this entire function is to workaround the lack of a param
	// for PrefixMap in CreateUrlCacheContainer() another hack shouldn't
	// matter since it's only temporary
	// On Win95 need to check this entry
	// HKEY_LOCAL_MACHINE\Network\Logon
	//		UserProfiles=DWORD:00000001
	// which says if UserProfiles are turned on
	// If they are turned on we use HKEY_CURRENT_USER
	// otherwise use HKEY_LOCAL_MACHINE
	
	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist
			lpszPrefixMap[0] = '\0';
		}
		else	// key did exist so lets return it in lpszPrefixMap
		{
			// Vendor name must be unique so is it ok to assume uniqueness?
			if ( (dwResult = RegQueryValueEx(hKeyVendor, szKeyPrefixMap, 0, &ulVal,
				(LPBYTE) lpszPrefixMap, &cbPrefixMap ))
				 == ERROR_SUCCESS )
			{
			}
			else
				lpszPrefixMap[0] = '\0';
		}
	}
	else
		lpszPrefixMap[0] = '\0';

	return dwResult;
}

/************************************************************************\
*   FUNCTION: WriteCacheContainerEntry()
*
* Manually write all the registry entries that WININET CreateUrlCacheContainer
* would normally write.
*
* This f() is used when IE4 WININET is not yet installed.
*
\************************************************************************/

DWORD WriteCacheContainerEntry(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
     IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
     IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,	        // New - part of WRAPPER
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,			// Not used by WININET currently
     IN DWORD dwOptions
	 )

{
    const static char *szCachePrefix    = "CachePrefix";
    const static char *szKeyPrefixMap   = "PrefixMap";
    const static char *szKeyVolumeLabel	= "VolumeLabel";
    const static char *szKeyVolumeTitle	= "VolumeTitle";
    const static char *szCacheLimit     = "CacheLimit";
    const static char *szCacheOptions   = "CacheOptions";
    const static char *szCachePath      = "CachePath";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";
    
	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	DWORD	dwResult = ERROR_SUCCESS;
	CHAR lpszCachePath[MAX_PATH];

	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		BYTE bBuf[4096];
		LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) bBuf;
		DWORD cbCEI = sizeof(bBuf);

		if (!lpfnGetUrlCacheConfigInfo)
		{
			HINSTANCE	hDll;

			hDll = LoadLibrary("WININET.DLL");

			if (hDll != NULL)
			{
				lpfnGetUrlCacheConfigInfo = (LPFNGETURLCACHECONFIGINFO)GetProcAddress(hDll, "GetUrlCacheConfigInfoA");

				if (!lpfnGetUrlCacheConfigInfo)
				{
					FreeLibrary(hDll);
					dwResult = -1;		// Indicate failure
				}
			}
		}

		if (lpfnGetUrlCacheConfigInfo)
		{
			// Figure out local user cache location directory
			// Note: Need to use IE3 backward compatible flag
			// IE3:   CACHE_CONFIG_DISK_CACHE_PATHS_FC
			// IE4:   CACHE_CONFIG_CONTENT_PATHS_FC
			if (lpfnGetUrlCacheConfigInfo(lpCCI, &cbCEI, CACHE_CONFIG_DISK_CACHE_PATHS_FC))
			{
				// Now need to parse the returned CachePath to remove trailing 'cache1\'
				// "c:\windows\Temporary Internet Files\cache1\"
				// look for backslash starting from end of string
				int i = lstrlen(lpCCI->CachePaths[0].CachePath);

				while( (lpCCI->CachePaths[0].CachePath[i] != '\\') && (i >= 0) )
					   i--;

				if (lpCCI->CachePaths[0].CachePath[i] == '\\')
					lpCCI->CachePaths[0].CachePath[i+1] = '\0';		// Leave '\' intact for later strcat

				if (lpCCI->dwNumCachePaths > 0)
					lstrcpy(lpszCachePath, lpCCI->CachePaths[0].CachePath);

				// Add Cache Container Unique Vendor Name to CachePath
				// All container content will be stored in this location
				if(lstrlen(lpszCachePath) + lstrlen(lpszUniqueVendorName) >= sizeof(lpszCachePath) / sizeof(lpszCachePath[0]))
				{
					return FALSE;
				}

				lstrcat(lpszCachePath, lpszUniqueVendorName);
			}
		}
		else
		{
			// No IE3 or IE4 WININET present
			// so synthesize CachePath from GetWinDir() + "Temporary Internet Files"

			if ( GetWindowsDirectory(lpszCachePath, MAX_PATH) > 0)
			{
				if ('\\' == lpszCachePath[lstrlen(lpszCachePath)-1])
					lstrcat(lpszCachePath, _T("Temporary Internet Files"));
				else
				{
					lstrcat(lpszCachePath, _T("\\"));
					lstrcat(lpszCachePath, _T("Temporary Internet Files"));
				}
			}

		}

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist

			// Let's try to create it
			dwResult = RegCreateKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
				NULL, &hKeyVendor, &dwDisposition);

        }    
    
    }

    if (dwResult == ERROR_SUCCESS)
    {
        RegSetValueEx(hKeyVendor, szKeyPrefixMap, 0, REG_SZ,
            (CONST UCHAR *) lpszPrefixMap, lstrlen(lpszPrefixMap)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeLabel, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeLabel, lstrlen(lpszVolumeLabel)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeTitle, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeTitle, lstrlen(lpszVolumeTitle)+1);

        RegSetValueEx(hKeyVendor, szCachePrefix, 0, REG_SZ,
            (CONST UCHAR *) lpszCachePrefix, lstrlen(lpszCachePrefix)+1);

        RegSetValueEx(hKeyVendor, szCachePath, 0, REG_SZ,
            (CONST UCHAR *) lpszCachePath, lstrlen(lpszCachePath)+1);

        RegSetValueEx(hKeyVendor, szCacheLimit, 0, REG_DWORD,
            (unsigned char *)&KBCacheLimit, sizeof(DWORD));

        RegSetValueEx(hKeyVendor, szCacheOptions, 0, REG_DWORD,
            (unsigned char *)&dwOptions, sizeof(DWORD));
	
	}        
    
    
	if (dwResult != ERROR_SUCCESS)
		return (FALSE);
	else
		return (TRUE);
}

/************************************************************************\
*    FUNCTION: CacheContainer()
*
*	 Parameters:
*		dwAction - flag indicating what to do
*					CACHE_ACTION_INSTALL
*					CACHE_ACTION_REMOVE
*					CACHE_ACTION_FILL_LB
*
*		hListBox - HWND to ListBox to fill in with Container names
*
*
*		Note:
*				if dwAction == CACHE_ACTION_FILL_LB then if hListBox  
*				is NULL then return TRUE if ALL Containers installed
*				correctly or FALSE if not
*  
*		Additionally create a CDCACHE.INF at the root of the CD-ROM.
*		Typical contents:
*
*			[Add.CacheContainer]
*			<Unique Vendor Name>=<INF Section Name>
*			Encarta 97=EncartaCD
*
*			[INF Section Name]
*			VolumeLabel=<string>
*			VolumeTitle=<string>
*			CachePrefix=<string>
*			CacheRoot=<relative path on CD-ROM of data>
*			KBCacheLimit=<numerical amount in KB>
*			AutoDelete=Yes|No (default)
*			IncludeSubDirs=Yes|No (default)
*			NoDesktopInit=Yes|No (default)
*
*			[EncartaCD]
*			VolumeLabel=MSENCART97
*			VolumeTitle=Microsoft Encarta CD 97
*			CachePrefix=http://www.microsoft.com/encarta
*			CacheRoot=%EXE_ROOT%\data\http
*			KBCacheLimit=500
*			AutoDelete=Yes
*			IncludeSubDirs=Yes
*
*	NOTE: %EXE_ROOT% is a replaceable param that gets set to the
*		path this EXE was ran from, such as E: or E:\BIN
*
*
*	Calls _CreateUrlCacheContainer()
\************************************************************************/
BOOL CacheContainer(DWORD *dwTotal, DWORD *dwInstalled, DWORD dwAction, HWND hListBox)
{
    BOOL	bRet = FALSE;
    BOOL    bVolumeLabel = FALSE;
    DWORD	dwRes = 0;
	HRESULT hr = 0;
	
	int nSectionSize = 4096;	// Limit each INF section to 4K
	char szSections[4096];
	char *lpSections = (char *)szSections;

    const static char *szAddCacheContainerSection = "Add.CacheContainer";
    const static char *szKey_Name			= "Name";
    const static char *szKey_VolumeTitle	= "VolumeTitle";
    const static char *szKey_Prefix			= "CachePrefix";
    const static char *szKey_Root			= "CacheRoot";
    const static char *szKey_CacheLimit		= "KBCacheLimit";
    const static char *szKey_AutoDelete		= "AutoDelete";
    const static char *szKey_IncludeSubDirs = "IncludeSubDirs";
    const static char *szKey_NoDesktopInit	= "NoDesktopInit";
	char szDefault[12] = "*Unknown*"; // note: buffer needs to hold larger strings
	DWORD len;

	char szInf[STRING_BUFFER_SIZE];
	char szInfPath[MAX_PATH];
	char szContainerName[STRING_BUFFER_SIZE];
	char szCachePrefix[STRING_BUFFER_SIZE];
	char szCacheRoot[MAX_PATH];
	char szPrefixMap[MAX_PATH];
    char szVolumeLabel[MAX_PATH];
    char szMapDrive[4];
    char szVolumeTitle[MAX_PATH];
	char szAutoDelete[STRING_BUFFER_SIZE];
	char szIncludeSubDirs[STRING_BUFFER_SIZE];
	char szNoDesktopInit[STRING_BUFFER_SIZE];

	int			nDefault = 0;
	int			nCacheLimit = 0;
	BOOL		bResult;
	HANDLE		hFile;

#define SIZE_CMD_LINE   2048

    char szBuf[SIZE_CMD_LINE];  // enough for commandline

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] =
	{
#define VAR_EXE_ROOT     0       // Replace with drive+path (ex. "D:" or "D:\PATH") of this EXE
        "%EXE_ROOT%",

#define VAR_EXE_DRIVE    1       // Replace with drive (ex. "D:") of this EXE
        "%EXE_DRIVE%",

#define NUM_VARS        2
        ""
    };

	int nValBuffSize = MAX_PATH;
    char lpValBuffer[MAX_PATH];
	int nDriveBuffSize = MAX_PATH;
    char lpDriveBuffer[MAX_PATH];
    const char *szValues[NUM_VARS + 1];
    szValues[VAR_EXE_ROOT] = GetINFDir(lpValBuffer, nValBuffSize);
	szValues[VAR_EXE_DRIVE] = GetINFDrive(lpDriveBuffer, nDriveBuffSize);
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order

	CWaitCursor wait;

	// Look for INF
	//
	LoadString (g_hInst, ID_INFNAME, szInf, sizeof(szInf));
	lstrcpy(szInfPath, GetINFDir(szInfPath, sizeof(szInfPath)) );
	strcat (szInfPath, "\\");
	strcat (szInfPath, szInf);
	strcat (szInfPath, ".INF");
	hFile = CreateFile(szInfPath, GENERIC_READ, FILE_SHARE_READ, NULL,
					   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;

		// Is there a [Add.CacheContainer] section

		// BUGBUG: GetPrivateProfileSection() fails on Win95
		// Workaround for GetPrivateProfileSection() failure on Win95
		szDefault[0] = '\0';
		len = GetPrivateProfileString(szAddCacheContainerSection, NULL, szDefault,
									lpSections, nSectionSize, szInfPath);


		if (!len)
		{
			// no CD-ROM Cache Container sections in INF
			// BUGBUG: Display a message if in NON Silent mode?

			// This is case where AUTORUN.INF has no [Add.Container] section

		}
		else
		{
			// lpBuffer now has list of key strings (as in key=value)
			// final pair terminated with extra NULL
			//
			// Loop through each cache container entry
			while (*lpSections)
			{
				WORD  dResult   = 0;
                
                // Init flags for this container to map-able.
                DWORD dwOptions = INTERNET_CACHE_CONTAINER_MAP_ENABLED;	

				GetPrivateProfileString(szAddCacheContainerSection, lpSections, szDefault,
								szContainerName, STRING_BUFFER_SIZE, szInfPath);

				if (szContainerName)
				{
					(*dwTotal)++;	// Keep track of how many cache containers in INF

					// Build PrefixMap
					//
					// BUGBUG: Default to root?
					lstrcpy(szDefault, "%EXE_ROOT%");
					// Get the PrefixMap entry
					dwRes = GetPrivateProfileString(szContainerName, szKey_Root, szDefault,
											szCacheRoot, MAX_PATH, szInfPath);

					// Replace any %parameters%
					// S_OK indicates that something was expanded
					if (S_OK == (hr = ExpandEntry(szCacheRoot, szBuf, SIZE_CMD_LINE, szVars, szValues)))
						lstrcpyn(szPrefixMap, szBuf, sizeof(szPrefixMap));
					else
						lstrcpy(szPrefixMap, szCacheRoot);


                    memcpy(szMapDrive, szPrefixMap, 2);
                    memcpy(szMapDrive + 2, "\\", sizeof("\\"));
                    if (GetVolumeInformation(szMapDrive, szVolumeLabel, MAX_PATH, 
                             NULL, NULL, NULL, NULL, 0))
                    {
                        bVolumeLabel = TRUE;
                    }
                    else
                    {
                        *szVolumeLabel = '\0';
                        bVolumeLabel = FALSE;
                    }

					lstrcpy(szDefault, "");
					GetPrivateProfileString(szContainerName, szKey_Prefix, szDefault,
											szCachePrefix, STRING_BUFFER_SIZE, szInfPath);

                    lstrcpy(szDefault, "");
					GetPrivateProfileString(szContainerName, szKey_VolumeTitle, szDefault,
											szVolumeTitle, STRING_BUFFER_SIZE, szInfPath);
 
					// Now trim off trailing backslash '\' from szCachePrefix
					// workaround for #43375
					int i = lstrlen(szCachePrefix);

					if (i > 0)
						if ('\\' == szCachePrefix[i - 1])
							szCachePrefix[i - 1] = '\0';

					// BUGBUG: Should create custom Profile f() to
					// read/return DWORD value rather than int
					nDefault = 500;	// 500K Cache Limit
					nCacheLimit = GetPrivateProfileInt(szContainerName, szKey_CacheLimit,
													   nDefault, szInfPath);

					dResult = GetProfileBooleanWord(szContainerName, szKey_AutoDelete, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is No/False for AutoDelete
						case FALSE:
							break;
						case TRUE:
							dwOptions |= INTERNET_CACHE_CONTAINER_AUTODELETE;
							break;
					}

					dResult = GetProfileBooleanWord(szContainerName, szKey_IncludeSubDirs, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is Yes/True for IncludeSubDirs
						case FALSE:
							dwOptions |= INTERNET_CACHE_CONTAINER_NOSUBDIRS;	// Don't include subdirs in cacheview
							break;
						case TRUE:
							break;
					}

					dResult = GetProfileBooleanWord(szContainerName, szKey_NoDesktopInit, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is No/False for NoDesktopInit
						case FALSE:
							break;
						case TRUE:
							dwOptions |= INTERNET_CACHE_CONTAINER_NODESKTOPINIT;
							break;
					}


					switch (dwAction)
					{
					case CACHE_ACTION_INSTALL:
						// Call CreateUrlCacheContainer WRAPPER
                        if (bVolumeLabel)
                        {
                            bRet = _CreateUrlCacheContainer(lpSections, szCachePrefix, szPrefixMap, 
                                                            szVolumeTitle, szVolumeLabel, nCacheLimit, 0, dwOptions);
                        }
                        else
                        {
                            bRet = FALSE;
                        }

						break;
					case CACHE_ACTION_REMOVE:
						if (!WininetLoaded())
							return FALSE;

						bRet = lpfnDeleteUrlCacheContainer(lpSections, dwOptions);
						break;
					case CACHE_ACTION_FILL_LB:
						// Fill listbox hListBox

						if (hListBox)
						{
							SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)lpSections);
						}
						else
						{
							// hListBox is NULL
							//
							//	if dwAction == CACHE_ACTION_FILL_LB then if hListBox  
							//	is NULL then return TRUE if ALL Containers installed
							//	correctly or FALSE if not
							//

							if (UrlCacheContainerExists(lpSections, szCachePrefix, szPrefixMap))
								bRet = TRUE;
							else
								return FALSE;	// One container is not installed so bail out
						}

						break;
					case CACHE_ACTION_MAKE_REG_ENTRIES:
                        if (bVolumeLabel)
                        {
						    bRet = WriteCacheContainerEntry(lpSections, szCachePrefix, szPrefixMap, szVolumeTitle, 
                                                            szVolumeLabel, nCacheLimit, 0, dwOptions);
                        }
                        else
                            bRet = FALSE;


						break;
					}

					if (bRet)
						(*dwInstalled)++;	// Keep track of successful installs
				}
				//else empty section entry, ignore and move to next
				
				// Get Next Section name
				while ( (*(lpSections++) != '\0')  );

			}
		}
	}
	else
	{
		// Couldn't find INF file
		// BUGBUG: need to do anything else here?
	}

	return bRet;
}

/************************************************************************\
*    FUNCTION: ExpandEntry()
*
* Borrowed from urlmon\download\hooks.cxx
\************************************************************************/
HRESULT	ExpandEntry(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
	//Assert(szSrc);

    HRESULT hr = S_FALSE;

    LPSTR pchSrc = szSrc;     // start parsing at begining of cmdline

    LPSTR pchOut = szBuf;       // set at begin of out buffer
    DWORD cbLen = 0;

    while (*pchSrc) {

        // look for match of any of our env vars
        if (*pchSrc == '%') {

            HRESULT hr1 = ExpandVar(pchSrc, pchOut, cbLen, // all passed by ref!
                cbBuffer, szVars, szValues);  

            if (FAILED(hr1)) {
                hr = hr1;
                goto Exit;
            }


            if (hr1 == S_OK) {    // expand var expanded this
                hr = hr1;
                continue;
            }
        }
            
        // copy till the next % or nul
        if ((cbLen + 1) < cbBuffer) {

            *pchOut++ = *pchSrc++;
            cbLen++;

        } else {

            // out of buffer space
            *pchOut = '\0'; // term
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;

        }


    }

    *pchOut = '\0'; // term


Exit:

    return hr;

}

/************************************************************************\
*    FUNCTION: ExpandVar()
*
* Borrowed from urlmon\download\hooks.cxx
\************************************************************************/
HRESULT ExpandVar(
    LPSTR& pchSrc,          // passed by ref!
    LPSTR& pchOut,          // passed by ref!
    DWORD& cbLen,           // passed by ref!
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    HRESULT hr = S_FALSE;
    int cbvar = 0;

    //Assert (*pchSrc == '%');

    for (int i=0; szVars[i] && (cbvar = lstrlen(szVars[i])) ; i++) { // for each variable

        int cbneed = 0;

        if ( (szValues[i] == NULL) || !(cbneed = lstrlen(szValues[i])))
            continue;

        cbneed++;   // add for nul

        if (0 == strncmp(szVars[i], pchSrc, cbvar)) {

            // found something we can expand

                if ((cbLen + cbneed) >= cbBuffer) {
                    // out of buffer space
                    *pchOut = '\0'; // term
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                lstrcpy(pchOut, szValues[i]);
                cbLen += (cbneed -1); //don't count the nul

                pchSrc += cbvar;        // skip past the var in pchSrc
                pchOut += (cbneed -1);  // skip past dir in pchOut

                hr = S_OK;
                goto Exit;

        }
    }

Exit:

    return hr;
    
}

// Return drive+path without trailing backslash
LPSTR GetINFDir(LPSTR lpBuffer, int nBuffSize)
{
	// Figure out what directory we've been started in
	GetModuleFileName(g_hInst, lpBuffer, nBuffSize);

	// Now trim off trailing backslash '\' if any
	int i = lstrlen(lpBuffer);

	if (i > 0)
		if ('\\' == lpBuffer[i - 1])
			lpBuffer[i - 1] = '\0';

	// Get rid of executable name
	i = lstrlen(lpBuffer);

	while( (lpBuffer[i] != '\\') && (i >= 0) )
		   i--;

	if (lpBuffer[i] == '\\')
		lpBuffer[i] = '\0';


	return lpBuffer;
}


// Return drive without trailing backslash
LPSTR GetINFDrive(LPSTR lpBuffer, int nBuffSize)
{
	// Figure out what directory we've been started in
	GetModuleFileName(g_hInst, lpBuffer, nBuffSize);

	if (!lpBuffer)
		return NULL;

	LPSTR lpSaveBuffer = lpBuffer;

	// Now trim off everything after first colon ':'
	if (':' == lpBuffer[1])
		lpBuffer[2] = '\0';
	else
	{
		// assumption that lpBuffer of form "D:\path" failed
		// so actually parse it
		// #48022 robgil - add check for end of lpBuffer string
		while (*lpBuffer != '\0' && *lpBuffer != ':')
			lpBuffer++;

		if (':' == *lpBuffer)
			*(lpBuffer + 1) = '\0';
		else
		{
			// #48022
			// Need to return \\server\share
			// for Drive when a UNC path
			lpBuffer = lpSaveBuffer;

			if ('\\' == lpBuffer[0] && '\\' == lpBuffer[1])
			{
				lpBuffer += 2;	// move past leading '\\'

				while (*lpBuffer != '\0' && *lpBuffer != '\\')
					lpBuffer++;

				if ('\\' == *lpBuffer)
				{
					lpBuffer++;

					while (*lpBuffer != '\0' && *lpBuffer != '\\')
						lpBuffer++;

					if ('\\' == *lpBuffer)
						*lpBuffer = '\0';
				}
			}

		}

	}

	return lpSaveBuffer;
}


//------------------------------------------------------------------------
//  BOOL GetProfileBooleanWord
//
//  Description:
//     Retrieves the value associated with szKeyName and
//     evaluates to a TRUE or FALSE.  If a value is not
//     associated with the key, -1 is returned.
//
//  Parameters:
//     LPSTR szKeyName
//        pointer to key name
//
//  Return Value:
//     WORD
//        -1, if a setting for the given key does not exist
//        TRUE, if value evaluates to a "positive" or "true"
//        FALSE, otherwise
//
//------------------------------------------------------------------------

WORD GetProfileBooleanWord
(
	LPCTSTR			szIniSection,
	LPCTSTR         szKeyName,
    LPCTSTR			szIniFile
)
{
	TCHAR	szTemp[10];

	GetPrivateProfileString( szIniSection,
							 szKeyName, _T(""), szTemp, sizeof( szTemp ),
                             szIniFile ) ;

	if (0 == lstrlen( szTemp ))
		return ( (WORD) -1 ) ;

	if ((0 == lstrcmpi( szTemp, gszIniValTrue )) ||
	   (0 == lstrcmpi( szTemp, gszIniValYes )) ||
	   (0 == lstrcmpi( szTemp, gszIniValOn )))
		return ( TRUE ) ;

	// Try and convert something numeric
	if (0 != _ttoi(szTemp))		// atoi (via tchar.h)
		return ( TRUE );

	return ( FALSE ) ;

} // end of GetProfileBooleanWord()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\urlcache\perf\fndquota\fndquota.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    fndquota.c

Abstract:

    Test program to fill you cache to just under your quota.

Author:

    Vince Roggero (vincentr)  27-Jun-1997


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <wininet.h>
#include <winineti.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
#define URL_NAME_SIZE   (16 + 1)

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define CACHE_DATA_BUFFER_SIZE 1024

#define CACHE_HEADER_INFO_SIZE  2048
#define CACHE_HEADER_INFO_SIZE_NORMAL_MAX   256
#define CACHE_HEADER_INFO_SIZE_BIG_MAX      512

//=================================================================================
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];
BYTE GlobalCacheDataBuffer[CACHE_DATA_BUFFER_SIZE];
BYTE GlobalCacheHeaderInfo[CACHE_HEADER_INFO_SIZE];
DWORD g_dwFileSize = 16384;
DWORD g_dwNumEntries = 1;
DWORD g_dwInitEntries = 0;
BOOL g_bVerbose = FALSE;

//=================================================================================
DWORD SetFileSizeByName(LPCTSTR FileName, DWORD FileSize)
/*++

Routine Description:
    Set the size of the specified file.

Arguments:
    FileName : full path name of the file whose size is asked for.
    FileSize : new size of the file.

Return Value:
    Windows Error Code.

--*/
{
    HANDLE FileHandle;
    DWORD FilePointer;
    DWORD Error = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    DWORD dwCreate;
    BOOL BoolError;

    //
    // get the size of the file being cached.
    //
    dwFlags = 0;
    dwCreate = CREATE_ALWAYS;

    FileHandle = CreateFile(
                    FileName,
                    GENERIC_WRITE,
                    0,   //FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreate,
                    FILE_ATTRIBUTE_NORMAL | dwFlags,
                    NULL );

    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( GetLastError() );
    }

    FilePointer = SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN );

    if( FilePointer != 0xFFFFFFFF )
    {
        if(!SetEndOfFile( FileHandle ))
            Error = GetLastError();
    }
    else
    {
        Error = GetLastError();
    }

    CloseHandle( FileHandle );
    return( Error );
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}


//=================================================================================
DWORD EnumUrlCacheEntries(DWORD *pdwTotal)
{
    DWORD BufferSize, dwSmall=0, dwLarge=0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD dwTotal = 0;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    BOOL bRC;
    char Str[256];
 
    //
    // start enum.
    //
    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx (
        NULL,         // search pattern
        0,            // flags
        0xffffffff,   // filter
        0,            // groupid
        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
        &BufferSize,
        NULL,
        NULL,
        NULL
    );

    if( EnumHandle == NULL ) 
    {
        return( GetLastError() );
    }

    ++dwTotal;

    //
    // get more entries.
    //
    for ( ;; )
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;
    }

    *pdwTotal = dwTotal;
    
    FindCloseUrlCache(EnumHandle);

    return(ERROR_SUCCESS);
}

//=================================================================================
DWORD ProcessSimulateCache(DWORD dwNumUrls)
{
    static DWORD dwUrlNum = 0;
    DWORD Error;
    DWORD i, j;
    CHAR UrlName[ URL_NAME_SIZE ];
    TCHAR LocalFileName[MAX_PATH];
    DWORD FileSize;
    LONGLONG ExpireTime;
    FILETIME LastModTime;
    CHAR TimeBuffer[MAX_PATH];
    DWORD UrlLife;
    DWORD BufferSize;
    DWORD CacheHeaderInfoSize;

    for( i = dwUrlNum; i < (dwUrlNum + dwNumUrls); i++ ) 
    {
        //
        // make a new url name.
        //
        sprintf(UrlName, "http://serv/URL%ld", i);

        //
        // create url file.
        //
        if( !CreateUrlCacheEntry(UrlName, 0, "tmp", LocalFileName, 0 ) ) 
        {
            Error = GetLastError();
            printf( "CreateUrlFile call failed, %ld.\n", Error );
            return( Error );
        }

        //
        // set file size.
        //
        Error = SetFileSizeByName(LocalFileName, g_dwFileSize);
        if( Error != ERROR_SUCCESS ) 
        {
            printf( "SetFileSizeByName call failed, %ld.\n", Error );
            return( Error );
        }

        UrlLife = rand() % 48;

        ExpireTime = (LONGLONG)UrlLife * (LONGLONG)36000000000;
        // in 100 of nano seconds.

        LastModTime = GetGmtTime();
        ExpireTime += *((LONGLONG *)&LastModTime);

        CacheHeaderInfoSize = CACHE_HEADER_INFO_SIZE_NORMAL_MAX;

        //
        // cache this file.
        //
        if( !CommitUrlCacheEntryA(
                        UrlName,
                        LocalFileName,
                        *((FILETIME *)&ExpireTime),
                        LastModTime,
                        NORMAL_CACHE_ENTRY,
                        (LPBYTE)GlobalCacheHeaderInfo,
                        CacheHeaderInfoSize,
                        TEXT("tst"),
                        0 ) ) {
            Error = GetLastError();
            printf( "CreateUrlFile call failed, %ld.\n", Error );
            return( Error );
        }

    }
    dwUrlNum = i;   // Save last for next call

    return( ERROR_SUCCESS );
}

//---------------------------------------------------------------------
void Display_Usage(const char *szApp)
{
    printf("Usage: %s [Options]\r\n\n", szApp);
    printf("Options:\r\n");
    printf("\t-f#   File size of cache entries in bytes.\r\n");
    printf("\t-i#   Initial number of entries to create\r\n");
    printf("\t-n#   Number of entries to create before checking total.\r\n");
    printf("\t-v    Turn on verbose output.\r\n");
}

//---------------------------------------------------------------------
BOOL ParseCommandLine(int argcIn, char *argvIn[])
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;

    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'f':
                g_dwFileSize = atoi(&argv[0][2]);
                break;
            case 'i':
                g_dwInitEntries= atoi(&argv[