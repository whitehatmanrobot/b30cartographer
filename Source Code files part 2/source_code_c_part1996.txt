he data from acceleration
            LimitedPresence read = new LimitedPresence();
            read.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(read);

            // validate the data
            Assert.IsTrue(read.OwnerID == user.UserId, string.Format("OwnerID did not match userId: {0} {1}", read.OwnerID, user.UserId));
            Assert.IsTrue(read.OwnerID == record.OwnerID, string.Format("OwnerID did not match OwnerID: {0} {1}", read.OwnerID, record.OwnerID));
            Assert.IsTrue(read.sGamertag == record.sGamertag, string.Format("Gamertag did not match: {0} {1}", read.sGamertag, record.sGamertag));
            Assert.IsTrue(read.dwState == record.dwState, string.Format("State did not match: {0} {1}", read.dwState, record.dwState));
            Assert.IsTrue(read.dwState == dwState, string.Format("State should be online: {0} {1}", read.dwState, dwState));
            Assert.IsTrue(read.dwTitleID == record.dwTitleID, string.Format("TitleID did not match: {0} {1}", read.dwTitleID, record.dwTitleID));
            Assert.IsTrue(read.dwTitleID == dwTitleID, string.Format("TitleID did not match: {0} {1}", read.dwTitleID, dwTitleID));
        }

        /// <summary>
        /// Basic BVT Test creates limited presence for a single user
        /// </summary>
        [TestCase]
        public void P_No_Change()
        {
            PNUser user;
            LimitedPresence write;
            PresenceRecord record;
            InitTest(out user, out write, out record);

            // change the last seen time
            Thread.Sleep(5000);
            record.SetState(record.dwTitleID, record.dwState, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            LimitedPresence read = new LimitedPresence();
            read.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(read);

            // validate the data
            Assert.IsTrue(read.OwnerID == user.UserId, string.Format("OwnerID did not match userId: {0} {1}", read.OwnerID, user.UserId));
            Assert.IsTrue(read.OwnerID == write.OwnerID, string.Format("OwnerID did not match OwnerID: {0} {1}", read.OwnerID, write.OwnerID));
            Assert.IsTrue(read.sGamertag == write.sGamertag, string.Format("Gamertag did not match: {0} {1}", read.sGamertag, write.sGamertag));
            Assert.IsTrue(read.dwState == write.dwState, string.Format("State did not match: {0} {1}", read.dwState, write.dwState));
            Assert.IsTrue(read.dwTitleID == write.dwTitleID, string.Format("TitleID did not match: {0} {1}", read.dwTitleID, write.dwTitleID));
            Assert.IsTrue(read.dwTitleID == record.dwTitleID, string.Format("TitleID did not match presence record: {0} {1}", read.dwTitleID, record.dwTitleID));
            Assert.IsTrue(read.mtLastSeen == write.mtLastSeen, string.Format("Last Seen did not match: {0} {1}", read.mtLastSeen, write.mtLastSeen));
            Assert.IsTrue(read.mtLastSeen != MsgDefs.DateTimeToMsgTime(record.dtLastSeen), string.Format("Last Seen should not match: {0} {1}", read.mtLastSeen, write.mtLastSeen));
        }

        /// <summary>
        /// Basic BVT Test creates limited presence for a single user
        /// </summary>
        [TestCase]
        public void P_TitleId_Change()
        {
            PNUser user;
            LimitedPresence write;
            PresenceRecord record;
            InitTest(out user, out write, out record);

            // change the titleID
            record.SetState(record.dwTitleID + 1, record.dwState, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            LimitedPresence read = new LimitedPresence();
            read.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(read);

            // validate the data
            Assert.IsTrue(read.OwnerID == user.UserId, string.Format("OwnerID did not match userId: {0} {1}", read.OwnerID, user.UserId));
            Assert.IsTrue(read.OwnerID == record.OwnerID, string.Format("OwnerID did not match OwnerID: {0} {1}", read.OwnerID, record.OwnerID));
            Assert.IsTrue(read.sGamertag == record.sGamertag, string.Format("Gamertag did not match: {0} {1}", read.sGamertag, record.sGamertag));
            Assert.IsTrue(read.dwState == record.dwState, string.Format("State did not match: {0} {1}", read.dwState, record.dwState));
            Assert.IsTrue(read.dwTitleID == record.dwTitleID, string.Format("TitleID did not match presence record: {0} {1}", read.dwTitleID, record.dwTitleID));
        }

        /// <summary>
        /// Basic BVT Test creates limited presence for a single user
        /// </summary>
        [TestCase]
        public void P_LimitedPresenceState_Change_Offline()
        {
            PNUser user;
            LimitedPresence write;
            PresenceRecord record;
            InitTest(out user, out write, out record);

            // change the state to offline
            record.SetState(record.dwTitleID, 0, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            LimitedPresence read = new LimitedPresence();
            read.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(read);

            // validate the data
            Assert.IsTrue(read.OwnerID == user.UserId, string.Format("OwnerID did not match userId: {0} {1}", read.OwnerID, user.UserId));
            Assert.IsTrue(read.OwnerID == record.OwnerID, string.Format("OwnerID did not match OwnerID: {0} {1}", read.OwnerID, record.OwnerID));
            Assert.IsTrue(read.sGamertag == record.sGamertag, string.Format("Gamertag did not match: {0} {1}", read.sGamertag, record.sGamertag));
            Assert.IsTrue(read.dwState == record.dwState, string.Format("State did not match: {0} {1}", read.dwState, record.dwState));
            Assert.IsTrue(read.dwState == 0, string.Format("State should be offline: {0} 0", read.dwState));
            Assert.IsTrue(read.dwTitleID == record.dwTitleID, string.Format("TitleID did not match: {0} {1}", read.dwTitleID, record.dwTitleID));
        }

        /// <summary>
        /// Basic BVT Test creates limited presence for a single user
        /// </summary>
        [TestCase]
        public void P_LimitedPresenceState_Change_Cloaked()
        {
            PNUser user;
            LimitedPresence write;
            PresenceRecord record;
            InitTest(out user, out write, out record);

            // change the state to cloaked
            record.SetState(record.dwTitleID, record.dwState & PresDefs.P_STATE_FLAG_CLOAKED, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            LimitedPresence read = new LimitedPresence();
            read.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(read);

            // validate the data
            Assert.IsTrue(read.OwnerID == user.UserId, string.Format("OwnerID did not match userId: {0} {1}", read.OwnerID, user.UserId));
            Assert.IsTrue(read.OwnerID == record.OwnerID, string.Format("OwnerID did not match OwnerID: {0} {1}", read.OwnerID, record.OwnerID));
            Assert.IsTrue(read.sGamertag == record.sGamertag, string.Format("Gamertag did not match: {0} {1}", read.sGamertag, record.sGamertag));
            Assert.IsTrue(read.dwState == 0, string.Format("State should be offline: {0} 0", read.dwState));
            Assert.IsTrue(read.dwTitleID == record.dwTitleID, string.Format("TitleID did not match presence record: {0} {1}", read.dwTitleID, record.dwTitleID));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\test\stf\SocialCacheAPITests.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.SocialQuery;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;

using xonline.common.community;
using xonline.common.community.socialquery;
using xonline.common.community.socialquery.protocol;
using xonline.common.config;
using xonline.common.protocol.socialquery;

namespace SocialCacheTest
{
    //Helper object for creation of a social network.
    public class FriendCreator
    {
        private static FriendsCommon _fc;

        public FriendCreator()
        {
            _fc = new FriendsCommon();
        }

        // Version of CreateUser that doesn't need friend xuids returned
        public PNUser CreateUser(int numFriends)
        {
            List<ulong> friendXuids;
            return(CreateUser(numFriends, false, out friendXuids));
        }

        public PNUser CreateUser(int numFriends, bool bPending, out List<ulong> friendXuids)
        {
            friendXuids = new List<ulong>();

            // Create some clean users who are friends
            PNUser a = _fc.CreateXenonUser(false);
            if(numFriends > 0) 
            {
                PNUser[] friends = _fc.CreateXenonUsers((uint)numFriends, false);
                if(bPending) 
                {
                    MakePendingFriends(a, friends);
                } else {
                    MakeFriends(a, friends);
                }

                for(int i = 0; i < numFriends; i++) 
                {
                    friendXuids.Add(friends[i].UserId);
                }
            }

            return a;
        }

        public void MakePendingFriends(PNUser a, PNUser[] list)
        {
            foreach (PNUser b in list)
            {
                FriendsListUtil.Add(a.UserId, b.UserId, a.Name, b.Name);
            }
        }

        public void MakeFriends(PNUser a, PNUser[] list)
        {
            foreach (PNUser b in list)
            {
                FriendsListUtil.Add(a.UserId, b.UserId, a.Name, b.Name);
                FriendsListUtil.Accept(b.UserId, a.UserId);
            }
        }

        public void MakeFriends(PNUser a, PNUser b)
        {
            MakeFriends(a, new PNUser[] { b });
        }

    }

    [Owner("douga"), TestFrequency("Daily"), ServerTestFramework.Description("Social Cache Server")]
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class SocialCacheAPIUnit : SocialCacheTestBaseGroup
    {
        static int totalFailures = 0;

        [TestCase]
        public void SocialCacheINH_BasicHealthCheck()
        {
            HealthCheckFD healthCheckProcessor = new HealthCheckFD(SocialCacheProxy.Instance);

            Assert.IsTrue(healthCheckProcessor.Failures == 0, String.Format("Number of INH failures = {0}.", healthCheckProcessor.Failures));            
        }

        public static void ThreadProc()
        {
            HealthCheckFD healthCheckProcessor = new HealthCheckFD(SocialCacheProxy.Instance);


            uint failures = healthCheckProcessor.Failures;

            Interlocked.Add(ref totalFailures, (int)failures);
        }

        [TestCase]
        public void SocialCacheINH_MultithreadedHealthCheck()
        {
            const int NumThreads = 100;

            totalFailures = 0;

            Thread[] healthCheckThreads = new Thread[NumThreads];

            for (int i = 0; i < NumThreads; i++)
            {
                healthCheckThreads[i] = new Thread(new ThreadStart(ThreadProc));
                healthCheckThreads[i].Start();
            }

            for (int i = 0; i < NumThreads; i++)
            {
                healthCheckThreads[i].Join(); // block until the threads complete            
            }

            Assert.IsTrue(totalFailures == 0, String.Format("Number of INH failures = {0}.", totalFailures));
        }

        [TestCase]
        public void GetFriendsINH()
        {
            string sFailure = "GetFriendsINH API test failed!! ";

            FriendCreator network = new FriendCreator();

            const int NumFriends = 10;
            const int PageSize = 4;     // really small... but helps test paging since its < NumFriends

            ulong xuid = network.CreateUser(NumFriends).UserId;

            GetFriendsINHRequest request = new GetFriendsINHRequest();
            request.data = new GetFriendsXrlRequest();
            request.data.RequestorXuid = xuid;
            request.data.OwnerXuid  = xuid;
            request.data.SortType = GetFriendSortType.Gamertag;
            request.data.PagingInfo = new PagingInfo();
            request.data.PagingInfo.PageSize = PageSize;
            request.data.PagingInfo.PageStart = 0;
            // request.data.PagingInfo.FocusXuid is not used yet...

            // open a connection to the server

            ErrorReply reply;
            uint hr;

            hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsINHRequest query failed for page 1. hr = {0}", hr));
            GetFriendsINHReply page1 = reply as GetFriendsINHReply;

            Assert.IsTrue(page1 != null, sFailure);
            Assert.IsTrue(page1.Friends.Length == PageSize, String.Format("{0} Expected {1} friends back but received only {2}", sFailure, PageSize, page1.Friends.Length));
            Assert.IsTrue(page1.PageStartIndex == request.data.PagingInfo.PageStart, String.Format("{0} Expected {1} as the first friend index but got {2}", sFailure, request.data.PagingInfo.PageStart, page1.PageStartIndex));
            Assert.IsTrue(page1.TotalNumUsers == NumFriends, String.Format("{0} Expected {1} for total number of friends by only got {2}", sFailure, NumFriends, page1.TotalNumUsers));

            request.data.PagingInfo.PageStart += PageSize;  // ask for "Page 2"

            hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsINHRequest query failed for page 1. hr = {0}", hr));
            GetFriendsINHReply page2 = reply as GetFriendsINHReply;

            // The 2nd page should still be "full"
            Assert.IsTrue(page2 != null, sFailure);
            Assert.IsTrue(page2.Friends.Length == PageSize, String.Format("{0} Expected {1} friends back but received only {2}", sFailure, PageSize, page2.Friends.Length));
            Assert.IsTrue(page2.PageStartIndex == request.data.PagingInfo.PageStart, String.Format("{0} Expected {1} as the first friend index but got {2}", sFailure, request.data.PagingInfo.PageStart, page2.PageStartIndex));
            Assert.IsTrue(page2.TotalNumUsers == NumFriends, String.Format("{0} Expected {1} for total number of friends by only got {2}", sFailure, NumFriends, page2.TotalNumUsers));
            Assert.IsTrue(page1.Friends[0].Xuid != page2.Friends[0].Xuid, "Different pages have the same page results but should not!"); // verify the page results are different

            request.data.PagingInfo.PageStart += PageSize;  // ask for "Page 3"

            hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsINHRequest query failed for page 1. hr = {0}", hr));
            GetFriendsINHReply page3 = reply as GetFriendsINHReply;

            // The 3rd page should not be "full" (but should still return results)
            Assert.IsTrue(page3 != null, sFailure);
            Assert.IsTrue(page3.Friends.Length > 0, sFailure);
            Assert.IsTrue(page3.PageStartIndex == request.data.PagingInfo.PageStart, String.Format("{0} Expected {1} as the first friend index but got {2}", sFailure, request.data.PagingInfo.PageStart, page3.PageStartIndex));
            Assert.IsTrue(page3.TotalNumUsers == NumFriends, String.Format("{0} Expected {1} for total number of friends by only got {2}", sFailure, NumFriends, page3.TotalNumUsers));
            Assert.IsTrue(page3.Friends.Length != PageSize, String.Format("{0} {1} friends were expected in page {2} but {3} were returned!",
                            sFailure,
                            NumFriends % PageSize,
                            request.data.PagingInfo.PageStart,
                            page3.Friends.Length));
        }

        [TestCase]
        public void GetFriendsOfFriendsINH()
        {
            string sFailure = "GetFriendsOfFriendsINH API test failed!! ";

            FriendCreator network = new FriendCreator();

            // Create a user with no friends initially
            PNUser user = network.CreateUser(0);
            Global.RO.Info("Created user xuid={0:X16}", user.UserId);

            // Create another user, this one with with some friends
            const int numFriends = 10;
            List<ulong> fofXuids;
            PNUser friend = network.CreateUser(numFriends, false, out fofXuids); 
            Global.RO.Info("Created friend xuid={0:X16}", friend.UserId);
            foreach(ulong fofx in fofXuids) {
                Global.RO.Info("[{0:X16}] Friend of friend xuid={1:X16}", friend.UserId, fofx);
            }
            
            // Make the first user friends with the user with friends
            network.MakeFriends(user, friend);

            // Setup the request
            GetFriendsINHRequest request = new GetFriendsINHRequest();
            request.data                 = new GetFriendsXrlRequest();
            request.data.RequestorXuid   = user.UserId;
            request.data.OwnerXuid       = friend.UserId;
            request.data.SortType        = GetFriendSortType.OnlineStatus;
            request.data.PagingInfo      = new PagingInfo();
            request.data.PagingInfo.PageSize = 20;
            request.data.PagingInfo.PageStart = 0;

            // Query the INH
            ErrorReply reply;
            uint hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsOfFriendsINH request query failed. hr = {0}", hr));
            GetFriendsINHReply fofReply = reply as GetFriendsINHReply;

            // Validate results
            Assert.IsTrue(fofReply != null, sFailure);

            for(int i = 0; i < fofReply.Friends.Length; i++) {
                Global.RO.Info("Response: FriendOfFriend[{0}]={1:X16}", i, fofReply.Friends[i].Xuid);
            }

            Assert.IsTrue(fofReply.Friends.Length == numFriends, String.Format("{0} Expected {1} friends back but received {2}", sFailure, numFriends, fofReply.Friends.Length));
            Assert.IsTrue(fofReply.TotalNumUsers == numFriends, String.Format("{0} Expected {1} for total number of friends but got {2}", sFailure, numFriends, fofReply.TotalNumUsers));

            // Make sure the returned list contains the expected xuids
            for(int i = 0; i < fofReply.Friends.Length; i++) {
                bool bInList = fofXuids.Contains(fofReply.Friends[i].Xuid);
                Assert.IsTrue(bInList, String.Format("{0} Friend xuid {1:X16} was unexpected", sFailure, fofReply.Friends[i].Xuid));
            }            
        }

        [TestCase]
        public void GetFriendsOfFriendsINHNoPendingFriends()
        {
            string sFailure = "GetFriendsOfFriendsNoPendingINH API test failed!! ";

            FriendCreator network = new FriendCreator();

            // Create a user with no friends initially
            PNUser user = network.CreateUser(0);
            Global.RO.Info("Created user xuid={0:X16}", user.UserId);

            // Create another user, this one with with some pending friends
            const int numFriends = 10;
            List<ulong> fofXuids;
            PNUser friend = network.CreateUser(numFriends, true, out fofXuids); 
            Global.RO.Info("Created friend xuid={0:X16}", friend.UserId);
            foreach(ulong fofx in fofXuids) {
                Global.RO.Info("[{0:X16}] Friend of friend xuid={1:X16}", friend.UserId, fofx);
            }
            
            // Make the first user friends with the user with friends
            network.MakeFriends(user, friend);

            // Setup the request
            GetFriendsINHRequest request = new GetFriendsINHRequest();
            request.data                 = new GetFriendsXrlRequest();
            request.data.RequestorXuid   = user.UserId;
            request.data.OwnerXuid       = friend.UserId;
            request.data.SortType        = GetFriendSortType.OnlineStatus;
            request.data.PagingInfo      = new PagingInfo();
            request.data.PagingInfo.PageSize = 20;
            request.data.PagingInfo.PageStart = 0;

            // Query the INH
            ErrorReply reply;
            uint hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsOfFriendsINH request query failed. hr = {0}", hr));
            GetFriendsINHReply fofReply = reply as GetFriendsINHReply;

            // Validate results
            Assert.IsTrue(fofReply != null, sFailure);

            for(int i = 0; i < fofReply.Friends.Length; i++) {
                Global.RO.Info("Response: FriendOfFriend[{0}]={1:X16}", i, fofReply.Friends[i].Xuid);
            }

            // No friends should come back since they're all pending
            Assert.IsTrue(fofReply.Friends.Length == 0, String.Format("{0} Expected 0 friend back but received {1}", sFailure, fofReply.Friends.Length));
            Assert.IsTrue(fofReply.TotalNumUsers == 0, String.Format("{0} Expected 0 for total number of friends but got {1}", sFailure, fofReply.TotalNumUsers));
        }
    }

    [TestGroup]
    public class SocialCacheSampleQuery : SocialCacheTestBaseGroup
    {
        public static SocialNetworkHash networkHash = new SocialNetworkHash();	    

        public static GetFriendsINHReply ExecuteGetFriendsCall(GetFriendsXrlRequest request)
        {                        
            GetFriendsINHRequest message = new GetFriendsINHRequest();
            message.data = request;

            ErrorReply reply = null;

            //Call INH through the proxy, normally from FD.
            uint hr = SocialCacheProxy.Instance.Query(message.data.RequestorXuid, message, out reply);

            // verify the response is what we're expecting...
            if (hr == HResult.S_OK && reply != null)
            {
                return (GetFriendsINHReply) reply;
            }
            return null;
        }
                               
        public static uint ExecuteGetFriendsCallExpectingError(GetFriendsXrlRequest request)
        {            
            GetFriendsINHRequest message = new GetFriendsINHRequest();
            message.data = request;

            ErrorReply reply = null;

            //Call INH through the proxy, normally from FD.
            uint hr = SocialCacheProxy.Instance.Query(message.data.RequestorXuid, message, out reply);

            if (reply != null) {
                Global.RO.Error("Reply returned when expecting error!!");
            }
            return hr;
        }

        public static GetFriendsXrlRequest CreateDefaultGetFriendsRequest(ulong xuid)
        {
            GetFriendsXrlRequest request = new GetFriendsXrlRequest();
            request.RequestorXuid = xuid;
            request.OwnerXuid = xuid;
            request.SortType = GetFriendSortType.Gamertag;
            request.PagingInfo = new PagingInfo();
            request.PagingInfo.PageSize = 10;
            request.PagingInfo.PageStart = 0;
            request.PagingInfo.FocusXuid = xuid;
            return request;
        }

        private static void PrintReply(GetFriendsINHReply reply) {
            Global.RO.Info("Reply contains " + reply.Friends.Length);
            for (int i=0; i< reply.Friends.Length; i++) {
                Global.RO.Info(reply.Friends[i].Xuid.ToString("X"));
            }            
        }

        private static bool Verify(GetFriendsXrlRequest request, GetFriendsINHReply reply, SocialNetwork network) {
            //get all friends.
/*
  //this way uses PNUser, and doesn't seem to work.
            IDictionaryEnumerator e = network.GetPNUser(request.RequestorXuid).BuddyEnumerator;
            ArrayList friends = new ArrayList();
            while (e.MoveNext()) {
                friends.Add(network.GetPNUser((ulong) e.Key));
            }
*/
            ArrayList friends = network.GetFriends(request.RequestorXuid);
            //sort.
            if (request.SortType == GetFriendSortType.Gamertag) {
                friends.Sort(new SortByGamertag());
            }
            //page.
            int pageStart = request.PagingInfo.PageStart;
            int pageEnd = request.PagingInfo.PageSize + request.PagingInfo.PageStart;
            if (pageEnd > friends.Count) {
                pageEnd = friends.Count;
            }
            if (pageStart > friends.Count) {
                pageStart = friends.Count;
            }
            //copy out the elements into a new array.
            ArrayList pagedFriends = new ArrayList();
            for (int i=pageStart; i<pageEnd; i++) {
                pagedFriends.Add(friends[i]);
            }
            //replace the friends list with the paged one.
            friends = pagedFriends;

            if (reply.NumSqFriends != reply.Friends.Length) {
                Global.RO.Error("Reply friendsLen does not equal length of friends array!");
            }

            //compare to the answers in the reply
            if (friends.Count != reply.NumSqFriends) {
                Global.RO.Error("Number of results is incorrect.  Expected " + friends.Count + " but received " + reply.NumSqFriends);
                return false;
            }
            for (int i=0; i<friends.Count; i++) {
                ulong expected = ((PNUser) friends[i]).UserId;
                ulong received = ((SocialQueryUser)reply.Friends[i]).Xuid;
                if (expected != received) {
                    Global.RO.Error("Expecting xuid " + expected + " at location " + i + " but received " + received);
                    return false;
                }
            }
            Global.RO.Success("Friends list returned is as expected.");
            return true;
        }
        public class SortByGamertag : IComparer {
            int IComparer.Compare(Object x, Object y) {
                string nameX = ((PNUser) x).Name;
                string nameY = ((PNUser) y).Name;
                return nameX.CompareTo(nameY);
            }
        }
        public class SortByXuid : IComparer {
            int IComparer.Compare(Object x, Object y) {
                ulong puidX = ((PNUser) x).UserId;
                ulong puidY = ((PNUser) y).UserId;
                return puidX.CompareTo(puidY);
            }
        }
	
/*****************************************************************************/
/****************     TEST CASES START HERE      *****************************/
/*****************************************************************************/        

        [TestCase]
        public void Mainline()
        {
            SocialNetwork network = networkHash.Get(10, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));

            GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
            SocialQueryUser[] friends = getFriendsReply.Friends;
            PrintReply(getFriendsReply);
            Verify(request, getFriendsReply, network);
        }
        [TestCase]
        public void Mainline_Check_Entire_Network()
        {
            SocialNetwork network = networkHash.Get(10, .5, 1);

            for (int i=0; i< 10; i++) {
                GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(i));
                GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
                SocialQueryUser[] friends = getFriendsReply.Friends;
                PrintReply(getFriendsReply);
                Assert.IsTrue(Verify(request, getFriendsReply, network));
            }
        }
        [TestCase]
        public void Mainline_Check_Entire_Network_Half_Logged_In()
        {
            SocialNetwork network = networkHash.Get(10, .5, .5);

            for (int i=0; i< 10; i++) {
                GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(i));
                GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
                SocialQueryUser[] friends = getFriendsReply.Friends;
                PrintReply(getFriendsReply);
                Assert.IsTrue(Verify(request, getFriendsReply, network));
            }
        }

        [TestCase]
        public void P_Larger_Page_Size_Second_Page()
        {
            SocialNetwork network = networkHash.Get(10, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
            request.PagingInfo.PageSize = 100;
            request.PagingInfo.PageStart = 500;

            GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
            SocialQueryUser[] friends = getFriendsReply.Friends;
            PrintReply(getFriendsReply);
            Assert.IsTrue (friends.Length == 0);
        }
        [TestCase]
        public void P_Large_Page_First_Page()
        {
            SocialNetwork network = networkHash.Get(10, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
            request.PagingInfo.PageSize = 500000;
            request.PagingInfo.PageStart = 0;

            GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
            SocialQueryUser[] friends = getFriendsReply.Friends;
            PrintReply(getFriendsReply);
            Assert.IsTrue (friends.Length > 0);
        }
        [TestCase]
        public void P_Many_Pages()
        {
            SocialNetwork network = networkHash.Get(10, 1, 1);
            for (int i=0; i<5; i++) {
                GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
                request.PagingInfo.PageSize = 2;
                request.PagingInfo.PageStart = (i * 2);
                GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
                SocialQueryUser[] friends = getFriendsReply.Friends;
                Verify(request, getFriendsReply, network);
            }
        }

        //looks like this will be treated as "okay" with empty results.
        [TestCase]
        public void P_Invalid_Xuid()
        {
            SocialNetwork network = networkHash.Get(3, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest((ulong)0xffffffffffffffff);

            GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
            Assert.IsTrue (getFriendsReply.Friends.Length == 0);
        }
        [TestCase]
        public void P_Page_Size_Is_0()
        {
            SocialNetwork network = networkHash.Get(3, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
            request.PagingInfo.PageSize = 0;

            GetFriendsINHReply getFriendsReply = ExecuteGetFriendsCall(request);
            Assert.IsTrue (getFriendsReply.Friends.Length == 0);
        }

        [TestCase]
        public void N_Invalid_Sort_Type()
        {
            SocialNetwork network = networkHash.Get(3, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
            unchecked {
                request.SortType = (GetFriendSortType) (-1);
            }

            uint hr = ExecuteGetFriendsCallExpectingError(request);
            Global.RO.Info("HR returned was " + hr);
//            SocialQueryUser[] friends = getFriendsReply.Friends;
//            PrintReply(getFriendsReply);
        }

        [TestCase]
        public void N_Page_Size_Is_Neg()
        {
            SocialNetwork network = networkHash.Get(3, 1, 1);
            
            GetFriendsXrlRequest request = CreateDefaultGetFriendsRequest(network.GetXuid(0));
            request.PagingInfo.PageSize = -50;

            uint hr = ExecuteGetFriendsCallExpectingError(request);
            Global.RO.Info("HR returned was " + hr);
//            SocialQueryUser[] friends = getFriendsReply.Friends;
//            PrintReply(getFriendsReply);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\test\stf\SocialCacheTest.cs ===
using System;
using System.Xml;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.mgmt;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

[assembly: RootNode(typeof(SocialCacheTest.SocialCacheSuite))]

namespace SocialCacheTest
{
    [Owner("jeffng"), TestFrequency("Daily"), ServerTestFramework.Description("Social Cache Server")]
    public class SocialCacheSuite : TestNode
    {
        private static Report ro = new Report("UnhandledException");

        ////////////////////////////////////////////////
        // Initialize
        //
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.FUNCTIONAL)
            {
                return;
            }

            // Let the fake SG know where to send state updates
            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());
        }
    }

    public class SocialCacheTestBaseGroup : TestNode
    {
        public FriendsCommon _fc;
        protected ArrayList _alUsers;
        public SocialCacheTestBaseGroup()
            : base()
        {
        }


        [TestGroupSetup]
        public virtual void Setup()
        {
            _fc = new FriendsCommon();
            _alUsers = new ArrayList();
        }

        [TestGroupTearDown]
        public virtual void TearDown()
        {
            foreach (PNUser user in _alUsers)
            {
                user.Dispose();
            }
            _fc = null;
            _alUsers = null;
        }

        public PNUser[] CreateXenonUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreateXenonUser(alive);
            }
            return users;
        }

        public PNUser CreateXenonUser(bool alive)
        {
            PNUser user = _fc.CreateXenonUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateXenonUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreateXenonUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser[] CreatePanoramaUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreatePanoramaUser(alive);
            }
            return users;
        }

        public PNUser CreatePanoramaUser(bool alive)
        {
            PNUser user = _fc.CreatePanoramaUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreatePanoramaUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreatePanoramaUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateLinkedUser(bool alive)
        {
            PNUser user = _fc.CreateLinkedUser(alive);
            _alUsers.Add(user);
            return user;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\test\stf\SocialCachePrivacy.cs ===
using System;
using System.Threading;

using xonline.common.community.socialquery;
using xonline.common.diagnostics;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.service;
using ServerTestFramework.LiveService.Presence;
using xonline.common.protocol;
using xonline.common.community;
using xonline.common.community.socialquery.protocol;
using xonline.common.protocol.socialquery;

namespace SocialCacheTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class SocialCachePrivacyTests : SocialCacheTestBaseGroup
    {
        [TestCase]
        public void SocialCacheINH_CheckPrivacy_Legacy()
        {
            // This checks privacy through legacy APIs (GetFriendsList from presence fd)
            // This uses the same variation list that should be used by the INH tests and ensures that
            // the semantics are the same with both mechanisms.
            PNUser user;
            OnlineStatusVariation[] osvs;
            GenerateFriends(out user, out osvs);

            // retrieve the friends list
            PGetFriendsListReplyMsgData friendMsg = user.GetFriendsList(user);
            ServerTestFramework.LiveService.Presence.GetFriendsListData[] friends = friendMsg.rgFriends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(friendMsg.cdwFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friendMsg.cdwFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                ServerTestFramework.LiveService.Presence.GetFriendsListData userData = Array.Find(friends, x => x.BuddyID == osv.user.UserId);
                Assert.IsTrue(userData != null, "Could not find user in result set!");

                if (userData != null)
                {
                    if (osv.stateVisible)
                        Assert.IsTrue((userData.OnlineState & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
                    else
                        Assert.IsTrue((userData.OnlineState & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");
                }
            }
        }

        [TestCase]
        public void SocialCacheINH_CheckPrivacy()
        {
            PNUser user;
            OnlineStatusVariation[] osvs;
            GenerateFriends(out user, out osvs);

            // retrieve the friends list
            GetFriendsINHRequest request = new GetFriendsINHRequest();
            request.data = new GetFriendsXrlRequest();
            request.data.OwnerXuid = user.UserId;
            request.data.RequestorXuid = user.UserId;
            request.data.SortType = GetFriendSortType.Gamertag;
            request.data.PagingInfo = new PagingInfo();
            request.data.PagingInfo.PageSize = osvs.Length;
            request.data.PagingInfo.PageStart = 0;
            
            ErrorReply reply;
            uint hr;

            // open a connection to the server
            hr = SocialCacheProxy.Instance.Query(request.data.RequestorXuid, request, out reply);
            Assert.IsTrue(hr == HResult.S_OK, String.Format("GetFriendsINHRequest query failed. hr = {0}", hr));
            GetFriendsINHReply friendMsg = reply as GetFriendsINHReply;

            SocialQueryUser[] friends = friendMsg.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(friendMsg.NumSqFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friendMsg.NumSqFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    if (osv.stateVisible)
                        Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
                    else
                        Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");
                }
            }
        }                                                                                            

        #region helper functions

        private void GenerateFriends(out PNUser user, out OnlineStatusVariation[] osvs)
        {
            user = CreateXenonUser(false);
            PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
            user.Connect(xbox);
            Global.RO.Info("Created initial user {0} [{0:x}]", user.UserId);

            // set up the users according to the matrix of variations
            osvs = GenerateOnlineStatusVariations();

            foreach (OnlineStatusVariation osv in osvs)
            {
                osv.user = CreateXenonUser(false);
                PNXbox xbox2 = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
                user.Connect(xbox2);
                Global.RO.Info("Setting up user {0} [{0:x}]. Accepted: {1}, Privacy: {2}", osv.user.UserId, osv.isAccepted, osv.presencePrivacy);

                Global.RO.Info("User {0} [{0:x}]. requesting friend {1} [{1:x}]", osv.user.UserId, user.UserId);
                FriendsListUtil.Add(osv.user.UserId, user.UserId, osv.user.Name, user.Name);
                if (osv.isAccepted)
                {
                    Global.RO.Info("User {0} [{0:x}]. accepting friend {1} [{1:x}]", user.UserId, osv.user.UserId);
                    FriendsListUtil.Accept(user.UserId, osv.user.UserId);
                }

                switch (osv.presencePrivacy)
                {
                    case PrivacySetting.Blocked:
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE, false);
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);
                        break;

                    case PrivacySetting.FriendOnly:
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE, false);
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
                        break;

                    case PrivacySetting.Everyone:
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE, true);
                        SetPrivilege(osv.user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
                        break;
                }
            }

            foreach (OnlineStatusVariation osv in osvs)
            {
                Global.RO.Info("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                _fc.LogonUser(osv.user, osv.appearOffline);
            }
        }

        private static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            ServerTestFramework.LiveService.UserAccount.UserPrivileges grants = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();
            ServerTestFramework.LiveService.UserAccount.UserPrivileges restrictions = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }

        private static OnlineStatusVariation[] GenerateOnlineStatusVariations()
        {
            return new OnlineStatusVariation[]{
                                          new OnlineStatusVariation(false, PrivacySetting.Blocked, false, false),
                                          new OnlineStatusVariation(false, PrivacySetting.Blocked, true, false),
                                          new OnlineStatusVariation(false, PrivacySetting.FriendOnly, false, false),
                                          new OnlineStatusVariation(false, PrivacySetting.FriendOnly, true, false),
                                          new OnlineStatusVariation(false, PrivacySetting.Everyone, false, true),
                                          new OnlineStatusVariation(false, PrivacySetting.Everyone, true, false),
                                          new OnlineStatusVariation(true, PrivacySetting.Blocked, false, false),
                                          new OnlineStatusVariation(true, PrivacySetting.Blocked, true, false),
                                          new OnlineStatusVariation(true, PrivacySetting.FriendOnly, false, true),
                                          new OnlineStatusVariation(true, PrivacySetting.FriendOnly, true, false),
                                          new OnlineStatusVariation(true, PrivacySetting.Everyone, false, true),
                                          new OnlineStatusVariation(true, PrivacySetting.Everyone, true, false),
                                  };
        }

        #endregion
    }

    enum PrivacySetting
    {
        Blocked,
        FriendOnly,
        Everyone
    }

    class OnlineStatusVariation
    {
        public bool isAccepted;
        public PrivacySetting presencePrivacy;
        public bool appearOffline;
        public bool stateVisible;
        public PNUser user;

        public OnlineStatusVariation(bool isAccepted, PrivacySetting presencePrivacy, bool appearOffline, bool stateVisible)
        {
            this.isAccepted = isAccepted;
            this.presencePrivacy = presencePrivacy;
            this.appearOffline = appearOffline;
            this.stateVisible = stateVisible;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\fd\SocialQueryHandlerBase.cs ===
//
// SocialQueryHandlerBase.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.community.socialquery;

namespace xonline.server.socialquery.fd
{
    //-----------------------------------------------------------------------------------
    // Base class for all social query XRL handlers
    //-----------------------------------------------------------------------------------
    public abstract class SocialQueryHandlerBase : IHttpHandler
    {
        //-----------------------------------------------------------------------------------
        // Functions to be implemented by subclasses
        //-----------------------------------------------------------------------------------
        /// <summary>
        /// Create the API-specific wiredata request object
        /// </summary>
        /// <returns>A newly-created XRLObject2-derived wireadata object that will the request will be deserialized into.</returns>
        protected abstract XRLObject2 CreateRequest();

        /// <summary>
        /// Create the API-specific wiredata response object
        /// </summary>
        /// <returns>A newly-created XRLObject2-derived wireadata object that will the response will be serialized into.</returns>
        protected abstract XRLObject2 CreateResponse();

        /// <summary>
        /// Perform all processing necessary to generate the response and populate the response object.
        /// </summary>
        /// <returns>HResult indicating success or error code of processing.</returns>
        public  abstract HResult      GenerateResponse(XRLObject2 xrlReq, XRLObject2 xrlResp);

        /// <summary>
        /// Perform all API-specific processing necessary when an error condition is detected
        /// </summary>
        public abstract void          HandleError(HResult hr, XRLObject2 xrlReq, XRLObject2 xrlResp);

        /// <summary>
        /// Perform all API-specific processing necessary (logging, perf counters, etc.) after the response has been serialized.
        /// </summary>
        protected abstract void       FinishResponse(XRLObject2 xrlReq, XRLObject2 xrlResp, long timeElapsed);

        //-----------------------------------------------------------------------------------
        // IHttpHandler implementation
        //-----------------------------------------------------------------------------------
        public void ProcessRequest(HttpContext httpCtx)
        {
            HResult hr = HResult.E_FAIL;

            XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();

            // Check calling source
            CallSource.Check(VirtualInterface.socialqueryfd, VirtualInterface.socialqueryfd_int);

            // Track the request
            SocialQueryAllCounters.Counters.RequestsInProgress.Increment();

            // Get the request object from the XRL-specific handler
            XRLObject2 request  = CreateRequest();
            XRLObject2 response = CreateResponse();

            try {
                // Deserialize the incoming request stream
                request.SchemaVersion = WireData.GetSchemaVersion(httpCtx.Request);
                request.ReadFromRequest(httpCtx.Request);

                // Initialize the response
                response.SchemaVersion = request.SchemaVersion;

                // Process the request and generate the response
                hr = GenerateResponse(request, response);
                if(HResult.Failed(hr)) {
                    throw new XRLExceptionWithoutEvent(hr, "GenerateResponse failed");
                }
            }
            catch(Exception e) {
                // Get the hr from the exception, or use a default value 
                if(e is XRLException) {
                    hr = ((XRLException)e).HResult;
                } else if (e is ArgumentException) {
                    hr = HResult.E_INVALIDARG;
                } else {
                    hr = XRLException.ToHResult(e, HResult.XONLINE_E_SOCIAL_QUERY_GENERIC_ERROR);
                }

                // Let the XRL-specific handler can do any work it needs to (clear repsonse fields, store hr in response, etc.)
                HandleError(hr, request, response);

                // If the exception is specifically without an event or already has an event id, then we don't need to wrap it
                if((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) {
                    throw;
                } else {
                    // Something unexpected has happened. Rethrow an XRLException so we get proper eventing, 
                    // and set the hr so it is logged properly below
                    throw new XRLException(hr, XEvent.Id.SOCIALQUERY_UNKNOWN_ERROR,
                                           "socialqueryfd: Unexpected exception was thrown. Details should follow.", e);
                }
            }
            finally {
                // Send the response
                XRLUtil.SetXRLResponse(httpCtx.Response, XOService.SocialQuery, 0, hr, response);

                // Let subclass perform final tasks such as logging, perf counters, etc.
                FinishResponse(request, response, xrteRequestTime.TimeElapsed);

                // Update perf counters
                SocialQueryAllCounters.Counters.RequestsInProgress.Decrement();
                SocialQueryAllCounters.Counters.TotalRequests.Increment();
                SocialQueryAllCounters.Counters.RequestsPerSec.Increment();
                SocialQueryAllCounters.Counters.AverageExecutionTime.IncrementBy(xrteRequestTime.TimeElapsed);
                SocialQueryAllCounters.Counters.AverageExecutionTimeBase.Increment();
                if(HResult.Failed(hr)) {
                    SocialQueryAllCounters.Counters.TotalRequestsFailed.Increment();
                    SocialQueryAllCounters.Counters.RequestsPerSecFailed.Increment();
                }
            }
        }

        public bool IsReusable {
            get { return(true); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\FuncGetFriends.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.SocialQuery;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;
using System.Collections.Generic;
using System.Diagnostics;
using ServerTestFramework.LiveService.Auth;
using xonline.common.protocol.socialquery;
using xonline.common.community;

namespace SocialQueryTest
{
    /// <summary>
    /// Summary description for FuncGetFriends.
    /// </summary>
    [TestGroup]
    public class FuncGetFriends : SocialQueryTestBaseGroup
    {
        [TestCase, Description("Fetch the viewer's friends list which has 1 friend.")]
        public void P_GetFriends_FullAdd_BVT()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a;

            // Create a clean user and friend him to the viewer
            a = CreateXenonUser(false);
            MakeFriends(viewer, a);

            ro.Debug("Getting friends list for viewer...");
            SocialQueryUser userA = InitSocialQueryUser(a);

            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);

            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch the viewer's friends list which has 1 pending friend.")]
        public void P_GetFriends_SentFriendRequest_BVT()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a;

            // Create a clean user and friend him to the viewer
            a = CreateXenonUser(false);
            MakePendingFriends(viewer, a);

            ro.Debug("Getting friends list for viewer...");
            SocialQueryUser userA = InitSocialQueryUser(a, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));

            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 1, 1, 0, new SocialQueryUser[] { userA });
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Friend request is rejected, verifying viewer has empty list...");
            RejectRequest(a, viewer, true);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 0, 0, new SocialQueryUser[] { });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch the viewer's friends list which has 1 friend request.")]
        public void P_GetFriends_ReceivedFriendRequest_BVT()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a;

            // Create a clean user and friend him to the viewer
            a = CreateXenonUser(false);
            MakePendingFriends(a, viewer);

            ro.Debug("Getting friends list for viewer...");
            SQUserFlag_FriendStatus friendStatus = new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest);
            SocialQueryUser userA = InitSocialQueryUser(a, friendStatus);

            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 1, 1, 0, new SocialQueryUser[] { userA });
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Viewer rejects friend request, verifying viewer has empty list...");
            RejectRequest(viewer, a, true);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 0, 0, new SocialQueryUser[] { });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch list for owner containing offline and online friends")]
        public void P_GetFriends_OnlineOfflineFriends_BVT()
        {
            PNUser viewer = CreateXenonUser(true);

            int numFriends = 4;
            int friendlistVer = numFriends * 2;
            PNUser[] friends = new PNUser[numFriends];
            PNUser transitioner = null;
            int firstOnlineIndex = 1;
            int secondOnlineIndex = 3;

            for (int i = 0; i < numFriends; i++)
            {
                friends[i] = CreateXenonUser(false);
            }
            MakeFriends(viewer, friends);

            SocialQueryUser[] sqFriends = new SocialQueryUser[numFriends];
            for (int i = 0; i < numFriends; i++)
            {
                sqFriends[i] = InitSocialQueryUser(friends[i]);
            }

            SocialQueryUser[] gamertagSorted = SortByGamertag(sqFriends);
            foreach (PNUser friend in friends)
            {
                if (friend.UserId == gamertagSorted[firstOnlineIndex].Xuid)
                {
                    LogonUser(friend);
                    transitioner = friend;
                    gamertagSorted[firstOnlineIndex] = InitSocialQueryUser(friend, new SQUserFlag_UserState(true, false));
                }
                else if (friend.UserId == gamertagSorted[secondOnlineIndex].Xuid)
                {
                    LogonUser(friend);
                    friend.PartyPlaying = true;
                    gamertagSorted[secondOnlineIndex] = InitSocialQueryUser(friend, new SQUserFlag_UserState(true, true));
                }
            }

            WaitForCacheToUpdate();

            ro.Debug("Getting friends list with online and offline friends sorted by gamertag");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendlistVer, numFriends, 0, gamertagSorted);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Getting friends list with online and offline friends sorted by OnlineStatus");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendlistVer, numFriends, 0, SortByOnlineStatus(gamertagSorted));
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Logging off a user gamertag sorting shouldn't change, but onlineStatus should");
            LogoffUser(transitioner, true);
            gamertagSorted[1] = InitSocialQueryUser(transitioner);

            ro.Debug("Getting friends list with online and offline friends sorted by gamertag");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendlistVer, numFriends, 0, gamertagSorted);
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Getting friends list with online and offline friends sorted by OnlineStatus");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendlistVer, numFriends, 0, SortByOnlineStatus(gamertagSorted));
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch the viewer's friends list which has no friends, then one friend, then no friends.")]
        public void P_GetFriends_AddRemoveFriend()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a;

            // Create a clean user
            a = CreateXenonUser(false);

            // getfriendslist of user b, who has no friends
            ro.Debug("Getting viewer's friends list for viewer with no friends");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 0, 0, 0, null);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 12, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            // give user b a friend!
            MakeFriends(viewer, a, true);

            // getfriendslist of user b, who has 1 friend
            ro.Debug("Getting viewer's friends list with 1 friend");
            SocialQueryUser userA = InitSocialQueryUser(a);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 12, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            // remove user b's friend! Aww.
            RemoveFriends(viewer, new PNUser[] { a }, true);

            ro.Debug("Getting viewer's friends list back to no friends");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 3, 0, 0, null);
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 12, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch list for owner and for owner's friend when owner is offline / online")]
        public void P_GetFriends_ListOwnerIsOnlineOffline()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a = CreateXenonUser(true);

            MakeFriends(viewer, a);
            SocialQueryUser userA = InitSocialQueryUser(a, new SQUserFlag_UserState(true, false));

            ro.Debug("Getting friends list with online friend for online list owner");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Logging off friend by sending dead user message");
            LogoffUser(a, true);

            ro.Debug("Getting friends list with offline friend for online list owner");
            userA = InitSocialQueryUser(a);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Logging off list owner by sending dead user message");
            LogoffUser(viewer, true);

            ro.Debug("Getting friends list for owner when offline");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Logging on friend by sending alive user message");
            LogonUser(a, true);

            ro.Debug("Getting friends list with online friend for offline list owner");
            userA = InitSocialQueryUser(a, new SQUserFlag_UserState(true, false));
            expectedResponse = InitExpectedGetFriendsResponse(viewer, 2, 1, 0, new SocialQueryUser[] { userA });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch viewer's entire friends list who has 100 friends.")]
        public void P_GetFriends_100FriendsGetAll()
        {
            PNUser viewer = CreateXenonUser(true);

            // Create some clean users to become the viewer's friends
            PNUser[] friends = new PNUser[100];
            for (int i = 0; i < friends.Length; i++)
            {
                friends[i] = CreateXenonUser(false);
            }

            ro.Debug("Making friends for viewer...");
            MakeFriends(viewer, friends);
            SocialQueryUser[] sqFriends = SortByGamertag(friends);

            ro.Debug("Getting friends list for viewer...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, 200, 100, 0, sqFriends);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);

            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        #region Paging cases

        [TestCase, Description("Fetch viewer's friends list which has 40 pending/sent/full friends in every single paging scenario (pageSize=0-61 x startIndex=0-61.")]
        public void P_GetFriends_Paging_OnlineStatus_FourtyFriends()
        {
            PNUser viewer = CreateXenonUser(true);

            ro.Debug("viewer's xuid " + viewer.UserId);
            Random r = new Random();

            int totalNumUsers = 40;
            int expectedFriendsListVersion = 0;

            PNUser[] users = new PNUser[totalNumUsers];
            SocialQueryUser[] presortSQUsers = new SocialQueryUser[totalNumUsers];
            SQUserFlag_UserState onlineFlag = new SQUserFlag_UserState();
            for (int i = 0; i < users.Length; i++)
            {
                users[i] = CreateXenonUser(false);

                if (i > totalNumUsers / 2)
                {
                    LogonUser(users[i]);
                    onlineFlag = new SQUserFlag_UserState(true, false);
                }

                //ro.Debug("user " + i + "'s xuid " + users[i].UserId);
                int val = r.Next(0, 7);
                if (val == 2) //i/6 chance
                {
                    // pending sent
                    MakePendingFriends(viewer, users[i]);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], onlineFlag, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
                    expectedFriendsListVersion++;
                }
                else if (val == 4)
                {
                    // pending rec
                    MakePendingFriends(users[i], viewer);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], onlineFlag, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
                    expectedFriendsListVersion++;
                }
                else
                {
                    // full friends
                    MakeFriends(viewer, users[i]);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], onlineFlag, new SQUserFlag_FriendStatus(SocialQueryDefs.SQ_FLAG_FRIEND_REQUEST_ACCEPTED));
                    expectedFriendsListVersion += 2;
                }
            }

            // perform the default sort
            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(presortSQUsers);
            GetFriendsXrlResponse expectedResponse, replyData;

            // perform the matrix of paging parameters
            for (int pageSize = 1; pageSize <= totalNumUsers + 1; pageSize++)
            {
                ro.Debug("Getting paged friends, start index = 0-" + (users.Length + 1) + ", page size = " + pageSize);
                for (int i = 1; i <= users.Length + 1; i++)
                {
                    // setup the expected page start and size
                    int expectedReturnedUserCount = 0;
                    if (i + pageSize >= users.Length)
                    {
                        expectedReturnedUserCount = (i >= users.Length) ? 0 : users.Length - i;
                    }
                    else
                    {
                        expectedReturnedUserCount = pageSize;
                    }

                    // setup expected users array
                    SocialQueryUser[] expectedUsers = new SocialQueryUser[expectedReturnedUserCount];
                    for (int j = 0; j < expectedReturnedUserCount; j++)
                    {
                        expectedUsers[j] = sortedSQUsers[i + j];
                    }

                    //ro.Debug("Getting paged friends, start index = " + i + ", page size = " + pageSize + " (" + expectedReturnedUserCount + ")");
                    expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, totalNumUsers, i, expectedUsers);
                    replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, pageSize, i);
                    //int xx = 0;
                    //foreach (SocialQueryUser user in expectedResponse.Friends)
                    //{
                    //    ro.Debug("EX[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    //    xx++;
                    //}
                    //xx = 0;
                    //foreach (SocialQueryUser user in replyData.Friends)
                    //{
                    //    ro.Debug("AC[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    //    xx++;
                    //}

                    ValidateGetFriendsXrlResponse(replyData, expectedResponse);
                }
            }
        }

        [TestCase, Description("Fetch viewer's friends list which has 30 pending/sent/full friends in every single paging scenario (pageSize=0-31 x startIndex=0-31.")]
        public void P_GetFriends_Paging_Gamertag_ThirtyFriends()
        {
            PNUser viewer = CreateXenonUser(true);

            ro.Debug("viewer's xuid " + viewer.UserId);
            Random r = new Random();

            int totalNumUsers = 30;
            int expectedFriendsListVersion = 0;

            PNUser[] users = new PNUser[totalNumUsers];
            SocialQueryUser[] presortSQUsers = new SocialQueryUser[totalNumUsers];
            for (int i = 0; i < users.Length; i++)
            {
                users[i] = CreateXenonUser(false);
                //ro.Debug("user " + i + "'s xuid " + users[i].UserId);
                int val = r.Next(0, 7);
                if (val == 2) //i/6 chance
                {
                    // pending sent
                    MakePendingFriends(viewer, users[i]);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
                    expectedFriendsListVersion++;
                }
                else if (val == 4)
                {
                    // pending rec
                    MakePendingFriends(users[i], viewer);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
                    expectedFriendsListVersion++;
                }
                else
                {
                    // full friends
                    MakeFriends(viewer, users[i]);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], new SQUserFlag_FriendStatus(SocialQueryDefs.SQ_FLAG_FRIEND_REQUEST_ACCEPTED));
                    expectedFriendsListVersion += 2;
                }
            }

            // perform the default sort
            SocialQueryUser[] sortedSQUsers = SortByGamertag(presortSQUsers);
            GetFriendsXrlResponse expectedResponse, replyData;

            // perform the matrix of paging parameters
            for (int pageSize = 0; pageSize <= totalNumUsers + 1; pageSize++)
            {
                ro.Debug("Getting paged friends, start index = 0-" + (users.Length + 1) + ", page size = " + pageSize);
                for (int i = 0; i <= users.Length + 1; i++)
                {
                    // setup the expected page start and size
                    int expectedReturnedUserCount = 0;
                    if (i + pageSize >= users.Length)
                    {
                        expectedReturnedUserCount = (i >= users.Length) ? 0 : users.Length - i;
                    }
                    else
                    {
                        expectedReturnedUserCount = pageSize;
                    }

                    // setup expected users array
                    SocialQueryUser[] expectedUsers = new SocialQueryUser[expectedReturnedUserCount];
                    for (int j = 0; j < expectedReturnedUserCount; j++)
                    {
                        expectedUsers[j] = sortedSQUsers[i + j];
                    }

                    // ro.Debug("Getting paged friends, start index = " + i + ", page size = " + pageSize + " (" + expectedReturnedUserCount + ")");
                    expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, totalNumUsers, i, expectedUsers);
                    replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, i);
                    ValidateGetFriendsXrlResponse(replyData, expectedResponse);
                }
            }
        }

        [TestCase, Description("Fetch viewer's friends list which has 1 friend by requesting page size of 5 but a page start index of 4, 5, 6, 9")]
        public void P_GetFriends_Paging_StartIndexBoundaries()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a;

            // Create a clean user and friend him to the viewer
            a = CreateXenonUser(false);
            MakeFriends(viewer, a);

            ro.Debug("Getting friends list for viewer...");
            SocialQueryUser userA = InitSocialQueryUser(a);

            // Request a page size of 5 but a page start of 4, 5, 6 and then 9.  We should get 0 records back.
            int pageSize = 5;
            int pageStartIndex = 4;
            int totalNumFriends = 1;
            int expectedFriendsListVer = totalNumFriends * 2;
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, totalNumFriends, pageStartIndex, new SocialQueryUser[] { });
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            pageStartIndex = 5;
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, totalNumFriends, pageStartIndex, new SocialQueryUser[] { });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            pageStartIndex = 6;
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, totalNumFriends, pageStartIndex, new SocialQueryUser[] { });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            pageStartIndex = 9;
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, totalNumFriends, pageStartIndex, new SocialQueryUser[] { });
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

        }

        [TestCase, Description("Fetch a page of viewer's friends list sorted by Gamertag then remove users at the boundaries of that page.")]
        public void P_GetFriends_Paging_MovingBoundaries_Gamertag()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser[] users = new PNUser[15];
            users[0] = GetUser("fitretTaken");
            users[1] = GetUser("Tick");
            users[2] = GetUser("Major Havok");
            users[3] = GetUser("Pointy Swords");
            users[4] = GetUser("Chuck Norris");
            users[5] = GetUser("Nemarus");
            users[6] = GetUser("Flot");
            users[7] = GetUser("Corner Case");
            users[8] = GetUser("Chuckles");
            users[9] = GetUser("Gamingloser");
            users[10] = GetUser("Doug Has Issues");
            users[11] = GetUser("DMZilla");
            users[12] = GetUser("Jesiatha");
            users[13] = GetUser("DT");
            users[14] = GetUser("Kyellan");

            MakeFriends(viewer, users);
            int friendsListVer = users.Length * 2;


            // Sorted By Gamertag:
            //      Chuck Norris
            //      Chuckles
            //      Corner Case
            //      DMZilla                     -- First Removal
            //  ||  Doug Has Issues
            //  ||  DT                          -- Second Removal
            //  ||  fitret
            //  ||  Flot
            //  ||  Gamingloser
            //      Jesiatha
            //      Kyellan                     -- Third Removal
            //      Major Havok
            //      Nemarus                     -- Fourth Removal
            //      Pointy Swords
            //      Tick
            //

            ro.Debug("Getting full friends list for viewer...");
            SocialQueryUser[] sqUsers = new SocialQueryUser[users.Length];
            for (int i = 0; i < users.Length; i++)
            {
                sqUsers[i] = InitSocialQueryUser(users[i]);
            }
            SocialQueryUser[] sortedSQUsers = SortByGamertag(sqUsers);

            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            // For the rest of the test, we'll be requesting a page size of 5 and a pageStartIndex of 4
            int pageSize = 5;
            int pageStartIndex = 4;

            // setup expected users array
            SocialQueryUser[] expectedUsers = new SocialQueryUser[pageSize];
            for (int j = 0; j < pageSize; j++)
            {
                expectedUsers[j] = sortedSQUsers[pageStartIndex + j];
            }

            ro.Debug("Getting a page of 5 friends starting at index 4 for viewer...");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length, pageStartIndex, expectedUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            List<string> nonFriends = new List<string>();
            PNUser[] friendsToRemove = new PNUser[] { users[11], users[10], users[14], users[5] };
            for (int i = 0; i < friendsToRemove.Length; i++)
            {
                ro.Debug("De-friending the following user: " + friendsToRemove[i].Name);
                RemoveFriends(viewer, new PNUser[] { friendsToRemove[i] }, true);
                friendsListVer++;
                nonFriends.Add(friendsToRemove[i].Name);
                int onPageIndex = 0;
                int adjustedFriendsListIndex = 0;
                for (int listIdx = 0; listIdx < users.Length; listIdx++)
                {
                    if (!nonFriends.Contains(sortedSQUsers[listIdx].Gamertag))
                    {
                        adjustedFriendsListIndex++;

                        if (adjustedFriendsListIndex > pageStartIndex)
                        {
                            expectedUsers[onPageIndex] = sortedSQUsers[listIdx];
                            onPageIndex++;
                            if (onPageIndex == pageSize)
                                break;
                        }
                    }
                }

                expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length - nonFriends.Count, pageStartIndex, expectedUsers);
                replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }

            for (int i = 0; i < friendsToRemove.Length; i++)
            {
                ro.Debug("Re-friending the following user: " + friendsToRemove[i].Name);
                MakeFriends(viewer, friendsToRemove[i], true);
                friendsListVer += 2;
                nonFriends.Remove(friendsToRemove[i].Name);
                int onPageIndex = 0;
                int adjustedFriendsListIndex = 0;
                for (int listIdx = 0; listIdx < users.Length; listIdx++)
                {
                    if (!nonFriends.Contains(sortedSQUsers[listIdx].Gamertag))
                    {
                        adjustedFriendsListIndex++;

                        if (adjustedFriendsListIndex > pageStartIndex)
                        {
                            expectedUsers[onPageIndex] = sortedSQUsers[listIdx];
                            onPageIndex++;
                            if (onPageIndex == pageSize)
                                break;
                        }
                    }
                }

                expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length - nonFriends.Count, pageStartIndex, expectedUsers);
                replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, pageSize, pageStartIndex);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase, Description("Fetch a page of viewer's friends list sorted by Gamertag then remove users at the boundaries of that page.")]
        public void P_GetFriends_Paging_MovingBoundaries_OnlineStatus()
        {
            int totalNumUsers = 50;
            Random r = new Random();

            PNUser viewer = CreateXenonUser(true);
            PNUser[] users = new PNUser[totalNumUsers];
            SocialQueryUser[] presortSQUsers = new SocialQueryUser[totalNumUsers];
            for (int i = 0; i < users.Length; i++)
            {
                int val = r.Next(0, 5);
                if (val == 2 || val == 4)
                {
                    users[i] = CreateXenonUser(true);
                    presortSQUsers[i] = InitSocialQueryUser(users[i], new SQUserFlag_UserState(true, false));
                }
                else
                {
                    users[i] = CreateXenonUser(false);
                    presortSQUsers[i] = InitSocialQueryUser(users[i]);
                }
            }

            MakeFriends(viewer, users);
            int expectedFriendsListVersion = users.Length * 2;
            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(presortSQUsers);

            ro.Debug("Getting full friends list for viewer...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, users.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            // For the rest of the test, we'll be requesting a page size of 36 and a pageStartIndex of 7
            int pageSize = 36;
            int pageStartIndex = 7;

            // setup expected users array
            SocialQueryUser[] expectedUsers = new SocialQueryUser[pageSize];
            for (int j = 0; j < pageSize; j++)
            {
                expectedUsers[j] = sortedSQUsers[pageStartIndex + j];
            }

            ro.Debug("Getting a page of " + pageSize + " friends starting at index " + pageStartIndex + " for viewer...");
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, users.Length, pageStartIndex, expectedUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, pageSize, pageStartIndex);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            List<string> nonFriends = new List<string>();
            PNUser[] friendsToRemove = new PNUser[] { users[pageStartIndex - 1], users[pageStartIndex + 1], users[pageStartIndex + pageSize +1], users[pageStartIndex + pageSize + 3] };
            for (int i = 0; i < friendsToRemove.Length; i++)
            {
                ro.Debug("De-friending the following user: " + friendsToRemove[i].Name);
                RemoveFriends(viewer, new PNUser[] { friendsToRemove[i] }, true);
                expectedFriendsListVersion++;
                nonFriends.Add(friendsToRemove[i].Name);
                int onPageIndex = 0;
                int adjustedFriendsListIndex = 0;
                for (int listIdx = 0; listIdx < users.Length; listIdx++)
                {
                    if (!nonFriends.Contains(sortedSQUsers[listIdx].Gamertag))
                    {
                        adjustedFriendsListIndex++;

                        if (adjustedFriendsListIndex > pageStartIndex)
                        {
                            expectedUsers[onPageIndex] = sortedSQUsers[listIdx];
                            onPageIndex++;
                            if (onPageIndex == pageSize)
                                break;
                        }
                    }
                }

                ro.Debug("Getting the new page of " + pageSize + " friends starting at index " + pageStartIndex);
                expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, users.Length - nonFriends.Count, pageStartIndex, expectedUsers);
                replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, pageSize, pageStartIndex);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }

            for (int i = 0; i < friendsToRemove.Length; i++)
            {
                ro.Debug("Re-friending the following user: " + friendsToRemove[i].Name);
                MakeFriends(viewer, friendsToRemove[i], true);
                expectedFriendsListVersion += 2;
                nonFriends.Remove(friendsToRemove[i].Name);
                int onPageIndex = 0;
                int adjustedFriendsListIndex = 0;
                for (int listIdx = 0; listIdx < users.Length; listIdx++)
                {
                    if (!nonFriends.Contains(sortedSQUsers[listIdx].Gamertag))
                    {
                        adjustedFriendsListIndex++;

                        if (adjustedFriendsListIndex > pageStartIndex)
                        {
                            expectedUsers[onPageIndex] = sortedSQUsers[listIdx];
                            onPageIndex++;
                            if (onPageIndex == pageSize)
                                break;
                        }
                    }
                }

                expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVersion, users.Length - nonFriends.Count, pageStartIndex, expectedUsers);
                replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, pageSize, pageStartIndex);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        #endregion

        #region Sort by Gamertag cases

        [TestCase, Description("Fetch entire list sorted by gamertag where gamertags are substrings of each other, some with spaces.")]
        public void P_GetFriends_Sort_Gamertag_SubstringGamertags()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a = GetUser("apple");
            PNUser b = GetUser("z");
            PNUser c = GetUser("apple zorgs");
            PNUser d = GetUser("a");
            PNUser e = GetUser("apple z o");
            PNUser f = GetUser("appler");
            WaitForXCache();

            MakeFriends(viewer, b);
            MakeFriends(viewer, c);
            MakeFriends(viewer, a);
            MakeFriends(viewer, d);
            MakeFriends(viewer, e);
            MakeFriends(viewer, f);
            int friendsListVer = 12;  // 2 * numFriends

            SocialQueryUser userA = InitSocialQueryUser(a);
            SocialQueryUser userB = InitSocialQueryUser(b);
            SocialQueryUser userC = InitSocialQueryUser(c);
            SocialQueryUser userD = InitSocialQueryUser(d);
            SocialQueryUser userE = InitSocialQueryUser(e);
            SocialQueryUser userF = InitSocialQueryUser(f);

            SocialQueryUser[] users = new SocialQueryUser[] { userD, userA, userE, userC, userF, userB };
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length, 0, users);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, users.Length, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch entire list sorted by gamertag where gamertags are have numbers instead of some letters.")]
        public void P_GetFriends_Sort_Gamertag_LeetGamertags()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a = GetUser("lollipop");
            PNUser b = GetUser("l0ll1p0p");
            PNUser c = GetUser("lollip0p");
            WaitForXCache();

            MakeFriends(viewer, b);
            MakeFriends(viewer, c);
            MakeFriends(viewer, a);
            int friendsListVer = 6;  // 2 * numFriends

            SocialQueryUser userA = InitSocialQueryUser(a);
            SocialQueryUser userB = InitSocialQueryUser(b);
            SocialQueryUser userC = InitSocialQueryUser(c);

            //gamertag ascending
            SocialQueryUser[] users = new SocialQueryUser[] { userB, userC, userA };
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length, 0, users);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, users.Length, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch entire list sorted by gamertag where gamertags start with some of the same letters, some upper and lower case.")]
        public void P_GetFriends_Sort_Gamertag_CapitalGamertags()
        {
            PNUser viewer = CreateXenonUser(true);
            PNUser a = GetUser("LowAmmo1");
            PNUser b = GetUser("captureA");
            //PNUser c = GetUser("xXx blamer bB");
            PNUser d = GetUser("SecuringAlpha");
            PNUser e = GetUser("smokeemout");
            PNUser f = GetUser("linger");
            PNUser g = GetUser("xXxblamertag5");
            PNUser h = GetUser("XxXalpha");
            PNUser i = GetUser("XXxcharile");
            PNUser j = GetUser("xxxyackityyack");
            //PNUser k = GetUser("xXx bla mer t");
            WaitForXCache();

            MakeFriends(viewer, b);
            MakeFriends(viewer, a);
            MakeFriends(viewer, i);
            MakeFriends(viewer, f);
            MakeFriends(viewer, h);
            MakeFriends(viewer, g);
            MakeFriends(viewer, d);
            MakeFriends(viewer, e);
            MakeFriends(viewer, j);
            //MakeFriends(viewer, c);
            //MakeFriends(viewer, k);
            int friendsListVer = 18;  // 2 * numFriends

            SocialQueryUser userA = InitSocialQueryUser(a);
            SocialQueryUser userB = InitSocialQueryUser(b);
            //SocialQueryUser userC = InitSocialQueryUser(c);
            SocialQueryUser userD = InitSocialQueryUser(d);
            SocialQueryUser userE = InitSocialQueryUser(e);
            SocialQueryUser userF = InitSocialQueryUser(f);
            SocialQueryUser userG = InitSocialQueryUser(g);
            SocialQueryUser userH = InitSocialQueryUser(h);
            SocialQueryUser userI = InitSocialQueryUser(i);
            SocialQueryUser userJ = InitSocialQueryUser(j);
            //SocialQueryUser userK = InitSocialQueryUser(k);

            //gamertag ascending
            SocialQueryUser[] users = new SocialQueryUser[] { userB, userF, userA, userD, userE, userH, /*userK,*/ userG, userI, userJ/*, userC*/ };
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, users.Length, 0, users);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, users.Length, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        #endregion

        #region Sort by OnlineStatus cases

        [TestCase, Description("List owner's sent requests are accepted and rejected, verify correct sorting")]
        public void P_GetFriends_Sort_OnlineStatus_SentRequestToFull()
        {
            PNUser viewer = CreateXenonUser(true);

            PNUser aOn = GetUser("alphaOn");
            PNUser aOff = GetUser("alphaOff");
            PNUser bOn = GetUser("bravoOn");
            PNUser bOff = GetUser("bravoOff");
            PNUser cOn = GetUser("charlieOn");
            PNUser cOff = GetUser("charlieOff");
            PNUser dOn = GetUser("deltaOn");
            PNUser dOff = GetUser("deltaOff");

            // Login online users:
            LogonUser(aOn);
            LogonUser(bOn);
            LogonUser(cOn);
            LogonUser(dOn);

            MakeFriends(viewer, aOn);
            MakeFriends(viewer, aOff);
            MakeFriends(viewer, dOn);
            MakeFriends(viewer, dOff);
            MakePendingFriends(viewer, bOn);
            MakePendingFriends(viewer, bOff);
            MakePendingFriends(viewer, cOn);
            MakePendingFriends(viewer, cOff);
            int expectedFriendsListVer = 12;  // numFullFriends * 2 + numPartialFriends

            SocialQueryUser userAOn = InitSocialQueryUser(aOn, new SQUserFlag_UserState(true, false));
            SocialQueryUser userAOff = InitSocialQueryUser(aOff);
            SocialQueryUser userBOn = InitSocialQueryUser(bOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userBOff = InitSocialQueryUser(bOff, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userCOn = InitSocialQueryUser(cOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userCOff = InitSocialQueryUser(cOff, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userDOn = InitSocialQueryUser(dOn, new SQUserFlag_UserState(true, false));
            SocialQueryUser userDOff = InitSocialQueryUser(dOff);

            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userCOn, userCOff, userDOn, userDOff });

            ro.Debug("Getting friends list for viewer...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            //for (int idx = 0; idx < replyData.Friends.Length; idx++)
            //{
            //    ro.Debug("user[" + idx + "]: " + replyData.Friends[idx].Gamertag + " : " + replyData.Friends[idx].Flags);
            //}
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Friend request is accepted, verify new sort order");
            AcceptRequest(bOn, viewer);
            AcceptRequest(bOff, viewer, true);
            expectedFriendsListVer += 2;
            userBOn = InitSocialQueryUser(bOn, new SQUserFlag_UserState(true, false));
            userBOff = InitSocialQueryUser(bOff);
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userCOn, userCOff, userDOn, userDOff });
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Friend request is rejected, verify new sort order");
            RejectRequest(cOn, viewer);
            RejectRequest(cOff, viewer, true);
            expectedFriendsListVer += 2;
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userDOn, userDOff });
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("List owner's received requests are accepted and rejected, verify correct sorting")]
        public void P_GetFriends_Sort_OnlineStatus_ReceivedRequestToFull()
        {
            PNUser viewer = CreateXenonUser(true);

            PNUser aOn = GetUser("alphaOn");
            PNUser aOff = GetUser("alphaOff");
            PNUser bOn = GetUser("bravoOn");
            PNUser bOff = GetUser("bravoOff");
            PNUser cOn = GetUser("charlieOn");
            PNUser cOff = GetUser("charlieOff");
            PNUser dOn = GetUser("deltaOn");
            PNUser dOff = GetUser("deltaOff");

            // Login online users:
            LogonUser(aOn);
            LogonUser(bOn);
            LogonUser(cOn);
            LogonUser(dOn);

            MakeFriends(viewer, aOn);
            MakeFriends(viewer, aOff);
            MakeFriends(viewer, dOn);
            MakeFriends(viewer, dOff);
            MakePendingFriends(bOn, viewer);
            MakePendingFriends(bOff, viewer);
            MakePendingFriends(cOn, viewer);
            MakePendingFriends(cOff, viewer);
            int expectedFriendsListVer = 12;  // numFullFriends * 2 + numPartialFriends

            SocialQueryUser userAOn = InitSocialQueryUser(aOn, new SQUserFlag_UserState(true, false));
            SocialQueryUser userAOff = InitSocialQueryUser(aOff);
            SocialQueryUser userBOn = InitSocialQueryUser(bOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser userBOff = InitSocialQueryUser(bOff, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser userCOn = InitSocialQueryUser(cOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser userCOff = InitSocialQueryUser(cOff, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser userDOn = InitSocialQueryUser(dOn, new SQUserFlag_UserState(true, false));
            SocialQueryUser userDOff = InitSocialQueryUser(dOff);

            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userCOn, userCOff, userDOn, userDOff });

            ro.Debug("Getting friends list for viewer...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Friend request is accepted, verify new sort order");
            AcceptRequest(viewer, bOn);
            AcceptRequest(viewer, bOff, true);
            expectedFriendsListVer += 2;
            userBOn = InitSocialQueryUser(bOn, new SQUserFlag_UserState(true, false));
            userBOff = InitSocialQueryUser(bOff);
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userCOn, userCOff, userDOn, userDOff });
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Friend request is accepted, verify new sort order");
            RejectRequest(viewer, cOn);
            RejectRequest(viewer, cOff, true);
            expectedFriendsListVer += 2;
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userAOn, userAOff, userBOn, userBOff, userDOn, userDOff });
            expectedResponse = InitExpectedGetFriendsResponse(viewer, expectedFriendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Verify the correct sorting of the partial friend section returned by Sort By OnlineStatus")]
        public void P_GetFriends_Sort_OnlineStatus_PartialFriendSection()
        {
            PNUser owner = CreateXenonUser(true);
            PNUser fullOn = CreateXenonUser(true);
            PNUser sentOn = CreateXenonUser(true);
            PNUser sentOff = CreateXenonUser(false);
            PNUser recdOn = CreateXenonUser(true);
            PNUser recdOff = CreateXenonUser(false);

            MakeFriends(owner, fullOn);
            MakePendingFriends(owner, sentOn);
            MakePendingFriends(owner, sentOff);
            MakePendingFriends(recdOn, owner);
            MakePendingFriends(recdOff, owner);

            SocialQueryUser userFullOn = InitSocialQueryUser(fullOn, new SQUserFlag_UserState(true, false));
            SocialQueryUser userSentOn = InitSocialQueryUser(sentOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userSentOff = InitSocialQueryUser(sentOff, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser userRecdOn = InitSocialQueryUser(recdOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser userRecdOff = InitSocialQueryUser(recdOff, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            int friendsListVer = sortedSQUsers.Length + 1; // all are partial friends save 1 full friend

            ro.Debug("Getting friends list for owner...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Online user which has received a FR from owner goes offline...");
            LogoffUser(sentOn, true);
            userSentOn = InitSocialQueryUser(sentOn, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Offline user which has received a FR from owner goes online...");
            LogonUser(sentOff, true);
            userSentOff = InitSocialQueryUser(sentOff, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Offline user which has sent a FR to owner goes online...");
            LogonUser(recdOff, true);
            userRecdOff = InitSocialQueryUser(recdOff, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Online user which has sent a FR to owner goes offline...");
            LogoffUser(recdOn, true);
            userRecdOn = InitSocialQueryUser(recdOn, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);


            // Now go back to their original states
            ro.Debug("Offline user which has received a FR from owner goes online...");
            LogonUser(sentOn, true);
            userSentOn = InitSocialQueryUser(sentOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Online user which has received a FR from owner goes offline...");
            LogoffUser(sentOff, true);
            userSentOff = InitSocialQueryUser(sentOff, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Online user which has sent a FR to owner goes offline...");
            LogoffUser(recdOff, true);
            userRecdOff = InitSocialQueryUser(recdOff, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Offline user which has sent a FR to owner goes online...");
            LogonUser(recdOn, true);
            userRecdOn = InitSocialQueryUser(recdOn, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { userFullOn, userSentOn, userSentOff, userRecdOn, userRecdOff });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);

        }

        [TestCase, Description("Verify the correct sorting of the partial friend section returned by Sort By OnlineStatus")]
        public void P_GetFriends_Sort_OnlineStatus_ComplexPartialsToFull()
        {
            PNUser owner = CreateXenonUser(true);

            // These users ordered as they should appear on the initial friends list
            PNUser SentinelPartialTop = GetUser("Capybara");
            PNUser NewSentinelOnlineTop = GetUser("dashchund");
            PNUser NewSentinelOfflineTop = GetUser("eagle");
            PNUser OnlineSent = GetUser("Kangar00");
            PNUser OfflineRecd = GetUser("mmmM0nster");
            PNUser OfflineSent = GetUser("p9999999");
            PNUser OnlineRecd = GetUser("sloooooooth");
            PNUser NewSentinelOfflineBottom = GetUser("snakeWasTaken");
            PNUser NewSentinelOnlineBottom = GetUser("zerg");
            PNUser SentinelPartialBottom = GetUser("ZzZebra");
            PNUser SentinelOnlineTop = GetUser("j4Guarrrr");
            PNUser SentinelOnlineMiddle = GetUser("L1G3R");
            PNUser SentinelOnlineBottom = GetUser("WWWWWWWWWWWWWWW");
            PNUser SentinelOfflineTop = GetUser("hiiipppo");
            PNUser SentinelOfflineMiddle = GetUser("Ocelot");
            PNUser SentinelOfflineBottom = GetUser("platypus");

            // Added after the first friendslist fetch
            PNUser NewSentinelPartialTop = GetUser("Beagle");
            PNUser NewSentinelPartialBottom = GetUser("zzZzebraa");

            MakeFriends(owner, SentinelOnlineTop);
            MakeFriends(owner, SentinelOnlineMiddle);
            MakeFriends(owner, SentinelOnlineBottom);
            MakeFriends(owner, SentinelOfflineTop);
            MakeFriends(owner, SentinelOfflineMiddle);
            MakeFriends(owner, SentinelOfflineBottom);

            MakePendingFriends(owner, SentinelPartialTop);
            MakePendingFriends(owner, NewSentinelOfflineTop);
            MakePendingFriends(owner, OnlineSent);
            MakePendingFriends(owner, OfflineSent);
            MakePendingFriends(owner, NewSentinelOfflineBottom);

            MakePendingFriends(NewSentinelOnlineTop, owner);
            MakePendingFriends(OnlineRecd, owner);
            MakePendingFriends(OfflineRecd, owner);
            MakePendingFriends(NewSentinelOnlineBottom, owner);
            MakePendingFriends(SentinelPartialBottom, owner);

            LogonUser(NewSentinelPartialTop);
            LogonUser(NewSentinelOnlineTop);
            LogonUser(OnlineSent);
            LogonUser(OnlineRecd);
            LogonUser(NewSentinelOnlineBottom);
            LogonUser(SentinelPartialBottom);
            LogonUser(SentinelOnlineTop);
            LogonUser(SentinelOnlineMiddle);
            LogonUser(SentinelOnlineBottom, true);

            SocialQueryUser uSentinelPartialTop = InitSocialQueryUser(SentinelPartialTop, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser uNewSentinelOnlineTop = InitSocialQueryUser(NewSentinelOnlineTop, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser uNewSentinelOfflineTop = InitSocialQueryUser(NewSentinelOfflineTop, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser uOnlineSent = InitSocialQueryUser(OnlineSent, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser uOfflineRecd = InitSocialQueryUser(OfflineRecd, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser uOfflineSent = InitSocialQueryUser(OfflineSent, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser uOnlineRecd = InitSocialQueryUser(OnlineRecd, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser uNewSentinelOfflineBottom = InitSocialQueryUser(NewSentinelOfflineBottom, new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            SocialQueryUser uNewSentinelOnlineBottom = InitSocialQueryUser(NewSentinelOnlineBottom, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            SocialQueryUser uSentinelPartialBottom = InitSocialQueryUser(SentinelPartialBottom, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));

            SocialQueryUser uSentinelOnlineTop = InitSocialQueryUser(SentinelOnlineTop, new SQUserFlag_UserState(true, false));
            SocialQueryUser uSentinelOnlineMiddle = InitSocialQueryUser(SentinelOnlineMiddle, new SQUserFlag_UserState(true, false));
            SocialQueryUser uSentinelOnlineBottom = InitSocialQueryUser(SentinelOnlineBottom, new SQUserFlag_UserState(true, false));

            SocialQueryUser uSentinelOfflineTop = InitSocialQueryUser(SentinelOfflineTop);
            SocialQueryUser uSentinelOfflineMiddle = InitSocialQueryUser(SentinelOfflineMiddle);
            SocialQueryUser uSentinelOfflineBottom = InitSocialQueryUser(SentinelOfflineBottom);

            SocialQueryUser uNewSentinelPartialTop = InitSocialQueryUser(NewSentinelPartialTop);
            SocialQueryUser uNewSentinelPartialBottom = InitSocialQueryUser(NewSentinelPartialBottom);

            SocialQueryUser[] sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            int friendsListVer = sortedSQUsers.Length + 6; // all are partial friends save for 6 partial friends

            ro.Debug("Getting initial friends list for owner...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            GetFriendsXrlResponse replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("OfflineSent accepts the friend request...");
            AcceptRequest(OfflineSent, owner, true);
            friendsListVer++;
            uOfflineSent = InitSocialQueryUser(OfflineSent);
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Owner accepts the friend request from OfflineRecd...");
            AcceptRequest(owner, OfflineRecd, true);
            friendsListVer++;
            uOfflineRecd = InitSocialQueryUser(OfflineRecd);
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("OnlineSent accepts the friend request...");
            AcceptRequest(OnlineSent, owner, true);
            friendsListVer++;
            uOnlineSent = InitSocialQueryUser(OnlineSent, new SQUserFlag_UserState(true, false));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Owner accepts the friend request from OnlineRecd...");
            AcceptRequest(owner, OnlineRecd, true);
            friendsListVer++;
            uOnlineRecd = InitSocialQueryUser(OnlineRecd, new SQUserFlag_UserState(true, false));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("New challengers have appeared!  NewSentinelPartialTop and NewSentinelPartialBottom send friend requests");
            MakePendingFriends(NewSentinelPartialTop, owner);
            friendsListVer++;
            MakePendingFriends(NewSentinelPartialBottom, owner, true);
            friendsListVer++;
            uNewSentinelPartialTop = InitSocialQueryUser(NewSentinelPartialTop, new SQUserFlag_UserState(true, false), new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            uNewSentinelPartialBottom = InitSocialQueryUser(NewSentinelPartialBottom, new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            sortedSQUsers = SortByOnlineStatus(new SocialQueryUser[] { uNewSentinelPartialTop, uSentinelPartialTop, uNewSentinelOnlineTop, uNewSentinelOfflineTop, uOnlineSent, uOfflineRecd, uOfflineSent, uOnlineRecd, uNewSentinelOfflineBottom, uNewSentinelOnlineBottom, uSentinelPartialBottom, uNewSentinelPartialBottom, uSentinelOnlineTop, uSentinelOnlineMiddle, uSentinelOnlineBottom, uSentinelOfflineTop, uSentinelOfflineMiddle, uSentinelOfflineBottom });
            expectedResponse = InitExpectedGetFriendsResponse(owner, friendsListVer, sortedSQUsers.Length, 0, sortedSQUsers);
            replyData = owner.GetFriendsList(GetFriendSortType.OnlineStatus, 100, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

        }


        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\fd\GetFriends.cs ===
//
// GetFriends.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol.socialquery;
using xonline.common.community.socialquery;
using xonline.common.community.socialquery.protocol;

namespace xonline.server.socialquery.fd
{
    //-----------------------------------------------------------------------------------
    // Get friend list
    //-----------------------------------------------------------------------------------
    public class GetFriends : SocialQueryHandlerBase
    {
        protected override XRLObject2 CreateRequest()
        {
            return(new GetFriendsXrlRequest());
        }

        protected override XRLObject2 CreateResponse()
        {
            return(new GetFriendsXrlResponse());
        }

        public override HResult GenerateResponse(XRLObject2 xrlReq, XRLObject2 xrlResp)
        {
            return (GenerateResponse(xrlReq, xrlResp, SocialCacheProxy.Instance));
        }

        public HResult GenerateResponse(XRLObject2 xrlReq, XRLObject2 xrlResp, ISocialCacheProxy sqProxy)
        {
            GetFriendsXrlRequest  req  = (GetFriendsXrlRequest)xrlReq;
            GetFriendsXrlResponse resp = (GetFriendsXrlResponse)xrlResp;

            // Update perf counters if they're installed
            if(PerformanceCounterCategory.Exists(GetFriendsCounters.PerfCounterCategoryName)) {
                GetFriendsCounters.Counters.RequestsInProgressGetUserList.Increment();
            }

            resp.hr            = HResult.S_OK;
            resp.RequestorXuid = req.RequestorXuid;
            resp.OwnerXuid     = req.OwnerXuid;

            Xom.Log(XomAreaName.socialqueryfd, "GetFriendList req.RequestorXuid = 0x{0:X16}", req.RequestorXuid);
            Xom.Log(XomAreaName.socialqueryfd, "GetFriendList req.OwnerXuid = 0x{0:X16}", req.OwnerXuid);
            Xom.Log(XomAreaName.socialqueryfd, "GetFriendList req.SortType = {0}", req.SortType);
            Xom.Log(XomAreaName.socialqueryfd, "GetFriendList req.PagingInfo.PageStart = {0}", req.PagingInfo.PageStart);
            Xom.Log(XomAreaName.socialqueryfd, "GetFriendList req.PagingInfo.PageSize = {0}", req.PagingInfo.PageSize);


            // Create the processor object that talks to the cache
            GetFriendsProcessorFD processor = new GetFriendsProcessorFD(req, sqProxy);
            try {
                processor.ProcessRequest();

                resp.TotalNumUsers = processor.TotalNumUsers;
                resp.FriendListVersion = processor.FriendListVersion;
                if(processor.Friends == null) {
                    resp.NumFriends = 0;
                } else {
                    resp.NumFriends = (uint)processor.Friends.Length;
                }
                resp.PageStartIndex = processor.FirstUserIndex;
                resp.Friends = processor.Friends;

                // Make sure the start index returned is within the proper range
                if(resp.TotalNumUsers > 0 && 
                    resp.PageStartIndex >= resp.TotalNumUsers && 
                    resp.Friends != null && 
                    resp.Friends.Length > 0) 
                {
                    resp.Friends = new SocialQueryUser[0];
                    resp.NumFriends = (uint)resp.Friends.Length;
                }

                Xom.Log(XomAreaName.socialqueryfd, "GetFriendList resp.TotalNumUsers = {0}", resp.TotalNumUsers);
                Xom.Log(XomAreaName.socialqueryfd, "GetFriendList resp.NumFriends = {0}", resp.NumFriends);
                Xom.Log(XomAreaName.socialqueryfd, "GetFriendList resp.PageStartIndex = {0}", resp.PageStartIndex);
            }
            catch(XRLException ex) {
                // Store hresult of the error and return it in the response
                resp.hr = ex.HResult;
            }

            return(resp.hr);
        }

        public override void HandleError(HResult hr, XRLObject2 xrlReq, XRLObject2 xrlResp)
        {
            GetFriendsXrlResponse resp = (GetFriendsXrlResponse)xrlResp;

            // Clear out the response in case something got written to it.
            resp.Friends           = null;
            resp.PageStartIndex    = 0;
            resp.TotalNumUsers     = 0;
            resp.NumFriends      = 0;
            resp.FriendListVersion = 0;
            // Must set hresult!
            resp.hr = hr;
        }

        protected override void FinishResponse(XRLObject2 xrlReq, XRLObject2 xrlResp, long timeElapsed)
        {
            GetFriendsXrlRequest  req  = (GetFriendsXrlRequest)xrlReq;
            GetFriendsXrlResponse resp = (GetFriendsXrlResponse)xrlResp;

            if(SGInfo.Current != null) {
                Xom.Log(XomAreaName.socialqueryfd, "GFL|{0:X}:{1}|{2:X16}|{3:X8}",
                        SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, req.RequestorXuid, resp.hr);
            }

            // Update perf counters if they're installed
            if(PerformanceCounterCategory.Exists(GetFriendsCounters.PerfCounterCategoryName)) {
                GetFriendsCounters.Counters.RequestsInProgressGetUserList.Decrement();
                GetFriendsCounters.Counters.TotalRequestsGetUserList.Increment();
                GetFriendsCounters.Counters.RequestsPerSecGetUserList.Increment();
                GetFriendsCounters.Counters.AverageExecutionTimeGetUserList.IncrementBy(timeElapsed);
                GetFriendsCounters.Counters.AverageExecutionTimeBaseGetUserList.Increment();
                if(HResult.Failed(resp.hr)) {
                    GetFriendsCounters.Counters.TotalRequestsGetUserListFailed.Increment();
                    GetFriendsCounters.Counters.RequestsPerSecGetUserListFailed.Increment();
                }
            }
        }
    }

    //-----------------------------------------------------------------------------------
    // Processor class that performs the actual work
    //-----------------------------------------------------------------------------------
    public class GetFriendsProcessorFD : GetFriendsListProcessorBase
    {
        private readonly ISocialCacheProxy scinhProxy;

        // called by the FD
        public GetFriendsProcessorFD(GetFriendsXrlRequest request, ISocialCacheProxy proxy)
        {
            scinhProxy = proxy;

            message = new GetFriendsINHRequest();
            message.data = request;
        }

        public override void ProcessRequest()
        {
            Gather();
            // Filter();   -- This API (currently) does no addional filtering
            // Sort();     -- This API (currently) leaves sorting up to the INH
            // Page();     -- This API (currently) leaves paging up to the INH
            // Decorate(); -- This API (currently) adds no additional data to the response
        }

        public override void Reply()
        {
        }

        public override void Gather()
        {
            // query the INH for the data
            ErrorReply reply;
            uint hr = scinhProxy.Query(message.data.RequestorXuid, message, out reply);

            // verify the response is what we're expecting...
            if (hr == HResult.S_OK && reply != null)
            {
                GetFriendsINHReply getFriendsReply = (GetFriendsINHReply)reply;
                friends = getFriendsReply.Friends;
                friendListVersion = getFriendsReply.FriendListVersion;
                totalNumUsers = getFriendsReply.TotalNumUsers;
                firstUserIndex = getFriendsReply.PageStartIndex;
            }
            else
            {
                throw new XRLException(hr, XEvent.Id.SOCIALCACHE_PROXY_REQUEST_FAILED, "SocialCache Proxy request failed");
            }
        }
    }

    //-----------------------------------------------------------------------------------
    // Perf counters for this API
    //-----------------------------------------------------------------------------------
    [XomPerformanceCounterCategoryAttr(PerfCounterCategoryName,
                                       "Xbox Social Query Server Performance Counters - Get Friends Requests")]
    public class GetFriendsCounters : XomPerformanceCounterCategory
    {
        // Category name for these counters
        public const string PerfCounterCategoryName = "SocialQuery FD: GetFriends Requests";

        static public GetFriendsCounters Counters = new GetFriendsCounters();

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Total",
             "Total number of GetFriends requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsGetUserList;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: In Progress",
             "Number of GetFriends requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressGetUserList;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Per Sec",
             "Number of GetFriends requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecGetUserList;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Avg. Execution Time",
             "Average GetFriends request execution time in milliseconds",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeGetUserList;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Avg. Execution Time Base",
             "Base for the average GetFriends request excution time",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseGetUserList;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Failed: Total",
             "Total number of GetFriends requests failed at the application level.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsGetUserListFailed;

        [XomPerformanceCounterAttr(
             "Requests: GetFriends: Failed: Per Sec",
             "Number of GetFriends requests failed at the application level per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecGetUserListFailed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\test\stf\SocialCacheUnitTests.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.community;
using xonline.common.protocol;
using xonline.common.config;
using System.Net;
using System.Text;

namespace SocialCacheTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class SocialCacheUnitTests : SocialCacheTestBaseGroup
    {
        static int waitTimeInMs;

        private void InitTest(bool fSleep, out PNUser user, out LimitedPresence limitedPresence, out PresenceRecord record)
        {
            uint dwState = 1;
            uint dwTitleID = 2;

            user = CreateXenonUser(false);
            record = PresenceRecord.Init(user.UserId, user.Name, dwTitleID, new xonline.common.protocol.SGADDR(), new xonline.common.community.UserPrivileges(user.UserId, new byte[32]));
            record.dtLastSeen = DateTime.UtcNow;

            // this will write the data to acceleration
            record.SetState(dwTitleID, dwState, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            limitedPresence = new LimitedPresence();
            limitedPresence.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(limitedPresence);

            if (fSleep)
            {
                Global.RO.Debug("Sleeping for 30 seconds to let our user's acceleration change notifications propogate.");
                Thread.Sleep(30000);
                if (waitTimeInMs < 30000)
                {
                    waitTimeInMs = 40000;
                }
                waitTimeInMs = waitTimeInMs - 30000;
            }
        }

        [TestCase]
        public void ReadUsersTest()
        {
            string sFailure = "ReadUsers test failed.";
            uint hr = HResult.S_OK;

            try
            {
                string[] servers = Config.GetServerListByInterface("socialcache");

                if (servers.Length == 0)
                {
                    hr = HResult.E_FAIL;
                    sFailure = "Couldn't get the server";
                }

                // Create several users
                PNUser[] users = new PNUser[5];
                LimitedPresence[] write = new LimitedPresence[5];
                PresenceRecord[] record = new PresenceRecord[5];
                for (int i = 0; i < users.Length; i++)
                {
                    InitTest(false, out users[i], out write[i], out record[i]);
                }

                Global.RO.Debug("Sleeping 30 seconds to let acceleration changes propogate.");
                Thread.Sleep(30);

                if (hr == HResult.S_OK)
                {
                    Global.RO.Debug("Sending Management command");
                    Global.RO.Debug("Server: " + servers[0]);

                    string command;

                    // Get the IP of the server to send a message to the management console.
                    IInterfaceInfo ifc = Config.GetInterface(servers[0], Interface.xmgmtsrv);
                    IPEndPoint ipEndPoint = new IPEndPoint(ifc.IPAddress, ifc.Port);
                    string result;
                    bool Succeeded;

                    // Call checkuser to verify none are in the cache.
                    for (int i = 0; i < users.Length; i++)
                    {
                        command = "exec socialcache checkuser " + users[i].UserId;
                        Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                        Assert.IsTrue(Succeeded, "Management console failed on checkuser.");
                        sFailure = "Cache user did not have status Missing.  Was: " + result;
                        Assert.IsTrue(result.Contains("Missing"), sFailure);
                    }

                    // Call lookupuser on the 3rd and 5th users to put them in the cache.
                    command = "exec socialcache lookupuser " + users[2].UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupuser.");

                    command = "exec socialcache lookupuser " + users[4].UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupuser.");

                    // Call lookupusers on all of the users and then verify the order
                    StringBuilder usersString = new StringBuilder();
                    for (int i = 0; i < users.Length; i++)
                    {
                        usersString.Append(users[i].UserId + " ");
                    }
                    command = "exec socialcache lookupusers " + usersString;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on checkuser.");
                    Global.RO.Debug("Result:\n" + result);
                    sFailure = "Readusers did not return the users in the right order, was:\n" + result;

                    // Make it so we can use splitstring to pick out the results returned in order.
                    result = result.Replace("userXuid", "&");
                    string[] splitBy = new string[1];
                    splitBy[0] = "&";
                    string[] results = result.Split(splitBy, StringSplitOptions.None);

                    // Verify we got the right number of results back, and check that the ids match up in order.
                    Assert.IsTrue(results.Length == users.Length + 1);
                    Global.RO.Debug("Split string resulted in " + results.Length + " results.");
                    for (int i = 1; i < results.Length; i++)
                    {
                        Global.RO.Debug("Checking for " + String.Format("{0:X}", users[i - 1].UserId));
                        Global.RO.Debug("in " + results[i]);
                        Assert.IsTrue(results[i].Contains(String.Format("{0:X}", users[i - 1].UserId)));
                    }

                    Global.RO.Debug("Finished Test!");
                }



            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                sFailure = String.Format("{0}, exception = {1}", sFailure, e.ToString());
            }

            Assert.IsTrue(hr == HResult.S_OK, sFailure);
        }

        [TestCase]
        public void CacheExpirationNoSettingEditTest()
        {
            string sFailure = "Cache Expiration test failed.";
            uint hr = HResult.S_OK;

            try
            {
                string[] servers = Config.GetServerListByInterface("socialcache");

                if (servers.Length == 0)
                {
                    hr = HResult.E_FAIL;
                    sFailure = "Couldn't get the server";
                }

                // Create a user
                PNUser user;
                LimitedPresence write;
                PresenceRecord record;
                InitTest(true, out user, out write, out record);

                if (hr == HResult.S_OK)
                {
                    Global.RO.Debug("Sending Management command");
                    Global.RO.Debug("Server: " + servers[0]);

                    string command = "exec socialcache checkuser " + user.UserId;

                    // Get the IP of the server to send a message to the management console.
                    IInterfaceInfo ifc = Config.GetInterface(servers[0], Interface.xmgmtsrv);
                    IPEndPoint ipEndPoint = new IPEndPoint(ifc.IPAddress, ifc.Port);
                    string result;

                    // Call checkuser on our new user and verify that the user is not in the cache.
                    bool Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Missing.  Was: " + result;
                    Assert.IsTrue(result.Contains("Missing"), sFailure);

                    // Call checkfriends to verify friends are not in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache relationship did not have status Missing.  Was: " + result;
                    Assert.IsTrue(result.Contains("Missing"), sFailure);

                    // Call lookupuser to get the user into the cache.
                    command = "exec socialcache lookupuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupuser.");

                    // Call lookupfriends to get the user into the cache.
                    command = "exec socialcache lookupfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupfriends.");

                    // Call checkuser to verify our user is found in the cache.
                    command = "exec socialcache checkuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    Global.RO.Debug("Sleeping for 30 seconds to wait for acceleration changes to propogate regarding friendslist.");
                    Thread.Sleep(30000);

                    // Call lookupfriends to get the user into the cache, an acceleration notification probably removed him.
                    command = "exec socialcache lookupfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed 2nd lookupfriends.");

                    // Call checkfriends to verify our relationship is found in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    // Expire our cache entries with xmgmt.  Set the delay for 10 seconds.
                    command = "exec socialcache expireuser " + user.UserId + " 10";
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed expireuser.");

                    command = "exec socialcache expirefriends " + user.UserId + " 10";
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed expirefriends.");

                    Global.RO.Debug("Verifying that they have not expired yet.");
                    
                    // Call checkuser to verify our user is found in the cache.
                    command = "exec socialcache checkuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    // Call checkfriends to verify our relationship is found in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    // Sleep past our 10 second expiry time.
                    Global.RO.Debug("Sleeping 15 second for expiry.");
                    Thread.Sleep(15000);

                    // Call checkuser to verify our user is expired in the cache.
                    command = "exec socialcache checkuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Expired.  Was: " + result;
                    Assert.IsTrue(result.Contains("Expired"), sFailure);

                    // Call checkfriends to verify our user is expired in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Expired.  Was: " + result;
                    Assert.IsTrue(result.Contains("Expired"), sFailure);

                    Global.RO.Debug("Finished Test!");
                }



            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                sFailure = String.Format("{0}, exception = {1}", sFailure, e.ToString());
            }

            Assert.IsTrue(hr == HResult.S_OK, sFailure);
        }

        [TestCase]
        public void CacheExpirationTest()
        {
            string sFailure = "Cache Expiration test failed.";
            uint hr = HResult.S_OK;

            try
            {
                string[] servers = Config.GetServerListByInterface("socialcache");

                waitTimeInMs = Config.GetIntSetting(Setting.config_cacheRefreshInterval) + 5000; // a few extra seconds for good measure

                if (servers.Length == 0)
                {
                    hr = HResult.E_FAIL;
                    sFailure = "Couldn't get the server";
                }

                Global.RO.Debug("Overriding SocialCache_CacheEntryExpirationTimeout to 1 second.");
                Global.XEnv.OverrideSetting("socialcache", servers[0], "SocialCache_CacheEntryExpirationTimeout", "1");

                // Create a user
                PNUser user;
                LimitedPresence write;
                PresenceRecord record;
                InitTest(true, out user, out write, out record);

                if (hr == HResult.S_OK)
                {
                    Global.RO.Debug("Sending Management command");
                    Global.RO.Debug("Server: " + servers[0]);

                    string command = "exec socialcache checkuser " + user.UserId;

                    // Get the IP of the server to send a message to the management console.
                    IInterfaceInfo ifc = Config.GetInterface(servers[0], Interface.xmgmtsrv);
                    IPEndPoint ipEndPoint = new IPEndPoint(ifc.IPAddress, ifc.Port);
                    string result;

                    // Call checkuser on our new user and verify that the user is not in the cache.
                    bool Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Missing.  Was: " + result;
                    Assert.IsTrue(result.Contains("Missing"), sFailure);

                    // Call checkfriends to verify friends are not in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache relationship did not have status Missing.  Was: " + result;
                    Assert.IsTrue(result.Contains("Missing"), sFailure);

                    // Call lookupuser to get the user into the cache.
                    command = "exec socialcache lookupuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupuser.");

                    // Call lookupfriends to get the user into the cache.
                    command = "exec socialcache lookupfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on lookupfriends.");

                    // Call checkuser to verify our user is found in the cache.
                    command = "exec socialcache checkuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    Global.RO.Debug("Sleeping for 30 seconds to wait for acceleration changes to propogate regarding friendslist.");
                    Thread.Sleep(30000);
                    if (waitTimeInMs < 30000)
                    {
                        waitTimeInMs = 40000;
                    }
                    waitTimeInMs = waitTimeInMs - 30000;

                    // Call lookupfriends to get the user into the cache, an acceleration notification probably removed him.
                    command = "exec socialcache lookupfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed 2nd lookupfriends.");

                    // Call checkfriends to verify our relationship is found in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Found.  Was: " + result;
                    Assert.IsTrue(result.Contains("Found"), sFailure);

                    Global.RO.Debug("Sleeping for another " + waitTimeInMs / 1000 + " seconds to make sure the cache expiration timeout change propogates.");
                    Thread.Sleep(waitTimeInMs);

                    // Call checkuser to verify our user is expired in the cache.
                    command = "exec socialcache checkuser " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkuser.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Expired.  Was: " + result;
                    Assert.IsTrue(result.Contains("Expired"), sFailure);

                    // Call checkfriends to verify our user is expired in the cache.
                    command = "exec socialcache checkfriends " + user.UserId;
                    Succeeded = ManagementConsole.Execute(ipEndPoint, command, out result);
                    Assert.IsTrue(Succeeded, "Management console failed on 2nd checkfriends.");
                    Global.RO.Debug("Result:\n " + result);
                    sFailure = "Cache user did not have status Expired.  Was: " + result;
                    Assert.IsTrue(result.Contains("Expired"), sFailure);

                    Global.RO.Debug("Remove override.");
                    Global.XEnv.DeleteOverrideSetting("socialcache", servers[0], "SocialCache_CacheEntryExpirationTimeout");

                    Global.RO.Debug("Finished Test!");
                }
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                sFailure = String.Format("{0}, exception = {1}", sFailure, e.ToString());
            }

            Assert.IsTrue(hr == HResult.S_OK, sFailure);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\FuncGetFriendsFull.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using xonline.common.community.socialquery;
using xonline.common.diagnostics;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.service;
using ServerTestFramework.LiveService.Presence;
using xonline.common.protocol;
using xonline.common.community;
using xonline.common.community.socialquery.protocol;
using xonline.common.protocol.socialquery;


namespace SocialQueryTest
{
    /// <summary>
    /// Summary description for FuncGetUserList.
    /// </summary>
    [TestGroup, Description("Contains long running tests that should be run individually"), TestFrequency("Individually")]
    public class FuncGetFriendsFull : SocialQueryTestBaseGroup
    {

        [TestCase, Description("Fetch entire friends list of another user who has 1000 friends.")]
        public void P_GetFriends_FullFriendsListGetAll()
        {
            int numFriends = 1000;
            int friendsListVer = numFriends * 2; // fully fledged friends

            PNUser viewer = CreateXenonUser(true);

            // Create some clean users to become the viewer's friends
            PNUser[] friends = new PNUser[numFriends];
            friends = CreateXenonUsers((uint)friends.Length, false);


            ro.Debug("Making Friends");
            for (int i = 0; i < friends.Length-2; i++)
            {
                LightWeightMakeFriends(viewer, friends[i]);
            }

            // Make a call to the heavyweight MakeFriends.  This updates the cache layer
            MakeFriends(viewer, friends[friends.Length-2]);
            MakeFriends(viewer, friends[friends.Length-1]);

            ro.Debug("Setting up response validation data...");
            SocialQueryUser[] sqFriends = SortByGamertag(friends);

            ro.Debug(string.Format("Viewer: {0}", viewer.Name));
            ro.Debug("Getting friends list for viewer sorted by gamertag...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sqFriends);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Getting friends list for viewer sorted by OnlineStatus...");
            sqFriends = SortByOnlineStatus(sqFriends);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sqFriends);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        ///// <summary>
        ///// Use this to debug  P_GetFriends_FullFriendsListGetAll
        ///// </summary>
        //[TestCase, Description("Fetch entire friends list of another user who has 1000 friend. Used to debug P_GetFriends_FullFriendsListGetAll")]
        //public void P_GetFriends_FullFriendsListGetAll_DEBUG()
        //{
        //    // Put the gamertag of the created user here.
        //    PNUser viewer = GetUser("AAaegqaaaaaaeqa");
        //    GetFriendsXrlResponse response = viewer.GetFriendsList(GetFriendSortType.Gamertag, 1000, 0);

        //    if (0 != response.hr) throw new Exception("HR Does not match!");
        //    ValueCheck.Test("Requestor Xuid", viewer.UserId, response.RequestorXuid);
        //    ValueCheck.Test("Friend List Version", 2000, response.FriendListVersion);
        //    ValueCheck.Test("Total Friend count", 1000, response.TotalNumUsers);
        //    ValueCheck.Test("Page Start Index", 0, response.PageStartIndex);
        //    ValueCheck.Test("Returned user count", 1000, response.NumFriends);
        //    ValueCheck.Test("Number of returned users array count", 1000, response.Friends.Length);

        //    for (int i = 0; i < response.Friends.Length - 1; i++)
        //    {
        //        if (string.Compare(response.Friends[i].Gamertag, response.Friends[i + 1].Gamertag) >= 0) throw new Exception("Gamertags are in the wrong order!");
        //    }
        //}

        [TestCase, Description("Fetch entire friends list of another user who has 1000 pending sent friends.")]
        public void P_GetFriends_FullFriendsListAllPendingSent()
        {
            int numFriends = 1000;
            int friendsListVer = numFriends; // friends request sent friends

            PNUser viewer = CreateXenonUser(true);

            // Create some clean users to become the viewer's friends
            PNUser[] friends = new PNUser[numFriends];
            friends = CreateXenonUsers((uint)friends.Length, false);

            ro.Debug("Sending Friend Requests");
            for (int i = 0; i < friends.Length - 2; i++)
            {
                LightWeightMakePendingFriends(viewer, friends[i]);
            }

            // Make a call to the heavyweight MakePending.  This updates the cache layer
            MakePendingFriends(viewer, friends[friends.Length - 2]);
            MakePendingFriends(viewer, friends[friends.Length - 1]);

            ro.Debug("Setting up response validation data...");
            SocialQueryUser[] sqUsers = new SocialQueryUser[numFriends];
            for (int i = 0; i < numFriends; i++)
            {
                sqUsers[i] = InitSocialQueryUser(friends[i], new SQUserFlag_FriendStatus(eFriendshipState.eSentRequest));
            }
            SocialQueryUser[] sortedFriends = SortByGamertag(sqUsers);

            ro.Debug(string.Format("Viewer: {0}", viewer.Name));
            ro.Debug("Getting friends list for viewer sorted by gamertag...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sortedFriends);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Getting friends list for viewer sorted by OnlineStatus...");
            sortedFriends = SortByOnlineStatus(sqUsers);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sortedFriends);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase, Description("Fetch entire friends list of another user who has 1000 pending received friends.")]
        public void P_GetFriends_FullFriendsListAllPendingReceived()
        {
            int numFriends = 1000;
            int friendsListVer = numFriends; // friends request sent friends

            PNUser viewer = CreateXenonUser(true);

            // Create some clean users to become the viewer's friends
            PNUser[] friends = new PNUser[numFriends];
            friends = CreateXenonUsers((uint)friends.Length, false);

            ro.Debug("Sending Friend Requests");
            for (int i = 0; i < friends.Length - 2; i++)
            {
                LightWeightMakePendingFriends(friends[i], viewer);
            }

            // Make a call to the heavyweight MakePendingFriends.  This updates the cache layer
            MakePendingFriends(friends[friends.Length - 2], viewer);
            MakePendingFriends(friends[friends.Length - 1], viewer, true);

            ro.Debug("Setting up response validation data...");
            SocialQueryUser[] sqUsers = new SocialQueryUser[numFriends];
            for (int i = 0; i < numFriends; i++)
            {
                sqUsers[i] = InitSocialQueryUser(friends[i], new SQUserFlag_FriendStatus(eFriendshipState.eReceivedRequest));
            }
            SocialQueryUser[] sortedFriends = SortByGamertag(sqUsers);


            ro.Debug(string.Format("Viewer: {0}", viewer.Name));
            ro.Debug("Getting friends list for viewer sorted by gamertag...");
            GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sortedFriends);
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(GetFriendSortType.Gamertag, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);

            ro.Debug("Getting friends list for viewer sorted by OnlineStatus...");
            sortedFriends = SortByOnlineStatus(sqUsers);
            expectedResponse = InitExpectedGetFriendsResponse(viewer, friendsListVer, numFriends, 0, sortedFriends);
            replyData = viewer.GetFriendsList(GetFriendSortType.OnlineStatus, numFriends, 0);
            ValidateGetFriendsXrlResponse(replyData, expectedResponse);
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_FullFriendsListAllOffline()
        {
            PNUser user;
            int maximumFriendsCount = 250;

            OnlineStatusVariation[] osvs = new OnlineStatusVariation[maximumFriendsCount];

            OnlineStatusVariation[] allOfflineScenarios = new OnlineStatusVariation[]
                {
                new OnlineStatusVariation(false, ePrivacySetting.Blocked, false, false),
                new OnlineStatusVariation(false, ePrivacySetting.Blocked, true, false),
                new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, false, false),
                new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, true, false),
                new OnlineStatusVariation(false, ePrivacySetting.Everyone, true, false),
                new OnlineStatusVariation(true, ePrivacySetting.Blocked, false, false),
                new OnlineStatusVariation(true, ePrivacySetting.Blocked, true, false),
                new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, true, false),
                new OnlineStatusVariation(true, ePrivacySetting.Everyone, true, false),
                };

            // fill out the friends list with all these combinations
            int fillerCount = maximumFriendsCount / allOfflineScenarios.Length;
            int modCount = maximumFriendsCount % allOfflineScenarios.Length;

            for (int i = 0; i < fillerCount; ++i)
            {
                for (int j = 0; j < allOfflineScenarios.Length; ++j)
                {
                    osvs[i * allOfflineScenarios.Length + j] = new OnlineStatusVariation(allOfflineScenarios[j].isAccepted, allOfflineScenarios[j].presencePrivacy, allOfflineScenarios[j].appearOffline, allOfflineScenarios[j].stateVisible);
                }
            }
            for (int j = 0; j < modCount; ++j)
            {
                osvs[fillerCount * allOfflineScenarios.Length + j] = new OnlineStatusVariation(allOfflineScenarios[j].isAccepted, allOfflineScenarios[j].presencePrivacy, allOfflineScenarios[j].appearOffline, allOfflineScenarios[j].stateVisible);
            }

            ro.Debug("Generated max number of friends: {0} who should all be offline upon querying", maximumFriendsCount);
            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, maximumFriendsCount, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    // They all must be offline
                    Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");
                }
            }
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_FullFriendsListAllOnline()
        {
            PNUser user;
            int maximumFriendsCount = 250;

            OnlineStatusVariation[] osvs = new OnlineStatusVariation[maximumFriendsCount];

            OnlineStatusVariation[] allOnlineScenarios = new OnlineStatusVariation[]
                {
                    new OnlineStatusVariation(false, ePrivacySetting.Everyone, false, true),
                    new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, false, true),
                    new OnlineStatusVariation(true, ePrivacySetting.Everyone, false, true),
                };

            // fill out the friends list with all these combinations
            int fillerCount = maximumFriendsCount / allOnlineScenarios.Length;
            int modCount = maximumFriendsCount % allOnlineScenarios.Length;

            for (int i = 0; i < fillerCount; ++i)
            {
                for (int j = 0; j < allOnlineScenarios.Length; ++j)
                {
                    osvs[i * allOnlineScenarios.Length + j] = new OnlineStatusVariation(allOnlineScenarios[j].isAccepted, allOnlineScenarios[j].presencePrivacy, allOnlineScenarios[j].appearOffline, allOnlineScenarios[j].stateVisible);
                }
            }
            for (int j = 0; j < modCount; ++j)
            {
                osvs[fillerCount * allOnlineScenarios.Length + j] = new OnlineStatusVariation(allOnlineScenarios[j].isAccepted, allOnlineScenarios[j].presencePrivacy, allOnlineScenarios[j].appearOffline, allOnlineScenarios[j].stateVisible);
            }

            Global.RO.Info("Generated max number of friends: {0} who should all be offline upon querying", maximumFriendsCount);
            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, maximumFriendsCount, 0);

            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));

            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    // They all must be online
                    Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\FuncGetFriendsActivity.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.SocialQuery;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.community;
using xonline.common.community.socialquery;
using xonline.common.config;
using xonline.common.protocol.socialquery;

namespace SocialQueryTest
{
    [TestGroup, Description("Contains tests that should be run with > 4 titles in an environemnt"), TestFrequency("Daily")]
    public class FuncGetFriendsActivity : SocialQueryTestBaseGroup
    {

        private int _minNumberTitles = 4;
        private int _numFriends = 12;
        uint[] _titles = null;

        [TestGroupSetup]
        public void Test_Group_Setup()
        {
            // Let the fake SG know where to send state updates
            // This is REQUIRED for users to be truly on line.
            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

            uint[] temptitles = FriendsCommon.GetListOfProppedTitleIds();
            List<uint> titleList = new List<uint>(temptitles.Length);

            ro.Info(string.Format("Found {0} titles", temptitles.Length));
            TitleStringFetcher fetcher = new TitleStringFetcher();
            foreach (uint titleId in temptitles)
            {
                try
                {
                    ro.Info(fetcher.GetTitleString(titleId, 36));
                    titleList.Add(titleId);
                }
                catch (Exception e)
                {
                    ro.Info(string.Format("Hit error '{0}' for title id: {1}", e.Message, titleId));
                }
            }

            _titles = titleList.ToArray();

            if (_titles.Length < _minNumberTitles)
            {
                ro.Error(string.Format("Need at least {0} titles to run this test. Found {1}", _minNumberTitles, _titles.Length));
                ro.Error("Install titles by: 1) Copy titles to C:\\esp\\titlesource. 2)Run C:\\esp\\tpp\\tpp.exe /env:xblob /title:[titleId]. 3) try again.");
                throw new Exception("Not enough titles");
            }
        }

        [TestCase, Description("Fetch friends list sorted by activity.")]
        public void P_GetFriends_Activity_BVT()
        {
            Random ran = new Random();
            uint requestedTitleId = _titles[ran.Next(_titles.Length)];

            ro.Debug("Making users");
            PNUser viewer; // = CreateXenonUser(true);
            // Create some clean users to become the viewer's friends
            PNUser[] friends = GenerateUserMatrix(out viewer, _numFriends, requestedTitleId);


            ro.Info("Sleeping for 5 seconds for acceleration notifications to trickle through.");
            Thread.Sleep(TimeSpan.FromSeconds(5));
            ro.Debug("Getting friends list...");
            GetFriendsXrlResponse replyData = viewer.GetFriendsList(viewer.UserId, 
                viewer.UserId, 
                GetFriendSortType.Activity, 
                requestedTitleId, 
                36, //36 == En-Us
                friends.Length, 
                0, 
                HResult.S_OK);

            ro.Info(string.Format("Requested title: {0}", new TitleStringFetcher().GetTitleString(requestedTitleId, 36))); // 36 is En-Us
            ValidateActivitySort(requestedTitleId,
                friends,
                replyData.Friends);
        }

        private void ValidateActivitySort(uint requestedTitleId,
            PNUser[] createdUsers,
            SocialQueryUser[] returnedUsers)
        {

            Hashtable titlesAndNames = GetUsEnTitleNames(_titles);
            string titleName = string.Empty;

            // debug:
            for (int idx = 0; idx < createdUsers.Length; idx++)
            {
                titleName = (titlesAndNames[returnedUsers[idx].TitleId] == null) ? string.Empty : titlesAndNames[returnedUsers[idx].TitleId].ToString();
                // Debug line:
                Global.RO.Debug(string.Format("Xuid: {0}\tTitle: {1} [{4}]\tGT:{2}\tFlags:{3}",
                    returnedUsers[idx].Xuid,
                    returnedUsers[idx].TitleId,
                    returnedUsers[idx].Gamertag,
                    returnedUsers[idx].Flags,
                    titleName));
            }

            ValueCheck.Test("first user's title", returnedUsers[0].TitleId, requestedTitleId);
            ActivitySortValidationState validationState = ActivitySortValidationState.RequestedTitle;

            // walk through the array and ensure the correct sorts were performed.
            for (int idx = 1; idx < createdUsers.Length; idx++)
            {
                ro.Debug(string.Format("Testing user {0}", idx));

                // Debug line:
                Global.RO.Debug(string.Format("Xuid: {0} \tTitle: {1} [{4}]\tGT:{2}\tFlags:{3}",
                    returnedUsers[idx].Xuid,
                    returnedUsers[idx].TitleId,
                    returnedUsers[idx].Gamertag,
                    returnedUsers[idx].Flags,
                    titlesAndNames[returnedUsers[idx].TitleId].ToString()));

                switch(validationState)
                {
                    case ActivitySortValidationState.RequestedTitle:
                        ValueCheck.Test("Online state", 
                            returnedUsers[idx].Flags & SocialQueryDefs.SQ_FLAG_ONLINE, 
                            SocialQueryDefs.SQ_FLAG_ONLINE);
                        ValueCheck.Test("title string", 
                            titlesAndNames[returnedUsers[idx].TitleId].ToString(), 
                            titlesAndNames[returnedUsers[idx - 1].TitleId].ToString());
                        ValueCheck.TestLessThan("Gamertag", 
                            returnedUsers[idx].Gamertag, 
                            returnedUsers[idx - 1].Gamertag);
                        break;

                    case ActivitySortValidationState.OnlineFullFriends:
                        ValueCheck.Test("Online state",
                            returnedUsers[idx].Flags & SocialQueryDefs.SQ_FLAG_ONLINE,
                            SocialQueryDefs.SQ_FLAG_ONLINE);

                        // Don't do additional tests on the first entry after the requested title
                        if (returnedUsers[idx - 1].TitleId != requestedTitleId)
                        {
                            if (returnedUsers[idx].TitleId != returnedUsers[idx - 1].TitleId)
                            {
                                // Only check the title if it's a new title
                                ValueCheck.TestLessThan("title string",
                                    titlesAndNames[returnedUsers[idx].TitleId].ToString(),
                                    titlesAndNames[returnedUsers[idx - 1].TitleId].ToString());
                            }
                            else
                            {
                                // Only check the gamertag if the previous user is playing the same title.
                                ValueCheck.TestLessThan("Gamertag",
                                    returnedUsers[idx].Gamertag,
                                    returnedUsers[idx - 1].Gamertag);
                            }
                        }
                        break;

                    case ActivitySortValidationState.OfflineAndPendingFriends:
                        if (IsFriendOfflineOrPending(returnedUsers[idx - 1]))
                        {
                            ValueCheck.TestLessThan("Gamertag",
                                    returnedUsers[idx].Gamertag,
                                    returnedUsers[idx - 1].Gamertag);
                        }
                        break;
                }

                if (idx + 1 < createdUsers.Length)
                {
                    if (validationState == ActivitySortValidationState.RequestedTitle && 
                        requestedTitleId != returnedUsers[idx + 1].TitleId)
                    {
                        validationState = ActivitySortValidationState.OnlineFullFriends;
                    }

                    if (validationState == ActivitySortValidationState.OnlineFullFriends &&
                        IsFriendOfflineOrPending(returnedUsers[idx + 1]))
                    {
                        validationState = ActivitySortValidationState.OfflineAndPendingFriends;
                    }
                }
            }
        }

        private enum ActivitySortValidationState
        {
            RequestedTitle,
            OnlineFullFriends,
            OfflineAndPendingFriends
        }

        private bool IsFriendOfflineOrPending(SocialQueryUser user)
        {
            return (SocialQueryDefs.SQ_FLAG_ONLINE != (user.Flags & SocialQueryDefs.SQ_FLAG_ONLINE) ||
                    SocialQueryDefs.SQ_FLAG_SENTREQUEST == (user.Flags & SocialQueryDefs.SQ_FLAG_SENTREQUEST) ||
                    SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST == (user.Flags & SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST));
        }

        private Hashtable GetUsEnTitleNames(uint[] titleIds)
        {
            Hashtable table = new Hashtable(titleIds.Length);
            TitleStringFetcher fetcher = new TitleStringFetcher();

            foreach (uint title in titleIds)
            {
                try
                {
                    table.Add(title, fetcher.GetTitleString(title, 36)); //36 = US-EN.
                }
                catch
                {
                    // Swallow it.
                }
            }

            return table;
        }

        private PNUser[] GenerateUserMatrix(out PNUser user, int numFriends, uint requestedTitleId)
        {
            user = CreateXenonUser(false);
            PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
            user.Connect(xbox);
            Global.RO.Info("Created initial user {0} [{0:x}]", user.UserId);

            Random ran = new Random();

            PNUser[] friends = new PNUser[numFriends];

            PNUser tempUser = null;
            bool appearOffline;
            for(int idx=0; idx<friends.Length; idx++)
            {
                tempUser = CreateXenonUser(false);
                PNXbox xbox2 = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
                tempUser.Connect(xbox2);
                appearOffline = false;

                uint titleId = 0;
                ro.Debug("Setting title & making friends");
                switch (idx)
                {
                    case 3:
                        // A pending friend request sent
                        FriendsListUtil.Add(user.UserId, tempUser.UserId, user.Name, tempUser.Name);
                        titleId = requestedTitleId;
                        break;
                    case 4:
                        // A pending friend request recieved
                        FriendsListUtil.Add(tempUser.UserId, user.UserId, tempUser.Name, user.Name);
                        titleId = requestedTitleId;
                        break;
                    case 7:
                        // An offline full friend.
                        FriendsListUtil.MakeFriends(user.UserId, tempUser.UserId, user.Name, tempUser.Name);
                        titleId = requestedTitleId;
                        appearOffline = true;
                        break;
                    default:
                        // online full friends
                        FriendsListUtil.MakeFriends(user.UserId, tempUser.UserId, user.Name, tempUser.Name);
                        titleId = (uint)_titles[ran.Next(_titles.Length)];
                        break;
                }

                if (idx == friends.Length - 1)
                {
                    titleId = requestedTitleId;
                }

                Global.RO.Info("Logon user {0} [{0:x}].", tempUser.UserId);
                _fc.LogonUser(tempUser, titleId, appearOffline);

                friends[idx] = tempUser;
            }

            return friends;
        }

        ///// <summary>
        ///// Use this to debug  P_GetFriends_FullFriendsListGetAll
        ///// </summary>
        //[TestCase, Description("Fetch entire friends list of another user who has 1000 friend. Used to debug P_GetFriends_FullFriendsListGetAll")]
        //public void P_GetFriends_FullFriendsListGetAll_DEBUG()
        //{
        //    // Put the gamertag of the created user here.
        //    PNUser viewer = GetUser("AAaegqaaaaaaeqa");
        //    GetFriendsXrlResponse response = viewer.GetFriendsList(GetFriendSortType.Gamertag, 1000, 0);

        //    if (0 != response.hr) throw new Exception("HR Does not match!");
        //    ValueCheck.Test("Requestor Xuid", viewer.UserId, response.RequestorXuid);
        //    ValueCheck.Test("Friend List Version", 2000, response.FriendListVersion);
        //    ValueCheck.Test("Total Friend count", 1000, response.TotalNumUsers);
        //    ValueCheck.Test("Page Start Index", 0, response.PageStartIndex);
        //    ValueCheck.Test("Returned user count", 1000, response.NumSqFriends);
        //    ValueCheck.Test("Number of returned users array count", 1000, response.Friends.Length);

        //    for (int i = 0; i < response.Friends.Length-1; i++)
        //    {
        //        if (string.Compare(response.Friends[i].Gamertag, response.Friends[i + 1].Gamertag) >= 0) throw new Exception("Gamertags are in the wrong order!");
        //    }
        //}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\NegGetFriends.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.SocialQuery;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;
using System.Collections.Generic;
using System.Diagnostics;
using ServerTestFramework.LiveService.Auth;
using xonline.common.protocol.socialquery;
using xonline.common.community;
using xonline.common.community.socialquery;
using xonline.common.community.socialquery.protocol;
using xonline.server.socialquery.fd;
using Microsoft.MMF;


namespace SocialQueryTest
{
    /// <summary>
    /// Summary description for FuncGetUserList.
    /// </summary>
    [TestGroup]
    public class NegGetFriends : SocialQueryTestBaseGroup
    {
        [TestCase, Description("Attempt to get friends list request fails with E_FAIL.")]
        public void N_GetFriends_CacheFail()
        {
            StubObjectWrapper<ISocialCacheProxy> cacheWrapper = StubFactory.Create<ISocialCacheProxy>();

            GetFriends handler = new GetFriends();

            GetFriendsXrlRequest Req = new GetFriendsXrlRequest();
            GetFriendsXrlResponse Resp = new GetFriendsXrlResponse();
            SocialCacheMessageHeader Header = new SocialCacheMessageHeader();
            ErrorReply ProxyReply = new ErrorReply(SOCIALCACHE_MESSAGE_TYPES.eErrorINHReply);

            Req.SortType = GetFriendSortType.Gamertag;
            Req.RequestorXuid = 0L;
            Req.PagingInfo = new PagingInfo();
            Req.PagingInfo.PageSize = 10;
            Req.PagingInfo.PageStart = 0;
            Req.PagingInfo.FocusXuid = 0L;

            GetFriendsINHReply iNHReply = new GetFriendsINHReply();
            iNHReply.FriendListVersion = 0;
            iNHReply.Friends = new SocialQueryUser[0];
            iNHReply.NumSqFriends = 0;
            iNHReply.PageStartIndex = 0;
            iNHReply.TotalNumUsers = 0;

            GetFriendsXrlResponse expected = IntializeExpectedData(HResult.E_FAIL, 0L, iNHReply);

            using (Recorder.StartUnorderedRecording())
            {
                cacheWrapper.
                   IgnoresAllArguments().
                   AssignsOutParameters(iNHReply).
                   AndReturns(HResult.E_FAIL).
                   On(c => c.Query(0L, Header, out ProxyReply));
            }

            xonline.common.service.HResult hr = handler.GenerateResponse(Req, Resp, cacheWrapper.Target);

            if (hr != xonline.common.service.HResult.S_OK)
            {
                handler.HandleError(hr, Req, Resp);
            }

            ValidateResponse(Resp, expected);
        }

        [TestCase, Description("Attempt to get friends list request fails with E_ABORT.")]
        public void N_GetFriends_CacheAbort()
        {
            StubObjectWrapper<ISocialCacheProxy> cacheWrapper = StubFactory.Create<ISocialCacheProxy>();

            GetFriends handler = new GetFriends();

            GetFriendsXrlRequest Req = new GetFriendsXrlRequest();
            GetFriendsXrlResponse Resp = new GetFriendsXrlResponse();
            SocialCacheMessageHeader Header = new SocialCacheMessageHeader();
            ErrorReply ProxyReply = new ErrorReply(SOCIALCACHE_MESSAGE_TYPES.eErrorINHReply);

            Req.SortType = GetFriendSortType.Gamertag;
            Req.RequestorXuid = 0L;
            Req.PagingInfo = new PagingInfo();
            Req.PagingInfo.PageSize = 10;
            Req.PagingInfo.PageStart = 0;
            Req.PagingInfo.FocusXuid = 0L;

            GetFriendsINHReply iNHReply = new GetFriendsINHReply();
            iNHReply.FriendListVersion = 0;
            iNHReply.Friends = new SocialQueryUser[0];
            iNHReply.NumSqFriends = 0;
            iNHReply.PageStartIndex = 0;
            iNHReply.TotalNumUsers = 0;

            GetFriendsXrlResponse expected = IntializeExpectedData(HResult.E_FAIL, 0L, iNHReply);

            using (Recorder.StartUnorderedRecording())
            {
                cacheWrapper.
                   IgnoresAllArguments().
                   AssignsOutParameters(iNHReply).
                   AndReturns(HResult.E_FAIL).
                   On(c => c.Query(0L, Header, out ProxyReply));
            }

            xonline.common.service.HResult hr = handler.GenerateResponse(Req, Resp, cacheWrapper.Target);

            if (hr != xonline.common.service.HResult.S_OK)
            {
                handler.HandleError(hr, Req, Resp);
            }

            ValidateResponse(Resp, expected);
        }

        [TestCase, Description("Attempt to get friends list gets back a mismatch in FL length and friends.")]
        public void N_GetFriends_ListLengthMismatch()
        {
            StubObjectWrapper<ISocialCacheProxy> cacheWrapper = StubFactory.Create<ISocialCacheProxy>();

            GetFriends handler = new GetFriends();

            GetFriendsXrlRequest Req = new GetFriendsXrlRequest();
            GetFriendsXrlResponse Resp = new GetFriendsXrlResponse();
            SocialCacheMessageHeader Header = new SocialCacheMessageHeader();
            ErrorReply ProxyReply = new ErrorReply(SOCIALCACHE_MESSAGE_TYPES.eErrorINHReply);

            Req.SortType = GetFriendSortType.Gamertag;
            Req.RequestorXuid = 0L;
            Req.PagingInfo = new PagingInfo();
            Req.PagingInfo.PageSize = 10;
            Req.PagingInfo.PageStart = 0;
            Req.PagingInfo.FocusXuid = 0L;

            SocialQueryUser friend = new SocialQueryUser(1L, "friend", 0, 0, 0);

            GetFriendsINHReply iNHReply = new GetFriendsINHReply();
            iNHReply.FriendListVersion = 2;
            iNHReply.Friends = new SocialQueryUser[] { friend };
            iNHReply.NumSqFriends = 2;
            iNHReply.PageStartIndex = 0;
            iNHReply.TotalNumUsers = 2;

            GetFriendsXrlResponse expected = IntializeExpectedData(HResult.S_OK, 0L, iNHReply);

            using (Recorder.StartUnorderedRecording())
            {
                cacheWrapper.
                   IgnoresAllArguments().
                   AssignsOutParameters(iNHReply).
                   AndReturns(HResult.S_OK).
                   On(c => c.Query(0L, Header, out ProxyReply));
            }

            xonline.common.service.HResult hr = handler.GenerateResponse(Req, Resp, cacheWrapper.Target);

            if (hr != xonline.common.service.HResult.S_OK)
            {
                handler.HandleError(hr, Req, Resp);
            }

            ValidateResponse(Resp, expected);
        }

        private GetFriendsXrlResponse IntializeExpectedData(xonline.common.service.HResult expectedHr, 
            ulong expectedXuid,
            GetFriendsINHReply data)
        {
            GetFriendsXrlResponse returnValue = new GetFriendsXrlResponse();

            returnValue.hr = expectedHr;
            returnValue.RequestorXuid = expectedXuid;
            returnValue.FriendListVersion = data.FriendListVersion;
            returnValue.Friends = data.Friends;
            returnValue.NumFriends = (uint)data.Friends.Length;
            returnValue.PageStartIndex = (data.PageStartIndex < returnValue.TotalNumUsers) ? data.PageStartIndex : 0;
            returnValue.TotalNumUsers = (data.TotalNumUsers < returnValue.NumFriends) ? returnValue.NumFriends : data.TotalNumUsers;
            return returnValue;
        }

        private void ValidateResponse(GetFriendsXrlResponse actual, GetFriendsXrlResponse expected)
        {
            if (expected.hr != actual.hr)
                throw new Exception("HR value mismatch");

            if (expected.NumFriends != actual.NumFriends)
                throw new Exception("NumFriends value mismatch");

            if (expected.PageStartIndex != actual.PageStartIndex)
                throw new Exception("PageStartIndex value mismatch");
            
            if (expected.FriendListVersion != actual.FriendListVersion)
                throw new Exception("Friends List Version value mismatch");

            if (expected.RequestorXuid != actual.RequestorXuid)
                throw new Exception("RequestorXuid value mismatch");

            if (expected.TotalNumUsers != actual.TotalNumUsers)
                throw new Exception("TotalNum value mismatch");

            if (expected.Friends.Length != (actual.Friends == null ? 0 : actual.Friends.Length))
                throw new Exception("Friend list length mismatch");

            for (int idx=0; idx < expected.Friends.Length; idx++)
            {
                if (expected.Friends[idx].Xuid != actual.Friends[idx].Xuid)
                {
                    throw new Exception(string.Format("Friend mismatch at index {0}", idx));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\statsfrontdoorutil.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Schema;

using xonline.common.config;
using xonline.common.leaderboard;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.xlastutil;
using xonline.server.stats.common;

namespace xonline.stats.admin
{
    class StatFrontDoorUtilities
    {
        //This will call into the stats Front Door and check if the user has a ranked entry on this leaderboard
        public static  bool IsUserMemberOfLeaderboard(ulong ulPuid, uint uiTitleID, uint uiLbID)
        {   
            StatsReadRequest objStatRead = new StatsReadRequest();

            objStatRead.TitleId = uiTitleID;
            objStatRead.Users = new ulong[1];
            objStatRead.Users[0]= ulPuid;
            objStatRead.UserCount = (uint)objStatRead.Users.Length;

            objStatRead.Specs = new StatsSpec[1];
            objStatRead.Specs[0] = new StatsSpec();
            objStatRead.Specs[0].ViewId = uiLbID;

            objStatRead.SpecCount = (uint)objStatRead.Specs.Length;
            
            MemoryStream objMemStream = new MemoryStream();
            BinaryWriter objBinWriter = new BinaryWriter(objMemStream);
            objStatRead.WriteStream(objBinWriter);
            
            XrlRequest objXrlReq = new XrlRequest();
            objXrlReq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
            objXrlReq.PostData = objMemStream.ToArray();
            objXrlReq.AuthData = new HTTPAuthData().GetBase64EncodedString();

            objXrlReq.Path     = objStatRead.GetXRL();
            
            uint hr = objXrlReq.Send();
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Error While calling Stats FD IsUserMemberOfLeaderboard hr {0}", hr));
            }

            StatsReadResponse objResponse = new StatsReadResponse();

            objResponse.ReadBytes(objXrlReq.ResponseData);

            return (objResponse.Results[0].Rows[0].Rank > 0);
        }

        public static void DeleteUserFromLeaderboard(ulong ulPuid, uint uiTitleID, uint uiLbID)
        {
            if (0 == ulPuid)
            {
                throw new Exception("StatsFrontDoorUtilities:DeleteUserFromLeaderboard can't accept a 0 user puid");
            }

            MsgReset msgReset = new MsgReset();

            msgReset.titleId = uiTitleID;
            msgReset.userId  = ulPuid;
            msgReset.leaderBoardType = uiLbID;

            MemoryStream objMemStream = new MemoryStream();
            BinaryWriter objBinWriter = new BinaryWriter(objMemStream);
            msgReset.WriteTo(objBinWriter);
            
            XrlRequest objXrlReq = new XrlRequest();
            objXrlReq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
            objXrlReq.PostData = objMemStream.ToArray();
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, ulPuid, uiTitleID, 0, 0);
            objXrlReq.AuthData = authData.GetBase64EncodedString();
            objXrlReq.Path     = msgReset.GetXRL();
            
            uint hr = objXrlReq.Send();
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Error While calling Stats FD DeleteUserFromLeaderboard hr {0}",hr));
            }
        }
        
    }
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\SocialQueryPrivacy.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using xonline.common.community.socialquery;
using xonline.common.diagnostics;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.service;
using ServerTestFramework.LiveService.Presence;
using xonline.common.protocol;
using xonline.common.community;
using xonline.common.community.socialquery.protocol;
using xonline.common.protocol.socialquery;

namespace SocialQueryTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncGetFriendsPrivacyTests : SocialQueryTestBaseGroup
    {
        [TestCase]
        public void P_GetFriends_CheckPrivacy_Legacy()
        {
            // This checks privacy through legacy APIs (GetFriendsList from presence fd)
            // This uses the same variation list that should be used by the INH tests and ensures that
            // the semantics are the same with both mechanisms.
            PNUser user;
            OnlineStatusVariation[] osvs = GenerateOnlineStatusVariations();
            GenerateFriendsWithPrivacy(osvs, out user);

            // retrieve the friends list
            PGetFriendsListReplyMsgData friendMsg = user.GetFriendsList(user);
            ServerTestFramework.LiveService.Presence.GetFriendsListData[] friends = friendMsg.rgFriends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(friendMsg.cdwFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friendMsg.cdwFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                ServerTestFramework.LiveService.Presence.GetFriendsListData userData = Array.Find(friends, x => x.BuddyID == osv.user.UserId);
                Assert.IsTrue(userData != null, "Could not find user in result set!");

                if (userData != null)
                {
                    if (osv.stateVisible)
                        Assert.IsTrue((userData.OnlineState & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
                    else
                        Assert.IsTrue((userData.OnlineState & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");
                }
            }
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_RegularCases()
        {
            PNUser user;
            OnlineStatusVariation[] osvs = GenerateOnlineStatusVariations();
            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);

            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));

            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    if (osv.stateVisible)
                        Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
                    else
                        Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");
                }
            }
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_TargetRealStateOffline()
        {
            PNUser user;
            OnlineStatusVariation[] osvs = new OnlineStatusVariation[]{
                                                  new OnlineStatusVariation(false, ePrivacySetting.Blocked, false, false),
                                                  new OnlineStatusVariation(false, ePrivacySetting.Blocked, true, false),
                                          };

            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            Global.RO.Info("Setting all Friends' Real State to Offline");
            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");
                LogoffUser(osv.user);
            }
            WaitForCacheToUpdate();

            replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should be offline if their real state is offline");
                }
            }

        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_TargetAppearOffline()
        {
            PNUser user;
            bool appearOffline = true;

            OnlineStatusVariation[] osvs = 
                new OnlineStatusVariation[]{
                                              new OnlineStatusVariation(false, ePrivacySetting.Blocked, appearOffline, false),
                                              new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, appearOffline, false),
                                              new OnlineStatusVariation(false, ePrivacySetting.Everyone, appearOffline, false),
                                              new OnlineStatusVariation(true, ePrivacySetting.Blocked, appearOffline, false),
                                              new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, appearOffline, false),
                                              new OnlineStatusVariation(true, ePrivacySetting.Everyone, appearOffline, false),
                                              new OnlineStatusVariation(false, ePrivacySetting.Blocked, appearOffline, true),
                                              new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, appearOffline, true),
                                              new OnlineStatusVariation(false, ePrivacySetting.Everyone, appearOffline, true),
                                              new OnlineStatusVariation(true, ePrivacySetting.Blocked, appearOffline, true),
                                              new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, appearOffline, true),
                                              new OnlineStatusVariation(true, ePrivacySetting.Everyone, appearOffline, true),
                                      };


            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should be offline if appear offline = true");
                }
            }

        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_TargetPrivacyBlocked()
        {
            PNUser user;
            ePrivacySetting blockedPrivacySetting = ePrivacySetting.Blocked;

            OnlineStatusVariation[] osvs = 
                new OnlineStatusVariation[]{
                                              new OnlineStatusVariation(false, blockedPrivacySetting, false, false),
                                              new OnlineStatusVariation(false, blockedPrivacySetting, false, false),
                                              new OnlineStatusVariation(false, blockedPrivacySetting, true, false),
                                              new OnlineStatusVariation(false, blockedPrivacySetting, true, false),
                                              new OnlineStatusVariation(true, blockedPrivacySetting, false, false),
                                              new OnlineStatusVariation(true, blockedPrivacySetting, false, false),
                                              new OnlineStatusVariation(true, blockedPrivacySetting, true, false),
                                              new OnlineStatusVariation(true, blockedPrivacySetting, true, false),
                                      };

            GenerateFriendsWithPrivacy(osvs, out user);

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            // make sure each user in the list has the expected state
            Assert.IsTrue(replyData.NumFriends == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == osvs.Length, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            foreach (OnlineStatusVariation osv in osvs)
            {
                // find the user in the result set
                SocialQueryUser friend = Array.Find(friends, x => x.Xuid == osv.user.UserId);
                Assert.IsTrue(friend != null, "Could not find user in result set!");

                if (friend != null)
                {
                    Assert.IsTrue((friend.Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should be offline if privacy setting = blocked");
                }
            }
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_TargetChangeRealState()
        {
            PNUser user;

            OnlineStatusVariation[] osvs = 
                new OnlineStatusVariation[]{ 
                                            new OnlineStatusVariation(false, ePrivacySetting.Everyone, false, true),
                                            };

            GenerateFriendsWithPrivacy(osvs, out user);
            WaitForCacheToUpdate();

            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            Global.RO.Info("Verifying one pending Friend, appear Offline = false, privacy setting = Everybody");

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            // verify the friend is online
            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");

            // log off friend
            Global.RO.Info("Logging off friend");
            LogoffUser(osvs[0].user, true);
            WaitForCacheToUpdate();

            replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            friends = replyData.Friends;

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == 0, "User should appear offline but doesn't");

            // log on friend
            Global.RO.Info("Logging on friend again");
            LogonUser(osvs[0].user, true);

            replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            friends = replyData.Friends;

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
        }

        [TestCase]
        public void P_GetFriends_CheckPrivacy_TargetChangePresencePrivacySettingForAcceptedFriend()
        {
            PNUser user;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                                            new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, false, false),
                                            };

            GenerateFriendsWithPrivacy(osvs, out user);
            WaitForCacheToUpdate();

            Global.RO.Info("Friend's Presence Privacy Setting to FriendsOnly");
            GetFriendsXrlResponse replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            SocialQueryUser[] friends = replyData.Friends;

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));
            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");

            Global.RO.Info("Changing Friend's Presence Privacy Setting to Everyone");
            SetPresencePrivacy(osvs[0].user, ePrivacySetting.Everyone);
            WaitForCacheToUpdate();

            // logoff and relogon to refresh the cache
            LogoffUser(osvs[0].user);
            LogonUser(osvs[0].user, true);

            replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            friends = replyData.Friends;

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");

            Global.RO.Info("Changing Friend's Presence Privacy Setting back to Friend Only");
            SetPresencePrivacy(osvs[0].user, ePrivacySetting.FriendsOnly);

            // logoff and then logon to refresh the cache
            LogoffUser(osvs[0].user);
            LogonUser(osvs[0].user, true);

            replyData = user.GetFriendsList(GetFriendSortType.Gamertag, 100, 0);
            Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            friends = replyData.Friends;

            // dealing with one friend
            Assert.IsTrue(replyData.NumFriends == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, replyData.NumFriends));
            Assert.IsTrue(friends.Length == 1, string.Format("Expected {0} friends, got {1}!", osvs.Length, friends.Length));

            Assert.IsTrue((friends[0].Flags & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE, "User should appear online but doesn't");
        }

        #region helper functions

        private static OnlineStatusVariation[] GenerateOnlineStatusVariations()
        {
            return new OnlineStatusVariation[]{
                                          new OnlineStatusVariation(false, ePrivacySetting.Blocked, false, false),
                                          new OnlineStatusVariation(false, ePrivacySetting.Blocked, true, false),
                                          new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, false, false),
                                          new OnlineStatusVariation(false, ePrivacySetting.FriendsOnly, true, false),
                                          new OnlineStatusVariation(false, ePrivacySetting.Everyone, false, true),
                                          new OnlineStatusVariation(false, ePrivacySetting.Everyone, true, false),
                                          new OnlineStatusVariation(true, ePrivacySetting.Blocked, false, false),
                                          new OnlineStatusVariation(true, ePrivacySetting.Blocked, true, false),
                                          new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, false, true),
                                          new OnlineStatusVariation(true, ePrivacySetting.FriendsOnly, true, false),
                                          new OnlineStatusVariation(true, ePrivacySetting.Everyone, false, true),
                                          new OnlineStatusVariation(true, ePrivacySetting.Everyone, true, false),
                                  };
        }

        #endregion

    }


    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncGetFriendsofFriendsPrivacyTests : SocialQueryTestBaseGroup
    {

        [TestCase, Description("Fetch the Friends of Friends list for a user with only the requestor for a friend")]
        public void P_GetFriendsOfFriends_CheckPrivacy_OwnersListHasNoFriends()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            int expectedFriendsListVer = 0;

            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs = new OnlineStatusVariation[0];

            FriendsOfFriendsOnlineStatusVariation[] fofosvs = 
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, blocked, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, sqUsers);
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_RegularCases()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool isAccepted = true;
            bool appearOffline = false;
            bool notUsed = true;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, notUsed, true),
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, notUsed, false),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, notUsed, true),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, notUsed, false),
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(none, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(none, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, friendsOnly, osvs)
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetIsPendingFriend()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            // make the declarations simpler
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                  new OnlineStatusVariation(false, everyone, false, false, true),
                  new OnlineStatusVariation(false, friendsOnly, false, false, true),
                  new OnlineStatusVariation(false, blocked, false, false, true),
                  new OnlineStatusVariation(false, everyone, false, false, false),
                  new OnlineStatusVariation(false, friendsOnly, false, false, false),
                  new OnlineStatusVariation(false, blocked, false, false, false),
               };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, friendsOnly, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
                Assert.IsTrue(replyData.NumFriends == 0, string.Format("Expected {0} friends, got {1}!", 0, replyData.NumFriends)); 
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetRealStateOffline()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool isLoggedOn = false;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(true, everyone, true, true, isLoggedOn),
                   new OnlineStatusVariation(true, everyone, false, true, isLoggedOn),
                   new OnlineStatusVariation(true, friendsOnly, true, true, isLoggedOn),
                   new OnlineStatusVariation(true, friendsOnly, false, true, isLoggedOn),
                   new OnlineStatusVariation(true, blocked, true, true, isLoggedOn),
                   new OnlineStatusVariation(true, blocked, false, true, isLoggedOn)
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, friendsOnly, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetAppearOffline()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool appearOffline = true;
            bool isAccepted = true;
            bool stateVisible = false;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, stateVisible, false),
                };

            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs = 
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, friendsOnly, osvs)
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetOnlineStatusBlocked()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            // make the declaration simpler
            bool notUsed = false;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                  new OnlineStatusVariation(false, blocked, false, notUsed, true),
                  new OnlineStatusVariation(false, blocked, false, notUsed, false),
                  new OnlineStatusVariation(false, blocked, true, notUsed, true),
                  new OnlineStatusVariation(false, blocked, true, notUsed, false),
                  new OnlineStatusVariation(true, blocked, false, notUsed, true),
                  new OnlineStatusVariation(true, blocked, false, notUsed, false),
                  new OnlineStatusVariation(true, blocked, true, notUsed, true),
                  new OnlineStatusVariation(true, blocked, true, notUsed, false),
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, friendsOnly, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetChangeRealState()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            // make the declaration simpler
            bool notUsed = true;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                  // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                  new OnlineStatusVariation(false, everyone, false, notUsed, true),
                  new OnlineStatusVariation(false, everyone, false, notUsed, false),
                  new OnlineStatusVariation(false, everyone, true, notUsed, true),
                  new OnlineStatusVariation(false, everyone, true, notUsed, false),
                  new OnlineStatusVariation(false, friendsOnly, false, notUsed, true),
                  new OnlineStatusVariation(false, friendsOnly, false, notUsed, false),
                  new OnlineStatusVariation(false, friendsOnly, true, notUsed, true),
                  new OnlineStatusVariation(false, friendsOnly, true, notUsed, false),
                  new OnlineStatusVariation(false, blocked, false, notUsed, true),
                  new OnlineStatusVariation(false, blocked, false, notUsed, false),
                  new OnlineStatusVariation(false, blocked, true, notUsed, true),
                  new OnlineStatusVariation(false, blocked, true, notUsed, false),
                  new OnlineStatusVariation(true, everyone, false, notUsed, true),
                  new OnlineStatusVariation(true, everyone, false, notUsed, false),
                  new OnlineStatusVariation(true, everyone, true, notUsed, true),
                  new OnlineStatusVariation(true, everyone, true, notUsed, false),
                  new OnlineStatusVariation(true, friendsOnly, false, notUsed, true),
                  new OnlineStatusVariation(true, friendsOnly, false, notUsed, false),
                  new OnlineStatusVariation(true, friendsOnly, true, notUsed, true),
                  new OnlineStatusVariation(true, friendsOnly, true, notUsed, false),
                  new OnlineStatusVariation(true, blocked, false, notUsed, true),
                  new OnlineStatusVariation(true, blocked, false, notUsed, false),
                  new OnlineStatusVariation(true, blocked, true, notUsed, true),
                  new OnlineStatusVariation(true, blocked, true, notUsed, false),
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(none, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);

                // If a friend is logged in, log them out
                // If a friend is logged out, log them in
                OnlineStatusVariation[] toggleOsvs = new OnlineStatusVariation[fof.osvs.Length];
                for (int i = 0; i < fof.osvs.Length; i++)
                {
                    // Toggle sign in state for the owner's friends
                    toggleOsvs[i] = new OnlineStatusVariation(fof.osvs[i]);
                    toggleOsvs[i].isLoggedOn = (fof.osvs[i].isLoggedOn) ? false : true;
                    eUserAppearOnlineStatus eCloaked = (fof.osvs[i].appearOffline) ? eUserAppearOnlineStatus.eAppearOffline : eUserAppearOnlineStatus.eAppearOnline;

                    // we've toggled the value of their isLoggedOn value above, so now change their actual state
                    if (toggleOsvs[i].isLoggedOn)
                    {
                        LogonUser(toggleOsvs[i].user, eCloaked, false);
                    }
                    else
                    {
                        LogoffUser(toggleOsvs[i].user);
                    }
                }
                WaitForCacheToUpdate();

                FriendsOfFriendsOnlineStatusVariation toggleFoF = new FriendsOfFriendsOnlineStatusVariation(fof.requestorToOwner, fof.requestorToTarget, fof.ownerFriendsListPrivacy, toggleOsvs);
                SocialQueryUser[] toggleSQUsers = new SocialQueryUser[0];
                OnlineStatusVariation[] toggleReqOsvs = new OnlineStatusVariation[0];
                int dummyFLVer = 0; // shouldn't change just because users are going on/offline
                GenerateFriendsWithPrivacy(toggleFoF, out requestor, out owner, ref toggleSQUsers, out dummyFLVer, ref toggleReqOsvs, false);
                WaitForCacheToUpdate();

                expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(toggleSQUsers, InitSocialQueryUser(requestor), toggleReqOsvs));
                replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);

                foreach (OnlineStatusVariation osv in fof.osvs)
                {
                    if (osv.isLoggedOn)
                    {
                        eUserAppearOnlineStatus eCloaked = (osv.appearOffline) ? eUserAppearOnlineStatus.eAppearOffline : eUserAppearOnlineStatus.eAppearOnline;
                        LogonUser(osv.user, eCloaked, false);
                    }
                    else
                    {
                        LogoffUser(osv.user);
                    }
                }
                WaitForCacheToUpdate();

                // We don't need to regenerate because we didn't write over the original values
                expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_TargetChangeAppearOffline()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            // make the declaration simpler
            bool notUsed = true;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                  //new OnlineStatusVariation(false, everyone, false, notUsed, true),
                  //new OnlineStatusVariation(false, everyone, false, notUsed, false),
                  //new OnlineStatusVariation(false, everyone, true, notUsed, true),
                  //new OnlineStatusVariation(false, everyone, true, notUsed, false),
                  //new OnlineStatusVariation(false, friendsOnly, false, notUsed, true),
                  //new OnlineStatusVariation(false, friendsOnly, false, notUsed, false),
                  //new OnlineStatusVariation(false, friendsOnly, true, notUsed, true),
                  //new OnlineStatusVariation(false, friendsOnly, true, notUsed, false),
                  //new OnlineStatusVariation(false, blocked, false, notUsed, true),
                  //new OnlineStatusVariation(false, blocked, false, notUsed, false),
                  //new OnlineStatusVariation(false, blocked, true, notUsed, true),
                  //new OnlineStatusVariation(false, blocked, true, notUsed, false),
                  new OnlineStatusVariation(true, everyone, false, notUsed, true),
                  new OnlineStatusVariation(true, everyone, false, notUsed, false),
                  new OnlineStatusVariation(true, everyone, true, notUsed, true),
                  new OnlineStatusVariation(true, everyone, true, notUsed, false),
                  new OnlineStatusVariation(true, friendsOnly, false, notUsed, true),
                  new OnlineStatusVariation(true, friendsOnly, false, notUsed, false),
                  new OnlineStatusVariation(true, friendsOnly, true, notUsed, true),
                  new OnlineStatusVariation(true, friendsOnly, true, notUsed, false),
                  new OnlineStatusVariation(true, blocked, false, notUsed, true),
                  new OnlineStatusVariation(true, blocked, false, notUsed, false),
                  new OnlineStatusVariation(true, blocked, true, notUsed, true),
                  new OnlineStatusVariation(true, blocked, true, notUsed, false),
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(none, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);


                int xx = 0;
                foreach (SocialQueryUser user in expectedResponse.Friends)
                {
                    ro.Debug("PR[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    xx++;
                }


                // Toggle a user's AppearOffline state
                OnlineStatusVariation[] toggleOsvs = new OnlineStatusVariation[fof.osvs.Length];
                for (int i = 0; i < fof.osvs.Length; i++)
                {
                    toggleOsvs[i] = new OnlineStatusVariation(fof.osvs[i]);
                    toggleOsvs[i].appearOffline = (fof.osvs[i].appearOffline) ? false : true;

                    // we've toggled the value of their appearOffline value above, so now change their actual state
                    toggleOsvs[i].user.State &= ~(XonPresNoti.P_STATE_MASK_CLOAKED);
                }
                WaitForCacheToUpdate();

                FriendsOfFriendsOnlineStatusVariation toggleFoF = new FriendsOfFriendsOnlineStatusVariation(fof.requestorToOwner, fof.requestorToTarget, fof.ownerFriendsListPrivacy, toggleOsvs);
                SocialQueryUser[] toggleSQUsers = new SocialQueryUser[0];
                OnlineStatusVariation[] toggleReqOsvs = new OnlineStatusVariation[0];
                int dummyFLVer = 0; // shouldn't change just because users are going on/offline
                GenerateFriendsWithPrivacy(toggleFoF, out requestor, out owner, ref toggleSQUsers, out dummyFLVer, ref toggleReqOsvs, false);

                expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(toggleSQUsers, InitSocialQueryUser(requestor), toggleReqOsvs));
                replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                //int xx = 0;
                xx = 0;
                foreach (SocialQueryUser user in expectedResponse.Friends)
                {
                    ro.Debug("EX[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    xx++;
                }
                xx = 0;
                foreach (SocialQueryUser user in replyData.Friends)
                {
                    ro.Debug("AC[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    xx++;
                }
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);

                foreach (OnlineStatusVariation osv in fof.osvs)
                {
                    osv.user.State &= ~(XonPresNoti.P_STATE_MASK_CLOAKED);
                }
                WaitForCacheToUpdate();

                // We don't need to regenerate because we didn't write over the original values
                expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);

                xx = 0;
                foreach (SocialQueryUser user in expectedResponse.Friends)
                {
                    ro.Debug("EX[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    xx++;
                }
                xx = 0;
                foreach (SocialQueryUser user in replyData.Friends)
                {
                    ro.Debug("AC[" + xx + "]: " + user.Gamertag + "--" + user.Flags);
                    xx++;
                }

                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_OwnerChangeFriendsListPriv()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool isAccepted = true;
            bool appearOffline = false;
            bool notUsed = true;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, notUsed, true),
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, notUsed, false),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, notUsed, true),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, notUsed, false),
                };

            // Create the FoF's once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, everyone, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);

                // Now change to FriendsOnly and verify we don't see the list
                SetFriendsListPrivacy(owner, ePrivacySetting.FriendsOnly);
                LogoffUser(owner);
                LogonUser(owner, true);
                int expectedLength = 0;
                if (eFriendshipState.eFullFriendship == fof.requestorToOwner)
                    expectedLength = osvs.Length;

                expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                Assert.IsTrue(replyData.hr == HResult.S_OK, String.Format("GetFriendsList query failed. hr = {0}", replyData.hr));
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_OwnerFriendsListBlocked()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool appearOffline = false;
            bool stateVisible = false;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            ePrivacySetting blocked = ePrivacySetting.Blocked;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(true, everyone, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(true, everyone, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(true, friendsOnly, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(true, friendsOnly, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(true, blocked, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(true, blocked, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(false, everyone, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(false, everyone, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(false, friendsOnly, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(false, friendsOnly, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(false, blocked, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(false, blocked, appearOffline, stateVisible, false),
                };

            // Generate the FoFs once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs = 
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, none, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, sent, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, recd, blocked, osvs),
                new FriendsOfFriendsOnlineStatusVariation(full, full, blocked, osvs),
            };

            foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
            {
                ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                ValidateGetFriendsXrlResponse(replyData, expectedResponse);
            }
        }

        [TestCase]
        public void P_GetFriendsOfFriends_CheckPrivacy_RequestorFriendsListHasDiffPriv()
        {
            PNUser requestor;
            PNUser owner;
            SocialQueryUser[] sqUsers = new SocialQueryUser[0];
            OnlineStatusVariation[] reqOsvs = new OnlineStatusVariation[0];
            int expectedFriendsListVer = 0;

            bool isAccepted = true;
            bool appearOffline = false;
            bool stateVisible = true;
            ePrivacySetting everyone = ePrivacySetting.Everyone;
            ePrivacySetting friendsOnly = ePrivacySetting.FriendsOnly;
            eFriendshipState none = eFriendshipState.eNoFriendship;
            eFriendshipState sent = eFriendshipState.eSentRequest;
            eFriendshipState recd = eFriendshipState.eReceivedRequest;
            eFriendshipState full = eFriendshipState.eFullFriendship;

            OnlineStatusVariation[] osvs =
                new OnlineStatusVariation[]{
                   // isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(isAccepted, everyone, appearOffline, stateVisible, false),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, stateVisible, true),
                   new OnlineStatusVariation(isAccepted, friendsOnly, appearOffline, stateVisible, false),
                };

            // Generate the FoFs once
            GenerateFriendsWithPrivacy(ref osvs);

            FriendsOfFriendsOnlineStatusVariation[] fofosvs =
            {
                new FriendsOfFriendsOnlineStatusVariation(sent, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, everyone, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(sent, full, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, none, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, sent, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, recd, friendsOnly, osvs),
                new FriendsOfFriendsOnlineStatusVariation(recd, full, friendsOnly, osvs),
            };

            ePrivacySetting cur = ePrivacySetting.MAX;
            for (int priv = 0; priv < (int)ePrivacySetting.MAX; priv++)
            {
                foreach (FriendsOfFriendsOnlineStatusVariation fof in fofosvs)
                {
                    ro.Debug("Setting up FoF fetch for OwnerFLPriv = " + GetPrivString(fof.ownerFriendsListPrivacy) + ", RequestorToOwner = " + GetFriendshipStateString(fof.requestorToOwner) + ", RequestorToTarget = " + GetFriendshipStateString(fof.requestorToTarget));
                    GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out expectedFriendsListVer, ref reqOsvs, false);

                    if (cur != (ePrivacySetting)priv)
                    {
                        SetFriendsListPrivacy(requestor, (ePrivacySetting)priv);
                        WaitForCacheToUpdate();
                        cur = (ePrivacySetting)priv;
                    }

                    GetFriendsXrlResponse expectedResponse = InitExpectedGetFriendsResponse(requestor, expectedFriendsListVer, sqUsers.Length, 0, SortByFriendsOfFriends(sqUsers, InitSocialQueryUser(requestor), reqOsvs));
                    GetFriendsXrlResponse replyData = requestor.GetFriendsList(owner.UserId, GetFriendSortType.OnlineStatus, 100, 0);
                    ValidateGetFriendsXrlResponse(replyData, expectedResponse);
                }
            }
        }

        private string GetPrivString(ePrivacySetting priv)
        {
            if (ePrivacySetting.Blocked == priv)
                return "Blocked";
            if (ePrivacySetting.FriendsOnly == priv)
                return "FriendsOnly";
            if (ePrivacySetting.Everyone== priv)
                return "Everyone";

            return "Unknown";
        }

        private string GetFriendshipStateString(eFriendshipState state)
        {
            if (eFriendshipState.eNoFriendship == state)
                return "None";
            if (eFriendshipState.eSentRequest== state)
                return "Sent";
            if (eFriendshipState.eReceivedRequest == state)
                return "Recd";
            if (eFriendshipState.eFullFriendship== state)
                return "Full";

            return "Unknown";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\sgauth.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Reflection;
using System.Threading;

using xonline.common.service;

namespace xonline.server.stats.test.dvt 
{
    // SGSession
    // Pass it to SGAuth so it knows what to simulate
    class SGSession
    {
        public SGSession(ulong ulMachineId, ulong[] users)
        {
            Debug.Assert(users != null && users.Length >= 1 && users.Length <= 4);
            _ulMachineId = ulMachineId;

            for(int ndx=0; ndx < users.Length; ndx++)
                _users[ndx] = users[ndx];
        }
        
        public uint     _uiTitleId      = xonline.stats.admin.Constants.TitleId;
        public ulong    _ulMachineId;
        public ulong[]  _users = new ulong[4];
        public ulong    _fileTimeSessionStarted = (ulong) DateTime.Now.AddMinutes(5).ToFileTime();
    }
    
    // SGAuth
    // Handles SG auth stuff 
    class SGAuth
    {
        private const ushort sgMessagePort = 0xFFFF;
            // That's where SG receives UDP messages
        
        // Start
        // Start the auth thread. Call it at the beginning of the app.
        static public void Start()
        {
            _authThread = new XboxLiveThread(new ThreadStart((new SGAuth()).AuthThread));
            _authThread.Name = "Auth thread";
            _authThread.Start();
        }
        
        // Shutdown
        // Stop the auth thread and do clean up. Call it at the end of the app.
        static public void Shutdown()
        {
            if(_authThread != null)
            {
                // Signal auth thread to stop
                _fShutdown = true;
                
                // Wait until it finishes
                while(_authThread.IsAlive)
                {
                    Thread.Sleep(500);
                }
            }
        }

        // AddSession
        // Add a session to the list of stuff to be simulated
        static public void AddSession(IPEndPoint endPoint, SGSession session)
        {
            _sessionTable.Add(endPoint, session);
        }

        // DropSession
        // Drop a session from the list
        static public void DropSession(IPEndPoint endPoint)
        {
            _sessionTable.Remove(endPoint);
        }

        // AuthThread
        // Does the real work
        private void AuthThread()
        {
            byte[] authStuff = new Byte[4096];
            Socket authSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            authSocket.Bind(new IPEndPoint(0, sgMessagePort));
            EndPoint endPointRequester = new IPEndPoint(0, 0);            
            
            while(!_fShutdown)
            {
                if(!authSocket.Poll(500000, SelectMode.SelectRead))
                {
                    continue;
                }
                
                int iSize = authSocket.ReceiveFrom(authStuff, ref endPointRequester);
                MemoryStream memStream = new MemoryStream(authStuff, 0, iSize);
                BinaryReader reader = new BinaryReader(memStream);

                // Read message header
                SGMsgHdr hdr = new SGMsgHdr();
                hdr.ReadFrom(reader);

                if(hdr._wType != SGMsgHdr.SGMSG_TYPE_SPIDATA_REQ2)
                {
                    throw new Exception("Invalid SG message type " + hdr._wType);
                }
                
                // Read SPI request
                SGMsgSpiReq2 spiReq = new SGMsgSpiReq2();
                spiReq.ReadFrom(reader);

                // Look for the session
                IPEndPoint sessionEndPoint = new IPEndPoint(spiReq._ipaZ, IPAddress.NetworkToHostOrder((short)spiReq._ipportZ));
                SGSession session = (SGSession) _sessionTable[sessionEndPoint];
                
                // Prepare to send reply
                memStream = new MemoryStream(authStuff);
                BinaryWriter writer = new BinaryWriter(memStream);

                // SPI reply
                SGMsgSpiRep2 spiRep = new SGMsgSpiRep2();
                hdr._wType                  = SGMsgHdr.SGMSG_TYPE_SPIDATA_REP2;
                hdr._cbEnt                  = (ushort) (SGMsgHdr.Size + SGMsgSpiRep2.Size);
                hdr.WriteTo(writer);
                spiRep._dwReqNum            = spiReq._dwReqNum;
                spiRep._ipaZ                = spiReq._ipaZ;
                spiRep._ipportZ             = spiReq._ipportZ;
                spiRep._fNotFound           = (byte) (session != null ? 0 : 1);
                spiRep.WriteTo(writer);

                if(session != null)
                {
                    // SPI data
                    hdr._wType                  = SGMsgHdr.SGMSG_TYPE_SPIDATA2;
                    hdr._cbEnt                  = (ushort) (SGMsgHdr.Size + SGMsgSpiData2.Size);
                    hdr.WriteTo(writer);
                    
                    SGMsgSpiData2 spiData       = new SGMsgSpiData2();
                    spiData._ipportI            = 0;
                    spiData._ipaI               = 0;
                    spiData._sgaddr             = new byte[20];
                    spiData._wVersionKeyEx      = 1;
                    spiData._wFlagsKeyEx        = 1;
                    spiData._liNonce            = 123;
                    spiData._liTimeInit         = (ulong) session._fileTimeSessionStarted;
                    spiData._fCs                = 1;
                    spiData.WriteTo(writer);  
                    
                    hdr._wType                  = SGMsgHdr.SGMSG_TYPE_AUTHDATA2;
                    hdr._cbEnt                  = SGAuthData3.Size;
                    hdr.WriteTo(writer);
                    
                    SGAuthData3 authdata        = new SGAuthData3();
                    authdata._dwTitleID         = session._uiTitleId;
                    authdata._qwXboxID          = session._ulMachineId;
                    authdata._users[0]._userId  = session._users[0];
                    authdata._users[1]._userId  = session._users[1];
                    authdata._users[2]._userId  = session._users[2];
                    authdata._users[3]._userId  = session._users[3];
                    authdata.WriteTo(writer);
                }
                
                authSocket.SendTo(memStream.ToArray(), endPointRequester);
            }
        }
        
        private static XboxLiveThread       _authThread         = null;
        private static bool                 _fShutdown          = false;
        private static Hashtable            _sessionTable       = new Hashtable();
    }

    // *** SG Protocol stuff ***
    
    // SGMsgHdr
    // SG message header 
    class SGMsgHdr 
    {
        public const int    Size                    = 4;

        public const int    SGMSG_TYPE_SPIDATA_REQ2 = 0x4710;  // CSgMsgSpiReq2
        public const int    SGMSG_TYPE_SPIDATA_REP2 = 0x4711;  // CSgMsgSpiRep2
        public const int    SGMSG_TYPE_SPIDATA2     = 0x4782;  // CSgMsgSpiData2 in the payload
        public const int    SGMSG_TYPE_AUTHDATA2    = 0x4783;  // SGAuthData2
    
        public ushort       _wType = 0;
        public ushort       _cbEnt = 0;

        public void ReadFrom(BinaryReader reader)
        {
            _wType = reader.ReadUInt16();
            _cbEnt = reader.ReadUInt16();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_wType);
            writer.Write(_cbEnt);
        }
    }

    // SGMsgSpiReq
    // SPI request
    class SGMsgSpiReq2
    {
        public const int    Size                    = 10;

        public uint         _dwReqNum               = 0;        // Request number from requester
        public uint         _ipaZ                   = 0;        // IP address of the client on the DMZ
        public ushort       _ipportZ                = 0;        // IP port of the client on the DMZ

        public void ReadFrom(BinaryReader reader)
        {
            _dwReqNum = reader.ReadUInt32();
            _ipaZ = reader.ReadUInt32();
            _ipportZ = reader.ReadUInt16();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_dwReqNum);
            writer.Write(_ipaZ);
            writer.Write(_ipportZ);
        }
    }

    // SGMsgSpiRep
    // SPI response
    class SGMsgSpiRep2
    {
        public const int    Size                    = 11;

        public uint         _dwReqNum               = 0;        // Copy of _dwReqNum from request
        public uint         _ipaZ                   = 0;        // IP address of the client on the DMZ
        public ushort       _ipportZ                = 0;        // IP port of the client on the DMZ
        public byte         _fNotFound              = 0;        // TRUE if client not found (no auth-data enclosed)

        public void ReadFrom(BinaryReader reader)
        {
            _dwReqNum = reader.ReadUInt32();
            _ipaZ = reader.ReadUInt32();
            _ipportZ = reader.ReadUInt16();
            _fNotFound = reader.ReadByte();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_dwReqNum);
            writer.Write(_ipaZ);
            writer.Write(_ipportZ);
            writer.Write(_fNotFound);
        }
    }

    // SGMsgSpiData
    class SGMsgSpiData2
    {
        public const int    Size                = 50;
        
        public ushort       _ipportI            = 0;        // IP port of the client on the Internet
        public uint         _ipaI               = 0;        // IP address of the client on the Internet
        public byte[/*20*/] _sgaddr             = new byte[20];     // SGADDR of the client (size = 20 bytes)
        public ushort       _wVersionKeyEx      = 1;        // KeyEx version of the client
        public ushort       _wFlagsKeyEx        = 1;        // Flags sent in KeyEx initiator
        public ulong        _liNonce            = 0;        // A random nonce associated with this session
        public ulong        _liTimeInit         = 0;        // FILETIME marking session initiation
        public uint         _fCs                = 0;        // TRUE if SG is providing connection services

        public void ReadFrom(BinaryReader reader)
        {
            _ipportI        = reader.ReadUInt16();
            _ipaI           = reader.ReadUInt32();
            _sgaddr         = reader.ReadBytes(20);
            _wVersionKeyEx  = reader.ReadUInt16();
            _wFlagsKeyEx    = reader.ReadUInt16();
            _liNonce        = reader.ReadUInt64();
            _liTimeInit     = reader.ReadUInt64();
            _fCs            = reader.ReadUInt32();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ipportI);
            writer.Write(_ipaI);
            writer.Write(_sgaddr);
            writer.Write(_wVersionKeyEx);
            writer.Write(_wFlagsKeyEx);
            writer.Write(_liNonce);
            writer.Write(_liTimeInit);
            writer.Write(_fCs);
        }
    }

    // SGAuthData
    class SGAuthData3
    {
        public const int    Size                    = 44 + (4*SGXUID.Size) + (12*4) + (4*4);
        public const ushort XONLINE_AUTHDATA_VERSION = 3;

        public ushort       _wAuthDataVersion       = XONLINE_AUTHDATA_VERSION;
        public ushort       _wAuthDataSize          = Size;
        public ushort       _wMajorVersion          = 1;
        public ushort       _wMinorVersion          = 2;
        public ushort       _wBuildNumber           = 3;
        public ushort       _wQFENumber             = 4;
        public uint         _dwTitleID              = 0;
        public uint         _dwTitleVersion         = 0;
        public uint         _dwTitleRegion          = 0;
        public uint         _dwConsoleRegion        = 0;
        public uint         _dwMediaId              = 0;
        public ushort       _wLanguageId            = 0;
        public uint         _dwAuthDataFlags        = 0;
        public ushort       _wNumPrivileges         = 0;
        public uint[]       _rgPrivileges           = new uint[8];
        public ulong        _qwXboxID               = 0;
        public SGXUID[]     _users                  = new SGXUID[4];
        public float[]      _afltTrustFactor        = new float[4];
        public ushort       _wNumServices           = 0;
        public uint[]       _dwServiceID            = new uint[12];
        public uint[]       _rgAltTitleId           = new uint[4];
        public byte[]       _key                    = new byte[16];
        

        public void ReadFrom(BinaryReader reader)
        {
            _wAuthDataVersion = reader.ReadUInt16();
            _wAuthDataSize = reader.ReadUInt16();
            _wMajorVersion = reader.ReadUInt16();
            _wMinorVersion = reader.ReadUInt16();
            _wBuildNumber = reader.ReadUInt16();
            _wQFENumber = reader.ReadUInt16();
            _dwTitleID = reader.ReadUInt32();
            _dwTitleVersion = reader.ReadUInt32();
            _dwTitleRegion = reader.ReadUInt32();
            _dwConsoleRegion = reader.ReadUInt32();
            _dwMediaId = reader.ReadUInt32();
            _dwAuthDataFlags = reader.ReadUInt32();
            _wNumPrivileges = reader.ReadUInt16();
            
            for(int iPriv=0; iPriv < _rgPrivileges.Length; iPriv++)
            {
                _rgPrivileges[iPriv] = reader.ReadUInt32();
            }
            
            _qwXboxID = reader.ReadUInt64();

            for(int iUser=0; iUser < _users.Length; iUser++)
            {
                _users[iUser].ReadFrom(reader);
            }
            
            for(int iTrustFactor=0; iTrustFactor < _afltTrustFactor.Length; iTrustFactor++)
            {
                _afltTrustFactor[iTrustFactor] = reader.ReadSingle();
            }
            
            _wNumServices = reader.ReadUInt16();
            
            for(int iService=0; iService < _dwServiceID.Length; iService++)
            {
                _dwServiceID[iService] = reader.ReadUInt32();
            }
            
            for(int iAltTitle=0; iAltTitle < _rgAltTitleId.Length; iAltTitle++)
            {
                _rgAltTitleId[iAltTitle] = reader.ReadUInt32();
            }
            
            _key = reader.ReadBytes(_key.Length);
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_wAuthDataVersion);
            writer.Write(_wAuthDataSize);
            writer.Write(_wMajorVersion);
            writer.Write(_wMinorVersion);
            writer.Write(_wBuildNumber);
            writer.Write(_wQFENumber);
            writer.Write(_dwTitleID);
            writer.Write(_dwTitleVersion);
            writer.Write(_dwTitleRegion);
            writer.Write(_dwConsoleRegion);
            writer.Write(_dwMediaId);
            writer.Write(_wLanguageId);
            writer.Write(_dwAuthDataFlags);
            writer.Write(_wNumPrivileges);
            
            for(int iPriv=0; iPriv < _rgPrivileges.Length; iPriv++)
            {
                writer.Write(_rgPrivileges[iPriv]);
            }
            
            writer.Write(_qwXboxID);

            for(int iUser=0; iUser < _users.Length; iUser++)
            {
                _users[iUser].WriteTo(writer);
            }
            for(int iTrustFactor=0; iTrustFactor < _afltTrustFactor.Length; iTrustFactor++)
            {
                writer.Write(_afltTrustFactor[iTrustFactor]);
            }

            writer.Write(_wNumServices);
            
            for(int iService=0; iService < _dwServiceID.Length; iService++)
            {
                writer.Write(_dwServiceID[iService]);
            }
            
            for(int iAltTitle=0; iAltTitle < _rgAltTitleId.Length; iAltTitle++)
            {
                writer.Write(_rgAltTitleId[iAltTitle]);
            }
            
            writer.Write(_key);
        }
    } 

    // SGXUID
    // user id
    struct SGXUID 
    {
        public const int    Size                    = 12;

        public ulong        _userId;
        public uint         _userFlags;
 
        public void ReadFrom(BinaryReader reader)
        {
            _userId = reader.ReadUInt64();
            _userFlags = reader.ReadUInt32();
        }
        
        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_userId);
            writer.Write(_userFlags);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\dbleaderboard.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Xml;
using System.Xml.Schema;

using xonline.common.config;
using xonline.common.leaderboard;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.xlastutil;
using xonline.server.stats.common;

using xonline.server.stats.test.dvt;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
//task: add all the config stuff for this...
// omDefineArea( LeaderboardSettings );

namespace xonline.stats.admin
{

    #region Copied from Stats file
    // this region copied from private\server\stats\test\dvt\statsunitest.cs
    // which had a Main method that interfered with it's use in this console app.
    // so, as a temporary hack, just the config is copied here...
    public class Constants
    {
        public const uint   TitleId         = 0xfeedfeed;
        public const ulong  TestMachineId   = 0xf00df00df00df00d;
    }

    // TODO: most of the fields in this class are never used (after initialization)
    // we need to get rid of them.  Naming the class "Config" is also a bad idea.
    public class Config
    {
        static public string     _environment = "xblob";
        static public int        _iInternetPort   = 10070;
        static public int        _iDatacenterPort = 11070;
        static public string     _frontdoor = "127.0.0.1";
        static public string     _lbsvrname = "inspectorgadget";
        static public IPEndPoint _lbsvraddr = new IPEndPoint(0, 0);
        static public int        _iRandomSeed = (new Random()).Next();
        static public bool       _fThrow = false;
    }

    #endregion

    // DbLeaderboard
    // Handles stuff where we have to go directly to the database.
    // task: add unit tests for this class... don't have time now, but have tried to make it easy to retro-fit with tests
    public class DbLeaderboard
    {
        private const string statWildCard = "ALL";

        static DbLeaderboard()
        {

            //task: need to make sure this works for production

            // environment
            Config._environment = xonline.common.config.Config.Environment;

            // Lbsvr
            string[] serverNames = xonline.common.config.Config.GetServerListByInterface(Interface.lbsvr);
            Config._lbsvrname = serverNames[0];
            IInterfaceInfo face = xonline.common.config.Config.GetInterface(Config._lbsvrname, Interface.lbsvr);
            Config._lbsvraddr = new IPEndPoint(face.IPAddress, face.Port);

            // Stats FD
            IVirtualInterfaceInfo faceFD = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.xstatsfd);
            Config._frontdoor = faceFD.IPAddressString;
            Config._iInternetPort = faceFD.Port;

            faceFD = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.xstatsfd_int);
            Config._iDatacenterPort = faceFD.Port;
        }


        /// <summary>
        /// Populate t_leaderboard_info and t_leaderboard_name_info
        /// tables in WebDB.
        /// </summary>
        /// <param name="lbServer"></param>
        /// <param name="uiTitleID"></param>
        /// <param name="iLbID"></param>
        /// <param name="iLbType"></param>
        /// <param name="bResetType"></param>
        static public void CreateLeaderboardInWebDb( LeaderboardSettings lbSettings )
        {

            // Create in WebDB
            SqlConnection sql = null;

            // these values are not found in the XSC file, so setting
            // default values
            const int entriesPerCacheLine = 50;
            const int expirationSeconds = 900;

            IInterfaceInfo info = xonline.common.config.Config.GetSingleInterface( Interface.webdb );
            string connection = "Data Source=" + info.IPAddressString + ";Trusted_Connection=Yes;Initial Catalog=" + info.DBName;

            using(sql = new SqlConnection( connection ))
            {
                sql.Open();

                // First, populate t_leaderboard_info
                //
                SqlCommand cmd = new SqlCommand("dbo.p_webdb_tmr_insert_lb_info", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",                   (int)lbSettings.TitleID);
                cmd.Parameters.AddWithValue("@i_lb_id",                      lbSettings.LeaderboardID);
                cmd.Parameters.AddWithValue("@ti_reset_type",                (byte)lbSettings.ResetType);
                cmd.Parameters.AddWithValue("@i_entries_per_cache_line",     entriesPerCacheLine);
                cmd.Parameters.AddWithValue("@i_expiration_seconds",         expirationSeconds);
                cmd.Parameters.AddWithValue("@i_lb_type",                    ( lbSettings.TeamView ? 1 : 0 ));
                cmd.Parameters.AddWithValue("@ti_dont_list",                 0);

                // Add return value
                SqlParameter paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                paramReturnValue.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(paramReturnValue);

                cmd.ExecuteNonQuery();

                // populate t_leaderboard_name_info
                //
                foreach (LocalizedDescription desc in lbSettings.Descriptions)
                {
                    cmd = new SqlCommand("dbo.p_webdb_tmr_insert_lb_name_info", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@i_title_id",       (int)lbSettings.TitleID);
                    cmd.Parameters.AddWithValue("@i_lb_id",          lbSettings.LeaderboardID);
                    cmd.Parameters.AddWithValue("@vc_locale_id",     desc.Locale);
                    cmd.Parameters.AddWithValue("@vc_display_name",  desc.Description);

                    // Add return value
                    paramReturnValue = null;
                    paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                    paramReturnValue.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(paramReturnValue);

                    cmd.ExecuteNonQuery();
                }


                // populate raw attributes
                //
                foreach(RawAttribute attrib in lbSettings.RawAttributes)
                {
                    cmd = new SqlCommand("dbo.p_webdb_tmr_insert_raw_attribute_info", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@i_title_id",       (int)lbSettings.TitleID);
                    cmd.Parameters.AddWithValue("@i_lb_id",          lbSettings.LeaderboardID);
                    cmd.Parameters.AddWithValue("@i_raw_attribute_id", attrib.Index);
                    // there is no conversion from boolean to other data types,
                    // so manually set an integer value for ti_puid_attribute
                    cmd.Parameters.AddWithValue("@ti_puid_attribute", attrib.IsPuid ? 1 : 0);

                    // Add return value
                    paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                    paramReturnValue.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(paramReturnValue);

                    cmd.ExecuteNonQuery();
                }


                // populate column value formatters
                //
                foreach(LbColumn col in lbSettings.Columns)
                {
                    cmd = new SqlCommand("dbo.p_webdb_tmr_insert_attribute_info", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@i_title_id",       (int)lbSettings.TitleID);
                    cmd.Parameters.AddWithValue("@i_lb_id",          lbSettings.LeaderboardID);
                    cmd.Parameters.AddWithValue("@vc_name",          col.Name);
                    cmd.Parameters.AddWithValue("@i_type",           (int)col.ReturnType);
                    cmd.Parameters.AddWithValue("@vc_formula",       (col.Formula == null ? "0+0" : col.Formula)); //it needs to have a default of 0+0 or wcstats don't start properly

                    // Add return value
                     paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                    paramReturnValue.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(paramReturnValue);

                    cmd.ExecuteNonQuery();

                    // populate localized column names
                    if (col.Descriptions != null)
                    {
                        foreach (LocalizedDescription desc in col.Descriptions)
                        {
                            if (desc.Description == null)
                            {
                                throw new Exception("Error: No Translation was supplied for a LocalizedString, check the XLAST file!");
                            }
                            cmd = new SqlCommand("dbo.p_webdb_tmr_insert_attribute_name_info", sql);
                            cmd.CommandType = CommandType.StoredProcedure;
                            cmd.Parameters.AddWithValue("@i_title_id",       (int)lbSettings.TitleID);
                            cmd.Parameters.AddWithValue("@i_lb_id",          lbSettings.LeaderboardID);
                            cmd.Parameters.AddWithValue("@vc_name",          col.Name);
                            cmd.Parameters.AddWithValue("@vc_locale_id",     desc.Locale);
                            cmd.Parameters.AddWithValue("@vc_display_name",  desc.Description);

                            // Add return value
                            paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                            paramReturnValue.Direction = ParameterDirection.ReturnValue;
                            cmd.Parameters.Add(paramReturnValue);

                            cmd.ExecuteNonQuery();
                        }
                    }
                }
            } // using

        }

        static public void CreateLeaderboard( LeaderboardSettings lb )
        {
            CreateLeaderboard(
                    lb.LBServer,
                    lb.TitleID,
                    lb.LeaderboardID,
                    lb.ResetType,
                    lb.MaxAttachments,
                    lb.MaxAttachmentSize,
                    lb.DecayDays,
                    lb.TopEntries,
                    lb.EloE,
                    lb.EloK,
                    lb.EloNew,
                    lb.EloCtable,
                    lb.TeamView,
                    lb.Arbitrated
                    );

            CreateLeaderboardInWebDb(lb);

        }

        static public void CreateLeaderboard(
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType )
        {
            CreateLeaderboard( LeaderboardSettings.UnknownServer, uiTitleID, iLbType, bResetType, 0, 0, 0, 0, "E", 0, 0, "", false, false);
        }

        static public void CreateLeaderboard(
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType,
            string  szServer)
        {
            CreateLeaderboard( szServer, uiTitleID, iLbType, bResetType, 0, 0, 0, -1, "E", 0, 0, "", false, false);
        }

        static public void CreateLeaderboard(
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType,
            int     iAttCount,
            int     iMaxAttSize,
            int     iDecayDays,
            int     iMaxRatCount)
        {
            CreateLeaderboard( LeaderboardSettings.UnknownServer, uiTitleID, iLbType, bResetType, iAttCount, iMaxAttSize, iDecayDays, iMaxRatCount, "E", 0, 0, "",
                false, false);
        }

        static public void CreateLeaderboard(
            string  lbServer,
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType,
            int     iAttCount,
            int     iMaxAttSize,
            int     iDecayDays,
            int     iMaxRatCount,
            bool    bIsTeam,
            bool    bReqArbitration)
        {
            //took defaults partially from DVT code
            //NOTE: The ELO settings DO NOT MATTER FOR XENON, the stored procedure defaults are used
            CreateLeaderboard( lbServer, uiTitleID, iLbType, bResetType, iAttCount, iMaxAttSize, iDecayDays, iMaxRatCount, "10", 100, 500, "0:40",
                bIsTeam, bReqArbitration);
        }



        //task: will probably want to move this elsewhere eventually
        public static void ResetFrontDoors(  )
        {
            ResetStatsFDOnly();
            ResetWebStatsOnly();
        }

        public static void ResetWebStatsOnly()
        {
            ExecuteXmgmtOnInterface(Interface.wcstats, "wcstats", "ReloadLeaderboards");
        }

        public static void ResetWebStatsOnly(int nTimeOutInMillis)
        {
            ExecuteXmgmtOnInterface(Interface.wcstats, "wcstats", "ReloadLeaderboards", nTimeOutInMillis);
        }

        public static void ResetStatsFDOnly()
        {
            ExecuteXmgmtOnInterface(Interface.xstatsfd_int, "xstatsfd", "ReloadDbMap");
        }

         public static void ResetStatsFDOnly(int nTimeOutInMillis)
        {
            ExecuteXmgmtOnInterface(Interface.xstatsfd_int, "xstatsfd", "ReloadDbMap", nTimeOutInMillis);
        }

        public static void ExecuteXmgmtOnInterface( string iface, string component, string command )
        {
            ExecuteXmgmtOnInterface( iface, component, command , 60000);
        }

        public static void ExecuteXmgmtOnInterface( string iface, string component, string command , int nTimeOutMillis)
        {
            string[] serverList = xonline.common.config.Config.GetServerListByInterface( iface );
            string[] responses = null;
            int result = 0;

            foreach( string server in serverList )
            {
                try
                {
                    Console.Write( " " + server );

                    // Since we are executing XMGMT commands, rather than use the caller's Interface spec,
                    // we will retrieve the IP for the xmgmtsrv Interface.  If,

                    IInterfaceInfo svrIFaceInfo = xonline.common.config.Config.GetInterface( server, Interface.xmgmtsrv );

                    if (svrIFaceInfo == null)
                    {
                        Console.Write( " WARNING: Could not retrieve xmgmtsrv interface for " + server + ", using service interface instead");
                        svrIFaceInfo = xonline.common.config.Config.GetInterface( server, iface );
                    }

                    XomAdminSession xmgmt = new XomAdminSession( svrIFaceInfo.IPAddress );
                    xmgmt.SendCommand( "", component, command, nTimeOutMillis, out responses, out result);
                }
                catch ( Exception e )
                {
                    Console.WriteLine( "There was a serious error while reloading front doors:" );
                    Console.WriteLine( "  Error was : " + e.Message + "\n" + e.StackTrace );
                }
            }
            Console.WriteLine("");
        }



        // CreateLeaderboard
        // Creates a new unitest LeaderboardSettings on the database
        static public void CreateLeaderboard(
            string  lbServer,
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType,
            int     iAttCount,
            int     iMaxAttSize,
            int     iDecayDays,
            int     iMaxRatCount,
            string  eloE,
            int     eloK,
            int     eloNew,
            string  eloCtable,
            bool    fIsTeam,
            bool    fReqArbitration )
        {
            LbsvrClientConnection connection = null;
            IPEndPoint ip = null;

            try
            {
                IInterfaceInfo face = xonline.common.config.Config.GetInterface( lbServer, Interface.lbsvr );
                ip = new IPEndPoint(face.IPAddress, face.Port);

            }
            catch( Exception e )
            {
                Xom.NtEvent( XEvent.Id.STATS_CONFIG_0, "DbLeaderboard: Unable to retrieve config information for the LeaderboardSettings Server interface." );
                Console.WriteLine( "CreateLb: Problem retrieving config information for server: " + lbServer + "\n" + e.ToString() );
            }

            CreateLeaderboardInNPDB(lbServer    , uiTitleID   , iLbType, 
                                    bResetType  , iAttCount   , iMaxAttSize,
                                    iDecayDays  , iMaxRatCount, eloE,
                                    eloK        , eloNew      , eloCtable,
                                    fIsTeam     , fReqArbitration);

            connection = LbsvrClientConnection.OpenConnection( ip );
            connection.BeginRequest(1);
            connection.CallProc(
                LbsvrClientConnection.LbProcIdLoadLb,
                new object[] {
                                 (Int32)  uiTitleID,
                                 (Int32)  iLbType
                             });
            connection.SendRequest();
        }

        static private void CreateLeaderboardInNPDB(
            string  lbServer,
            uint    uiTitleID,
            int     iLbType,
            byte    bResetType,
            int     iAttCount,
            int     iMaxAttSize,
            int     iDecayDays,
            int     iMaxRatCount,
            string  eloE,
            int     eloK,
            int     eloNew,
            string  eloCtable,
            bool    fIsTeam,
            bool    fReqArbitration )
        {
            SqlConnection sql = null;
            
            using (sql = new SqlConnection( ConfigUtil.NpdbConnectionString ))
            {
                sql.Open();

                int realTopEntries = 0;
                switch ( iMaxRatCount )
                {
                   case 100:
                        realTopEntries = 1;
                        break;

                   //Xlast actually contains unsigned long 0xffffffff
                   case -1:
                        realTopEntries = 0;
                        break;

                   default:
                        throw new Exception( "Top Entries Value for title " + uiTitleID.ToString("X8") + " lbid " + iLbType.ToString() );
                }

                SqlCommand cmd = new SqlCommand("dbo.p_stats_lb_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@vc_server",        lbServer);
                cmd.Parameters.AddWithValue("@i_title_id",       ((int)   uiTitleID ));
                cmd.Parameters.AddWithValue("@i_lb_id",          (Int32)  iLbType);
                cmd.Parameters.AddWithValue("@i_reset_type",     (Int32)  bResetType);
                cmd.Parameters.AddWithValue("@ti_top_100",       (Int32)  realTopEntries);
                cmd.Parameters.AddWithValue("@ti_team",          (Int32)  (fIsTeam ? 1 : 0));
                cmd.Parameters.AddWithValue("@ti_req_arb",       (Int32)  (fReqArbitration ? 1 : 0));
                cmd.Parameters.AddWithValue("@i_decay_days",     (Int32)  iDecayDays);
                cmd.Parameters.AddWithValue("@c_Elo_E",          (string) eloE);
                cmd.Parameters.AddWithValue("@i_Elo_K",          (Int32)  eloK);
                cmd.Parameters.AddWithValue("@i_Elo_New",        (Int32)  eloNew);
                cmd.Parameters.AddWithValue("@vc_Elo_C_table",   (string) eloCtable);
                cmd.Parameters.AddWithValue("@i_attach_count",   (Int32)  iAttCount);
                cmd.Parameters.AddWithValue("@i_max_attach_size",(Int32)  iMaxAttSize);

                // Add return value
                SqlParameter paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                paramReturnValue.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(paramReturnValue);

                SqlDataReader reader = cmd.ExecuteReader();
                reader.Close();
                sql.Close();
            }
        }

        static public void ResetLeaderboard(
            int    iTitleID,
            int    iLbID)
        {
            LbsvrClientConnection connection = null;
            IPEndPoint ip = null;

            string lbServer = GetNPDBLeaderboardServerByID(iTitleID, iLbID);
            try
            {
                IInterfaceInfo face = xonline.common.config.Config.GetInterface( lbServer, Interface.lbsvr );
                ip = new IPEndPoint(face.IPAddress, face.Port);

                connection = LbsvrClientConnection.OpenConnection( ip );
                connection.BeginRequest(1);
                connection.CallProc(
                    LbsvrClientConnection.LbProcIdResetLb,
                    new object[] {
                                        iTitleID,
                                        iLbID
                                    });

                connection.SendRequest();
            }
            catch( Exception e )
            {
                Xom.NtEvent( XEvent.Id.STATS_CONFIG_1, e, "DbLeaderboard: There was an error while attempting to reset leaderboard.");
                Console.WriteLine( "ResetLb: There was an error while attempting to reset leaderboard: " + e.ToString() );
            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }


#region for Move LBS Feature
        static public uint SetReadOnly(int nTitleId, int nLbId, string szServer)
        {
            return SetStatusCommon(nTitleId, nLbId, LbsvrClientConnection.LbProcIdSetLbToReadOnly, szServer);
        }

        static public uint SetReadWrite (int nTitleId, int nLbId, string szServer)
        {
            return SetStatusCommon(nTitleId, nLbId, LbsvrClientConnection.LbProcIdSetLbToReadWrite, szServer);
        }

        static private uint SetStatusCommon (int nTitleId, int nLbId, UInt32 uStatus, string szServer)
        {
            LbsvrClientConnection lbsvrConn = null;
            uint nSwapSeed = 0;

            try
            {
                IInterfaceInfo face     = xonline.common.config.Config.GetInterface( szServer, Interface.lbsvr );
                IPEndPoint ip           = new IPEndPoint(face.IPAddress, face.Port);
                
                lbsvrConn           = LbsvrClientConnection.OpenConnection(ip);

                lbsvrConn.BeginRequest(1);
                    
                lbsvrConn.CallProc(uStatus, new object[] {
                                                           ((Int32) nTitleId),
                                                           ((Int32) nLbId)
                                                       });
                    
                lbsvrConn.SendRequest();

                if(lbsvrConn.NextResult() != LbsvrClientResult.Rowset || !lbsvrConn.Read())
                    throw new LbsvrRequestException("LbProcIdGetLbRankedEntryCount", "Rowset expected");
                    
                nSwapSeed = (uint)(int)lbsvrConn.GetColumn(0);
            }
            catch
            {
                throw;
            }
            finally
            {
                if(lbsvrConn != null)
                    lbsvrConn.Close();
            }

            return nSwapSeed;
        }

        static public bool SafeToDeleteLb (uint nSwapSeed, string szServer)
        {
            LbsvrClientConnection lbsvrConn = null;
            bool bSafe = false;

            try
            {
                IInterfaceInfo face     = xonline.common.config.Config.GetInterface( szServer, Interface.lbsvr );
                IPEndPoint ip           = new IPEndPoint(face.IPAddress, face.Port);
                
                lbsvrConn           = LbsvrClientConnection.OpenConnection(ip);

                lbsvrConn.BeginRequest(1);
                    
                lbsvrConn.CallProc(LbsvrClientConnection.LbProcIdIsSafeToDeleteLb, new object[] {
                                                           unchecked((Int32)nSwapSeed)
                                                       });
                    
                lbsvrConn.SendRequest();

                if(lbsvrConn.NextResult() != LbsvrClientResult.Rowset || !lbsvrConn.Read())
                    throw new LbsvrRequestException("LbProcIdGetLbRankedEntryCount", "Rowset expected");
                    
                bSafe = (((sbyte)lbsvrConn.GetColumn(0) > 0)?true:false);
            }
            catch
            {
                throw;
            }
            finally
            {
                if(lbsvrConn != null)
                    lbsvrConn.Close();
            }

            return bSafe;
        }
    

        static public void UnLoadLb(int nTitleId, int nLbId, string szServer)
        {
            LbsvrClientConnection lbsvrConn = null;

            try
            {
                IInterfaceInfo face     = xonline.common.config.Config.GetInterface( szServer, Interface.lbsvr );
                IPEndPoint ip           = new IPEndPoint(face.IPAddress, face.Port);
                
                lbsvrConn           = LbsvrClientConnection.OpenConnection(ip);
                lbsvrConn.SetLongCommandTimeOut();

                lbsvrConn.BeginRequest(1);
                
                lbsvrConn.CallProc(LbsvrClientConnection.LbProcIdDeleteLbFromMemoryOnly, new object[] {
                                                                                                    ((Int32) nTitleId),
                                                                                                    ((Int32) nLbId)
                                                                                                });
                lbsvrConn.SendRequest();

                if(lbsvrConn.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException("UnLoadCommon", "Response not expected");
            }
            catch
            {
                throw;
            }
            finally
            {
                if(lbsvrConn != null)
                    lbsvrConn.Close();
            }
        }

        static public void LoadLb(int nTitleId, int nLbId, string szServer)
        {
            LbsvrClientConnection lbsvrConn = null;

            try
            {
                IInterfaceInfo face     = xonline.common.config.Config.GetInterface( szServer, Interface.lbsvr );
                IPEndPoint ip           = new IPEndPoint(face.IPAddress, face.Port);
                
                lbsvrConn           = LbsvrClientConnection.OpenConnection(ip);
                lbsvrConn.SetLongCommandTimeOut();
                
                lbsvrConn.BeginRequest(1);
                
                lbsvrConn.CallProc(LbsvrClientConnection.LbProcIdCreateAndLoadOneLb, new object[] {
                                                                                                    ((Int32) nTitleId),
                                                                                                    ((Int32) nLbId)
                                                                                                });
                lbsvrConn.SendRequest();

                if(lbsvrConn.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException("LoadCommon", "Response not expected");
            }
            catch
            {
                throw;
            }
            finally
            {
                if(lbsvrConn != null)
                    lbsvrConn.Close();
            }
        }  


        
#endregion

        static public bool IsLeaderBoardServer(string szServer)
        {
            IInterfaceInfo face     = xonline.common.config.Config.GetInterface( szServer, Interface.lbsvr );
            return !(null == face);
        }
    
        static public void SetLbsvrForTitle(int titleID, int nLbId, string szServer)
        {
            SqlConnection objCon  = null;

            try
            {
                objCon = new SqlConnection( ConfigUtil.NpdbConnectionString );
                objCon.Open();

                SqlCommand cmd    = objCon.CreateCommand();
                cmd.CommandType   = CommandType.StoredProcedure;
                cmd.CommandText   = "dbo.p_stats_update_server_for_lb";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int);
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_title_id"].Value     = titleID;

                cmd.Parameters.Add("@i_lb_id", SqlDbType.Int);
                cmd.Parameters["@i_lb_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_lb_id"].Value     = nLbId;

                cmd.Parameters.Add("@vc_server", SqlDbType.VarChar);
                cmd.Parameters["@vc_server"].Direction = ParameterDirection.Input;
                cmd.Parameters["@vc_server"].Value     = szServer;

                cmd.Parameters.Add("@result", SqlDbType.Int);
                cmd.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

                cmd.ExecuteNonQuery();
            }
            catch
            {
                throw;
            }
            finally
            {
                if (objCon != null)
                {
                    objCon.Close();
                    objCon = null;
                }
            }
        }

        static public void SetCompLbsvrForTitle(int titleID, int nCompPartID, string szServer)
        {
            SqlConnection objCon = null;

            try
            {
                objCon = new SqlConnection(ConfigUtil.NpdbConnectionString);
                objCon.Open();

                SqlCommand cmd = objCon.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_stats_update_server_for_complb";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int);
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_title_id"].Value = titleID;

                cmd.Parameters.Add("@i_comp_part_id", SqlDbType.Int);
                cmd.Parameters["@i_comp_part_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_comp_part_id"].Value = nCompPartID;

                cmd.Parameters.Add("@vc_server", SqlDbType.VarChar);
                cmd.Parameters["@vc_server"].Direction = ParameterDirection.Input;
                cmd.Parameters["@vc_server"].Value = szServer;

                cmd.Parameters.Add("@result", SqlDbType.Int);
                cmd.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

                cmd.ExecuteNonQuery();
            }
            catch
            {
                throw;
            }
            finally
            {
                if (objCon != null)
                {
                    objCon.Close();
                    objCon = null;
                }
            }
        }

        /// <summary>
        /// Locks the Creation of CompLBs for a Title on the given PartitionID
        /// </summary>
        /// <param name="titleID">TitleID</param>
        /// <param name="nCompPartID">PartitionID</param>
        /// <param name="bLockPartition">Lock/Unlock Flag</param>
        static public void LockCompLbsvrPartitionForTitle(int titleID, int nCompPartID, bool bLockPartition)
        {
            SqlConnection objCon = null;

            try
            {
                objCon = new SqlConnection(ConfigUtil.NpdbConnectionString);
                objCon.Open();

                SqlCommand cmd = objCon.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_stats_competition_partition_lock";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int);
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_title_id"].Value = titleID;

                cmd.Parameters.Add("@i_comp_part_id", SqlDbType.Int);
                cmd.Parameters["@i_comp_part_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_comp_part_id"].Value = nCompPartID;

                cmd.Parameters.Add("@i_lock_partition", SqlDbType.VarChar);
                cmd.Parameters["@i_lock_partition"].Direction = ParameterDirection.Input;
                if (bLockPartition)
                    cmd.Parameters["@i_lock_partition"].Value = 1;
                else
                    cmd.Parameters["@i_lock_partition"].Value = 0;

                cmd.Parameters.Add("@result", SqlDbType.Int);
                cmd.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

                cmd.ExecuteNonQuery();
            }
            catch
            {
                throw;
            }
            finally
            {
                if (objCon != null)
                {
                    objCon.Close();
                    objCon = null;
                }
            }
        }

        //Get all current LB for a lb server
        static public int [] GetAllLbForTitle(int titleID, string szServer)
        {

            ArrayList     list    = new ArrayList();
            SqlConnection objCon  = null;

            try
            {
                objCon = new SqlConnection( ConfigUtil.NpdbConnectionString );
                objCon.Open();

                SqlCommand cmd    = objCon.CreateCommand();
                cmd.CommandType   = CommandType.StoredProcedure;
                cmd.CommandText   = "dbo.p_stats_get_all_lb_for_title";

                cmd.Parameters.Add( "@i_title_id", SqlDbType.Int );
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_title_id"].Value     = titleID;

                cmd.Parameters.Add( "@vc_server", SqlDbType.VarChar );
                cmd.Parameters["@vc_server"].Direction = ParameterDirection.Input;
                cmd.Parameters["@vc_server"].Value     = szServer;
                
                SqlDataReader sqlReader = cmd.ExecuteReader();

                while ( sqlReader.Read() )
                {
                    int lbid = sqlReader.GetInt32( sqlReader.GetOrdinal( "i_lb_id" ) );
                    list.Add(lbid);
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                if (objCon != null)
                {
                    objCon.Close();
                    objCon = null;
                }
            }

            return (int [])list.ToArray(typeof(int));
        }

        /// <summary>
        /// Get all Competition LBs for a Title
        /// </summary>
        /// <param name="titleID">TitleID</param>
        /// <returns>LBIDs for the CLBs</returns>
        static public int[] GetAllCompLbForTitle(int titleID)
        {

            ArrayList list = new ArrayList();
            SqlConnection objCon = null;

            try
            {
                objCon = new SqlConnection(ConfigUtil.NpdbConnectionString);
                objCon.Open();

                SqlCommand cmd = objCon.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_stats_get_complbs_for_title";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int);
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
                cmd.Parameters["@i_title_id"].Value = titleID;

                SqlDataReader sqlReader = cmd.ExecuteReader();

                while (sqlReader.Read())
                {
                    int lbid = sqlReader.GetInt32(sqlReader.GetOrdinal("i_lb_id"));
                    list.Add(lbid);
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                if (objCon != null)
                {
                    objCon.Close();
                    objCon = null;
                }
            }

            return (int[])list.ToArray(typeof(int));
        }

        static public List<string> GetLeaderboardColumnIDs(uint titleID, int lbID)
        {
            SqlConnection sql = null;
            List<string> result = new List<string>();

            IInterfaceInfo info = xonline.common.config.Config.GetSingleInterface(Interface.webdb);
            string connectionStr = "Data Source=" + info.IPAddressString + ";Trusted_Connection=Yes;Initial Catalog=" + info.DBName;

            using (sql = new SqlConnection(connectionStr))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_webdb_get_lb_cols", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id", (int)titleID);
                cmd.Parameters.AddWithValue("@i_lb_id", (int)lbID);

                SqlDataReader lbReader = cmd.ExecuteReader();
                while (lbReader.Read())
                {
                    string col_id = lbReader.GetString(lbReader.GetOrdinal("vc_name"));
                    // string vc_display_name = lbReader.GetString(lbReader.GetOrdinal("vc_display_name"));
                    if (!result.Contains(col_id))
                        result.Add(col_id);
                }
            }
            return result;
        }

        /// <summary>
        /// Delete all platform visible leaderboard metadata from NPDB's t_platform_visible_leaderboards table
        /// for a provided titleId.
        /// </summary>
        /// <param name="uiTitleID">uiTitleID</param>        
        static public void DeletePlatformVisibleLeaderboardMetadataForTitleId(uint uiTitleID)
        {
            using (SqlConnection sql = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_stats_platform_visible_leaderboards_delete_all_for_title_id";
                cmd.Parameters.AddWithValue("@i_title_id", (Int32)uiTitleID);

                cmd.ExecuteNonQuery();
            } // using
        }

        /// <summary>
        /// Add a new platform visible leaderboard metadata row to NPDB's t_platform_visible_leaderboards table
        /// with the provided input data.
        /// </summary>
        /// <param name="uiTitleID">uiTitleID</param>
        /// <param name="uiLbId">uiLbId</param>
        /// <param name="locale">locale</param>
        /// <param name="uiRatingAttrId">uiRatingAttrId</param>
        /// <param name="bFlags">bFlags</param>
        /// <param name="bFlags">bType</param>        
        /// <param name="bFlags">bFormat</param>        
        /// <param name="name">name</param>
        /// <param name="rating">rating</param>
        static public void AddPlatformVisibleLeaderboardMetaData(
            uint    uiTitleID, 
            uint    uiLbId,
            string  locale,
            ushort  usRatingAttrId,
            byte    bFlags,
            byte    bType,
            byte    bFormat,
            string  name,
            string  rating)
        {
            using (SqlConnection sql = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                sql.Open();
                SqlCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_stats_platform_visible_leaderboard_add";

                cmd.Parameters.AddWithValue("@i_title_id",          (Int32)uiTitleID);
                cmd.Parameters.AddWithValue("@i_lb_id",             (Int32)uiLbId);
                cmd.Parameters.AddWithValue("@vc_locale",           (string)locale);
                cmd.Parameters.AddWithValue("@si_rating_attr_id",   (Int16)usRatingAttrId);
                cmd.Parameters.AddWithValue("@ti_flags",            (byte)bFlags);
                cmd.Parameters.AddWithValue("@ti_type",             (byte)bType);
                cmd.Parameters.AddWithValue("@ti_format",           (byte)bFormat);
                cmd.Parameters.AddWithValue("@vc_name",             (string)name);
                cmd.Parameters.AddWithValue("@vc_rating",           (string)rating);                

                cmd.ExecuteNonQuery();
            } // using
        }       

        /// <summary>
        /// Get all current platform visible leaderboard data for a titleId within NPDB, and integrate that data in each corresponding
        /// LeaderboardSettings object passed in the ArrayList (leaderboards)
        /// </summary>
        /// <param name="titleID">titleID</param>
        /// <param name="leaderboards">leaderboards</param>
        static private void GetNPDBPlatformLeaderboardConfiguration(uint titleID, ref ArrayList leaderboards)
        {            
            using (SqlConnection leaderboardConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                leaderboardConn.Open();
                SqlCommand lbCmd = leaderboardConn.CreateCommand();
                lbCmd.CommandType = CommandType.StoredProcedure;
                lbCmd.CommandText = "dbo.p_stats_platform_visible_leaderboards_get_all_for_title_id";
                lbCmd.Parameters.AddWithValue("@i_title_id", (int)titleID);
                
                SqlDataReader lbReader = lbCmd.ExecuteReader();

                // do we have results?
                while (lbReader.Read())
                {
                    uint lbid = (uint)lbReader.GetInt32(lbReader.GetOrdinal("i_lb_id"));
                    string locale = lbReader.GetString(lbReader.GetOrdinal("vc_locale"));
                    ushort ratingAttrId = (ushort)lbReader.GetInt16(lbReader.GetOrdinal("si_rating_attr_id"));
                    byte flags = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_flags"));
                    byte type = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_type"));
                    byte format = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_format"));
                    string name = lbReader.GetString(lbReader.GetOrdinal("vc_name"));
                    string rating = lbReader.GetString(lbReader.GetOrdinal("vc_rating"));

                    foreach (LeaderboardSettings lb in leaderboards)
                    {
                        if (lbid == lb.LeaderboardID)
                        {
                            lb.AddPlatformVisibleLeaderboardInfo(locale, ratingAttrId, flags, type, format, name, rating);
                        }
                    }
                } // while rows
            } // using
        }

        static public ArrayList GetNPDBLeaderboardConfiguration( uint titleID )
        {

            int title = (int) titleID;
            ArrayList leaderboards = new ArrayList( 20 );
            LeaderboardSettings lb;

            using (SqlConnection leaderboardConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                leaderboardConn.Open();
                SqlCommand lbCmd = leaderboardConn.CreateCommand();
                lbCmd.CommandType = CommandType.StoredProcedure;
                lbCmd.CommandText = "dbo.p_stats_lb_get_all";

                lbCmd.Parameters.Add( "@vc_server", SqlDbType.VarChar ).Value = statWildCard;
                lbCmd.Parameters["@vc_server"].Direction = ParameterDirection.Input;

                lbCmd.Parameters.Add( "@hr", SqlDbType.Int );
                lbCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader lbReader = lbCmd.ExecuteReader();

                // do we have results?
                while ( lbReader.Read() )
                {

                   if (title == lbReader.GetInt32(1))
                   {
                        int lbid = lbReader.GetInt32( lbReader.GetOrdinal( "i_lb_id" ) );
                        if (StatLbIdParser.IsCompetition((uint)lbid))
                        {
                            // skip competition instance leaderboards
                            //continue;
                        }

                        //task: this really begs to be unit tested...
                        lb = new LeaderboardSettings(
                            //doing it this way prevents a changed sql procedure from messing us up
                            lbReader.GetString( lbReader.GetOrdinal( "vc_server" ) ),           // server
                            //database titleid is int, otherwise this uses uint
                            (uint)lbReader.GetInt32( lbReader.GetOrdinal( "i_title_id" ) ),     // titleid
                            lbid,                                                               // lbid
                            (byte)lbReader.GetInt32( lbReader.GetOrdinal( "i_reset_type" ) ),   // reset type
                            lbReader.GetInt32( lbReader.GetOrdinal( "i_attach_count" )  ),      // max attachments
                            lbReader.GetInt32( lbReader.GetOrdinal( "i_max_attach_size" ) ),    // max attachment size
                            lbReader.GetInt32( lbReader.GetOrdinal( "i_decay_days" )  ),        // decay days

                            //Elo settings need to be supported for back-compat to Xbox titles
                            lbReader.GetString( lbReader.GetOrdinal( "c_Elo_E" ) ),             // elo e
                            lbReader.GetInt32( lbReader.GetOrdinal( "i_Elo_K" ) ),              // elo k
                            lbReader.GetInt32( lbReader.GetOrdinal( "i_Elo_New" ) ),            // elo new
                            lbReader.GetString( lbReader.GetOrdinal( "vc_Elo_C_table" ) ),      // elo table

                            lbReader.GetInt32( lbReader.GetOrdinal( "ti_top_100" ) ),          // is this a top100 lb?
                            System.Convert.ToBoolean( lbReader.GetInt32( lbReader.GetOrdinal( "ti_is_team_lb" ) ) ),       // is this a team lb?
                            System.Convert.ToBoolean( lbReader.GetInt32( lbReader.GetOrdinal( "ti_req_arb" ) ) ),          // is this lb arbitrated?

                            lbReader.GetDateTime( lbReader.GetOrdinal( "dt_last_reset" )  )        // last reset of this LeaderboardSettings
                            );
                        leaderboards.Add( lb );

                    }

                } // while rows

            } // using

            leaderboards.TrimToSize();
            
            if (leaderboards.Count > 0)
            {
                // get platform visible leaderboard data for all leaderboards in the leaderboard ArrayList
                GetNPDBPlatformLeaderboardConfiguration(titleID, ref leaderboards);
            }

            return leaderboards;
        } // display leaderboards


        /// <summary>
        /// Return the leaderboard server on which the given LB is configured.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="lbID"></param>
        /// <returns></returns>
        static public string GetNPDBLeaderboardServerByID( int titleID, int lbID )
        {
            string lbServer = "";

            using (SqlConnection leaderboardConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                leaderboardConn.Open();
                SqlCommand lbCmd = leaderboardConn.CreateCommand();
                lbCmd.CommandType = CommandType.StoredProcedure;
                lbCmd.CommandText = "dbo.p_stats_lb_get";

                lbCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = titleID;
                lbCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                lbCmd.Parameters.Add( "@i_lb_id", SqlDbType.Int ).Value = lbID;
                lbCmd.Parameters["@i_lb_id"].Direction = ParameterDirection.Input;

                lbCmd.Parameters.Add( "@r", SqlDbType.Int );
                lbCmd.Parameters["@r"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader lbReader = lbCmd.ExecuteReader();

                // do we have results?
                if ( lbReader.Read() )
                {
                    lbServer = lbReader.GetString( lbReader.GetOrdinal( "vc_server" ) );
                }
                else
                    throw new Exception("sproc dbo.p_stats_lb_get did not return " +
                        "any rows for title " + titleID.ToString("X") +
                        " and leaderboard " + lbID.ToString() + ".");
            } // using

            return lbServer;
        }

        static public string DisplayLeaderboards( ArrayList leaderboards )
        {
            StringBuilder sb = new StringBuilder( 500 );
            sb.Append( "Leaderboard Configuration " );
            sb.Append( "\r\n" );

            //sb.AppendFormat( "Leadboards for TitleID: {0}\n",titleID );
            sb.Append( "ServerName      TitleID    LBID    Rst t100 TmLB Arb DcyDy ELO_E ELO_K ELO_N ELO_CT Attach MxAttch LastReset" );
            sb.Append( "\r\n" );
            // do we have results?
            for ( int iLoop = 0; iLoop < leaderboards.Count; iLoop++ )
            {
                sb.AppendFormat( "{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14}",
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).LBServer.PadRight( 15 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TitleID.ToString().PadRight( 10 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).LeaderboardID.ToString().PadRight( 7 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).ResetType.ToString().PadRight( 3 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TopEntries.ToString().PadRight( 4 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TeamView.ToString().Substring(0,1).PadRight( 4 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).Arbitrated.ToString().Substring(0,1).PadRight( 3 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).DecayDays.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloE.PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloK.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloNew.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloCtable.PadRight( 6 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).MaxAttachments.ToString().PadRight( 6 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).MaxAttachmentSize.ToString().PadRight( 7 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).LastReset.ToString()
                    );
                sb.Append( "\r\n" );

            }// for
            return sb.ToString();
        }


        static public string DisplayCompetitionTemplates( ArrayList leaderboards )
        {
            StringBuilder sb = new StringBuilder( 500 );
            sb.Append( "Competition Template Configuration\r\n" );

            sb.Append( "TitleID    LBID    Rst t100 TmLB Arb DcyDy ELO_E ELO_K ELO_N ELO_CT Attach MxAttch LastReset" );
            sb.Append( "\r\n" );

            for ( int iLoop = 0; iLoop < leaderboards.Count; iLoop++ )
            {
                sb.AppendFormat( "{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14}",
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TitleID.ToString().PadRight( 10 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).LeaderboardID.ToString().PadRight( 7 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).ResetType.ToString().PadRight( 3 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TopEntries.ToString().PadRight( 4 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).TeamView.ToString().Substring(0,1).PadRight( 4 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).Arbitrated.ToString().Substring(0,1).PadRight( 3 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).DecayDays.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloE.PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloK.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloNew.ToString().PadRight( 5 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).EloCtable.PadRight( 6 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).MaxAttachments.ToString().PadRight( 6 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).MaxAttachmentSize.ToString().PadRight( 7 ),
                    ( (LeaderboardSettings) leaderboards[ iLoop ] ).LastReset.ToString()
                    );
                sb.Append( "\r\n" );

            }// for
            return sb.ToString();
        }

        static public void DeleteLeaderboardFromWebDB( uint titleId, int lbId)
        {
            SqlConnection sql = null;

            IInterfaceInfo info = xonline.common.config.Config.GetSingleInterface( Interface.webdb );
            string connectionStr = "Data Source=" + info.IPAddressString + ";Trusted_Connection=Yes;Initial Catalog=" + info.DBName;

            using (sql = new SqlConnection( connectionStr ))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_webdb_tmr_delete_lb", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",                   (int)titleId);
                cmd.Parameters.AddWithValue("@i_lb_id",                      (int)lbId);

                cmd.ExecuteNonQuery();
            }

        }

        static public void DeleteLeaderboardFromLbsvr(uint titleId, int lbId)
        {
            LbsvrClientConnection connection = null;
            IPEndPoint ip = null;
            IInterfaceInfo lbsvrInterface = null;

            ArrayList leaderboards = GetNPDBLeaderboardConfiguration( titleId );
            LeaderboardSettings lb = null;

            for (int i = 0; i < leaderboards.Count; i++)
            {
                if (((LeaderboardSettings)leaderboards[i]).LeaderboardID == lbId)
                {
                    lb = (LeaderboardSettings)leaderboards[i];
                    break;
                }
            }

            if ( lb == null )
            {
                string eventText = "DeleteLeaderboard: Couldn't find leaderboard to delete!! titleId = " + (TitleId) titleId + "  lb: " + lbId;
                Xom.NtEvent( XEvent.Id.STATS_CONFIG_2, eventText );
                throw new Exception(eventText);
            }

            if ( lb.LBServer != "" )
            {
                try
                {
                    lbsvrInterface = xonline.common.config.Config.GetInterface( lb.LBServer, Interface.lbsvr );
                    ip = new IPEndPoint( lbsvrInterface.IPAddress, lbsvrInterface.Port );
                }
                catch( Exception e )
                {
                    Xom.NtEvent(XEvent.Id.STATS_CONFIG_3, e,  "DeleteTitlesLeaderboards: Problem retrieving config information for server: '{0}'", lb.LBServer);
                    throw e;
                }

            }
            else
            {
                string eventText = "DeleteTitlesLeaderboards: Some leaderboards in NPDB did not have a LeaderboardSettings Server associated with them!";
                Xom.NtEvent( XEvent.Id.STATS_CONFIG_4, eventText );
                throw new Exception( eventText );
            }

            try
            {
                connection = LbsvrClientConnection.OpenConnection( ip );
                connection.BeginRequest(1);
                connection.CallProc(
                    LbsvrClientConnection.LbProcIdDeleteLb,
                    new object[] {  (Int32) lb.TitleID,  (Int32) lb.LeaderboardID }
                    );

                connection.SendRequest();

            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }        
    
        /*
            10/12/2006 - Bug 73874

            I need a way to update a LB meta data (e.g. Attachmentsize) but there is no update stored procedure.
            We will do an update by doing a delete followed by an insert. Note that this is only against NPDB. All user data are preserved.
        */
        static public void UpdateLbInNPDB(LeaderboardSettings lb)
        {
            DeleteLbInNPDB(lb.TitleID, lb.LeaderboardID);
        
            CreateLeaderboardInNPDB(
                    lb.LBServer,
                    lb.TitleID,
                    lb.LeaderboardID,
                    lb.ResetType,
                    lb.MaxAttachments,
                    lb.MaxAttachmentSize,
                    lb.DecayDays,
                    lb.TopEntries,
                    lb.EloE,
                    lb.EloK,
                    lb.EloNew,
                    lb.EloCtable,
                    lb.TeamView,
                    lb.Arbitrated
                    );

        }

        static public void UpdateLbInWebDB(LeaderboardSettings lb)
        {
            DeleteLeaderboardFromWebDB(lb.TitleID, lb.LeaderboardID);

            CreateLeaderboardInWebDb(lb);
        }

        static private void DeleteLbInNPDB(uint uiTitleID, int nLbID)
        {
            using (SqlConnection objSql = new SqlConnection( ConfigUtil.NpdbConnectionString ))
            {
                objSql.Open();

                SqlCommand objCmd = new SqlCommand("p_stats_lb_delete", objSql);
                objCmd.CommandType = CommandType.StoredProcedure;
                objCmd.Parameters.AddWithValue("@i_title_id", (int)uiTitleID);
                objCmd.Parameters.AddWithValue("@i_lb_id"   , nLbID);

                objCmd.ExecuteNonQuery();
            }
        }

        static public void DeleteLeaderboard( uint titleId, int lbId )
        {
            DeleteLeaderboardFromLbsvr(titleId, lbId);
            DeleteLeaderboardFromWebDB(titleId, lbId);
        }

        // analogous to the createleaderboard
        // copied from "Reset" below...
        static public void DeleteTitlesLeaderboards( uint titleId )
        {
            //retrieve NPDB info about current lbs...
            ArrayList leaderboards = GetNPDBLeaderboardConfiguration( titleId );
            LeaderboardSettings lb = null;

            for ( int iLoop = 0; iLoop < leaderboards.Count; iLoop++ )
            {
                lb = ( LeaderboardSettings ) leaderboards[ iLoop ];
                DeleteLeaderboard(lb.TitleID, lb.LeaderboardID);

            } // for

            using (SqlConnection sql = new SqlConnection( ConfigUtil.NpdbConnectionString ))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_stats_title_delete", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",                   (int)titleId);

                cmd.ExecuteNonQuery();
            }

        } //delete title

        static public void DeleteCompetitionTemplate( uint titleId, int compTemplateId )
        {
            using (SqlConnection sql = new SqlConnection( ConfigUtil.NpdbConnectionString ))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_stats_competition_template_delete", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",                   (int)titleId);
                cmd.Parameters.AddWithValue("@i_comp_templ_id",              compTemplateId);

                cmd.ExecuteNonQuery();
            }
        }




        static public void CreateCompetitionTemplate( LeaderboardSettings lb )
        {
            SqlConnection sql = null;
            try
            {
                sql = new SqlConnection( ConfigUtil.NpdbConnectionString );
                sql.Open();

                int realTopEntries = 0;
                switch ( lb.TopEntries )
                {
                    case 100:
                        realTopEntries = 1;
                        break;

                        //Xlast actually contains unsigned long 0xffffffff
                    case -1:
                        realTopEntries = 0;
                        break;

                    default:
                        throw new Exception( "Top Entries Value for title " + lb.TitleID.ToString("X8") + " lbid " + lb.LeaderboardID.ToString() );
                }

                SqlCommand cmd = new SqlCommand("dbo.p_stats_competition_template_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",       ((int)   lb.TitleID));
                cmd.Parameters.AddWithValue("@i_comp_templ_id",  (Int32)  lb.LeaderboardID); //comp_template_id aka leaderboardID
                cmd.Parameters.AddWithValue("@i_reset_type",     (Int32)  lb.ResetType);
                cmd.Parameters.AddWithValue("@ti_top_100",       (byte)   realTopEntries);
                cmd.Parameters.AddWithValue("@ti_team",          (byte)   (lb.TeamView ? 1 : 0));
                cmd.Parameters.AddWithValue("@ti_req_arb",       (byte)   (lb.Arbitrated ? 1 : 0));
                cmd.Parameters.AddWithValue("@i_decay_days",     (Int32)  lb.DecayDays);
                cmd.Parameters.AddWithValue("@c_Elo_E",          (string) lb.EloE);
                cmd.Parameters.AddWithValue("@i_Elo_K",          (Int32)  lb.EloK);
                cmd.Parameters.AddWithValue("@i_Elo_New",        (Int32)  lb.EloNew);
                cmd.Parameters.AddWithValue("@vc_Elo_C_table",   (string) lb.EloCtable);
                cmd.Parameters.AddWithValue("@i_attach_count",   (Int32)  lb.MaxAttachments);
                cmd.Parameters.AddWithValue("@i_max_attach_size",(Int32)  lb.MaxAttachmentSize);

                // Add return value
                SqlParameter paramReturnValue = new SqlParameter("@RETURN_VALUE",SqlDbType.Int);
                paramReturnValue.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(paramReturnValue);

                SqlDataReader reader = cmd.ExecuteReader();
                //if ((int)paramReturnValue.Value != 0)
                //    throw new Exception("Error: dbo.p_stats_lb_add returned " + paramReturnValue.Value.ToString());
                reader.Close();

                cmd = new SqlCommand("dbo.p_stats_competition_partition_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@vc_server",     (string) lb.LBServer);
                cmd.Parameters.AddWithValue("@i_title_id",    (int)    lb.TitleID);
                // task: is partition id always supposed to be 0??
                // oddly, SqlParamter treats this as "use the default.."
                //cmd.Parameters.Add("@i_comp_part_id", (int)   0);
                cmd.Parameters.AddWithValue("@i_comp_part_id", SqlDbType.Int);
                cmd.Parameters["@i_comp_part_id"].Value = 0;


                cmd.ExecuteNonQuery();

            }
            catch( SqlException se )
            {
                string eventText = "DbLeaderboard: There was a SQL error while adding a competition template.";
                Xom.NtEvent( XEvent.Id.STATS_CONFIG_5, se, eventText );
                throw new Exception(eventText, se);
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }

        }



        static public void RemoveUsersStats(
            int    iTitleID,
            int    iLbID,
            Int64  userPuid)
        {
            LbsvrClientConnection connection = null;
            IPEndPoint ip = null;

            string lbServer = GetNPDBLeaderboardServerByID(iTitleID, iLbID);
            try
            {
                IInterfaceInfo face = xonline.common.config.Config.GetInterface( lbServer, Interface.lbsvr );
                ip = new IPEndPoint(face.IPAddress, face.Port);

                connection = LbsvrClientConnection.OpenConnection( ip );
                connection.BeginRequest(1);
                connection.CallProc(
                    LbsvrClientConnection.LbProcIdResetPuid,
                    new object[] {
                                        iTitleID,
                                        iLbID,
                                        userPuid
                                    });

                connection.SendRequest();
            }
            catch
            {
                throw;
            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }

        static public void ZeroAttachmentSizeForUser(
            int    iTitleID,
            int    iLbID,
            Int64  userPuid)
        {
            LbsvrClientConnection connection = null;
            IPEndPoint ip = null;

            string lbServer = GetNPDBLeaderboardServerByID(iTitleID, iLbID);
            try
            {
                IInterfaceInfo face = xonline.common.config.Config.GetInterface( lbServer, Interface.lbsvr );
                ip = new IPEndPoint(face.IPAddress, face.Port);

                connection = LbsvrClientConnection.OpenConnection( ip );
                connection.BeginRequest(1);
                connection.CallProc(
                    LbsvrClientConnection.LbProcIdStatWrite,
                    new object[] {
                                        iTitleID,
                                        iLbID,
                                        userPuid,
                                        (Int64) 0,
                                        (Int16) 1,
                                        unchecked((Int16) SpecialAttrib.AttachmentSize),
                                        unchecked((Int32) 0),
                                    });

                connection.SendRequest();
            }
            catch
            {
                throw;
            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }

        

        //task: implement
        static public void ReportUsersStats( uint titleID, int leaderboardID, uint puid )
        {
            throw new Exception( "Not Implemented Yet " );
        }

        static public void ConfigureTitle( uint uiTitleId, int MaxWrites, int MaxReads )
        {
            SqlConnection sql = null;

            try
            {
                sql = new SqlConnection( ConfigUtil.NpdbConnectionString );

                sql.Open();

                SqlCommand cmd = new SqlCommand("p_stats_title_set_limits", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",     (int) uiTitleId );
                cmd.Parameters.AddWithValue("@i_max_writes",   MaxWrites);
                cmd.Parameters.AddWithValue("@i_max_reads",    MaxReads);
                cmd.ExecuteNonQuery();
            }
            catch( SqlException se )
            {
                Xom.NtEvent( XEvent.Id.STATS_COMM_0, se, "DbLeaderboard: There was a SQL error while calling p_stats_title_set_limits.");
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }

        } // configure title


        //Return list of title played by the user
        static public Hashtable GetPlayedUserTitle(ulong  ulUserPuid)
        {
            Hashtable htTitleIdPlayed = new Hashtable();
            
            HResult hr = HResult.S_OK;
            EnumTitlesRequest actualReq = new EnumTitlesRequest();
            EnumTitlesResponse actualResp = new EnumTitlesResponse();
            XRLObject2 xrlObject = actualResp;

            actualReq.UserId = ulUserPuid;
            actualReq.ForUserId = ulUserPuid;
            actualReq.LocaleId = (ushort)Locales.en_US;
            actualReq.StartingIndex = 0;
            actualReq.MaxTitles = ushort.MaxValue;

            // this stuff is coming off the web, we don't have a machine id
            // or a user id, so we like about it.  pass zeroes for all that
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, 0, ulUserPuid, XOn.XENON_DASH_TITLE_ID, (uint)XOService.Progress, 0);

            hr = XRLUtil.PostXrlRequest(VirtualInterface.progressfd_int, actualReq.Xrl, authData.GetBase64EncodedString(), actualReq, ref xrlObject);

            if (HResult.S_OK == hr)
            {
                foreach (UserTitle title in actualResp.Titles)
                {
                    htTitleIdPlayed[title.TitleId] = 1;
                }
            }
            
            return htTitleIdPlayed;
        }


        /*
            The hashtable structure is as follows
                (TitleID, Hashtable2)

            The hashtable2 is as follows
                (lbid, 1)
        */

        static Hashtable _hashAllLeaderboard = null;
        
        static public Hashtable GetAllLeaderboardInfoForServer(string strServer)
        {            
            SqlConnection sqlConnection = null;
            SqlDataReader sqlReader = null;
            Hashtable hashLeaderboardInfo = new Hashtable();
            
            try
            {
                sqlConnection = new SqlConnection(xonline.common.config.Config.NpdbConnectionString);
                sqlConnection.Open();
                
                SqlCommand sqlCmd = new SqlCommand("p_stats_lb_get_all", sqlConnection);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlCmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = strServer;
                sqlReader = sqlCmd.ExecuteReader();
                
                while(sqlReader.Read())
                {
                    int nTitleId       = (Int32)sqlReader.GetValue(1);
                    int nLbId          = (Int32)sqlReader.GetValue(2);

                    if (null == hashLeaderboardInfo[nTitleId])
                    {
                        hashLeaderboardInfo[nTitleId] = new Hashtable();
                    }

                    ((Hashtable)hashLeaderboardInfo[nTitleId])[nLbId] = 1;
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                if (null != sqlReader)
                {
                    sqlReader.Close();
                }

                if (null != sqlConnection)
                {
                    sqlConnection.Close();
                }
            }

            return hashLeaderboardInfo;
        }

        static public Hashtable GetAllLeaderboardInfo()
        {
            return GetAllLeaderboardInfoForServer("ALL");
        }

        /*
            userPuid - User Puid of the user to Nuke from all leaderboards
            In the event of an error, this method will throw an exception. 
            This method is  "recallable" without any noticeable user side effect. In the event of an error, e.g. Stats FD was out of VIP
            you may recall this API with the same user and it will continue cleaning the user up.

            This API is thread safe but should not be called concurrently with the same user.
        */
        static public void RemoveUserFromAllLeaderboards(ulong ulUserPuid)
        {
            try
            {
                if (null == _hashAllLeaderboard)
                {
                    lock(typeof(DbLeaderboard))
                    {
                        if (null == _hashAllLeaderboard)
                        {
                            _hashAllLeaderboard = GetAllLeaderboardInfo();
                        }
                    }
                }

                //let's find out all the titles played by this user
                Hashtable htUserPlayedTitle = GetPlayedUserTitle(ulUserPuid);

                //iterate through all the title's played
                foreach (int nTitleId in htUserPlayedTitle.Keys)
                {
                    Hashtable htLeaderboard = (Hashtable)_hashAllLeaderboard[nTitleId];
                    if (null == htLeaderboard)
                    {
                        //this guy played a title which does not exist anymore? - this does not seem right, throw an exception for now
                        throw new Exception(String.Format("User {0} Played Title {1} Title Does not Exist in NPDB", ulUserPuid, nTitleId));
                    }
                    
                    //iterate through all the cache leaderboard
                    foreach (int nLbId in htLeaderboard.Keys)
                    {
                        //first we perform a stat read to check if we need a delete - minimize write
                        //if (StatFrontDoorUtilities.IsUserMemberOfLeaderboard(ulUserPuid,(uint)nTitleId, (uint)nLbId))
                        //{
                            /*
                                We can't do a stat Read First because we do not know what to read
                                I initially thought about reading Rank but Rank is not guaranteed in all leaderboard believe it or not
                                There are some leaderboards which are used for user "settings" and hence require no rank
                            */
                            StatFrontDoorUtilities.DeleteUserFromLeaderboard(ulUserPuid,(uint)nTitleId, (uint)nLbId);
                        //}
                    }
                }
                
            }
            catch
            {
               throw;
            }
            finally
            {
                
            }
        }
    } // dbleaderboard class
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\socialQuery\test\func\SocialQuery.cs ===
using System;
using System.Text;
using System.Threading;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;
using xonline.common.protocol.socialquery;
using xonline.common.community;
using xonline.common.protocol;
using xonline.common.stfutil;
using xonline.common.service;

[assembly: RootNode(typeof(SocialQueryTest.Suite))]

namespace SocialQueryTest
{
    [Owner("smichael"), TestFrequency("Daily"), Description("Social Query tests")]
    public class Suite : TestNode
    {
        ////////////////////////////////////////////////
        // Initialize
        //
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                // Let the fake SG know where to send state updates
                GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());
            }
        }
    }

    public class SocialQueryTestBaseGroup : TestNode
    {
        public FriendsCommon _fc;
        protected ArrayList _alUsers;
        static public Report ro = new Report("GetUserList");

        private bool needToWaitForXCache;
        protected bool printData;

        public SocialQueryTestBaseGroup()
            : base()
        {
        }


        [TestGroupSetup]
        public virtual void Setup()
        {
            _fc = new FriendsCommon();
            _alUsers = new ArrayList();
        }

        [TestGroupTearDown]
        public virtual void TearDown()
        {
            foreach (PNUser user in _alUsers)
            {
                user.Dispose();
            }
            _fc = null;
            _alUsers = null;
        }

        #region Privacy Functionality

        public enum ePrivacySetting
        {
            Blocked,
            FriendsOnly,
            Everyone,


            MAX = Everyone
        }

        public enum eUserAppearOnlineStatus
        {
            eAppearOffline = 0,
            eAppearOnline,
            eAppearAway,
            eAppearBusy
        }

        public class OnlineStatusVariation
        {
            public bool isAccepted;
            public ePrivacySetting presencePrivacy;
            public bool appearOffline;
            public bool stateVisible;
            public bool isLoggedOn;
            public PNUser user;

            protected OnlineStatusVariation() { }

            public OnlineStatusVariation(bool isAccepted, ePrivacySetting presencePrivacy, bool appearOffline, bool stateVisible)
            {
                this.isAccepted = isAccepted;
                this.presencePrivacy = presencePrivacy;
                this.appearOffline = appearOffline;
                this.stateVisible = stateVisible;
                this.isLoggedOn = stateVisible;  // TODO: fix this legacy issue
            }

            public OnlineStatusVariation(bool isAccepted, ePrivacySetting presencePrivacy, bool appearOffline, bool stateVisible, bool isLoggedOn)
            {
                this.isAccepted = isAccepted;
                this.presencePrivacy = presencePrivacy;
                this.appearOffline = appearOffline;
                this.stateVisible = stateVisible;
                this.isLoggedOn = isLoggedOn;
            }

            public OnlineStatusVariation(OnlineStatusVariation osv)
            {
                this.isAccepted = osv.isAccepted;
                this.presencePrivacy = osv.presencePrivacy;
                this.appearOffline = osv.appearOffline;
                this.stateVisible = osv.stateVisible;
                this.isLoggedOn = osv.isLoggedOn;
                this.user = osv.user;
            }
        }

        public class FriendsOfFriendsOnlineStatusVariation
        {
            public OnlineStatusVariation[] osvs;
            public eFriendshipState requestorToOwner;
            public eFriendshipState requestorToTarget;
            public ePrivacySetting ownerFriendsListPrivacy;

            public FriendsOfFriendsOnlineStatusVariation(eFriendshipState requestorToOwner, eFriendshipState requestorToTarget, ePrivacySetting ownerFriendsListPrivacy, bool isAccepted, ePrivacySetting presencePrivacy, bool appearOffline, bool stateVisible, bool isLoggedOn)
            {
                this.osvs = new OnlineStatusVariation[1];
                this.osvs[0] = new OnlineStatusVariation(isAccepted, presencePrivacy, appearOffline, stateVisible, isLoggedOn);
                this.requestorToOwner = requestorToOwner;
                this.requestorToTarget = requestorToTarget;
                this.ownerFriendsListPrivacy = ownerFriendsListPrivacy;
            }

            public FriendsOfFriendsOnlineStatusVariation(eFriendshipState requestorToOwner, eFriendshipState requestorToTarget, ePrivacySetting ownerFriendsListPrivacy, OnlineStatusVariation[] osv)
            {
                this.osvs = new OnlineStatusVariation[osv.Length];
                for (int i = 0; i < osv.Length; i++)
                {
                    this.osvs[i] = new OnlineStatusVariation(osv[i]);
                }

                this.requestorToOwner = requestorToOwner;
                this.requestorToTarget = requestorToTarget;
                this.ownerFriendsListPrivacy = ownerFriendsListPrivacy;
            }
        }

        public static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            ServerTestFramework.LiveService.UserAccount.UserPrivileges grants = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();
            ServerTestFramework.LiveService.UserAccount.UserPrivileges restrictions = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();
        }

        public static void SetPresencePrivacy(PNUser user, ePrivacySetting privacySetting)
        {
            switch (privacySetting)
            {
                case ePrivacySetting.Blocked:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE, false);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);
                    break;

                case ePrivacySetting.FriendsOnly:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE, false);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
                    break;

                case ePrivacySetting.Everyone:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE, true);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
                    break;
            }
            ro.Debug("Sleeping 5s to set privileges for user " + user.UserId + " | " + user.Name);
            Thread.Sleep(5000);
        }

        public static void SetFriendsListPrivacy(PNUser user, ePrivacySetting privacySetting)
        {
            switch (privacySetting)
            {
                case ePrivacySetting.Blocked:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, false);
                    break;

                case ePrivacySetting.FriendsOnly:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, true);
                    break;

                case ePrivacySetting.Everyone:
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, true);
                    SetPrivilege(user, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, true);
                    break;
            }
            ro.Debug("Sleeping 5s to set privileges for user " + user.UserId + " | " + user.Name);
            Thread.Sleep(5000);
        }

        public bool CanUserViewTargetsFriendsList(eFriendshipState requestorToTarget, ePrivacySetting priv)
        {
            if (ePrivacySetting.Blocked == priv)
                return false;
            if (ePrivacySetting.Everyone == priv)
                return true;
            if (ePrivacySetting.FriendsOnly == priv && eFriendshipState.eFullFriendship == requestorToTarget)
                return true;

            return false;
        }

        public bool CanUserViewTargetsOnlineStatus(eFriendshipState requestorToTarget, OnlineStatusVariation osv)
        {
            if (osv.appearOffline || ePrivacySetting.Blocked == osv.presencePrivacy)
                return false;
            if (ePrivacySetting.Everyone == osv.presencePrivacy)
                return true;
            if (ePrivacySetting.FriendsOnly == osv.presencePrivacy && eFriendshipState.eFullFriendship == requestorToTarget)
                return true;

            return false;
        }

        #endregion

        #region Friendship Functionality

        public enum eFriendshipState
        {
            eNoFriendship = 0,
            eSentRequest,
            eReceivedRequest,
            eFullFriendship
        }

        public void LightWeightMakeFriends(PNUser a, PNUser b)
        {
            FriendsCommon.LightWeightMakeFriends(a.UserId, b.UserId, a.Name, b.Name);
        }

        public void LightWeightMakePendingFriends(PNUser a, PNUser b)
        {
            FriendsCommon.LightWeightFriendAdd(a.UserId, b.UserId, a.Name, b.Name);
        }

        public void MakeFriends(PNUser a, PNUser[] list)
        {
            foreach (PNUser b in list)
            {
                FriendsListUtil.MakeFriends(a.UserId, b.UserId, a.Name, b.Name);
            }
        }

        public void MakeFriends(PNUser a, PNUser[] list, bool wait)
        {
            MakeFriends(a, list);
            if (wait)
            {
                ro.Debug("Sleeping 5s for the friendships to form");
                Thread.Sleep(5000);
            }
        }

        public void MakeFriends(PNUser a, PNUser b)
        {
            MakeFriends(a, new PNUser[] { b });
        }

        public void MakeFriends(PNUser a, PNUser b, bool wait)
        {
            MakeFriends(a, b);
            if (wait)
            {
                ro.Debug("Sleeping 5s for the friendship to form");
                Thread.Sleep(5000);
            }
        }

        public void RemoveFriends(PNUser a, PNUser[] list)
        {
            foreach (PNUser b in list)
            {
                FriendsListUtil.Delete(a.UserId, b.UserId);
            }
        }

        public void RemoveFriends(PNUser a, PNUser[] list, bool wait)
        {
            RemoveFriends(a, list);
            if (wait)
            {
                ro.Debug("Sleeping 5s for the friendship to teardown");
                Thread.Sleep(5000);
            }
        }

        public void RejectRequest(PNUser a, PNUser b)
        {
            FriendsListUtil.Reject(a.UserId, b.UserId, false);
        }

        public void RejectRequest(PNUser a, PNUser b, bool wait)
        {
            RejectRequest(a, b);
            if (wait)
            {
                ro.Debug("Sleeping 10s for the rejection");
                Thread.Sleep(10000);
            }
        }

        public void AcceptRequest(PNUser a, PNUser b)
        {
            FriendsListUtil.Accept(a.UserId, b.UserId);
        }

        public void AcceptRequest(PNUser a, PNUser b, bool wait)
        {
            AcceptRequest(a, b);
            if (wait)
            {
                ro.Debug("Sleeping 5s for the friendship");
                Thread.Sleep(5000);
            }
        }

        public void MakePendingFriends(PNUser a, PNUser b)
        {
            FriendsListUtil.Add(a.UserId, b.UserId, a.Name, b.Name);
        }

        public void MakePendingFriends(PNUser a, PNUser b, bool wait)
        {
            MakePendingFriends(a, b);
            if (wait)
            {
                ro.Debug("Sleeping 5s for the friendship");
                Thread.Sleep(5000);
            }
        }

        public void MakeFriends(PNUser user, PNUser friend, eFriendshipState friendshipState, ref int friendsListVer)
        {
            if (user.UserId == friend.UserId)
                return;

            if (friendshipState == eFriendshipState.eSentRequest)
            {
                MakePendingFriends(user, friend);
                friendsListVer++;
            }
            else if (friendshipState == eFriendshipState.eReceivedRequest)
            {
                MakePendingFriends(friend, user);
                friendsListVer++;
            }
            else if (friendshipState == eFriendshipState.eFullFriendship)
            {
                MakeFriends(user, friend);
                friendsListVer += 2;
            }
        }

        public void MakeFriends(PNUser user, PNUser friend, eFriendshipState friendshipState)
        {
            int dummyFriendsListVer = 0;
            MakeFriends(user, friend, friendshipState, ref dummyFriendsListVer);
        }

        #region FriendGenerator Functionality

        public void GenerateFriendsWithPrivacy(ref OnlineStatusVariation[] osvs)
        {
            ro.Debug("Creating {0} Friends", osvs.Length);

            // Create some users to become the owner's friends
            PNUser[] friends = new PNUser[osvs.Length];
            friends = CreateXenonUsers((uint)friends.Length, false);

            int i = 0;
            foreach (OnlineStatusVariation osv in osvs)
            {
                osv.user = friends[i++];
                SetPresencePrivacy(osv.user, osv.presencePrivacy);
                if (osv.appearOffline)
                {
                    ro.Debug("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                    LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOffline);
                }
                else if (osv.isLoggedOn)
                {
                    ro.Debug("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                    LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOnline);
                }

                if (!osv.isLoggedOn)
                {
                    ro.Debug("Logoff user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                    LogoffUser(osv.user);
                }
            }
        }

        public void GenerateFriendsWithPrivacy(OnlineStatusVariation[] osvs, out PNUser user)
        {
            user = CreateXenonUser(false);
            PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
            user.Connect(xbox);
            Global.RO.Info("Created initial user {0} [{0:x}]", user.UserId);

            ro.Debug("Creating {0} Friends", osvs.Length);

            // Create some clean users to become the viewer's friends
            PNUser[] friends = new PNUser[osvs.Length];
            friends = CreateXenonUsers((uint)friends.Length, false);

            List<PNUser> pendingFriends = new List<PNUser>();
            List<PNUser> acceptedFriends = new List<PNUser>();

            for (int i = 0; i < osvs.Length; ++i)
            {
                osvs[i].user = friends[i];

                ro.Debug("Setting up user {0} [{0:x}]. Accepted: {1}, Privacy: {2}", osvs[i].user.UserId, osvs[i].isAccepted, osvs[i].presencePrivacy);

                if (osvs[i].isAccepted)
                    acceptedFriends.Add(friends[i]);
                else
                    pendingFriends.Add(friends[i]);
            }

            foreach (PNUser friend in pendingFriends)
            {
                MakePendingFriends(friend, user);
            }

            for (int i = 0; i < acceptedFriends.Count - 2; i++)
            {
                LightWeightMakeFriends(user, acceptedFriends[i]);
            }

            // Make a call to the heavyweight MakeFriends.  This updates the cache layer
            if (acceptedFriends.Count >= 2)
                MakeFriends(user, acceptedFriends[acceptedFriends.Count - 2]);
            if (acceptedFriends.Count >= 1)
                MakeFriends(user, acceptedFriends[acceptedFriends.Count - 1]);

            foreach (OnlineStatusVariation osv in osvs)
            {
                SetPresencePrivacy(osv.user, osv.presencePrivacy);
                ro.Debug("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                if (osv.appearOffline)
                {
                    LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOffline);
                }
                else
                {
                    LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOnline);
                }
            }
        }

        public void GenerateFriendsWithPrivacy(FriendsOfFriendsOnlineStatusVariation fof, out PNUser requestor, out PNUser owner, ref SocialQueryUser[] sqUsers, out int friendsListVer, ref OnlineStatusVariation[] reqOsvs, bool makeOsvs)
        {
            requestor = CreateXenonUser(false);
            owner = CreateXenonUser(false);
            PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
            PNXbox xbox2 = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
            owner.Connect(xbox);
            requestor.Connect(xbox2);
            Global.RO.Info("Created initial owner {0} [{0:x}]", owner.UserId);
            Global.RO.Info("Created initial requestor {0} [{0:x}]", requestor.UserId);
            PNUser[] friends = new PNUser[fof.osvs.Length];
            SocialQueryUser[] prelimSQList = new SocialQueryUser[fof.osvs.Length];
            OnlineStatusVariation[] prelimReqOsvs = new OnlineStatusVariation[fof.osvs.Length];

            if (makeOsvs)
            {
                // Create some clean users to become the viewer's friends
                ro.Debug("Creating {0} Friends", fof.osvs.Length);
                friends = CreateXenonUsers((uint)friends.Length, false);
            }

            List<PNUser> requestorPendingFriends = new List<PNUser>();
            List<PNUser> requestorAcceptedFriends = new List<PNUser>();
            List<PNUser> ownerPendingFriends = new List<PNUser>();
            List<PNUser> ownerAcceptedFriends = new List<PNUser>();

            int j = 0;
            for (int i = 0; i < fof.osvs.Length; ++i)
            {
                if (makeOsvs)
                {
                    fof.osvs[i].user = friends[i];
                }

                PNUser curTargetUser = fof.osvs[i].user;
                ro.Debug("Setting up user {0} [{0:x}]. Accepted: {1}, Privacy: {2}", curTargetUser.UserId, fof.osvs[i].isAccepted, fof.osvs[i].presencePrivacy);

                if (fof.osvs[i].isAccepted)
                {
                    ownerAcceptedFriends.Add(curTargetUser);

                    // Now we need to set up our ability to sort by FoF later
                    bool inParty = false;
                    bool flagOnline = fof.osvs[i].isLoggedOn && CanUserViewTargetsOnlineStatus(fof.requestorToTarget, fof.osvs[i]);
                    prelimSQList[j] = InitSocialQueryUser(curTargetUser, new SQUserFlag_UserState(flagOnline, inParty), new SQUserFlag_FriendStatus(eFriendshipState.eFullFriendship));
                    prelimReqOsvs[j] = new OnlineStatusVariation(fof.osvs[i]);
                    prelimReqOsvs[j].isAccepted = (fof.requestorToTarget == eFriendshipState.eFullFriendship) ? true : false;
                    j++;
                }
                else
                {
                    ownerPendingFriends.Add(curTargetUser);
                }

                if (fof.requestorToTarget == eFriendshipState.eFullFriendship)
                    requestorAcceptedFriends.Add(curTargetUser);
                else
                    requestorPendingFriends.Add(curTargetUser);
            }

            // Begin making friends for the owner and the requestor
            foreach (PNUser friend in ownerPendingFriends)
            {
                MakePendingFriends(friend, owner);
            }

            friendsListVer = ownerPendingFriends.Count + (ownerAcceptedFriends.Count * 2);
            sqUsers = new SocialQueryUser[ownerAcceptedFriends.Count];
            reqOsvs = new OnlineStatusVariation[ownerAcceptedFriends.Count];
            for (int i = 0; i < ownerAcceptedFriends.Count - 2; i++)
            {
                LightWeightMakeFriends(owner, ownerAcceptedFriends[i]);
                sqUsers[i] = InitSocialQueryUser(prelimSQList[i]);
                reqOsvs[i] = new OnlineStatusVariation(prelimReqOsvs[i]);
            }

            // Make a call to the heavyweight MakeFriends.  This updates the cache layer
            if (ownerAcceptedFriends.Count >= 2)
            {
                MakeFriends(owner, ownerAcceptedFriends[ownerAcceptedFriends.Count - 2]);
                sqUsers[ownerAcceptedFriends.Count - 2] = InitSocialQueryUser(prelimSQList[ownerAcceptedFriends.Count - 2]);
                reqOsvs[ownerAcceptedFriends.Count - 2] = new OnlineStatusVariation(prelimReqOsvs[ownerAcceptedFriends.Count - 2]);
            }
            if (ownerAcceptedFriends.Count >= 1)
            {
                MakeFriends(owner, ownerAcceptedFriends[ownerAcceptedFriends.Count - 1]);
                sqUsers[ownerAcceptedFriends.Count - 1] = InitSocialQueryUser(prelimSQList[ownerAcceptedFriends.Count - 1]);
                reqOsvs[ownerAcceptedFriends.Count - 1] = new OnlineStatusVariation(prelimReqOsvs[ownerAcceptedFriends.Count - 1]);
            }

            foreach (PNUser friend in requestorPendingFriends)
            {
                MakePendingFriends(friend, requestor);
            }

            for (int i = 0; i < requestorAcceptedFriends.Count - 2; i++)
            {
                LightWeightMakeFriends(requestor, requestorAcceptedFriends[i]);
            }

            // Make a call to the heavyweight MakeFriends.  This updates the cache layer
            if (requestorAcceptedFriends.Count >= 2)
                MakeFriends(requestor, requestorAcceptedFriends[requestorAcceptedFriends.Count - 2]);
            if (requestorAcceptedFriends.Count >= 1)
                MakeFriends(requestor, requestorAcceptedFriends[requestorAcceptedFriends.Count - 1]);


            // Set up behavior between the requestor and the owner
            // NOTE: this expects there to be no existing relationship between the two
            SetFriendsListPrivacy(owner, fof.ownerFriendsListPrivacy);
            LogoffUser(owner);
            LogonUser(owner, true);
            MakeFriends(requestor, owner, fof.requestorToOwner, ref friendsListVer);
            if (! CanUserViewTargetsFriendsList(fof.requestorToOwner, fof.ownerFriendsListPrivacy))
            {
                sqUsers = new SocialQueryUser[0];
                friendsListVer = 0;
            }

            if (makeOsvs)
            {
                foreach (OnlineStatusVariation osv in fof.osvs)
                {
                    SetPresencePrivacy(osv.user, osv.presencePrivacy);
                    if (osv.appearOffline)
                    {
                        ro.Debug("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                        LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOffline);
                    }
                    else if (osv.isLoggedOn)
                    {
                        ro.Debug("Logon user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                        LogonUser(osv.user, eUserAppearOnlineStatus.eAppearOnline);
                    }

                    if (!osv.isLoggedOn)
                    {
                        ro.Debug("Logoff user {0} [{0:x}]. Appear offline: {1}", osv.user.UserId, osv.appearOffline);
                        LogoffUser(osv.user);
                    }
                }
            }
        }

        public void GenerateFriendsWithPrivacy(FriendsOfFriendsOnlineStatusVariation fof, out PNUser requestor, out PNUser owner, ref SocialQueryUser[] sqUsers, out int friendsListVer)
        {
            OnlineStatusVariation[] dummy = new OnlineStatusVariation[0];
            GenerateFriendsWithPrivacy(fof, out requestor, out owner, ref sqUsers, out friendsListVer, ref dummy, true);
        }

        #endregion

        #endregion

        #region Logon/Logoff functions

        public void LogonUser(PNUser a, eUserAppearOnlineStatus aos, bool wait)
        {
            if (aos == eUserAppearOnlineStatus.eAppearOffline)
            {
                _fc.LogonUser(a, true);
            }
            else
            {

                _fc.LogonUser(a, false);
            }

            if (wait)
            {
                ro.Debug("Sleeping 3s for the logon");
                Thread.Sleep(3000);
            }
        }

        public void LogonUser(PNUser a, eUserAppearOnlineStatus aos)
        {
            LogonUser(a, aos, false);
        }

        public void LogonUser(PNUser a, bool wait)
        {
            LogonUser(a, eUserAppearOnlineStatus.eAppearOnline, wait);
        }

        public void LogonUser(PNUser a)
        {
            LogonUser(a, eUserAppearOnlineStatus.eAppearOnline, false);
        }

        public void LogoffUser(PNUser a)
        {
            _fc.LogoffUser(a);
        }

        public void LogoffUser(PNUser a, bool wait)
        {
            LogoffUser(a);
            if (wait)
            {
                ro.Debug("Sleeping 3s for the logoff");
                Thread.Sleep(3000);
            }
        }

        #endregion

        #region SocialQueryUser Functionality

        struct XuidGamertag
        {
            public ulong Xuid;
            public string Gamertag;
        }

        public class SQUserFlag_UserState
        {
            public uint us_flag;

            public SQUserFlag_UserState()
            {
                us_flag = 0;
            }

            public SQUserFlag_UserState(bool online, bool inParty)
            {
                us_flag = 0;
                if (online)
                {
                    us_flag = SocialQueryDefs.SQ_FLAG_ONLINE;
                }

                // really, if the user isn't online, this should always
                // be false, but we're not going to enforce that here
                if (inParty)
                {
                    us_flag |= SocialQueryDefs.SQ_FLAG_PARTY_PLAYING;
                }
            }
        }

        public class SQUserFlag_FriendStatus
        {
            public uint fs_flag;

            public SQUserFlag_FriendStatus()
            {
                fs_flag = SocialQueryDefs.SQ_FLAG_FRIEND_REQUEST_ACCEPTED;
            }

            public SQUserFlag_FriendStatus(eFriendshipState eFriendship)
            {
                if (eFriendshipState.eFullFriendship == eFriendship)
                {
                    // NOTE: this has a value of 0   :(
                    // There isn't a way of saying there is no relationship
                    fs_flag = SocialQueryDefs.SQ_FLAG_FRIEND_REQUEST_ACCEPTED;
                }
                else if (eFriendshipState.eSentRequest == eFriendship)
                {
                    fs_flag = SocialQueryDefs.SQ_FLAG_SENTREQUEST;
                }
                else if (eFriendshipState.eReceivedRequest == eFriendship)
                {
                    fs_flag = SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST;
                }
            }
        }

        private int CompareGamertagToString(string Gamertag, string s)
        {
            if (Gamertag.Length <= s.Length)
            {
                return Gamertag.CompareTo(s);
            }

            for (int i = 0; i < s.Length; i++)
            {
                if (Gamertag[i] > s[i])
                {
                    return 1;
                }
                else if (Gamertag[i] < s[i])
                {
                    return -1;
                }
            }

            return 0;
        }

        protected SocialQueryUser[] SortByGamertag(PNUser[] users)
        {
            if (users == null) return null;
            XuidGamertag[] list = new XuidGamertag[users.Length];
            for (int i = 0; i < list.Length; i++)
            {
                list[i] = new XuidGamertag();
                list[i].Xuid = users[i].UserId; //make a deep copy because i hate C#
                list[i].Gamertag = users[i].Name;
            }

            //ascending
            int compareVal = 1;

            for (int i = list.Length - 1; i > 0; i--)
            {
                for (int j = 0; j < i; j++)
                {
                    if (list[j].Gamertag.CompareTo(list[j + 1].Gamertag) == compareVal)
                    {
                        //switch
                        XuidGamertag temp = new XuidGamertag();
                        temp.Gamertag = list[j].Gamertag;
                        temp.Xuid = list[j].Xuid;
                        list[j].Gamertag = list[j + 1].Gamertag;
                        list[j].Xuid = list[j + 1].Xuid;
                        list[j + 1].Gamertag = temp.Gamertag;
                        list[j + 1].Xuid = temp.Xuid;
                    }
                }
            }

            //now that it's sorted, convert into social query friends
            SocialQueryUser[] ret = new SocialQueryUser[list.Length];
            for (int i = 0; i < list.Length; i++)
            {
                foreach (PNUser p in users)
                {
                    if (p.UserId == list[i].Xuid)
                    {
                        ret[i] = InitSocialQueryUser(p);
                    }
                }
            }

            return ret;
        }

        protected SocialQueryUser[] SortByGamertag(SocialQueryUser[] users)
        {
            if (users == null) return null;
            XuidGamertag[] list = new XuidGamertag[users.Length];
            for (int i = 0; i < list.Length; i++)
            {
                list[i] = new XuidGamertag();
                list[i].Xuid = users[i].Xuid; //make a deep copy because i hate C#
                list[i].Gamertag = users[i].Gamertag;
            }

            //ascending
            int compareVal = 1;

            for (int i = list.Length - 1; i > 0; i--)
            {
                for (int j = 0; j < i; j++)
                {
                    if (list[j].Gamertag.CompareTo(list[j + 1].Gamertag) == compareVal)
                    {
                        //switch
                        XuidGamertag temp = new XuidGamertag();
                        temp.Gamertag = list[j].Gamertag;
                        temp.Xuid = list[j].Xuid;
                        list[j].Gamertag = list[j + 1].Gamertag;
                        list[j].Xuid = list[j + 1].Xuid;
                        list[j + 1].Gamertag = temp.Gamertag;
                        list[j + 1].Xuid = temp.Xuid;
                    }
                }
            }

            //now that it's sorted, convert into social query friends
            SocialQueryUser[] ret = new SocialQueryUser[list.Length];
            for (int i = 0; i < list.Length; i++)
            {
                foreach (SocialQueryUser u in users)
                {
                    if (u.Xuid == list[i].Xuid)
                    {
                        ret[i] = u;
                    }
                }
            }

            return ret;
        }

        protected SocialQueryUser[] SortByOnlineStatus(SocialQueryUser[] users)
        {
            if (users == null) return null;

            int partialFriendTotal = 0;
            int onlineTotal = 0;
            int offlineTotal = 0;
            foreach (SocialQueryUser user in users)
            {
                if (0 != (user.Flags & (SocialQueryDefs.SQ_FLAG_SENTREQUEST | SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST)))
                {
                    partialFriendTotal++;
                }
                else if (0 != (user.Flags & SocialQueryDefs.SQ_FLAG_ONLINE))
                {
                    onlineTotal++;
                }
                else
                {
                    offlineTotal++;
                }
            }

            int partialIdx = 0;
            int onlineIdx = 0;
            int offlineIdx = 0;
            SocialQueryUser[] partialFriendList = new SocialQueryUser[partialFriendTotal];
            SocialQueryUser[] onlineList = new SocialQueryUser[onlineTotal];
            SocialQueryUser[] offlineList = new SocialQueryUser[offlineTotal];

            foreach (SocialQueryUser user in users)
            {
                if (0 != (user.Flags & (SocialQueryDefs.SQ_FLAG_SENTREQUEST | SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST)))
                {
                    partialFriendList[partialIdx++] = user;
                }
                else if (0 != (user.Flags & SocialQueryDefs.SQ_FLAG_ONLINE))
                {
                    onlineList[onlineIdx++] = user;
                }
                else
                {
                    offlineList[offlineIdx++] = user;
                }
            }

            // secondarily sort on gamertag
            partialFriendList = SortByGamertag(partialFriendList);
            onlineList = SortByGamertag(onlineList);
            offlineList = SortByGamertag(offlineList);

            // now that it's sorted, combine the lists back into one
            SocialQueryUser[] ret = new SocialQueryUser[users.Length];
            int retIdx = 0;
            for (partialIdx = 0; partialIdx < partialFriendTotal; partialIdx++)
            {
                ret[retIdx++] = partialFriendList[partialIdx];
            }
            for (onlineIdx = 0; onlineIdx < onlineTotal; onlineIdx++)
            {
                ret[retIdx++] = onlineList[onlineIdx];
            }
            for (offlineIdx = 0; offlineIdx < offlineTotal; offlineIdx++)
            {
                ret[retIdx++] = offlineList[offlineIdx];
            }

            return ret;
        }

        protected SocialQueryUser[] SortByFriendsOfFriends(SocialQueryUser[] users, SocialQueryUser requestor, OnlineStatusVariation[] reqOsvs)
        {
            if (users == null) return null;

            int onlineTotal = 0;
            int offlineTotal = 0;
            foreach (SocialQueryUser user in users)
            {
                if (user.Xuid == requestor.Xuid)
                {
                    continue;
                }
                if (0 != (user.Flags & (SocialQueryDefs.SQ_FLAG_SENTREQUEST | SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST)))
                {
                    continue;
                }
                else if (0 != (user.Flags & SocialQueryDefs.SQ_FLAG_ONLINE))
                {
                    onlineTotal++;
                }
                else
                {
                    offlineTotal++;
                }
            }

            int onlineIdx = 0;
            int offlineIdx = 0;
            int reqOsvsIdx = 0;
            SocialQueryUser[] onlineList = new SocialQueryUser[onlineTotal];
            SocialQueryUser[] offlineList = new SocialQueryUser[offlineTotal];
            foreach (SocialQueryUser user in users)
            {
                if (user.Xuid == requestor.Xuid)
                {
                    continue;
                }

                if (0 != (user.Flags & (SocialQueryDefs.SQ_FLAG_SENTREQUEST | SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST)))
                {
                    continue;
                }
                    //        public bool CanUserViewTargetsFriendsList(eFriendshipState requestorToTarget, ePrivacySetting priv)

                else if (0 != (user.Flags & SocialQueryDefs.SQ_FLAG_ONLINE))
                {
                    // TODO: not true that it's no friendship!
                    eFriendshipState reqToTarget = (reqOsvs[reqOsvsIdx].isAccepted) ? eFriendshipState.eFullFriendship : eFriendshipState.eNoFriendship;
                    if (CanUserViewTargetsOnlineStatus(reqToTarget, reqOsvs[reqOsvsIdx]))
                        onlineList[onlineIdx++] = user;
                    else
                        offlineList[offlineIdx++] = user;
                }
                else
                {
                    offlineList[offlineIdx++] = user;
                }

                reqOsvsIdx++;
            }

            // secondarily sort on gamertag
            onlineList = SortByGamertag(onlineList);
            offlineList = SortByGamertag(offlineList);

            // now that it's sorted, combine the lists back into one
            SocialQueryUser[] ret = new SocialQueryUser[onlineList.Length + offlineList.Length];
            int retIdx = 0;
            for (onlineIdx = 0; onlineIdx < onlineTotal; onlineIdx++)
            {
                ret[retIdx++] = onlineList[onlineIdx];
            }
            for (offlineIdx = 0; offlineIdx < offlineTotal; offlineIdx++)
            {
                ret[retIdx++] = offlineList[offlineIdx];
            }

            return ret;
        }

        protected SocialQueryUser[] SortByFriendsOfFriends(SocialQueryUser[] users, SocialQueryUser requestor)
        {
            OnlineStatusVariation[] dummy = new OnlineStatusVariation[0];
            return SortByFriendsOfFriends(users, requestor, dummy);
        }

        public SocialQueryUser InitSocialQueryUser(PNUser u, uint userState, uint friendStatus)
        {
            ASCIIEncoding enc = new ASCIIEncoding();

            SocialQueryUser ret = new SocialQueryUser();
            ret.Xuid = (ulong)u.UserId;
            ret.Gamertag = u.Name;
            ret.Flags = userState | friendStatus;
            //ro.Debug("InitUser: " + ret.Flags + " ( " + userState + " | " + friendStatus + " )");
            ret.TitleId = 0;

            return ret;
        }

        public SocialQueryUser InitSocialQueryUser(SocialQueryUser u)
        {
            ASCIIEncoding enc = new ASCIIEncoding();

            SocialQueryUser ret = new SocialQueryUser();
            ret.Xuid = u.Xuid;
            ret.Gamertag = u.Gamertag;
            ret.Flags = u.Flags;
            //ro.Debug("InitUser: " + ret.Flags + " ( " + userState + " | " + friendStatus + " )");
            ret.TitleId = 0;

            return ret;
        }

        public SocialQueryUser InitSocialQueryUser(PNUser u)
        {
            return InitSocialQueryUser(u, new SQUserFlag_UserState().us_flag, new SQUserFlag_FriendStatus().fs_flag);
        }

        public SocialQueryUser InitSocialQueryUser(PNUser u, SQUserFlag_UserState userStatus)
        {
            return InitSocialQueryUser(u, userStatus.us_flag, new SQUserFlag_FriendStatus().fs_flag);
        }

        public SocialQueryUser InitSocialQueryUser(PNUser u, SQUserFlag_FriendStatus friendStatus)
        {
            return InitSocialQueryUser(u, new SQUserFlag_UserState().us_flag, friendStatus.fs_flag);
        }

        public SocialQueryUser InitSocialQueryUser(PNUser u, SQUserFlag_UserState userStatus, SQUserFlag_FriendStatus friendStatus)
        {
            return InitSocialQueryUser(u, userStatus.us_flag, friendStatus.fs_flag);
        }

        #endregion

        #region SocialQueryXRL Functionality

        public GetFriendsXrlResponse InitExpectedGetFriendsResponse(PNUser sender, int expectedFriendsListVersion, int totalNumUsers, int pageStart, SocialQueryUser[] expectedUsers)
        {
            if (expectedUsers == null)
            {
                expectedUsers = new SocialQueryUser[0];
            }
            GetFriendsXrlResponse retVal = new GetFriendsXrlResponse();

            retVal.hr = xonline.common.service.HResult.S_OK;
            retVal.RequestorXuid = (ulong)sender.UserId;
            retVal.FriendListVersion = (uint)expectedFriendsListVersion;
            retVal.TotalNumUsers = (uint)totalNumUsers;
            retVal.PageStartIndex = (uint)pageStart;
            retVal.NumFriends = (uint)expectedUsers.Length;
            retVal.Friends = expectedUsers;

            return retVal;
        }

        public void ValidateGetFriendsXrlResponse(GetFriendsXrlResponse response, GetFriendsXrlResponse expectedResponse)
        {
            ValueCheck.Test("Response hresult", expectedResponse.hr, response.hr);
            ValueCheck.Test("Number of returned users array count", expectedResponse.Friends.Length, (response.Friends == null ? 0 : response.Friends.Length));
            ValueCheck.Test("Requestor Xuid", expectedResponse.RequestorXuid, response.RequestorXuid);
            ValueCheck.Test("Total Friend count", expectedResponse.TotalNumUsers, response.TotalNumUsers);
            ValueCheck.Test("Friend List Version", expectedResponse.FriendListVersion, response.FriendListVersion);
            ValueCheck.Test("Page Start Index", expectedResponse.PageStartIndex, response.PageStartIndex);
            ValueCheck.Test("Returned user count", expectedResponse.NumFriends, response.NumFriends);

            for (int i = 0; i < expectedResponse.Friends.Length; i++)
            {
                // Putting gamertag verification first as it is frequently more useful
                ValueCheck.Test("Returned User[" + i + "] Gamertag ", expectedResponse.Friends[i].Gamertag, response.Friends[i].Gamertag);
                ValueCheck.Test("Returned User[" + i + "] Xuid " + i, expectedResponse.Friends[i].Xuid, response.Friends[i].Xuid);
                //ro.Debug("Flags: " + expectedResponse.Friends[i].Flags + " | " + response.Friends[i].Flags);
                ValueCheck.Test("Returned User[" + i + "] Flags ", expectedResponse.Friends[i].Flags, response.Friends[i].Flags);
            }
        }

        #endregion

        #region User Creation Functionality

        public PNUser[] CreateXenonUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreateXenonUser(alive);
            }
            return users;
        }

        public PNUser CreateXenonUser(bool alive)
        {
            PNUser user = _fc.CreateXenonUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateXenonUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreateXenonUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser[] CreatePanoramaUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreatePanoramaUser(alive);
            }
            return users;
        }

        public PNUser CreatePanoramaUser(bool alive)
        {
            PNUser user = _fc.CreatePanoramaUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreatePanoramaUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreatePanoramaUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateLinkedUser(bool alive)
        {
            PNUser user = _fc.CreateLinkedUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser GetUser(string gamertag)
        {
            ulong xuid = 0;
            bool needToClean = false;
            //magic!
            //check to see if he exists.
            xuid = XCache.LookupPUID(gamertag);
            //if not, create him!
            if (xuid == 0)
            {
                UacsCommon2 uc = new UacsCommon2();
                XblUserSettings settings = new XblUserSettings(UserType.Gold);
                settings.GamerTag = gamertag;

                XblUser u = uc.CreateUser(settings);
                xuid = u.Puid;
                Thread.Sleep(25000);

                needToWaitForXCache = true;
            }
            else
            {
                //we have to make sure this user is in an expected state
                needToClean = true;
            }

            PNUser user = new PNUser(gamertag, xuid);
            if (needToClean)
            {
                //CleanUser(user);
            }

            return user;
        }

        public void WaitForXCache()
        {
            if (needToWaitForXCache)
            {
                Thread.Sleep(30000);
            }
            needToWaitForXCache = false;
            
        }

        public void WaitForCacheToUpdate()
        {
            ro.Debug("Sleeping 5s for cache to update");
            Thread.Sleep(5000);
        }

        public void CleanUser(PNUser user)
        {
            //go through each friend and remove him
            user.DeleteAllBuddies();
        }

        public uint ChangeGamertag(PNUser user, string gamertag)
        {
            XRLObject2 xrlo = null;
            //get and send in the SG slot
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = user.UserId;

            //set a FNC so we don't have to deal with billing
            SetUserAccountStatusRequest suasReq = new SetUserAccountStatusRequest();
            suasReq.puid = user.UserId;
            suasReq.forceNameChangeRequired = 1;
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.User_Account, suasReq.Xrl, suasReq);
            //Assert.IsTrue(HResult.Succeeded(hr), "0x" + hr.ToString("x8"));
            ro.Debug("FNC HR = " + hr);
            //change the gamertag
            ChangeGamertagRequest cgReq = new ChangeGamertagRequest();
            cgReq.userPuid = user.UserId;
            cgReq.machinePuid = 0x9FFFFFFFFFFFF;
            cgReq.gamertag = gamertag;

            ChangeGamertagResponse cgResp = new ChangeGamertagResponse();
            xrlo = cgResp;

            hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.User_Account, cgReq.Xrl, cgReq, ref xrlo);
            ro.Debug("change gamertag HR = " + hr);
            return hr;

        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_statsadmin1_none_12.4.56.0_none_b462fb2a1121a9bd
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statsadmin1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.manifest
XP_MANIFEST_PATH=manifests\x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.cat
XP_CATALOG_PATH=manifests\x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.cat
XP_PAYLOAD_PATH=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statsadmin1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_statsadmin1_none_12.4.56.0_none_b462fb2a1121a9bd
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statsadmin1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.manifest
XP_MANIFEST_PATH=manifests\x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.cat
XP_CATALOG_PATH=manifests\x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157.cat
XP_PAYLOAD_PATH=x86_statsadmin1_no-public-key_12.4.56.0_x-ww_c9fca157
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statsadmin1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\adminstatsdll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\xrl.cs ===
/*
 * StatsUnitest
 * xrl.cs
 * xrl request
*/

using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using xonline.common.service;

namespace xonline.server.stats.test.dvt 
{
    class XRLBundledAuth
    {
        public XRLBundledAuth(uint uiTitleId, ulong[] puids)
        {
            _uiTitleId  = uiTitleId;
            _puids      = puids;
        }
        
        public uint     _uiTitleId;
        public ulong[]  _puids;
    }
    
    // XRL
    // Handles XRL requests 
    class XRL
    {
        // SetSGSession
        // Sets the SGSession context object to be used on all AddSession requests originating from the same thread.
        static public void SetSGSession(SGSession session)
        {
            Thread.SetData(_currentSessionSlot, session);
        }
        
        static public void SetBundledAuth(XRLBundledAuth bundledAuth)
        {
            Thread.SetData(_bundledAuthSlot, bundledAuth);
        }
        
        static public void SetPort(int iPort)
        {
            Thread.SetData(_portSlot, (object)(ushort)iPort);
        }
        
        // Post
        // XRL post.
        public static uint Post(
            int serviceId, 
            string URL, 
            byte[] request, 
            out byte[] response)
        {
            Socket xrlSocket = null;
            response = null;
            uint hr = 0;
            IPEndPoint localEndPoint = null;

            // Parse URL
            string destHost;
            string destPort;
            string destPath;
            
            Match match = _urlParser.Match(URL);

            if(match.Groups.Count == 0)
            {
                throw new Exception("URL " + URL + " is invalid.");
            }

            destHost = match.Groups["host"].Value;
            destPort = match.Groups["port"].Value;
            destPath = match.Groups["path"].Value;            

            // Dest port
            ushort usPort;
            
            if(destPort.Length > 0)
            {
                usPort = Convert.ToUInt16(destPort, 10);
            }
            else
            {
                object port = Thread.GetData(_portSlot);
                
                if(port != null)
                {
                    usPort = (ushort) port;
                }
                else
                {
                    usPort = (ushort) xonline.stats.admin.Config._iInternetPort;
                }
            }
            
            // Resolve host name
            IPHostEntry hostEntry = Dns.GetHostEntry(destHost);
            IPEndPoint destEndPoint = new IPEndPoint(hostEntry.AddressList[0], usPort);
            
            try
            {
                // Create the xrlSocket and bind it to one of the available dynamic ports
                localEndPoint = new IPEndPoint(0, 0);
                xrlSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                xrlSocket.Bind(localEndPoint);

#if false // not working
                // Don't linger
                LingerOption lingerOption = new LingerOption(true, 10);
                xrlSocket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.Linger, lingerOption);
#endif

                // Build bundled auth header
                string bundledAuthHeader;
                XRLBundledAuth bundledAuth = (XRLBundledAuth) Thread.GetData(_bundledAuthSlot);
                
                if(bundledAuth != null)
                {   
                    XUIDAndTrust[] xuidAndTrust = new XUIDAndTrust[bundledAuth._puids.Length];
                    
                    for(int i=0; i < xuidAndTrust.Length && i < bundledAuth._puids.Length; i++)
                    {
                        xuidAndTrust[i] = new XUIDAndTrust(bundledAuth._puids[i], 0, 0.0f);
                    }
                    
                    BundledAuthData bundledAuthData = new BundledAuthData(bundledAuth._uiTitleId, xuidAndTrust);
                    bundledAuthHeader = XHttpHdr.BUNDLEDAUTHDATA + ":" + 
                        bundledAuthData.GetBase64EncodedString() + "\r\n";
                }
                else
                {
                    bundledAuthHeader = String.Empty;
                }
                
                // build request header
                string serviceHeader = 
                    "POST "+destPath+" HTTP/1.0\r\n" + 
                    "User-Agent: "+serviceId+"/1.0.0\r\n" +
                    "Content-Type: xon/"+serviceId+"\r\n" +
                    bundledAuthHeader +
                    "Content-Length: "+request.Length+"\r\n" +
                    "\r\n";

                // Connect 
                xrlSocket.Connect(destEndPoint);

                // Prepare auth
                SGSession session = (SGSession) Thread.GetData(_currentSessionSlot);
                
                if(session != null)
                {
                    localEndPoint = (IPEndPoint) xrlSocket.LocalEndPoint;
                    SGAuth.AddSession(localEndPoint, session);
                }
                else
                {
                    localEndPoint = null;
                }
                
                // Send request                
                xrlSocket.Send(Encoding.ASCII.GetBytes(serviceHeader));
                xrlSocket.Send(request);

                // Read the response
                int iWrittenResponse = 0;
                int iContentLength = 0;
                string responseHeader = String.Empty;
                byte[] responseBuffer = new Byte[2048];
                
                while(response == null || iWrittenResponse < iContentLength)
                {
                    // Any data available?
                    if(xrlSocket.Poll(100000, SelectMode.SelectRead))
                    {
                        int iReceived = xrlSocket.Receive(responseBuffer);
                        
                        // If response is null, then we're still parsing the http header
                        if(response == null)
                        {
                            // Add recently written buffer to header
                            responseHeader += Encoding.ASCII.GetString(responseBuffer, 0, iReceived);
                            
                            // Did we read the entire header?
                            int endOfHeader = responseHeader.IndexOf("\r\n\r\n");

                            if(endOfHeader == -1)
                                throw new Exception(
                                    "Failed to parse http response header. Can't find CRLF last pairs.");

                            endOfHeader += 4;
                            
                            // Parse the header. First the status.
                            match = _regexHTTPStatus.Match(responseHeader);
                            
                            if(! match.Success)
                                throw new Exception("Failed to parse http response header. "+
                                    "Failed part: status. Http header:\n"+responseHeader);

                            int status = Convert.ToInt32((string)match.Groups["status"].Value, 10);
                            
                            // X-Err
                            match = _regexXErr.Match(responseHeader);

                            if(match.Success)
                                hr = HResult.Parse((string)match.Groups["xerr"].Value);

                            if(status != 200 && HResult.Succeeded(hr))
                                hr = HResult.E_FAIL;

                            // Content-lenth
                            match = _regexContentLength.Match(responseHeader);
                            
                            if(match.Success)
                                iContentLength = Convert.ToInt32(match.Groups["len"].Value);
                            else
                                iContentLength = 0;

                            // Allocate response 
                            response = new byte[iContentLength];
                            Array.Copy(responseBuffer, endOfHeader, response, 0, iReceived - endOfHeader);
                            iWrittenResponse = iReceived - endOfHeader;
                        }
                        else
                        {
                            // Copy more of the response
                            Array.Copy(responseBuffer, 0, response, iWrittenResponse, iReceived);
                            iWrittenResponse += iReceived;
                        }
                    }
                }

                xrlSocket.Shutdown(SocketShutdown.Both);
            }
            finally
            {
                if(xrlSocket != null)
                {
                    xrlSocket.Close();
                    xrlSocket = null;
                }

                if(localEndPoint != null)
                {
                    SGAuth.DropSession(localEndPoint);
                }
            }

            return hr;
        }

        private static LocalDataStoreSlot   _currentSessionSlot = Thread.AllocateDataSlot();
        private static LocalDataStoreSlot   _portSlot           = Thread.AllocateDataSlot();
        private static LocalDataStoreSlot   _bundledAuthSlot    = Thread.AllocateDataSlot();
        private static Regex                _urlParser          = new Regex(@"http:\/\/(?<host>[\w-\.]+)(:(?<port>\d+))?(?<path>\/.*)?", RegexOptions.Compiled);
        private static Regex                _regexHTTPStatus    = new Regex(@"HTTP\/(?<httpver>\d+.\d+)\s(?<status>\d+)\s\w+.*", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexXErr          = new Regex(@"^X-Err: (?<xerr>[A-Za-z0-9]+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexContentLength = new Regex(@"^Content-Length: (?<len>\d+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\statsxscutil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.leaderboard;
using xonline.common.livetitleconfig;



namespace xonline.stats.admin
{

    class StatsXscUtil
    {
        
        /// <summary>
        /// Takes an XSC File and extracts the LeaderboardSettings information and returns LeaderboardSettings objects in an arraylist.
        /// </summary>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXLASTLeaderboardConfiguration( uint titleID )
        {
            
//            if ( ! xsc file exists for title in title vault )
//            {
                  return new ArrayList();
//            }
//            else
//            {
//                GetXscTextFromFile( xscPath );
//                return ExtractLeaderboards( xscText );
//            }
        }


        //NOTE: you'll need to add code to retrieve leaderboards from the XSC file
        //you can look at \common\config\titleconfig.cs for some helpful examples of using XPATH queries for this

        //keeping this separate makes it easier to test...
        //this function retrieves the information from the XSC file and matches it up with the 
        // leaderboard assignment information from the LTC file.
        public static ArrayList ExtractLeaderboards(  )
        {

            ArrayList leaderboardList = new ArrayList( );

            //NOTE: order of evaluation is important here
            //must have ltc.leaderboardconfigs
            //must have XSC stats view element

            
//            if ( 
//                ( null != ltc.LeaderboardConfigs ) ||
//                ( 0 != ltc.LeaderboardConfigs.Length ) 
//                )
//            {
//
//                //a hashtable makes it easier to retrieve the LC for a LeaderboardSettings, since ID's are not always sequential...
//                Hashtable lcHash = new Hashtable( ltc.LeaderboardConfigs.Length );
//                foreach( LeaderboardConfig lc in ltc.LeaderboardConfigs )
//                {
//                    lcHash.Add( lc.LeaderboardID, lc.HostingLbs );
//                }
//
//                LeaderboardSettings lb;
//
//                if ( //do we have stats views?
//                    ( null != xlsp.GameConfigProject.StatsViews ) &&
//                    ( null != xlsp.GameConfigProject.StatsViews.StatsView ) &&
//                    ( 0 != xlsp.GameConfigProject.StatsViews.StatsView.Length )
//                    )
//                {
//                    //extracts statsview leaderboards
//                    //loop through statsviews, creating leaderboards adding them
//                    foreach( StatsView sv in xlsp.GameConfigProject.StatsViews.StatsView )
//                    {
//                        //if you save it with an int, you cannot retrieve it with a UInt64
//                        //EVEN IF IT'S THE SAME VALUE!!!!
//                        lb = new LeaderboardSettings(
//                            lcHash[ (int) sv.id ].ToString(),
//                            ltc.TitleID,
//                            (int)  sv.id,
//                            (byte) sv.resetType,
//                            0, //       sv.maxAttachments, removed per bug 24991
//                            0, //(int)  sv.maxAttachmentSize,  -- removed in April XDK, but still in npdb schema
//                            sv.entryExpiration,
//                            (int)  sv.topEntries,
            			     // removed in June XDK, but it will be back... 

                             //Katia: you WILL have team leaderboards in XBOX
//			                 //sv.teamView,
//                            false, 
//                            sv.arbitrated,
//                            System.DateTime.UtcNow
                              //katia: You'll need to add population of ELO Settings
//                            );
//                        leaderboardList.Add( lb );
//                    }
//                }
//
//            }
             
            return leaderboardList;

        } // get xlast leaderboards

    } // class StatsXlastUtil

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\adminstatsdll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\adminstatsdll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\base\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\adminstatsdll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_adminstats_none_12.4.56.0_none_5240f869d8e05439
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=adminstats
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.manifest
XP_MANIFEST_PATH=manifests\msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.cat
XP_CATALOG_PATH=manifests\msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.cat
XP_PAYLOAD_PATH=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=adminstats,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\adminstatsdll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_adminstats_none_12.4.56.0_none_5240f869d8e05439
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=adminstats
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.manifest
XP_MANIFEST_PATH=manifests\msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.cat
XP_CATALOG_PATH=manifests\msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3.cat
XP_PAYLOAD_PATH=msil_adminstats_no-public-key_12.4.56.0_x-ww_a24933b3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=adminstats,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\admin\statsxlastutil.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.leaderboard;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using xonline.common.service;
using xonline.common.protocol;
using xonline.tools.framework;
using xonline.server.stats.common;

namespace xonline.stats.admin
{

    public class StatsXlastUtil
    {


        /*
            Byte    Server thinks       Tools think

            0       Never               Weekly
            1       Weekly              Biweekly
            2       Monthly             Monthly
            3       BiMonthly           BiMonthly
            4       Quarterly           Annually
            5       SemiAnnually        Never
            6       Annually            NA
        */

        private static byte [] m_arrMapping = new byte []{  1, 
                                                           4, //biweekly is map to quarterly temporarily but we will throw an error
                                                           2,
                                                           3,
                                                           6,
                                                           0,
                                                           };

        private static Dictionary<string, uint> PlatformVisibleFlags = new Dictionary<string,uint>
        {
            {"enabled", 0},
            {"primary", 1}
        };

        private static bool IsPlatformVisibleSpecified(string platformVisible)
        {
            if (!string.IsNullOrEmpty(platformVisible))
            {
                foreach (KeyValuePair<string, uint> kvp in PlatformVisibleFlags)
                {
                    if (kvp.Key == platformVisible.ToLower())
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public const int GAME_TYPE_CONTEXT_RANKED   = 0;
        public const int GAME_TYPE_CONTEXT_STANDARD = 1;

        public static byte MapResetTypeToServerResetType(ResetType rtToolResetType)
        {
             if (rtToolResetType == ResetType.Biweekly)
                throw new Exception("Biweekly is not supported by the server yet");

             if ((int)rtToolResetType >=  m_arrMapping.Length)
                throw new Exception("Unknown Reset Type");

             return  m_arrMapping[(int)rtToolResetType];
        }



        /// <summary>
        /// Takes an XLAST File and extracts the LeaderboardSettings information and returns LeaderboardSettings objects in an arraylist.
        /// Does not return skill leaderboards.
        /// </summary>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXLASTLeaderboardConfiguration( uint titleID )
        {
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlast( titleID );
            LiveTitleConfig ltc = LiveTitleConfig.Get( titleID );

            //essentially there needs to be:
            //xlsp & xlsp.GameConfigProject
            //ltc & ltc.LeaderboardConfigs
            //and...
            //at least one of: statsview or gamemodes
            //short-circuit execution is important here...
            if (
                ( null == xlsp ) ||
                ( null == xlsp.GameConfigProject ) ||
                ( null == ltc ) ||
                ( null == ltc.LeaderboardConfigs ) ||
                (
                  (
                    ( null == xlsp.GameConfigProject.StatsViews ) ||
                    ( null == xlsp.GameConfigProject.StatsViews.StatsView )
                   ) &&
                   (
                    ( null == xlsp.GameConfigProject.GameModes ) ||
                    ( null == xlsp.GameConfigProject.GameModes.GameMode )
                   )
                 )
               )
            {
                return new ArrayList();
            }
            else
            {
                return ExtractLeaderboards( xlsp, ltc );
            }
        }

        //Frankly, it would have been better to have changed the XLAST doc to reflect these leaderboards
        //at the time the XLAST gets deployed to the service, but we really don't want title devs
        //to know how we're managing skill leaderboards, and it's too late to add auto-creation functionality
        //to the LeaderboardSettings server... so knowledge about leaderboards is in lots of places... :-(

        //keeping this separate makes it easier to test...
        public static ArrayList ExtractLeaderboards( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc )
        {

            ArrayList leaderboardList = new ArrayList( );

            //NOTE: order of evaluation is important here
            //must have ltc.leaderboardconfigs
            //must have at least one of:
            //  - statsviews
            //  - gamemodes
            if (
                ( null != ltc.LeaderboardConfigs ) ||
                ( 0 != ltc.LeaderboardConfigs.Length )
                )
            {
                //a hashtable makes it easier to retrieve the LC for a LeaderboardSettings, since ID's are not always sequential...
                Hashtable lcHash = new Hashtable( ltc.LeaderboardConfigs.Length );
                foreach( LeaderboardConfig lc in ltc.LeaderboardConfigs )
                {
                    lcHash.Add( lc.LeaderboardID, lc.HostingLbs );
                }

                LeaderboardSettings lb;

                if ( //do we have stats views?
                    ( null != xlsp.GameConfigProject.StatsViews ) &&
                    ( null != xlsp.GameConfigProject.StatsViews.StatsView ) &&
                    ( 0 != xlsp.GameConfigProject.StatsViews.StatsView.Length )
                    )
                {
                    //extracts statsview leaderboards
                    //loop through statsviews, creating leaderboards adding them
                    foreach( StatsView sv in xlsp.GameConfigProject.StatsViews.StatsView )
                    {
                        if (lcHash[ (int) sv.id ] == null)
                            throw new ApplicationException("XLAST/LTC configuration mismatch: Cannot find leaderboard with ID = " + sv.id);

                        byte byResetTypeByServer = MapResetTypeToServerResetType(sv.resetType);

                        //if you save it with an int, you cannot retrieve it with a UInt64
                        //EVEN IF IT'S THE SAME VALUE!!!!
                        lb = new LeaderboardSettings(
                            lcHash[ (int) sv.id ].ToString(),
                            ltc.TitleID,
                            (int)  sv.id,
                            byResetTypeByServer,
                            sv.maxAttachments, 
                            0, //(int)  sv.maxAttachmentSize,  -- removed in April XDK, but still in npdb schema
                            sv.entryExpiration,
                            (int)  sv.topEntries,

                            // removed in June XDK, but it will be back...
                            //sv.teamView,
                            false,

                            sv.arbitrated,
                            System.DateTime.UtcNow
                            //note: omission of ELO values is expected here since Xbox titles (which use ELO)
                            //      will be configured via a different schema than XLAST.  ELO will be configured there.
                            //note: MuSigma values are per-title.  DrawProbability (epsilon) is consumed directly from XLAST.
                            );
                        
                        lb.Descriptions = GetLocalizedDescription(sv.stringId, xlsp.GameConfigProject.LocalizedStrings);                 

                        lb.Columns = new LbColumn[sv.Columns.Length];

                        // Is this a platform visible leaderboard?
                        bool fNeedsPlatformVisibleConfiguration = IsPlatformVisibleSpecified(sv.platformVisible);
                        
                        // if no platform visible rating attribute id is specified, use default rating attributeId (65534)
                        if (fNeedsPlatformVisibleConfiguration && !sv.platformVisibleRatingAttributeIdSpecified)
                        {
                            sv.platformVisibleRatingAttributeId = 0xFFFE;
                        }

                        for (int i = 0; i < sv.Columns.Length; i++)
                        {
                            lb.Columns[i] = new LbColumn();
                            lb.Columns[i].Name = sv.Columns[i].attributeId.ToString();
                            lb.Columns[i].AttributeId = sv.Columns[i].attributeId;                            

                            if (sv.Columns[i].Item is PropertyFieldType)
                            {
                                lb.Columns[i].PropertyId = SafeConvert.ToUInt32(((PropertyFieldType)(sv.Columns[i].Item)).id);
                                lb.Columns[i].Aggregation = ((PropertyFieldType)(sv.Columns[i].Item)).Aggregation.type.ToString();
                            }

                            lb.Columns[i].Formula      = String.Format("attr[{0}]!=null?attr[{0}]:0", lb.Columns[i].AttributeId);
                            lb.Columns[i].Descriptions = GetLocalizedDescription(sv.Columns[i].stringId, xlsp.GameConfigProject.LocalizedStrings);
                            lb.Columns[i].ReturnType   = (int)GetReturnType();

                            // If this is a Platform Visible Leaderboard, then ensure that it gets the data it needs now in order for mixstats to process
                            // that data properly into NPDB's t_platform_visible_leaderboards table later (rating formatting data
                            if (fNeedsPlatformVisibleConfiguration)
                            {
                                // Column data is important to Platform Visible Leaderboard configuration!
                                if (lb.Columns[i].AttributeId == sv.platformVisibleRatingAttributeId)
                                {
                                    byte flags = (byte)PlatformVisibleFlags[sv.platformVisible];
                                    byte formatType = (byte)PlatformVisibleLeaderboardDataType.Long; // default
                                    byte format = 0; 

                                    foreach (XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty property in xlsp.GameConfigProject.Properties.Property)
                                    {
                                        // need to compare uints to uints, so convert hex string propertyId to uint for comparison with column property id
                                        string propertyId = property.id;
                                        const string HexPrefix = "0x";
                                        if (propertyId.Substring(0, HexPrefix.Length).ToLower() == HexPrefix)
                                        {
                                            propertyId = propertyId.Substring(HexPrefix.Length, propertyId.Length - HexPrefix.Length);
                                        }

                                        if (uint.Parse(propertyId, System.Globalization.NumberStyles.HexNumber) == lb.Columns[i].PropertyId)
                                        {
                                            // based on the propery.Format, set the PlatformVisibleAttribute                                            
                                            SetPlatformVisibleFormatBits(property.Format, ref formatType, ref format);
                                            break;
                                        }
                                    }

                                    // Add a platform visible leaderboard row to t_platform_visible_leaderboards table for every supported language
                                    for (int locIndex = 0; locIndex < lb.Descriptions.Length; locIndex++)
                                    {
                                        lb.AddPlatformVisibleLeaderboardInfo(
                                            lb.Descriptions[locIndex].Locale,                  // what locale?
                                            sv.platformVisibleRatingAttributeId,               // what attributeId is being used for rating?                                            
                                            flags,                                             // platform visbible flags                                            
                                            formatType,                                        // must match one of the PlatformVisibleLeaderboardDataType types
                                            format,                                            // if the formatType is either a Timespan or a DateTime, then this value must match a value in the PlatformVisibleLeaderboardTimeFormats enum.  If the format is Decimal, then this value == the number of decimals in the formatted result
                                            lb.Descriptions[locIndex].Description,             // name of the leaderboard in a specific language (indicated by index)
                                            lb.Columns[i].Descriptions[locIndex].Description   // rating string for the rating column in a specific language (matching the same language as the leaderboard name)
                                            );                                        
                                    }

                                    fNeedsPlatformVisibleConfiguration = false;  // once a leaderboard is configured to be platform visible, there's no need to configure it as such again
                                }
                            }
                        }
                        
                        lb.RawAttributes= GetRawAttributes(sv.Columns);

                        leaderboardList.Add( lb );
                    }
                }

                if ( //do we have game modes?
                    ( null != xlsp.GameConfigProject.GameModes ) &&
                    ( null != xlsp.GameConfigProject.GameModes.GameMode ) &&
                    ( 0 != xlsp.GameConfigProject.GameModes.GameMode.Length )
                    )
                {

                    int lbID = 0;

                    //extract game mode leaderboards
                    //if there are game modes, add skill for each GameMode element (no game modes is an acceptable configuration)
                    foreach ( LiveGameMode gm in xlsp.GameConfigProject.GameModes.GameMode )
                    {
                        Context c = FindGameTypeContext(xlsp.GameConfigProject.Contexts);

                        /*
                            The enumeration for this special GameType context is guaranteed to be 

                            0 - Ranked
                            1 - Standard
                        */

                        foreach (ContextValue cv in c.ContextValue)
                        {
                            bool bArbitrated = false;
                            
                            if (cv.contextValue == GAME_TYPE_CONTEXT_RANKED)
                            {
                                if (cv.friendlyName == "RANKED")
                                {
                                    lbID = (int) ( StatLbIdParser.SkillTypeRanked + gm.Value );
                                    bArbitrated = true;
                                }
                                else
                                    throw new ApplicationException("GAME_TYPE Context 0 is not RANKED - Has it been hand edited");
                            }
                            else if (cv.contextValue == GAME_TYPE_CONTEXT_STANDARD)
                            {
                                if (cv.friendlyName == "STANDARD")
                                {
                                    lbID = (int) ( StatLbIdParser.SkillTypeStandard + gm.Value );
                                    bArbitrated = false;
                                }
                                else
                                    throw new ApplicationException("GAME_TYPE Context 1 is not STANDARD - Has it been hand edited");     
                            }
                            else
                            {
                                continue; //not supported
                            }


                            if (lcHash[ lbID ] == null)
                                throw new ApplicationException("XLAST/LTC configuration mismatch: Cannot find leaderboard with ID = " + lbID);

                            lb = new LeaderboardSettings(
                                lcHash[ lbID ].ToString(),
                                ltc.TitleID,
                                lbID,
                                (byte)LbResetType.LbResetTypeNever,
                                0,      //max attachments
                                0,      //(int)  sv.maxAttachmentSize,
                                0,      //decaydays
                                -1,      //topentries
                                false,  //teamlb
                                bArbitrated,  //arbitrated
                                System.DateTime.UtcNow
                                //note: omission of ELO values is expected here since Xbox titles (which use ELO)
                                //      will be configured via a different schema than XLAST.  ELO will be configured there.
                                );

                            lb.Columns = GetTruSkillColumns(xlsp.GameConfigProject.LocalizedStrings.defaultLocale);

                            LocalizedDescription [] arrLocalizedGameMode = GetLocalizedDescription(gm.stringId, xlsp.GameConfigProject.LocalizedStrings);
                            lb.Descriptions = GetLocalizedDescriptionForTruSkillLb(arrLocalizedGameMode, cv, xlsp.GameConfigProject.LocalizedStrings);

                            lb.RawAttributes= GetRawAttributesFromLbColumn(lb.Columns);
                            leaderboardList.Add( lb );        
                        }
                    }
                }
            }

            return leaderboardList;

        } // get xlast leaderboards

        // Provided a XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat, parse it and create a Uint16 value based on in for storage
        // in the t_platform_visible_leaderboards table in NPDB.  This format data is used by a PlatformVisibleLeaderboard api to know how to format
        // the rating response values.
        private static void SetPlatformVisibleFormatBits(XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat propertyFormat, ref byte formatType, ref byte format)
        {
            if (propertyFormat.decimals > 0)
            {
                formatType = (byte)PlatformVisibleLeaderboardDataType.Decimal;
                format = (byte)propertyFormat.decimals;
            }
            else
            {
                if (propertyFormat.year)
                {
                    formatType = (byte)PlatformVisibleLeaderboardDataType.DateTime;

                    if (propertyFormat.milliseconds)    // MM/DD/YYYY HH::mm::ss::nn
                    {
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate;
                    }
                    else if (propertyFormat.seconds)    // MM/DD/YYYY HH::mm::ss
                    {
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.FullDate;
                    }
                    else if (propertyFormat.minutes)    // MM/DD/YYYY HH::mm
                    {
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.ExpandedDate;
                    }
                    else                        // MM/DD/YYYY
                    {
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.ShortDate;
                    }
                }
                else  // time, but without date?
                {
                    if (propertyFormat.milliseconds)    // HH::mm::ss::nn
                    {
                        formatType = (byte)PlatformVisibleLeaderboardDataType.Timespan;
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime;
                    }
                    else if (propertyFormat.seconds)    // HH::mm::ss
                    {
                        formatType = (byte)PlatformVisibleLeaderboardDataType.Timespan;
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.LongTime;
                    }
                    else if (propertyFormat.minutes)    // HH::mm
                    {
                        formatType = (byte)PlatformVisibleLeaderboardDataType.Timespan;
                        format = (byte)PlatformVisibleLeaderboardTimeFormats.ShortTime;
                    }
                }
            }
        }

        enum SpecialAttribEnum
        {
            Rank                = SpecialAttrib.Rank,
            Rating              = SpecialAttrib.Rating,
            Nickname            = SpecialAttrib.Nickname,
            Skill               = SpecialAttrib.Skill,
            GamesPlayed         = SpecialAttrib.GamesPlayed,
            Mu                  = SpecialAttrib.Mu,
            Sigma               = SpecialAttrib.Sigma
        }

        static EWebValueReturnType GetReturnType()
        {
            /*
                In XSC each column have things like:

                        <Type>Integer</Type> or <Type>Timestamp</Type> or <Type>TenMillisecond</Type> or <Type>HundredMillisecond</Type> or <Type>Minute</Type>

                In XLast there are no such thing. There is a data size & a formatting tag
                        <Property clsid="{43CE4FA7-6DE9-4F37-A929-49BFE63CBAAA}" id="0x20000003" stringId="34" dataSize="8" friendlyName="SCORE">
    				            <Format hours="false" minutes="false" seconds="false" milliseconds="false"/>
    			        </Property>

                Since this is just an attempt to be compatible with XSC and we don't support formatting, everything will default to string.
            */

            return EWebValueReturnType.String;
        }

        static Context FindGameTypeContext(Contexts s)
        {
            foreach (Context c in s.Context)
            {
                if (SafeConvert.ToUInt32(c.id)== GIDefs.X_CONTEXT_GAME_TYPE)
                {
                    return c;
                }
            }

            throw new Exception("Unable to Find Game_Type Context in XLast");
        }


        static LocalizedDescription [] GetLocalizedDescriptionForTruSkillLb(LocalizedDescription [] arrGameModes, ContextValue  cv, LocalizedStrings objLocalizedStrings)
        {
            LocalizedDescription [] arrLocalizedContext = GetLocalizedDescription(cv.stringId, objLocalizedStrings);
            
            foreach (LocalizedDescription localizedDes in arrGameModes)
            {
                string szContext = cv.friendlyName; //give it a default of friendly name
                foreach (LocalizedDescription localizedCon in arrLocalizedContext)
                {
                    if (localizedDes.Locale == localizedCon.Locale)
                    {
                        szContext = localizedCon.Description;
                        break;
                    }
                }
                
                localizedDes.Description = String.Format("{0}-{1} TrueSkill", localizedDes.Description, szContext);
            }
            
            return arrGameModes;
        }

        static LbColumn [] GetTruSkillColumns(string szDefaultLocale)
        {
            /*
              TRUSKILL have 4 columns

                public const ushort Skill               = 61;
                public const ushort GamesPlayed         = 62;
                public const ushort Mu                  = 63;
                public const ushort Sigma               = 64;

              On top of usual:

                public const ushort Rank                = 0xFFFF;
                public const ushort Rating              = 0xFFFE;
                public const ushort Nickname            = 0xFFFD;
            */
            int      [] arrValues = (int []) Enum.GetValues(typeof(SpecialAttribEnum));
            LbColumn [] arrRet = new LbColumn[arrValues.Length];
            
            for (int i=0;i<arrRet.Length;i++)
            {
                SpecialAttribEnum mapValue = (SpecialAttribEnum) arrValues[i];
                arrRet[i] = new LbColumn(((uint)mapValue).ToString(), (uint)mapValue, GetSimpleFormula((uint)mapValue));
                arrRet[i].Descriptions    = new LocalizedDescription[1];
                arrRet[i].Descriptions[0] = new LocalizedDescription(szDefaultLocale, mapValue.ToString());
                arrRet[i].ReturnType = (int)GetReturnType();
            }

            return arrRet;
                        
        }

        static string GetSimpleFormula(UInt32 attributeId)
        {
            return string.Format("attr[{0}]!=null?attr[{0}]:0", attributeId);
        }

        static LocalizedDescription [] GetLocalizedDescription(ushort uColumnStringId, LocalizedStrings objLocalizedStrings)
        {
            LocalizedDescription [] arrRet = null;

            foreach (LocalizedString objLocalString in objLocalizedStrings.LocalizedString)
            {
                if (objLocalString.id == uColumnStringId)
                {
                    arrRet = new LocalizedDescription[objLocalString.Translation.Length];
                    for (int i=0;i<arrRet.Length;i++)
                    {
                        arrRet[i]               = new LocalizedDescription();
                        arrRet[i].Locale        = objLocalString.Translation[i].locale;
                        arrRet[i].Description   = objLocalString.Translation[i].Value;
                    }
                }
            }

            return arrRet;
        }
    

        static RawAttribute [] GetRawAttributes(ViewFieldType [] arrViewTypeField)
        {
            RawAttribute [] arrRet = null;

            arrRet = new RawAttribute[arrViewTypeField.Length];

            for (int i =0;i< arrRet.Length; i++)
            {
                arrRet[i] = new RawAttribute();
                arrRet[i].Index  = arrViewTypeField[i].attributeId;
                arrRet[i].IsPuid = false;
            }

            return arrRet;
        }

        static RawAttribute [] GetRawAttributesFromLbColumn(LbColumn [] arrColumn)
        {
            RawAttribute [] arrRet = null;

            arrRet = new RawAttribute[arrColumn.Length];

            for (int i =0;i< arrRet.Length; i++)
            {
                arrRet[i] = new RawAttribute();
                arrRet[i].Index  = (int)arrColumn[i].AttributeId;
                arrRet[i].IsPuid = false;
            }

            return arrRet;
        }
        

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\base\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__base_1_none_12.4.56.0_none_e550c2a82903eb5c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_base_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.manifest
XP_MANIFEST_PATH=manifests\x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.cat
XP_CATALOG_PATH=manifests\x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.cat
XP_PAYLOAD_PATH=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_base_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\lbsvrclient.cs ===
//****************************************************************************
// 
// LbsvrClient.cs
//
// Lbsvr client implementation.
// 
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//****************************************************************************

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using xonline.common.mgmt;
using xonline.common.diagnostics;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.lbsvrclient)]

namespace xonline.server.stats.common
{
    public class LbsvrClientException : Exception
    {
        public LbsvrClientException(string message, int error, Exception e) 
            : base(message, e)
        {
            _error = error;
        }
        
        public int Error
        {
            get { return _error; }
        }
        
        protected int _error = 0;
    }
    
    public class LbsvrClientNetworkException : LbsvrClientException
    {
        public LbsvrClientNetworkException(string message, Exception e)
            : base(message, -1, e)
        {}
    }
    
    public class LbsvrClientRequestFailureException : LbsvrClientException
    {
        public LbsvrClientRequestFailureException(string message, int error, Exception e)
            : base(message, error, e)
        {
        }
    }
    
    public enum LbsvrClientState
    {
        Disconnected,
        Connected,
        SendingRequest,
        ReceivingResults,
        ReceivingRowset
    }

    //leaderboard in read or write status
    public enum LbStatus
    {
        DontExist = 0,
        Created   = 1, //created - no operation can be performed
        Loading   = 2, //loading but not complete yet - no operation can be performed
        UnLoading = 3, //unloading - no operation can be performed
        ReadOnly  = 4, //can be read
        ReadWrite = 5  //can be read or written
    }
    
    public enum LbsvrClientResult
    {
        None,
        Rowset,
        Message
    };
    
    // Similar to CLR's NetworkStream, but buffered
    public class BufferedNetworkStream : Stream
    {
        // BufferedNetworkStream
        public BufferedNetworkStream(
            Socket socket,
            int readBufferSize,
            int writeBufferSize
        )
        {
            _readBuffer  = new MemoryStream(readBufferSize);
            _writeBuffer = new MemoryStream(writeBufferSize);
            
            _socket      = socket; 
        }
        
        // Yes, you can read from it
        public override bool CanRead
        {
            get { return true; }
        }
        
        // Yes, you can write to it
        public override bool CanWrite
        {
            get { return true; }
        }
        
        // No, you can't seek
        public override bool CanSeek
        {
            get { return false; }
        }
        
        // Getting the Length of the stream is not supported
        public override long Length
        {
            get 
            {
                throw new NotSupportedException();
            }
        }
        
        // Getting or setting the position is also not supported
        public override long Position
        {
            get 
            {
                throw new NotSupportedException();
            }
            
            set
            {
                throw new NotSupportedException();
            }
        }
        
        // Read bytes from the stream. If succeeds, it will read at least one
        // byte and at most 'count' bytes. It might return 0 bytes if the 
        // socket is being shutdown
        public override int Read(
            byte [] buffer, 
            int offset, 
            int count
        )
        {
            int read = 0;

            if (count <= 0)
            {
                throw new Exception("BufferedNetworkStream Called with count <= 0");
            }
            // Try to read the requested ammount of bytes from the read buffer.
            // If we are able to read at least one byte, then we're fine. 
            if((read = _readBuffer.Read(buffer, offset, count)) == 0)
            {
                // Read buffer is empty. Time to refill using the socket.
                byte[] rcvbuffer = _readBuffer.GetBuffer();
                int rcvd = _socket.Receive(rcvbuffer);
                _readBuffer = new MemoryStream(rcvbuffer, 0, rcvd, false, true);
                
                // Try to read the data from the buffer again. If it's still
                // empty, then it's because the socket is probably being 
                // shutdown
                read = _readBuffer.Read(buffer, offset, count);
            }
            
            return read;
        }
        
        // Write bytes to the stream.
        public override void Write(
            byte [] buffer, 
            int offset, 
            int count
        )
        {
            // If the data can't be fitted in the write buffer, flush the 
            // write buffer.
            if(_writeBuffer.Capacity - _writeBuffer.Length < count)
            {
                Flush();
                Assert.IsTrue(_writeBuffer.Length == 0);
            }
            
            if(count < _writeBuffer.Capacity)
            {
                // WARNING: This means that we can only write blobs that 
                // can fit in the write buffer. Should not be a problem as
                // far as the lbsvr is concerned but if we decide to use
                // this for something else in the future, it's something that
                // can be easily fixed
                
                _writeBuffer.Write(buffer, offset, count);
            }
        }
        
        // Sends all the pending data in the write buffer to the socket
        public override void Flush()
        {         
            if(_writeBuffer.Length > 0)
            {
                byte[] buffer = _writeBuffer.GetBuffer();
                
                int written = _socket.Send(buffer, (int)_writeBuffer.Length, SocketFlags.None);
                
                if(written != _writeBuffer.Length)
                {
                    throw new LbsvrClientNetworkException(
                        String.Format("_socket.Send returned a number of bytes {0} different that was specified {1}", 
                            written, _writeBuffer.Length), null);
                }
                
                _writeBuffer.Seek(0, SeekOrigin.Begin);
                _writeBuffer.SetLength(0);
            }
        }
        
        // Seek is not supported
        public override long Seek(
            long offset,
            SeekOrigin origin
        )
        {
            throw new NotSupportedException();
        }
        
        // SetLength is not supported
        public override void SetLength(
            long value
        )
        {
            throw new NotSupportedException();
        }
        
        // Socket
        protected Socket       _socket;
        
        // Read buffer
        protected MemoryStream _readBuffer;
        
        // Write buffer
        protected MemoryStream _writeBuffer;
    }
    
    public class LbsvrClientConnection : LbsvrClientBase
    {
        static public LbsvrClientConnection OpenConnection(IPEndPoint lbsvrendpt)
        {
            LbsvrClientConnection cnt = null;
                
            // try to get a connection from the pool first
            
            //Don't lock on global object - hash table can support multiple reader 1 - writer
            Queue pool = (Queue) _connectionPool[lbsvrendpt];
            
            if(pool != null && pool.Count > 0)
            {
                cnt = (LbsvrClientConnection) pool.Dequeue(); //pool is a synchronized queue
                if (cnt != null)
                {
                    Assert.IsTrue(cnt._state == LbsvrClientState.Connected);
                    cnt._isInPool = false;                    
                }
            }
            
            if(cnt == null)
            {
                cnt = new LbsvrClientConnection();
                cnt.InternalOpenConnection("put_client_name_here", lbsvrendpt);
            }
            
            return cnt;
        }
        
        public void Close()
        {
            if(_state == LbsvrClientState.Disconnected)
                return;
            
            try
            {
                SetDefaultCommandTimeOut(); //consider letting the user do this if there is performance problem
                
                // Reset the connection back to the 'Connected' state
                Reset();
                
                // Add connection to the pool 
                if(!_isInPool)
                {
                    Queue pool = (Queue) _connectionPool[_lbsvrendpt];
                    
                    if(pool == null)
                    {
                        Queue poolNotSynchronized = new Queue(MaxPoolSize);
                        pool = Queue.Synchronized(poolNotSynchronized); //return a wrapper around the synchronized Queue
                        lock(_connectionPool)
                        {
                            if (_connectionPool[_lbsvrendpt] == null)
                            {
                                _connectionPool[_lbsvrendpt] = pool;
                            }
                            else
                            {
                                pool = (Queue) _connectionPool[_lbsvrendpt]; //some other threads just created the pool - use the old one
                            }
                        }
                    }
                    
                    if(pool.Count < MaxPoolSize)
                    {
                        _isInPool = true;
                        pool.Enqueue(this);
                    }
                    else
                    {
                        InternalCloseConnection();
                    }
                }
            }
            catch(Exception e)
            {
                // Close connection
                try {
                    InternalCloseConnection();
                } catch (Exception) {}
                
                Xom.NtEvent(XEvent.Id.STATS_COMM_2, e,
                    "Failed while trying to reset and close connection");
            }
        }
        
        new public void BeginRequest(int procCount)
        {
            try
            {
                base.BeginRequest(procCount);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public void SendRequest()
        {
            try
            {
                base.SendRequest();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public void CallProc(UInt32 procId, object[] parameters)
        {
            try
            {
                base.CallProc(procId, parameters);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public LbsvrClientResult NextResult()
        {
            try
            {
                return base.NextResult();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public bool NextRowset()
        {
            try
            {
                return base.NextRowset();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public bool Read()
        {
            try
            {
                return base.Read();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        public void Reset()
        {
            try
            {
                base.Reset(/*fIgnoreErrors=*/false);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        // Object cannot be constructed directly
        protected LbsvrClientConnection()
        {
        }

        protected const int MaxPoolSize = 100;
        static protected Hashtable _connectionPool = new Hashtable();
        protected bool _isInPool = false;
    }
    
    public class LbsvrClientBase
    {
        //********************************************************************
        // Public methods
        //********************************************************************
        
        public void BeginRequest(int procCount)
        {
            Assert.IsTrue(_state == LbsvrClientState.Connected);
            
            _state = LbsvrClientState.SendingRequest; 
            LbspReqBeginRequest beginReq = new LbspReqBeginRequest();
            beginReq.dwReqId    = ++_reqId;
            beginReq.wProcCount = (UInt16) procCount;
            
            BeginMessage(LbspIdReqBeginRequest);
            beginReq.WriteStream(GetSendBw());
            EndMessage();
        }
        
        public void SendRequest()
        {
            Assert.IsTrue(_state == LbsvrClientState.SendingRequest);
            Flush();
            _state = LbsvrClientState.ReceivingResults;
        }
        
        public void CallProc(UInt32 procId, object[] parameters)
        {
            Assert.IsTrue(_state == LbsvrClientState.SendingRequest);
            
            LbspReqProcCall procCall = new LbspReqProcCall();
            procCall.dwProcId = procId;
            procCall.rgParam  = parameters;
            
            BeginMessage(LbspIdReqProcCall);
            procCall.WriteStream(GetSendBw());
            EndMessage();
        }
        
        // Jump to the next result in the stream
        public LbsvrClientResult NextResult()
        {
            // If we're not receiving results, don't bother
            if(_state != LbsvrClientState.ReceivingResults &&
               _state != LbsvrClientState.ReceivingRowset)
            {
                #if DEBUG
                Assert.IsTrue(_resultType == LbsvrClientResult.None);
                #endif
                return LbsvrClientResult.None;
            }
            
            // Process messages until we find a message, the beginning of a 
            // new rowset or the end of the request
            for(;;)
            {
                UInt16 msgId = ProcessNextMessage();
                
                if(msgId == LbspIdRepMessage)
                {
                    if(_message.dwErrorId != 0)
                    {
                        // If message is an error, throw it now
                        if(_message.dwErrorId != 0)
                            throw new LbsvrClientRequestFailureException("Request failure. Error="+_message.dwErrorId+
                                " and message is:\n" + _message.message, (int)_message.dwErrorId, null);
                    }
                    
                    // New message detected 
                    break;
                }
                else if(
                    msgId == LbspIdRepRowsetStart ||
                    msgId == LbspIdRepEndRequest)
                {
                    
                    // New rowset or end of request detected
                    break;
                }
            }
            
            return _resultType;
        }
        
        // Jump to the next rowset on the stream
        public bool NextRowset()
        {
            for(;;)
            {
                // Just call NextResult until we run out of results or until
                // we reach a rowset
                LbsvrClientResult res = NextResult();
                
                if(res == LbsvrClientResult.None)
                    return false;
                    
                if(res == LbsvrClientResult.Rowset)
                    return true;
            }
        }
        
        // Read the next row of the rowset
        public bool Read()
        {
            // If current result is not a rowset, don't bother
            if(_resultType != LbsvrClientResult.Rowset)
                return false;
                
            // If we're not parsing the rowset anymore (because we reached the 
            // end of the rowset in a previous call to Read), don't bother
            if(_state != LbsvrClientState.ReceivingRowset)
                return false;
                
            // If the next message is not a LbspIdRepRowsetRow, then we reached
            // the end of the rowset. (ProcessNextMessage will take the 
            // appropriate action in case of protocol errors)
            if(ProcessNextMessage() != LbspIdRepRowsetRow)
                return false;
                
            // New row available
            return true;
        }
        
        public int GetColumnCount()
        {
            Assert.IsTrue(_state == LbsvrClientState.ReceivingRowset);
            return _row.rgColumns.Length;
        }
        
        public object GetColumn(int iCol)
        {
            Assert.IsTrue(_state == LbsvrClientState.ReceivingRowset);
            return _row.rgColumns[iCol];
        }
        
        //********************************************************************
        // Constants
        //********************************************************************
        
        // Limits
        public const UInt32 LbspMaxClientName      = 32;
        public const UInt32 LbspMaxProcCount       = 1000;
        public const UInt32 LbspMaxProcParamCount  = 1000;
        public const UInt32 LbspMaxSizeStringParam = 1024;
        public const UInt32 LbspMaxSizeMessage     = 1024;
        public const UInt32 LbspMaxRowsetColumns   = 1000;

        // Value types
        public const byte   LbspTypeIdInt8         = 0x01;
        public const byte   LbspTypeIdInt16        = 0x02;
        public const byte   LbspTypeIdInt32        = 0x03;
        public const byte   LbspTypeIdInt64        = 0x04;
        public const byte   LbspTypeIdDouble       = 0x05;
        public const byte   LbspTypeIdString       = 0x06;
        public const byte   LbspTypeIdTypeMask     = 0x7F;
        public const byte   LbspTypeIdNullFlag     = 0x80;
        
        // Low-level LBSP Message Ids
        public const UInt16  LbspIdReqHello         = 1;
        public const UInt16  LbspIdRepHello         = 2;
        public const UInt16  LbspIdReqBeginRequest  = 3;
        public const UInt16  LbspIdReqProcCall      = 5;
        public const UInt16  LbspIdRepRowsetStart   = 8;
        public const UInt16  LbspIdRepRowsetRow     = 9;
        public const UInt16  LbspIdRepRowsetEnd     = 11;
        public const UInt16  LbspIdRepMessage       = 12;
        public const UInt16  LbspIdRepEndRequest    = 13;
        public const UInt16  LbspIdReqPing          = 14;
        public const UInt16  LbspIdRepPing          = 15;
        
        // Procedure ids
        public const UInt32  LbProcIdLoadLb                = 1; //this is create lbs - does not load anything
        public const UInt32  LbProcIdDeleteLb              = 2;
        public const UInt32  LbProcIdStatRead              = 3;
        public const UInt32  LbProcIdStatWrite             = 4;
        public const UInt32  LbProcIdStatEnum              = 5;
        public const UInt32  LbProcIdDeleteTitle           = 6;
        public const UInt32  LbProcIdGetLbRankedEntryCount = 7;
        public const UInt32  LbProcIdResetPuid             = 8;
        public const UInt32  LbProcIdStatEnumNearPuid      = 9;
        public const UInt32  LbProcIdResetLb               = 10;
        public const UInt32  LbProcIdStatEnumNearRating    = 11;

        public const UInt32  LbProcIdDeleteLbFromMemoryOnly = 12;
        public const UInt32  LbProcIdSetLbToReadOnly        = 13;
        public const UInt32  LbProcIdSetLbToReadWrite       = 14; 
        public const UInt32  LbProcIdIsSafeToDeleteLb       = 15;
        public const UInt32  LbProcIdCreateAndLoadOneLb     = 16;
        public const UInt32  LbProcIdGetLbStatus            = 17;
        public const UInt32  LbProcIdEstimateRankForRatings = 18;
        public const UInt32  LbProcIdCheckConnection        = 19;
        
        public const UInt32  LbProcIdTestAutoReset         = 1001;
        public const UInt32  LbProcIdTestAutoDecay         = 1002;
        public const UInt32  LbProcIdTestChangeLastUpdateTime = 1003;
        
        // Errors
        public const UInt32 LbspErrorInvalidProcId   = 0x00000001;
        public const UInt32 LbspErrorLbAlreadyExists = 0x00000002;
        public const UInt32 LbspErrorLbDoesntExist   = 0x00000003;
        public const UInt32 LbspErrorInvalidParam    = 0x00000004;
        public const UInt32 LbspErrorFailureOccurred = 0xFFFFFFFE;
        public const UInt32 LbspErrorUnexpected      = 0xFFFFFFFF;

        public const UInt32 LbspErrorOperationNotPermitted = 0xF0000001;
        
        //********************************************************************
        // Protocol structures
        //********************************************************************
        
        // All LBSP messages start with this header
        protected struct LbspMsgHeader
        {
            // Size of the message in bytes including header
            public UInt16 wMsgSize;
            
            // Message type. One of the LbspId* constants
            public UInt16 wMsgType;
        
            public void ReadStream(BinaryReader br)
            {
                wMsgSize = br.ReadUInt16();
                wMsgType = br.ReadUInt16();
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(wMsgSize);
                bw.Write(wMsgType);
            }
            
            public int Size
            {
                get { return 4; }
            }
        };
        
        // Sent by the client upon establishing a connection
        protected struct LbspReqHello
        {
            // Size in bytes of clientName. Maximum size is LbspMaxClientName
            public UInt16 wClientNameLen;
            
            // Client name. ANSI string. Not null terminated
            public byte[] clientName;
            
            public void SetClientName(string name)
            {
                if(name == null 
                   || name.Length <= 0
                   || name.Length > LbspMaxClientName)
                {
                    throw new ArgumentException("Invalid parameter.", "name");
                }
                
                clientName     = Encoding.ASCII.GetBytes(name);
                wClientNameLen = (UInt16) clientName.Length;
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                #if DEBUG
                    Assert.IsTrue(clientName != null);
                    Assert.IsTrue(clientName.Length > 0 && clientName.Length <= LbspMaxClientName);
                    Assert.IsTrue(clientName.Length == wClientNameLen);
                #endif
                
                bw.Write(wClientNameLen);
                bw.Write(clientName);
            }
            
        };
        
        // Sent by the server in response to a LbspReqHello
        protected struct LbspRepHello
        {
            // Connection id assigned by the Leaderboard Server. The client should 
            // include the connection id on its error messages and logs.  
            public UInt32 dwCid;
            
            public void ReadStream(BinaryReader br)
            {
                dwCid = br.ReadUInt32();
            }
        };
        
        // Sent by the client to start a request
        protected struct LbspReqBeginRequest
        {
            // This is an arbitrary id assigned by the client. It will be used by
            // the server in error messages. It has no other purpose.
            public UInt32 dwReqId;

            // Number of procedures in the request
            public UInt16 wProcCount;
            
            public void ReadStream(BinaryReader br)
            {
                dwReqId    = br.ReadUInt32();
                wProcCount = br.ReadUInt16();
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(dwReqId);
                bw.Write(wProcCount);
            }
        };

        // A procedure in a request
        protected struct LbspReqProcCall
        {
            // The id of the server procedure
            public UInt32 dwProcId;

            // Number of parameters in rgParam
            public UInt16 wParamCount;

            // Procedure parameters
            // (this array is part of this message and should be taken in
            // consideration when specifying the size of the message in the header)
            public object[] rgParam;
            
            public void ReadStream(BinaryReader br)
            {
                dwProcId = 0;
                wParamCount = 0;
                rgParam = null;
                Assert.IsTrue(false);
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                wParamCount = (UInt16)rgParam.Length;
                
                bw.Write(dwProcId);
                bw.Write(wParamCount);
                
                for(int i=0; i < rgParam.Length; i++)
                {
                    object param = rgParam[i];
                    
                    if(param == null)
                    {
                        bw.Write((byte)LbspTypeIdNullFlag);
                    }
                    else if(param is sbyte)
                    {
                        bw.Write((byte)LbspTypeIdInt8);
                        bw.Write((sbyte)param);
                    }
                    else if(param is Int16)
                    {
                        bw.Write((byte)LbspTypeIdInt16);
                        bw.Write((Int16)param);
                    }
                    else if(param is Int32)
                    {
                        bw.Write((byte)LbspTypeIdInt32);
                        bw.Write((Int32)param);
                    }
                    else if(param is Int64)
                    {
                        bw.Write((byte)LbspTypeIdInt64);
                        bw.Write((Int64)param);
                    }
                    else if(param is Double)
                    {
                        bw.Write((byte)LbspTypeIdDouble);
                        bw.Write((Double)param);
                    }
                    else if(param is string)
                    {
                        byte[] binstr = Encoding.UTF8.GetBytes((string)param);
                        bw.Write((byte)LbspTypeIdString);
                        bw.Write((Int16)binstr.Length);
                        bw.Write(binstr);
                    }
                    else
                    {
                        throw new Exception("Data type not supported.");
                    }
                    
                }

                Xom.Trace(XomAreaName.lbsvrclient, LogLevel.L_LOW, "Writing proc call message:\n" + ToString());
                
            }
            
            public override string ToString()
            {
                StringBuilder bldr = new StringBuilder();
                bldr.Append("dwProcId=" + dwProcId + "\n");
                bldr.Append("wParamCount=" + wParamCount + "\n");
                bldr.Append("rgParam:\n");
                for (int i = 0; i < rgParam.Length; i++)
                {
                    object param = rgParam[i];
                    
                    bldr.Append("rgParam[" + i + "]=");
                    
                    if(param == null)
                    {
                        bldr.Append("(null)");
                    }
                    else if(param is sbyte)
                    {
                        bldr.Append("(int8) ");
                        bldr.Append(((sbyte)param).ToString("x"));
                    }
                    else if(param is Int16)
                    {
                        bldr.Append("(int16) ");
                        bldr.Append(((Int16)param).ToString("x"));
                    }
                    else if(param is Int32)
                    {
                        bldr.Append("(int32) ");
                        bldr.Append(((Int32)param).ToString("x"));
                    }
                    else if(param is Int64)
                    {
                        bldr.Append("(int64) ");
                        bldr.Append(((Int64)param).ToString("x"));
                    }
                    else if(param is Double)
                    {
                        bldr.Append("(double) ");
                        bldr.Append((Double)param);
                    }
                    else if(param is string)
                    {
                        byte[] binstr = Encoding.UTF8.GetBytes((string)param);
                        bldr.Append("(string) ");
                        bldr.Append(binstr);
                    }
                    else
                    {
                        bldr.Append("Unknown type!");
                    }
                    bldr.Append("\n");
                }
                
                return bldr.ToString();
            }    
                                    
                    
            
        };

        protected struct LbspRepRowsetRow
        {
            public UInt16 wColCount;
            public object[] rgColumns;
            
            public void ReadStream(BinaryReader br)
            {
                wColCount = br.ReadUInt16();
                
                if(wColCount > LbspMaxRowsetColumns)
                    throw new LbsvrClientNetworkException("Number of rows exceeds maximum", null);
                
                rgColumns = new object[wColCount];
                
                for(int i=0; i < rgColumns.Length; i++)
                {
                    byte bType = br.ReadByte();
                    
                    if((bType & LbspTypeIdNullFlag) != 0)
                    {
                        rgColumns[i] = null;
                        continue;
                    }
                    
                    switch(bType)
                    {
                    case LbspTypeIdInt8:
                        rgColumns[i] = (object) br.ReadSByte();
                        break;
                        
                    case LbspTypeIdInt16:
                        rgColumns[i] = (object) br.ReadInt16();
                        break;
                    
                    case LbspTypeIdInt32:
                        rgColumns[i] = (object) br.ReadInt32();
                        break;
                    
                    case LbspTypeIdInt64:
                        rgColumns[i] = (object) br.ReadInt64();
                        break;
                    
                    case LbspTypeIdDouble:
                        rgColumns[i] = (object) br.ReadDouble();
                        break;
                    
                    case LbspTypeIdString:
                        UInt16 wStrSize = br.ReadUInt16();
                        
                        if(wStrSize > LbspMaxSizeStringParam)
                            throw new LbsvrClientNetworkException("Size of string column exceeds maximum", null);
                        if (wStrSize > 0)
                        {
                            byte[] binstr = br.ReadBytes(wStrSize);
                            rgColumns[i] = (object) Encoding.UTF8.GetString(binstr);
                        }
                        else
                        {
                            rgColumns[i] = (object) String.Empty;
                        }
                        
                        break;
                    
                    default:
                        throw new LbsvrClientNetworkException("Invalid column type", null);
                    }
                }
            }
        };

        protected struct LbspRepMessage
        {
            public UInt32 dwErrorId;
            public UInt16 wMsgLen;
            public string message;
            
            public void ReadStream(BinaryReader br)
            {
                dwErrorId = br.ReadUInt32();
                wMsgLen   = br.ReadUInt16();
                
                if(wMsgLen > LbspMaxSizeMessage)
                    throw new LbsvrClientNetworkException("Size of message string exceeds maximum", null);

                if (wMsgLen > 0)
                {
                    byte[] binmsg = br.ReadBytes(wMsgLen);
                    message = Encoding.UTF8.GetString(binmsg);
                }
                else
                {
                    message = String.Empty;
                }
            }
        };

        protected struct LbspRepEndRequest
        {
            public UInt32 dwReqId;
            
            public void ReadStream(BinaryReader br)
            {
                dwReqId = br.ReadUInt32();
            }
        };
        
        protected struct LbspReqPing
        {
            public UInt32 dwPing;
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(dwPing);
            }
        }
        
        protected struct LbspRepPing
        {
            public UInt32 dwPing;
            
            public void ReadStream(BinaryReader br)
            {
                dwPing = br.ReadUInt32();
            }
        }
        
        //********************************************************************
        // Protected methods
        //********************************************************************
        
        protected LbsvrClientBase()
        {
            _msgSendBuffer = new byte[LbspMaxSizeMessage];
            _msgSendStream = new MemoryStream(_msgSendBuffer);
            _msgBw         = new BinaryWriterWrapper(_msgSendStream);
        }

        public void SetLongCommandTimeOut()
        {
            if (null != _socket)
            {
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeoutLong);
            }
        }

        public void SetDefaultCommandTimeOut()
        {
            if (null != _socket)
            {
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeout);
            }
        }
        
        protected void InternalOpenConnection(string clientName, IPEndPoint lbsvrendpt)
        {
            InternalCloseConnection();
        
            _lbsvrendpt = new IPEndPoint(lbsvrendpt.Address, lbsvrendpt.Port);

            Assert.IsTrue(_socket == null && _netStream == null);
            
            // Connect
            try
            {
                // Create new TCP socket and connect
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _socket.Connect(lbsvrendpt);
                
                // Create stream to handle socket IO. 
                _netStream = new BufferedNetworkStream(_socket, SendBufferSize, SendBufferSize);
                _netBr     = new BinaryReader(_netStream);
                _netBw     = new BinaryWriterWrapper(_netStream);
                
                // Handshake with the server
                Handshake(clientName);
            
                // Set timeout settings
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeout);
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeout);
                
                _state = LbsvrClientState.Connected;
            }
            catch(Exception e)
            {
                if(_netStream != null)
                {
                    _netStream.Close();
                    _netStream = null;
                }
                
                if(_socket != null)
                {
                    _socket.Close();
                    _socket = null;
                }
                    
                throw new LbsvrClientNetworkException("Failed to connect to "+lbsvrendpt, e);
            }
        }

        protected void InternalCloseConnection()
        {
            if(_netStream != null)
            {
                _netStream.Close();
                _netStream = null;
            }
            
            if(_socket != null)
            {
                try
                {
                    // Try to close connection gracefully
                    _socket.Shutdown(SocketShutdown.Both);
                } 
                finally
                {
                    // Close socket
                    _socket.Close();
                    _socket = null;
                }
            }
            
            _state = LbsvrClientState.Disconnected;
        }
        
        // Reset connection state
        protected void Reset(bool fIgnoreErrors)
        {
            // Ignore all messages (or at least a bunch of them)
            for(int i=0; i < 30; i++)
            {
                if(_state == LbsvrClientState.Connected)
                    return;
                
                UInt16 msgId = ProcessNextMessage();
                
                if(msgId == LbspIdRepMessage)
                {
                    if(!fIgnoreErrors && _message.dwErrorId != 0)
                    {
                        // If message is an error, throw it now
                        if(_message.dwErrorId != 0)
                            throw new LbsvrClientRequestFailureException("Request failure. Error="+_message.dwErrorId+
                                " and message is:\n" + _message.message, (int)_message.dwErrorId, null);
                    }
                }
            }
            
            // If we got here, we failed to reset the connection
            throw new LbsvrClientNetworkException("Failed to reset connection", null);
        }
        
        protected BinaryWriter GetSendBw()
        {
            Assert.IsTrue(_wMsgType != 0, "GetSendBw cannot be called before BeginMessage.");
            return _msgBw;
        }
        
        protected BinaryReader GetRecvBr()
        {
            return _netBr;
        }

        protected void BeginMessage(UInt16 wMsgType)
        {
            Assert.IsTrue(_wMsgType == 0, "BeginMessage called with another message pending.");
            
            _wMsgType = wMsgType;
            _msgSendStream.SetLength(0);
        }
        
        protected void EndMessage()
        {
            Assert.IsTrue(_wMsgType != 0, "EndMessage called with no message pending.");
            
            // Prepare the header
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.wMsgSize = (UInt16) (hdr.Size + _msgSendStream.Length);
            hdr.wMsgType = _wMsgType;
            
            Assert.IsTrue(hdr.wMsgSize <= LbspMaxSizeMessage);
            
            // Write the header and then the message blob
            hdr.WriteStream(_netBw);
            _netStream.Write(_msgSendBuffer, 0, (int)_msgSendStream.Length);
            
            // Reset state for the next message
            _wMsgType = 0;
            _msgSendStream.SetLength(0);
        }
        
        protected void Flush()
        {
            _netStream.Flush();
        }
        
        // Process the next message in the stream. Return the message id.
        private UInt16 ProcessNextMessage()
        {
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.ReadStream(GetRecvBr());
            
            switch(hdr.wMsgType)
            {
                case LbspIdRepEndRequest:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        LbspRepEndRequest endReq = new LbspRepEndRequest();
                        endReq.ReadStream(GetRecvBr());
                        
                        if(endReq.dwReqId != _reqId)
                        {
                            throw new LbsvrClientNetworkException(
                                "End-request message's reqId " +endReq.dwReqId+
                                " doesn't match current request id "+_reqId, null);
                        }
                        
                        _state      = LbsvrClientState.Connected;
                        _resultType = LbsvrClientResult.None;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                    
                case LbspIdRepMessage:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        _message.ReadStream(GetRecvBr());
                        _resultType = LbsvrClientResult.Message;
                        break;
                    }
                    else 
                    {
                        throw new LbsvrClientRequestFailureException("Received non-error message response when "+
                            "when state = " + _state.ToString()+". Anyways, the message text is: " + 
                            _message.message, -1, null);
                    }
                
                case LbspIdRepRowsetStart:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        _state      = LbsvrClientState.ReceivingRowset;
                        _resultType = LbsvrClientResult.Rowset;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                
                case LbspIdRepRowsetRow:
                    if(_state == LbsvrClientState.ReceivingRowset)
                    {
                        #if DEBUG
                        Assert.IsTrue(_resultType == LbsvrClientResult.Rowset);
                        #endif
                        _row.ReadStream(GetRecvBr());
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                    
                case LbspIdRepRowsetEnd:
                    if(_state == LbsvrClientState.ReceivingRowset)
                    {
                        if(hdr.wMsgSize != hdr.Size)
                            throw new LbsvrClientNetworkException("Unexpected message size", null);
                        
                        _state = LbsvrClientState.ReceivingResults;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                
                default:
                    throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType, null);
            }
                
            return hdr.wMsgType;
        }
        
        private void Handshake(string clientName)
        {
            // Send hello message
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeout);
            BeginMessage(LbspIdReqHello);
            LbspReqHello hello = new LbspReqHello();
            hello.SetClientName(clientName);
            hello.WriteStream(GetSendBw());
            EndMessage();
            Flush();
            
            // Server should send the hello reply in timely fashion
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, ConnectTimeout);
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.ReadStream(_netBr);
            
            if(hdr.wMsgType != LbspIdRepHello)
                throw new LbsvrClientNetworkException("Server send unexpected message type ("+hdr.wMsgType+"). ", null);
            
            LbspRepHello repHello = new LbspRepHello();
            repHello.ReadStream(_netBr);
            
            // This is the connection id assigned by the server
            _cid = repHello.dwCid;
            
            // We use the connection id to initialize this 'ping seed'. We'll
            // increment it each time we send a ping in an attempt to generate
            // unique values
            _pingSeed = _cid << 16;
        }
        
        private void ProcessMessageResult()
        {
            _message.ReadStream(GetRecvBr());
            
            if(_message.dwErrorId != 0)
                throw new LbsvrClientRequestFailureException("Request failure. Error="+_message.dwErrorId+
                    " and message is:\n" + _message.message, (int)_message.dwErrorId, null);
        }
        
        //********************************************************************
        // Protected members
        //********************************************************************
        
        protected const int SendBufferSize      = 8192;    // TODO: config
        protected const int ConnectTimeout      = 5000;
        protected const int SendTimeout         = 5000;
        protected const int PingTimeout         = 1000;
        protected const int CommandTimeout      = 60000; 
        protected const int CommandTimeoutLong  = 1200000; 
        
        protected IPEndPoint _lbsvrendpt;
        protected LbsvrClientState _state  = LbsvrClientState.Disconnected;
        protected UInt16 _wMsgType         = 0;
        protected byte[] _msgSendBuffer    = null;
        protected MemoryStream _msgSendStream = null;
        protected BinaryWriterWrapper _msgBw      = null;
        
        protected Socket _socket           = null;
        protected BufferedNetworkStream _netStream = null;
        protected BinaryWriterWrapper _netBw      = null;
        protected BinaryReader _netBr      = null;
        
        protected UInt32 _cid              = 0;
        protected UInt32 _reqId            = 0;
        protected UInt32 _pingSeed         = 0;
        
        protected LbspRepMessage _message  = new LbspRepMessage();
        protected LbspRepRowsetRow _row    = new LbspRepRowsetRow();
        protected LbsvrClientResult _resultType = LbsvrClientResult.None;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\base\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__base_1_none_12.4.56.0_none_e550c2a82903eb5c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_base_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.manifest
XP_MANIFEST_PATH=manifests\x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.cat
XP_CATALOG_PATH=manifests\x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58.cat
XP_PAYLOAD_PATH=x86__base_1_no-public-key_12.4.56.0_x-ww_819d9f58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_base_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\profilecommon.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// ProfileCommon.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.IO;
using System.Web;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.stats.common 
{
    public class ProfileUtil
    {
        public static Friend[] GetFriendList(ulong userId)
        {
            Friend[] friends = new Friend[XOn.XONLINE_MAX_FRIEND_COUNT];
            int i = 0;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_xprof_get_friends";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);

                WstDataReader reader = ws.Execute();
                while (reader.Read())
                {
                    friends[i] = new Friend();
                    friends[i].UserId = (ulong)(long)reader["bi_friend_puid"];
                    friends[i].Status = (byte)reader["ti_status"];
                    i++;
                }
            }

            return friends;
        }


        public static bool IsFriendInList(ulong userId, ulong friendUserId, ref Friend[] friends, bool acceptRequested)
        {
            int friendIndex;
            bool isFriend = false;

            if (friends == null)
                friends = ProfileUtil.GetFriendList(userId);

            friendIndex = -1;

            for (int i = 0;i < friends.Length;i++)
            {
                if (friends[i] == null)
                    break;

                if (friends[i].UserId == friendUserId)
                {
                    friendIndex = i;
                    break;
                }
            }

            if (friendIndex != -1 && friends[friendIndex].IsTrueFriend())
            {
                isFriend = true;
            }
            else if (friendIndex != -1 && acceptRequested && friends[friendIndex].IsRequest())
            {
                isFriend = true;
            }

            return isFriend;
        }
        
    }


    public class Friend : IComparable
    {
        public ulong UserId;
        public byte Status;

        public int CompareTo(object o)
        {
            return UserId.CompareTo(o);
        }

        public override bool Equals(object o)
        {
            if (o is ulong)
                return ((ulong)o == UserId);

            return o == this;
        }

        public override int GetHashCode()
        {
            return UserId.GetHashCode();
        }


        public bool IsPending()
        {
            return (Status == PresDefs.P_BUDDY_STATUS_PENDING);
        }
        public bool IsRequest()
        {
            return (Status == PresDefs.P_BUDDY_STATUS_REQUEST);
        }
        public bool IsTrueFriend()
        {
            return (Status == PresDefs.P_BUDDY_STATUS_OK);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_1_none_12.4.56.0_none_2756e3c643f947fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_MANIFEST_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_CATALOG_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_PAYLOAD_PATH=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\statcommon.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;

[assembly: XomAreaDefinition(XomAreaName.statslog)]
[assembly: XomAreaDefinition(XomAreaName.ctxDebug)]

namespace xonline.server.stats.common 
{
    public class StatsUtil
    {
        public static bool IsTeamPuid(ulong ulPuid)
        {
            return (ulPuid & 0xFF00000000000000) == 0xFE00000000000000;
        }
        
        // EnableContextDebugging
        // Call it in requests that takes any puids. It will turn on context 
        // debugging (ctxDebug) for that thread for the duration of that 
        // request.
        public static void EnableContextDebugging(ulong ulPuid)
        {
            if(ulPuid == (ulong)Config.GetLongSetting(Setting.stats_debugPuid))
                XomLogArea.SetContextLogging(true);
        }
    }
    
    // UnitKey
    public class UnitMembersKey
    {
        public UnitMembersKey(ulong[] members)
        {
            Init(members, false);
        }
        
        public UnitMembersKey(ulong[] members, bool fDontVerify)
        {
            Init(members, fDontVerify);
        }
        
        public override int GetHashCode() 
        {
            return _iHash;
        }

        public override bool Equals(object obj)
        {
            UnitMembersKey otherObj = (UnitMembersKey) obj;
        
            if( _members.Length != otherObj._members.Length 
                || _iHash != otherObj._iHash )
                return false;

            for(int i=0; i < _members.Length; i++)
            {
                if(_members[i] != otherObj._members[i])
                    return false;
            }
    
            return true;
        }
        
        protected void Init(ulong[] members, bool fDontVerify)
        {
            if(fDontVerify)
            {
                _members = (ulong[]) members.Clone();
            }
            else
            {
                Array.Sort(members);
                
                int i;
               
                // Eliminate zeros
                for(i=0; i < members.Length; i++)
                    if(members[i] != 0)
                        break;
                        
                _members = new ulong[members.Length - i];
                
                if(_members.Length < 2 || _members.Length > 4)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_39,
                        "Invalid number of unit members.");

                // Copy members and detect dups
                ulong ulLastPuid = 0;
                int j;
                for(j=0; i < members.Length; i++,j++)
                {
                    _members[j] = members[i];
                    
                    if(_members[j] == ulLastPuid)
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_40,
                            "duplicate unit members.");
                            
                    ulLastPuid = _members[j];
                }
            }
            
            PreCalcHash();
        }
        
        protected void PreCalcHash()
        {
            // pre-calc hash based on unit members
            _iHash = 0;
            for(int i=0; i < _members.Length; i++)
            {
                _iHash ^= _members[i].GetHashCode();                   
            }
        }
        
        public override string ToString()
        {
            return
                (_members.Length >= 1 ? _members[0].ToString("x16") : "")+
                (_members.Length >= 2 ? _members[1].ToString("x16") : "")+
                (_members.Length >= 3 ? _members[2].ToString("x16") : "")+
                (_members.Length >= 4 ? _members[3].ToString("x16") : "");
        }
    
        public ulong[]  _members;
        public int      _iHash;
    }
    
    // LbUserKey
    public class LbUserKey 
    {
        public LbUserKey(
            uint leaderBoardType,
            ulong userId)
        {
            this.leaderBoardType = leaderBoardType;
            this.userId = userId;
        }

        public override int GetHashCode() 
        {
            return leaderBoardType.GetHashCode() ^ userId.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            LbUserKey otherObj = (LbUserKey) obj;
            return (otherObj.leaderBoardType == leaderBoardType) &&
                (otherObj.userId == userId);
        }

        public uint leaderBoardType;
        public ulong userId;
    }

    [DataContract]
    public class PlatformVisibleLeaderboardMetadata
    {
        [DataMember(Name = "lbid")]
        public UInt32 id;

        [DataMember(Name = "name")]
        public string name;

        [DataMember(Name = "rating")]
        public string rating;

        [NonSerializedAttribute]
        public ushort ratingAttributeId;

        // don't serialize this value
        [NonSerializedAttribute]
        public byte flags;

        [NonSerializedAttribute]
        public byte type;

        [NonSerializedAttribute]
        public byte format;

        public PlatformVisibleLeaderboardMetadata()
        {
        }

        public PlatformVisibleLeaderboardMetadata(UInt32 id, ushort ratingAttributeId, string name, string rating, byte flags, byte type, byte format)
        {
            this.id = id;
            this.ratingAttributeId = ratingAttributeId;
            this.name = name;
            this.rating = rating;
            this.flags = flags;
            this.type = type;
            this.format = format;
        }
    }

    [DataContract]
    public class PlatformLeaderboardResponse
    {
        [DataMember(Name = "titleid")]
        public UInt32 titleid;

        [DataMember(Name = "primaryid")]
        public UInt32 primaryId;

        [DataMember(Name = "leaderboards")]
        public List<PlatformVisibleLeaderboardMetadata> leaderboards = new List<PlatformVisibleLeaderboardMetadata>();

        public PlatformLeaderboardResponse()
        {
        }

        public PlatformLeaderboardResponse(UInt32 lbid, ushort ratingAttributeId, string name, string rating, byte flags, byte type, byte format)
        {
            leaderboards.Add(new PlatformVisibleLeaderboardMetadata(lbid, ratingAttributeId, name, rating, flags, type, format));

            // Set the first lbid to the default, as it will always refer to a 'real' lbid.  
            // This value will be overwritten by the explicitly stated 'default' lbid, if set.
            primaryId = lbid;
        }

        public void AddLeaderboard(UInt32 lbid, ushort ratingAttributeId, string name, string rating, byte flags, byte type, byte format)
        {
            if (flags == (byte)PlatformVisibleLeaderboardFlags.Primary) // primary
            {
                primaryId = lbid;

                // the primary leaderboard is always the first leaderboard returned in the response
                leaderboards.Insert(0, new PlatformVisibleLeaderboardMetadata(lbid, ratingAttributeId, name, rating, flags, type, format));
            }
            else
            {
                leaderboards.Add(new PlatformVisibleLeaderboardMetadata(lbid, ratingAttributeId, name, rating, flags, type, format));
            }
        }
    }

    [DataContract]
    public class PlatformLeaderboardRowData
    {        
        [DataMember(Name = "xuid")]
        public ulong xuid;
        
        [DataMember(Name = "gamertag")]
        public string gamertag;

        [DataMember(Name = "rating")]
        public string rating;

        [DataMember(Name = "rank")]
        public uint rank;

        // The serializer needs a public default ctor
        public PlatformLeaderboardRowData() { }

        public PlatformLeaderboardRowData(ulong xuid, string nickname, string rating, uint rank)
        {
            this.xuid = xuid;
            this.gamertag = nickname;
            this.rating = rating;
            this.rank = rank;
        }
    }

    [DataContract]
    public class PagingInfo
    {        
        [DataMember(Name = "continuationToken")]
        public string continuationToken = null;

        [DataMember(Name = "totalItems")]
        public UInt16 totalItems;

        // The serializer needs a public default ctor
        public PagingInfo( UInt16 totalItems ) 
        {
            this.totalItems = totalItems;
        }
    }

    [DataContract]
    public class PlatformLeaderboardDataForUserResponse
    {        
        [DataMember(Name = "lbname")]
        public string name;

        [DataMember(Name = "rating")]
        public string rating;

        [DataMember(Name = "userData")]
        public PlatformLeaderboardRowData user = null;

        [DataMember(Name = "pagingInfo")]
        public PagingInfo pagingInfo = null;

        [DataMember(Name = "userList")]
        public List<PlatformLeaderboardRowData> userList = null;
        
        // The serializer needs a public default ctor
        public PlatformLeaderboardDataForUserResponse() { }
    }

    //PlatformVisibleTitleLocKey
    public class PlatformVisibleTitleLocKey
    {
        public UInt32   _uiTitleId;
        public int      _nLcid;

        public PlatformVisibleTitleLocKey(UInt32 uiTitleId, string locale)
        {
            CultureInfo ci = null;
            try
            {                
                ci = new CultureInfo(locale, false);
            }
            catch
            {
                // treat all unknown locales as en-US
                ci = new CultureInfo("en-US", false);
            }
                        
            _uiTitleId = uiTitleId;            
            _nLcid = ci.LCID;
        }

        public PlatformVisibleTitleLocKey(UInt32 uiTitleId, int lcid)
        {
            _uiTitleId = uiTitleId;
            _nLcid = lcid;
        }

        public override bool Equals(object obj)
        {
            return (_uiTitleId == ((PlatformVisibleTitleLocKey)obj)._uiTitleId)
                    && (_nLcid == ((PlatformVisibleTitleLocKey)obj)._nLcid);
        }

        public override int GetHashCode()
        {
            return (int)(_uiTitleId) + _nLcid;
        }
    }
    
    // TitleLbKey
    public class TitleLbKey
    {
        public uint     _uiTitleId;
        public uint     _uiLbId;
        
        public TitleLbKey(uint uiTitleId, uint uiLbId)
        {
            _uiTitleId = uiTitleId;
            _uiLbId = uiLbId;
        }
        
        // Object.Equals
        public override bool Equals(object obj)
        {
            return (_uiTitleId == ((TitleLbKey)obj)._uiTitleId)
                    && (_uiLbId == ((TitleLbKey)obj)._uiLbId);
        }
        
        public override int GetHashCode()
        {
            return (int)(_uiTitleId + _uiLbId);
        }
    }

    // StatAuth
    public class StatAuth
    {
        public StatAuth(ulong ulMachineId, ulong[] puids)
        {
            _ulMachineId = ulMachineId;
            _puids = (ulong[]) puids.Clone();
        }
        
        public ulong     _ulMachineId;
        public ulong[]   _puids;
    }
    
    // StatDbUnitEnumOrder
    public enum StatDbUnitEnumOrder
    {
        Activity = 1,
        Rating = 2
    };
    
    // IStatDb
    public interface IStatDb
    {
        IStatDbStatUpdate CreateStatUpdate(
            uint uiTitleId,
            DateTime sessionStarted,
            bool fLog );
            
        IStatDbRead CreateStatRead(
            uint uiTitleId,
            bool fLog );

        IStatDbRead CreateStatReadWithoutReadLimit(
            uint uiTitleId,
            bool fLog );
        
        ILeaderboardInfo GetLbInfo(
            uint uiTitleId,
            uint uiLbId );
        
        void RegisterPendingAttachment(
            uint                uiTitleId,
            uint                uiLb,
            ulong               ulUser, 
            string              attPathName,
            out uint            uiMaxAttSize );
    }

    // IStatDbStatUpdate
    public interface IStatDbStatUpdate
    {
        void PlayerLbStart(LbUserKey lbUserKey);
        void PlayerUpdateStat(ushort usStatId, object val);
        void Process(IStatDbStatUpdateCallback callback);
    }
    
    public interface IStatDbStatUpdateCallback
    {
        void OnQualifyForAttachment(uint uiLbId, ulong ulPuid);
    }

    // IStatRequest
    public interface IStatIO
    {
        Stream InputStream { get; }
        Stream OutputStream { get; }
        HttpResponse Response { get; }
        void SetXErr(uint uiTitleId, uint hr);
    }
    
    // IStatDbUnitEnumCallback
    public interface IStatDbUnitEnumCallback
    {
        void OnNewRow(ulong[] members, string[] names, long lRating); // BUGBUG: Add Activity 
        void OnAttribute(ushort usStatId, object val);
    }
    
    // IStatDbEnumLbCallback
    public interface IStatDbEnumLbCallback
    {
        void OnNewRow(ulong ulUserId, string name, long lRating, uint uiRank);
        void OnAttribute(ushort usStatId, object val);
    }
    
    // IStatDbRead
    public interface IStatDbRead
    {
        void RequestDataForUser(
            LbUserKey       key, 
            ushort[]        stats,
            bool fForcedException); 
            
        void Process(IStatDbReadCallback callback);
    }
    
    // IStatDbReadCallback
    public interface IStatDbReadCallback
    {
        void OnPlayerLbEntry(ulong ulPuid, uint uiLbId);
        void OnPlayerStat(ushort usStatId, object val);
    }

    // IStatProc
    public interface IStatProc
    {
        void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr);
            
        void Process(
            IStatPostProcParam pp, 
            IStatPostData pd);
    }
    
    // IStatProcIf
    public interface IStatProcIf : IStatProc
    {
        bool True
        {
            get;
        }
    }
    
    // IStatPostProcParam
    // Methods to get parameters passed to a StatPost procedure.
    public interface IStatPostProcParam
    {
        // ParamCount
        // Number of parameters passed to the procedure
        int ParamCount
        {
            get;
        }
        
        // ProcCount
        // Number of procedures in the request
        int ProcCount
        {
            get;
        }
        
        // GetParamInt8
        // Get Int8 (byte) parameter
        byte    GetParamInt8(
            int index);
        
        // GetParamInt16
        // Get Int16 (short) parameter
        short   GetParamInt16(
            int index);

        // GetParamInt32
        // Get Int32 (int) parameter
        int     GetParamInt32(
            int index);

        // GetParamInt64
        // Get Int64 (long) parameter
        long    GetParamInt64(
            int index);

        // GetParamFloat
        // Get Float (double) parameter
        double  GetParamFloat(
            int index);

        // GetParamUtf8String 
        // Get string parameter
        string  GetParamUtf8String(
            int index);

        // GetParamPuid
        // Get PUID parameter
        ulong   GetParamPuid(
            int index);

        // GetParamType
        // Get the type of a parameter. Type is one the constants in StatParam
        byte    GetParamType(int index);
        
        // GetProcCount
        // Retur
        IStatProc GetProcedure(int index);
    
        // GetLeaderboardInfo
        ILeaderboardInfo GetLeaderboardInfo(
            uint uiLbId);
    }
    
    // IStatPostData
    // Methods to get and update data for units, users and teams
    public interface IStatPostData
    {
        // PlayerStatReplace
        // Replace a player stat
        void PlayerStatReplace(
            LbUserKey       key,
            ushort          usStatId,
            object          val);
            
        // PlayerStatGet
        // Returns a stat. The data must have already been requested at 
        // IStatPostDataRequirements.RequestPlayerData or an Exception will be
        // thrown.
        object PlayerStatGet(
            LbUserKey       lbUserKey,
            ushort          usStatId);
    }
    
    // IStatPostDataRequirements
    // Methods to specify data requirements for StatPost procedures.
    public interface IStatPostDataRequirements
    {
        // RequestPlayerData
        // Before using any stats in UnitStatGet, they must be requested using RequestUnitData during the 
        // GetDataRequirements call. 
        void RequestPlayerData(
            LbUserKey       lbUserKey,
            ushort          usStatId);
            
        // IsPuidAuthorized
        // Call this to verify if a puid is allowed to write to a given leaderboard.
        void VerifyPuidIsAuthorized(
            ulong           ulPuid,
            uint            uiLbid,
            bool            fIsUnit);
       
        bool IsPuidAuthorized(
            ulong           ulPuid,
            uint            uiLbid,
            bool            fIsUnit,
            out string      errorMsg);
    }

    // IStatDbLeaderboardInfo
    public interface ILeaderboardInfo
    {
        uint            TitleId         { get;  }
        uint            LbId            { get;  }
        bool            IsUnitLb        { get;  }
        bool            IsTeam          { get;  }
        bool            ReqArbitration  { get;  }
        bool            IsEloEnabled    { get;  }
        float           Elo_E           { get;  }
        float           Elo_K           { get;  }
        int             Elo_New         { get;  }
        uint            AttachCount     { get;  }
        uint            MaxAttachSize   { get;  }
        
        long GetElo_C(long lRating, out int iBucket);
    }
    
    // StatProcedureAttribute
    [AttributeUsage(AttributeTargets.Class)]
    class StatProcedureAttribute : Attribute
    {
        public StatProcedureAttribute(string name, ushort usProcId)
        {
            _name           = name;
            _usProcId       = usProcId;
        }
        
        public string _name;
        public ushort _usProcId;
    }

    // PVL (Platform Visible Leaderboard) flags (currently only 1.. whether it is the 'primary' PVL or not)
    public enum PlatformVisibleLeaderboardFlags : byte
    {
        Primary =       0x1,
    }

    // PVL format bits indicating how the value should be formatted to the response string (long, floating point, or a formatted date)
    public enum PlatformVisibleLeaderboardDataType : byte
    {
        Long =          0, 
        Decimal =       1,
        Timespan =      2,
        DateTime =      3,
    }

    // Formatting bits specific to the FormatDate PlatformVisibleLeaderboardFormatBits above.  Specifies how the long rating value 
    // should be converted to a diplayable time with various finite time units.  
    public enum PlatformVisibleLeaderboardTimeFormats : byte
    {
        ShortTime =     1,    // HH:mm
        LongTime =      2,    // HH:mm:ss
        ExtraLongTime = 3,    // HH:mm:ss.fff
        ShortDate =     4,    // MM/DD/YYYY
        ExpandedDate =  5,    // MM/DD/YYYY HH:mm
        FullDate =      6,    // MM/DD/YYYY HH:mm:ss
        ExtraFullDate = 7,    // MM/DD/YYYY HH:mm:ss.fff
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_1_none_12.4.56.0_none_2756e3c643f947fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_MANIFEST_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_CATALOG_PATH=manifests\x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2.cat
XP_PAYLOAD_PATH=x86__common_1_no-public-key_12.4.56.0_x-ww_e2ce7bf2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\statimdb.cs ===
using System;
using System.Collections;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.protocol;

namespace xonline.server.stats.common
{
    // StatIMDb
    // Stat in-memory database for test and emulation purposes.
    public class StatIMDb : IStatDb
    {
        // IStatDb.CreateStatUpdate
        public IStatDbStatUpdate CreateStatUpdate(uint uiTitleId, DateTime sessionStarted, bool fLog)
        {
            return (IStatDbStatUpdate) (new StatDbStatUpdate(this, uiTitleId));
        }
        
        // IStatDb.CreateStatRead
        public IStatDbRead CreateStatRead(uint uiTitleId, bool fLog)
        {
            return (IStatDbRead) (new StatDbRead(this, uiTitleId));
        }

        //Same as Create Stat Read since imdb does not seem to handle read limit
        public IStatDbRead CreateStatReadWithoutReadLimit(uint uiTitleId, bool fLog)
        {
            return (IStatDbRead) (new StatDbRead(this, uiTitleId));
        }

        // GetLbInfo
        public ILeaderboardInfo GetLbInfo(
            uint uiTitleId,
            uint uiLbId )
        {
            ILeaderboardInfo lbInfo = null;
            
            TitleLbKey titleLbKey = new TitleLbKey(uiTitleId, uiLbId);
            PlayerLb playerLb = (PlayerLb)_playerLbs[titleLbKey];
            
            if(playerLb != null)
            {
                lbInfo = (ILeaderboardInfo) playerLb._lbInfo;
            }
            else
            {
                UnitTitle unitTitle = (UnitTitle) _unitTitles[uiTitleId];
                
                if(unitTitle != null)
                    lbInfo = (ILeaderboardInfo) unitTitle._unitLbInfo[uiLbId];
            }
                
            if(lbInfo == null)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.STATS_CODE_88, 
                    "Can't find mapping for title 0x"+uiTitleId.ToString("x")+" leaderboard "+uiLbId);

            return lbInfo;
        }
        
        // IStatDb.UnitEnum
        public void UnitEnum(
            uint                    uiTitleId, 
            ulong                   ulPuid, 
            uint                    uiLbId, 
            uint                    uiRowCount, 
            StatDbUnitEnumOrder     enumOrder, 
            ushort[]                statIds, 
            IStatDbUnitEnumCallback callback,
            bool                    fLog )
        {
            // Get unitTitle from StatIMDb using uiTitleId
            UnitTitle unitTitle = (UnitTitle) this._unitTitles[uiTitleId];

            // If not found, throw exception.
            if(unitTitle == null)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.STATS_CODE_89,
                    "Invalid title id 0x" + uiTitleId.ToString("x"));

            // Get unitUser from unitTitle using ulPuid
            UnitUser unitUser = (UnitUser) unitTitle._users[ulPuid];

            // Prepare array to store user's unitLbs
            ArrayList unitLbs = new ArrayList(unitUser._units.Count);
            
            // For each unit from unitUser
            foreach(Unit unit in unitUser._units.Keys)
            {
                // Check if unit has a unitLb using uiLbId
                UnitLb unitLb = (UnitLb) unit._unitLbs[uiLbId];
                
                if(unitLb != null)
                {
                    // If so, insert unitLb in array
                    unitLbs.Add(unitLb);
                }
            }

            // Sort by desired field
            if(enumOrder == StatDbUnitEnumOrder.Activity)
            {
                unitLbs.Sort(new UnitLb.SortByActivityDescending(unitTitle._dDecayFactor));
            }
            else
            {
                unitLbs.Sort(new UnitLb.SortByRatingDescending());
            }

            // For each unitLb in the first uiRowCount rows in the array
            int iMax = Math.Min((int)uiRowCount, unitLbs.Count);
            for(int iUnitLbNdx=0; iUnitLbNdx < iMax; iUnitLbNdx++)
            {
                UnitLb unitLb = (UnitLb) unitLbs[iUnitLbNdx];
                
                string[] names = new String[unitLb._unit._members.Length];
                for(int i=0; i < names.Length; i++)
                    names[i] = "player 0x"+unitLb._unit._members[i].ToString("x");

                // Call callback for new rows
                callback.OnNewRow(unitLb._unit._members, names, unitLb._lRating);

                // For each statId in statIds
                for(int iStatIdNdx=0; iStatIdNdx < statIds.Length; iStatIdNdx++)
                {
                    // Find stat in unitLb using statId
                    object val = unitLb._stats[statIds[iStatIdNdx]];

                    if(val != null)
                    {
                        // if found call callback for new attributes
                        callback.OnAttribute(statIds[iStatIdNdx], val);
                    }
                }
            }
        }
        
        public void RegisterPendingAttachment(
            uint                uiTitleId,
            uint                uiLb,
            ulong               ulUser, 
            string              attPathName,
            out uint            uiMaxAttSize )
        {
            throw new Exception("Not implemented");
        }
        
        public void ResetUser(
            uint    uiTitleId,
            uint    uiLbId,
            ulong   ulUserId )
        {
            ArrayList lbs = new ArrayList();
            
            if(uiLbId != 0)
            {
                PlayerLb lb = (PlayerLb) _playerLbs[new TitleLbKey(uiTitleId, uiLbId)];
                if(lb != null)
                    lbs.Add(lb);
            }
            else
            {
                foreach(PlayerLb lb in _playerLbs.Values)
                {
                    if(lb._uiTitleId == uiTitleId)
                        lbs.Add(lb);
                }
            }

            foreach(PlayerLb lb in lbs)
            {
                PlayerLbEntry lbEntry = (PlayerLbEntry) lb._lbEntries[ulUserId];
                if(lbEntry != null)
                {
                    lb._lbEntries.Remove(ulUserId);
                    lb._rankedEntries.Remove(lbEntry);
                    lb.Rerank();
                }
            }
        }

        public void CreateLeaderboard(
            uint    uiTitleId,
            uint    uiLbId )
        {
            CreateLeaderboard(uiTitleId, uiLbId, 0, 0, 0, 0, 0, "", 0, 0, "", false, false);
        }
        
        public void CreateLeaderboard(
            uint    uiTitleId,
            uint    uiLbType, 
            byte    bResetType, 
            int     iAttCount, 
            int     iMaxAttSize, 
            int     iDecayDays, 
            int     iMaxRatCount,
            string  eloE,
            int     eloK,
            int     eloNew,
            string  eloCtable,
            bool    fIsTeam,
            bool    fReqArbitration 
        )
        {
            TitleLbKey titleLbKey = new TitleLbKey(uiTitleId, uiLbType);
            PlayerLb playerLb = new PlayerLb(uiTitleId, (int)uiLbType, bResetType, iAttCount, iMaxAttSize, iDecayDays,
                iMaxRatCount, eloE, eloK, eloNew, eloCtable, fIsTeam, fReqArbitration);
            _playerLbs[titleLbKey] = playerLb;
        }
        
        public void UnitsUpdateStat(
            uint uiTitleId, 
            ulong[] unitMembers,
            uint   uiLbId,
            ushort usStatId,
            object val )
        {
            // Get unittitle using uiTitleId
            UnitTitle unitTitle = (UnitTitle) _unitTitles[uiTitleId];

            if(unitTitle == null)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.STATS_CODE_90,
                    "Invalid title id 0x" + uiTitleId.ToString("x"));

            // Get the unit from unitTitle using unitMembers
            UnitMembersKey unitKey = new UnitMembersKey(unitMembers);
            Unit unit = (Unit) unitTitle._units[unitKey];

            // If there's none, create one
            if(unit == null)
            {
                unit = new Unit(unitKey._members);
                unitTitle._units.Add(unitKey, unit);
            }
            
            // Update activity. If stat is 'activity' stop here.
            if(usStatId == SpecialAttrib.UnitActivity)
            {
                unit.AddActivity(unitTitle._dDecayFactor, (double) val);
                return;
            }
            else
            {
                unit.AddActivity(unitTitle._dDecayFactor, (double) 1.0);
            }

            // Get the unitLb from unit using uiLbId.
            UnitLb unitLb = (UnitLb) unit._unitLbs[uiLbId];
            
            // If there is none, create one
            if(unitLb == null)
            {
                unitLb = new UnitLb(unit, uiLbId);
                unit._unitLbs.Add(uiLbId, unitLb);
            }

            // Update unitLb's stat using usStatId and val
            if(usStatId == SpecialAttrib.Rating)
            {
                unitLb._lRating = (long) val;
            }
            else
            {
                unitLb._stats[usStatId] = val;
            }

            // For each member
            for(int iMember=0; iMember < unitMembers.Length; iMember++)
            {
                // Get his UnitUser
                UnitUser user = (UnitUser) unitTitle._users[unitMembers[iMember]];

                // If he doesn't have one yet, create one
                if(user == null)
                {
                    user = new UnitUser();
                    unitTitle._users.Add(unitMembers[iMember], user);
                }

                // Check if he has a reference to unit in his units table
                if(!user._units.ContainsKey(unit))
                {
                    // If he doesn't, add one
                    user._units.Add(unit, null);
                }
            }
        }

        public object GetPlayerStat(
            uint uiTitleId,
            uint uiLbId,
            ulong ulUserId,
            ushort usStatId )
        {
            PlayerLb lb = (PlayerLb) _playerLbs[new TitleLbKey(uiTitleId, uiLbId)];
                
            if(usStatId == SpecialAttrib.LeaderboardSize)
                return (object) lb._rankedEntries.Count;
            else 
            {
                PlayerLbEntry lbEntry = (PlayerLbEntry) lb._lbEntries[ulUserId];
                
                if(lbEntry == null)
                    return null;
                
                if(usStatId == SpecialAttrib.Rank)
                    return lbEntry._uiRank == uint.MinValue ? null : (object) (int) lbEntry._uiRank;
                else
                    return lbEntry._stats[usStatId];
            }
        }
        
        public object GetUnitStat(
            uint uiTitleId, 
            ulong[] unitMembers,
            uint   uiLbId,
            ushort usStatId )
        {
            UnitTitle unitTitle = (UnitTitle) _unitTitles[uiTitleId];

            UnitMembersKey unitKey = new UnitMembersKey(unitMembers);
            Unit unit = (Unit) unitTitle._units[unitKey];

            if(unit == null)
                return null;
            
            UnitLb unitLb = (UnitLb) unit._unitLbs[uiLbId];
            
            if(unitLb == null)
                return null;

            if(usStatId == SpecialAttrib.Rating)
            {
                return (object) unitLb._lRating;
            }
            else
            {
                return unitLb._stats[usStatId];
            }
        }

        // TrimUnits
        // Trims units from all users that exceed the limit set for the title.
        protected void TrimUnits()
        {
            foreach(UnitTitle title in _unitTitles.Values)
            {
                foreach(UnitUser user in title._users.Values)
                {
                    // If he's got more units than maxUnits + buffer
                    uint uiLimit = title._uiMaxAvailUnits + title._uiSizeUnitCache;
        
                    if(user._units.Count > uiLimit)
                    {
                        // Put all his units in an array
                        Unit[] userUnits = new Unit[user._units.Count];
                        user._units.Keys.CopyTo(userUnits, 0);
        
                        // Sort them by activity
                        Array.Sort(userUnits, new Unit.SortByActivityDescending(title._dDecayFactor));
        
                        // Remove all references to units beyound the limit set by
                        // uiMaxAvaiUnits
                        for(uint i=title._uiMaxAvailUnits; i < userUnits.Length; i++)
                        {
                            user._units.Remove(userUnits[i]);
                        }
                    }
                }
            }
        }
        
        // IStatDb.UnitGetStats
        protected void UnitGetStats(
            uint            uiTitleId, 
            UnitMembersKey  members, 
            uint[]          lbIds, IStatDbReadCallback callback)
        {
            // Get unitTitle from StatIMDb using uiTitleId as key
            UnitTitle unitTitle = (UnitTitle) this._unitTitles[uiTitleId];

            if(unitTitle == null)
                throw new XRLException(HResult.
                    XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.STATS_CODE_91,
                    "Invalid title id 0x" + uiTitleId.ToString("x"));

            // Get unit from unitTitle using members as key
            Unit unit = (Unit) unitTitle._units[members];

            // If not found, return.
            if(unit == null)
                return;

            // For each leaderboard id in lbIds
            for(int iLbId=0; iLbId < lbIds.Length; iLbId++)
            {
                // Get the unitLb from unit using leaderboard id
                UnitLb unitLb = (UnitLb) unit._unitLbs[lbIds[iLbId]];

                // If not found, continue and skip this one.
                if(unitLb == null)
                    continue;

//                 // call callback for new Leaderboard entries
//                 callback.OnUnitLbEntry(members, lbIds[iLbId]);
//                 callback.OnUnitStat(SpecialAttrib.Rating, unitLb._lRating);
//                                       
//                 // for each custom stat in unitLb
//                 foreach(DictionaryEntry statDicEntry in unitLb._stats)
//                 {
//                     // call callback for new stats
//                     callback.OnUnitStat((ushort)statDicEntry.Key,
//                         statDicEntry.Value);
//                 }
            }
        }
        
        protected Hashtable _unitTitles = new Hashtable();
        protected Hashtable _playerLbs  = new Hashtable();

        protected class PlayerLb  
        {
            public uint         _uiTitleId;
            public uint         _uiLbId;
            public Hashtable    _lbEntries      = new Hashtable();
            public ArrayList    _rankedEntries  = new ArrayList();
            public LeaderboardInfo _lbInfo;
            
            public PlayerLb(
                uint    uiTitleId,
                int     iLbType, 
                byte    bResetType, 
                int     iAttCount, 
                int     iMaxAttSize, 
                int     iDecayDays, 
                int     iMaxRatCount,
                string  eloE,
                int     eloK,
                int     eloNew,
                string  eloCtable,
                bool    fIsTeam,
                bool    fReqArbitration )
            {
                _uiTitleId = uiTitleId;
                _uiLbId = (uint)iLbType;
                _lbInfo = new LeaderboardInfo(uiTitleId, (uint)iLbType, false, fIsTeam, fReqArbitration,
                    eloE.Trim().ToLower() == "e" ? (float)Math.E : (float)10.0, eloK, eloNew, eloCtable, 
                    (uint)iAttCount, (uint)iMaxAttSize);
            }
            
            public void Rerank()
            {
                _rankedEntries.Sort();
                int iRank = 1;
                foreach(PlayerLbEntry lbEntry in _rankedEntries)
                {
                    lbEntry._uiRank = (uint) iRank++;
                }
            }
        }
        
        protected class PlayerLbEntry : IComparable
        {
            public ulong        _ulUserId;
            public Hashtable    _stats = new Hashtable();
            public long         _lRating = long.MinValue;
            public uint         _uiUntier = 0;
            public uint         _uiRank = uint.MinValue;
            static public uint  _uiUntierSeed = 0;
            
            public PlayerLbEntry(ulong ulUserId)
            {
                _ulUserId = ulUserId;
            }
            
            public bool SetStat(ushort usStatId, object val)
            {
                if((usStatId & 0x8000) != 0)
                {
                    if(usStatId == SpecialAttrib.Rating)
                    {
                        if(!(val is long))
                            throw new Exception("ASSERT FAILED: !(val is long)");
                            
                        long lNewRating = (long) val;
                        
                        if(_lRating != lNewRating)
                        {
                            _lRating = (long) val;
                            _uiUntier = _uiUntierSeed++;
                        }
                    }
                    else if(usStatId == SpecialAttrib.Nickname)
                    {
                        if(!(val is string))
                            throw new Exception("ASSERT FAILED: !(val is string)");
                    }
                }
                
                bool fNew = !_stats.ContainsKey(usStatId);
                
                _stats[usStatId] = val;
                
                return fNew;
            }
            
            // IComparable.CompareTo
            public int CompareTo(object obj)
            {
                // Sort descending by rating               
                int c = ((PlayerLbEntry)obj)._lRating.CompareTo(_lRating);
                
                // In case of same rating, use _uiUntier to decide. The expected behavior is that who got in first
                // takes precedence.
                if(c == 0)
                    c = _uiUntier.CompareTo(((PlayerLbEntry)obj)._uiUntier);
                    
                return c;
            }
            
            
        }
           
        protected class UnitTitle
        {
            public uint         _uiTitleId;
            public double       _dDecayFactor;
            public uint         _uiMaxAvailUnits;
            public uint         _uiSizeUnitCache;
            public Hashtable    _unitLbInfo = new Hashtable();
            public Hashtable    _units = new Hashtable();
            public Hashtable    _users = new Hashtable();
        }
        
        protected class Unit
        {
            public class SortByActivityDescending : IComparer
            {
                public SortByActivityDescending(double dDecayFactor)
                {
                    _dDecayFactor = dDecayFactor;
                }
                
                public int Compare (object x, object y)
                {
                    Unit unit1 = (Unit) x;
                    Unit unit2 = (Unit) y;

                    return unit2.CalcActivity(_dDecayFactor).
                        CompareTo(unit1.CalcActivity(_dDecayFactor));
                }

                public double _dDecayFactor;
            }

            public Unit(ulong[] members)
            {
                _members = members;
            }
            
            public double CalcActivity(double dDecayFactor)
            {
                // Calculate the difference in minutes since last activity
                // 'til now.
                double dMinutesDiff = (DateTime.UtcNow - _lastActivity).TotalMinutes;
                
                // Effective activity is the stored activity decayed over
                // time
                return _activity * Math.Exp(-(dMinutesDiff * dDecayFactor));
            }

            public void AddActivity(double dDecayFactor, double delta)
            {
                _activity = CalcActivity(dDecayFactor) + delta;
            }
            
            public ulong[]      _members;
            public DateTime     _lastActivity   = DateTime.UtcNow;
            public double       _activity       = 0.0;
            public Hashtable    _unitLbs        = new Hashtable();
        }

        protected class UnitLb
        {
            public class SortByActivityDescending : IComparer
            {
                public SortByActivityDescending(double dDecayFactor)
                {
                    _dDecayFactor = dDecayFactor;
                }
                
                public int Compare (object x, object y)
                {
                    UnitLb unit1 = (UnitLb) x;
                    UnitLb unit2 = (UnitLb) y;

                    return unit2._unit.CalcActivity(_dDecayFactor).
                        CompareTo(unit1._unit.CalcActivity(_dDecayFactor));
                }

                public double _dDecayFactor;
            }

            public class SortByRatingDescending : IComparer
            {
                public int Compare (object x, object y)
                {
                    UnitLb unit1 = (UnitLb) x;
                    UnitLb unit2 = (UnitLb) y;

                    return unit2._lRating.CompareTo(unit1._lRating);
                }
            }
            
            public UnitLb(Unit unit, uint uiUnitLbId)
            {
                _unit = unit;
                _uiUnitLbId = uiUnitLbId;
            }
            
            public Unit         _unit;
            public uint         _uiUnitLbId;
            public Hashtable    _stats      = new Hashtable();
            public long         _lRating    = 0;
        }
        
        protected class UnitUser
        {
            public Hashtable    _units      = new Hashtable();
        }

        protected class StatDbRead : IStatDbRead
        {
            public StatDbRead(StatIMDb statimdb, uint uiTitleId)
            {
                _statimdb = statimdb;
                _uiTitleId = uiTitleId;
            }
            
            public void RequestDataForUnit(
                UnitMembersKey  members, 
                uint            uiLbId,
                ushort[]        stats )
            {
                Hashtable lbids = (Hashtable)_units[members];
                if(lbids == null)
                {
                    lbids = new Hashtable();
                    _units[members] = lbids;
                }
                
                lbids[uiLbId] = uiLbId;
            }
            
            public void RequestDataForUser(
                LbUserKey       key, 
                ushort[]        stats,
                bool fForcedException)
            {
                _playerLbEntries[key] = null;                
            }
            
            public void Process(IStatDbReadCallback callback)
            {
                foreach(DictionaryEntry unitDicEntry in _units)
                {
                    UnitMembersKey members = (UnitMembersKey) unitDicEntry.Key;
                    Hashtable lbidsTable = (Hashtable) unitDicEntry.Value;
                    
                    uint[] lbids = new uint[lbidsTable.Count];
                    lbidsTable.Values.CopyTo(lbids, 0);
                    _statimdb.UnitGetStats(_uiTitleId, members, lbids, callback);
                }
                
                foreach(LbUserKey lbUserKey in _playerLbEntries.Keys)
                {
                    PlayerLb lb = (PlayerLb) _statimdb._playerLbs[new TitleLbKey(_uiTitleId, lbUserKey.leaderBoardType)];
                    
                    if(lbUserKey.userId != 0)
                    {
                        PlayerLbEntry lbEntry = 
                            (PlayerLbEntry) lb._lbEntries[lbUserKey.userId];
                        
                        if(lbEntry != null)
                        {
                            callback.OnPlayerLbEntry(lbUserKey.userId, lbUserKey.leaderBoardType);
                            
                            foreach(DictionaryEntry statDicEntry in lbEntry._stats)
                            {
                                ushort usStatId = (ushort) statDicEntry.Key;
                                object val = statDicEntry.Value;
                                
                                callback.OnPlayerStat(usStatId, val);
                            }
                            
                            if(lbEntry._uiRank != uint.MinValue)
                                callback.OnPlayerStat(SpecialAttrib.Rank, (int)lbEntry._uiRank);
                        }
                    }
                    else
                    {
                        callback.OnPlayerLbEntry(0, lbUserKey.leaderBoardType);
                        callback.OnPlayerStat(SpecialAttrib.LeaderboardSize, (int) lb._rankedEntries.Count);
                    }
                }
            }
            
            protected Hashtable     _units = new Hashtable();
            protected Hashtable     _playerLbEntries = new Hashtable();
            protected StatIMDb      _statimdb;
            protected uint          _uiTitleId;
        }
        
        protected class StatDbStatUpdate : IStatDbStatUpdate
        {
            public StatDbStatUpdate(StatIMDb statimdb, uint uiTitleId)
            {
                _uiTitleId = uiTitleId;
                _statimdb = statimdb;
            }
            
            public void UnitStart(UnitMembersKey key)
            {
                _members = key._members;
            }

            public void UnitLbStart(uint uiUnitLb)
            {
                _uiUnitLbId = uiUnitLb;
            }

            public void UnitUpdateStat(ushort usStatId, object val)
            {
                _statimdb.UnitsUpdateStat(_uiTitleId, _members, _uiUnitLbId, usStatId, val);
            }

            public void PlayerLbStart(LbUserKey lbUserKey)
            {
                _playerLb = (PlayerLb) _statimdb._playerLbs[new TitleLbKey(_uiTitleId, lbUserKey.leaderBoardType)];
                
                if(_playerLb == null)
                    throw new Exception("ASSERT FAILED: playerLb == null");
                    
                _playerLbEntry = (PlayerLbEntry) _playerLb._lbEntries[lbUserKey.userId];
                
                if(_playerLbEntry == null)
                {
                    _playerLbEntry = new PlayerLbEntry(lbUserKey.userId);
                    _playerLb._lbEntries[lbUserKey.userId] = _playerLbEntry;
                }
            }
            
            public void PlayerUpdateStat(ushort usStatId, object val)
            {
                bool fNew = _playerLbEntry.SetStat(usStatId, val);
                
                if(usStatId == SpecialAttrib.Rating)
                {
                    if(fNew)
                    {
                        // fNew means that the lbEntry just got a rating, which means that it's not in the ranked 
                        // entries array yet. Add it to the array before we resort it.
                        _playerLb._rankedEntries.Add(_playerLbEntry);
                    }
                    
                    // Rerank later
                    _rerank[_playerLb] = null;
                }
            }
            
            public void Process(IStatDbStatUpdateCallback callback)
            {
                _statimdb.TrimUnits();
            
                foreach(PlayerLb playerLb in _rerank.Keys)
                {
                    playerLb.Rerank();
                }
            }
            
            public StatIMDb         _statimdb;
            public uint             _uiTitleId;
            public ulong[]          _members        = null;
            public uint             _uiUnitLbId     = 0;
            public PlayerLb         _playerLb       = null;
            public PlayerLbEntry    _playerLbEntry  = null;
            public Hashtable        _rerank = new Hashtable();
        }
        
        protected class LeaderboardInfo : ILeaderboardInfo
        {
            public LeaderboardInfo(
                uint            uiTitleId, 
                uint            uiLbId, 
                bool            fIsUnitLb, 
                bool            fIsTeam,
                bool            fReqArbitration,
                float           eloE,
                float           eloK,
                int             eloNew,
                string          eloC,
                uint            uiAttachCount,
                uint            uiMaxAttachSize )
            {
                _uiTitleId  = uiTitleId;
                _uiLbId     = uiLbId;
                _fIsUnitLb  = fIsUnitLb;
                _fIsTeam    = fIsTeam;
                _fReqArbitration = fReqArbitration;
                _fEloE      = eloE;
                _fEloK      = eloK;
                _iEloNew    = eloNew;
                ParseEloC(eloC);
                _uiAttachCount = uiAttachCount;
                _uiMaxAttachSize = uiMaxAttachSize;
            }
            
            public uint             TitleId         { get { return _uiTitleId; } }
            public uint             LbId            { get { return _uiLbId; } }
            public bool             IsUnitLb        { get { return _fIsUnitLb; } }
            public bool             IsTeam          { get { return _fIsTeam; }  }
            public bool             ReqArbitration  { get { return _fReqArbitration; } }
            public bool             IsEloEnabled    { get { return true; } }
            public float            Elo_E           { get { return _fEloE; } }
            public float            Elo_K           { get { return _fEloK; } }
            public int              Elo_New         { get { return _iEloNew; } }
            public uint             AttachCount     { get { return _uiAttachCount; } }
            public uint             MaxAttachSize   { get { return _uiMaxAttachSize; } }
            
            public long GetElo_C(long lRating, out int iBucket)
            {
                // Find the right C for this lRating
                int i;
                for(i=1; i < _eloC.Length; i++)
                {
                    if(_eloC[i]._lStartRating > lRating)
                        break;
                }
                
                iBucket = Math.Max(i-1, 0);
                
                return _eloC[i-1]._iC;
            }

            protected void ParseEloC(string eloCvalue)
            {
                // The ELO_C parameter contains an array that maps rating ranges to C constants.
                // Ex: ELO_C=0:40,1000:20,1500:10
                // The example above means that from 0 to 999 C = 40, 1000 to 1499 C = 20 and 1500 ahead C = 10
                
                if(eloCvalue != String.Empty)
                {
                    string[] elocpairs = eloCvalue.Split(new char[]{','});
                    _eloC = new ELO_C[elocpairs.Length];
                    
                    for(int iElocNdx=0; iElocNdx < _eloC.Length; iElocNdx++)
                    {
                        string[] ratingAndC = elocpairs[iElocNdx].Split(new char[]{':'});
                        _eloC[iElocNdx]._lStartRating = Convert.ToInt64(ratingAndC[0]);
                        _eloC[iElocNdx]._iC = Convert.ToInt32(ratingAndC[1]);
                    }
                }
                else
                {
                    _eloC = new ELO_C[1];
                    _eloC[0]._lStartRating = 0;
                    _eloC[0]._iC = 0;
                }

                
                Array.Sort(_eloC);
            }
            
            protected struct ELO_C : IComparable
            {
                public ELO_C(long lStartRating, int iC)
                {
                    _lStartRating = lStartRating;
                    _iC = iC;
                }
                
                public long     _lStartRating;
                public int      _iC;
                
                // IComparable.CompareTo
                public int CompareTo(object obj)
                {
                    return _lStartRating.CompareTo(((ELO_C)obj)._lStartRating);
                }
            }
            
            protected   uint            _uiTitleId;
            protected   uint            _uiLbId;
            protected   bool            _fIsUnitLb;
            protected   bool            _fIsTeam;
            protected   bool            _fReqArbitration;
            protected   float           _fEloE      = 10.0F;
            protected   float           _fEloK      = 120.0F;
            protected   int             _iEloNew    = 500;
            protected   ELO_C[]         _eloC       = new ELO_C[] { new ELO_C(0, 40) };
            protected   uint            _uiAttachCount;
            protected   uint            _uiMaxAttachSize;
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\statexcept.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;
    
namespace xonline.server.stats.common
{
    public class BadRequestStatsException : XRLException
    {
        public BadRequestStatsException(string req, string reason, Exception e)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_51,
            "Failed to parse "+req+". Reason: "+(reason!=null?reason:e.Message), e) {}
    }
    
    public class InvalidTitleOrLeaderboardStatsException : XRLException
    {
        public InvalidTitleOrLeaderboardStatsException(string proc) 
            : base(xonline.common.service.HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.XSTATSFD_MISSING_DB_MAPPING,
            "Procedure "+proc+" failed because one ore more leaderboards in the request don't exist or has the wrong "+
            "type. E.g. trying to write stats for a user in a units leaderboard.")  {}
    
        public InvalidTitleOrLeaderboardStatsException(uint uiTitleId, uint uiLbId) 
            : base(xonline.common.service.HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.XSTATSFD_MISSING_DB_MAPPING_1,
            "Can't find mapping for title 0x"+uiTitleId.ToString("x")+" leaderboard "+uiLbId+
            ". If the leaderboard exists in the server, use 'e :xstatsfd reloaddbmap' on xmgmtc to reload the dbmap."){}
    }
    
    public class InvalidCompetitionTemplateStatsException : XRLException
    {
        public InvalidCompetitionTemplateStatsException(uint uiTitleId, uint uiTemplateId)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.XSTATSFD_MISSING_DB_MAPPING_2,
            string.Format("Title 0x{0} is missing competition template {1} information or doesn't have partitions "+
            "configured", uiTitleId.ToString("x"), uiTemplateId)) {}
    }
    
    public class InvalidCompetitionPartitionStatsException : XRLException
    {
        public InvalidCompetitionPartitionStatsException(uint uiTitleId, uint uiLbId)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, XEvent.Id.STATS_CONFIG_9,
            "Can't find partition for title 0x"+uiTitleId.ToString("x")+" competition leaderboard id "+ uiLbId + 
            ". The partition id is "+StatLbIdParser.GetPartition(uiLbId) + ". If the partition has been created recently, "+
            "it was probably not updated in the front-door's dbmap. Use 'e :xstatsfd reloaddbmap' on xmgmtc to reload the "+
            "dbmap.") {}
    }
    
    public class LeaderboardReadonlyStatsException : XRLException
    {
        public LeaderboardReadonlyStatsException(string proc) 
            : base(xonline.common.service.HResult.XONLINE_E_STAT_LEADERBOARD_READONLY, XEvent.Id.XSTATSFD_LEADERBOARD_READONLY,
            "Procedure "+proc+" failed because one ore more leaderboards in the request is marked as read-only. "+
            "This can be expected ONLY when leaderboards are being moved between servers.")  {}
    }
    
    public class LeaderboardWasResetStatsException : XRLException
    {
        public LeaderboardWasResetStatsException(string proc)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_LEADERBOARD_WAS_RESET, XEvent.Id.XSTATSFD_RESET_CHECK_FAILED,
            "Procedure " +proc+" failed because one ore more leaderboards in the request failed the reset-check. "+
            "It means that the xbox trying to write logged on BEFORE the leaderboard was last reset.") {}
    }
    
    public class UnexpectedReturnCodeFromStoredProcedureStatsException : XRLException
    {
        public UnexpectedReturnCodeFromStoredProcedureStatsException(string proc, int ret) 
            : base(xonline.common.service.HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_4,
            "Procedure "+proc+" returned an unexpected error: "+ret) {}
    }
    
    public class CertificationModeNotEnabledStatsException : XRLException
    {
        public CertificationModeNotEnabledStatsException(string req)
            : base (xonline.common.service.HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.XSTATSFD_FORBIDDEN_CERT_REQUEST,
            "Request "+req+" failed because certification requests are not allowed in this environment. "+
            "To enable certification requests, add StatsEnableCertificationMode=true to xstatsfd.ini.") {}
    }
    
    public class AccessDeniedStatsException : XRLException
    {
        public AccessDeniedStatsException(string req)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_HACK_53,
            "Request "+req+" failed because it doesn't match its security credentials (SGAuth, BundledAuth)") {}
    }
    
    public class UnhandledStatsException : XRLException
    {
        public UnhandledStatsException(string req, Exception e)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_5,
            "Request "+req+" failed because of an unhandled exception. Message: "+e.Message, e) {}
    }
    
    public class LbsvrRequestException : XRLException
    {
        public LbsvrRequestException(string req, string error)
            : base(xonline.common.service.HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_6,
            "Lbsvr request '"+req+"' failed. Error: "+error) {}

        public LbsvrRequestException(uint hr, string req, string error)
            : base(hr, XEvent.Id.STATS_CODE_6,
            "Lbsvr request '" + req + "' failed. Error: " + error) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\base\statpost.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Web;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.stats.common 
{
    public abstract class StatPostIfBase 
    {
        protected bool IsComparisonTrue(byte bCompType, object val1, object val2)
        {
            // We can only compare integer and float types
            if(! (val2 is int 
                  || val2 is long
                  || val2 is double ) )
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_0,
                    "Error: Invalid type in IF statement. Only Int32, Int64 and Float are supported.");                    
            
            switch(bCompType)
            {
            case StatPostIfComparisonType.Equal:
            {
                // If database value is null, this operation will always be false.
                if(val1 == null)
                    return false;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) == ((int)val2);
                else if(val1 is long)
                    return ((long)val1) == ((long)val2);
                else if(val1 is double)
                    return ((double)val1) == ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }
            
            case StatPostIfComparisonType.NotEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be true.
                if(!val2.GetType().Equals(val1.GetType()))
                    return true;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) != ((int)val2);
                else if(val1 is long)
                    return ((long)val1) != ((long)val2);
                else if(val1 is double)
                    return ((double)val1) != ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }

            
            case StatPostIfComparisonType.Greater:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) > ((int)val2);
                else if(val1 is long)
                    return ((long)val1) > ((long)val2);
                else if(val1 is double)
                    return ((double)val1) > ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }
                
            case StatPostIfComparisonType.GreaterOrEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) >= ((int)val2);
                else if(val1 is long)
                    return ((long)val1) >= ((long)val2);
                else if(val1 is double)
                    return ((double)val1) >= ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }
            
            case StatPostIfComparisonType.Less:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) < ((int)val2);
                else if(val1 is long)
                    return ((long)val1) < ((long)val2);
                else if(val1 is double)
                    return ((double)val1) < ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }
                
            case StatPostIfComparisonType.LessOrEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;
                
                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) <= ((int)val2);
                else if(val1 is long)
                    return ((long)val1) <= ((long)val2);
                else if(val1 is double)
                    return ((double)val1) <= ((double)val2);
                else 
                    throw new Exception("Error: invalid type of val1");
            }
            
            case StatPostIfComparisonType.Exist:
            {
                return val1 != null;
            }
            
            case StatPostIfComparisonType.NotExist:
            {
                return val1 == null;
            }
                                    
            default:
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_1,
                    "Error: invalid bCompType "+bCompType);
            }
        }
    }
    
    [StatProcedure("IF", StatPostProcedure.If)]
    public class StatPostIf : StatPostIfBase, IStatProcIf
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _bCompType  = (byte) pp.GetParamInt8(2);
            _usStatId   = (ushort) pp.GetParamInt16(3);

            // Verification
            if( _bCompType < StatPostIfComparisonType.Equal 
                || _bCompType > StatPostIfComparisonType.NotEqual )
                throw new Exception("Error: Invalid Comparison Type " + _bCompType + " (parameter 3)");
                
            // Request data
            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);
            dr.RequestPlayerData(_lbUserKey, _usStatId);
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            
            
            // This is the value in the database
            object val1 = pd.PlayerStatGet(_lbUserKey, _usStatId);
            
            // This is the value from the procedure
            object val2;
            switch(pp.GetParamType(4))
            {
            case StatParam.Int32:
                val2 = (object) pp.GetParamInt32(4);
                break;
                
            case StatParam.Int64:
                val2 = (object) pp.GetParamInt64(4);
                break;
                
            case StatParam.Float:
                val2 = (object) pp.GetParamFloat(4);
                break;
                
            default:
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_2,
                    "Error: Invalid parameter type. Parameter 5 must be Int32, Int64 or Float");
            }
            
            if(IsComparisonTrue(_bCompType, val1, val2))
            {
                _fTrue = true;
            }
            else
            {
                _fTrue = false;
            }
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure If. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x")+
                "\nCompType="+_bCompType+
                "\nVal1="+(val1 != null ? val1.ToString() : "(null)")+
                "\nVal2="+(val2 != null ? val2.ToString() : "(null)")+
                "\nfTrue="+_fTrue);
            
            // Mark the procedure as processed. 
            _fProcessed = true;
        }
        
        public bool True
        {
            get
            {
                // If _fProcessed is false, this procedure hasn't been processed yet. If there is another procedure checking
                // on it, it's an error. It means that the other procedure has a dependency on this procedure but the other
                // procedure was probably listed before this procedure.
                if(!_fProcessed)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_3,
                        "Error: Procedure is specified BEFORE its dependency.");
                
                return _fTrue;
            }
        }
        
        public ulong        _ulPuid     = 0;
        public uint         _uiLbId     = 0;
        public byte         _bCompType  = 0;
        public ushort       _usStatId   = 0;
        public LbUserKey    _lbUserKey  = null;
        public bool         _fProcessed = false;
        public bool         _fTrue      = false;
    }
    
    [StatProcedure("IF_UNIT", StatPostProcedure.IfUnit)]
    public class StatPostIfUnit : StatPostIfBase, IStatProcIf
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            // Get parameters
            ulong   ulPuid1     = pp.GetParamPuid(0);
            ulong   ulPuid2     = pp.GetParamPuid(1);
            ulong   ulPuid3     = pp.GetParamPuid(2);
            ulong   ulPuid4     = pp.GetParamPuid(3);
            
            _key = new UnitMembersKey(new ulong[] {ulPuid1, ulPuid2, ulPuid3, ulPuid4});
            
            _uiLbId     = (uint) pp.GetParamInt32(4);
            _bCompType  = (byte) pp.GetParamInt8(5);
            _usStatId   = (ushort) pp.GetParamInt16(6);

            // Verification
            if( _bCompType < StatPostIfComparisonType.Equal 
                || _bCompType > StatPostIfComparisonType.NotEqual )
                throw new Exception("Error: Invalid Comparison Type " + _bCompType + " (parameter 3)");
                
            dr.RequestUnitData(_key, _uiLbId, _usStatId);
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            // This is the value in the database
            object val1 = pd.UnitStatGet(_key, _uiLbId, _usStatId);
            
            // This is the value from the procedure
            object val2;
            switch(pp.GetParamType(7))
            {
            case StatParam.Int32:
                val2 = (object) pp.GetParamInt32(7);
                break;
                
            case StatParam.Int64:
                val2 = (object) pp.GetParamInt64(7);
                break;
                
            case StatParam.Float:
                val2 = (object) pp.GetParamFloat(7);
                break;
                
            default:
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_4,
                    "Error: Invalid parameter type. Parameter 5 must be Int32, Int64 or Float");
            }
            
            if(IsComparisonTrue(_bCompType, val1, val2))
            {
                _fTrue = true;
            }
            else
            {
                _fTrue = false;
            }
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure IfUnit. lbId="+_uiLbId+" key=0x"+_key.ToString()+
                "\nCompType="+_bCompType+
                "\nVal1="+(val1 != null ? val1.ToString() : "(null)")+
                "\nVal2="+(val2 != null ? val2.ToString() : "(null)")+
                "\nfTrue="+_fTrue);
            
            // Mark the procedure as processed. 
            _fProcessed = true;
        }
        
        public bool True
        {
            get
            {
                // If _fProcessed is false, this procedure hasn't been processed yet. If there is another procedure checking
                // on it, it's an error. It means that the other procedure has a dependency on this procedure but the other
                // procedure was probably listed before this procedure.
                if(!_fProcessed)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_5,
                        "Error: Procedure is specified BEFORE its dependency.");
                
                return _fTrue;
            }
        }
        
        protected   UnitMembersKey  _key        = null;
        public      uint            _uiLbId     = 0;
        public      byte            _bCompType  = 0;
        public      ushort          _usStatId   = 0;
        public      LbUserKey       _lbUserKey  = null;
        public      bool            _fProcessed = false;
        public      bool            _fTrue      = false;
    }
    
    public abstract class StatPostDependentBase 
    {
        protected bool IsDependencyTrue(IStatPostProcParam pp, ushort usDepend)
        {
            if(usDepend != 0)
            {
                int iDependIndex = usDepend - 1;
                
                if(pp.ProcCount <= iDependIndex)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, 
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_9,
                        "Error: _usDepend > ProcCount");
                        
                IStatProcIf ifproc = pp.GetProcedure(iDependIndex) as IStatProcIf;
                
                if(ifproc == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, 
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_10,
                        "Error: _usDepend doesn't point to a conditional procedure");
                        
                // If dependency is false, don't execute.
                return ifproc.True;
            }
            else
                return true;
        }
    }
    
    [StatProcedure("REPLACE", StatPostProcedure.Replace)]
    public class StatPostReplace : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _usDepend   = (ushort) pp.GetParamInt16(2);
            
            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            LbUserKey key = new LbUserKey(_uiLbId, _ulPuid);

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Replace. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x"));

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                switch(pp.GetParamType(ndx + 1))
                {
                case StatParam.Int32:
                    int iParam = pp.GetParamInt32(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, iParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+iParam);
                    break;

                case StatParam.Int64:
                    long lParam = pp.GetParamInt64(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, lParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+lParam);
                    break;

                case StatParam.Float:
                    double dParam = pp.GetParamFloat(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, dParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+dParam);
                    break;
                
                default:
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_11, "Invalid parameter type for parameter " + ndx);
                }
            }
        }
        
        protected   ulong   _ulPuid = 0;
        protected   uint    _uiLbId = 0;
        protected   ushort  _usDepend = 0;
    }
    
    
    [StatProcedure("ADD", StatPostProcedure.Add)]
    public class StatPostAdd : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _usDepend   = (ushort) pp.GetParamInt16(2);
            
            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);
            
            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);
            
            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);
                dr.RequestPlayerData(_lbUserKey, usStatId);
            }
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Add. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x"));
            
            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                switch(pp.GetParamType(ndx + 1))
                {
                    // If Parameter type is Int32
                    case StatParam.Int32:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey, 
                            usStatId);
                        // The parameter is the delta
                        int delta = pp.GetParamInt32(ndx+1);

                        // Calculate new value                        
                        int newValue;
                        if(prev is int)
                        {
                            // Types match. Apply delta.
                            newValue = ((int)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId, 
                            newValue);
                            
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        
                        break;
                    }

                   // If Parameter type is Int64
                   case StatParam.Int64:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey,
                            usStatId);
                        // The parameter is the delta
                        long delta = pp.GetParamInt64(ndx+1);
                        
                        // Calculate new value                        
                        long newValue;
                        if(prev is long)
                        {
                            // Types match. Apply delta.
                            newValue = ((long)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId, 
                            newValue);
                        
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        
                        break;
                    }

                    // If Parameter type is Float
                    case StatParam.Float:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey,
                            usStatId);
                        // The parameter is the delta
                        double delta = pp.GetParamFloat(ndx+1);
                        
                        // Calculate new value                        
                        double newValue;
                        if(prev is double)
                        {
                            // Types match. Apply delta.
                            newValue = ((double)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId, 
                            newValue);
                        
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        
                        break;
                    }
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                            XEvent.Id.XSTATSFD_INVALID_REQUEST_12, "Invalid parameter type for parameter " + ndx);
                }
            }
        }
        
        protected   ulong       _ulPuid = 0;
        protected   uint        _uiLbId = 0;
        protected   ushort      _usDepend = 0;
        protected   LbUserKey   _lbUserKey;
    }
    
    [StatProcedure("REPLACE_UNIT", StatPostProcedure.ReplaceUnit)]
    public class StatPostReplaceUnit : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            ulong   ulPuid1     = pp.GetParamPuid(0);
            ulong   ulPuid2     = pp.GetParamPuid(1);
            ulong   ulPuid3     = pp.GetParamPuid(2);
            ulong   ulPuid4     = pp.GetParamPuid(3);
            
            _key = new UnitMembersKey(new ulong[] {ulPuid1, ulPuid2, ulPuid3, ulPuid4});

            _uiLbId      = (uint) pp.GetParamInt32(4);
            _usDepend    = (ushort) pp.GetParamInt16(5);
            
            for(int i=0; i < _key._members.Length; i++)
            {
                dr.VerifyPuidIsAuthorized(_key._members[i], _uiLbId, true);
            }
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure ReplaceUnit. lbId="+_uiLbId+" Members=0x"+_key.ToString());
            
            for(int ndx=6; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                // Replace cannot be applied to activity only add can be used to set activity
                if(usStatId == SpecialAttrib.UnitActivity)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_10,
                        "Error: REPLACE_UNIT procedure cannot be used to change unit activity.");

                switch(pp.GetParamType(ndx + 1))
                {
                case StatParam.Int32:
                    int iParam = pp.GetParamInt32(ndx+1);
                    pd.UnitStatReplace(_key, _uiLbId, usStatId, iParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+iParam);
                    break;

                case StatParam.Int64:
                    long lParam = pp.GetParamInt64(ndx+1);
                    pd.UnitStatReplace(_key, _uiLbId, usStatId, lParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+lParam);
                    break;

                case StatParam.Float:
                    double dParam = pp.GetParamFloat(ndx+1);
                    pd.UnitStatReplace(_key, _uiLbId, usStatId, dParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+dParam);
                    break;
                
                default:
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_13, "Invalid parameter type for parameter " + ndx);
                }
            }
        }
        
        protected   UnitMembersKey  _key        = null;
        protected   uint            _uiLbId     = 0;
        protected   ushort          _usDepend   = 0;
    }

    // StatPostAddUnit
    // The AddUnit procedure takes the following parameters:
    // puid1 (puid) - puid of the first member
    // puid2 (puid) - puid of the second member
    // puid3 (puid) - puid of the third member (can be zero)
    // puid4 (puid) - puid of the fourth member (can be zero)
    // depend (int16) - index of another procedure this procedure depends on
    // statId1 (int16) - Stat id of the stat to be changed
    // delta1 (variable) - Delta to be applied to the stat
    // statIdN         - Other stats to be changed   
    // deltaN
    //
    // Remarks:
    // The type of the delta must match the type of the stat in the database for
    // the delta to be applied. If the types don't match, the delta will be used
    // to *overwrite* the original stat.
    //
    [StatProcedure("ADD_UNIT", StatPostProcedure.AddUnit)]
    public class StatPostAddUnit : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            ulong   ulPuid1     = pp.GetParamPuid(0);
            ulong   ulPuid2     = pp.GetParamPuid(1);
            ulong   ulPuid3     = pp.GetParamPuid(2);
            ulong   ulPuid4     = pp.GetParamPuid(3);
            
            _key = new UnitMembersKey(new ulong[] {ulPuid1, ulPuid2, ulPuid3, ulPuid4});

            _uiLbId      = (uint) pp.GetParamInt32(4);
            _usDepend    = (ushort) pp.GetParamInt16(5);
            
            for(int i=0; i < _key._members.Length; i++)
            {
                dr.VerifyPuidIsAuthorized(_key._members[i], _uiLbId, true);
            }
                
            for(int ndx=6; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);
                dr.RequestUnitData(_key, _uiLbId, usStatId);
            }
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure AddUnit. lbId="+_uiLbId+" Members=0x"+_key.ToString());
            
            // Starting at the 7th parameter (index 6) we'll find the stat and
            // delta pairs.
            for(int ndx=6; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                switch(pp.GetParamType(ndx + 1))
                {
                    // If Parameter type is Int32
                    case StatParam.Int32:
                    {
                        // Get original stat
                        object prev = pd.UnitStatGet(_key, _uiLbId, 
                            usStatId);
                        // The parameter is the delta
                        int delta = pp.GetParamInt32(ndx+1);

                        // Calculate new value                        
                        int newValue;
                        if(prev is int)
                        {
                            // Types match. Apply delta.
                            newValue = ((int)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.UnitStatReplace(_key, _uiLbId, usStatId, 
                            newValue);
                            
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        break;
                    }

                   // If Parameter type is Int64
                   case StatParam.Int64:
                    {
                        // Get original stat
                        object prev = pd.UnitStatGet(_key, _uiLbId, 
                            usStatId);
                        // The parameter is the delta
                        long delta = pp.GetParamInt64(ndx+1);
                        
                        // Calculate new value                        
                        long newValue;
                        if(prev is long)
                        {
                            // Types match. Apply delta.
                            newValue = ((long)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.UnitStatReplace(_key, _uiLbId, usStatId, 
                            newValue);
                        
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        break;
                    }

                    // If Parameter type is Float
                    case StatParam.Float:
                    {
                        // Get original stat
                        object prev = pd.UnitStatGet(_key, _uiLbId, 
                            usStatId);
                        // The parameter is the delta
                        double delta = pp.GetParamFloat(ndx+1);
                        
                        // Calculate new value                        
                        double newValue;
                        if(prev is double)
                        {
                            // Types match. Apply delta.
                            newValue = ((double)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }
                        
                        // Update stat.
                        pd.UnitStatReplace(_key, _uiLbId, usStatId, 
                            newValue);
                        
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);
                        break;
                    }
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                            XEvent.Id.XSTATSFD_INVALID_REQUEST_14, "Invalid parameter type for parameter " + ndx);
                }
            }
        }
        
        protected   UnitMembersKey  _key        = null;
        protected   uint            _uiLbId     = 0;
        protected   ushort          _usDepend   = 0;
    }

    [StatProcedure("ELO", StatPostProcedure.Elo)]
    public class StatPostElo : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid1        = pp.GetParamPuid(0);
            _ulPuid2        = pp.GetParamPuid(1);
            _uiLbId         = (uint) pp.GetParamInt32(2);
            _usDepend       = (ushort) pp.GetParamInt16(3);
            _dMatchOutcome  = pp.GetParamFloat(4);
            _dC1            = pp.GetParamFloat(5);
            _dC2            = pp.GetParamFloat(6);
            
            _lbUserKey1     = new LbUserKey(_uiLbId, _ulPuid1);
            _lbUserKey2     = new LbUserKey(_uiLbId, _ulPuid2);
        
            // Verify parameters
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            
            if(!lbinfo.IsEloEnabled)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, 
                    XEvent.Id.XSTATSFD_INVALID_REQUEST_15,
                    "Leaderboard " + _uiLbId + " is not configured for ELO.");
            
            if(_dMatchOutcome < 0 || _dMatchOutcome > 1.0)                
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_14, 
                    "matchOutcome (parameter 4) must be between 0.0 and 1.0");
            
            if(_dC1 < 0 || _dC1 > 1.0)                
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_15, 
                    "C1 (parameter 5) must be between 0.0 and 1.0");
                
            if(_dC2 < 0 || _dC2 > 1.0)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_16, 
                    "C2 (parameter 6) must be between 0.0 and 1.0");

            dr.VerifyPuidIsAuthorized(_ulPuid1, _uiLbId, false);
            dr.VerifyPuidIsAuthorized(_ulPuid2, _uiLbId, false);
            
            if(_ulPuid1 == _ulPuid2)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_17,
                    "Error: puid1 is equal to puid2.");
            
            // Request data            
            dr.RequestPlayerData(_lbUserKey1, SpecialAttrib.Rating);
            dr.RequestPlayerData(_lbUserKey2, SpecialAttrib.Rating);
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Elo. lbId="+_uiLbId+
                " ulPuid1=0x"+_ulPuid1.ToString("x")+" ulPuid2=0x"+_ulPuid2.ToString("x"));
            
            // Get leaderboard information. It contains the parameters used in the Elo score calculation.
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);

            if(lbinfo.IsUnitLb) throw new Exception("ASSERT FAILED: lbinfo.IsUnitLb");
        
            // Get the ratings of both players. If they don't have rating yet, use the Elo_new constant specified in 
            // the leaderboard by the publisher.
            object rating1  = pd.PlayerStatGet(_lbUserKey1, SpecialAttrib.Rating);
            long   lRating1 = rating1 != null ? (long) rating1 : lbinfo.Elo_New;
            
            object rating2  = pd.PlayerStatGet(_lbUserKey2, SpecialAttrib.Rating);
            long   lRating2 = rating2 != null ? (long) rating2 : lbinfo.Elo_New;
            
            // Calculate the maximum weight of the match from the table provided by the publisher. The table contains
            // weights based on ranges of ratings. We're going to get the weight for both users and use the highest.
            int     iBucket1, iBucket2;
            long    lC1 = lbinfo.GetElo_C(lRating1, out iBucket1);
            long    lC2 = lbinfo.GetElo_C(lRating2, out iBucket2);
            long    lC  = Math.Max(lC1, lC2);
            
            // _dC1 and _dC2 can only be different when both users are in the first bucket. 
            if(_dC1 != _dC2)
            {
                if(iBucket1 != 0)
                    _dC1 = 1.0;
                    
                if(iBucket2 != 0)
                    _dC2 = 1.0;
            }
            
            // Calculate the expected outcome based on the players' ratings.
            double dExpectedOutcome1 = 1.0 / (1.0 + Math.Pow(lbinfo.Elo_E, (lRating2 - lRating1)/lbinfo.Elo_K));
            double dExpectedOutcome2 = 1.0 - dExpectedOutcome1;
            
            // Calculate the deltas. Look, they are symmetric!!!
            long lDelta1 = (long) (lC * (_dMatchOutcome - dExpectedOutcome1));
            long lDelta2 = lDelta1 * -1;
            
            // Calculated the new ratings. Apply the new deltas after being modified by C1 and C2 (specified by the 
            // game)
            long lNewRating1 = (long) (lRating1 + (_dC1 * lDelta1));
            long lNewRating2 = (long) (lRating2 + (_dC2 * lDelta2));
            
            // Update ratings
            pd.PlayerStatReplace(_lbUserKey1, SpecialAttrib.Rating, lNewRating1);
            pd.PlayerStatReplace(_lbUserKey2, SpecialAttrib.Rating, lNewRating2);
        
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, 
                "\nlRating1="+lRating1+
                "\nlRating2="+lRating2+
                "\niBucket1="+iBucket1+
                "\niBucket2="+iBucket2+
                "\nlC1="+lC1+
                "\nlC2="+lC2+
                "\nlC="+lC+
                "\ndC1="+_dC1+
                "\ndC2="+_dC2+
                "\ndExpectedOutcome1="+dExpectedOutcome1+
                "\ndExpectedOutcome2="+dExpectedOutcome2+
                "\nlDelta1="+lDelta1+
                "\nlDelta2="+lDelta2+
                "\nlNewRating1="+lNewRating1+
                "\nlNewRating2="+lNewRating2);
        }
        
        protected ulong     _ulPuid1        = 0;
        protected ulong     _ulPuid2        = 0;
        protected uint      _uiLbId         = 0;
        protected double    _dMatchOutcome  = 0;
        protected double    _dC1            = 0;
        protected double    _dC2            = 0;
        protected LbUserKey _lbUserKey1     = null;
        protected LbUserKey _lbUserKey2     = null;
        protected ushort    _usDepend       = 0;
    }

    [StatProcedure("EloUnit", StatPostProcedure.EloUnit)]
    public class StatPostEloUnit : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp, 
            IStatPostDataRequirements dr)
        {
            // Get parameters
            ulong[] members1 = new ulong[4];
            for(int i=0; i < 4; i++)
            {
                members1[i] = pp.GetParamPuid(i);
            }
            ulong[] members2 = new ulong[4];
            for(int i=0; i < 4; i++)
            {
                members2[i] = pp.GetParamPuid(i + 4);
            }
            
            _uiLbId         = (uint) pp.GetParamInt32(8);
            _usDepend       = (ushort) pp.GetParamInt16(9);
            _dMatchOutcome  = pp.GetParamFloat(10);
            _dC1            = pp.GetParamFloat(11);
            _dC2            = pp.GetParamFloat(12);
        
            _unitkey1 = new UnitMembersKey(members1);
            _unitkey2 = new UnitMembersKey(members2);
            
            // Verify parameters
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            
            if(!lbinfo.IsEloEnabled)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, 
                    XEvent.Id.XSTATSFD_INVALID_REQUEST_16,
                    "Leaderboard " + _uiLbId + " is not configured for ELO.");
            
            if(_dMatchOutcome < 0 || _dMatchOutcome > 1.0)                
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_19, 
                    "matchOutcome (parameter 4) must be between 0.0 and 1.0");
            
            if(_dC1 < 0 || _dC1 > 1.0)                
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_20, 
                    "C1 (parameter 5) must be between 0.0 and 1.0");
                
            if(_dC2 < 0 || _dC2 > 1.0)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_21, 
                    "C2 (parameter 6) must be between 0.0 and 1.0");
                
            if(_unitkey1.Equals(_unitkey2))
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_22, 
                    "Error: unitkey1 is equal to unitkey2");
                
            for(int i=0; i < _unitkey1._members.Length; i++)
                dr.VerifyPuidIsAuthorized(_unitkey1._members[i], _uiLbId, true);
                
            for(int i=0; i < _unitkey2._members.Length; i++)
                dr.VerifyPuidIsAuthorized(_unitkey2._members[i], _uiLbId, true);
                
            dr.RequestUnitData(_unitkey1, _uiLbId, SpecialAttrib.Rating);
            dr.RequestUnitData(_unitkey2, _uiLbId, SpecialAttrib.Rating);
        }
        
        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure EloUnit. lbId="+_uiLbId+
                " unitKey1=0x"+_unitkey1.ToString()+" unitKey1=0x"+_unitkey2.ToString());
            
            // Get leaderboard information. It contains the parameters used in the Elo score calculation.
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            
            if(!lbinfo.IsUnitLb) throw new Exception("ASSERT FAILED: !lbinfo.IsUnitLb");
            
            // Get the ratings of both players. If they don't have rating yet, use the Elo_new constant specified in 
            // the leaderboard by the publisher.
            object rating1  = pd.UnitStatGet(_unitkey1, _uiLbId, SpecialAttrib.Rating);
            long   lRating1 = rating1 != null ? (long) rating1 : lbinfo.Elo_New;
            
            object rating2  = pd.UnitStatGet(_unitkey2, _uiLbId, SpecialAttrib.Rating);
            long   lRating2 = rating2 != null ? (long) rating2 : lbinfo.Elo_New;
            
            // Calculate the maximum weight of the match from the table provided by the publisher. The table contains
            // weights based on ranges of ratings. We're going to get the weight for both users and use the highest.
            int     iBucket1, iBucket2;
            long    lC1 = lbinfo.GetElo_C(lRating1, out iBucket1);
            long    lC2 = lbinfo.GetElo_C(lRating2, out iBucket2);
            long    lC  = Math.Max(lC1, lC2);
            
            // _dC1 and _dC2 can only be different when both users are in the first bucket. 
            if(_dC1 != _dC2)
            {
                if(iBucket1 != 0)
                    _dC1 = 1.0;
                    
                if(iBucket2 != 0)
                    _dC2 = 1.0;
            }
            
            // Calculate the expected outcome based on the players' ratings.
            double dExpectedOutcome1 = 1.0 / (1.0 + Math.Pow(lbinfo.Elo_E, (lRating2 - lRating1)/lbinfo.Elo_K));
            double dExpectedOutcome2 = 1.0 - dExpectedOutcome1;
            
            // Calculate the deltas. Look, they are symmetric!!!
            long lDelta1 = (long) (lC * (_dMatchOutcome - dExpectedOutcome1));
            long lDelta2 = lDelta1 * -1;
            
            // Calculated the new ratings. Apply the new deltas after being modified by C1 and C2 (specified by the 
            // game)
            long lNewRating1 = (long) (lRating1 + (_dC1 * lDelta1));
            long lNewRating2 = (long) (lRating2 + (_dC2 * lDelta2));
            
            // Update ratings
            pd.UnitStatReplace(_unitkey1, _uiLbId, SpecialAttrib.Rating, lNewRating1);
            pd.UnitStatReplace(_unitkey2, _uiLbId, SpecialAttrib.Rating, lNewRating2);
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, 
                "\nlRating1="+lRating1+
                "\nlRating2="+lRating2+
                "\niBucket1="+iBucket1+
                "\niBucket2="+iBucket2+
                "\nlC1="+lC1+
                "\nlC2="+lC2+
                "\nlC="+lC+
                "\ndC1="+_dC1+
                "\ndC2="+_dC2+
                "\ndExpectedOutcome1="+dExpectedOutcome1+
                "\ndExpectedOutcome2="+dExpectedOutcome2+
                "\nlDelta1="+lDelta1+
                "\nlDelta2="+lDelta2+
                "\nlNewRating1="+lNewRating1+
                "\nlNewRating2="+lNewRating2);
        }
        
        protected UnitMembersKey _unitkey1  = null;
        protected UnitMembersKey _unitkey2  = null;
        protected ulong     _ulPuid2        = 0;
        protected uint      _uiLbId         = 0;
        protected double    _dMatchOutcome  = 0;
        protected double    _dC1            = 0;
        protected double    _dC2            = 0;
        protected LbUserKey _lbUserKey1     = null;
        protected LbUserKey _lbUserKey2     = null;
        protected ushort    _usDepend       = 0;
    }
    
    // StatPost
    // Processes the StatPost request
    public class StatPost
    {
        public StatPost(
            IStatIO         statIO,
            IStatDb         statDb,
            StatAuth        statAuth )
        {
            _statIO = statIO;
            _statDb = statDb;
            
            if(statAuth != null)
            {
                // Build hashtable with the puids that are authorized to write.
                _puidsAuthorized = new Hashtable(statAuth._puids.Length);
                for(int i=0; i < statAuth._puids.Length; i++)
                {
                    _puidsAuthorized[statAuth._puids[i]] = null;
                    
                    // Is puid being debugged?
                    StatsUtil.EnableContextDebugging(statAuth._puids[i]);
                }
                _ulMachineId = statAuth._ulMachineId;
                
                // Is puid being debugged?
                StatsUtil.EnableContextDebugging(statAuth._ulMachineId);
            }
            else
            {
                // Don't check auth.
                _puidsAuthorized = null;
                _ulMachineId = 0;
            }
        }
        
        public void Process()
        {
            try
            {
                ParseRequest();
                CreateProcControlObjects();
                BuildDataRequirements();
                ReadDatabase();
                ProcessProcedures();
                UpdateDatabase();
                RegisterPendingAttachments();
                SendResponse();
                WriteLog();
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_0,
                        "StatPost failed. Unhandled exception. Message: " + e.Message, e);
                
                try { if(_req != null) se.AppendInfo("\nReqStatPost:"+_req.ToString()); } catch(Exception){}
                if(se != e) throw se; else throw;
            }
        }
        
        // ParseRequest
        protected void ParseRequest()
        {
            BinaryReader reader  = new BinaryReader(_statIO.InputStream);
            
            try
            {
                _req = new ReqStatPost();
                _req.ReadFrom(reader);
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_17,
                        "Failed to parse StatPost request. Reason: " + e.Message, e);
                if(se != e) throw se; else throw;
            }
        
            StatsUtil.EnableContextDebugging((ulong)_req._uiTitleId);
            
            // Debug trace
            try { Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, ">>ReqStatPost:\n" + _req.ToString()); } catch {}
            
            if(_req._teamTickets != null)
            {
                ProcessTeamTickets();
            }
        }
        
        protected virtual void ProcessTeamTickets()
        {
            if(_ulMachineId != 0)
            {
                // Request came from an untrusted source (the xbox). We need to verify that each ticket is valid.
                // The ticket object will check its own signature using some information from the SG.
                
                for(int iTicket=0; iTicket < _req._teamTickets.teamTickets.Length; iTicket++)
                {
                    _req._teamTickets.teamTickets[iTicket].VerifyTicket();
                }
            }
            
            // The team tickets will provide us with valid team ids, team ids that we are allowed to write in their
            // behalf. We just need to make sure that each owner of the ticket is a authorized user. Then we can add
            // the team puids to the authorized puids table.
            for(int iTicket=0; iTicket < _req._teamTickets.teamTickets.Length; iTicket++)
            {
                ulong ulPlayer = _req._teamTickets.teamTickets[iTicket].userID;
                
                // Owner cannot be a team puid
                if(StatsUtil.IsTeamPuid(ulPlayer))
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_24, 
                        "Error: Invalid team ticket owner 0x" + ulPlayer.ToString("x"));
                        
                // Owner himself must be authorized. 
                if(!_puidsAuthorized.ContainsKey(ulPlayer))
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_25, 
                        "Error: Team ticket owner 0x" + ulPlayer.ToString("x") + " not an authorized player.");
                    
                // Add team puids to the authorized list
                for(int iTeam=0; iTeam < _req._teamTickets.teamTickets[iTicket].rgqwTeamIDs.Length; iTeam++)
                {
                    _puidsAuthorized[_req._teamTickets.teamTickets[iTicket].rgqwTeamIDs[iTeam]] = null;
                }
            }
        }
        
        protected void SetPlayerStat(
            LbUserKey       key,
            ushort          usStatId,
            object          val)
        {
            // BUGBUG: This will be called a lot. At least cache last match and avoid most of the lookup work.
                                                                            
            // Lb data is stored in memory so we can write everything in
            // batches. Check out if there is already an entry in memory for
            // this key.
            LbEntry lbEntry = (LbEntry) _playerRows[key];

            if(lbEntry == null)
            {
                // Not in memory yet. Create a new blank, write-only
                // entry.
                lbEntry = new LbEntry();
                _playerRows[key] = lbEntry;
            }
            
            lbEntry._fChanged = true;

            Stat stat = (Stat) lbEntry._stats[usStatId];
            if(stat == null)
            {
                // Stat was not in memory. Create a new blank entry.
                stat = new Stat();
                lbEntry._stats[usStatId] = stat;
            }
            
            // Check for reserved stat ids
            if((usStatId & 0x8000) != 0)
            {
                if( usStatId != SpecialAttrib.Rating &&
                    usStatId != SpecialAttrib.Nickname )
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_18,
                        "Invalid use of reserved stat ids. Reserved stat  either does not exist or is read-only."); 
                }
            }
            else
            {
                if(usStatId <= 0 || usStatId > 64)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_27,
                        "Error: attribute id equal to zero or greater than 64");
            }
            
            stat.Set(usStatId, val);
            stat._fChanged = true;
        }
        
        protected object GetPlayerStat(
            LbUserKey   lbUserKey,
            ushort      usStatId )
        {
            // Get leaderboard entry that we have in store. It must be there if all data has been correctly requested 
            // beforehand while in GetDataRequiments.
            LbEntry lbEntry = (LbEntry) _playerRows[lbUserKey];            
            
            if( lbEntry == null )
            {
                // if object is not in memory, it was not requested during the
                // GetDataRequirements call. 
                throw new Exception("ASSERT: lbEntry == null");
            }
            
            Stat stat = (Stat) lbEntry._stats[usStatId];
            if(stat == null)
            {
                // Same as before
                throw new Exception("ASSERT: stat == null");
           }
            
            return stat._val;
        }
        
        // SetUnitStat
        protected void SetUnitStat(
            UnitMembersKey  members, 
            uint            uiUnitLbId, 
            ushort          usStatId,
            object          val)
        {
            // BUGBUG: This will be called a lot. At least cache last match and avoid most of the lookup work.
            
            // Unit data is stored in memory so we can write everything in
            // batches. Check out if this unit already has an entry in memory.
            Unit unit = (Unit) _units[members];

            if(unit == null)
            {
                // Unit was not in memory. Create a new blank, write-only
                // entry.
                unit = new Unit();
                _units[members] = unit;
            }

            unit._fChanged = true;
            
            // Lazy create the LbEntry for this unit
            LbEntry unitLb = (LbEntry) unit._lbs[uiUnitLbId];
            
            if(unitLb == null)
            {
                // UnitLb not in memory. Create a new blank, write-only
                // entry.
                unitLb = new LbEntry();
                unit._lbs[uiUnitLbId] = unitLb;
            }

            unitLb._fChanged = true;
               
            Stat stat = (Stat) unitLb._stats[usStatId];
            if(stat == null)
            {
                // Stat was not in memory. Create a new blank entry.
                stat = new Stat();
                unitLb._stats[usStatId] = stat;
            }
            
            // Check for reserved stat ids
            if((usStatId & 0x8000) != 0)
            {
                if( usStatId != SpecialAttrib.Rating &&
                    usStatId != SpecialAttrib.UnitActivity )
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_19, 
                        "Invalid use of reserved stat ids. Reserved stat either does not exist or is read-only."); 
                }
            }
            else
            {
                if(usStatId <= 0 || usStatId > 64)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_29,
                        "Error: attribute id equal to zero or greater than 64");
            }
            
            if(! (val is int
                || val is long
                || val is double) )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_20, 
                    "Invalid stat type. Only LONG, LONGLONG and DOUBLE are supported.");
            }
            
            stat.Set(usStatId, val);
            stat._fChanged = true;
        }
        
        // GetUnitStat
        protected object GetUnitStat(
            UnitMembersKey  members, 
            uint            uiUnitLbId,
            ushort          usStatId )
        {
            // Get unit object
            Unit    unit    = (Unit) _units[members];
            LbEntry unitLb  = null;
            
            if(unit != null)
            {
                unitLb = (LbEntry) unit._lbs[uiUnitLbId];
            }
            
            // Get unitLb object. 
            if( unitLb == null )
            {
                // if object is not in memory, it was not requested during the
                // GetDataRequirements call. 
                throw new Exception("ASSERT FAILED: unitLb == null");
            }
            
            Stat stat = (Stat) unitLb._stats[usStatId];
            if(stat == null)
            {
                // Same as before
                throw new Exception("ASSERT FAILED: stat == null");
           }
            
            return stat._val;
        }
        
        // RequestUnitData
        protected void RequestUnitData(
            UnitMembersKey  members, 
            uint            uiUnitLbId,
            ushort          usStatId )
        {
            // This method will just create the placeholders for the data in
            // memory. Later, the database read fase will fill out the blanks.
            
            // Create, if not there already, unit object
            Unit unit = (Unit) _units[members];
            if(unit == null)
            {
                // No placeholder for this unit yet.
                unit = new Unit();
                _units[members] = unit;
            }

            // Create, if not there already, LbEntry for the unit
            LbEntry unitLb = (LbEntry) unit._lbs[uiUnitLbId];
            if(unitLb == null)
            {
                // UnitLb not in memory. Create a new blank, write-only
                // entry.
                unitLb = new LbEntry();
                unit._lbs[uiUnitLbId] = unitLb;
            }
            
            Stat stat = new Stat();
            unitLb._stats[usStatId] = stat;
        }

        // RequestUnitData
        protected void RequestPlayerData(
            LbUserKey       lbUserKey,
            ushort          usStatId )
        {
            // This method will just create the placeholders for the data in
            // memory. Later, the database read fase will fill out the blanks.
            
            // Create, if not there already, LbEntry for player/team
            LbEntry lbEntry = (LbEntry) _playerRows[lbUserKey];
            if(lbEntry == null)
            {
                // lbEntry not in memory. Create a new blank, write-only
                // entry.
                lbEntry = new LbEntry();
                _playerRows[lbUserKey] = lbEntry;
            }
            
            Stat stat = new Stat();
            lbEntry._stats[usStatId] = stat;
        }
        
        // IsPuidAuthorized
        // This is where most of the permission check happens. It will throw the right exception if a puid doesn't 
        // have the rights to write to a leaderboard id.
        protected void VerifyPuidIsAuthorized(
            ulong   ulPuid,
            uint    uiLbId,
            bool    fIsUnitLb )
        {
            ILeaderboardInfo lbInfo = _statDb.GetLbInfo(_req._uiTitleId, uiLbId);
            
            // Is request for the right type of leaderboard?
            if(lbInfo.IsUnitLb != fIsUnitLb)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, 
                XEvent.Id.XSTATSFD_INVALID_REQUEST_21, 
                    "Request writting to leaderboard "+ uiLbId + " is assuming incorrectly that fIsUnitLb = "+fIsUnitLb+
                    ". Either leaderboard configuration is incorrect (the leaderboard was supposed to be a unit "+
                    "leaderboard or not) or the game is using the wrong procedure to update the leaderboard.");
            
            // Some leaderboards require arbitration. If the request is comming from arbitration, _ulMachineId will be
            // zero.
            if(lbInfo.ReqArbitration && _ulMachineId != 0)
                throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.XSTATSFD_INVALID_REQUEST_22, 
                    "Error: leaderboard " + uiLbId + " requires arbitration ");
            
            // Is puid authorized to write?
            if(_puidsAuthorized != null && !_puidsAuthorized.ContainsKey(ulPuid))
                throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.XSTATSFD_INVALID_REQUEST_23,
                    "Puid 0x"+ulPuid.ToString("x")+" is not authorized to write to leaderboard "+uiLbId);
                    
            // Is puid a team? Is this a team only leaderboard?
            if(StatsUtil.IsTeamPuid(ulPuid) != lbInfo.IsTeam)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD, 
                    XEvent.Id.XSTATSFD_INVALID_REQUEST_24,
                    "Puid 0x"+ulPuid.ToString("x")+" is not a valid puid to be written in leaderboard " + uiLbId);
                    
        }
        
        // CreateProcControlObjects
        // Creates StatPostProcControl objects, one for each procedure call in
        // the request. These objects will be used to process the procedures.
        protected void CreateProcControlObjects()
        {
            _procs = new StatPostProcControl[_req._procs.Length];
            
            for(int iProcNdx=0; iProcNdx < _procs.Length; iProcNdx++)
            {
                MsgStatPostProcedureCall msgProcCall = _req._procs[iProcNdx];
                
                // Find the procedure by procedure id.
                IStatProc proc = _procDir.CreateProcHandler(msgProcCall._usProcId);

                // Create a "control" object for the procedure. The procedure 
                // will use this control object to get parameters, read and 
                // write stats.
                _procs[iProcNdx] = new StatPostProcControl(proc, this, 
                    msgProcCall);
            }
        }
        
        // BuildDataRequirements
        // Gather what kind of data will be needed in order to process the 
        // procedures.
        protected void BuildDataRequirements()
        {
            for(int i=0; i < _procs.Length; i++)
            {
                StatPostProcControl pc = _procs[i];

                try
                {
                    pc._proc.GetDataRequirements((IStatPostProcParam)pc,
                        (IStatPostDataRequirements)pc);
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_1,
                            "GetDataRequirements failed. Reason: " + e.Message, e);
                    
                    try { se.AppendInfo("current proc index: "+i); } catch(Exception){}
                    if(se != e) throw se; else throw;
                }
            }
        }

        // ReadDatabase
        // Read data required during BuildDataRequirements. Read it from the
        // database.
        protected void ReadDatabase()
        {
            // Create a Read request and specify all the data we want to read.
            // Start with units            
            IStatDbRead statDbRead = _statDb.CreateStatReadWithoutReadLimit(this._req._uiTitleId, StatsConfig.EnableCertificationMode);
            
            foreach(DictionaryEntry unitDicEntry in _units)
            {
                UnitMembersKey members = (UnitMembersKey) unitDicEntry.Key;
                Unit unit = (Unit) unitDicEntry.Value;
                
                foreach(DictionaryEntry lbDicEntry in unit._lbs)
                {
                    uint uiLbId = (uint)lbDicEntry.Key;
                    LbEntry lbEntry = (LbEntry)lbDicEntry.Value;
                    ushort[] statIds = new ushort[lbEntry._stats.Count];
                    lbEntry._stats.Keys.CopyTo(statIds, 0);
                    statDbRead.RequestDataForUnit(members, uiLbId, statIds);
                }
            }

            // Players and teams            
            foreach(DictionaryEntry dicEntry in _playerRows)
            {
                LbUserKey   lbUserKey   = (LbUserKey) dicEntry.Key;
                LbEntry     lbEntry     = (LbEntry) dicEntry.Value;
                
                ushort[] statIds = new ushort[lbEntry._stats.Count];
                lbEntry._stats.Keys.CopyTo(statIds, 0);
                statDbRead.RequestDataForUser(lbUserKey, statIds, true);
            }
            
            // Process the request. Create a callback object that will process
            // the data the way we want as IStatDbRead reads the data.
            statDbRead.Process(new StatDbReadCallback(this));
        }
        
        // ProcessProcedures
        protected void ProcessProcedures()
        {
            for(int i=0; i < _procs.Length; i++)
            {
                StatPostProcControl pc = _procs[i];
                
                try
                {
                    pc._proc.Process((IStatPostProcParam)pc, (IStatPostData)pc);
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_2,
                            "Process failed. Reason: " + e.Message, e);
                    
                    try { se.AppendInfo("current proc index: "+i); } catch(Exception){}
                    if(se != e) throw se; else throw;
                }
            }
        }
        
        // UpdateDatabase
        protected void UpdateDatabase()
        {
            // Create a new database stat update object
            IStatDbStatUpdate update = _statDb.CreateStatUpdate(
                this._req._uiTitleId, DateTime.Now.AddHours(1), StatsConfig.EnableCertificationMode);

            // Enumerate all units in memory
            foreach(DictionaryEntry unitEntry in _units)
            {
                UnitMembersKey members = (UnitMembersKey) unitEntry.Key;
                Unit unit = (Unit) unitEntry.Value;

                if(!unit._fChanged)
                    continue;
                
                update.UnitStart(members);
                
                // And all leaderboard entries in each unit
                foreach(DictionaryEntry lbDicEntry in unit._lbs)
                {
                    uint uiUnitLbId = (uint) lbDicEntry.Key;
                    LbEntry lbEntry = (LbEntry) lbDicEntry.Value;
                    
                    if(!lbEntry._fChanged)
                        continue;
                    
                    update.UnitLbStart(uiUnitLbId);

                    // and all stats in each leaderboard entry
                    foreach(DictionaryEntry statDicEntry in lbEntry._stats)
                    {
                        ushort usStatId = (ushort) statDicEntry.Key;
                        Stat   stat     = (Stat) statDicEntry.Value;
                        
                        if(!stat._fChanged)
                            continue;

                        update.UnitUpdateStat(usStatId, stat._val);
                    }
                }
            }
            
            // Enumerate all player lb entries in memory
            foreach(DictionaryEntry lbDicEntry in _playerRows)
            {
                LbUserKey lbUserKey = (LbUserKey) lbDicEntry.Key;
                LbEntry lbEntry = (LbEntry) lbDicEntry.Value;
                
                if(!lbEntry._fChanged)
                    continue;
                    
                update.PlayerLbStart(lbUserKey);
                
                foreach(DictionaryEntry statDicEntry in lbEntry._stats)
                {
                    ushort usStatId = (ushort) statDicEntry.Key;
                    Stat   stat     = (Stat) statDicEntry.Value;
                    
                    if(!stat._fChanged)
                        continue;

                    update.PlayerUpdateStat(usStatId, stat._val);
                }
            }

            // process database changes
            StatDbStatUpdateCallback callback = new StatDbStatUpdateCallback();
            update.Process((IStatDbStatUpdateCallback)callback); 
            
            if(callback._refs.Count > 0)
            {
                // Only register attachments if this request is comming from an XBOX. If the request is comming from
                // arbitration, there is no single user that can be attached to the token and there is no client to
                // receive the signed token.
                
                if(_ulMachineId != 0) // _ulMachineId 0 means arbitrated request or auth is turned off 
                    _attachRefs = callback._refs;
            }
        }
        
        protected void RegisterPendingAttachments()
        {
            if(_attachRefs == null)
                return;
            
            ArrayList refsFinal = new ArrayList(_attachRefs.Count);
            
            // The attachment shall go under the puid of the first reference
            _attachPuid = ((RepSetDataReference)_attachRefs[0])._ulUser;
            
            // Create a new name for the attachment
            _attachPathName  = "//" + ProtocolConstant.AttachStorageDomain + 
                "/u:" + _attachPuid.ToString("x") + "/" + _req._uiTitleId.ToString("x") + "/" + 
                Guid.NewGuid().ToString();
            
            // Register attachments in the database
            _uiAttachMaxSize = uint.MaxValue;
            foreach(RepSetDataReference rf in _attachRefs)
            {
                uint uiMaxAttSize;
                try
                {
                    _statDb.RegisterPendingAttachment(_req._uiTitleId, rf._uiLb, rf._ulUser, 
                        _attachPathName, out uiMaxAttSize);
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.STATS_CODE_3, e, 
                        "Pathname: {0}\r\nReference: {1}", _attachPathName, rf.ToString()
                    );
                    // We can't return an error because we have already committed
                    // the stuff to the database. We also can't return this 
                    // reference so we'll have to skip it. Sucks but it's better
                    // than nothing.
                    continue;
                }
                
                // Consolidate max att size. The smallest wins.
                if(uiMaxAttSize < _uiAttachMaxSize)
                    _uiAttachMaxSize = uiMaxAttSize; 
                
                refsFinal.Add(rf);
            }
            
            _attachRefs = refsFinal;            
        }
        
        protected void SendResponse()
        {
            if(_attachRefs == null || _attachRefs.Count == 0)
            {
                // No attachment. No response body.
                _statIO.SetXErr(_req._uiTitleId, HResult.S_OK);
                
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "No attachment. hr = S_OK.");
            }
            else
            {
                // Prepare response.
                RepSetDataCanUploadAtt rep  = new RepSetDataCanUploadAtt();
                
                // Access token
                rep._accessToken            = new Storage.WriteFileToken();
                rep._accessToken._operation = (ushort) Storage.Operation.FileWrite;
                rep._accessToken._serviceId = (ushort) XOService.Stats;
                rep._accessToken._flags     = 0;
                rep._accessToken._userPuid  = _attachPuid;
                rep._accessToken._xboxPuid  = _ulMachineId;
                rep._accessToken._pathName  = _attachPathName;
                rep._accessToken._tokenExpirationDate = 0;
                rep._accessToken._fileExpirationDate  = 0;
                rep._accessToken._maxFileSize = _uiAttachMaxSize;
                rep._accessToken._signature = null;
                
                // Add the references
                rep._refs = (RepSetDataReference[])_attachRefs.ToArray(typeof(RepSetDataReference));
                
                // Sign the access token
                bool fSucceeded = false;
                
                try
                {
                    rep._accessToken.SignOnBehalf(XOService.Stats);
                    fSucceeded = true;
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.STATS_COMM_1, e,
                        "Failed to sign the access token. " +
                        "\nReqStatPost: " + _req +
                        "\nRepSetDataCanUploadAtt: "+rep.ToString());
                    
                    // Sign process failed. However we can't return an error to the client because
                    // the stats transaction has already been commited. We'll just return S_OK 
                    // instead of the expected S_STAT_CAN_UPLOAD_ATTACHMENT.
                    
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_WARNING, "Failed to sign access token. More details in the NT event log.");
                }
                
                if(fSucceeded)
                {
                    // Send the response
                    _statIO.SetXErr(_req._uiTitleId, HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT);
                    rep.WriteTo(new BinaryWriter(_statIO.OutputStream));
                    
                    try { Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepSetDataCanUploadAtt:\n"+rep.ToString()); } catch {}
                }
                else
                {
                    _statIO.SetXErr(_req._uiTitleId, HResult.S_OK);
                }
            }
        }
        
        protected void WriteLog()
        {
            StringBuilder logentry = new StringBuilder(
                "STATPOST"+
                "|"+_req._uiTitleId.ToString("x")+
                "|"+(_attachPathName != null ? _attachPathName : "")+
                "|"+_req._usProcCount.ToString("x"));
                
            foreach(DictionaryEntry unitentry in _units)
            {
                UnitMembersKey members = (UnitMembersKey) unitentry.Key;
                
                Unit unit = (Unit)unitentry.Value;
                
                string strmembers = 
                    (members._members.Length >= 1 ? members._members[0].ToString("x16") : "")+
                    (members._members.Length >= 2 ? members._members[1].ToString("x16") : "")+
                    (members._members.Length >= 3 ? members._members[2].ToString("x16") : "")+
                    (members._members.Length >= 4 ? members._members[3].ToString("x16") : "");
                
                foreach(DictionaryEntry unitLbEntry in unit._lbs)
                {
                    uint uiLbId = (uint) unitLbEntry.Key;
                    LbEntry lbEntry = (LbEntry) unitLbEntry.Value;
                    
                    if(lbEntry._fChanged)
                    {
                        Stat rating = (Stat) lbEntry._stats[SpecialAttrib.Rating];
                        
                        logentry.Append(
                            "|"+uiLbId.ToString("x")+
                            "|"+strmembers+
                            "|"+(rating != null ? ((long)rating._val).ToString("x") : "")+
                            "|"+lbEntry._stats.Count.ToString("x"));
                    }
                }
            }


            foreach(DictionaryEntry lbEntry in _playerRows)
            {
                LbUserKey lbUserKey = (LbUserKey) lbEntry.Key;
                LbEntry lbrow = (LbEntry) lbEntry.Value;
                
                if(lbrow._fChanged)
                {
                    Stat rating = (Stat) lbrow._stats[SpecialAttrib.Rating];
                    
                    logentry.Append(
                        "|"+lbUserKey.leaderBoardType.ToString("x")+
                        "|"+lbUserKey.userId.ToString("x")+
                        "|"+(rating != null ? ((long)rating._val).ToString("x") : "")+
                        "|"+lbrow._stats.Count.ToString("x"));
                }
            }
            
            Xom.Log(XomAreaName.statslog, logentry.ToString());
        }

        protected StatPostProcControl[] _procs = null;
        protected IStatIO     _statIO;
        protected IStatDb     _statDb;
        protected Hashtable   _puidsAuthorized;
        protected ulong       _ulMachineId;
        protected ReqStatPost _req              = null;
        protected Hashtable   _units            = new Hashtable(); // BUGBUG: use data requirements to estimate size of hashtable
        protected Hashtable   _playerRows       = new Hashtable(); // BUGBUG: use data requirements to estimate size of hashtable
        protected ArrayList   _attachRefs       = null;
        protected ulong       _attachPuid       = 0;
        protected string      _attachPathName   = null;
        protected uint        _uiAttachMaxSize  = 0;
        
        static protected StatProcedureDirectory _procDir = new StatProcedureDirectory();
        
        // StatDbStatUpdateCallback
        // Callback to IStatDbStatUpdate.Update. 
        protected class StatDbStatUpdateCallback : IStatDbStatUpdateCallback
        {
            public void OnQualifyForAttachment(uint uiLbId, ulong ulPuid)
            {
                RepSetDataReference rf = new RepSetDataReference();
                rf._uiLb = uiLbId;
                rf._ulUser = ulPuid;
                _refs.Add(rf);
            }
            
            public ArrayList _refs = new ArrayList(5);
        }
        
        // StatDbReadCallback
        // This is the callback used in ReadDatabase to process the data as it's
        // being read from the database.
        protected class StatDbReadCallback : IStatDbReadCallback
        {
            public StatDbReadCallback(StatPost statPost)
            {
                _statPost = statPost;
            }
            
            public void OnUnitLbEntry(
                UnitMembersKey  members, 
                uint            uiLbId )
            {
                // We're about to receive stats for a specific unit. Search for
                // the unit object and leave it around for the next callback
                // calls.
                
                _unit = (Unit) _statPost._units[members];
                if(_unit == null)
                    throw new Exception("ASSERT FAILED: _unit == null");
                    
                _lbEntry = (LbEntry) _unit._lbs[uiLbId];
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");
            }
            
            public void OnUnitStat(
                ushort usStatId, 
                object val)
            {
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");
                    
                Stat stat = (Stat) _lbEntry._stats[usStatId];
                if(stat != null)
                    stat.Set(usStatId, val);
            }
            
            public void OnPlayerLbEntry(ulong ulPuid, uint uiLbId)
            {
                LbUserKey lbUserKey = new LbUserKey(uiLbId, ulPuid);
                _lbEntry = (LbEntry) _statPost._playerRows[lbUserKey];
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");
            }
            
            public void OnPlayerStat(ushort usStatId, object val)
            {
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");
                
                Stat stat = (Stat) _lbEntry._stats[usStatId];
                if(stat != null)
                    stat.Set(usStatId, val);
            }
            
            protected StatPost  _statPost;
            protected Unit      _unit       = null;
            protected LbEntry   _lbEntry    = null;
        }
        
        protected class StatPostProcControl 
            : IStatPostProcParam, IStatPostDataRequirements, IStatPostData
        {
            public StatPostProcControl(
                IStatProc                   proc,
                StatPost                    statPost, 
                MsgStatPostProcedureCall    msgProcCall )
            {
                _proc           = proc;
                _statPost       = statPost;
                _msgProcCall    = msgProcCall;
            }

            // IStatPostProcParam.ParamCount
            public int ParamCount
            {
                get { return _msgProcCall._params.Length; }
            }

            // IStatPostProcParam.ProcCount
            public int ProcCount
            {
                get { return _statPost._procs.Length; }
            }
            
            protected MsgStatPostParameter GetParam(int index)
            {
                if(index > _msgProcCall._params.Length)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS, XEvent.Id.XSTATSFD_INVALID_REQUEST_25,
                        "Parameter "+index+" expected (index is zero-based).");
                }

                return _msgProcCall._params[index];
            }
            
            // IStatPostProcParam.GetParamInt8
            public byte GetParamInt8(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                if(param._bParamType != StatParam.Int8)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_26,
                        "Parameter "+index+" expected to be Int8.");
                }
                return (byte)param._data;
            }

            // IStatPostProcParam.GetParamInt16
            public short GetParamInt16(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Int16)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_27,
                        "Parameter "+index+" expected to be Int16.");
                }
                                
                return (short)param._data;
            }

            // IStatPostProcParam.GetParamInt32
            public int GetParamInt32(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Int32)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_28,
                        "Parameter "+index+" expected to be Int32.");
                }
                                
                return (int)param._data;
            }

            // IStatPostProcParam.GetParamInt64
            public long GetParamInt64(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Int64)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_29,
                        "Parameter "+index+" expected to be Int64.");
                }
                                        
                return (long)param._data;
            }
    
            // IStatPostProcParam.GetParamFloat
            public double GetParamFloat(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Float)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_30,
                        "Parameter "+index+" expected to be Float.");
                }
                    
                return (double)param._data;
            }

            // IStatPostProcParam.GetParamUtf8String
            public string GetParamUtf8String(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Utf8string)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_31,
                        "Parameter "+index+" expected to be Utf8string.");
                }
                                        
                return (string)param._data;
            }

            // IStatPostProcParam.GetParamPuid
            public ulong GetParamPuid(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                
                if(param._bParamType != StatParam.Puid)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_32,
                        "Parameter "+index+" expected to be Int64.");
                }
                
                return (ulong)param._data;
            }

            // IStatPostProcParam.GetParamType
            public byte GetParamType(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                return (byte) param._bParamType;
            }
            
            // IStatPostProcParam.GetProcedure
            public IStatProc GetProcedure(
                int index)
            {
                return _statPost._procs[index]._proc;
            }
            
            // IStatPostData.UnitStatReplace
            public void UnitStatReplace(
                UnitMembersKey  members, 
                uint            uiUnitLbId,
                ushort          usStatId,
                object          val)
            {
                _statPost.SetUnitStat(members, uiUnitLbId, usStatId, val);
            }
            
            // IStatPostData.UnitStatGet
            public object UnitStatGet(
                UnitMembersKey  members,
                uint            uiUnitLbId,
                ushort          usStatId )
            {
                return _statPost.GetUnitStat(members, uiUnitLbId, usStatId);
            }

        
            // IStatPostData.PlayerStatReplace
            public void PlayerStatReplace(
                LbUserKey       key,
                ushort          usStatId,
                object          val)
            {
                _statPost.SetPlayerStat(key, usStatId, val);
            }

            // IStatPostData.PlayerStatGet
            public object PlayerStatGet(
                LbUserKey       lbUserKey,
                ushort          usStatId)
            {
                return _statPost.GetPlayerStat(lbUserKey, usStatId);
            }
            
            // IStatPostData.GetLeaderboardInfo
            public ILeaderboardInfo GetLeaderboardInfo(uint uiLbId)
            {
                return _statPost._statDb.GetLbInfo(_statPost._req._uiTitleId, uiLbId);
            }

            // IStatPostDataRequirements.RequestUnitData
            public void RequestUnitData(
                UnitMembersKey  members,
                uint            uiUnitLbId,
                ushort          usStatId)
            {
                _statPost.RequestUnitData(members, uiUnitLbId, usStatId);
            }
            
            // IStatPostDataRequirements.RequestPlayerData
            public void RequestPlayerData(
                LbUserKey       lbUserKey,
                ushort          usStatId)
            {
                _statPost.RequestPlayerData(lbUserKey, usStatId);
            }

            // IStatPostDataRequirements.RequestPlayerData
            public void VerifyPuidIsAuthorized(
                ulong           ulPuid,
                uint            uiLbId,
                bool            fIsUnit)
            {
                _statPost.VerifyPuidIsAuthorized(ulPuid, uiLbId, fIsUnit);
            }
            
            public  StatPost                  _statPost;
            public  MsgStatPostProcedureCall  _msgProcCall;
            public  IStatProc                 _proc;
        }
        
        // Unit
        protected class Unit
        {
            public double       _activity           = 0;
            public DateTime     _lastActivity       = DateTime.MinValue; 
            public Hashtable    _lbs                = new Hashtable(10); // BUGBUG: hardcoded
            public bool         _fActivityAvailable = false;
            public bool         _fChanged           = false;
        }

        // LbEntry
        protected class LbEntry
        {
            public Hashtable    _stats = new Hashtable(70); // BUGBUG: hardcoded
            public bool         _fChanged = false;
        }

        // Stat
        protected class Stat
        {
            public void Set(ushort usStatId, object val)
            {
                // If stat id is a reserved stat id, verify type restrictions.                
                if((usStatId & 0x8000) != 0)
                {
                    if(usStatId == SpecialAttrib.Rating)
                    {
                        if(! (val is long))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_33,
                                "Invalid type for rating. Type should be LONGLONG.");
                        }
                    }
                    else if(usStatId == SpecialAttrib.Nickname)
                    {
                        if(! (val is string))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_34,
                                "Invalid type for Nickname. Type should be LPCSTR.");
                        }
                    }
                    else if(usStatId == SpecialAttrib.UnitActivity)
                    {
                        // Effectively, val will be added to the activity. 
                        // That's the only operation supported on activity.
                        if(! (val is double))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_35,
                                "Invalid type for UnitActivity. Type should be DOUBLE.");
                        }
                    }
                    else
                    {
                        throw new XRLException(
                            HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_36,
                            "Invalid use of reserved stat ids. Reserved stat either does not exist or is read-only."); 
                    }
                }
                else
                {
                    if(! (val is int
                        || val is long
                        || val is double) )
                    {
                        throw new XRLException(
                            HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_37,
                            "Invalid stat type. Only LONG, LONGLONG and DOUBLE are supported for custom stats.");
                    }
                }
                
                _val           = val;
            }

            public object       _val        = null;
            public bool         _fChanged   = false;
        }
    }
    
    // StatProcedureDirectory
    public class StatProcedureDirectory
    {
        public StatProcedureDirectory()
        {
            // Catalog all procedures
            Type[] allTypes = Assembly.GetExecutingAssembly().GetTypes();

            string istatprocName = typeof(IStatProc).FullName;
            
            foreach( Type t in allTypes )
            {
                if( t.IsClass
                    && t.GetInterface(istatprocName) != null )
                {
                    StatProcedureAttribute attrib = 
                        (StatProcedureAttribute) t.GetCustomAttributes(
                            typeof(StatProcedureAttribute), false)[0] 
                            as StatProcedureAttribute;

                    // Add one instance to directory
                    _procs[attrib._usProcId] = t.GetConstructor(Type.EmptyTypes);
                }
            }
        }
        
        public IStatProc CreateProcHandler(ushort usProcId)
        {
            ConstructorInfo ci = (ConstructorInfo) _procs[usProcId];
            
            if(ci == null)
                throw new XRLException(
                    HResult.XONLINE_E_STAT_INVALID_PROCEDURE, XEvent.Id.XSTATSFD_INVALID_REQUEST_38,
                    "Invalid procedure id " + usProcId);
                    
            return (IStatProc) ci.Invoke(null);
        }
        
        public IStatProc this[ushort usProcId]
        {
            get { return (IStatProc)_procs[usProcId]; }
        }

        protected Hashtable _procs = new Hashtable(16);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\statget.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.protocol;

namespace xonline.server.stats.common
{
    public class StatGet
    {
        public StatGet(BinaryReader br, IStatDb statDb)
        {
            _br     = br;
            _statDb = statDb;
            _rep    = null;
        }
        
        public void Process()
        {
            try
            {
                ParseRequest();
                WriteLog(); //log as soon as the request is decoded
                PrepareResponse();
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.MC_APPLICATION_ERROR_9,
                        "Failed to process StatGet request. Unhandled exception: " + e.Message, e);
                
                try { se.AppendInfo("_req: "+ (_req == null ? "(null)" : _req.ToString())); } catch(Exception){}
                if(se != e) throw se; else throw;
            }
            
        }

        public void ProcessRequest(ReqGetData req)
        {
            // Request previously read off the wire or submited directly
            // Make it look like it does when reading from the binary reader
            _req = req;
            if(_req._messages.Length > 0)
            {
                _uiTitleId = _req._messages[0]._uiTitleId;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "ReqGetData:"+_req);
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, SGInfo.ToStr());

            // Run query
            PrepareResponse();
            WriteLog();
        }
        
        public uint TitleId
        {
            get { return _uiTitleId; }
        }
        
        public ReqGetData Request
        {
            get { return _req; }
        }
        
        public RepGetData Reply
        {
            get { return _rep; }
        }
        
        protected void ParseRequest()
        {
            try
            {
                _req = new ReqGetData();
                _req.ReadFrom(_br);
                
                if(_req._messages.Length > 0)
                    _uiTitleId = _req._messages[0]._uiTitleId;
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_41, 
                        "Failed to parse ReqGetData. Reason: " + e.Message, e);
                
                if(se != e)
                    throw se;
                else
                    throw;                        
            }
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "ReqGetData:"+_req);
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, SGInfo.ToStr());
        }
        
        protected void PrepareResponse()
        {
            if (0 >= _req._messages.Length)
            {
               throw new XRLException(HResult.XONLINE_E_STAT_READ_NO_SPEC, XEvent.Id.XSTATSFD_INVALID_REQUEST_75, 
                        "ReqGetData contains 0 MsgGetData");
            }
            
            // Prepare the response based on the request. Also prepare an index of all messages for fast access by
            // the database callback. At the same time, prepare the database request.
            _lbUserIndex = new Hashtable(_req._messages.Length);
            IStatDbRead statDbRead = _statDb.CreateStatRead(_req._messages[0]._uiTitleId, 
                Config.GetBoolSetting(Setting.stats_enableCertificationMode));
            
            _rep = new RepGetData();
            _rep._reps = new MsgRepGetData[_req._messages.Length];
            
            for(int iMsgNdx=0; iMsgNdx < _req._messages.Length; iMsgNdx++)
            {
                IndexedMsgRepGetData msg = new IndexedMsgRepGetData(this, _req._messages[iMsgNdx]);
                _rep._reps[iMsgNdx] = msg;
            
                // Add message to index
                LbUserKey key     = new LbUserKey(msg._uiLbId, msg._ulUserId);
                ArrayList msgList = (ArrayList) _lbUserIndex[key];

                if(msgList == null)
                {
                    msgList             = new ArrayList(1);
                    _lbUserIndex[key]   = (object) msgList;
                }

                msgList.Add(msg);
                
                // Request data
                statDbRead.RequestDataForUser(key, _req._messages[iMsgNdx]._attrIds, false);
            }
            
            // Process Database request
            statDbRead.Process(new StatDbReadCallback(this));
            
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepGetData:"+_rep);
        }
        
        protected void WriteLog()
        {
            StringBuilder logentry = new StringBuilder(
                "GETDATA"+
                "|"+Request._messages[0]._uiTitleId.ToString("x") );
                
            for(int i=0; i < Request._messages.Length; i++)
            {
                logentry.Append(
                    "|"+Request._messages[i]._uiLbId.ToString("x")+
                    "|"+Request._messages[i]._ulUserId.ToString("x")+
                    "|"+Request._messages[i]._uiAttrCount.ToString("x"));
            }
            
            Xom.Log(XomAreaName.statslog, logentry.ToString());
        }
        
        protected BinaryReader  _br;
        protected IStatDb       _statDb;
        protected ReqGetData    _req            = null;
        protected RepGetData    _rep            = null;
        protected Hashtable     _lbUserIndex    = null;
        protected uint          _uiTitleId      = 0;
        
        protected class IndexedMsgRepGetData : MsgRepGetData
        {
            public IndexedMsgRepGetData(StatGet parent, MsgGetData msg)
            {
                _parent = parent;
                
                _statIndex  = new Hashtable((int) msg._uiAttrCount);
                
                LbUserKey lbUserKey = new LbUserKey(msg._uiLbId, msg._ulUserId);
                
                // Fill out MsgRepGetData based on MsgGetData counterpart
                _ulUserId   = msg._ulUserId;
                _uiLbId     = msg._uiLbId;
                _attribs    = new MsgAttribData[msg._uiAttrCount];
                for(int i=0; i < _attribs.Length; i++)
                {
                    _attribs[i] = new MsgAttribData();
                    _attribs[i]._usAttrId = msg._attrIds[i];
                    _attribs[i]._bAttrType = (byte) AttrType.None;
                    _attribs[i]._value = null;
                    
                    // Index stats for fast look-up
                    try
                    {
                        _statIndex.Add(_attribs[i]._usAttrId, _attribs[i]);
                    }
                    catch
                    {
                        // Redundant stat id. It will not be filled out. That's a legacy behavior from V1.
                    }
                }
            }
            
            public Hashtable    _statIndex;
            public StatGet      _parent;
        }
        
        protected class StatDbReadCallback : IStatDbReadCallback
        {
            public StatDbReadCallback(StatGet parent)
            {
                _parent = parent;
            }
            
            public void OnUnitLbEntry(UnitMembersKey members, uint uiLbId)
            {
                throw new Exception("ASSERT FAILED: OnUnitLbEntry should not be called");
            }
            
            public void OnUnitStat(ushort usStatId, object val)
            {
                throw new Exception("ASSERT FAILED: OnUnitStat should not be called");
            }
            
            public void OnPlayerLbEntry(ulong ulPuid, uint uiLbId)
            {
                _current = (ArrayList) _parent._lbUserIndex[new LbUserKey(uiLbId, ulPuid)];
                
                if(_current == null)
                    throw new Exception("ASSERT FAILED: _current == null");  
            }
            
            public void OnPlayerStat(ushort usStatId, object val)
            {
                foreach(IndexedMsgRepGetData msg in _current)
                {
                    MsgAttribData stat = (MsgAttribData) msg._statIndex[usStatId];
                    if(stat != null)
                    {
                        if(val != null)
                        {
                            if(val is int)
                            {
                                stat._bAttrType = (byte) AttrType.Long;
                                stat._value = val;
                            }
                            else if (val is long)
                            {
                                stat._bAttrType = (byte) AttrType.LongLong;
                                stat._value = val;
                            }
                            else if (val is double)
                            {
                                stat._bAttrType = (byte) AttrType.Double;
                                stat._value = val;
                            }
                            else if(val is string)
                            {
                                stat._bAttrType = (byte) AttrType.String;
                                stat._value = val;
                            }
                            else
                                throw new Exception("ASSERT FAILED: invalid type");
                        }
                    }
                }
            }
            
            public StatGet  _parent;
            public ArrayList    _current = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\DataSerializer.cs ===
//-----------------------------------------------------------------------
// <copyright file="DataSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

namespace Microsoft.Xbox.Serialization
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Json;
    using System.Text;
    using System.Xml;

    /// <summary>
    /// Static class that provides support for serialization and deserialization of objects based on DataContract atttributes
    /// </summary>
    public static class DataSerializer
    {
        /// <summary>
        /// Default content type that should be used if none is specified by the client
        /// </summary>
        public const string ContentTypeDefault = ContentTypeApplicationJson;

        /// <summary>
        /// Expected content type when serializing into or from XML
        /// </summary>
        public const string ContentTypeApplicationXml = "application/xml";

        /// <summary>
        /// Expected content type when serializing into or from JSON
        /// </summary>
        public const string ContentTypeApplicationJson = "application/json";

        /// <summary>
        /// List of supported content types to serialize to and from
        /// </summary>
        private static string[] supportedContentTypes = new string[]
            {
                ContentTypeApplicationXml,
                ContentTypeApplicationJson
            };

        /// <summary>
        /// Gets a list of supported content types to serialize to and from
        /// </summary>
        public static string[] SupportedContentTypes 
        { 
            get 
            { 
                return supportedContentTypes; 
            } 
        }

        /// <summary>
        /// Reads a serialized object from the provided stream and returns the serialized object.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "ContentType HTTP headers are lowercase by default")]
        public static object ReadSerializedObjectFromStream(Stream stream, Encoding encoding, Type type, string contentType)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (encoding == null)
            {
                throw new ArgumentNullException("encoding");
            }

            if (type == null)
            {
                throw new ArgumentNullException("type");
            }

            if (contentType == null)
            {
                throw new ArgumentNullException("contentType");
            }

            if (encoding != Encoding.UTF8)
            {
                throw new ArgumentException(string.Format("Encoding {0} not supported", encoding), "encoding");
            }

            if (type.GetCustomAttributes(typeof(DataContractAttribute), false).Length == 0 &&
                type.GetCustomAttributes(typeof(CollectionDataContractAttribute), false).Length == 0)
            {
                throw new ArgumentException(string.Format("Type {0} does not contain a DataContractAttribute or CollectionDataContractAttribute", type), "type");
            }

            switch (contentType.ToLowerInvariant())
            {
                case ContentTypeApplicationXml:
                    return ReadSerializedXmlObjectFromStream(stream, encoding, type);

                case ContentTypeApplicationJson:
                    return ReadSerializedJsonObjectFromStream(stream, type);

                default:
                    throw new ArgumentException("The specified contentType {0} is not supported", contentType);
            }
        }

        /// <summary>
        /// Writes a given object into serialized data in the provided stream
        /// </summary>
        public static void WriteSerializedObjectToStream(Stream stream, Encoding encoding, Type type, object graph, string contentType)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            if (graph == null)
            {
                throw new ArgumentNullException("graph");
            }

            if (type == null)
            {
                throw new ArgumentNullException("type");
            }

            if (contentType == null)
            {
                throw new ArgumentNullException("contentType");
            }

            if (type.GetCustomAttributes(typeof(DataContractAttribute), false).Length == 0 &&
                type.GetCustomAttributes(typeof(CollectionDataContractAttribute), false).Length == 0)
            {
                throw new ArgumentException(string.Format("Type {0} does not contain a DataContractAttribute or CollectionDataContractAttribute", type), "type");
            }

            switch (contentType)
            {
                case ContentTypeApplicationXml:
                    WriteSerializedXmlObjectToStream(stream, type, encoding, graph);
                    break;

                case ContentTypeApplicationJson:
                    WriteSerializedJsonObjectToStream(stream, type, graph);
                    break;

                default:
                    throw new ArgumentException("The specified contentType {0} is not supported", contentType);
            }
        }

        /// <summary>
        /// Reads a serialized XML object from the provided stream
        /// </summary>
        private static object ReadSerializedXmlObjectFromStream(Stream stream, Encoding encoding, Type type)
        {
            DataContractSerializer serializer = new DataContractSerializer(type);
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.CloseInput = false;
            using (XmlDictionaryReader reader = XmlDictionaryReader.CreateDictionaryReader(XmlReader.Create(new StreamReader(stream, encoding), settings)))
            {
                return serializer.ReadObject(reader);
            }
        }

        /// <summary>
        /// Reads a serialized JSON object from the provided stream
        /// </summary>
        private static object ReadSerializedJsonObjectFromStream(Stream stream, Type type)
        {
            DataContractJsonSerializer serializer = new DataContractJsonSerializer(type);
            return serializer.ReadObject(stream);
        }

        /// <summary>
        /// Writes a given object into XML serialized data in the provided stream
        /// </summary>
        private static void WriteSerializedXmlObjectToStream(Stream stream, Type type, Encoding encoding, object graph)
        {
            DataContractSerializer serializer = new DataContractSerializer(type);
            using (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateTextWriter(stream, encoding, false))
            {
                serializer.WriteObject(writer, graph);
            }
        }

        /// <summary>
        /// Writes a given object into JSON serialized data in the provided stream
        /// </summary>
        private static void WriteSerializedJsonObjectToStream(Stream stream, Type type, object graph)
        {
            DataContractJsonSerializer serializer = new DataContractJsonSerializer(type);
            serializer.WriteObject(stream, graph);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\EnumLeaderBoard.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd
{
    // XRLEnumLB
    // HTTP handler for Enumerate leaderboard request
    public class XRLEnumLB : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            MsgEnumLB       msgEnumLB = new MsgEnumLB();
            Stream          inputStream = ctx.Request.InputStream;
            BinaryReader    reader = new BinaryReader(inputStream);
            BinaryWriterWrapper    writer = new BinaryWriterWrapper(ctx.Response.OutputStream);
            ulong           pivot;
            StatDb.EnumType enumType;
            uint            leaderboardSize;
            uint            uiAttachCount;
            uint            uiMaxAttachSize;
            uint            uiTitleId = 0;
            uint            hr = HResult.S_OK;

            // Read request
            try
            {
                msgEnumLB.ReadFrom(reader);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_REQUEST_66,
                    "Invalid message EnumLb."+
                    "\nException: " + e +
                    "\nSGInfo: " + SGInfo.ToStr());
                hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                goto lDone;
            }

            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "MsgEnumLB:"+msgEnumLB.ToString());
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "SGInfo:" + SGInfo.ToStr());

            uiTitleId = msgEnumLB._uiTitleId;

            if(Config.GetBoolSetting(Setting.stats_trackCountersPerLb))
            {
                // Track counters per leaderboard
                StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgEnumLB._uiLb].EnumLbPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgEnumLB._uiLb].EnumLbTotal.Increment();
            }

            // Set pivot
            pivot = msgEnumLB._ulPivotOrPageStart;

            // Set enum type
            if (msgEnumLB._bIsPivotUser != 0)
            {
                enumType = StatDb.EnumType.User;
            }
            else
            {
                enumType = StatDb.EnumType.Rank;

                if (pivot == 0)
                {
                    pivot = 1;
                }
            }

            StatDb db = new StatDb();
            RepEnumLB rep = new RepEnumLB();
            EnumLbCallback callback = new EnumLbCallback(rep, msgEnumLB._uiPageSize,msgEnumLB._attrIds);

            try
            {
                bool fLog = Config.GetBoolSetting(Setting.stats_enableCertificationMode) && AuthToggle.On;
                ulong ulCallerPuid = 0;

                if(fLog)
                    ulCallerPuid = SGInfo.Current.LogonUsers[0].qwUserID;

                db.EnumLeaderBoard(msgEnumLB._uiTitleId,
                                   msgEnumLB._uiLb,
                                   enumType,
                                   pivot,
                                   msgEnumLB._uiPageSize,
                                   msgEnumLB._attrIds,
                                   callback,
                                   fLog,
                                   ulCallerPuid,
                                   out leaderboardSize,
                                   out uiAttachCount,
                                   out uiMaxAttachSize);
            }
            catch(Exception e)
            {
                if(e is XRLException)
                    hr = ((XRLException)e).HResult;
                else
                    hr = HResult.XONLINE_E_STAT_ERROR;

                if(hr != HResult.XONLINE_E_STAT_USER_NOT_FOUND) // This is not really an error. Logging it would be spam.
                {
                    Xom.NtEvent(XEvent.Id.XSTATSFD_DATABASE_ERROR, "EnumLeaderBoard failed. MsgEnumLeaderBoard: {0}.", msgEnumLB.ToString());
                }

                goto lDone;
            }

            callback.PrepareResponse();
            rep._uiLbSize = leaderboardSize;

            // Write response
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, uiTitleId, HResult.S_OK);
            rep.WriteTo(writer);

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepEnumLB:"+rep.ToString());

            // Log
            string logentry =
                "ENUMLB"+
                "|"+msgEnumLB._uiTitleId.ToString("x")+
                "|"+msgEnumLB._uiLb.ToString("x")+
                "|"+msgEnumLB._ulPivotOrPageStart.ToString("x")+
                "|"+msgEnumLB._bIsPivotUser.ToString("x")+
                "|"+msgEnumLB._uiPageSize.ToString("x")+
                "|"+msgEnumLB._uiAttrCount.ToString("x")+
                "|"+rep._uiRepUserCount.ToString("x");

            Xom.Log(XomAreaName.statslog, logentry);

        lDone:

            // Update performance counters
            StatisticsCounters.Counters.EnumLbPerSecond.Increment();
            StatisticsCounters.Counters.EnumLbTotal.Increment();

            if(uiTitleId != 0)
            {
                StatisticsCounters.Counters[uiTitleId.ToString("x")].EnumLbPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")].EnumLbTotal.Increment();
            }

            if(HResult.Failed(hr))
            {
                // Write response
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, uiTitleId, hr);

                // Update performance counters
                StatisticsCounters.Counters.EnumLbFailedPerSecond.Increment();
                StatisticsCounters.Counters.EnumLbFailedTotal.Increment();

                if(uiTitleId != 0)
                {
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].EnumLbFailedPerSecond.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].EnumLbFailedTotal.Increment();
                }
            }
        }

        protected class EnumLbCallback : IStatDbEnumLbCallback
        {
            public EnumLbCallback(RepEnumLB rep, uint uiPageSize, ushort[] attrids)
            {
                _rep = rep;
                _uiPageSize = uiPageSize;
                _attrids = (ushort[]) attrids.Clone();
                Array.Sort(_attrids);

                _attrIdMap = new Hashtable(_attrids.Length);
                for(int i=0; i < _attrids.Length; i++)
                {
                    _attrIdMap.Add(_attrids[i], i);
                }

                _lbEntry = null;
                _entries = new ArrayList((int)_uiPageSize);

                _rep._uiAttrPerUser  = (uint) attrids.Length;
            }

            public void OnNewRow(ulong ulUserId, string name, long lRating, uint uiRank)
            {
                _lbEntry = new RepEnumLBUser(_attrids.Length);
                _lbEntry._ulUser = ulUserId;
                _lbEntry._uiRank = uiRank;
                _lbEntry._lRating = lRating;
                _lbEntry._xName = name;
                _lbEntry._nickname = String.Empty;

                for(int i=0; i < _attrids.Length; i++)
                {
                    _lbEntry._attribs[i] = new MsgAttribData();
                    _lbEntry._attribs[i]._usAttrId = _attrids[i];
                    _lbEntry._attribs[i]._bAttrType = (byte) AttrType.None;
                    _lbEntry._attribs[i]._value = null;
                }

                _entries.Add(_lbEntry);
            }

            public void OnAttribute(ushort usStatId, object val)
            {
                if(usStatId == SpecialAttrib.Nickname)
                {
                    _lbEntry._nickname = (string) val;
                }
                else
                {
                    object index = _attrIdMap[usStatId];

                    if(index != null)
                    {
                        int iIndex = (int) index;

                        if(_lbEntry._attribs[iIndex]._usAttrId != usStatId)
                            throw new Exception("ASSERT FAILED: _usAttrId != usStatId");

                        if(val == null)
                        {
                            _lbEntry._attribs[iIndex]._bAttrType = (byte) AttrType.None;
                            _lbEntry._attribs[iIndex]._value = val;
                        }
                        else if(val is int)
                        {
                            _lbEntry._attribs[iIndex]._bAttrType = (byte) AttrType.Long;
                            _lbEntry._attribs[iIndex]._value = val;
                        }
                        else if (val is long)
                        {
                            _lbEntry._attribs[iIndex]._bAttrType = (byte) AttrType.LongLong;
                            _lbEntry._attribs[iIndex]._value = val;
                        }
                        else if (val is double)
                        {
                            _lbEntry._attribs[iIndex]._bAttrType = (byte) AttrType.Double;
                            _lbEntry._attribs[iIndex]._value = val;
                        }
                        else if(val is string)
                        {
                            _lbEntry._attribs[iIndex]._bAttrType = (byte) AttrType.String;
                            _lbEntry._attribs[iIndex]._value = val;
                        }
                        else
                            throw new Exception("ASSERT FAILED: invalid type");
                    }
                }
            }

            public void PrepareResponse()
            {
                _rep._users = (RepEnumLBUser[]) _entries.GetRange(0, Math.Min((int)_uiPageSize, _entries.Count)).ToArray(
                    typeof(RepEnumLBUser));
                _rep._uiRepUserCount = (uint) _rep._users.Length;
            }

            public RepEnumLB _rep;
            public uint _uiPageSize;
            public ushort[] _attrids;

            public Hashtable _attrIdMap;
            public RepEnumLBUser _lbEntry;
            public ArrayList _entries;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\common\statpost.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Web;

// Bayesian ranking system
using MSRC.Ranking.LinearAlgebra;
using MSRC.Ranking.Numerics;

using MSRC.Ranking.RankingSystems;
using MSRC.Ranking;
using MSRC.Ranking.Skills;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.protocol;

namespace xonline.server.stats.common
{
    public abstract class StatPostDependentBase
    {
        protected bool IsDependencyTrue(IStatPostProcParam pp, ushort usDepend)
        {
            if(usDepend != 0)
            {
                int iDependIndex = usDepend - 1;

                if(pp.ProcCount <= iDependIndex)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_42,
                        "Error: _usDepend > ProcCount");

                IStatProcIf ifproc = pp.GetProcedure(iDependIndex) as IStatProcIf;

                if(ifproc == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_43,
                        "Error: _usDepend doesn't point to a conditional procedure");

                // If dependency is false, don't execute.
                return ifproc.True;
            }
            else
                return true;
        }
    }

    public abstract class StatPostIfBase
    {
        protected bool IsComparisonTrue(byte bCompType, object val1, object val2)
        {
            // We can only compare integer and float types
            if(! (val2 is int
                  || val2 is long
                  || val2 is double ) )
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_57,
                    "Error: Invalid type in IF statement. Only Int32, Int64 and Float are supported.");

            switch(bCompType)
            {
            case StatPostIfComparisonType.Equal:
            {
                // If database value is null, this operation will always be false.
                if(val1 == null)
                    return false;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) == ((int)val2);
                else if(val1 is long)
                    return ((long)val1) == ((long)val2);
                else if(val1 is double)
                    return ((double)val1) == ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.NotEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be true.
                if(!val2.GetType().Equals(val1.GetType()))
                    return true;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) != ((int)val2);
                else if(val1 is long)
                    return ((long)val1) != ((long)val2);
                else if(val1 is double)
                    return ((double)val1) != ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.Greater:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) > ((int)val2);
                else if(val1 is long)
                    return ((long)val1) > ((long)val2);
                else if(val1 is double)
                    return ((double)val1) > ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.GreaterOrEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) >= ((int)val2);
                else if(val1 is long)
                    return ((long)val1) >= ((long)val2);
                else if(val1 is double)
                    return ((double)val1) >= ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.Less:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) < ((int)val2);
                else if(val1 is long)
                    return ((long)val1) < ((long)val2);
                else if(val1 is double)
                    return ((double)val1) < ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.LessOrEqual:
            {
                // If database value is null, this operation will always be true.
                if(val1 == null)
                    return true;

                // If Value types are different, this operation will always be false.
                if(!val2.GetType().Equals(val1.GetType()))
                    return false;

                // Execute comparison according to type
                if(val1 is int)
                    return ((int)val1) <= ((int)val2);
                else if(val1 is long)
                    return ((long)val1) <= ((long)val2);
                else if(val1 is double)
                    return ((double)val1) <= ((double)val2);
                else
                    throw new Exception("Error: invalid type of val1");
            }

            case StatPostIfComparisonType.Exist:
            {
                return val1 != null;
            }

            case StatPostIfComparisonType.NotExist:
            {
                return val1 == null;
            }

            default:
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_58,
                    "Error: invalid bCompType "+bCompType);
            }
        }
    }

    public abstract class StatPostIfDependentBase : StatPostIfBase
    {
        protected bool IsDependencyTrue(IStatPostProcParam pp, ushort usDepend)
        {
            if(usDepend != 0)
            {
                int iDependIndex = usDepend - 1;

                if(pp.ProcCount <= iDependIndex)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_44,
                        "Error: _usDepend > ProcCount");

                IStatProcIf ifproc = pp.GetProcedure(iDependIndex) as IStatProcIf;

                if(ifproc == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_45,
                        "Error: _usDepend doesn't point to a conditional procedure");

                // If dependency is false, don't execute.
                return ifproc.True;
            }
            else
                return true;
        }
    }

    #region StatPost procedures

    /// <summary>
    /// StatPostIf
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="CompType">Comparison type (StatPostIfComparisonType)</param>
    /// <param name="StatId">Stat id (usually ordinal)</param>
    /// <param name="val2">Input value to compare</param>
    /// <returns>True or False</returns>
    /// <remarks>
    /// Conditional operator based on comparison type.
    /// </remarks>
    [StatProcedure("IF", StatPostProcedure.If)]
    public class StatPostIf : StatPostIfBase, IStatProcIf
    {
        public void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _bCompType  = (byte) pp.GetParamInt8(2);
            _usStatId   = (ushort) pp.GetParamInt16(3);

            // Verification
            if( _bCompType < StatPostIfComparisonType.Equal
                || _bCompType > StatPostIfComparisonType.NotEqual )
                throw new Exception("Error: Invalid Comparison Type " + _bCompType + " (parameter 3)");

            // Request data
            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);
            dr.RequestPlayerData(_lbUserKey, _usStatId);
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            // This is the value in the database
            object val1 = pd.PlayerStatGet(_lbUserKey, _usStatId);

            // This is the value from the procedure
            object val2;
            switch(pp.GetParamType(4))
            {
            case StatParam.Int32:
                val2 = (object) pp.GetParamInt32(4);
                break;

            case StatParam.Int64:
                val2 = (object) pp.GetParamInt64(4);
                break;

            case StatParam.Float:
                val2 = (object) pp.GetParamFloat(4);
                break;

            default:
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_61,
                    "Error: Invalid parameter type. Parameter 4 must be Int32, Int64 or Float");
            }

            if(IsComparisonTrue(_bCompType, val1, val2))
            {
                _fTrue = true;
            }
            else
            {
                _fTrue = false;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure If. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x")+
                "\nCompType="+_bCompType+
                "\nVal1="+(val1 != null ? val1.ToString() : "(null)")+
                "\nVal2="+(val2 != null ? val2.ToString() : "(null)")+
                "\nfTrue="+_fTrue);

            // Mark the procedure as processed.
            _fProcessed = true;
        }

        public bool True
        {
            get
            {
                // If _fProcessed is false, this procedure hasn't been processed yet. If there is another procedure checking
                // on it, it's an error. It means that the other procedure has a dependency on this procedure but the other
                // procedure was probably listed before this procedure.
                if(!_fProcessed)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_62,
                        "Error: Procedure is specified BEFORE its dependency.");

                return _fTrue;
            }
        }

        public ulong        _ulPuid     = 0;
        public uint         _uiLbId     = 0;
        public byte         _bCompType  = 0;
        public ushort       _usStatId   = 0;
        public LbUserKey    _lbUserKey  = null;
        public bool         _fProcessed = false;
        public bool         _fTrue      = false;
    }

    /// <summary>
    /// StatPostReplace
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="StatId">Stat ID's to replace</param>
    /// <param name="Param">Replacement value</param>
    /// <remarks>
    /// Replace current value with input value.
    /// Replacement can be conditional for a previous IF operation.
    /// Supports multiple stat id + replacment value combinations.
    /// </remarks>
    [StatProcedure("REPLACE", StatPostProcedure.Replace)]
    public class StatPostReplace : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _usDepend   = (ushort) pp.GetParamInt16(2);

            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;

            LbUserKey key = new LbUserKey(_uiLbId, _ulPuid);

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Replace. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x"));

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                switch(pp.GetParamType(ndx + 1))
                {
                case StatParam.Int32:
                    int iParam = pp.GetParamInt32(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, iParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+iParam);
                    break;

                case StatParam.Int64:
                    long lParam = pp.GetParamInt64(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, lParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+lParam);
                    break;

                case StatParam.Float:
                    double dParam = pp.GetParamFloat(ndx+1);
                    pd.PlayerStatReplace(key, usStatId, dParam);
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+" with value "+dParam);
                    break;

                default:
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_INVALID_REQUEST_46, "Invalid parameter type for parameter " + ndx);
                }
            }
        }

        protected   ulong   _ulPuid = 0;
        protected   uint    _uiLbId = 0;
        protected   ushort  _usDepend = 0;
    }

    /// <summary>
    /// StatPostAdd
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="StatId">Stat ID's to replace</param>
    /// <param name="Param">Amount to increment</param>
    /// <remarks>
    /// Increment existing value by amount of new value.
    /// Add can be conditional for a previous operation.
    /// Supports adding multiple stat id + increment value combinations.
    /// </remarks>
    [StatProcedure("ADD", StatPostProcedure.Add)]
    public class StatPostAdd : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            _ulPuid     = pp.GetParamPuid(0);
            _uiLbId     = (uint) pp.GetParamInt32(1);
            _usDepend   = (ushort) pp.GetParamInt16(2);

            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);

            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);
                dr.RequestPlayerData(_lbUserKey, usStatId);
            }
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Add. lbId="+_uiLbId+" ulPuid=0x"+_ulPuid.ToString("x"));

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                switch(pp.GetParamType(ndx + 1))
                {
                    // If Parameter type is Int32
                    case StatParam.Int32:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey,
                            usStatId);
                        // The parameter is the delta
                        int delta = pp.GetParamInt32(ndx+1);

                        // Calculate new value
                        int newValue;
                        if(prev is int)
                        {
                            // Types match. Apply delta.
                            newValue = ((int)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }

                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId,
                            newValue);

                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);

                        break;
                    }

                   // If Parameter type is Int64
                   case StatParam.Int64:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey,
                            usStatId);
                        // The parameter is the delta
                        long delta = pp.GetParamInt64(ndx+1);

                        // Calculate new value
                        long newValue;
                        if(prev is long)
                        {
                            // Types match. Apply delta.
                            newValue = ((long)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }

                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId,
                            newValue);

                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);

                        break;
                    }

                    // If Parameter type is Float
                    case StatParam.Float:
                    {
                        // Get original stat
                        object prev = pd.PlayerStatGet(_lbUserKey,
                            usStatId);
                        // The parameter is the delta
                        double delta = pp.GetParamFloat(ndx+1);

                        // Calculate new value
                        double newValue;
                        if(prev is double)
                        {
                            // Types match. Apply delta.
                            newValue = ((double)prev) + delta;
                        }
                        else
                        {
                            // Types don't match. Overwrite stat.
                            newValue = delta;
                        }

                        // Update stat.
                        pd.PlayerStatReplace(_lbUserKey, usStatId,
                            newValue);

                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x"+usStatId.ToString("x")+
                            " Prev="+(prev!=null ? prev : "(null)")+
                            " New="+newValue);

                        break;
                    }

                    default:
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                            XEvent.Id.XSTATSFD_INVALID_REQUEST_47, "Invalid parameter type for parameter " + ndx);
                }
            }
        }

        protected   ulong       _ulPuid = 0;
        protected   uint        _uiLbId = 0;
        protected   ushort      _usDepend = 0;
        protected   LbUserKey   _lbUserKey;
    }

    /// <summary>
    /// StatPostElo
    /// </summary>
    /// <param name="Puid1">User PUID 1</param>
    /// <param name="Puid2">User PUID 2</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="MatchOutcome">Between 0.0 and 1.0</param>
    /// <param name="C1">Between 0.0 and 1.0</param>
    /// <param name="C2">Between 0.0 and 1.0</param>
    /// <remarks>
    /// Calculate value using ELO algorithm
    /// </remarks>
    [StatProcedure("ELO", StatPostProcedure.Elo)]
    public class StatPostElo : StatPostDependentBase, IStatProc
    {
        public void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid1        = pp.GetParamPuid(0);
            _ulPuid2        = pp.GetParamPuid(1);
            _uiLbId         = (uint) pp.GetParamInt32(2);
            _usDepend       = (ushort) pp.GetParamInt16(3);
            _dMatchOutcome  = pp.GetParamFloat(4);
            _dC1            = pp.GetParamFloat(5);
            _dC2            = pp.GetParamFloat(6);

            _lbUserKey1     = new LbUserKey(_uiLbId, _ulPuid1);
            _lbUserKey2     = new LbUserKey(_uiLbId, _ulPuid2);

            // Verify parameters
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);

            if(!lbinfo.IsEloEnabled)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD,
                    XEvent.Id.XSTATSFD_INVALID_REQUEST_48,
                    "Leaderboard " + _uiLbId + " is not configured for ELO.");

            if(_dMatchOutcome < 0 || _dMatchOutcome > 1.0)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_66,
                    "matchOutcome (parameter 4) must be between 0.0 and 1.0");

            if(_dC1 < 0 || _dC1 > 1.0)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_67,
                    "C1 (parameter 5) must be between 0.0 and 1.0");

            if(_dC2 < 0 || _dC2 > 1.0)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_68,
                    "C2 (parameter 6) must be between 0.0 and 1.0");

            dr.VerifyPuidIsAuthorized(_ulPuid1, _uiLbId, false);
            dr.VerifyPuidIsAuthorized(_ulPuid2, _uiLbId, false);

            if(_ulPuid1 == _ulPuid2)
                throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_69,
                    "Error: puid1 is equal to puid2.");

            // Request data
            dr.RequestPlayerData(_lbUserKey1, SpecialAttrib.Rating);
            dr.RequestPlayerData(_lbUserKey2, SpecialAttrib.Rating);
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(! IsDependencyTrue(pp, _usDepend))
                return;

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Elo. lbId="+_uiLbId+
                " ulPuid1=0x"+_ulPuid1.ToString("x")+" ulPuid2=0x"+_ulPuid2.ToString("x"));

            // Get leaderboard information. It contains the parameters used in the Elo score calculation.
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);

            if(lbinfo.IsUnitLb) throw new Exception("ASSERT FAILED: lbinfo.IsUnitLb");

            // Get the ratings of both players. If they don't have rating yet, use the Elo_new constant specified in
            // the leaderboard by the publisher.
            object rating1  = pd.PlayerStatGet(_lbUserKey1, SpecialAttrib.Rating);
            long   lRating1 = rating1 != null ? (long) rating1 : lbinfo.Elo_New;

            object rating2  = pd.PlayerStatGet(_lbUserKey2, SpecialAttrib.Rating);
            long   lRating2 = rating2 != null ? (long) rating2 : lbinfo.Elo_New;

            // Calculate the maximum weight of the match from the table provided by the publisher. The table contains
            // weights based on ranges of ratings. We're going to get the weight for both users and use the highest.
            int     iBucket1, iBucket2;
            long    lC1 = lbinfo.GetElo_C(lRating1, out iBucket1);
            long    lC2 = lbinfo.GetElo_C(lRating2, out iBucket2);
            long    lC  = Math.Max(lC1, lC2);

            // _dC1 and _dC2 can only be different when both users are in the first bucket.
            if(_dC1 != _dC2)
            {
                if(iBucket1 != 0)
                    _dC1 = 1.0;

                if(iBucket2 != 0)
                    _dC2 = 1.0;
            }

            // Calculate the expected outcome based on the players' ratings.
            double dExpectedOutcome1 = 1.0 / (1.0 + Math.Pow(lbinfo.Elo_E, (lRating2 - lRating1)/lbinfo.Elo_K));
            double dExpectedOutcome2 = 1.0 - dExpectedOutcome1;

            // Calculate the deltas. Look, they are symmetric!!!
            long lDelta1 = (long) (lC * (_dMatchOutcome - dExpectedOutcome1));
            long lDelta2 = lDelta1 * -1;

            // Calculated the new ratings. Apply the new deltas after being modified by C1 and C2 (specified by the
            // game)
            long lNewRating1 = (long) (lRating1 + (_dC1 * lDelta1));
            long lNewRating2 = (long) (lRating2 + (_dC2 * lDelta2));

            // Update ratings
            pd.PlayerStatReplace(_lbUserKey1, SpecialAttrib.Rating, lNewRating1);
            pd.PlayerStatReplace(_lbUserKey2, SpecialAttrib.Rating, lNewRating2);

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW,
                "\nlRating1="+lRating1+
                "\nlRating2="+lRating2+
                "\niBucket1="+iBucket1+
                "\niBucket2="+iBucket2+
                "\nlC1="+lC1+
                "\nlC2="+lC2+
                "\nlC="+lC+
                "\ndC1="+_dC1+
                "\ndC2="+_dC2+
                "\ndExpectedOutcome1="+dExpectedOutcome1+
                "\ndExpectedOutcome2="+dExpectedOutcome2+
                "\nlDelta1="+lDelta1+
                "\nlDelta2="+lDelta2+
                "\nlNewRating1="+lNewRating1+
                "\nlNewRating2="+lNewRating2);
        }

        protected ulong     _ulPuid1        = 0;
        protected ulong     _ulPuid2        = 0;
        protected uint      _uiLbId         = 0;
        protected double    _dMatchOutcome  = 0;
        protected double    _dC1            = 0;
        protected double    _dC2            = 0;
        protected LbUserKey _lbUserKey1     = null;
        protected LbUserKey _lbUserKey2     = null;
        protected ushort    _usDepend       = 0;
    }

    /// <summary>
    /// StatPostMin
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="StatId">Stat ID's to replace</param>
    /// <param name="inVal">Input value to compare with current</param>
    /// <remarks>
    /// Updates target stat id with minimum between input value and current value
    /// Replacement can be conditional for a previous IF operation.
    /// Supports multiple stat id + input value combinations.
    /// </remarks>
    [StatProcedure("MIN", StatPostProcedure.Min)]
    public class StatPostMin : StatPostIfDependentBase, IStatProc
    {
        public void GetDataRequirements(IStatPostProcParam pp, IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid   = pp.GetParamPuid(0);
            _uiLbId   = (uint) pp.GetParamInt32(1);
            _usDepend = (ushort) pp.GetParamInt16(2);

            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);

            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);
                dr.RequestPlayerData(_lbUserKey, usStatId);
            }
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if (!IsDependencyTrue(pp, _usDepend))
            {
                return;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Min. lbId=" + _uiLbId + " ulPuid=0x" + _ulPuid.ToString("x"));

            for (int ndx=3; ndx < pp.ParamCount; ndx += 2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                // This is the value in the database
                object dbVal = pd.PlayerStatGet(_lbUserKey, usStatId);

                // This is the value from the procedure
                object inVal;

                switch(pp.GetParamType(ndx + 1))
                {
                    case StatParam.Int32:
                        inVal = (object) pp.GetParamInt32(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Int32))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to max so that MIN always works
                            dbVal = Int32.MaxValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.LessOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (int) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }

                        break;

                    case StatParam.Int64:
                        inVal = (object) pp.GetParamInt64(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Int64))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to max so that MIN always works
                            dbVal = Int64.MaxValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.LessOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (long) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }
                        break;

                    case StatParam.Float:
                        inVal = (object) pp.GetParamFloat(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Double))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to max so that MIN always works
                            dbVal = Double.MaxValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.LessOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (double) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }
                        break;

                    default:
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                            XEvent.Id.XSTATSFD_INVALID_REQUEST_49,
                            "Error: Invalid parameter type. Parameter " + ndx + " must be Int32, Int64 or Float");
                }
            }
        }

        protected ulong     _ulPuid     = 0;
        protected uint      _uiLbId     = 0;
        protected ushort    _usDepend   = 0;
        protected LbUserKey _lbUserKey;
    }

    /// <summary>
    /// StatPostMax
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="StatId">Stat ID's to replace</param>
    /// <param name="inVal">Input value to compare with current</param>
    /// <remarks>
    /// Updates target stat id with maximum between input value and current value
    /// Replacement can be conditional for a previous IF operation.
    /// Supports multiple stat id + input value combinations.
    /// </remarks>
    [StatProcedure("MAX", StatPostProcedure.Max)]
    public class StatPostMax : StatPostIfDependentBase, IStatProc
    {
        public void GetDataRequirements(IStatPostProcParam pp, IStatPostDataRequirements dr)
        {
            // Get parameters
            _ulPuid   = pp.GetParamPuid(0);
            _uiLbId   = (uint) pp.GetParamInt32(1);
            _usDepend = (ushort) pp.GetParamInt16(2);

            dr.VerifyPuidIsAuthorized(_ulPuid, _uiLbId, false);

            _lbUserKey  = new LbUserKey(_uiLbId, _ulPuid);

            for(int ndx=3; ndx < pp.ParamCount; ndx+=2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);
                dr.RequestPlayerData(_lbUserKey, usStatId);
            }
        }

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if (!IsDependencyTrue(pp, _usDepend))
            {
                return;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure Max. lbId=" + _uiLbId + " ulPuid=0x" + _ulPuid.ToString("x"));

            for (int ndx=3; ndx < pp.ParamCount; ndx += 2)
            {
                ushort usStatId = (ushort) pp.GetParamInt16(ndx);

                // This is the value in the database
                object dbVal = pd.PlayerStatGet(_lbUserKey, usStatId);

                // This is the value from the procedure
                object inVal;

                switch(pp.GetParamType(ndx + 1))
                {
                    case StatParam.Int32:
                        inVal = (object) pp.GetParamInt32(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Int32))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to min so that MAX always works
                            dbVal = Int32.MinValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.GreaterOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (int) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }

                        break;

                    case StatParam.Int64:
                        inVal = (object) pp.GetParamInt64(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Int64))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to min so that MAX always works
                            dbVal = Int64.MinValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.GreaterOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (long) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }
                        break;

                    case StatParam.Float:
                        inVal = (object) pp.GetParamFloat(ndx + 1);

                        if ((dbVal == null) || !(dbVal is Double))
                        {
                            // Either no value was there or the data type has changed
                            // Just do a replace.
                            // Fake by setting to min so that MAX always works
                            dbVal = Double.MinValue;
                        }

                        if (IsComparisonTrue(StatPostIfComparisonType.GreaterOrEqual, inVal, dbVal))
                        {
                            pd.PlayerStatReplace(_lbUserKey, usStatId, (double) inVal);
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Replacing stat 0x" + usStatId.ToString("x")
                                     + " with value " + inVal.ToString());
                        }
                        break;

                    default:
                        throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST,
                            XEvent.Id.STATS_HACK_71,
                            "Error: Invalid parameter type. Parameter " + ndx + " must be Int32, Int64 or Float");
                }
            }
        }

        protected ulong     _ulPuid     = 0;
        protected uint      _uiLbId     = 0;
        protected ushort    _usDepend   = 0;
        protected LbUserKey _lbUserKey;
    }

    /// <summary>
    /// StatPostMuSigma
    /// </summary>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="Team">User's team (0-based)</param>
    /// <param name="Rank">User's score</param>
    /// <remarks>
    /// Calculate rank using MuSigma system
    /// </remarks>
    [StatProcedure("MUSIGMA", StatPostProcedure.MuSigma)]
    public class StatPostMuSigma : StatPostMuSigmaBase
    {
        public override void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            bool authorized = false;
            string authErrorMsg = "";

            // Initialize the hashtables
            _players = new Hashtable();
            _teams   = new Hashtable();

            // Get parameters
            _uiLbId         = (uint) pp.GetParamInt32(0);
            _usDepend       = (ushort) pp.GetParamInt16(1);

            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            _titleId        = lbinfo.TitleId;

            //initialize MuSigma Params now that we know which lbid we are dealing with
            InitializeDefaultMuSigmaParams();

            // Verify parameters
            // Process list of users, teams, and rank
            for(int ndx=2; ndx < pp.ParamCount; ndx += 3)
            {
                int playerid = (ndx + 1) / 3;

                ulong puid  = pp.GetParamPuid(ndx);

                if (StatLbIdParser.IsRankedSkill(_uiLbId))
                {
                    // in ranked skil leaderboards, this must be arbitrated
                    dr.VerifyPuidIsAuthorized(puid, _uiLbId, false);
                    authorized = true;
                }

                if (StatLbIdParser.IsStandardSkill(_uiLbId) && !authorized)
                {
                    // for standard skill leaderboards, there only needs to be at
                    // least one player who matches the current auth data.
                    authorized = dr.IsPuidAuthorized(puid, _uiLbId, false, out authErrorMsg);
                }

                // Verify all the params are supplied
                if (ndx + 2 > pp.ParamCount)
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS, XEvent.Id.STATS_HACK_72,
                                           "Error: Missing parameters for PUID " + puid.ToString("x"));
                }

                // Add player key to list of users
                LbUserKey key = new LbUserKey(_uiLbId, puid);

                if (_players.ContainsValue(key))
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_73,
                                           "Error: duplicate puid is invalid.");
                }
                
                _players.Add((Int32) playerid, key);

                int  teamId = pp.GetParamInt32(ndx + 1);
                int  score  = pp.GetParamInt32(ndx + 2);
                Team team   = null;

                if (_teams.ContainsKey((Int32) teamId))
                {
                    team = (Team) _teams[teamId];
                }
                else
                {
                    _teams.Add((Int32) teamId, new Team());
                    team = (Team) _teams[teamId];
                }

                team.AddPlayer(playerid, score);

                dr.RequestPlayerData(key, SpecialAttrib.Mu);
                dr.RequestPlayerData(key, SpecialAttrib.Sigma);
                dr.RequestPlayerData(key, SpecialAttrib.GamesPlayed);
            }

            if (!authorized)
                throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_HACK_74, authErrorMsg);

        }
    }


     /// <summary>
    /// StatPostMuSigmaEx
    /// </summary>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="Depend">Dependency ordinal for proc (based on stack position)</param>
    /// <param name="Beta">Beta Override</param>
    /// <param name="Tau">Tau Override</param>
    /// <param name="DrawProbability">Draw Probability Override</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="Team">User's team (0-based)</param>
    /// <param name="Score">User's score</param>
    /// <param name="PartialPlay">User's Partial Play Override</param>
    /// <remarks>
    /// Calculate rank using MuSigmaEx system
    /// </remarks>
    [StatProcedure("MUSIGMAEX", StatPostProcedure.MuSigmaEx)]
    public class StatPostMuSigmaEx : StatPostMuSigmaBase
    {
        public const int   c_playerSkillPartialPlayShift   = 0;
        public const int   c_playerSkillLearningShift      = 16;
        public const int   c_playerSkillFlagsShift         = 48;
        public const int   c_playerSkillFlagPartialPlaySet = 0x0001;
        public const int   c_playerSkillFlagLearningSet    = 0x0002;
                    
        public override void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr)
        {
            bool authorized = false;
            string authErrorMsg = "";

            // Initialize the hashtables
            _players = new Hashtable();
            _teams   = new Hashtable();

            // Get parameters
            _uiLbId         = (uint) pp.GetParamInt32(0);
            _usDepend       = (ushort) pp.GetParamInt16(1);

            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            _titleId        = lbinfo.TitleId;

            //initialize MuSigma Params now that we know which lbid we are dealing with
            InitializeDefaultMuSigmaParams();

            //check for overrides
            if (pp.GetParamType(2) != StatParam.Null)
            {
                //overriding Beta
                m_beta = pp.GetParamFloat(2);
        
                if (BETA_MIN > m_beta || BETA_MAX < m_beta)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_BAD_BETA_OVERRIDE,
                        String.Format("Error: Invalid Beta Override value for Title 0x{0:X8} LbID 0x{1:X8}.",
                        _titleId,
                        _uiLbId));
                }
            }

            if (pp.GetParamType(3) != StatParam.Null)
            {
                //overriding TAU
                m_tau = pp.GetParamFloat(3);

                if (TAU_MIN > m_tau || TAU_MAX < m_tau)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_BAD_TAU_OVERRIDE,
                        String.Format("Error: Invalid Tau Override value for Title 0x{0:X8} LbID 0x{1:X8}.",
                        _titleId,
                        _uiLbId));
                }
            }

            if (pp.GetParamType(4) != StatParam.Null)
            {
                //overriding draw probability
                m_drawProbability = pp.GetParamFloat(4);

                if (DRAW_PROBABILITY_MIN > m_drawProbability || DRAW_PROBABILITY_MAX < m_drawProbability)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST,
                        XEvent.Id.XSTATSFD_BAD_DRAW_PROBABILITY_OVERRIDE,
                        String.Format("Error: Invalid Draw Probability Override value for Title 0x{0:X8} LbID 0x{1:X8}.",
                        _titleId,
                        _uiLbId));
                }
            }

            // Verify parameters
            // Process list of users, teams, score and partialplay
            for(int ndx=5; ndx < pp.ParamCount; ndx += 4)
            {
                int playerid = (ndx + 1) / 4;

                ulong puid  = pp.GetParamPuid(ndx);

                if (StatLbIdParser.IsRankedSkill(_uiLbId))
                {
                    // in ranked skil leaderboards, this must be arbitrated
                    dr.VerifyPuidIsAuthorized(puid, _uiLbId, false);
                    authorized = true;
                }

                if (StatLbIdParser.IsStandardSkill(_uiLbId) && !authorized)
                {
                    // for standard skill leaderboards, there only needs to be at
                    // least one player who matches the current auth data.
                    authorized = dr.IsPuidAuthorized(puid, _uiLbId, false, out authErrorMsg);
                }

                // Verify all the params are supplied
                if (ndx + 3 > pp.ParamCount)
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS, XEvent.Id.STATS_HACK_100,
                                           "Error: Missing parameters for PUID " + puid.ToString("x"));
                }

                // Add player key to list of users
                LbUserKey key = new LbUserKey(_uiLbId, puid);

                if (_players.ContainsValue(key))
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_101,
                                           "Error: duplicate puid is invalid.");
                }

                _players.Add((Int32) playerid, key);

                int  teamId = pp.GetParamInt32(ndx + 1);
                int  score  = pp.GetParamInt32(ndx + 2);
                Team team   = null;

                if (_teams.ContainsKey((Int32) teamId))
                {
                    team = (Team) _teams[teamId];
                }
                else
                {
                    _teams.Add((Int32) teamId, new Team());
                    team = (Team) _teams[teamId];
                }

                if (pp.GetParamType(ndx + 3) != StatParam.Null)
                {
                    long playerOverrides = pp.GetParamInt64(ndx + 3);

                    // There are 2 per-player TrueSkill overrides, but a limited number of
                    // parameters that can be sent in a MuSigma stats post (256).  So we
                    // pack all 2 into a single 64-bit parameter.  The format is 16 bits
                    // for each of the following, from MSB to LSB:
                    //  flags           (bits 48 - 63)
                    //  unused          (bits 32 - 47)
                    //  learning factor (bits 16 - 31)
                    //  partial play    (bits 0 - 15)

                    Int16 flags                 = (Int16)((playerOverrides >> c_playerSkillFlagsShift) & 0xFFFF);
                    Int16 skillLearningFactor   = 100;
                    Int16 partialPlayPercentage = 100;

                    if (0 != (flags & c_playerSkillFlagPartialPlaySet))
                    {
                        partialPlayPercentage = (Int16)((playerOverrides >> c_playerSkillPartialPlayShift) & 0xFFFF);

                        if (0 > partialPlayPercentage || 100 < partialPlayPercentage)
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST,
                                XEvent.Id.XSTATSFD_BAD_PARTIAL_PLAY,
                                String.Format("Error: Invalid partial play value for user 0x{0:X16}: {1}.",
                                puid,
                                partialPlayPercentage));
                        }
                    }

                    if (0 != (flags & c_playerSkillFlagLearningSet))
                    {
                        skillLearningFactor = (Int16)((playerOverrides >> c_playerSkillLearningShift) & 0xFFFF);

                        if (0 > skillLearningFactor || 100 < skillLearningFactor)
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST,
                                XEvent.Id.XSTATSFD_BAD_SKILL_LEARNING_FACTOR,
                                String.Format("Error: Invalid skill learning factor for user 0x{0:X16}: {1}.",
                                puid,
                                skillLearningFactor));
                        }
                    }

                    team.AddPlayer(playerid, score, ((double)partialPlayPercentage) / 100.0  , ((double)skillLearningFactor) / 100.0);
                }
                else
                {
                    team.AddPlayer(playerid, score);
                }

                dr.RequestPlayerData(key, SpecialAttrib.Mu);
                dr.RequestPlayerData(key, SpecialAttrib.Sigma);
                dr.RequestPlayerData(key, SpecialAttrib.GamesPlayed);
            }

            if (!authorized)
                throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_HACK_102, authErrorMsg);
        }
    }


    public abstract class StatPostMuSigmaBase : StatPostDependentBase, IStatProc
    {
        public const double  BETA             = 0.5;
        public const double  TAU              = 0.01;
        public const double  MU               = 3.0;
        public const double  SIGMA            = 1.0;

        public const double BETA_MIN = 0.25;
        public const double BETA_MAX = 5.0;
        public const double TAU_MIN  = 0.01;
        public const double TAU_MAX  = 0.05;
        public const double DRAW_PROBABILITY_MIN = 0.0;
        public const double DRAW_PROBABILITY_MAX = 0.99;

        protected double m_beta;
        protected double m_tau;
        protected double m_drawProbability;

        public void InitializeDefaultMuSigmaParams()
        {
            m_beta     = BETA;
            m_tau      = TAU;
            m_drawProbability = GetDrawProbability();
        }

        public double GetMuSigmaRating(MuSigmaSkill skill)
        {
            return ((skill.Mu - (3*skill.Sigma)) * 50/6) + 1;
        }

        public double GetDrawProbability()
        {
            uint gameModeId = StatLbIdParser.GetGameModeId(_uiLbId);
            TitleConfig tcfg = TitleConfig.GetTitle(_titleId);
            GameMode m = (GameMode)tcfg.GameModes[gameModeId];

            if (null == m)
            {
                string szMessage = String.Format("No Game Mode Found - Unable to Get Draw Probability - Title ID 0x{0:X8} LBID 0x{1:X8}", _titleId,_uiLbId);
                throw new XRLException(HResult.XONLINE_E_STAT_MUSIGMA_NO_GAME_MODE, XEvent.Id.XSTATSFD_MUSIGMA_NOT_GAME_MODE_1, szMessage );
            }

            return (double)m.DrawProbability / (double)100;
        }

        public abstract void GetDataRequirements(
            IStatPostProcParam pp,
            IStatPostDataRequirements dr);

        public void Process(IStatPostProcParam pp, IStatPostData pd)
        {
            if(!IsDependencyTrue(pp, _usDepend))
            {
                return;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Procedure MuSigma. lbId=" + _uiLbId);

            // Get leaderboard info - MuSigma engine parameters Beta, DrawProbability, Tau
            // TODO: Extend ILeaderboardInfo and metadata to have three new columns?
            ILeaderboardInfo lbinfo = pp.GetLeaderboardInfo(_uiLbId);
            object gamesPlayed = (long)0;

            try
            {
                MuSigmaRankingSystem rankingSystem = new MuSigmaRankingSystem(m_beta, m_drawProbability, m_tau);
                Game game = new Game(DateTime.Now);

                IDictionaryEnumerator enumerator = _teams.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Team team = (Team) enumerator.Value;
                    game.AddTeam(team);

                    for (int i = 0; i < team.NumberOfPlayers; i++)
                    {
                        int          playerId     = team.PlayerIDs[i];
                        LbUserKey    key          = (LbUserKey) _players[playerId];
                        object       mu           = pd.PlayerStatGet(key, SpecialAttrib.Mu);
                        object       sigma        = pd.PlayerStatGet(key, SpecialAttrib.Sigma);
                        PlayerSkills playerSkills = new PlayerSkills();

                        if (mu == null || sigma == null)
                        {
                            // Default mu and sigma
                            mu          = MU;
                            sigma       = SIGMA;
                        }

                        playerSkills.AddSkill(new MuSigmaSkill((double)mu, (double)sigma), game.Date);
                        rankingSystem.PlayerSkillsList.AddPlayerSkills(playerSkills, playerId);

                        // update the number of games playd
                        gamesPlayed  = pd.PlayerStatGet(key, SpecialAttrib.GamesPlayed);
                        if (gamesPlayed == null)
                            gamesPlayed = (long) 0;

                        pd.PlayerStatReplace(key, SpecialAttrib.GamesPlayed, ((long)gamesPlayed) + 1);

                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Read:  puid=" + key.userId.ToString("x") + "\tmu=" + (double)mu + "\tsigma=" + (double)sigma);
                    }
                }

                // Rank game and update each player's mu and sigma
                rankingSystem.Update(game);

                // Update each player's mu and sigma
                enumerator.Reset();
                while (enumerator.MoveNext())
                {
                    Team team = (Team) enumerator.Value;

                    for (int i = 0; i < team.NumberOfPlayers; i++)
                    {
                        int          playerId = team.PlayerIDs[i];
                        LbUserKey    key      = (LbUserKey) _players[playerId];
                        MuSigmaSkill skill    = (MuSigmaSkill) rankingSystem.PlayerSkillsList.GetPlayerSkills(playerId).LatestSkill;
                        double       rating   = GetMuSigmaRating(skill);
                        long         normalizedRating = (long)rating;
                        if (normalizedRating < 1)
                            normalizedRating = 1;
                        if (normalizedRating > 50)
                            normalizedRating = 50;

                        pd.PlayerStatReplace(key, SpecialAttrib.Mu,    skill.Mu);
                        pd.PlayerStatReplace(key, SpecialAttrib.Sigma, skill.Sigma);
                        pd.PlayerStatReplace(key, SpecialAttrib.Skill, (long)normalizedRating);
                        pd.PlayerStatReplace(key, SpecialAttrib.Rating,(long)(rating * 1000000.0));

                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, "Read:  puid=" + key.userId.ToString("x") + "\tmu=" + (double)skill.Mu + "\tsigma=" + (double)skill.Sigma + "\tskill=" + rating);
                    }
                }
            }
            catch (ArithmeticException ae)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW, XEvent.Id.STATS_MUSIGMA_ARITHMETIC_NAN_2 ,ae.Message);
            }
        }

        protected Hashtable _teams      = null;
        protected Hashtable _players    = null;
        protected uint      _uiLbId     = 0;
        protected ushort    _usDepend   = 0;
        protected uint      _titleId    = 0;
    }

    #endregion

    /// <summary>
    /// StatPost
    /// </summary>
    /// <remarks>
    /// Processes StatPost requests
    /// </remarks>
    public class StatPost
    {
        protected uint         _hr = HResult.S_OK;
        protected StatPostProcControl[] _procs = null;
        protected IStatIO      _statIO;
        protected IStatDb      _statDb;
        protected Hashtable    _puidsAuthorized;
        protected ulong        _ulMachineId;
        protected StatPostData _req              = null;
        protected Hashtable    _playerRows       = new Hashtable(); // BUGBUG: use data requirements to estimate size of hashtable
        protected ArrayList    _attachRefs       = null;
        protected ulong        _attachPuid       = 0;
        protected string       _attachPathName   = null;
        protected uint         _uiAttachMaxSize  = 0;
        protected string       _altSignUrl       = null;

        static protected StatProcedureDirectory _procDir = new StatProcedureDirectory();

        public StatPost(
            IStatIO         statIO,
            IStatDb         statDb,
            StatAuth        statAuth )
        {
            _statIO = statIO;
            _statDb = statDb;
            _req    = new StatPostData();

            if(statAuth != null)
            {
                // Build hashtable with the puids that are authorized to write.
                _puidsAuthorized = new Hashtable(statAuth._puids.Length);
                for(int i=0; i < statAuth._puids.Length; i++)
                {
                    _puidsAuthorized[statAuth._puids[i]] = null;

                    // Is puid being debugged?
                    StatsUtil.EnableContextDebugging(statAuth._puids[i]);
                }
                _ulMachineId = statAuth._ulMachineId;

                // Is puid being debugged?
                StatsUtil.EnableContextDebugging(statAuth._ulMachineId);
            }
            else
            {
                // Don't check auth.
                _puidsAuthorized = null;
                _ulMachineId = 0;
            }
        }


        /// <summary>
        /// Process
        /// </summary>
        /// <remarks>
        /// Execute requested leader board operators and update the database.
        /// Request parsing and responses are handled outside the process method.
        /// </remarks>
        public void Process()
        {
            try
            {
                try
                {
                    CreateProcControlObjects();
                    BuildDataRequirements();
                    ReadDatabase();
                    ProcessProcedures();
                    UpdateDatabase();
                    RegisterPendingAttachments();
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if (se == null)
                    {
                        se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_8,
                                              "StatPost failed. Unhandled exception. Message: " + e.Message, e);
                    }

                    try
                    {
                        if (_req != null) se.AppendInfo("\nReqStatPost:"+_req.ToString());
                    }
                    catch (Exception)
                    {
                    }

                    // Save the HRESULT for logging
                    _hr = se.HResult;

                    if (se != e)
                    {
                        throw se;
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            finally
            {
                try
                {
                    WriteLog();
                }
                catch
                {
                    throw;
                }
            }
        }


        /// <summary>
        /// ParseRequest
        /// </summary>
        /// <remarks>
        /// Parse ReqStatPost (Xbox) request.
        /// Puts data into StatPostData structure.
        /// </remarks>
        public void ParseRequest()
        {
            ReqStatPost reqStatPost = null;
            BinaryReader reader  = new BinaryReader(_statIO.InputStream);

            try
            {
                reqStatPost = new ReqStatPost();
                reqStatPost.ReadFrom(reader);
                _req.Set(reqStatPost);
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if (se == null)
                {
                    se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_50,
                                          "Failed to parse StatPost request. Reason: " + e.Message, e);
                }

                if (se != e)
                {
                    throw se;
                }
                else
                {
                    throw;
                }
            }

            StatsUtil.EnableContextDebugging((ulong)_req._uiTitleId);

            // Debug trace
            try
            {
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, ">>ReqStatPost:\n" + _req.ToString());
            }
            catch
            {
            }

            if(_req._teamTickets != null)
            {
                ProcessTeamTickets();
            }
        }


        /// <summary>
        /// ParseRequest
        /// </summary>
        /// <param name="req">StatsPostRequest object to parse</param>
        /// <remarks>
        /// Parse StatsPostRequest (Xenon) request
        /// Puts data into StatPostData structure
        /// </remarks>
        public void ParseRequest(StatsPostRequest req)
        {
            _req.Set(req);
            StatsUtil.EnableContextDebugging((ulong) _req._uiTitleId);

            // Debug trace
            try
            {
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, ">>StatsPostRequest:\n" + _req.ToString());
            }
            catch
            {
            }

            if(_req._teamTickets != null)
            {
                ProcessTeamTickets();
            }
        }

        protected virtual void ProcessTeamTickets()
        {
            if(_puidsAuthorized == null)
                return; // Verify auth is off. There is nothing we can do.

            if(_ulMachineId != 0)
            {
                // Request came from an untrusted source (the xbox). We need to verify that each ticket is valid.
                // The ticket object will check its own signature using some information from the SG.

                for(int iTicket=0; iTicket < _req._teamTickets.teamTickets.Length; iTicket++)
                {
                    _req._teamTickets.teamTickets[iTicket].VerifyTicket();
                }
            }

            // The team tickets will provide us with valid team ids, team ids that we are allowed to write in their
            // behalf. We just need to make sure that each owner of the ticket is a authorized user. Then we can add
            // the team puids to the authorized puids table.
            for(int iTicket=0; iTicket < _req._teamTickets.teamTickets.Length; iTicket++)
            {
                ulong ulPlayer = _req._teamTickets.teamTickets[iTicket].userID;

                // Owner cannot be a team puid
                if(StatsUtil.IsTeamPuid(ulPlayer))
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_76,
                        "Error: Invalid team ticket owner 0x" + ulPlayer.ToString("x"));

                // Owner himself must be authorized.
                if(!_puidsAuthorized.ContainsKey(ulPlayer))
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_77,
                        "Error: Team ticket owner 0x" + ulPlayer.ToString("x") + " not an authorized player.");

                // Add team puids to the authorized list
                for(int iTeam=0; iTeam < _req._teamTickets.teamTickets[iTicket].rgqwTeamIDs.Length; iTeam++)
                {
                    _puidsAuthorized[_req._teamTickets.teamTickets[iTicket].rgqwTeamIDs[iTeam]] = null;
                }
            }
        }


        /// <summary>
        /// SendResponse
        /// </summary>
        /// <remarks>
        /// Construct response to ReqStatPost request (Xbox).
        /// </remarks>
        public void SendResponse()
        {
            if(_attachRefs == null || _attachRefs.Count == 0 || !SGInfo.IsXbox())
            {
                // No attachment. No response body.
                _statIO.SetXErr(_req._uiTitleId, HResult.S_OK);

                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "No attachment. hr = S_OK.");
            }
            else
            {
                // Prepare response.
                RepSetDataCanUploadAtt rep  = new RepSetDataCanUploadAtt();

                // Access token
                rep._accessToken            = new WriteFileToken();
                rep._accessToken._operation = (ushort) Operation.FileWrite;
                rep._accessToken._serviceId = (ushort) XOService.Stats;
                rep._accessToken._flags     = 0;
                rep._accessToken._userPuid  = _attachPuid;
                rep._accessToken._xboxPuid  = _ulMachineId;
                rep._accessToken._pathName  = _attachPathName;
                rep._accessToken._tokenExpirationDate = 0;
                rep._accessToken._fileExpirationDate  = 0;
                rep._accessToken._maxFileSize = _uiAttachMaxSize;
                rep._accessToken._signature = null;

                // Add the references
                rep._refs = (RepSetDataReference[])_attachRefs.ToArray(typeof(RepSetDataReference));

                // Sign the access token
                bool fSucceeded = false;

                if(_altSignUrl != null)
                {
                    // For test purposes only, if a alternative signonbehalf
                    // url has been provided, pass it on to the access token.
                    Xom.NtEvent(XEvent.Id.STATS_CONFIG_11,
                        string.Format("Using alternate SignOnBehalf URL: {0}", _altSignUrl));

                    rep._accessToken.SetAltSignUrl(_altSignUrl);
                }

                try
                {
                    rep._accessToken.SignOnBehalf(XOService.Stats);
                    //rep._accessToken._signature = new byte[ProtocolConstants.sizeSignature];
                    fSucceeded = true;
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.STATS_COMM_3, e,
                        "Failed to sign the access token. " +
                        "\nReqStatPost: " + _req +
                        "\nRepSetDataCanUploadAtt: "+rep.ToString());

                    // Sign process failed. However we can't return an error to the client because
                    // the stats transaction has already been commited. We'll just return S_OK
                    // instead of the expected S_STAT_CAN_UPLOAD_ATTACHMENT.

                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_WARNING, "Failed to sign access token. More details in the NT event log.");
                }

                if(fSucceeded)
                {
                    // Send the response
                    _statIO.SetXErr(_req._uiTitleId, HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT);
                    rep.WriteTo(new BinaryWriterWrapper(_statIO.OutputStream));

                    try
                    {
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepSetDataCanUploadAtt:\n"+rep.ToString());
                    }
                    catch
                    {
                    }
                }
                else
                {
                    _statIO.SetXErr(_req._uiTitleId, HResult.S_OK);
                }
            }
        }


        /// <summary>
        /// SendResponse
        /// </summary>
        /// <param name="resp">StatsPostResponse object to store response</param>
        /// <remarks>
        /// Constructs a response matching StatsPostRequest (Xenon)
        /// </remarks>
        public void SendResponseXe()
        {
            if (_attachRefs == null || _attachRefs.Count == 0)
            {
                StatsPostResponse resp = new StatsPostResponse();
                resp.TitleId = _req._uiTitleId;

                XRLUtil.SetXRLResponse(_statIO.Response, XOService.Stats, HResult.S_OK, resp);

                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "No attachment. hr = S_OK.");
            }
            /// TODO: Prepare attachment response
        }

        public void WriteLog()
        {
            StringBuilder logentry = new StringBuilder(
                "STATPOST"+
                "|" + _hr.ToString("x") +
                "|" + _req._uiTitleId.ToString("x") +
                "|"+(_attachPathName != null ? _attachPathName : "")+
                "|"+_req._usProcCount.ToString("x"));

            try
            {
                foreach(DictionaryEntry lbEntry in _playerRows)
                {
                    LbUserKey lbUserKey = (LbUserKey) lbEntry.Key;
                    LbEntry lbrow = (LbEntry) lbEntry.Value;

                    if(lbrow._fChanged)
                    {
                        Stat rating = (Stat) lbrow._stats[SpecialAttrib.Rating];

                        logentry.Append(
                            "|"+lbUserKey.leaderBoardType.ToString("x")+
                            "|"+lbUserKey.userId.ToString("x")+
                            "|"+(rating != null ? ((long)rating._val).ToString("x") : "")+
                            "|"+lbrow._stats.Count.ToString("x"));
                    }
                }
            }
            catch(Exception)
            {
            }

            Xom.Log(XomAreaName.statslog, logentry.ToString());
        }


        // Set alternate XRL for signature server Sign request
        public void SetAltSignUrl(
            string altSignUrl)
        {
            _altSignUrl = altSignUrl;
        }


        protected void SetPlayerStat(
            LbUserKey       key,
            ushort          usStatId,
            object          val)
        {
            // BUGBUG: This will be called a lot. At least cache last match and avoid most of the lookup work.

            // Lb data is stored in memory so we can write everything in
            // batches. Check out if there is already an entry in memory for
            // this key.
            LbEntry lbEntry = (LbEntry) _playerRows[key];

            if(lbEntry == null)
            {
                // Not in memory yet. Create a new blank, write-only
                // entry.
                lbEntry = new LbEntry();
                _playerRows[key] = lbEntry;
            }

            lbEntry._fChanged = true;

            Stat stat = (Stat) lbEntry._stats[usStatId];
            if(stat == null)
            {
                // Stat was not in memory. Create a new blank entry.
                stat = new Stat();
                lbEntry._stats[usStatId] = stat;
            }

            // Check for reserved stat ids
            if((usStatId & 0x8000) != 0)
            {
                if( usStatId != SpecialAttrib.Rating &&
                    usStatId != SpecialAttrib.Nickname &&
                    usStatId != SpecialAttrib.AttachmentSize)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_51,
                        "Invalid use of reserved stat ids. Reserved stat  either does not exist or is read-only.");
                }
            }
            else
            {
                if(usStatId <= 0 || usStatId > 64)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_HACK_79,
                        "Error: attribute id equal to zero or greater than 64");
            }

            stat.Set(usStatId, val);
            stat._fChanged = true;
        }


        protected object GetPlayerStat(
            LbUserKey   lbUserKey,
            ushort      usStatId )
        {
            // Get leaderboard entry that we have in store. It must be there if all data has been correctly requested
            // beforehand while in GetDataRequiments.
            LbEntry lbEntry = (LbEntry) _playerRows[lbUserKey];

            if( lbEntry == null )
            {
                // if object is not in memory, it was not requested during the
                // GetDataRequirements call.
                throw new Exception("ASSERT: lbEntry == null");
            }

            Stat stat = (Stat) lbEntry._stats[usStatId];
            if(stat == null)
            {
                // Same as before
                throw new Exception("ASSERT: stat == null");
           }

            return stat._val;
        }


        protected void RequestPlayerData(
            LbUserKey       lbUserKey,
            ushort          usStatId )
        {
            // This method will just create the placeholders for the data in
            // memory. Later, the database read fase will fill out the blanks.

            // Create, if not there already, LbEntry for player/team
            LbEntry lbEntry = (LbEntry) _playerRows[lbUserKey];
            if(lbEntry == null)
            {
                // lbEntry not in memory. Create a new blank, write-only
                // entry.
                lbEntry = new LbEntry();
                _playerRows[lbUserKey] = lbEntry;
            }

            Stat stat = new Stat();
            lbEntry._stats[usStatId] = stat;
        }

        // IsPuidAuthorized
        // This is where most of the permission check happens. It will throw the right exception if a puid doesn't
        // have the rights to write to a leaderboard id.
        protected void VerifyPuidIsAuthorized(
            ulong   ulPuid,
            uint    uiLbId,
            bool    fIsUnitLb )
        {
            string msg;

            if (!IsPuidAuthorized(ulPuid, uiLbId, fIsUnitLb, out msg))
                throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_HACK_80, msg);
        }

        protected bool IsPuidAuthorized(
            ulong   ulPuid,
            uint    uiLbId,
            bool    fIsUnitLb,
            out string errorMsg )
        {
            ILeaderboardInfo lbInfo = _statDb.GetLbInfo(_req._uiTitleId, uiLbId);
            errorMsg = "";

            // Is request for the right type of leaderboard?
            if(lbInfo.IsUnitLb != fIsUnitLb)
            {
                errorMsg = "Request writting to leaderboard "+ uiLbId + " is assuming incorrectly that fIsUnitLb = "+fIsUnitLb+
                    ". Either leaderboard configuration is incorrect (the leaderboard was supposed to be a unit "+
                    "leaderboard or not) or the game is using the wrong procedure to update the leaderboard.";

                return false;
            }

            // Some leaderboards require arbitration. If the request is comming from arbitration, _ulMachineId will be
            // zero.
            if(lbInfo.ReqArbitration && _ulMachineId != 0)
            {
                errorMsg = "Error: leaderboard " + uiLbId + " requires arbitration ";
                return false;
            }

            // Is puid authorized to write?
            if(_puidsAuthorized != null && !_puidsAuthorized.ContainsKey(ulPuid))
            {
                errorMsg = "Puid 0x"+ulPuid.ToString("x")+" is not authorized to write to leaderboard "+uiLbId;
                return false;
            }

            // Is puid a team? Is this a team only leaderboard?
            if(StatsUtil.IsTeamPuid(ulPuid) != lbInfo.IsTeam)
            {
                errorMsg = "Puid 0x"+ulPuid.ToString("x")+" is not a valid puid to be written in leaderboard " + uiLbId;
                return false;
            }

            return true;
        }


        // CreateProcControlObjects
        // Creates StatPostProcControl objects, one for each procedure call in
        // the request. These objects will be used to process the procedures.
        protected void CreateProcControlObjects()
        {
            _procs = new StatPostProcControl[_req._procs.Length];

            for(int iProcNdx=0; iProcNdx < _procs.Length; iProcNdx++)
            {
                MsgStatPostProcedureCall msgProcCall = _req._procs[iProcNdx];

                // Find the procedure by procedure id.
                IStatProc proc = _procDir.CreateProcHandler(msgProcCall._usProcId);

                // Create a "control" object for the procedure. The procedure
                // will use this control object to get parameters, read and
                // write stats.
                _procs[iProcNdx] = new StatPostProcControl(proc, this,
                    msgProcCall);
            }
        }


        // BuildDataRequirements
        // Gather what kind of data will be needed in order to process the
        // procedures.
        protected void BuildDataRequirements()
        {
            for(int i=0; i < _procs.Length; i++)
            {
                StatPostProcControl pc = _procs[i];

                try
                {
                    pc._proc.GetDataRequirements((IStatPostProcParam)pc,
                        (IStatPostDataRequirements)pc);
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_9,
                            "GetDataRequirements failed. Reason: " + e.Message, e);

                    try { se.AppendInfo("current proc index: "+i); } catch(Exception){}
                    if(se != e) throw se; else throw;
                }
            }
        }

        // ReadDatabase
        // Read data required during BuildDataRequirements. Read it from the
        // database.
        protected void ReadDatabase()
        {
            // Create a Read request and specify all the data we want to read.
            // Start with units
            IStatDbRead statDbRead = _statDb.CreateStatReadWithoutReadLimit(this._req._uiTitleId,
                Config.GetBoolSetting(Setting.stats_enableCertificationMode));

            // Players and teams
            foreach(DictionaryEntry dicEntry in _playerRows)
            {
                LbUserKey   lbUserKey   = (LbUserKey) dicEntry.Key;
                LbEntry     lbEntry     = (LbEntry) dicEntry.Value;

                ushort[] statIds = new ushort[lbEntry._stats.Count];
                lbEntry._stats.Keys.CopyTo(statIds, 0);
                statDbRead.RequestDataForUser(lbUserKey, statIds, true);
            }

            // Process the request. Create a callback object that will process
            // the data the way we want as IStatDbRead reads the data.
            statDbRead.Process(new StatDbReadCallback(this));
        }

        // ProcessProcedures
        protected void ProcessProcedures()
        {
            for(int i=0; i < _procs.Length; i++)
            {
                StatPostProcControl pc = _procs[i];

                try
                {
                    pc._proc.Process((IStatPostProcParam)pc, (IStatPostData)pc);
                }
                catch (XRLException xe)
                {
                    // For XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW exception, we want
                    // to process the rest of the procedures before we throw the exception
                    if (xe.HResult == HResult.XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_MUSIGMA_ARITHMETIC_NAN_1, xe, "Current proc index: {0}", i);
                    }
                    else
                    {
                        throw;
                    }
                }
                catch(Exception e)
                {
                    XRLException xe = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_10,
                            "Process failed. Reason: " + e.Message, e);

                    xe.AppendInfo("current proc index: " +i);

                    throw xe;
                }
            }
        }

        // UpdateDatabase
        protected void UpdateDatabase()
        {
            // Create a new database stat update object
            IStatDbStatUpdate update = _statDb.CreateStatUpdate(
                this._req._uiTitleId, DateTime.Now.AddHours(1),
                Config.GetBoolSetting(Setting.stats_enableCertificationMode));

            // Enumerate all player lb entries in memory
            foreach(DictionaryEntry lbDicEntry in _playerRows)
            {
                LbUserKey lbUserKey = (LbUserKey) lbDicEntry.Key;
                LbEntry lbEntry = (LbEntry) lbDicEntry.Value;

                if(!lbEntry._fChanged)
                    continue;

                update.PlayerLbStart(lbUserKey);

                foreach(DictionaryEntry statDicEntry in lbEntry._stats)
                {
                    ushort usStatId = (ushort) statDicEntry.Key;
                    Stat   stat     = (Stat) statDicEntry.Value;

                    if(!stat._fChanged)
                        continue;

                    update.PlayerUpdateStat(usStatId, stat._val);
                }
            }

            // process database changes
            StatDbStatUpdateCallback callback = new StatDbStatUpdateCallback();
            update.Process((IStatDbStatUpdateCallback)callback);

            if(callback._refs.Count > 0)
            {
                // Only register attachments if this request is comming from an XBOX. If the request is comming from
                // arbitration, there is no single user that can be attached to the token and there is no client to
                // receive the signed token.

                if(_ulMachineId != 0) // _ulMachineId 0 means arbitrated request or auth is turned off
                    _attachRefs = callback._refs;
            }
        }

        protected void RegisterPendingAttachments()
        {
            if(_attachRefs == null || !SGInfo.IsXbox())
                return;

            ArrayList refsFinal = new ArrayList(_attachRefs.Count);

            // The attachment shall go under the puid of the first reference
            _attachPuid = ((RepSetDataReference)_attachRefs[0])._ulUser;

            // Create a new name for the attachment
            _attachPathName  = "//" + ProtocolConstant.AttachStorageDomain +
                "/u:" + _attachPuid.ToString("x") + "/" + _req._uiTitleId.ToString("x") + "/" +
                Guid.NewGuid().ToString();

            // Register attachments in the database
            _uiAttachMaxSize = uint.MaxValue;
            foreach(RepSetDataReference rf in _attachRefs)
            {
                uint uiMaxAttSize;
                try
                {
                    _statDb.RegisterPendingAttachment(_req._uiTitleId, rf._uiLb, rf._ulUser,
                        _attachPathName, out uiMaxAttSize);
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.STATS_CODE_11, e, 
                        "\nPathname:"+_attachPathName+
                        "\nReference: "+ rf.ToString()
                    );

                    // We can't return an error because we have already committed
                    // the stuff to the database. We also can't return this
                    // reference so we'll have to skip it. Sucks but it's better
                    // than nothing.
                    continue;
                }

                // Consolidate max att size. The smallest wins.
                if(uiMaxAttSize < _uiAttachMaxSize)
                    _uiAttachMaxSize = uiMaxAttSize;

                refsFinal.Add(rf);
            }

            _attachRefs = refsFinal;
        }

        /// <summary>
        /// StatPostData
        /// </summary>
        /// <remarks>
        /// Internal class to store the stat post data that is not
        /// dependent on the request protocol
        /// </remarks>
        protected class StatPostData
        {
            public uint         _uiTitleId   = 0;
            public ushort       _usProcCount = 0;
            public MsgStatPostProcedureCall[] _procs = null;
            public xonline.common.protocol.TeamTickets _teamTickets = null;

            /// <summary>
            /// Set
            /// </summary>
            /// <param name="req">Input ReqStatPost object (Xbox)</param>
            /// <remarks>
            /// Copies data from ReqStatPost to the stat data structure
            /// </remarks>
            public void Set(ReqStatPost req)
            {
                _uiTitleId   = req._uiTitleId;
                _usProcCount = req._usProcCount;
                _procs       = req._procs;
                _teamTickets = req._teamTickets;
            }

            /// <summary>
            /// Set
            /// </summary>
            /// <param name="req">Input StatsPostRequest object (Xenon)</param>
            /// <remarks>
            /// Copies data from StatsPostRequest to the stat data structure
            /// </remarks>
            public void Set(StatsPostRequest req)
            {
                _uiTitleId   = req.TitleId;
                _usProcCount = req.OperatorCount;

                MsgStatPostProcedureCall[] procs = new MsgStatPostProcedureCall[_usProcCount];

                // Convert StatsOperators into MsgStatPostProcedureCall
                for (int i = 0; i < req.OperatorCount; i++)
                {
                    procs[i] = new MsgStatPostProcedureCall();
                    MsgStatPostProcedureCall proc = procs[i];
                    StatsOperator op = req.Operators[i];

                    proc._usProcId     = op.OperatorId;
                    proc._usParamCount = op.ParameterCount;

                    proc._params = new MsgStatPostParameter[proc._usParamCount];
                    for (int j = 0; j < op.ParameterCount; j++)
                    {
                        proc._params[j] = new MsgStatPostParameter();
                        MsgStatPostParameter procparam = proc._params[j];
                        StatsOperatorParameter opparam = op.Parameters[j];

                        procparam._bParamType = opparam.Type;
                        procparam._data = opparam.Data;
                    }
                }

                _procs       = procs;
                _teamTickets = req.TeamTickets;
            }
        }

        // StatDbStatUpdateCallback
        // Callback to IStatDbStatUpdate.Update.
        protected class StatDbStatUpdateCallback : IStatDbStatUpdateCallback
        {
            public void OnQualifyForAttachment(uint uiLbId, ulong ulPuid)
            {
                RepSetDataReference rf = new RepSetDataReference();
                rf._uiLb = uiLbId;
                rf._ulUser = ulPuid;
                _refs.Add(rf);
            }

            public ArrayList _refs = new ArrayList(5);
        }

        // StatDbReadCallback
        // This is the callback used in ReadDatabase to process the data as it's
        // being read from the database.
        protected class StatDbReadCallback : IStatDbReadCallback
        {
            public StatDbReadCallback(StatPost statPost)
            {
                _statPost = statPost;
            }

            public void OnPlayerLbEntry(ulong ulPuid, uint uiLbId)
            {
                LbUserKey lbUserKey = new LbUserKey(uiLbId, ulPuid);
                _lbEntry = (LbEntry) _statPost._playerRows[lbUserKey];
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");
            }

            public void OnPlayerStat(ushort usStatId, object val)
            {
                if(_lbEntry == null)
                    throw new Exception("ASSERT FAILED: _lbEntry == null");

                Stat stat = (Stat) _lbEntry._stats[usStatId];
                if(stat != null)
                    stat.Set(usStatId, val);
            }

            protected StatPost  _statPost;
            protected Unit      _unit       = null;
            protected LbEntry   _lbEntry    = null;
        }

        protected class StatPostProcControl
            : IStatPostProcParam, IStatPostDataRequirements, IStatPostData
        {
            public StatPostProcControl(
                IStatProc                   proc,
                StatPost                    statPost,
                MsgStatPostProcedureCall    msgProcCall )
            {
                _proc           = proc;
                _statPost       = statPost;
                _msgProcCall    = msgProcCall;
            }

            // IStatPostProcParam.ParamCount
            public int ParamCount
            {
                get { return _msgProcCall._params.Length; }
            }

            // IStatPostProcParam.ProcCount
            public int ProcCount
            {
                get { return _statPost._procs.Length; }
            }

            protected MsgStatPostParameter GetParam(int index)
            {
                if(index > _msgProcCall._params.Length)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS, XEvent.Id.XSTATSFD_INVALID_REQUEST_52,
                        "Parameter "+index+" expected (index is zero-based).");
                }

                return _msgProcCall._params[index];
            }

            // IStatPostProcParam.GetParamInt8
            public byte GetParamInt8(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                if(param._bParamType != StatParam.Int8)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_53,
                        "Parameter "+index+" expected to be Int8.");
                }
                return (byte)param._data;
            }

            // IStatPostProcParam.GetParamInt16
            public short GetParamInt16(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Int16)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_54,
                        "Parameter "+index+" expected to be Int16.");
                }

                return (short)param._data;
            }

            // IStatPostProcParam.GetParamInt32
            public int GetParamInt32(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Int32)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_55,
                        "Parameter "+index+" expected to be Int32.");
                }

                return (int)param._data;
            }

            // IStatPostProcParam.GetParamInt64
            public long GetParamInt64(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Int64)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_56,
                        "Parameter "+index+" expected to be Int64.");
                }

                return (long)param._data;
            }

            // IStatPostProcParam.GetParamFloat
            public double GetParamFloat(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Float)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_57,
                        "Parameter "+index+" expected to be Float.");
                }

                return (double)param._data;
            }

            // IStatPostProcParam.GetParamUtf8String
            public string GetParamUtf8String(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Utf8string)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_58,
                        "Parameter "+index+" expected to be Utf8string.");
                }

                return (string)param._data;
            }

            // IStatPostProcParam.GetParamPuid
            public ulong GetParamPuid(int index)
            {
                MsgStatPostParameter param = GetParam(index);

                if(param._bParamType != StatParam.Puid)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_59,
                        "Parameter "+index+" expected to be Int64.");
                }

                return (ulong)param._data;
            }

            // IStatPostProcParam.GetParamType
            public byte GetParamType(int index)
            {
                MsgStatPostParameter param = GetParam(index);
                return (byte) param._bParamType;
            }

            // IStatPostProcParam.GetProcedure
            public IStatProc GetProcedure(
                int index)
            {
                return _statPost._procs[index]._proc;
            }

            // IStatPostData.PlayerStatReplace
            public void PlayerStatReplace(
                LbUserKey       key,
                ushort          usStatId,
                object          val)
            {
                _statPost.SetPlayerStat(key, usStatId, val);
            }

            // IStatPostData.PlayerStatGet
            public object PlayerStatGet(
                LbUserKey       lbUserKey,
                ushort          usStatId)
            {
                return _statPost.GetPlayerStat(lbUserKey, usStatId);
            }

            // IStatPostData.GetLeaderboardInfo
            public ILeaderboardInfo GetLeaderboardInfo(uint uiLbId)
            {
                return _statPost._statDb.GetLbInfo(_statPost._req._uiTitleId, uiLbId);
            }

            // IStatPostDataRequirements.RequestPlayerData
            public void RequestPlayerData(
                LbUserKey       lbUserKey,
                ushort          usStatId)
            {
                _statPost.RequestPlayerData(lbUserKey, usStatId);
            }

            // IStatPostDataRequirements.RequestPlayerData
            public void VerifyPuidIsAuthorized(
                ulong           ulPuid,
                uint            uiLbId,
                bool            fIsUnit)
            {
                _statPost.VerifyPuidIsAuthorized(ulPuid, uiLbId, fIsUnit);
            }
            public bool IsPuidAuthorized(
                ulong           ulPuid,
                uint            uiLbid,
                bool            fIsUnit,
                out string      errorMsg)
            {
                return _statPost.IsPuidAuthorized(ulPuid, uiLbid, fIsUnit, out errorMsg);
            }

            public  StatPost                  _statPost;
            public  MsgStatPostProcedureCall  _msgProcCall;
            public  IStatProc                 _proc;
        }

        // Unit
        protected class Unit
        {
            public double       _activity           = 0;
            public DateTime     _lastActivity       = DateTime.MinValue;
            public Hashtable    _lbs                = new Hashtable(10); // BUGBUG: hardcoded
            public bool         _fActivityAvailable = false;
            public bool         _fChanged           = false;
        }

        // LbEntry
        protected class LbEntry
        {
            public Hashtable    _stats = new Hashtable(70); // BUGBUG: hardcoded
            public bool         _fChanged = false;
        }

        // Stat
        protected class Stat
        {
            public void Set(ushort usStatId, object val)
            {
                // If stat id is a reserved stat id, verify type restrictions.
                if((usStatId & 0x8000) != 0)
                {
                    if(usStatId == SpecialAttrib.Rating)
                    {
                        if(! (val is long))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_60,
                                "Invalid type for rating. Type should be LONGLONG.");
                        }
                    }
                    else if(usStatId == SpecialAttrib.Nickname)
                    {
                        if(! (val is string))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_61,
                                "Invalid type for Nickname. Type should be LPCSTR.");
                        }
                    }
                    else if(usStatId == SpecialAttrib.UnitActivity)
                    {
                        // Effectively, val will be added to the activity.
                        // That's the only operation supported on activity.
                        if(! (val is double))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_62,
                                "Invalid type for UnitActivity. Type should be DOUBLE.");
                        }
                    }
                    else if(usStatId == SpecialAttrib.AttachmentSize)
                    {
                        if(! (val is Int32))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_76,
                                "Invalid type for Attachment Size. Type should be Int32.");
                        }
                    }
                    else
                    {
                        throw new XRLException(
                            HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_63,
                            "Invalid use of reserved stat ids. Reserved stat either does not exist or is read-only.");
                    }
                }
                else
                {
                    if(! (val is int
                        || val is long
                        || val is double) )
                    {
                        throw new XRLException(
                            HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_64,
                            "Invalid stat type. Only LONG, LONGLONG and DOUBLE are supported for custom stats.");
                    }
                }

                _val           = val;
            }

            public object       _val        = null;
            public bool         _fChanged   = false;
        }
    }

    // StatProcedureDirectory
    public class StatProcedureDirectory
    {
        public StatProcedureDirectory()
        {
            // Catalog all procedures
            Type[] allTypes = Assembly.GetExecutingAssembly().GetTypes();

            string istatprocName = typeof(IStatProc).FullName;

            foreach( Type t in allTypes )
            {
                if (    t.IsClass
                    && !t.IsAbstract
                    &&  t.GetInterface(istatprocName) != null )
                {
                    StatProcedureAttribute attrib =
                        (StatProcedureAttribute) t.GetCustomAttributes(
                            typeof(StatProcedureAttribute), false)[0]
                            as StatProcedureAttribute;

                    // Add one instance to directory
                    _procs[attrib._usProcId] = t.GetConstructor(Type.EmptyTypes);
                }
            }
        }

        public IStatProc CreateProcHandler(ushort usProcId)
        {
            ConstructorInfo ci = (ConstructorInfo) _procs[usProcId];

            if(ci == null)
                throw new XRLException(
                    HResult.XONLINE_E_STAT_INVALID_PROCEDURE, XEvent.Id.XSTATSFD_INVALID_REQUEST_65,
                    "Invalid procedure id " + usProcId);

            return (IStatProc) ci.Invoke(null);
        }

        public IStatProc this[ushort usProcId]
        {
            get { return (IStatProc)_procs[usProcId]; }
        }

        protected Hashtable _procs = new Hashtable(16);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\GetData.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    // XRLGetData
    // HTTP handler for Commit Attachment request
    public class XRLGetData : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            BinaryReader           reader      = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper    writer      = new BinaryWriterWrapper(ctx.Response.OutputStream);
            
            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();
            
            StatGet statGet = new StatGet(reader, (IStatDb) new StatDb());

            statGet.Process();

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, statGet.TitleId, HResult.S_OK);
            statGet.Reply.WriteTo(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\perfctrs.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;
	
namespace xonline.server.stats.fd 
{
	[XomPerformanceCounterCategoryAttr( "Stats (Leaderboards) FD", "XBox Online Statistics Service" )]
	public class StatisticsCounters : XomPerformanceCounterCategory
	{
		// SetData request counters

		[XomPerformanceCounterAttr(
			"SetData per second", 
			"SetData requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter SetDataPerSecond;

		[XomPerformanceCounterAttr(
			"Total SetData", 
			"Total SetData requests", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter SetDataTotal;

		[XomPerformanceCounterAttr(
			"SetData failed per second", 
			"SetData requests failed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter SetDataFailedPerSecond;

		[XomPerformanceCounterAttr(
			"Total SetData failed", 
			"Total SetData requests failed", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter SetDataFailedTotal;

		[XomPerformanceCounterAttr(
			"Rating updates per second", 
			"Rating update requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RatingUpdPerSecond;

        [XomPerformanceCounterAttr(
             "SetData not qualified per second", 
             "Number of SetData requests to lightweight leaderboards per second that did not qualify.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SetDataNotQualifiedPerSecond;

        [XomPerformanceCounterAttr(
             "SetData not qualified total", 
             "Number of SetData requests to lightweight leaderboards that did not qualify.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SetDataNotQualifiedTotal;


		// GetData request counters

		[XomPerformanceCounterAttr(
			"GetData per second", 
			"GetData requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetDataPerSecond;

		[XomPerformanceCounterAttr(
			"Total GetData", 
			"Total GetData requests", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter GetDataTotal;

		[XomPerformanceCounterAttr(
			"GetData failed per second", 
			"GetData requests failed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetDataFailedPerSecond;

		[XomPerformanceCounterAttr(
			"Total GetData failed", 
			"Total GetData requests failed", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter GetDataFailedTotal;

		// EnumLb request counters

		[XomPerformanceCounterAttr(
			"EnumLb per second", 
			"EnumLb requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter EnumLbPerSecond;

		[XomPerformanceCounterAttr(
			"Total EnumLb", 
			"Total EnumLb requests", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter EnumLbTotal;

		[XomPerformanceCounterAttr(
			"EnumLb failed per second", 
			"EnumLb requests failed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter EnumLbFailedPerSecond;

		[XomPerformanceCounterAttr(
			"Total EnumLb failed", 
			"Total EnumLb requests failed", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter EnumLbFailedTotal;

		// Reset request counters

		[XomPerformanceCounterAttr(
			"Reset per second", 
			"Reset requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter ResetPerSecond;

		[XomPerformanceCounterAttr(
			"Total Reset", 
			"Total Reset requests", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter ResetTotal;

		[XomPerformanceCounterAttr(
			"Reset failed per second", 
			"Reset requests failed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter ResetFailedPerSecond;

		[XomPerformanceCounterAttr(
			"Total Reset failed", 
			"Total Reset requests failed", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter ResetFailedTotal;

        // EnumLb request counters

        [XomPerformanceCounterAttr(
             "WebEnumLb per second", 
             "WebEnumLb requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter WebEnumLbPerSecond;

        [XomPerformanceCounterAttr(
             "Total WebEnumLb", 
             "Total WebEnumLb requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter WebEnumLbTotal;

        [XomPerformanceCounterAttr(
             "WebEnumLb failed per second", 
             "WebEnumLb requests failed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter WebEnumLbFailedPerSecond;

        [XomPerformanceCounterAttr(
             "Total WebEnumLb failed", 
             "Total WebEnumLb requests failed", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter WebEnumLbFailedTotal;

        // Commit Attachment

        [XomPerformanceCounterAttr(
             "CommitAtt per second", 
             "CommitAtt requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CommitAttPerSecond;

        [XomPerformanceCounterAttr(
             "Total CommitAtt", 
             "Total CommitAtt requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CommitAttTotal;

        [XomPerformanceCounterAttr(
             "CommitAtt failed per second", 
             "CommitAtt requests failed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CommitAttFailedPerSecond;

        [XomPerformanceCounterAttr(
             "Total CommitAtt failed", 
             "Total CommitAtt requests failed", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CommitAttFailedTotal;


        // Specialized counters

		[XomPerformanceCounterAttr(
			"GetData/sec <= 10 specs w/ nickname", 
			"GetData/sec <= 10 specs w/ nickname", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetDataLTE10SpecsWithNickname;

		[XomPerformanceCounterAttr(
			"GetData/sec <= 10 specs no nickname", 
			"GetData/sec <= 10 specs no nickname", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetDataLTE10SpecsNoNickname;

		[XomPerformanceCounterAttr(
			"GetData/sec > 10 specs", 
			"GetData/sec > 10 specs", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetDataMT10Specs;

		[XomPerformanceCounterAttr(
			"SetData/sec > 3 attributes w/ nickname", 
			"SetData/sec > 3 attributes w/ nickname", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter SetDataMT3AttrWithNickname;

		[XomPerformanceCounterAttr(
			"SetData/sec > 3 attributes no nickname", 
			"SetData/sec > 3 attributes no nickname", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter SetDataMT3AttrNoNickname;

		[XomPerformanceCounterAttr(
			"SetData/sec <= 3 attributes", 
			"SetData/sec <= 3 attributes", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter SetDataLTE3Attr;

        [XomPerformanceCounterAttr(
             "Bucket splits per second", 
             "Estimated bucket splits per second. This number is just an "+
             "estimation and may not be totally accurate.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BucketSplitsPerSecond;

		//More general stats - from bug 30724
		[XomPerformanceCounterAttr(
			 "Stats Reads Per Second", 
			 "All Stats Reads Per Second", 
			 PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter StatsReadPerSecond;

		[XomPerformanceCounterAttr(
			 "Stats Writes Per Second", 
			 "All Stats Writes Per Second", 
			 PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter StatsWritePerSecond;

		[XomPerformanceCounterAttr(
			 "Stats Enumerations Per Second", 
			 "All Stats Enumerations Per Second", 
			 PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter StatsEnumPerSecond;

        // Fix for bug# 19066
        // Connection issues cos of bad LBS Servers
        // 1 success, 1 failure and 1 ratio counter
        // must keep the help string between 0 and 255 in length though.
        [XomPerformanceCounterAttr(
             "Stats FD2LBS Connect Per Second",
             "Provides a per second rate of number of connection attempts to the LBS. Note that this will actually " +
             "get the number of connection requests to the pool, not just the creation of new TCP " +
             "connections. Instanced by server name housing the LBS.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FD2LBSConnectPerSecond;

        [XomPerformanceCounterAttr(
             "Stats FD2LBS Connect failures Per Second",
             "Provides a per second rate of failures due to transport errors/socket exceptions " +
             "AND due to problems in the handshake protocol " +
             "with the LBS servers. Instanced by server name housing the LBS.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FD2LBSConnectFailPerSecond;

        [XomPerformanceCounterAttr(
             "Stats FD2LBS Connect failures % Per Second",
            "Provides a per second percentage of failed connection requests(due to transport errors) vs " +
            "actual requests to connect to a LBS. Note that these are requests made to the connection pool " +
            "that may or may not lead to a new TCP connection.",
           PerformanceCounterType.SampleFraction)]
        public PerformanceCounter FD2LBSConnectFailPercentagePerSecond;

        [XomPerformanceCounterAttr(
             "Stats FD2LBS Connect requests Per Second Base",
             "All Stats FD2LBS Connect requests Per Second Base. This is a base counter for the counter with a similar name.",
          PerformanceCounterType.SampleBase)]
        public PerformanceCounter FD2LBSConnectFailPercentagePerSecondBase;

        public virtual StatisticsCounters this[string strInstanceName]
        {
            get
            {
                return (StatisticsCounters) GetInstance(strInstanceName);
            }
        }
		
		static public StatisticsCounters Counters = new StatisticsCounters();
        
        // PlatformLeaderboard REST API request counters

        [XomPerformanceCounterAttr(
           "PlatformLeaderboard Current Requests",
           "PlatformLeaderboard Current Requests in progress",
           PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PlatformLeaderboardCurrent;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard Total Requests",
            "PlatformLeaderboard Total Requests Successfully Processed",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardTotal;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard Total Failed Requests",
            "PlatformLeaderboard Total Failed Requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardFailedTotal;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard Requests For a Non-platform leaderboard",
            "PlatformLeaderboard Requests For a Non-platform leaderboard",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardRequestForNonPlatformLeaderboard;

        [XomPerformanceCounterAttr(
             "PlatformLeaderboard Calls Per Second",
             "PlatformLeaderboard Calls Per Second",
             PerformanceCounterType.RateOfCountsPerSecond64)]
        public PerformanceCounter PlatformLeaderboardCallsPerSecond;

       // PlatformLeaderboardDataForUser REST API request counters

        [XomPerformanceCounterAttr(
           "PlatformLeaderboard User Data Current Requests",
           "PlatformLeaderboard User Data Current Requests in progress",
           PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PlatformLeaderboardDataForUserCurrent;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard User Data Total Requests",
            "PlatformLeaderboard User Data Total Requests Successfully Processed",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardDataForUserTotal;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard User Data Average Friends Per Request",
            "PlatformLeaderboard User Data Average Friends Per Request",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter PlatformLeaderboardDataForUserAvgFriends;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard User Data Average Friends Per Request Base",
            "PlatformLeaderboard User Data Average Friends Per Request Base",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PlatformLeaderboardDataForUserAvgFriendsBase;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard User Data Total Failed Requests",
            "PlatformLeaderboard User Data Total Failed Requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardDataForUserFailedTotal;

        [XomPerformanceCounterAttr(
            "PlatformLeaderboard User Data request for a non-platform leaderboard",
            "PlatformLeaderboard User Data request for a non-platform leaderboard",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PlatformLeaderboardRequestForNonPlatformLeaderboardUserData;
        
        [XomPerformanceCounterAttr(
             "PlatformLeaderboard User Data Calls Per Second",
             "PlatformLeaderboard User Data Calls Per Second",
             PerformanceCounterType.RateOfCountsPerSecond64)]
        public PerformanceCounter PlatformLeaderboardUserCallsPerSecond;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\avatar.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// Avatar.cs
//
// This file contains validation logic for avatar manifests,
// most of which is ported from various places in the xbox 360 console
// code. Main sources of this validation are:
// - Avatars::ManifestReaderWriter
// - AvatarSysCore in XAM
// - Avatars::AvatarGetDataContext::FixupAndValidateManifest
//
// If anything changes in this file, it should be ported back to the
// console code, too.
//
////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Security.Cryptography;
using System.Collections;
using System.Data;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class Avatar
    {
        private static Guid guidMaleBody = new Guid(0x00000002, 0x0000, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
        private static Guid guidFemaleBody = new Guid(0x00000002, 0x0001, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
        private static Guid guidHead = new Guid(0x00000001, 0x0002, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);

        private static Dictionary<Guid, int> guestGuids = new Dictionary<Guid, int>()
        {
            {new Guid(0x00000008, 0x005C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}, // male guest 1
            {new Guid(0x00000008, 0x005D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}, // male guest 2
            {new Guid(0x00000008, 0x005E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}, // male guest 3
            {new Guid(0x00000008, 0x012D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}, // female guest 1
            {new Guid(0x00000008, 0x012E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}, // female guest 2
            {new Guid(0x00000008, 0x012F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), 0}  // female guest 3
        };

        // This lists that components that should appear in PreviousRequiredComponentInfo.
        // They should appear in this order.
        private static AvatarManifest.XAVATAR_COMPONENT_MASK[] s_requiredComponents =
        {
            AvatarManifest.XAVATAR_COMPONENT_MASK.Shoes,
            AvatarManifest.XAVATAR_COMPONENT_MASK.Trousers,
            AvatarManifest.XAVATAR_COMPONENT_MASK.Shirt,
            AvatarManifest.XAVATAR_COMPONENT_MASK.Hair
        };

        // Category masks used to validate blend shapes and replacement textures.
        // These aren't currently exposed to title developers as components that can
        // be altered, so these definitions are only used for validation and aren't
        // currently exposed publicly.
        private enum XAVATAR_CATEGORY_MASK
        {
            // Textures
            Eye         = 0x00002000,
            EyeBrow     = 0x00004000,
            Mouth       = 0x00008000,
            FacialHair  = 0x00010000,
            FacialOther = 0x00020000,
            EyeShadow   = 0x00040000,

            // Blendshapes
            Nose        = 0x00080000,
            Chin        = 0x00100000,
            Ears        = 0x00200000,
            Shape       = 0x01000000
        };

        public static bool CompareByteArrays(byte[] b1, byte[] b2)
        {
            if (b1.Length != b2.Length)
            {
                return false;
            }

            for (int i = 0; i < b1.Length; ++i)
            {
                if (b1[i] != b2[i])
                {
                    return false;
                }
            }

            return true;
        }

        // Validate that the users has the right to use awarded and purchased assets that are
        // presence in the manifest.
        private static bool ValidateAssetOwnership(ulong userId, AvatarManifest manifest, uint validationFlags)
        {
            ArrayList awarded = new ArrayList();
            ArrayList purchased = new ArrayList();

            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO comp in manifest.ComponentInfo)
            {
                switch (comp.ModelAssetId.Version)
                {
                    case AvatarAssetId.AVATAR_ASSET_VERSION_FREE:
                        // free asset - no validation necessary
                        break;
                    case AvatarAssetId.AVATAR_ASSET_VERSION_AWARD:
                        awarded.Add(comp.ModelAssetId);
                        break;
                    case AvatarAssetId.AVATAR_ASSET_VERSION_MARKETPLACE:
                        purchased.Add(comp.ModelAssetId);
                        break;
                    default:
                        Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: invalid avatar asset id {1}. Unknown version {2}", userId, comp.ModelAssetId.Id, comp.ModelAssetId.Version);
                        return false;
                }
            }

            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO comp in manifest.PreviousRequiredComponentInfo)
            {
                switch (comp.ModelAssetId.Version)
                {
                    case AvatarAssetId.AVATAR_ASSET_VERSION_FREE:
                        // free asset - no validation necessary
                        break;
                    case AvatarAssetId.AVATAR_ASSET_VERSION_AWARD:
                        awarded.Add(comp.ModelAssetId);
                        break;
                    case AvatarAssetId.AVATAR_ASSET_VERSION_MARKETPLACE:
                        purchased.Add(comp.ModelAssetId);
                        break;
                    default:
                        Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: invalid avatar asset id {1}. Unknown version {2}", userId, comp.ModelAssetId.Id, comp.ModelAssetId.Version);
                        return false;
                }
            }

            // Awarded avatar items in UODB
            if (awarded.Count > 0)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_stats_validate_awarded_avatar_assets";
                    ws.Partition = ws.CalcPartition(userId);

                    ws.AddParameter("@bi_user_puid", userId);
                    ws.AddParameter("@full_validation", ((validationFlags & ValidateAvatarManifestRequest.XAVATAR_VALIDATE_AVATAR_AWARDS) != 0) ? 1 : 0);

                    // Add the awarded assets using a table-valued parameter
                    DataTable dtAwarded = new DataTable();
                    dtAwarded.Columns.Add("uid_avatar_asset", typeof(Guid));
                    dtAwarded.Columns.Add("i_title_id", typeof(int));
                    dtAwarded.Columns.Add("i_asset_ordinal", typeof(int));
                    dtAwarded.Columns.Add("i_body_type_mask", typeof(int));
                    foreach (AvatarAssetId avatarAssetId in awarded)
                    {
                        dtAwarded.Rows.Add(avatarAssetId.Id, (int)avatarAssetId.TitleId, (int)avatarAssetId.AwardOrdinal, (int)avatarAssetId.BodyTypeMask);
                    }
                    ws.Parameters.AddWithValue("@awarded_avatar_assets", dtAwarded);

                    // execute the query and get back the list of invalid assets
                    WstDataReader reader = ws.Execute();
                    if (reader.Read())
                    {
                        do
                        {
                            Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: invalid avatar asset id {1}", userId, reader["uid_invalid_avatar_asset"]);
                        }
                        while (reader.Read());

                        return false;
                    }
                }
            }

            // Purchased avatar items in UserCommerceDB
            if (purchased.Count > 0)
            {
                using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_stats_validate_purchased_avatar_assets";
                    ws.Partition = ws.CalcPartition(userId);

                    ws.AddParameter("@bi_user_puid", userId);

                    // Add the purchased assets using a table-valued parameter
                    DataTable dtPurchased = new DataTable();
                    dtPurchased.Columns.Add("uid_avatar_asset", typeof(Guid));
                    foreach (AvatarAssetId avatarAssetId in purchased)
                    {
                        dtPurchased.Rows.Add(avatarAssetId.Id);
                    }
                    ws.Parameters.AddWithValue("@purchased_avatar_assets", dtPurchased);

                    // execute the query and get back the list of invalid assets
                    WstDataReader reader = ws.Execute();
                    if (reader.Read())
                    {
                        do
                        {
                            Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: invalid avatar asset id {1}", userId, reader["uid_invalid_avatar_asset"]);
                        }
                        while (reader.Read());

                        return false;
                    }
                }
            }

            return true;
        }


        // Validates:
        // - body type of component is neutral or matches body type of avatar
        // - all clothing components are clothing items (no second head, etc)
        // - no guest components
        private static bool ValidateAvatarComponent(ulong userId, AvatarManifest.XAVATAR_COMPONENT_INFO body, AvatarManifest.XAVATAR_COMPONENT_INFO component)
        {
            if ((body.ModelAssetId.Id == guidMaleBody && component.ModelAssetId.BodyTypeMask == (byte)AvatarAssetId.BodyType.Female) ||
                (body.ModelAssetId.Id == guidFemaleBody && component.ModelAssetId.BodyTypeMask == (byte)AvatarAssetId.BodyType.Male))
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: avatar is wearing component {1} for the wrong body type", userId, component.ModelAssetId.Id);
                return false;
            }

            if ((component.ComponentMask & (ushort)AvatarManifest.XAVATAR_COMPONENT_MASK.Body) != 0)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: avatar has a body component equipped in a clothing slot", userId);
                return false;
            }

            if ((component.ComponentMask & (ushort)AvatarManifest.XAVATAR_COMPONENT_MASK.Head) != 0)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: avatar has a head component equipped in a clothing slot", userId);
                return false;
            }

            if (guestGuids.ContainsKey(component.ModelAssetId.Id))
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: avatar is wearing guest shirt", userId);
                return false;
            }

            return true;
        }

        // Validates that the blend shape is the correct asset type
        // All blend shapes must be specified.
        private static bool ValidateBlendShape(ulong userId, AvatarManifest.Shape_e shape, XAVATAR_CATEGORY_MASK expectedMask, AvatarManifest.BlendShape_c asset)
        {
            if (asset.BlendShapeAssetId.BodyComponent != (uint)expectedMask)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: blend shape {1} in {2} slot is incorrect type.", userId, asset.BlendShapeAssetId.Id, shape);
                return false;
            }

            return true;
        }

        // Validates that the replacement texture is the correct asset type.
        // Not all replacement textures must be specified (such as facial hair and skin texture)
        private static bool ValidateReplacementTexture(ulong userId, AvatarManifest.Texture_e texture, XAVATAR_CATEGORY_MASK expectedMask, AvatarManifest.ReplacementTexture_c asset, bool required)
        {
            if (asset.TextureAssetId.BodyComponent != (uint)expectedMask && (required || (asset.TextureAssetId.Id != Guid.Empty)))
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: replacement texture {1} in {2} slot is incorrect type.", userId, asset.TextureAssetId.Id, texture);
                return false;
            }

            return true;
        }

        public static bool ValidateAvatarManifest(ulong userId, byte[] manifestBytes, uint validationFlags)
        {
            // If there's an error in validation, we log an error and return false instead of
            // throwing an error, which would cause the sync call to be aborted.
            // In response to a validation failure, such as equipping an asset the user's been
            // banned from using due to cheating, we zero out the avatar manifest.

            // Check the length.
            if (manifestBytes.Length != XOn.XONLINE_MAX_SETTING_VALUE_BYTES)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: incorrect manifest length {1}", userId, manifestBytes.Length);
                return false;
            }

            // Get the existing manifest and see if it's changed.
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_stats_get_user_settings";
                ws.SetHashVal(userId);

                ws.AddParameter("@i_title_id", XOn.XENON_DASH_TITLE_ID);
                ws.AddParameter("@bi_user_puid0", userId);
                ws.AddParameter("@i_setting_id0", ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1);

                WstDataReader reader = ws.Execute();

                if (reader.Read())
                {
                    byte[] oldValue = reader.GetSqlBinary(reader.GetOrdinal("vb_value")).Value;
                    if (CompareByteArrays(manifestBytes, oldValue))
                    {
                        return true;
                    }
                }
            }

            // Now shred the blob into a structure and start checking the fields
            AvatarManifest manifest = AvatarManifest.Read(manifestBytes);

            // Version 0 is the only valid version right now
            if (manifest.Version != 0)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: unknown version {1}", userId, manifest.Version);
                return false;
            }

            // OwnerXuid should be the offline xuid of the user if the manifest comes from a console.
            // If the manifest comes from another source, it may be empty or the online xuid.
            // Don't check it, since it doesn't affect rendering and isn't worth hitting UODB.

            // SrcConsoleId will be empty when the console saves the manifest to the profile,
            // but has the real console id when the console calls ValidateAvatarManifest
            // directly with an in-memory manifest. Don't check it.

            // Body should be male or female
            if (manifest.BodyComponentInfo.ModelAssetId.Id != guidMaleBody && manifest.BodyComponentInfo.ModelAssetId.Id != guidFemaleBody)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: unknown body type {1}", userId, manifest.BodyComponentInfo.ModelAssetId.Id);
                return false;
            }

            // Head component should be valid
            if (manifest.HeadComponentInfo.ModelAssetId.Id != guidHead)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: unknown head type {1}", userId, manifest.HeadComponentInfo.ModelAssetId.Id);
                return false;
            }

            // PreviousRequiredComponentInfo should have entries of the appropriate type.
            // Entries must be exact matches of the required type so that they can be used as replacements for required
            // components when a newly equipped item conflicts with a costume that covers a required component.
            // Example: a user is wearing a long-sleeved shirt and puts on wristwear. Long-sleeved shirts cover the
            // wristwear slot, so the shirt needs to be removed. In that case, the short-sleeved shirt from
            // PreviousRequiredComponentInfo will be equipped in place of the long-sleeved shirt that had to be removed.
            for (int i = 0; i < manifest.PreviousRequiredComponentInfo.Length; ++i)
            {
                if (manifest.PreviousRequiredComponentInfo[i].ComponentMask != (ushort)s_requiredComponents[i])
                {
                    Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: PreviousRequiredComponentInfo entry {1} is incorrect type {2}", userId, i, manifest.PreviousRequiredComponentInfo[i].ComponentMask);
                    return false;
                }
            }

            // Check ComponentInfo:
            // - should be packed. non-null, followed by null
            // - no duplicates
            // - no conflicts (ring/glove, etc)
            // - required components are all present (avatar must wear pants)
            bool reachedEnd = false;
            uint componentsSeen = 0;
            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO component in manifest.ComponentInfo)
            {
                // Make sure it's packed. non-null, followed by null
                if (reachedEnd && component.ModelAssetId.Id != Guid.Empty)
                {
                    Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: ComponentInfo array is not packed properly", userId);
                    return false;
                }

                if (!reachedEnd)
                {
                    if (component.ModelAssetId.Id == Guid.Empty)
                    {
                        reachedEnd = true;
                    }
                    else
                    {
                        // Check for duplicates/conflicts
                        if ((componentsSeen & component.ComponentMask) != 0)
                        {
                            Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: Multiple components present with type {1}", userId, componentsSeen & component.ComponentMask);
                            return false;
                        }
                        componentsSeen |= component.ComponentMask;
                    }
                }
            }

            // Make sure all required components were present. Each requiredComponent entry mask in the array should have all bits
            // found in the accumulated componentsSeen value. Find the first entry from s_requiredComponents that's not
            // present in componentsSeen.
            int missing = Array.FindIndex(s_requiredComponents, mask => (componentsSeen & (ushort)mask) != (ushort)mask);
            if (missing != -1)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: Required component of type {1} is missing", userId, s_requiredComponents[missing]);
                return false;
            }

            // Check all components:
            // - body type of component is neutral or matches body type of avatar
            // - all clothing components are clothing items (no second head, etc)
            // - no guest components
            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO component in manifest.ComponentInfo)
            {
                if (!ValidateAvatarComponent(userId, manifest.BodyComponentInfo, component))
                {
                    return false;
                }
            }

            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO component in manifest.PreviousRequiredComponentInfo)
            {
                if (!ValidateAvatarComponent(userId, manifest.BodyComponentInfo, component))
                {
                    return false;
                }
            }

            // Check height/weight
            if (manifest.HeightFactor < -1.0 || manifest.HeightFactor > 1.0)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: Height factor {1} is out of bounds", userId, manifest.HeightFactor);
                return false;
            }

            if (manifest.WeightFactor < -1.0 || manifest.WeightFactor > 1.0)
            {
                Xom.NtEvent(XEvent.Id.AVATAR_ASSET_VALIDATION_FAILED, "Manifest validation failed for user {0}: Weight factor {1} is out of bounds", userId, manifest.WeightFactor);
                return false;
            }

            // Blend shapes should be valid
            if (!ValidateBlendShape(userId, AvatarManifest.Shape_e.Chin, XAVATAR_CATEGORY_MASK.Chin, manifest.BlendShapes[(int)AvatarManifest.Shape_e.Chin]) ||
                !ValidateBlendShape(userId, AvatarManifest.Shape_e.Nose, XAVATAR_CATEGORY_MASK.Nose, manifest.BlendShapes[(int)AvatarManifest.Shape_e.Nose]) ||
                !ValidateBlendShape(userId, AvatarManifest.Shape_e.Ear, XAVATAR_CATEGORY_MASK.Ears, manifest.BlendShapes[(int)AvatarManifest.Shape_e.Ear]))
            {
                return false;
            }

            // Replacement textures should be valid
            if (!ValidateReplacementTexture(userId, AvatarManifest.Texture_e.Mouth, XAVATAR_CATEGORY_MASK.Mouth, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Mouth], true) ||
                !ValidateReplacementTexture(userId, AvatarManifest.Texture_e.Eye, XAVATAR_CATEGORY_MASK.Eye, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Eye], true) ||
                !ValidateReplacementTexture(userId, AvatarManifest.Texture_e.EyeBrow, XAVATAR_CATEGORY_MASK.EyeBrow, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeBrow], true) ||
                !ValidateReplacementTexture(userId, AvatarManifest.Texture_e.FacialHair, XAVATAR_CATEGORY_MASK.FacialHair, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.FacialHair], false) ||
                !ValidateReplacementTexture(userId, AvatarManifest.Texture_e.EyeShadow, XAVATAR_CATEGORY_MASK.EyeShadow, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeShadow], false) ||
                !ValidateReplacementTexture(userId, AvatarManifest.Texture_e.SkinFeatures, XAVATAR_CATEGORY_MASK.FacialOther, manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.SkinFeatures], false))
            {
                return false;
            }

            if (!ValidateAssetOwnership(userId, manifest, validationFlags))
            {
                return false;
            }

            return true;
        }


        public static void EraseAvatarPic(ulong userId, string picToReplace, string defaultPic)
        {
            ReqHdrWriteFile req = new ReqHdrWriteFile();

            byte[] picData = Config.GetBlobSetting(defaultPic);
            string strPath = string.Format("//avatar/u:{0:x}/{1}", userId, picToReplace);

            // Set up the base access token
            req._accessToken = new WriteFileToken();
            req._accessToken._operation = (ushort)Operation.FileWrite;
            req._accessToken._serviceId = (uint)XOService.Storage;
            req._accessToken._flags = 0;
            req._accessToken._userPuid = userId;
            req._accessToken._xboxPuid = 0;
            req._accessToken._pathName = strPath; // _pathNameSize is set automatically based on this
            req._accessToken._signature = null; // _signatureSize is set automatically based on this

            // Set up the write access token
            req._accessToken._tokenExpirationDate = 0;
            req._accessToken._fileExpirationDate = 0;
            req._accessToken._maxFileSize = ProtocolConstants.maxFileSize;

            // Set up the request body
            req._titleId = 0x584D07D1; // avatar editor
            req._titleVersion = 0;
            req._userCountryId = 0;
            req._compressionType = (byte)CompressionType.Uncompressed;

            // Compute a digest of the attachment data
            SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider();
            req._blobHash = sha1.ComputeHash(picData);

            // NOTE: Make the signature the correct size, but leave it all zeroes.
            req._blobSignature = new byte[ProtocolConstants.sizeSignature];

            // Set the content type appropriately
            req._contentType = (uint)ContentType.ContentBlob;

            req._blobSizeUncompressed = (uint)picData.Length;
            req._blobSize = (uint)picData.Length;
            req._attributes = null; // _attributesSize is set automatically based on this

            // Write the full request into a binary stream
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            // Write out the request header
            req.WriteTo(writer);

            // Write out the attachment data
            writer.Write(picData);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            // Make the request to Storage
            HTTPAuthData httpAuthData = new HTTPAuthData(0, 0, 0, userId, 0x584D07D1, (uint)XOService.Storage, 0);

            byte[] response;
            XRLUtil.PostXrlRequest(VirtualInterface.stfd_storage_int, req.GetXRL(), httpAuthData.GetBase64EncodedString(), stream.ToArray(), null, out response);
        }

        public static void EraseAvatarManifest(ulong userId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_stats_sync_user_settings";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@i_title_id", XOn.XENON_DASH_TITLE_ID);
                ws.AddParameter("@dt_client_version", DateTime.UtcNow);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@i_setting_id0", ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1);
                ws.AddParameter("@i_title_id0", XOn.XENON_DASH_TITLE_ID);
                ws.AddParameter(ParamType.INPUT, "@vb_value0", (byte[])null, 0);

                ws.ExecuteNonQuery();
            }

            Profile.Cache.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, XOn.XENON_DASH_TITLE_ID, userId));

            EraseAvatarPic(userId, "avatarpic-s.png", MultiSetting.storageModule_DefaultAvatarPicSmall);
            EraseAvatarPic(userId, "avatarpic-l.png", MultiSetting.storageModule_DefaultAvatarPicLarge);
            EraseAvatarPic(userId, "avatar-body.png", MultiSetting.storageModule_DefaultAvatarPicBody);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\profile.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// Profile.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using System.Security.Cryptography;
using Microsoft.Xbox.Privacy.Interfaces;
using Microsoft.Xbox.Privacy.Client;
using System.Net;


namespace xonline.server.stats.fd
{
    public class Profile
    {
        private static uint Xprofile_Permissions_Field_Id = ProfileDefs.XPROFILE_PERMISSIONS;

        protected static Acceleration _cache = new Acceleration(Interface.ProfileCache);
        public static Acceleration Cache
        {
            get
            {
                return _cache;
            }
        }
        
        public static void RegisterGuid(ulong userId, byte[] guid)
        {

            uint hr = HResult.S_OK;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_stats_add_guid";
                ws.CalcPartition(BitConverter.ToUInt64(guid, 8));

                ws.AddParameter("@bin_guid", guid);
                ws.AddParameter("@bi_user_id", userId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.STATS_CODE_92, "Duplicate guid found!  " + ByteConvert.ToString(guid));
                }
            }
        }


        public static void RecalcGamerscore(
            ulong userId,
            uint titleId)
        {
            WSClient    ws;
            int         titleGamerScore = 0;
            int         titleAchievements = 0;

            TitleConfig tcfg = TitleConfig.GetTitle(titleId, false /* throwOnNotFound */);

            if (null == tcfg)
            {
                Xom.NtEvent(XEvent.Id.STATS_CONFIG_13, "Error loading title config for titleId = {0}. Gamerscore for this title will not be updated.", (TitleId) titleId);
                goto Exit;
            }

            using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();

                // Get the list of earned achievements
                ws.StoredProc = "dbo.p_achievement_enum";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_puid", userId);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@i_flag_mask", XOn.XACHIEVEMENT_DETAILS_ACHIEVED);

                WstDataReader reader = ws.Execute();

                // Calculate the earned gamerscore and achievement count

                // CONSIDER: If there was a way to calculate the cred in SQL then we could
                // do this whole operation in a stored procedure.  But the cred per achievement
                // is only available in the XLAST file which means the front door has to make
                // a couple queries.
                while (reader.Read())
                {
                    uint achievementId = (uint)(int)reader["i_achievement_id"];

                    TitleAchievement tach = (TitleAchievement)tcfg.Achievements[achievementId];

                    if (tach != null)
                    {
                        titleGamerScore += tach.Cred;
                        titleAchievements++;
                    }
                }

                reader.Close();

                // Update the title list and settings with these new values
                ws.ClearParameters();

                // Get the list of earned achievements
                ws.StoredProc = "dbo.p_stats_gamerscore_update";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@i_gamerscore", titleGamerScore);
                ws.AddParameter("@i_achievements", titleAchievements);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                reader = ws.Execute();
            }

            // remove gamerscore settings from cache
            ClearGamerscoreFromCache(userId, titleId);

Exit:

            return;
        }

        private static void ClearGamerscoreFromCache(ulong userId, uint titleId)
        {
            byte[][] keys = new byte[4][];
            keys[0] = ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLE_CRED_EARNED, titleId, userId);
            keys[1] = ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED, titleId, userId);
            keys[2] = ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_CRED, XOn.XENON_DASH_TITLE_ID, userId);
            keys[3] = ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED, XOn.XENON_DASH_TITLE_ID, userId);

            Cache.Remove(keys);
        }


        public static void SyncSettings(ulong userId, 
            uint titleId, 
            DateTime clientVersion, 
            ushort startingIndex, 
            UserSetting[] clientSettings, 
            out DateTime serverVersion, 
            out UserSetting[] serverSettings, 
            out ushort totalSettings)
        {
            string      vi = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.profilefd, VirtualInterface.profilefd_int);
            ArrayList   settingsList = null;
            CmdType     cmdType;
            bool        eraseAvatar = false;
            ulong       avatarUser = 0;

            // list of settings we're going to update in cache.
            ArrayList settingsToCache = null;

            serverSettings = null;
            totalSettings = 0;

            // Only request write access if necessary
            if (clientSettings.Length > 0)
                cmdType = CmdType.WRITEONLY_COMMANDTYPE;
            else
                cmdType = CmdType.WRITETHENREAD_COMMANDTYPE;

            // Hack to allow a parent to set a child's profile security settings.
            bool isParentalCall = false;
            if (startingIndex == 0 &&
                clientSettings.Length == 1 &&
                clientSettings[0].SettingId == Xprofile_Permissions_Field_Id &&
                userId != clientSettings[0].UserId)
            {
                xonline.common.user.User target = new xonline.common.user.User();
                target.Load(clientSettings[0].UserId);

                if (target.IsChildOf(userId))
                {
                    // The parent is calling. Hack things so it works.
                    isParentalCall = true;
                }

            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, cmdType))
            {
                ws.StoredProc = "dbo.p_stats_sync_user_settings";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@dt_client_version", clientVersion);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                int j = 0;

                for (int i = 0; i < clientSettings.Length; i++)
                {
                    // make sure the userid is set to the current user
                    if (!isParentalCall)
                    {
                        XRLUtil.VerifyParam(clientSettings[i].UserId == userId, "Settings can only be written for the user making the request!");
                    }

                    SettingInfo sinfo = SettingIds.Item(clientSettings[i].SettingId);

                    if (null == sinfo)
                        continue;

                    // make sure the setting can be written by whoever is calling this
                    if (vi == VirtualInterface.xstatsfd && sinfo.IsConsoleWritable() == false)
                        continue;

                    if (vi == VirtualInterface.xstatsfd_int && sinfo.IsWebWritable() == false)
                        continue;

                    if (clientSettings[i].Source == XOn.XSOURCE_TITLE && sinfo.IsTitleWritable() == false)
                        continue;

                    if (clientSettings[i].ValueLen > sinfo.GetMaxSize())
                        continue;

                    if (clientSettings[i].SettingId == ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1)
                    {
                        uint validationFlags = 0;

                        if (SGInfo.Current.GetPlatformType() != XOn.XPLT_XBOX360)
                        {
                            // The xbox 360 uses a local cache of awards and doesn't necessarily sync up awards
                            // before syncing a manifest which might be wearing them. So if the client is a 360,
                            // skip validation of equipped assets. All other platforms get their award list
                            // from the service, so we can validate everything that they send.
                            validationFlags = ValidateAvatarManifestRequest.XAVATAR_VALIDATE_AVATAR_AWARDS;
                        }

                        // Users is uploading an avatar manifest. Validate that it doesn't contain unpurchased marketplace avatar assets
                        // or awarded avatar assets that have been marked with XAVATAR_DETAILS_NOT_ACHIEVABLE.
                        if (!Avatar.ValidateAvatarManifest(clientSettings[i].UserId, clientSettings[i].Value, validationFlags))
                        {
                            eraseAvatar = true;
                            avatarUser = clientSettings[i].UserId;
                            continue;
                        }
                    }

                    if (clientSettings[i].SettingId == ProfileDefs.XPROFILE_GAMERCARD_ZONE && null != clientSettings[i].Value)
                    {
                        // The client uses this setting as an index into a fixed-sized array when viewing a
                        // gamercard. Some hackers have started changing the setting to invalid values,
                        // which causes other users to crash when an attempt is made to file a complaint against
                        // the hacker. To prevent this, reject invalid values. Valid values are 0-4, inclusive.
                        int value = BitConverter.ToInt32(clientSettings[i].Value, 0);
                        if (value < 0 || value > 4)
                        {
                            Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_REQUEST, "Invalid XPROFILE_GAMERCARD_ZONE setting uploaded for user = {0}: {1}", (Puid) userId, value);
                            continue;
                        }
                    }

                    if (sinfo.IsDatabasePersisted())
                    {
                        ws.AddParameter("@i_setting_id" + j, clientSettings[i].SettingId);
                        ws.AddParameter("@i_title_id" + j, clientSettings[i].Source == XOn.XSOURCE_DEFAULT ? XOn.XENON_DASH_TITLE_ID : titleId);
                        ws.AddParameter(ParamType.INPUT, "@vb_value" + j, (clientSettings[i].ValueLen == 0 ? null : clientSettings[i].Value), (int)clientSettings[i].ValueLen);
                        j++;
                    }
                    
                    // add to the cache list.
                    if (settingsToCache == null) settingsToCache = new ArrayList();
                    settingsToCache.Add(clientSettings[i]);
                }

                WstDataReader reader = ws.Execute();
                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_93, "Unexpected recordset from p_stats_sync_user_settings! " +
                        "Received no results");
                }

                serverVersion = (DateTime)reader["dt_version"];

                if (!reader.NextResult())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_stats_sync_user_settings! " +
                        "Only one resultset returned");
                }

                ushort index = 0;
                while (reader.Read())
                {
                    index++;

                    if (index < startingIndex)
                        continue;

                    if (settingsList == null) settingsList = new ArrayList();

                    UserSetting setting = new UserSetting();

                    setting.UserId = userId;
                    setting.SettingId = (uint)(int)reader["i_setting_id"];
                    setting.Source = (titleId == XOn.XENON_DASH_TITLE_ID ? XOn.XSOURCE_DEFAULT : XOn.XSOURCE_TITLE);

                    SqlBinary sqlbin = reader.GetSqlBinary(reader.GetOrdinal("vb_value"));
                    if (sqlbin.IsNull)
                    {
                        setting.ValueLen = 0;
                        setting.Value = null;
                    }
                    else
                    {
                        setting.ValueLen = (ushort)sqlbin.Length;
                        setting.Value = sqlbin.Value;
                    }

                    settingsList.Add(setting);

                    if (settingsList.Count >= XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT)
                        break;
                }

                if (settingsList != null)
                {
                    serverSettings = new UserSetting[settingsList.Count];
                    settingsList.CopyTo(serverSettings);
                }

                if (settingsToCache != null)
                {
                    byte[][] keys = new byte[settingsToCache.Count][];
                    byte[][] values = new byte[settingsToCache.Count][];
                    
                    for (int iKey = 0; iKey < keys.Length; iKey++)
                    {
                        UserSetting setting = (UserSetting)(settingsToCache[iKey]);
                        keys[iKey] = ProfileDefs.BuildCacheKey(
                            setting.SettingId,
                            (setting.Source == XOn.XSOURCE_DEFAULT) ? XOn.XENON_DASH_TITLE_ID : titleId,
                            setting.UserId);
                        values[iKey] = (setting.ValueLen == 0) ? ProfileDefs.CacheNoValue : setting.Value;
                    }

                    Cache.SetData(keys, values, new uint[keys.Length], new uint[keys.Length]);
                }

                totalSettings = index;
            }

            if (eraseAvatar)
            {
                // If validation failed, it means the manifest is improperly formed or the
                // the user is attempting to equip an asset they're not allowed to use.
                // In either case, ValidateAvatarManifest has already logged an error.
                // In response we want to zero out the manifest so the user has to create a
                // new avatar.
                //
                // We erase the manifest after syncing other settings so that the zero manifest
                // is sent back as part of the next response. If we sent it back in the current
                // response, the client would discard it because it was a setting that was
                // in the client request and the client always wins setting conflicts.
                //
                // Subtract 10 ms from the version we return so there's no chance that the
                // blank manifest gets the same timestamp as the version we're returning.
                // We'd rather send some duplicates back next time than skip sending the manifest.
                serverVersion = serverVersion.Subtract(new TimeSpan(0, 0, 0, 0, 10));
                Avatar.EraseAvatarManifest(avatarUser);
            }
        }


        public static HResult SyncTitles(
            ulong           userId,
            string[]        locales,
            DateTime        clientVersion,
            ushort          startingIndex,
            UserTitle[]     clientTitles,
            out DateTime    serverVersion,
            out UserTitle[] serverTitles,
            out ushort      totalTitles)
        {
            WSClient        ws;
            ArrayList       titleList = null;
            CmdType         cmdType;
            DateTime[]      maxTimes;

            // Default the version that the client sends.  In the case of an
            // error this is still correct and is better than DateTime.Min
            // which cannot be converted to a UTC time for the wire.
            serverVersion = clientVersion;
            serverTitles = null;
            totalTitles = 0;

            // Only request write access if necessary
            if (clientTitles.Length > 0)
            {
                cmdType = CmdType.WRITEONLY_COMMANDTYPE;

                // if we're writing, we need to remove the cached entry from cache.
                Cache.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLES_PLAYED, XOn.XENON_DASH_TITLE_ID, userId));
            }
            else
            {
                cmdType = CmdType.WRITETHENREAD_COMMANDTYPE;
            }

            // Calculate the maximum possible last played time based on the
            // sequences and Last Played Online times in the client request.
            // These max times are used to interleave the title list with
            // those titles already in the database.  The code below makes
            // the assumption that the list is ordered and doesn't check
            // the sequence numbers.

            // Any Last Played Time before this date will be considered
            // bogus and we'll use the greatest time seen so far.  This
            // magic number is needed because the client will send a 0
            // FILETIME which is converted into a DateTime around 1753,
            // so we'll have one magic number or another.  This one is
            // easier to understand.
            DateTime minPossibleTime = new DateTime(2002, 11, 15);
            DateTime maxTime = DateTime.UtcNow;

            maxTimes = new DateTime[clientTitles.Length];

            for (int i = maxTimes.Length - 1; i >= 0; i--)
            {
                if (clientTitles[i].LastPlayed > minPossibleTime &&
                    clientTitles[i].LastPlayed < maxTime)
                {
                    maxTime = clientTitles[i].LastPlayed;
                }

                maxTimes[i] = maxTime;
            }

            using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, cmdType))
            {
                ws.StoredProc = "dbo.p_stats_sync_user_titles";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@dt_client_version", clientVersion);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                int paramNum = 0;

                for (int i = 0; i < clientTitles.Length; i++)
                {
                    // Make sure there's an XLAST file for the title
                    xonline.common.config.TitleConfig tcfg = xonline.common.config.TitleConfig.GetTitle(clientTitles[i].TitleId, false /* throwWhenNotFound */);

                    if (null == tcfg)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_NO_XLAST_IN_TITLE_SYNC, "Error loading title config for titleId = " + (TitleId) clientTitles[i].TitleId + ". Skipping sync of title.");
                        continue;
                    }

                    ws.AddParameter("@i_title_id" + paramNum, clientTitles[i].TitleId);
                    ws.AddParameter("@dt_last_played" + paramNum, clientTitles[i].LastPlayed);
                    ws.AddParameter("@i_sequence" + paramNum, clientTitles[i].Sequence);
                    ws.AddParameter("@dt_max_time" + paramNum, maxTimes[i]);

                    paramNum++;

                    // Ignore client values of cred and achievements.  Those
                    // will be updated when an achievement is earned.
                }

                WstDataReader reader = ws.Execute();

                ushort index = 0;

                while (reader.Read())
                {
                    index++;

                    if (index < startingIndex)
                        continue;

                    if (titleList == null)
                        titleList = new ArrayList();

                    UserTitle title = new UserTitle();

                    title.TitleId              = (uint)(int)reader["i_title_id"];
                    title.NumCreds             = (uint)(int)reader["i_creds"];
                    title.NumAchievements      = (ushort)(int)reader["i_achievements"];
                    title.Sequence             = (uint)(int)reader["i_sequence"];
                    title.LastPlayed           = (DateTime)reader["dt_last_logon"];

                    // fill in other data from title config stuff
                    xonline.common.config.TitleConfig tcfg = xonline.common.config.TitleConfig.GetTitle(title.TitleId, false /* throwWhenNotFound */);

                    if (null == tcfg)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_12, "Error loading title config for titleId = " + (TitleId) title.TitleId + ". Title information will not be returned to the client.");
                        continue;
                    }

                    title.TitleName = tcfg.Names[locales];
                    title.TotalAchievements = (ushort)tcfg.Achievements.Count;
                    title.TotalCred = tcfg.MaxCred;

                    titleList.Add(title);

                    if (titleList.Count >= XOn.XONLINE_MAX_SETTING_COUNT)
                        break;
                }

                if (titleList != null)
                {
                    serverTitles = new UserTitle[titleList.Count];
                    titleList.CopyTo(serverTitles);
                }

                totalTitles = index;

                // Get the 2nd rowset, the "Synced As Of" time

                if (!reader.NextResult())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_95, "Unexpected recordset from p_stats_sync_user_titles! " +
                        "Only one resultset returned");
                }

                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_96, "Unexpected recordset from p_stats_sync_user_titles! " +
                        "Received no last sync time.");
                }

                serverVersion = reader.GetDateTime(0);
            }

            return HResult.S_OK;
        }


        public static void SyncAchievements(
                ulong userId,
                uint titleId,
                string[] locales,
                DateTime clientVersion,
                ushort startingIndex,
                Achievement[] clientAchievements,
                bool isServerPort,
                out DateTime serverVersion,
                out Achievement[] serverAchievements,
                out ushort totalAchievements)
        {
            WSClient    ws;
            ArrayList   achievementList = null;
            CmdType     cmdType;
            DateTime[]  maxTimes;
            int         platformType = 0;

            // Default the version that the client sends.  In the case of an
            // error this is still correct and is better than DateTime.Min
            // which cannot be converted to a UTC time for the wire.
            serverVersion = clientVersion;
            serverAchievements = null;
            totalAchievements = 0;

            TitleConfig tcfg = TitleConfig.GetTitle(titleId, false /* throwOnNotFound */);

            if (null == tcfg)
            {
                Xom.NtEvent(XEvent.Id.STATS_CONFIG_13, "Error loading title config for titleId = " + (TitleId) titleId + ". Achievements for this title will not be written to the server profile.");
                goto Exit;
            }

            // Calculate the maximum possible last played time based on the
            // sequences and Last Played Online times in the client request.
            // These max times are used to interleave the title list with
            // those titles already in the database.  The code below makes
            // the assumption that the list is ordered and doesn't check
            // the sequence numbers.

            // Any Last Played Time before this date will be considered
            // bogus and we'll use the greatest time seen so far.  This
            // magic number is needed because the client will send a 0
            // FILETIME which is converted into a DateTime around 1753,
            // so we'll have one magic number or another.  This one is
            // easier to understand.
            DateTime minPossibleTime = new DateTime(2002, 11, 15);
            DateTime maxTime = DateTime.UtcNow;

            maxTimes = new DateTime[clientAchievements.Length];

            for (int i = maxTimes.Length - 1; i >= 0; i--)
            {
                // Only use time if it's valid and the achievement says it was
                // earned while online.
                if ((0 != (clientAchievements[i].Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE)) &&
                    clientAchievements[i].Achieved > minPossibleTime &&
                    clientAchievements[i].Achieved < maxTime)
                {
                    maxTime = clientAchievements[i].Achieved;
                }

                maxTimes[i] = maxTime;
            }

            if (clientAchievements.Length > 0)
            {

                if (SGInfo.IsActiveAuth())
                {
                    platformType = XOn.XPLT_WEB;
                }
                else
                {
                    platformType = SGInfo.Current.GetPlatformType();

                    if (SGInfo.IsFromLiveCache())
                    {
                        string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                        if (!String.IsNullOrEmpty(OnBehalfHeader))
                        {
                            platformType = int.Parse(OnBehalfHeader);
                        }
                    }
                }
				
                switch (platformType)
                {
                    case XOn.XPLT_XBOX1:
						
                        // Achievement Requests shouldn't be from XBox 1
                        throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.XBOX_ACHIEVEMENTS_NOT_SUPPORTED, "Achievements cannot be written from Xbox 1 for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                    case XOn.XPLT_XBOX360:
                        // Check for 360 Achievement Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.Xbox360])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.XBOX360_ACHIEVEMENTS_NOT_SUPPORTED, "The Title does not support Xbox 360 Achievements for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                        }
                        break;
                    case XOn.XPLT_PC:
                        // Check for PC Achievement Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.PC])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.PC_ACHIEVEMENTS_NOT_SUPPORTED, "The Title does not support PC Achievements for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                        }
                        break;
                    case XOn.XPLT_MOBILE:
                        // Check for Windows Mobile Achievement Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.Mobile])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.MOBILE_ACHIEVEMENTS_NOT_SUPPORTED, "The Title does not support Windows Mobile Achievements for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                        }
                        break;			
                    case XOn.XPLT_WEB_GAMES:
                        // Check for Web Games Achievement Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.WebGames])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.WEB_GAMES_ACHIEVEMENTS_NOT_SUPPORTED, "The Title does not support Web Game Achievements for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                        }
                        break;								
                    case XOn.XPLT_INTERNAL:
                    default:
                        // Internal Request
                        throw new XRLException(HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED, XEvent.Id.UNKNOWN_PLATFORM_ACHIEVEMENTS_NOT_SUPPORTED, "The Title does not support Unknown Platform for TitleID 0x" + titleId.ToString("x") + " for User 0x" + userId.ToString("x"));
                }
            }

            // Only request write access if necessary
            if (clientAchievements.Length > 0)
                cmdType = CmdType.WRITEONLY_COMMANDTYPE;
            else
                cmdType = CmdType.WRITETHENREAD_COMMANDTYPE;

            using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, cmdType))
            {
                ws.StoredProc = "dbo.p_stats_sync_user_achievements";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_puid", userId);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@dt_client_version", clientVersion);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@bi_machine_puid", SGInfo.Current.MachineId);

                int paramNum = 0;

                for (int i = 0; i < clientAchievements.Length; i++)
                {
                    if (!tcfg.Achievements.Contains(clientAchievements[i].AchievementId))
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_14, "The SyncAchievements request contains an unknown achievement. It will not be written to the server profile. userId = {0}, achievement id 0x{1:x}, titleId = {2}", (Puid) userId, clientAchievements[i].AchievementId, (TitleId) titleId);
                        continue;
                    }

                    // Only earned achievements are written to the database
                    if (0 == (clientAchievements[i].Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED))
                        continue;

                    ws.AddParameter("@i_achievement_id" + paramNum, (int)clientAchievements[i].AchievementId);
                    ws.AddParameter("@dt_achieved" + paramNum, clientAchievements[i].Achieved);
                    ws.AddParameter("@i_sequence" + paramNum, (int)clientAchievements[i].Sequence);
                    ws.AddParameter("@i_flags" + paramNum, Achievement.SetPlatformTypeInFlags(clientAchievements[i].Flags, platformType));
                    ws.AddParameter("@dt_max_time" + paramNum, maxTimes[i]);

                    paramNum++;
                }

                WstDataReader reader = ws.Execute();

                ushort index = 0;

                while (reader.Read())
                {
                    index++;

                    if (index < startingIndex)
                        continue;

                    if (achievementList == null)
                        achievementList = new ArrayList();

                    Achievement achievement = new Achievement();

                    achievement.AchievementId = (uint)(int)reader["i_achievement_id"];
                    achievement.Achieved = (DateTime)reader["dt_achieved"];
                    achievement.Sequence = (uint)(int)reader["i_sequence"];
                    achievement.Flags = (int)reader["i_flags"];

                    TitleAchievement tach = (TitleAchievement)tcfg.Achievements[achievement.AchievementId];

                    if (null == tach)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_15, "The server profile contains an unknown achievement. It will not be returned to the caller.  userId = {0}, achievement id 0x{1:x}, titleId = {2}", (Puid) userId, achievement.AchievementId, (TitleId) titleId);
                        continue;
                    }

                    achievement.Type = (byte)tach.Type;
                    achievement.Cred = tach.Cred;
                    achievement.ImageId = tach.ImageId;
                    achievement.Title = tach.Title[locales];
                    achievement.Description = tach.Description[locales];
                    achievement.HowTo = tach.Unachieved[locales];
                    achievement.NextIds = tach.NextIds;
                    achievement.ReplaceIds = tach.ReplaceIds;

                    achievementList.Add(achievement);

                    if (achievementList.Count >= XOn.XONLINE_MAX_ACHIEVEMENTS)
                        break;
                }

                if (achievementList != null)
                {
                    serverAchievements = new Achievement[achievementList.Count];
                    achievementList.CopyTo(serverAchievements);
                }

                totalAchievements = index;

                if (!reader.NextResult())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_97, "Unexpected recordset from p_stats_sync_user_achievements! " +
                        "Only one resultset returned");
                }

                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_98, "Unexpected recordset from p_stats_sync_user_achievements! " +
                        "Received no last sync time.");
                }

                serverVersion = (DateTime)reader["dt_version"];
            }

        Exit:

            return;
        }


        public static void SyncAvatarAssets(
                ulong userId,
                uint titleId,
                string[] locales,
                DateTime clientVersion,
                ushort startingIndex,
                AvatarAsset[] clientAvatarAssets,
                bool isServerPort,
                out DateTime serverVersion,
                out AvatarAsset[] serverAvatarAssets,
                out ushort totalAvatarAssets,
                out uint moreAvatarAssetsPending)
        {
            WSClient ws;
            ArrayList avatarAssetList = null;
            CmdType cmdType;
            int platformType = 0;

            // Default the version that the client sends.  In the case of an
            // error this is still correct and is better than DateTime.Min
            // which cannot be converted to a UTC time for the wire.
            serverVersion = clientVersion;
            serverAvatarAssets = null;
            totalAvatarAssets = 0;
            moreAvatarAssetsPending = 0;

            TitleConfig tcfg = TitleConfig.GetTitle(titleId, false /* throwOnNotFound */);

            if (null == tcfg)
            {
                Xom.NtEvent(XEvent.Id.STATS_CONFIG_13, "Error loading title config for titleId = {0}. Avatar Assets for this title will not be written to the server profile.", (TitleId) titleId);
                goto Exit;
            }

            // Calculate the maximum possible last played time based on the
            // sequences and Last Played Online times in the client request.
            // These max times are used to interleave the title list with
            // those titles already in the database.  The code below makes
            // the assumption that the list is ordered and doesn't check
            // the sequence numbers.

            // Any Last Played Time before this date will be considered
            // bogus and we'll use the greatest time seen so far.  This
            // magic number is needed because the client will send a 0
            // FILETIME which is converted into a DateTime around 1753,
            // so we'll have one magic number or another.  This one is
            // easier to understand.
            DateTime minPossibleTime = new DateTime(2002, 11, 15);
            DateTime maxTime = DateTime.UtcNow;

            for (int i = clientAvatarAssets.Length - 1; i >= 0; i--)
            {
                // Only use time if it's valid and the asset data says it was
                // earned while online.
                if ((0 != (clientAvatarAssets[i].Flags & XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE)) &&
                    clientAvatarAssets[i].Awarded > minPossibleTime &&
                    clientAvatarAssets[i].Awarded < maxTime)
                {
                    maxTime = clientAvatarAssets[i].Awarded;
                }

                clientAvatarAssets[i].Awarded = maxTime;
            }

            if (clientAvatarAssets.Length > 0)
            {

                if (SGInfo.IsActiveAuth())
                {
                    platformType = XOn.XPLT_WEB;
                }
                else
                {
                    platformType = SGInfo.Current.GetPlatformType();

                    if (SGInfo.IsFromLiveCache())
                    {
                        string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                        if (!String.IsNullOrEmpty(OnBehalfHeader))
                        {
                            platformType = int.Parse(OnBehalfHeader);
                        }
                    }
                }

                switch (platformType)
                {
                    case XOn.XPLT_XBOX1:
                        // Avatar Asset Requests shouldn't be from XBox 1
                        throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.XBOX_AVATAR_ASSETS_NOT_SUPPORTED,
                            String.Format("Avatar Assets cannot be written from Xbox 1 for TitleID 0x{0:x8} for User 0x{1:x8}", titleId, userId));
                    case XOn.XPLT_XBOX360:
                        // Check for 360 Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.Xbox360])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.XBOX360_AVATAR_ASSETS_NOT_SUPPORTED,
                                String.Format("The Title does not support Xbox 360 Avatar Assets for TitleID 0x{0:x8} for User 0x{1:x8}", titleId, userId));
                        }
                        break;
                    case XOn.XPLT_PC:
                        // Check for PC Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.PC])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.PC_AVATAR_ASSETS_NOT_SUPPORTED,
                                String.Format("The Title does not support PC Avatar Assets for TitleID 0x{0:x8} for User 0x{1:x8}", titleId, userId));
                        }
                        break;
                    case XOn.XPLT_MOBILE:
                        // Check for Windows Mobile Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.Mobile])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.MOBILE_AVATAR_ASSETS_NOT_SUPPORTED, 
                                String.Format("The Title does not support Mobile Avatar Assets for TitleID 0x{0:x8} for User 0x{1:x8}", titleId, userId));
                        }
                        break;			
                    case XOn.XPLT_WEB_GAMES:
                        // Check for Web Games Platform
                        if (!tcfg.Platforms[(int)TitleConfig.SupportedPlatforms.WebGames])
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.WEB_GAMES_AVATAR_ASSETS_NOT_SUPPORTED, 
                                String.Format("The Title does not support Web Game Avatar Assets for TitleID 0x{0:x8} for User 0x{1:x8}", titleId, userId));
                        }
                        break;								
                    case XOn.XPLT_INTERNAL:
                    default:
                        // Internal Request
                        throw new XRLException(HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED, XEvent.Id.UNKNOWN_PLATFORM_AVATAR_ASSETS_NOT_SUPPORTED,
                            String.Format("The Title does not support Unknown Platform {0} for TitleID 0x{1:x8} for User 0x{2:x8}", platformType, titleId, userId));
						
                }
            }

            // Only request write access if necessary
            if (clientAvatarAssets.Length > 0)
            {
                cmdType = CmdType.WRITEONLY_COMMANDTYPE;
            }
            else
            {
                cmdType = CmdType.WRITETHENREAD_COMMANDTYPE;
            }

            using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, cmdType))
            {
                ws.StoredProc = "dbo.p_stats_sync_user_avatar_assets";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@dt_client_version", clientVersion);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@bi_machine_puid", SGInfo.Current.MachineId);

                int paramNum = 0;

                for (int i = 0; i < clientAvatarAssets.Length; i++)
                {
                    if (!tcfg.AvatarAssets.Contains(new TitleAvatarAssetKey(titleId, clientAvatarAssets[i].AvatarAssetOrdinal, clientAvatarAssets[i].BodyTypeMask)))
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_14, "The SyncAvatarAssets request contains an unknown avatar asset. It will not be written to the server profile. userId {0}, avatar asset ordinal 0x{1:x}, body type mask 0x{2:x}, titleId = {3}", (Puid) userId, clientAvatarAssets[i].AvatarAssetOrdinal, clientAvatarAssets[i].BodyTypeMask, (TitleId) titleId);
                        continue;
                    }

                    int status = (int)(clientAvatarAssets[i].Flags & XOn.XAVATAR_DETAILS_STATUS_MASK);

                    // The client can only send 'achieved' or 'achieved online'.
                    // 'not achievable' or 'was not achievable' can be set on the server.
                    // We ignore the colorizable bit in this check. It's only used by the client.
                    if (( (status & ~XOn.XAVATAR_DETAILS_COLORIZABLE) != XOn.XAVATAR_DETAILS_ACHIEVED) &&
                        ( (status & ~XOn.XAVATAR_DETAILS_COLORIZABLE) != (XOn.XAVATAR_DETAILS_ACHIEVED | XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE))
                        )
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_14, "The SyncAvatarAssets request contains an avatar asset with invalid status 0x{0:x}. It will not be written to the server profile. userId = {1}, avatar asset ordinal 0x{2:x}, body type mask 0x{3:x}, titleId {4}", status, (Puid) userId, clientAvatarAssets[i].AvatarAssetOrdinal, clientAvatarAssets[i].BodyTypeMask, (TitleId) titleId);
                        continue;
                    }

                    // Only earned avatar assets are written to the database
                    if (0 == (clientAvatarAssets[i].Flags & XOn.XAVATAR_DETAILS_ACHIEVED))
                    {
                        continue;
                    }

                    ws.AddParameter("@i_asset_ordinal" + paramNum, (int)clientAvatarAssets[i].AvatarAssetOrdinal);
                    ws.AddParameter("@i_body_type_mask" + paramNum, (int)clientAvatarAssets[i].BodyTypeMask);
                    ws.AddParameter("@dt_awarded" + paramNum, clientAvatarAssets[i].Awarded);
                    ws.AddParameter("@i_sequence" + paramNum, (int)clientAvatarAssets[i].Sequence);
                    ws.AddParameter("@i_status" + paramNum, status);
                    
                    ws.AddParameter("@i_platform" + paramNum, (AvatarAsset.MapPlatformTypeFlags(platformType)));

                    paramNum++;
                }

                WstDataReader reader = ws.Execute();

                ushort index = 0;

                while (reader.Read())
                {
                    index++;

                    if (index < startingIndex)
                    {
                        continue;
                    }

                    if (avatarAssetList == null)
                    {
                        avatarAssetList = new ArrayList();
                    }

                    AvatarAsset avatarAsset = new AvatarAsset();

                    avatarAsset.AvatarAssetOrdinal = (uint)(int)reader["i_asset_ordinal"];
                    avatarAsset.BodyTypeMask = (byte)(int)reader["i_body_type_mask"];
                    avatarAsset.Awarded = (DateTime)reader["dt_awarded"];
                    avatarAsset.Sequence = (uint)(int)reader["i_sequence"];
                    int status = (int)reader["i_status"];

                    TitleAvatarAsset tass = (TitleAvatarAsset)tcfg.AvatarAssets[new TitleAvatarAssetKey(titleId, avatarAsset.AvatarAssetOrdinal, avatarAsset.BodyTypeMask)];

                    if (null == tass)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_15, "The server profile contains an unknown avatar asset. It will not be returned to the caller.  userId = {0}, avatar asset ordinal 0x{1:x}, body type mask 0x{2:x}, titleId = {3}", (Puid) userId, avatarAsset.AvatarAssetOrdinal, avatarAsset.BodyTypeMask, (TitleId) titleId);
                        continue;
                    }

                    // status values must have either 'achieved' or 'achieved' + 'achieved online'.
                    // additionally they can have one of 'not achievable' or 'was not achievable' but not both.
                    if (((status & XOn.XAVATAR_DETAILS_ACHIEVED) != XOn.XAVATAR_DETAILS_ACHIEVED) ||
                        ((status & (XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE | XOn.XAVATAR_DETAILS_WAS_NOT_ACHIEVABLE)) == (XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE | XOn.XAVATAR_DETAILS_WAS_NOT_ACHIEVABLE))
                        )
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_15, "The server profile contains an avatar asset with invalid status 0x{0:x}. It will not be written to the server profile. userId = {1}, avatar asset ordinal 0x{2:x}, body type mask 0x{3:x}, title id {4}", status, (Puid) userId, avatarAsset.AvatarAssetOrdinal, avatarAsset.BodyTypeMask, (TitleId) titleId);
                        continue;
                    }

                    // When an asset is marked with XAVATAR_DETAILS_NOT_ACHIEVABLE, we keep
                    // the achieved and achieved online flags in case we want to reset the
                    // XAVATAR_DETAILS_NOT_ACHIEVABLE, but we don't want to return the achieved flags to
                    // the client - to clients, the asset is considered unachieved.
                    if ((status & XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE) != 0)
                    {
                        status = (int)XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE;
                    }

                    avatarAsset.Flags = status | ((int)reader["i_platform"]);
                    avatarAsset.ImageId = tass.ImageId;
                    avatarAsset.Title = tass.Title[locales];
                    avatarAsset.Description = tass.Description[locales];
                    avatarAsset.HowTo = tass.Unachieved[locales];
                    avatarAsset.BodyComponent = tass.Id.BodyComponent;
                    avatarAsset.SubCategory = tass.SubCategory;

                    avatarAssetList.Add(avatarAsset);

                    if (avatarAssetList.Count >= XOn.XONLINE_MAX_AVATAR_ASSETS)
                    {
                        // We've filled the response array. If there are more rows, set the flag that
                        // indicates that
                        if (reader.Read())
                        {
                            moreAvatarAssetsPending = 1;
                        }
                        break;
                    }
                }

                if (avatarAssetList != null)
                {
                    serverAvatarAssets = new AvatarAsset[avatarAssetList.Count];
                    avatarAssetList.CopyTo(serverAvatarAssets);
                }

                totalAvatarAssets = index;

                if (!reader.NextResult())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_97,
                        "Unexpected recordset from p_stats_sync_user_avatar_assets! Only one resultset returned");
                }

                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_98,
                        "Unexpected recordset from p_stats_sync_user_avatar_assets! Received no last sync time.");
                }

                serverVersion = (DateTime)reader["dt_version"];
            }

        Exit:

            return;
        }


        public static void UploadConsoleAuditList(
                ulong userId,
                ConsoleIdData uploadingConsoleId,
                ConsoleIdData signingConsoleId,
                ConsoleIdData[] consoleIdList)
        {
            WSClient ws;

            if (consoleIdList.Length == 0)
            {
                // The console that signed the console list should always be in the list.
                throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_EMPTY, XEvent.Id.CONSOLE_AUDIT_LIST_EMPTY,
                    String.Format("Console history list uploaded by console {0:x}, signed by console 0x{1:x}, for user 0x{2:x} is empty", SGInfo.Current.MachineId, signingConsoleId, userId));
            }
            else
            {
                int platformType = SGInfo.Current.GetPlatformType();

                switch (platformType)
                {
                    case XOn.XPLT_XBOX1:
                        // Console ids shouldn't be uploaded from XBox 1
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from Xbox 1 for user 0x{0:x}", userId));
                    case XOn.XPLT_XBOX360:
                        break;
                    case XOn.XPLT_PC:
                        // Console ids shouldn't be uploaded from PC
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from PC for user 0x{0:x}", userId));
                    case XOn.XPLT_INTERNAL:
                    default:
                        // Internal Request
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from unknown platform {0} for user 0x{1:x}", platformType, userId));
                }
            }

            using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_stats_upload_console_audit_list";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@bi_uploading_machine_console_id", ConsoleIdData.GetDecimalValue(uploadingConsoleId.ConsoleId));
                ws.AddParameter("@bi_uploading_machine_puid", SGInfo.Current.MachineId);
                ws.AddParameter("@bi_signing_machine_console_id", ConsoleIdData.GetDecimalValue(signingConsoleId.ConsoleId));

                // Add the console list using a table-valued parameter
                DataTable dtConsoleIdList = new DataTable();
                dtConsoleIdList.Columns.Add("bi_console_id", typeof(long));
                dtConsoleIdList.Columns.Add("i_ordinal", typeof(byte));
                foreach (ConsoleIdData consoleId in consoleIdList)
                {
                    dtConsoleIdList.Rows.Add(ConsoleIdData.GetDecimalValue(consoleId.ConsoleId), dtConsoleIdList.Rows.Count);
                }
                ws.Parameters.AddWithValue("@console_audit_list", dtConsoleIdList);

                ws.ExecuteNonQuery();
            }
        }

        public static bool CheckPrivacy(ulong viewerId, ulong targetId, PrivacySetting setting)
        {
            IVirtualInterfaceInfo vInt = Config.GetVirtualInterface("privacy_int");
            IPEndPoint endpoint = new IPEndPoint(vInt.IPAddress, vInt.Port);

            PrivacyClientInternal internalClient = new PrivacyClientInternal(endpoint, Component.xstatsfd);

            PrivacyCheckRequest req = new PrivacyCheckRequest(viewerId, targetId, setting);

            return internalClient.CheckPrivacy(new PrivacyCheckRequest[] { req })[0];
        }


        public static HResult CheckPermissions(ulong userId, ulong forUserId, uint enforcePerms, ref Friend[] friends)
        {
            HResult hr = HResult.S_OK;

            if (userId == forUserId || enforcePerms == 0)
            {
                // users can always see their own stuff..
                return HResult.S_OK;
            }

            //
            // check this user's ability to see other people's stuff
            //

            if ((enforcePerms & XOn.XPROFILE_SETTING_ENFORCE_ACTIVITY) != 0)
            {
                if (!SGInfo.HasPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING)) // They can't view all profiles
                {
                    if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY)) // The are allowed to view friends' profiles
                    {
                        if (!ProfileUtil.IsFriendInList(userId, forUserId, ref friends, true)) // But the target isn't a friend
                        {
                            Xom.Trace(
                                XomAreaName.ctxDebug, 
                                LogLevel.L_NORMAL, 
                                "User 0x{0:x} attempted to read a non-friend's profile (0x{0:x}) but has the XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY bit set!",
                                userId,
                                forUserId);

                            // not a true friend, they can't see this user's settings
                            hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                            goto end;
                        }
                    }
                    else // Can't view friends profiles either, no profiles allowed
                    {
                        // user has said they shouldn't be able to view anyone else's profile
                        Xom.Trace(
                            XomAreaName.ctxDebug, 
                            LogLevel.L_NORMAL, 
                            "User 0x{0:x} doesn't have the XOn.XPRIVILEGE_PROFILE_VIEWING_EVERYONE bit set!",
                            userId);

                        hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                        goto end;
                    }
                }

                if (!CheckPrivacy(userId, forUserId, PrivacySetting.GameHistory)) // User can't see target's activity
                {
                    Xom.Trace(
                        XomAreaName.ctxDebug,
                        LogLevel.L_NORMAL,
                        "User 0x{0:x} attempted to read user 0x{1:x}'s profile, but the target's privacy settings did not allow it.",
                        userId,
                        forUserId);

                    // not a true friend, they can't see this user's settings
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                    goto end;
                }
            }

           if ((enforcePerms & XOn.XPROFILE_SETTING_ENFORCE_UCC) != 0)
           {
               if (!SGInfo.HasPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT)) // User can't view everybody's UCC 
               {
                   if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY)) // User can view friends' UCC
                   {
                       if (!ProfileUtil.IsFriendInList(userId, forUserId, ref friends, true)) // But the target isn't a friend
                       {
                           Xom.Trace(
                               XomAreaName.ctxDebug,
                               LogLevel.L_NORMAL,
                               "User 0x{0:x} attempted to read a non-friend's profile (0x{0:x}) but has the XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY bit set!",
                               userId,
                               forUserId);

                           // not a true friend, they can't see this user's settings
                           hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                           goto end;
                       }
                   }
                   else // Can't view friends' UCC either, no UCC allowed
                   {
                       // user has said they shouldn't be able to view anyone else's profile
                       Xom.Trace(
                           XomAreaName.ctxDebug,
                           LogLevel.L_NORMAL,
                           "User 0x{0:x} doesn't have the XOn.XPRIVILEGE_PROFILE_VIEWING_EVERYONE bit set!",
                           userId);
                       
                       hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                       goto end;
                   }
               }
            }
end:

            return hr;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\PlatformVisibleLeaderboardData.cs ===
/*
 * Copyright (c) 2011 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * XRLGetPlatformLeaderboards.cs
 * 
 * Implementation of XRLGetPlatformLeaderboards REST requests
 * 
 * */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Net;
using System.Xml;
using System.Globalization;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;
using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Rest.Utilities;

namespace xonline.server.stats.fd 
{
    public class PlatformVisibleLeaderboardDataRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new PlatformVisibleLeaderboardData((string)requestContext.RouteData.Values["titleid"]);
        }
    }    

    // REST API object for Platform Visible Leaderboard metadata
    public class PlatformVisibleLeaderboardData : IHttpHandler
    {
        // private data
        private string _titleId;
        
        public PlatformVisibleLeaderboardData(string titleid)
        {
            _titleId = titleid;
        }

        public void ParseRequest(HttpContext ctx, out UInt32 titleId, out CultureInfo ci)
        {
            titleId = 0;
            ci = StatsFdUtil.GetCultureInfoFromRequestHeader(ctx);
            titleId = UInt32.Parse(_titleId);
        }

        // Process
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            ErrorInfo error = null;
            PlatformLeaderboardResponse response = null;
            UInt32 titleId;
            CultureInfo ci;

            // bump perf counters...
            StatisticsCounters.Counters.PlatformLeaderboardTotal.Increment();
            StatisticsCounters.Counters.PlatformLeaderboardCurrent.Increment();
            StatisticsCounters.Counters[_titleId].PlatformLeaderboardCurrent.Increment();
            StatisticsCounters.Counters[_titleId].PlatformLeaderboardTotal.Increment();
            StatisticsCounters.Counters.PlatformLeaderboardCallsPerSecond.Increment();

            try
            {
                try
                {
                    ParseRequest(ctx, out titleId, out ci);
                }
                catch
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                try
                {
                    StatDb db = new StatDb();
                    response = db.EnumPlatformVisibleLeaderboardsForTitleIdAndLocale(titleId, ci.Name);

                    if (response != null)
                    {
                        RestUtilities.SerializeResponse(ctx, response);
                    }
                    else
                    {
                        StatisticsCounters.Counters.PlatformLeaderboardRequestForNonPlatformLeaderboard.Increment();
                        StatisticsCounters.Counters[_titleId].PlatformLeaderboardRequestForNonPlatformLeaderboard.Increment();

                        hr = RestErrorHandler.InvalidTitleError;
                        error = new ErrorInfo(hr, "No Platform Visible Leaderboard Content was found for this titleId", HttpStatusCode.NoContent);

                        PlatformVisibleLeaderboardData.SetHttpErrorStatusCode(ctx, error); // an invalid titleID was provided to this API
                    }
                }
                catch
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Could not read platform visible meta data", HttpStatusCode.InternalServerError); // should never happen!
                    throw;
                }
            }
            catch
            {
                StatisticsCounters.Counters.PlatformLeaderboardFailedTotal.Increment();
                StatisticsCounters.Counters[_titleId].PlatformLeaderboardFailedTotal.Increment();

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(XomAreaName.statslog,
                    @"PVLMD|{0}|{1}",
                    hr,
                    _titleId);

                StatisticsCounters.Counters.PlatformLeaderboardCurrent.Decrement();
                StatisticsCounters.Counters[_titleId].PlatformLeaderboardCurrent.Decrement();
            }
        } 
       
        // IsReusable
        // Returns if this object can be reused. Since the object holds state variables, this method always returns false
        public bool IsReusable
        {
            get { return false; }
        }

        /// <summary>
        /// Sets the HTTP status code but does not send a response body.
        /// Note: Consider refactoring this into the Util class.
        /// </summary>
        internal static void SetHttpErrorStatusCode(HttpContext ctx, ErrorInfo resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);

            ctx.Response.StatusCode = (int)resp.status;
            ctx.Response.ContentType = contentType;
            ctx.Response.TrySkipIisCustomErrors = true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\PlatformVisibleLeaderboardDataForUser.cs ===
/*
 * Copyright (c) 2011 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * XRLGetPlatformLeaderboards.cs
 * 
 * Implementation of XRLGetPlatformLeaderboards REST requests
 * 
 * */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Net;
using System.Xml;
using System.Xml.Serialization;
using System.Globalization;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;
using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Rest.Utilities;

namespace xonline.server.stats.fd 
{
    public class PlatformVisibleLeaderboardDataForUserRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new PlatformVisibleLeaderboardDataForUser
                (
                (string)requestContext.RouteData.Values["titleid"],
                (string)requestContext.RouteData.Values["lbid"],
                (string)requestContext.RouteData.Values["xuid"]
                );
        }
    }

    public class RankComparer : IComparer
    {
        int IComparer.Compare(Object x, Object y)
        {
            StatsRow val1 = (StatsRow)x;
            StatsRow val2 = (StatsRow)y;
            return (int)(val1.Rank - val2.Rank);
        }
    }

    public class PlatformVisibleLeaderboardDataForUser : IHttpHandler
    {
        // declare response formaat delegate
        public delegate string ResponseDelegate(Object obj);

        // private data
        private string _xuid;
        private string _titleId;
        private string _lbid;

        /// <summary>
        /// The routing logic specified in statfeapp.cs, RegisterRoutes, will call this ctor with its relative {args} 
        /// as string inputs, which can be cached and used as inputs to the API for processing.
        /// </summary>
        /// <param name="titleid">The titleId to return PVL data for</param>
        /// <param name="lbid">The leaderboardId to return PVL data for</param>
        /// <param name="gamertag">The gamertag of the user to return PVL data for (plus the user's friends)</param>
        public PlatformVisibleLeaderboardDataForUser(string titleid, string lbid, string xuid)
        {
            _titleId = titleid;
            _lbid = lbid;
            _xuid = xuid;            
        }

        /// <summary>
        /// Parses the HttpContext for various URI nouns and query string params, and returns them as inputs
        /// to the PlatformVisibleLeaderboardDataForUser API.
        /// </summary>
        /// <param name="ctx">HttpContext from the incoming HttpRequest</param>
        /// <param name="xuid">User to retrive PVL data for</param>
        /// <param name="titleId">TitleID to retrieve PVL data for</param>
        /// <param name="lbid">Leaderboard ID to retrieve PVL data for</param>
        /// <param name="skipItems">Paging arg that indicates the starting friends array index to return PVL data for</param>
        /// <param name="maxItems">Paging arg that indicates the maximum number of friends to return PVL data for</param>
        /// <param name="locale">The Accept-Language header from the HttpRequest.  Used to craft the response in a culture sensitive way</param>
        private void ParseRequest(HttpContext ctx, 
            out Puid xuid, 
            out uint titleId, 
            out uint lbid,
            out uint skipItems,
            out uint maxItems, 
            out CultureInfo ci)            
        {
            titleId = uint.Parse(_titleId); 
            lbid = uint.Parse(_lbid);
            xuid = RestUtilities.ParsePuid(_xuid);
            
            const uint DefaultMaxItems = 100; // what maxItems will be if the maxItems query string arg is not specified in the URL
            RestUtilities.GetRequestPagingInfo(ctx, out skipItems, out maxItems, DefaultMaxItems);

            ci = StatsFdUtil.GetCultureInfoFromRequestHeader(ctx);
        }

        /// <summary>
        /// Gets the list of friends for a user from the actual Presence service
        /// </summary>
        /// <param name="xuid">User requesting the friend list</param>
        /// <returns>Array of friends that was retrieved for the provided user xuid</returns>
        public HResult GetFriendsListWithoutPresenceInfo(Puid xuid, out GetFriendsNoPresenceData[] friends)
        {
            HResult hr = HResult.S_OK;

            GetFriendsNoPresenceRequest presenceRequest = new GetFriendsNoPresenceRequest();
            GetFriendsNoPresenceResponse presenceResponse = new GetFriendsNoPresenceResponse();

            friends = null;

            presenceRequest.puid = xuid;

            XRLObject2 xrlRefObj = presenceResponse;

            try
            {
                // Make inter-service call to the presence front door to get back an array of friends for the given user
                hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int,
                                                    presenceRequest.Xrl,
                                                    null,
                                                    presenceRequest,
                                                    ref xrlRefObj);

                if (presenceResponse != null)
                {
                    friends = presenceResponse.rgFriends;
                }
            }
            catch
            {
                hr = HResult.E_FAIL;
            }

            return hr;
        }

        /// <summary>
        /// Given an user xuid, and an array of friends for that user xuid, obtain the platform visible leaderobard
        /// stats for that user and the user's friends for the given title id, and leaderboard id and apply the 
        /// the results to the response struct.        
        /// </summary>
        /// <param name="leaderboardData">The PVL metadata for the requested leaderboard</param>
        /// <param name="titleId">The titleId to get PVL data for</param>
        /// <param name="xuid">The user to query PVL data for</param>
        /// <param name="friends">The array of friends for the provided user xuid to retrive PVL data for</param>
        /// <param name="locale">The culture locale string.  Used to format the response in culture sensitive ways</param>
        /// <param name="skipItems">paging arg.  Indicates the starting index of the friends array to return PVL data for</param>
        /// <param name="maxItems">paging arg.  Indicates the maximum number of friends to return PVL data for</param>
        /// <param name="userData">The user data to be returned in the http response
        /// <param name="userList">The friend leaderboard data to be returned in the http response 
        /// <param name="pagingInfo">The paging info to be returned in the http response
        public HResult GetPlatformVisibleLeaderboardStatsForUsers(
                                                PlatformVisibleLeaderboardMetadata leaderboardData,
                                                UInt32 titleId,
                                                UInt32 lbid,
                                                Puid xuid, 
                                                GetFriendsNoPresenceData[] friends, 
                                                CultureInfo ci,
                                                UInt16 skipItems, 
                                                UInt16 maxItems, 
                                                out PlatformLeaderboardRowData userData,
                                                out List<PlatformLeaderboardRowData> userList,
                                                out PagingInfo pagingInfo,
                                                ref ErrorInfo error)
        {
            HResult hr = HResult.S_OK;

            // Create the request
            StatsReadRequest statsRequest = new StatsReadRequest();
            StatsReadResponse statsReadResponse = new StatsReadResponse();

            userData = null;
            userList = null;
            pagingInfo = null;

            try
            {
                statsRequest.UserCount = 1;  // the user 
                if (friends != null && friends.Length > 0)
                {
                    statsRequest.UserCount += (uint)friends.Length;
                    statsRequest.Users = new ulong[statsRequest.UserCount];

                    int index = 1;
                    foreach (GetFriendsNoPresenceData friend in friends)
                    {
                        statsRequest.Users[index++] = friend.Puid;
                    }
                }
                else
                {
                    statsRequest.Users = new ulong[statsRequest.UserCount];
                }

                statsRequest.Users[0] = xuid; // the first xuid in the list is always the user

                statsRequest.TitleId = titleId;
                statsRequest.SpecCount = 1;
                statsRequest.Specs = new StatsSpec[1];
                statsRequest.Specs[0] = new StatsSpec();
                statsRequest.Specs[0].ViewId = lbid;
                if (leaderboardData.ratingAttributeId != SpecialAttrib.Rating)
                {
                    // Need to get the alternate display rating column value...
                    statsRequest.Specs[0].ColumnCount = 1;
                    statsRequest.Specs[0].ColumnIds = new ushort[1];
                    statsRequest.Specs[0].ColumnIds[0] = leaderboardData.ratingAttributeId;
                }

                XRLObject2 xrlRefObj = statsReadResponse;

                // Send it to the stats leaderboard api
                hr = XRLUtil.PostXrlRequest(VirtualInterface.xstatsfd_int,
                                                    statsRequest.GetXRL(),
                                                    null,
                                                    statsRequest,
                                                    ref xrlRefObj);

                if (hr != HResult.S_OK)
                {
                    if (hr == HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD)
                    {
                        error = new ErrorInfo(hr, "No leaderboard was found for the specified titleId and lbid!", HttpStatusCode.BadRequest);
                    }
                    else
                    {
                        error = new ErrorInfo(hr, "StatsRead XRL request failed", HttpStatusCode.BadRequest);
                    }

                    // Log the failure to the app event log.  We want to know about this...
                    Xom.Trace(XomAreaName.statslog,
                        LogLevel.L_ERROR,
                        "VirtualInterface.xstatsfd_int get stats call failed for user, 0x{0}, Lbid, {1}, with hr = {2}",
                        xuid.ToString(),
                        lbid,
                        hr);

                    return hr;
                }                

                if (statsReadResponse.ResultsCount == 1) // should only be 1 result because we only asked for one!
                {                    
                    StatsRow[] rows = statsReadResponse.Results[0].Rows;

                    List<StatsRow> listRows = new List<StatsRow>();

                    // Filter out all users that don't have scores posted to this leaderboard...
                    foreach (StatsRow row in rows)
                    {
                        if (row.Rank > 0)
                        {
                            listRows.Add(row);
                        }
                    }
                                       
                    rows = listRows.ToArray();

                    // Results are returned in order of xuid... so I must SORT the results now based on the RANK in order 
                    // for the caller to get back the results in the proper order.  This is especially important once
                    // paging is applied.

                    if (rows.Length > 1) // only sort if > 1 record to begin with...
                    {
                        Array.Sort(rows, new RankComparer());
                    }

                    UInt16 userListResponses = 0;
                    string formattedRating;

                    // the rows array is sorted by rank, so the array index *is* the rank relative to friends, including the user rank
                    for (uint relativeRank = 0; relativeRank < rows.Length; relativeRank++)
                    {
                        StatsRow row = rows[relativeRank];

                        if (row.Puid == xuid)
                        {
                            userData = new PlatformLeaderboardRowData(
                                row.Puid, 
                                row.GamerTag, 
                                PlatformVisibleRating(row, leaderboardData, ci),
                                relativeRank + 1); // the variable is base 0, but the actual relative rank is base 1 (so +1)
                        }
                                                
                        if (relativeRank >= skipItems)
                        {
                            if (userListResponses < maxItems)
                            {
                                formattedRating = PlatformVisibleRating(row, leaderboardData, ci);

                                if (userList == null)
                                {
                                    userList = new List<PlatformLeaderboardRowData>();
                                }                                

                                userList.Add(new PlatformLeaderboardRowData(
                                    row.Puid,
                                    row.GamerTag,                                   // gamertag
                                    formattedRating,                                // formatted rating value
                                    relativeRank + 1));                             // rank (relative to friends)

                                userListResponses++;
                            }
                        }
                    }

                    pagingInfo = new PagingInfo((ushort)rows.Length);

                    // if there is more data than can fit in this response page, return a continuation token
                    if ((skipItems + userListResponses) < rows.Length)
                    {
                        pagingInfo.continuationToken = (skipItems + userListResponses).ToString();
                    }
                }
            }
            catch
            {
                hr = HResult.E_FAIL;
                error = new ErrorInfo(hr, "GetPlatformVisibleLeaderboardStatsForUsers call failed", HttpStatusCode.InternalServerError);
            }

            return hr;
        }

        /// <summary>
        /// Often, formatting strings provided by the DateTimeFormatInfo for a given CultureInfo is provided 
        /// with a " tt" suffix, which indicates that the "meridian" should be appended to the formatted string, e.g.
        /// AM, PM, etc.  Since we are displaying relative times for a leaderboard score, it doesn't make sense to 
        /// include the meridian.  This method detecsts the meridian suffix, if it exists, and removes it from the culture
        /// time format string.  It also replaces all lower case hour format characters, e.g. "h:" with "HH:"
        /// </summary>
        /// <param name="formatString">culture relative time format string</param>
        /// <returns>the input format string but without the " tt" suffix, and with HH: instead of h:</returns>
        private string DisplayRatingTimePattern(string formatString)
        {
            formatString = formatString.Replace("h:", "HH:"); // ensure to use HH: instead of "h:" for hours, otherwise, 0 hours == 12 in the string conversion
            return formatString.Replace(" tt", ""); // remove trailing meridian suffix from format string
        }

        /// <summary>
        /// Given a StatsRow object a PlatformVisibleLeaderboardMetadata object, and a locale string, e.g. "en-US", etc.,
        /// determine which column represents the "display rating" column, and how that value should be formatted as a 
        /// string response to the caller in its globalized format relative to the provided locale.
        /// </summary>
        /// <param name="rating">rating value requesting the friend list</param>
        /// <param name="leaderboardData">Leaderboard metadata object that provides rating attribute id and 
        /// response formatting instructions.
        /// <param name="locale">The locale found int the "Accept-Language" HttpRequest header.  This can be used to
        /// know how to best format a culture sensitive response for each rating value, when appropriate.
        /// <returns>Fully formatted display rating value that can be directly serialized to the response body</returns>
        public string PlatformVisibleRating(StatsRow row, PlatformVisibleLeaderboardMetadata leaderboardData, CultureInfo ci)
        {
            if (leaderboardData.ratingAttributeId == SpecialAttrib.Rating)
            {
                return row.Rating.ToString(); // The actual rating is the display rating.  (simplest case)
            }

            string formatString = "";

            switch((PlatformVisibleLeaderboardDataType)leaderboardData.type)
            {
                case PlatformVisibleLeaderboardDataType.DateTime:
                {                    
                    switch ((PlatformVisibleLeaderboardTimeFormats)leaderboardData.format)
                    {
                        case PlatformVisibleLeaderboardTimeFormats.ShortDate:       // M/d/yyyy
                            formatString = ci.DateTimeFormat.ShortDatePattern;
                            break;

                        case PlatformVisibleLeaderboardTimeFormats.ExpandedDate:    // M/d/yyyy h::mm
                            formatString = string.Format("{0} {1}", ci.DateTimeFormat.ShortDatePattern, DisplayRatingTimePattern(ci.DateTimeFormat.ShortTimePattern));
                            break;

                        case PlatformVisibleLeaderboardTimeFormats.FullDate:        // M/d/yyyy h::mm::ss
                            formatString = string.Format("{0} {1}", ci.DateTimeFormat.ShortDatePattern, DisplayRatingTimePattern(ci.DateTimeFormat.LongTimePattern));
                            break;

                        default: // PlatformVisibleLeaderboardTimeFormats.ExtraFullDate:   // M/d/yyyy h::mm::ss.fff
                            formatString = string.Format("{0} {1}.fff", ci.DateTimeFormat.ShortDatePattern, DisplayRatingTimePattern(ci.DateTimeFormat.LongTimePattern));
                            break;
                    }

                    long value = Convert.ToInt64(row.Columns[0].Data);
                    DateTime dt = DateTime.FromFileTimeUtc(value); // long was stored as a FILETIME
                    return string.Format("{0}", dt.ToString(formatString));
                }
                case PlatformVisibleLeaderboardDataType.Timespan: // no dates, just hours, minutes, seconds, and/or milliseconds
                {
                    DateTime dt;
                    long value = Convert.ToInt64(row.Columns[0].Data);
                    
                    // In these cases, the value itself is in units determined by the smallest unit of time for that time format
                    // For example, if using the ShortTime format, then the value is in minutes. If LongTime format, then the value 
                    // is in seconds.  If in "ExtraLongTime" format, then the value is measured in milliseconds.
                    switch ((PlatformVisibleLeaderboardTimeFormats)leaderboardData.format)
                    {
                        case PlatformVisibleLeaderboardTimeFormats.ShortTime:       // h::mm
                            formatString = DisplayRatingTimePattern(ci.DateTimeFormat.ShortTimePattern);
                            dt = new DateTime(value * TimeSpan.TicksPerMinute);
                            break;

                        case PlatformVisibleLeaderboardTimeFormats.LongTime:        // h::mm::ss
                            formatString = DisplayRatingTimePattern(ci.DateTimeFormat.LongTimePattern);
                            dt = new DateTime(value * TimeSpan.TicksPerSecond);
                            break;

                        default:  // PlatformVisibleLeaderboardTimeFormats.ExtraLongTime  (h::mm::ss.fff)
                            formatString = DisplayRatingTimePattern(ci.DateTimeFormat.LongTimePattern) + ".fff";  // tack on milliseconds to long time format
                            dt = new DateTime(value * TimeSpan.TicksPerMillisecond);
                            break;
                    }

                    return string.Format("{0}", dt.ToString(formatString));
                }
                case PlatformVisibleLeaderboardDataType.Decimal:
                {
                    // format response value according to the number of decimals it specified in the title config tool
                    StringBuilder sb = new StringBuilder("{0:0.");
                    sb.Append('0', (int)leaderboardData.format);
                    sb.Append("}");

                    string formattedResult = string.Format(sb.ToString(), System.Convert.ToDouble(row.Columns[0].Data));
                    return formattedResult.Replace(".", ci.NumberFormat.NumberDecimalSeparator);
                }
                default:  // long
                {
                    return row.Columns[0].Data.ToString();
                }
            }
        }

        // Process
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            ErrorInfo error = null;
            Puid xuid;
            UInt32 titleId;
            uint lbid;
            uint skipItems;
            uint maxItems;
            CultureInfo ci;            
            
            // bump perf counters...
            StatisticsCounters.Counters.PlatformLeaderboardDataForUserTotal.Increment();
            StatisticsCounters.Counters.PlatformLeaderboardDataForUserCurrent.Increment();
            StatisticsCounters.Counters[_titleId].PlatformLeaderboardDataForUserCurrent.Increment();
            StatisticsCounters.Counters[_titleId].PlatformLeaderboardDataForUserTotal.Increment();
            StatisticsCounters.Counters.PlatformLeaderboardUserCallsPerSecond.Increment();

            try
            {                
                try
                {
                    ParseRequest(ctx, out xuid, out titleId, out lbid, out skipItems, out maxItems, out ci);
                }
                catch
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }
                
                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                // Validate user claim in XAuthData header...
                hr = RestUtilities.AuthorizeUser(ctx, xuid, ref error);
                if (hr != HResult.S_OK)
                {
                    throw new Exception();
                }

                StatDb db = new StatDb();

                PlatformVisibleLeaderboardMetadata leaderboardData = db.GetPlatformLeaderboardData(titleId, lbid, ci.Name);
                if (null == leaderboardData)
                {
                    StatisticsCounters.Counters.PlatformLeaderboardRequestForNonPlatformLeaderboardUserData.Increment();
                    StatisticsCounters.Counters[_titleId].PlatformLeaderboardRequestForNonPlatformLeaderboardUserData.Increment();

                    hr = RestErrorHandler.InvalidTitleError;
                    error = new ErrorInfo(hr, "No Platform Visible Leaderboard Content was found for this titleId", HttpStatusCode.NoContent);

                    throw new Exception(); // no content for this leaderboard!
                }

                // Now we can work on generating a response...
                PlatformLeaderboardDataForUserResponse response = new PlatformLeaderboardDataForUserResponse();

                response.name = leaderboardData.name;
                response.rating = leaderboardData.rating;
                
                GetFriendsNoPresenceData[] friends = null;

                hr = GetFriendsListWithoutPresenceInfo(xuid, out friends);
                if (HResult.S_OK == hr)
                {
                    // track how many friends (on average) we're returning to the caller on average
                    StatisticsCounters.Counters.PlatformLeaderboardDataForUserAvgFriendsBase.Increment();
                    if (friends != null)
                    {
                        StatisticsCounters.Counters.PlatformLeaderboardDataForUserAvgFriends.IncrementBy(friends.Length);
                    }
                }
                else
                {
                    // Log the failure to the app event log, then continue.  A friends failure is not fatal to the overall 
                    // call since we can still get user data, but we still want to know that these calls are failing!
                    Xom.Trace(XomAreaName.statslog,
                        LogLevel.L_WARNING,
                        "VirtualInterface.xpnfd_presence_int call failed for user, 0x{0}",
                        xuid.ToString());
                }                
                
                hr = GetPlatformVisibleLeaderboardStatsForUsers(leaderboardData,
                        titleId,
                        lbid,
                        xuid,
                        friends,
                        ci,
                        (UInt16)skipItems,
                        (UInt16)maxItems,
                        out response.user,
                        out response.userList,
                        out response.pagingInfo,
                        ref error);

                if (hr != HResult.S_OK)
                {
                    throw new Exception();
                }

                RestUtilities.SerializeResponse(ctx, response);
            }
            catch
            {
                StatisticsCounters.Counters.PlatformLeaderboardDataForUserFailedTotal.Increment();
                StatisticsCounters.Counters[_titleId].PlatformLeaderboardDataForUserFailedTotal.Increment();                

                // if an unexpected error occurs
                if (error == null)
                {
                    if (hr == HResult.S_OK) // if no HRESULT is set yet, set one
                    {
                        hr = HResult.E_UNEXPECTED;
                    }
                    error = new ErrorInfo(hr, "An unexpected error occured in PlatformVisibleLeaderboardDataForUser!", HttpStatusCode.InternalServerError);
                }
                else
                {
                    hr = error.error_code;
                }
                
                if (error.status == HttpStatusCode.NoContent)
                {
                    // Just set the status code, don't send a body.
                    PlatformVisibleLeaderboardData.SetHttpErrorStatusCode(ctx, error);
                }
                else
                {
                    RestErrorHandler.SerializeErrorResponse(ctx, error);
                }
            }
            finally
            {
                Xom.Log(XomAreaName.statslog,
                    @"PVLUD|{0}|{1}|{2}|{3}",
                    hr,
                    _titleId,
                    _lbid,
                    _xuid);

                StatisticsCounters.Counters.PlatformLeaderboardDataForUserCurrent.Decrement();
                StatisticsCounters.Counters[_titleId].PlatformLeaderboardDataForUserCurrent.Decrement();
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object holds state variables, this method always returns false
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProgressReadAllAchievements.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.Xbox.Rest.Utilities;

namespace xonline.server.stats.fd
{
    // protocol object for response
    [DataContract(Name="response")]
    public class ProgressReadAllAchievementsResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }

        [DataMember(Name = "pagingInfo")]
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name = "achievements")]
        public UserProgressAchievement[] Achievements = null;
    }

    [DataContract(Name="achievement")]
    public class UserProgressAchievement
    {
        [DataMember(Name="titleId")] 
        public uint TitleId = 0;

        [DataMember(Name = "id")] 
        public uint Id = 0;
        
        internal DateTime AchievedDate = DateTime.MinValue;

        [DataMember(Name="timeUnlocked")] 
        public string AchievedDateString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(AchievedDate);
            }
            set {}
        }

        [DataMember(Name = "sequence")] 
        public uint Sequence = 0;

        [DataMember(Name = "flags")] 
        public uint Flags = 0;

        [DataMember(Name = "platform")] 
        public uint Platform = 0;

        [DataMember(Name = "unlockedOnline")] 
        public bool AchievedOnline
        {
            get
            {
                return (0 != (Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE)) ? true : false;
            }
            set {}
        }
    }
    
    public class ProgressReadAllAchievementsRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProgressReadAllAchievements((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProgressReadAllAchievements : IHttpHandler
    {
        private string _xuid;
        public ProgressReadAllAchievements(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);
            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProgressReadAllAchievementsResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProgressReadAllAchievementsResponse), 
                resp,
                contentType);

            ctx.Response.ContentType = contentType;
        }
        
        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            ProgressReadAllAchievementsResponse resp = new ProgressReadAllAchievementsResponse();
            List<UserProgressAchievement> achievementList = null;
            
            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                achievementList = new List<UserProgressAchievement>((int)maxCount);
                
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_progress_get_all_user_achievements";
                    ws.Partition = ws.CalcPartition(xuid);

                    ws.AddParameter("@bi_user_puid", xuid);
                    ws.AddParameter("@i_start_index", startIndex);
                    ws.AddParameter("@i_end_index", startIndex + maxCount - 1);

                    WstDataReader reader = ws.Execute();

                    if (!reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_93, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Received no results");
                    }
                    
                    resp.LastModified = (DateTime)reader["dt_version"];

                    if (!reader.NextResult() || !reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    resp.PagingInfo.TotalItems = (uint)(int)reader["i_total_achievements"];

                    if (!reader.NextResult())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    int titleOrdinal = reader.GetOrdinal("i_title_id");
                    int achievementOrdinal = reader.GetOrdinal("i_achievement_id");
                    int achievedOrdinal = reader.GetOrdinal("dt_achieved");
                    int flagsOrdinal = reader.GetOrdinal("i_flags");
                    int sequenceOrdinal = reader.GetOrdinal("i_sequence");

                    while (reader.Read())
                    {
                        UserProgressAchievement achievement = new UserProgressAchievement();

                        achievement.TitleId = (uint)reader.GetInt32(titleOrdinal);
                        achievement.AchievedDate = reader.GetDateTime(achievedOrdinal);
                        achievement.Id = (uint)reader.GetInt32(achievementOrdinal);
                        achievement.Flags = (uint)reader.GetInt32(flagsOrdinal);

                        // If the achievement was not earned online then we set an
                        // invalid date.  That date is SQL's minimum date because
                        // that's what legacy achievements have.
                        if (0 == (achievement.Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE))
                            achievement.AchievedDate = new DateTime(1753, 1, 1);

                        achievement.Platform = (uint)Achievement.GetPlatformTypeFromFlags((int)achievement.Flags);
                        achievement.Sequence = (uint)reader.GetInt32(sequenceOrdinal);

                        achievementList.Add(achievement);
                    }
                }

                resp.Achievements = achievementList.ToArray();
                resp.PagingInfo.Count = (resp.Achievements == null) ? 0 : (uint)resp.Achievements.Length;
                uint nextPosition = resp.PagingInfo.Count + startIndex;
                if (resp.PagingInfo.TotalItems > nextPosition)
                {
                    resp.PagingInfo.ContinuationToken = nextPosition;
                }

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProgressReadAllAchievements|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProgressReadAllAvatarAwards.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.Xbox.Rest.Utilities;

namespace xonline.server.stats.fd
{
    // protocol object for response
    [DataContract(Name="response")]
    public class ProgressReadAllAvatarAwardsResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }

        [DataMember(Name = "pagingInfo")]
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name = "avatarAwards")]
        public UserProgressAvatarAward[] AvatarAwards = null;
    }

    [DataContract(Name = "avatarAward")]
    public class UserProgressAvatarAward
    {
        [DataMember(Name = "titleId")]
        public uint TitleId = 0;

        [DataMember(Name = "id")]
        public uint Id = 0;

        [DataMember(Name = "bodyType")]
        public uint BodyTypeMask = 0;

        [DataMember(Name = "sequence")]
        public uint Sequence = 0;

        [DataMember(Name = "flags")]
        public uint Flags = 0;

        [DataMember(Name = "platform")]
        public uint Platform = 0;

        internal DateTime AwardedDate = DateTime.MinValue;

        [DataMember(Name="timeUnlocked")] 
        public string AwardedDateString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(AwardedDate);
            }
            set {}
        }

        [DataMember(Name = "unlockedOnline")]
        public bool AchievedOnline
        {
            get
            {
                return (0 != (Flags & XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE)) ? true : false;
            }
            set {}
        }
    }
    
    public class ProgressReadAllAvatarAwardsRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProgressReadAllAvatarAwards((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProgressReadAllAvatarAwards : IHttpHandler
    {
        private string _xuid;
        public ProgressReadAllAvatarAwards(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);
            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProgressReadAllAvatarAwardsResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProgressReadAllAvatarAwardsResponse), 
                resp,
                contentType);

            ctx.Response.ContentType = contentType;
        }
        
        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            ProgressReadAllAvatarAwardsResponse resp = new ProgressReadAllAvatarAwardsResponse();
            List<UserProgressAvatarAward> avatarAwardList = null;
            
            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                avatarAwardList = new List<UserProgressAvatarAward>((int)maxCount);
                
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_progress_get_all_user_avatar_awards";
                    ws.Partition = ws.CalcPartition(xuid);

                    ws.AddParameter("@bi_user_puid", xuid);
                    ws.AddParameter("@i_start_index", startIndex);
                    ws.AddParameter("@i_end_index", startIndex + maxCount - 1);

                    WstDataReader reader = ws.Execute();

                    if (!reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_93, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Received no results");
                    }
                    
                    resp.LastModified = (DateTime)reader["dt_version"];

                    if (!reader.NextResult() || !reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    resp.PagingInfo.TotalItems = (uint)(int)reader["i_total_avatar_awards"];

                    if (!reader.NextResult())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    int titleOrdinal = reader.GetOrdinal("i_title_id");
                    int avatarAssetOrdinalOrdinal = reader.GetOrdinal("i_asset_ordinal");
                    int awardedOrdinal = reader.GetOrdinal("dt_awarded");
                    int statusOrdinal = reader.GetOrdinal("i_status");
                    int platformOrdinal = reader.GetOrdinal("i_platform");
                    int sequenceOrdinal = reader.GetOrdinal("i_sequence");
                    int bodyMaskOrdinal = reader.GetOrdinal("i_body_type_mask");

                    while (reader.Read())
                    {
                        UserProgressAvatarAward avatarAward = new UserProgressAvatarAward();

                        avatarAward.TitleId = (uint)reader.GetInt32(titleOrdinal);
                        avatarAward.Flags = (uint)reader.GetInt32(statusOrdinal);
                        avatarAward.AwardedDate = reader.GetDateTime(awardedOrdinal);

                        // If the avatar asset was not earned online then we set an
                        // invalid date.  Use SQL's minimum date.
                        if (0 == (avatarAward.Flags & XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE))
                        {
                            avatarAward.AwardedDate = new DateTime(1753, 1, 1);
                        }

                        avatarAward.Id = (uint)reader.GetInt32(avatarAssetOrdinalOrdinal);
                        avatarAward.Platform = (uint)AvatarAsset.GetPlatformTypeFromFlags(reader.GetInt32(platformOrdinal));
                        avatarAward.Flags |= (uint)reader.GetInt32(platformOrdinal);
                        avatarAward.Sequence = (uint)reader.GetInt32(sequenceOrdinal);
                        avatarAward.BodyTypeMask = (uint)reader.GetInt32(bodyMaskOrdinal);

                        avatarAwardList.Add(avatarAward);
                    }
                }

                resp.AvatarAwards = avatarAwardList.ToArray();
                resp.PagingInfo.Count = (resp.AvatarAwards == null) ? 0 : (uint)resp.AvatarAwards.Length;
                uint nextPosition = resp.PagingInfo.Count + startIndex;
                if (resp.PagingInfo.TotalItems > nextPosition)
                {
                    resp.PagingInfo.ContinuationToken = nextPosition;
                }

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProgressReadAllAvatarAwards|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\profdb.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.stats.fd
{
    public class ProfDb
    {
        public void GetUserName(ulong puid, out string userName)
        {
            WstConnection   conn    = null;
            WstCommand      cmd     = null;
            WstDataReader   dataset = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_pres_get_user_name";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType   = WstPartitionType.Logical;
                cmd.Partition       = WSClient.GetHashPartition(puid, ConfigUtil.UodbWebstoreApp);
                cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = (long) puid;

                dataset = cmd.ExecuteReader();

                if(dataset.Read())
                {
                    userName = dataset.GetString(0);
                }
                else
                {
                    userName = null;
                }
            }
            finally
            {
                if(dataset != null)
                    dataset.Close();

                if(conn != null)
                    conn.Close();
            }
        }

        public void GetTeamName(ulong puid, out string teamName)
        {
            WstConnection   conn    = null;
            WstCommand      cmd     = null;
            WstDataReader   dataset = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_team_get_team_name";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType   = WstPartitionType.Logical;
                cmd.Partition       = WSClient.GetHashPartition(puid, ConfigUtil.UodbWebstoreApp);
                cmd.Parameters.Add("@bi_team_puid", SqlDbType.BigInt).Value = (long) puid;

                dataset = cmd.ExecuteReader();

                if(dataset.Read())
                {
                    teamName = dataset.GetString(0);
                }
                else
                {
                    teamName = null;
                }
            }
            finally
            {
                if(dataset != null)
                    dataset.Close();

                if(conn != null)
                    conn.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProfileReadAllSettings.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using xonline.common.mgmt;
using Microsoft.Webstore.WstClient;
using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.Xbox.Rest.Utilities;

namespace xonline.server.stats.fd
{
    // NOTE: PageInfo is common to all REST response types
    [DataContract(Name="pagingInfo")]
    public class ResponsePagingInfo
    {
        [DataMember(Name = "continuationToken")]
        public uint? ContinuationToken;
        public uint Count;
        [DataMember(Name="totalRecords")] public uint TotalItems;        
    }
    
    // protocol object for response
    [DataContract(Name="response")]
    public class ProfileReadAllSettingsResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }
        
        [DataMember(Name="pagingInfo")] 
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name="settings")] 
        public UserProfileSetting[] Settings = null;
    }

    [DataContract(Name="setting")]
    public class UserProfileSetting
    {
        [DataMember(Name = "id")]
        public uint Id = 0;

        [DataMember(Name="titleId")] public uint TitleId = 0;

        internal byte[] Value;
        [DataMember(Name="value")] public string ValueString
        {
            get
            {
                return Convert.ToBase64String((Value == null) ? new byte[0] : Value);
            }
            set {}
        }
    }
    
    public class ProfileReadAllSettingsRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProfileReadAllSettings((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProfileReadAllSettings : IHttpHandler
    {
        private string _xuid;
        public ProfileReadAllSettings(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);

            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProfileReadAllSettingsResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProfileReadAllSettingsResponse), 
                resp, 
                contentType);

            ctx.Response.ContentType = contentType;
        }

        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            ProfileReadAllSettingsResponse resp = new ProfileReadAllSettingsResponse();
            List<UserProfileSetting> settingList = null;

            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if(claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                settingList = new List<UserProfileSetting>((int)maxCount);

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_profile_get_all_user_settings";
                    ws.Partition = ws.CalcPartition(xuid);

                    ws.AddParameter("@bi_user_puid", xuid);
                    ws.AddParameter("@i_start_index", startIndex);
                    ws.AddParameter("@i_end_index", startIndex + maxCount - 1);

                    WstDataReader reader = ws.Execute();

                    if (!reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_93, "Unexpected recordset from p_profile_get_all_user_settings! " +
                            "Received no results");
                    }

                    resp.LastModified = (DateTime)reader["dt_version"];

                    if (!reader.NextResult() || !reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_profile_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    resp.PagingInfo.TotalItems = (uint)(int)reader["i_total_settings"];

                    if (!reader.NextResult())
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_profile_get_all_user_settings! " +
                            "Only one resultset returned");
                    }

                    int settingOrdinal = reader.GetOrdinal("i_setting_id");
                    int titleOrdinal = reader.GetOrdinal("i_title_id");
                    int valueOrdinal = reader.GetOrdinal("vb_value");

                    while (reader.Read())
                    {
                        // TODO: are there settings that should not be returned to the console?  check SettingInfo here?

                        UserProfileSetting setting = new UserProfileSetting();

                        setting.Id = (uint)reader.GetInt32(settingOrdinal);
                        setting.TitleId = (uint)reader.GetInt32(titleOrdinal);

                        SqlBinary sqlbin = reader.GetSqlBinary(valueOrdinal);
                        setting.Value = (sqlbin.IsNull) ? null : sqlbin.Value;

                        settingList.Add(setting);
                    }
                }

                resp.Settings = settingList.ToArray();
                resp.PagingInfo.Count = (resp.Settings == null) ? 0 : (uint)resp.Settings.Length;
                uint nextPosition = resp.PagingInfo.Count + startIndex;
                if (resp.PagingInfo.TotalItems > nextPosition)
                {
                    resp.PagingInfo.ContinuationToken = nextPosition;
                }

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProfileReadAllSettings|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProgressReadAllPossibleAvatarAwards.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Rest.Utilities;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;

namespace xonline.server.stats.fd
{
    // protocol object for response
    [DataContract(Name="response")]
    public class ProgressReadAllPossibleAvatarAwardsResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }

        [DataMember(Name = "pagingInfo")]
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name = "avatarAwards")]
        public UserPossibleAvatarAward[] AvatarAwards = null;
    }

    [DataContract(Name="avatarAward")]
    public class UserPossibleAvatarAward
    {
        [DataMember(Name = "titleId")]
        public uint TitleId = 0;

        internal Guid AssetId;
        [DataMember(Name="assetId")] public string AssetIdString
        {
            get
            {
                return AssetId.ToString();
            }
            set {}
        }

        [DataMember(Name = "id")]
        public uint Id = 0;

        [DataMember(Name = "bodyComponent")]
        public uint BodyComponent = 0;

        [DataMember(Name = "subCategory")]
        public uint SubCategory = 0;

        [DataMember(Name = "imageId")]
        public uint ImageId = 0;

        [DataMember(Name = "bodyType")]
        public uint BodyTypeMask = 0;

        [DataMember(Name = "name")]
        public string Title = null;

        [DataMember(Name = "description")]
        public string Description = null;

        [DataMember(Name = "lockedDescription")]
        public string HowTo = null;

        [DataMember(Name = "isSecret")]
        public bool SecretAward = false;

        [DataMember(Name = "flags")]
        public uint Flags = 0;
    }
    
    public class ProgressReadAllPossibleAvatarAwardsRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProgressReadAllPossibleAvatarAwards((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProgressReadAllPossibleAvatarAwards : IHttpHandler
    {
        private string _xuid;
        public ProgressReadAllPossibleAvatarAwards(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);
            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProgressReadAllPossibleAvatarAwardsResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProgressReadAllPossibleAvatarAwardsResponse), 
                resp,
                contentType);

            ctx.Response.ContentType = contentType;
        }
        
        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            string[] locales = null;
            ProgressReadAllPossibleAvatarAwardsResponse resp = new ProgressReadAllPossibleAvatarAwardsResponse();
            List<UserPossibleAvatarAward> awardList = null;
            
            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                locales = RestUtilities.GetLocales(authHelper);

                // get all the titles first.
                ProgressReadAllTitlesResponse titlesResp = ProgressReadAllTitles.ReadUserTitles(xuid, 0, Int32.MaxValue, locales);

                awardList = new List<UserPossibleAvatarAward>((int)maxCount);
                uint skip = 0;

                foreach (UserProgressTitle title in titlesResp.Titles)
                {
                    TitleConfig tcfg = TitleConfig.GetTitle(title.TitleId);
                    resp.PagingInfo.TotalItems += (uint)tcfg.AvatarAssets.Count;

                    if ((tcfg.AvatarAssets.Count < (startIndex - skip)) ||
                        (awardList.Count >= maxCount))
                    {
                        // skip the whole title.
                        skip += (uint)tcfg.AvatarAssets.Count;
                        continue;
                    }

                    foreach (TitleAvatarAsset tass in tcfg.AvatarAssets.Values)
                    {
                        if (startIndex > skip)
                        {
                            // skip ahead.
                            skip++;
                            continue;
                        }
                        
                        UserPossibleAvatarAward avataraward = new UserPossibleAvatarAward();
                        avataraward.AssetId = tass.Id.Id;
                        avataraward.Id = tass.Id.AwardOrdinal;
                        avataraward.Description = tass.Description[locales];
                        avataraward.HowTo = tass.Unachieved[locales];
                        avataraward.ImageId = tass.ImageId;
                        avataraward.Title = tass.Title[locales];
                        avataraward.TitleId = title.TitleId;
                        avataraward.BodyComponent = tass.Id.BodyComponent;
                        avataraward.SecretAward = !tass.ShowUnachieved;
                        avataraward.SubCategory = tass.SubCategory;
                        avataraward.BodyTypeMask = tass.Id.BodyTypeMask;
                        avataraward.Flags |= (tass.ShowUnachieved ? XOn.XAVATAR_DETAILS_SHOWUNACHIEVED : 0);

                        awardList.Add(avataraward);

                        if (awardList.Count >= maxCount)
                        {
                            break;
                        }
                    }
                }

                resp.AvatarAwards = awardList.ToArray();
                resp.LastModified = titlesResp.LastModified;
                resp.PagingInfo.Count = (resp.AvatarAwards == null) ? 0 : (uint)resp.AvatarAwards.Length;
                uint nextPosition = resp.PagingInfo.Count + startIndex;
                if (resp.PagingInfo.TotalItems > nextPosition)
                {
                    resp.PagingInfo.ContinuationToken = nextPosition;
                }

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProgressReadAllTitleAwards|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProgressReadAllTitles.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Rest.Utilities;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;

namespace xonline.server.stats.fd
{
    // protocol object for response
    [DataContract(Name="response")]
    public class ProgressReadAllTitlesResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] 
        public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }

        [DataMember(Name = "pagingInfo")]
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name = "titles")]
        public UserProgressTitle[] Titles = null;
    }

    [DataContract(Name="title")]
    public class UserProgressTitle
    {
        [DataMember(Name = "titleId")]
        public uint TitleId = 0;

        [DataMember(Name = "name")]
        public string Name = null;

        internal DateTime LastPlayed = DateTime.MinValue;
        [DataMember(Name="lastPlayed")] public string LastPlayedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastPlayed);
            }
            set {}
        }

        [DataMember(Name = "currentGamerscore")]
        public uint UserGamerscore = 0;

        [DataMember(Name = "currentAchievements")]
        public uint UserAchievements = 0;

        [DataMember(Name = "totalAchievements")]
        public uint MaxAchievements = 0;

        [DataMember(Name = "totalGamerscore")]
        public uint MaxGamerscore = 0;

        [DataMember(Name = "sequence")]
        public uint Sequence = 0;
    }
    
    public class ProgressReadAllTitlesRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProgressReadAllTitles((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProgressReadAllTitles : IHttpHandler
    {
        private string _xuid;
        public ProgressReadAllTitles(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);
            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProgressReadAllTitlesResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProgressReadAllTitlesResponse), 
                resp,
                contentType);

            ctx.Response.ContentType = contentType;
        }
        
        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            string[] locales = null;
            ProgressReadAllTitlesResponse resp = new ProgressReadAllTitlesResponse();
            
            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                locales = RestUtilities.GetLocales(authHelper);

                resp = ReadUserTitles(xuid, startIndex, maxCount, locales);

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProgressReadAllTitles|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        internal static ProgressReadAllTitlesResponse ReadUserTitles(ulong xuid, uint startIndex, uint maxCount, string[] locales)
        {
            ProgressReadAllTitlesResponse resp = new ProgressReadAllTitlesResponse();
            List<UserProgressTitle> titleList = new List<UserProgressTitle>();
            
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_progress_get_all_user_titles";
                ws.Partition = ws.CalcPartition(xuid);

                ws.AddParameter("@bi_user_puid", xuid);
                ws.AddParameter("@i_start_index", startIndex);
                ws.AddParameter("@i_end_index", startIndex + maxCount - 1);

                WstDataReader reader = ws.Execute();

                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_93, "Unexpected recordset from p_progress_get_all_user_settings! " +
                        "Received no results");
                }
                
                resp.LastModified = (DateTime)reader["dt_version"];

                if (!reader.NextResult() || !reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                        "Only one resultset returned");
                }

                resp.PagingInfo.TotalItems = (uint)(int)reader["i_total_titles"];

                if (!reader.NextResult())
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_MISSING_RESULTS, XEvent.Id.STATS_CODE_94, "Unexpected recordset from p_progress_get_all_user_settings! " +
                        "Only one resultset returned");
                }

                int titleOrdinal = reader.GetOrdinal("i_title_id");
                int logonOrdinal = reader.GetOrdinal("dt_last_logon");
                int credsOrdinal = reader.GetOrdinal("i_creds");
                int achievementsOrdinal = reader.GetOrdinal("i_achievements");
                int sequenceOrdinal = reader.GetOrdinal("i_sequence");

                while (reader.Read())
                {
                    UserProgressTitle title = new UserProgressTitle();

                    title.TitleId = (uint)reader.GetInt32(titleOrdinal);
                    title.LastPlayed = reader.GetDateTime(logonOrdinal);
                    title.UserGamerscore = (uint)reader.GetInt32(credsOrdinal);
                    title.UserAchievements = (uint)reader.GetInt32(achievementsOrdinal);
                    title.Sequence = (uint)reader.GetInt32(sequenceOrdinal);

                    TitleConfig titleConfig = TitleConfig.GetTitle(title.TitleId);
                    title.MaxGamerscore = titleConfig.MaxCred;
                    title.MaxAchievements = (uint)titleConfig.Achievements.Count;
                    title.Name = titleConfig.Names[locales];

                    titleList.Add(title);
                }
            }

            resp.Titles = titleList.ToArray();
            resp.PagingInfo.Count = (resp.Titles == null) ? 0 : (uint)resp.Titles.Length;
            uint nextPosition = resp.PagingInfo.Count + startIndex;
            if (resp.PagingInfo.TotalItems > nextPosition)
            {
                resp.PagingInfo.ContinuationToken = nextPosition;
            }

            return resp;
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\reset.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    public class XRLReset : IHttpHandler
    {
		const uint StatsSampleTitleId = 0xFFFF0107;

        public void ProcessRequest(HttpContext ctx)
        {
            try
            {
				StatisticsCounters.Counters.ResetPerSecond.Increment();
				StatisticsCounters.Counters.ResetTotal.Increment();

                _ProcessRequest(ctx);
            }
            catch(System.Exception)
            {
				StatisticsCounters.Counters.ResetFailedPerSecond.Increment();
				StatisticsCounters.Counters.ResetFailedTotal.Increment();
                throw;
            }
        }


        public bool IsReusable
        {
            get { return true; }
        }
        
        public void _ProcessRequest(HttpContext ctx)
        {
            CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            
            Stream inputStream = ctx.Request.InputStream;
            MsgReset msgReset = null;
            
            try
            {
                //
                // Parse message
                //
    
                try
                {
                    msgReset = new MsgReset();
                    msgReset.ReadFrom(new BinaryReader(ctx.Request.InputStream));
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_67, 
                            "Failed to parse MsgReset. Reason: " + e.Message, e);
                    
                    if(se != e)
                        throw se;
                    else
                        throw;                        
                }
    
                StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();
                
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "MsgReset:"+msgReset);
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, SGInfo.ToStr());
                  
                if(inputStream.Position != inputStream.Length)
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.STATS_CODE_99, "Reset request is too big");
                }
    
                if(Config.GetBoolSetting(Setting.stats_trackCountersPerLb))
                {
                    // Track counters per leaderboard
                    StatisticsCounters.Counters[msgReset.titleId.ToString("x")+"-"+msgReset.leaderBoardType].GetDataPerSecond.Increment();
                    StatisticsCounters.Counters[msgReset.titleId.ToString("x")+"-"+msgReset.leaderBoardType].GetDataTotal.Increment();
                }
    
    			// If userId == 0, then this request is a special 'title reset request'
    			// for development only purposes and that should never be used in 
    			// production. This request will only succeed if AllowTitleReset=on in
    			// xstatsfd.ini. Use it wisely.
    
    			if(msgReset.userId == 0)
    			{
    				if(msgReset.titleId == StatsSampleTitleId)
    				{
    					throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_CODE_100, "Reset with UserId=0 on stats sample.");
    				}
    
    				if(!Config.GetBoolSetting(Setting.stats_allowTitleReset))
    				{
    					throw new XRLException(HResult.XONLINE_E_STAT_PERMISSION_DENIED, XEvent.Id.STATS_CODE_101, "Reset with UserId=0 not allowed when AllowTitleReset is off.");
    				}
    			}
    			else
    			{
                    VerifyAuth(msgReset);
    			}
    
                //
                // Make the db call
                //
    
                StatDb db = new StatDb();
    
                if(msgReset.userId != 0)
                {
                    // Reset only a user in one or more leaderboards
    
                    db.ResetUser(msgReset.titleId, msgReset.userId, msgReset.leaderBoardType);
                }
                else
                {
                    if(msgReset.leaderBoardType != 0)
                    {
                        // *** TEST/DEVELOPMENT ENVIRONMENT ONLY ***
                        // Reset an entire leaderboard 
    
                        db.ResetLeaderboard(msgReset.titleId, msgReset.leaderBoardType);
                    }
                    else
                    {
                        // *** TEST/DEVELOPMENT ENVIRONMENT ONLY ***
                        // Reset all the leaderboards of a title
    
                        db.ResetTitle(msgReset.titleId);
                    }
                }
    
                //
                // Return the response
                //
    
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, msgReset.titleId, HResult.S_OK);
                
                // Log
                string logentry = 
                    "RESET"+
                    "|"+msgReset.titleId.ToString("x")+
                    "|"+msgReset.userId.ToString("x")+
                    "|"+msgReset.leaderBoardType.ToString("x");
                    
                Xom.Log(XomAreaName.statslog, logentry);
            }
            catch(Exception e)
            {
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.MC_APPLICATION_ERROR_10, 
                        "XRLReset failed. Reason: " + e.Message, e);
                
                try { se.AppendInfo("msgReset: "+ (msgReset == null ? "(null)" : msgReset.ToString())); } catch(Exception){}
                
                if(se != e)
                    throw se;
                else
                    throw;                        
            }
        }
        
        static protected void VerifyAuth(MsgReset msgReset)
        {
            SGInfo.VerifyTitleId(msgReset.titleId);  	            
            
            if(!StatsUtil.IsTeamPuid(msgReset.userId))
            {
                SGInfo.VerifyUserId((ulong)msgReset.userId);
            }
            else
            {
                if(msgReset._teamTickets == null)
                    throw new AccessDeniedStatsException("XRLReset");
                
                for(int iTicket=0; iTicket < msgReset._teamTickets.teamTickets.Length; iTicket++)
                {
                    // Add team puids to the authorized list
                    for(int iTeam=0; iTeam < msgReset._teamTickets.teamTickets[iTicket].rgqwTeamIDs.Length; iTeam++)
                    {
                        if(msgReset._teamTickets.teamTickets[iTicket].rgqwTeamIDs[iTeam] == msgReset.userId &&
                           SGInfo.Current.IsUserPresent(msgReset._teamTickets.teamTickets[iTicket].userID))
                        {
                            return;
                        }
                    }
                }
                
                throw new AccessDeniedStatsException("XRLReset");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\ProgressReadAllPossibleAchievements.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Routing;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

using Microsoft.Xbox.Rest.Errors;
using Microsoft.Xbox.Rest.Utilities;
using Microsoft.Xbox.Serialization;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;

namespace xonline.server.stats.fd
{
    // protocol object for response
    [DataContract(Name="response")]
    public class ProgressReadAllPossibleAchievementsResponse
    {
        internal DateTime LastModified;
        [DataMember(Name="version")] public string LastModifiedString
        {
            get
            {
                return RestUtilities.ConvertDateTimeToString(LastModified);
            }
            set {}
        }

        [DataMember(Name = "pagingInfo")]
        public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

        [DataMember(Name = "achievements")]
        public UserPossibleAchievement[] Achievements = null;
    }

    [DataContract(Name="achievement")]
    public class UserPossibleAchievement
    {
        [DataMember(Name="titleId")] 
        public uint TitleId = 0;

        [DataMember(Name = "id")]
        public uint Id = 0;

        [DataMember(Name = "type")]
        public byte Type = 0;

        [DataMember(Name="gamerscore")] 
        public int Gamerscore = 0;

        [DataMember(Name = "imageId")]
        public uint ImageId = 0;

        [DataMember(Name = "name")]
        public string Title = null;

        [DataMember(Name = "description")]
        public string Description = null;

        [DataMember(Name="lockedDescription")] 
        public string HowTo = null;

        [DataMember(Name = "isSecret")]
        public bool SecretAchievement = false;

        [DataMember(Name = "flags")]
        public uint Flags = 0;
    }
    
    public class ProgressReadAllPossibleAchievementsRouteHandler : IRouteHandler
    {
        public IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new ProgressReadAllPossibleAchievements((string)requestContext.RouteData.Values["xuid"]);
        }
    }    

    public class ProgressReadAllPossibleAchievements : IHttpHandler
    {
        private string _xuid;
        public ProgressReadAllPossibleAchievements(string xuid)
        {
            _xuid = xuid;
        }
        
        public void ParseRequest(HttpContext ctx, out Puid xuid, out uint startIndex, out uint maxCount)
        {
            xuid = RestUtilities.ParsePuid(_xuid);
            string topParam = ctx.Request.Params["maxitems"];
            string skipParam = ctx.Request.Params["skipitems"];
            string token = ctx.Request.Params["continuationtoken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? 32 : UInt32.Parse(topParam);
        }

        public void SerializeResponse(HttpContext ctx, ProgressReadAllPossibleAchievementsResponse resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream, 
                Encoding.UTF8, 
                typeof(ProgressReadAllPossibleAchievementsResponse), 
                resp,
                contentType);

            ctx.Response.ContentType = contentType;
        }
        
        public void ProcessRequest(HttpContext ctx)
        {
            ErrorInfo error = null;
            HResult hr = HResult.S_OK;
            Puid xuid = 0;
            uint startIndex = 0;
            uint maxCount = 0;
            string[] locales = null;
            ProgressReadAllPossibleAchievementsResponse resp = new ProgressReadAllPossibleAchievementsResponse();
            List<UserPossibleAchievement> achievementList = null;
            
            try
            {
                try
                {
                    ParseRequest(ctx, out xuid, out startIndex, out maxCount);
                }
                catch (Exception)
                {
                    hr = RestErrorHandler.BadArgumentsError;
                    error = new ErrorInfo(hr, "Bad request", HttpStatusCode.BadRequest);
                    throw;
                }

                if (xuid == 0)
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "Invalid UserId", HttpStatusCode.BadRequest);
                    throw new Exception();
                }

                IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

                AuthHelper authHelper = new AuthHelper();
                authHelper.Principal = claims;
                //If user claims not equals passed in user then return error.
                if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
                {
                    hr = RestErrorHandler.InvalidUserError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                if (!authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360) &&
                    !authHelper.VerifyEquals(AuthClaimTypes.DeviceType, Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC))
                {
                    hr = RestErrorHandler.InvalidDeviceError;
                    error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                    throw new Exception();
                }

                locales = RestUtilities.GetLocales(authHelper);

                // get all the titles first.
                ProgressReadAllTitlesResponse titlesResp = ProgressReadAllTitles.ReadUserTitles(xuid, 0, Int32.MaxValue, locales);

                achievementList = new List<UserPossibleAchievement>((int)maxCount);
                uint skip = 0;

                foreach (UserProgressTitle title in titlesResp.Titles)
                {
                    TitleConfig tcfg = TitleConfig.GetTitle(title.TitleId);
                    resp.PagingInfo.TotalItems += (uint)tcfg.Achievements.Count;

                    if ((tcfg.Achievements.Count < (startIndex - skip)) ||
                        (achievementList.Count >= maxCount))
                    {
                        // skip the whole title.
                        skip += (uint)tcfg.Achievements.Count;
                        continue;
                    }

                    foreach (TitleAchievement tach in tcfg.Achievements.Values)
                    {
                        if (startIndex > skip)
                        {
                            // skip ahead.
                            skip++;
                            continue;
                        }
                        
                        UserPossibleAchievement achievement = new UserPossibleAchievement();
                        achievement.Id = tach.Id;
                        achievement.Description = tach.Description[locales];
                        achievement.Gamerscore = tach.Cred;
                        achievement.HowTo = tach.Unachieved[locales];
                        achievement.ImageId = tach.ImageId;
                        achievement.Title = tach.Title[locales];
                        achievement.TitleId = title.TitleId;
                        achievement.Type = (byte)tach.Type;
                        achievement.SecretAchievement = !tach.ShowUnachieved;
                        achievement.Flags |= (tach.ShowUnachieved ? XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED : 0);
                        achievement.Flags |= (uint)achievement.Type;

                        achievementList.Add(achievement);

                        if (achievementList.Count >= maxCount)
                        {
                            break;
                        }
                    }
                }

                resp.Achievements = achievementList.ToArray();
                resp.LastModified = titlesResp.LastModified;
                resp.PagingInfo.Count = (resp.Achievements == null) ? 0 : (uint)resp.Achievements.Length;
                uint nextPosition = resp.PagingInfo.Count + startIndex;
                if (resp.PagingInfo.TotalItems > nextPosition)
                {
                    resp.PagingInfo.ContinuationToken = nextPosition;
                }

                SerializeResponse(ctx, resp);
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    error = new ErrorInfo(hr, "Error occured while reading settings " + xrle.ToString(), HttpStatusCode.ServiceUnavailable);
                }
                else if (error == null)
                {
                    hr = RestErrorHandler.SystemError;
                    error = new ErrorInfo(hr, "Unknown error occured.", HttpStatusCode.ServiceUnavailable);
                }

                RestErrorHandler.SerializeErrorResponse(ctx, error);
            }
            finally
            {
                Xom.Log(
                    XomAreaName.statslog, 
                    @"ProgressReadAllTitleAchievements|{0}|{1}|{2}|{3}|{4}",
                    hr,
                    xuid,
                    resp.LastModified,
                    resp.PagingInfo.TotalItems,
                    resp.PagingInfo.Count);
            }
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\RestErrorHandler.cs ===
//-----------------------------------------------------------------------
// <copyright file="RestErrorHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

namespace Microsoft.Xbox.Rest.Errors
{
    using System;
    using System.Net;
    using System.Web;
    using System.Text;
    using System.Xml;
    using System.Runtime.Serialization;
    using Microsoft.Xbox.Serialization;
    using xonline.server.stats.fd;

    // NOTE: ErrorInfo is common to all REST response types
    [DataContract(Name = "ErrorInfo")]
    public class ErrorInfo
    {
        [DataMember]
        public uint error_code;
        public HttpStatusCode status;
        [DataMember]
        public string error_text;

        public ErrorInfo()
        { }

        public ErrorInfo(uint code, string desc, HttpStatusCode status)
        {
            this.error_code = code;
            this.error_text = desc;
            this.status = status;
        }
    }

    /// <summary>
    /// Static class that provides error serialization utility functions.
    /// </summary>
    public static class RestErrorHandler
    {
        //Copy these codes from TFS code base so that error codes are exact same in both places.
        public const uint SystemError = 0x80200000u;
        public const uint InvalidUserError = 0x80200001u;
        public const uint InvalidTitleError = 0x80200002u;
        public const uint NullInputError = 0x80200005u;
        public const uint InvalidDeviceError = 0x80200006u;
        public const uint BadArgumentsError = 0x80200007u;

        /// <summary>
        /// Serializes error for Rest code.
        /// </summary>
        /// <param name="ctx"></param>
        /// <param name="resp"></param>
        public static void SerializeErrorResponse(HttpContext ctx, ErrorInfo resp)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream,
                Encoding.UTF8,
                typeof(ErrorInfo),
                resp,
                contentType);

            ctx.Response.StatusCode = (int)resp.status;
            ctx.Response.ContentType = contentType;
            ctx.Response.TrySkipIisCustomErrors = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\RestUtilities.cs ===
//-----------------------------------------------------------------------
// <copyright file="RestUtilities.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

namespace Microsoft.Xbox.Rest.Utilities
{
    using System;
    using System.Net;
    using System.Web;
    using System.Text;
    using System.Xml;
    using System.Globalization;
    using xonline.common.service;
    using xonline.common.utilities;
    using Microsoft.IdentityModel.Claims;
    using Microsoft.XboxLive.Auth;
    using Microsoft.XboxLive.Auth.Claims;
    using Microsoft.Xbox.Rest.Errors;
    using xonline.server.stats.fd;
    using Microsoft.Xbox.Serialization;

    public static class RestUtilities
    {
        /// <summary>
        /// TODO. Fix this after getting latest security dll.
        /// </summary>
        public const string DeviceLanguage = "http://schemas.microsoft.com/xbox/2011/07/claims/user/devicelanguage";

        public static string[] GetLocales(AuthHelper authHelper)
        {
            Claim claim = authHelper.FindClaim(AuthClaimTypes.Country);
            byte countryId = claim != null ? Byte.Parse(claim.Value) : (byte)0;

            claim = authHelper.FindClaim(AuthClaimTypes.Language);
            ushort userLanguageId = claim != null ? ushort.Parse(claim.Value) : (ushort)0;

            claim = authHelper.FindClaim(DeviceLanguage);
            ushort deviceLanguageId = claim != null ? ushort.Parse(claim.Value) : (ushort)0;

            string countryCode = CountryDictionary.CountryCode(countryId);

            // User language takes precedent over console language
            return Locale.BuildValidLocaleList(
                deviceLanguageId,
                userLanguageId,
                countryCode);
        }

        /// <summary>
        /// Serialize the response object 
        /// </summary>
        /// <param name="ctx">HttpContext object to respond to</param>
        /// <param name="obj">Object to be serialized</param>
        /// <returns>nothing</returns>
        ///         
        public static void SerializeResponse(HttpContext ctx, Object obj)
        {
            string contentType = StatsFrontEndApp.GetResponseContentType(ctx);
            DataSerializer.WriteSerializedObjectToStream(
                ctx.Response.OutputStream,
                Encoding.UTF8,
                obj.GetType(),
                obj,
                contentType);

            ctx.Response.ContentType = contentType;
        }

        /// <summary>
        /// Get optional paging info that might be provided as query string arguments
        /// </summary>
        /// <param name="ctx">HttpContext object</param>
        /// <param name="startIndex">zero based starting index for paging info</param>
        /// <param name="maxCount">maximum number of items to return</param>
        /// <param name="defaultMaxCount">default maximum items to return if maxItems query string parameter is not specified</param>
        /// <returns>nothing</returns>
        /// 
        public static void GetRequestPagingInfo(HttpContext ctx, out uint startIndex, out uint maxCount, uint defaultMaxCount)
        {
            string topParam = ctx.Request.Params["maxItems"];
            string skipParam = ctx.Request.Params["skipItems"];
            string token = ctx.Request.Params["continuationToken"];
            if (token != null)
            {
                startIndex = UInt32.Parse(token);
            }
            else
            {
                startIndex = (skipParam == null) ? 0 : UInt32.Parse(skipParam);
            }

            maxCount = (topParam == null) ? defaultMaxCount : UInt32.Parse(topParam);
        }

        /// <summary>
        /// Authorize the user specified in the URI against the user claim in the XAuthData token
        /// </summary>
        /// <param name="ctx">Incoming HttpContext object</param>
        /// <param name="xuid">The user xuid that was in the URI</param>
        /// <param name="error">The errorInfo object to be returned to the caller in case problems are found during validation</param>
        /// <returns>nothing</returns>
        ///  
        public static HResult AuthorizeUser(HttpContext ctx, Puid xuid, ref ErrorInfo error)
        {
            HResult hr = HResult.S_OK;

            IClaimsPrincipal claims = ctx.User as IClaimsPrincipal;

            AuthHelper authHelper = new AuthHelper();
            authHelper.Principal = claims;
            //If user claims not equals passed in user then return error.
            if (claims == null || !authHelper.VerifyEquals(AuthClaimTypes.Xuid, (ulong)xuid))
            {
                hr = RestErrorHandler.InvalidUserError;
                error = new ErrorInfo(hr, "UnAuthorized request", HttpStatusCode.Unauthorized);
                return hr;
            }

            return hr;
        }

        public static Puid ParsePuid(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture))
            {
                s = s.Substring(2);
                return (Puid)Convert.ToUInt64(s, 16);
            }
            else
            {
                return (Puid)Convert.ToUInt64(s);
            }
        }

        public static string ConvertDateTimeToString(DateTime dt)
        {
            return DateTime.SpecifyKind(dt, DateTimeKind.Utc).ToString("o");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\SettingIds.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

                                        
namespace xonline.server.stats.fd 
{
    public class SettingIds
    {
        private static Hashtable _settingIds = null;

        public static Hashtable AllItems
        {
            get
            {
                if (_settingIds == null)
                {
                    LoadSettingIds();
                }
                return _settingIds;
            }
        }
        
        public static void ValidateList(uint[] ids)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            foreach (uint id in ids)
            {
                if (!_settingIds.Contains(id))
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.STATS_CODE_102, "The Setting ID 0x" + id.ToString("X") + " is unknown.");
                }
            }
        }
        
        public static void ValidateList(UserSetting[] settings)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            foreach (UserSetting setting in settings)
            {
                if (!_settingIds.Contains(setting.SettingId))
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.STATS_CODE_103, "The Setting ID 0x" + setting.SettingId.ToString("X") + " is unknown.");
                }
            }
        }
        
        public static SettingInfo Item(uint id)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            return (SettingInfo)_settingIds[id];
        }
            
            
        private static void LoadSettingIds()
        {
            Hashtable ids = new Hashtable();
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_stats_get_setting_ids";
                SqlDataReader reader = cmd.Execute();
                
                while (reader.Read())
                {
                    SettingInfo setting = new SettingInfo();
                    
                    setting.Id = (uint)(int)reader["i_setting_id"];
                    setting.Name = (string)reader["vc_name"];
                    setting.Location = (string)reader["vc_location"];
                    setting.Permissions = (uint)(int)reader["i_permission_flags"];
                    
                    ids[setting.Id] = setting;
                }    
            }
            
            _settingIds = ids;                    
        }
        
        public static void Flush()
        {
            _settingIds = null;
        }    
    }
    
    public class SettingInfo
    {
        public uint Id;
        public string Name;
        public string Location;
        public uint Permissions;

        public ushort GetMaxSize()
        {
            return (ushort)((Id >> 16) & 0x3FF);
        }
        
        public bool IsConsoleWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_CONSOLE_RO) == 0);
        }   
        
        public bool IsWebWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_WEB_RO) == 0);
        }
    
        public bool IsTitleWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_TITLE_RO) == 0);
        }
    
        public bool IsDatabasePersisted()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_TRANSIENT_ONLY) == 0);
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\SetData.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
	// BucketToSplit
    // Contains a bucket that should split
    public class BucketToSplit
	{
		public Guid uidLb  = Guid.Empty;
		public uint uiBkt  = 0;
	}

    // DecoratedMsgSetData
    // MsgSetData plus stuff to help process the request
    class DecoratedMsgSetData : MsgSetData
    {
        public long         _lRating         = 0;       // Rating
        public bool         _fRatingNull     = true;    // Rating is null
        public string       _nickname        = null;    // Nickname
        public ArrayList    _customAttribs   = null;    // All title specific attributes
        public bool         _fAttachCandidate= false;   // Is this update a candidate for an attachment?
        public bool         _fNoUpdate       = false;   // If true, rating does not qualify in lightweight lb.

        new public void ReadFrom(BinaryReader reader)
        {
            base.ReadFrom(reader);

            // Fill out decoration fields
            _customAttribs = new ArrayList((int)_uiAttrCount);

            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                switch(_attribs[ndx]._usAttrId)
                {
                    case SpecialAttrib.Rating:

                        if(_attribs[ndx]._bAttrType != (byte) AttrType.LongLong)
                            throw new Exception("Rating must be LongLong type. Type was " + 
                                _attribs[ndx]._bAttrType);

                        _lRating = (long) _attribs[ndx]._value;
                        _fRatingNull = false;
                        break;

                    case SpecialAttrib.Nickname:

                        if(_attribs[ndx]._bAttrType != (byte) AttrType.String)
                            throw new Exception("Nickname must be a string. Type was " + 
                                _attribs[ndx]._bAttrType);

                        _nickname = (string) _attribs[ndx]._value;

                        if(_nickname.Length > ProtocolConstant.MaxNicknameLength)
                            throw new Exception("Nickname length("+_nickname.Length+
                                ") > " + ProtocolConstant.MaxNicknameLength);

                        break;

                    default:

                        if((_attribs[ndx]._usAttrId & 0x8000) != 0)
                            throw new Exception("Invalid use of reserved attribute id 0x"+
                                _attribs[ndx]._usAttrId.ToString("x"));

                        _customAttribs.Add(_attribs[ndx]);
                        break;
                }
            }
        }

        // ToString
        // ToString, array version
        static public string ToString(IList msgs)
        {
            StringBuilder str = new StringBuilder(String.Empty);

            foreach(DecoratedMsgSetData msg in msgs)
            {
                str.Append(msg.ToString());
            }

            return str.ToString();
        }
    }

    // XRLCommitAtt
    // HTTP handler for SetData request
    public class XRLSetData : IHttpHandler
	{
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }
        
        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
		{
            uint                   hr          = HResult.S_OK;
			Stream                 inputStream = ctx.Request.InputStream;
            BinaryReader           reqReader   = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper    respWriter  = new BinaryWriterWrapper(ctx.Response.OutputStream);
            uint            uiTitleId   = 0;
            StatDb          statDb      = new StatDb();

            if(inputStream.Length == 0)
            {
                Xom.NtEvent(XEvent.Id.STATS_HACK_97, 
                    "Invalid message SetData. Message body is empty."
                );

                hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                goto lDone;
            }

            // The SetData request is formed by one or more 'specs'. Each spec 
            // contains all the data associated to a user+leaderboard. The first
            // step is to parse all the specs.
            
            ArrayList   setDataMessages = new ArrayList((int)ProtocolConstant.MaxSpecsPerSetDataRequest);
            bool        fNicknameUsed   = false;
            int         iAttrPerSpec    = 0;

            while(inputStream.Position < inputStream.Length)
            {
                // Check max limit
                if(setDataMessages.Count == ProtocolConstant.MaxSpecsPerSetDataRequest)
                {
                    Xom.NtEvent(XEvent.Id.STATS_HACK_98, 
                        "Invalid message SetData. # of specs exceeds {0}.", ProtocolConstant.MaxSpecsPerSetDataRequest
                    );

                    hr = HResult.XONLINE_E_STAT_TOO_MANY_SPECS;
                    goto lDone;
                }
                
                // Parse a spec
                DecoratedMsgSetData msgSetData;
                try
                {
                    msgSetData = new DecoratedMsgSetData();
                    msgSetData.ReadFrom(reqReader);
                }
                catch(Exception e)
                {
                    if(e is XRLException)
                        hr = ((XRLException) e).HResult;
                    else
                        hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                    
                    Xom.NtEvent(XEvent.Id.STATS_HACK_99, e,
                        "Invalid message SetData. "
                    );

                    goto lDone;
                }
                
                uiTitleId = msgSetData._uiTitleId;

                if(Config.GetBoolSetting(Setting.stats_trackCountersPerLb))
                {
                    // Track counters per leaderboard
                    StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgSetData._uiLbId].SetDataPerSecond.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgSetData._uiLbId].SetDataTotal.Increment();
                }
                
                if(msgSetData._nickname != null)
                    fNicknameUsed = true;

                iAttrPerSpec += msgSetData._customAttribs.Count;

                setDataMessages.Add(msgSetData);
            }

            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "XRLSetData:" + DecoratedMsgSetData.ToString(setDataMessages));
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, SGInfo.ToStr());

            // Process specialized performance counters
            iAttrPerSpec /= setDataMessages.Count;
            
            if( iAttrPerSpec > 3 )
            {
                if(fNicknameUsed)
                {
                    StatisticsCounters.Counters.
                        SetDataMT3AttrWithNickname.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].
                        SetDataMT3AttrWithNickname.Increment();
                }
                else
                {
                    StatisticsCounters.Counters.
                        SetDataMT3AttrNoNickname.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].
                        SetDataMT3AttrNoNickname.Increment();
                }
            }
            else
            {
                StatisticsCounters.Counters.SetDataLTE3Attr.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")].
                    SetDataLTE3Attr.Increment();
            }


            // Get the time that the session started from the auth check data. If we're not
            // checking auth data, use the current time. 
            DateTime sessionStarted;

            if(AuthToggle.On)
            {
                try
                {
                    sessionStarted = DateTime.FromFileTime((long)SGInfo.Current.TimeSessionStarted);
                }
                catch(Exception e)
                {
                    hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                    
                    Xom.NtEvent(XEvent.Id.STATS_COMM_4, e,
                        "Failed to get the sessionStarted from SGInfo."+
                        "\nReqSetData: " + DecoratedMsgSetData.ToString(setDataMessages)
                    );
                    goto lDone;
                }
            }
            else
                sessionStarted = DateTime.Now;

            // Get a database connection and start the transaction. 
            IStatDbStatUpdate dbUpdate = statDb.CreateStatUpdate(uiTitleId, sessionStarted, 
                Config.GetBoolSetting(Setting.stats_enableCertificationMode));
            
            // Update title specific attributes and nicknames. 
            try
            {
                foreach(DecoratedMsgSetData msgSetData in setDataMessages)
                {
                    // Security check. Only xbox logged users can change their 
                    // data.
                    
                    if(!Config.GetBoolSetting(Setting.stats_allowUnverifiedWrite))
                    {
                        try
                        {
                            SGInfo.VerifyUserId((ulong)msgSetData._ulUserId);
                            SGInfo.VerifyTitleId(msgSetData._uiTitleId);
                        }
                        catch(Exception e)
                        {
                            hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                            
                            Xom.NtEvent(XEvent.Id.STATS_COMM_5, e,
                                "Cannot verify user. "+
                                "\nReqSetData: " + DecoratedMsgSetData.ToString(setDataMessages)
                            );

                            goto lDone;
                        }
                    }
                    
                    LbUserKey lbUserKey = new LbUserKey(msgSetData._uiLbId, msgSetData._ulUserId);
                    dbUpdate.PlayerLbStart(lbUserKey);
                    
                    foreach(MsgAttribData attribData in msgSetData._attribs)
                    {
                        // BUGBUG: need to support the legacy reset check
                        dbUpdate.PlayerUpdateStat(attribData._usAttrId, attribData._value);
                    }

/* BUGBUG: this counter gotta go.                    
                    // Update counter if write didn't qualify (lightweight leaderboards)
                    if(msgSetData._fNoUpdate)
                    {
                        StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataNotQualifiedPerSecond.Increment();
                        StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataNotQualifiedTotal.Increment();

                        if(StatisticsCounters._trackPerfCountersPerLeaderboard.GetBool())
                        {
                            // Track counters per leaderboard
                            StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgSetData._uiLbId].SetDataNotQualifiedPerSecond.Increment();
                            StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgSetData._uiLbId].SetDataNotQualifiedTotal.Increment();
                        }
                    }
*/                
                }
                
                dbUpdate.Process(new StatDbStatUpdateCallback(setDataMessages));
            }
            catch(Exception e)
            {
                if(e is XRLException)
                    hr = ((XRLException) e).HResult;
                else
                    hr = HResult.XONLINE_E_STAT_ERROR;

                Xom.NtEvent(XEvent.Id.STATS_CODE_14, e,
                    "StatUpdate failed. " +
                    "\nReqSetData: " + DecoratedMsgSetData.ToString(setDataMessages)
                );

                goto lDone;
            }

/*                
            // Get the time that the session started from the auth check data. If we're not
            // checking auth data, use the current time. 
            DateTime sessionStarted;

            if(AuthToggle.On)
                sessionStarted = DateTime.FromFileTime((long)SGInfo.Current.TimeSessionStarted);
            else
                sessionStarted = DateTime.Now;
*/                    

            // Process candidates for attachments
            RepSetDataCanUploadAtt rep  = new RepSetDataCanUploadAtt();
            ArrayList attRefs           = new ArrayList(setDataMessages.Count);
            uint uiMaxAttSize           = 0;
            
            foreach(DecoratedMsgSetData spec in setDataMessages)
            {
                if(spec._fAttachCandidate)
                {
                    if(rep._accessToken == null)
                    {
                        // Fill out the access token. Since it will be one
                        // token for possible multiple leaderboard/users we
                        // have to choose one. Might as well choose the 
                        // first one.
                        
                        rep._accessToken            = new WriteFileToken();
                        rep._accessToken._operation = (ushort) Operation.FileWrite;
                        rep._accessToken._serviceId = (ushort) XOService.Stats;
                        rep._accessToken._flags     = 0;
                        rep._accessToken._userPuid  = spec._ulUserId;
                        rep._accessToken._xboxPuid  = (SGInfo.Current != null ? SGInfo.Current.MachineId : 0);
                        rep._accessToken._pathName  = "//" + ProtocolConstant.AttachStorageDomain + 
                            "/u:" + spec._ulUserId.ToString("x") + "/" + spec._uiTitleId.ToString("x") + "/" + 
                            Guid.NewGuid().ToString();
                        rep._accessToken._tokenExpirationDate = 0;
                        rep._accessToken._fileExpirationDate  = 0;
                        rep._accessToken._maxFileSize = uint.MaxValue; // We'll change this down the road
                        rep._accessToken._signature = null;
                    }
                    
                    RepSetDataReference attRef  = new RepSetDataReference();
                    attRef._uiLb                = spec._uiLbId;
                    attRef._ulUser              = spec._ulUserId;

                    // Register pending attachment in the database
                    try
                    {
                        statDb.RegisterPendingAttachment(spec._uiTitleId, attRef._uiLb, attRef._ulUser, 
                            rep._accessToken._pathName, out uiMaxAttSize);
                    }
                    catch(Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CODE_15, e,
                            "\nPathname:"+rep._accessToken._pathName+
                            "\nSpec: "+ spec.ToString()
                        );
                        
                        // We can't return an error because we have already committed
                        // the stuff to the database. We also can't return this 
                        // reference so we'll have to skip it. Sucks but it's better
                        // than nothing.
                        continue;
                    }
                    
                    // Consolidate max att size. The smallest wins.
                    if(uiMaxAttSize < rep._accessToken._maxFileSize)
                        rep._accessToken._maxFileSize = uiMaxAttSize; 

                    attRefs.Add(attRef);
                }
            }
            
            rep._refs = (RepSetDataReference[]) attRefs.ToArray(typeof(RepSetDataReference));

            // Write response                
            if(rep._refs.Length > 0)
            {
                if(Config.GetBoolSetting(Setting.stats_AllowAlternateDestination))
                {
                    // For test purposes only, if an alternative signonbehalf
                    // url has been provided, pass it on to the access token.
                    if(ctx.Request.Headers["AlternateSignUrl"] != null)
                    {
                        string altSignUrl = ctx.Request.Headers["AlternateSignUrl"];
                        Xom.NtEvent(XEvent.Id.STATS_CONFIG_16, 
                            "Using alternate SignOnBehalf URL: {0}",
                            altSignUrl);
                        rep._accessToken.SetAltSignUrl(altSignUrl);
                    }
                }
                
                // Sign the access token. 
                try
                {
                    rep._accessToken.SignOnBehalf(XOService.Stats);
                    //rep._accessToken._signature = new byte[ProtocolConstants.sizeSignature];
                    hr = HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT;
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.STATS_COMM_6, e, 
                        "Failed to sign the access token. " +
                        "\nReqSetData: " + DecoratedMsgSetData.ToString(setDataMessages) +
                        "\nRepSetDataCanUploadAtt: "+rep.ToString());
                    
                    // Sign process failed. However we can't return an error to the client because
                    // the stats transaction has already been commited. We'll just return S_OK 
                    // instead of the expected S_STAT_CAN_UPLOAD_ATTACHMENT.
                    hr = HResult.S_OK;
                }
            }
            else
            {
                hr = HResult.S_OK;
            }

            // Send response to the client                
            if(hr == HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT)
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, uiTitleId, HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT);
                rep.WriteTo(respWriter);
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "hr = XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT "+
                    "\nRepSetDataCanUploadAtt:"+rep.ToString());
            }
            else
            {
                // For backwards compability purposes return no reply
                // if there are no attachments to upload.
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, uiTitleId, HResult.S_OK);
            }
            
            // Log entry
            StringBuilder logentry = new StringBuilder(
                "SETDATA"
                + "|" + uiTitleId.ToString("x") 
                + "|" + (rep._accessToken != null ? rep._accessToken._pathName : ""));
                
            foreach(DecoratedMsgSetData msg in setDataMessages)
            {
                logentry.Append(
                    "|"+msg._uiLbId.ToString("x")+
                    "|"+msg._ulUserId.ToString("x")+
                    "|"+msg._lRating.ToString("x")+
                    "|"+msg._uiAttrCount.ToString("x"));
            }
             
            Xom.Log(XomAreaName.statslog, logentry.ToString());   

        lDone:

            // Counters
            StatisticsCounters.Counters.SetDataPerSecond.Increment();
            StatisticsCounters.Counters.SetDataTotal.Increment();
            if(uiTitleId != 0)
            {
                StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataTotal.Increment();
            }
            
            if(HResult.Failed(hr))
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, uiTitleId, hr);

                // Counters
                StatisticsCounters.Counters.SetDataFailedPerSecond.Increment();
                StatisticsCounters.Counters.SetDataFailedTotal.Increment();
                if(uiTitleId != 0)
                {
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataFailedPerSecond.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].SetDataFailedTotal.Increment();
                }
            }
		}
        
        protected class StatDbStatUpdateCallback : IStatDbStatUpdateCallback
        {
            public StatDbStatUpdateCallback(ArrayList msgs)
            {
                _msgs = msgs;
            }
            
            public void OnQualifyForAttachment(uint uiLbId, ulong ulPuid)
            {
                foreach(DecoratedMsgSetData msg in _msgs)
                {
                    if( msg._uiLbId == uiLbId
                        && msg._ulUserId == ulPuid )
                    {
                        msg._fAttachCandidate = true;
                    }
                }
            }
            
            protected ArrayList _msgs;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\statsfeapp.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Stats Front-Door (xstatsfd)
 * 
 * statsfeapp.cs
 * 
 * Stats front-end application class
 * 
 * */
using System;
using System.Diagnostics;
using System.Web;
using System.Web.Routing;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.stats.common;

using Microsoft.Xbox.Serialization;

[assembly: XomIisInstallerAttribute( Interface.xstatsfd )]
[assembly: XomIisInstallerAttribute( Interface.xstatsfd_int )]
[assembly: ConfigAttribute(Component.xstatsfd)]

namespace xonline.server.stats.fd 
{
    // StatsFrontEndApp
    // Stats own front-end application class 
    public class StatsFrontEndApp : FrontEndApp
    {
        // OnApplicationStart
        // Gets called by FEApp during application start up
        protected override void OnApplicationStart()
        {
            RegisterRoutes(RouteTable.Routes);

            if(Config.GetBoolSetting(Setting.stats_allowUnverifiedWrite))
            {
                Xom.NtEvent(XEvent.Id.XSTATSFD_ALLOW_UNVERIFIED_STAT_WRITE_IS_ON, 
                    "The setting AllowUnverifiedStatWrite is on. This should *NEVER* "+
                    "happen in production.");
            }
            
            if(Config.GetBoolSetting(Setting.stats_AllowAlternateDestination))
            {
                Xom.NtEvent(XEvent.Id.STATS_CONFIG_22, 
                    "The setting AllowAlternateDestination is on. This should *NEVER* "+
                    "happen in production.");
            }
            
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest2);

            // Load database information
            StatDb.InitializeDbMap();
        }

        private void RegisterRoutes(RouteCollection Routes)
        {
            Routes.Add(new Route("users/xuid({xuid})/settings", new ProfileReadAllSettingsRouteHandler()));
            Routes.Add(new Route("users/xuid({xuid})/progress/achievements", new ProgressReadAllAchievementsRouteHandler()));
            Routes.Add(new Route("users/xuid({xuid})/progress/titleachievements", new ProgressReadAllPossibleAchievementsRouteHandler()));
            Routes.Add(new Route("users/xuid({xuid})/progress/avatarawards", new ProgressReadAllAvatarAwardsRouteHandler()));
            Routes.Add(new Route("users/xuid({xuid})/progress/titleavatarawards", new ProgressReadAllPossibleAvatarAwardsRouteHandler()));
            Routes.Add(new Route("users/xuid({xuid})/titlehistory", new ProgressReadAllTitlesRouteHandler()));

            // Add Platform Visible Leaderboard APIs...
            Routes.Add(new Route("activity/titles/{titleid}/leaderboards", new PlatformVisibleLeaderboardDataRouteHandler()));
            Routes.Add(new Route("activity/titles/{titleid}/leaderboards/{lbid}/users/xuid({xuid})", new PlatformVisibleLeaderboardDataForUserRouteHandler()));
            Routes.Add(new Route("media/titles/{titleid}/leaderboards", new PlatformVisibleLeaderboardDataRouteHandler()));
            Routes.Add(new Route("media/titles/{titleid}/leaderboards/{lbid}/users/xuid({xuid})", new PlatformVisibleLeaderboardDataForUserRouteHandler()));
        }
        
        // Application_BeginRequest
        // Gets called at the beginning of every request
        public override void Application_BeginRequest(object sender, EventArgs e)
        {
            base.Application_BeginRequest(sender, e);
            
        }

        // Application_End
        // Called when application is shutting down.
        public override void Application_End(object sender, EventArgs e)
        {
            base.Application_End(sender, e);
            Config.ServerListChange += new ServerListChangeEventHandler(OnChangeServerList);
        }

        public static void OnChangeServerList(object sender, ServerListChangeEventArgs e)
        {
        }
        
        public static void OnControlRequest2(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command)
            {
            case "help":
                XomControlConnection.SendMessage(
                    "To reload the title map from the databases:\n" +
                    "  ReloadDbMap\n"+
                    "To reload the platform visible leaderboard title map from the databases:\n" +
                    "  reloadplatformvisibleleaderboards\n"+ 
                   "To set debug trace filter on puid:\n"+
                    "  SetDebugPuid <puid>\n" +
                    "To flush the cached setting ids:\n"+
                    "  cacheflush\n"
                    , args.RequestId);
                args.Handled = true;
                break;
            case "reloaddbmap":
                StatDb.InitializeDbMap();
                
                XomControlConnection.SendMessage(
                    "InitializeDbMap Called ", args.RequestId);
                args.Handled = true;
                break;
            case "reloadplatformvisibleleaderboards":
                StatDb.InitializePlatformVisibleLeaderboardMap();

                XomControlConnection.SendMessage(
                    "InitializePlatformVisibleLeaderboardMap Called ", args.RequestId);
                args.Handled = true;
                break;
            case "cacheflush":
                SettingIds.Flush();
                XomControlConnection.SendMessage(
                    "Setting IDs flushed.  They will be reloaded on the next " + 
                    "read or sync settings call.", args.RequestId);
                args.Handled = true;
                break;
            case "setdebugpuid":
                throw new Exception("Not implemented"); // BUGBUG
            }
        }        

        public static string GetResponseContentType(HttpContext ctx)
        {
            if (ctx.Request.AcceptTypes != null)
            {
                foreach (string accepted in ctx.Request.AcceptTypes)
                {
                    if (Array.IndexOf<string>(DataSerializer.SupportedContentTypes, accepted) >= 0)
                    {
                        return accepted;
                    }
                }
            }

            if (Array.IndexOf<string>(DataSerializer.SupportedContentTypes, ctx.Request.ContentType) >= 0)
            {
                return ctx.Request.ContentType;
            }

            return DataSerializer.ContentTypeDefault;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\StatsLBSvrHealthBlock.cs ===
// 
// StatsLBSvrHealthBlock.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Stats Front Door - HealthCheck
// Xbox Online Service
// 
//

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Collections.Specialized;
using System.Globalization;
using System.Xml;
using System.Collections;
using System.Collections.Generic;

using xonline.common.health;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{

    /// <summary>
    /// Enum representing the connection status to the LeaderBoard server
    /// </summary>
    public enum ServerStatus
    {
        Connected = 1,

        UnableToConnect = 2,
    }

    /// <summary>
    /// Stats HealthCheck to check connectivity to the LeaderBoard server
    /// </summary>
    public class StatsLBSvrHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        /// <summary>
        /// The heart of the health check
        /// </summary>
        /// <param name="blockManager"></param>
        /// <param name="blockParams"></param>
        /// <param name="report"></param>
        public void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport report
        )
        {
            bool allServersVerified = true;

            try
            {
                StatDb statDb = new StatDb();

                List<ServerStatusInfo> allServerStatus = statDb.VerifyConnectionToLeaderboards();               
                report.ExtendedReport = new StatsLeaderboardServerReport(allServerStatus);

                foreach ( ServerStatusInfo singleServerStatus in allServerStatus)
                {
                    if (singleServerStatus.Status != ServerStatus.Connected)
                    {
                        allServersVerified = false;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }

            //On Success
            if (allServersVerified)
                report.HealthStatus = HealthStatusEnum.Green;
            else
                report.HealthStatus = HealthStatusEnum.Yellow;

        }
    }


    /// <summary>
    /// HealthReport that contains the information regd the various servers & their status
    /// </summary>
    public class StatsLeaderboardServerReport : IExtendedHealthReport
    {
        //public SerializableDictionary< string, string> serverDetails = new SerializableDictionary<string, string>();
        public List<ServerStatusInfo> serverDetails = new List<ServerStatusInfo>();

        public StatsLeaderboardServerReport(List<ServerStatusInfo> serverStates)
        {
            serverDetails = serverStates;
        }

        //Parameter less contructor for enabling Serialization
        public StatsLeaderboardServerReport()
        {
        }

    }

    /// <summary>
    /// Container class for storing information regarding the leaderboard server stauts
    /// </summary>
    public class ServerStatusInfo
    {

        public string           ServerName;
        public ServerStatus     Status;
        public string           Information;
        
        public ServerStatusInfo()
        {

        }

        public ServerStatusInfo(string svrName, ServerStatus statusCode , string info)
        {
            if (!string.IsNullOrEmpty(svrName))
                ServerName = svrName;

            Status = statusCode;

            Information = info;
        }

    }




     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\util.cs ===
using System;
using System.IO;
using System.Net;
using System.Web;
using System.Text;
using System.Collections;
using System.Data.SqlClient;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;
using xonline.common.mgmt;
using xonline.common.config;

using System.Globalization;

namespace xonline.server.stats.fd 
{
    public class StatsFdIO : IStatIO
    {
        public StatsFdIO(HttpContext ctx)
        {
            _ctx = ctx;
        }
        
        public Stream InputStream
        {
            get { return _ctx.Request.InputStream; }
        }
        
        public Stream OutputStream 
        {
            get { return _ctx.Response.OutputStream; }
        }

        public HttpResponse Response
        {
            get { return _ctx.Response; }
        }
        
        public void SetXErr(uint uiTitleId, uint hr)
        {
            XRLUtil.SetXRLResponse(_ctx.Response, XOService.Stats, uiTitleId, hr);
        }
        
        protected HttpContext _ctx;
    }
    
    public class StatsFdUtil
    {
        /// <summary>
        /// Extract the Accept-Language header string from the HttpRequest context, if provided.
        /// If multiple locales are provided, always return the first one specified in the list
        /// list, regardless of any provided locale weights.  If no locale is provided, return 
        /// en-US by default.
        /// </summary>
        /// <param name="ctx">HttpContext of incoming HttpRequest</param>
        /// <returns>CultureInfo for the requestd Accept-Language header</returns>
        /// 
        public static CultureInfo GetCultureInfoFromRequestHeader(HttpContext ctx)
        {
            try
            {
                string locales = ctx.Request.Headers["Accept-Language"]; 
                if (string.IsNullOrEmpty(locales))
                {
                    return new CultureInfo("en-US");
                }
                else
                {
                    string[] rglocales = locales.Split(new char[] { ',', ';' } );
                    return new CultureInfo(rglocales[0]); // first locale always wins
                }
            }
            catch
            {
                return new CultureInfo("en-US");
            }
        }

        public static StatAuth BuildStatAuth(HttpContext ctx, string viface)
        {
            if(AuthToggle.Off)
            {
                return null;
            }
            
            ArrayList puids = new ArrayList(16);
            ulong ulMachineId;

            if (VirtualInterface.xstatsfd == viface || (VirtualInterface.xstatsfd_int == viface && ctx.Request.Headers[XHttpHdr.BUNDLEDAUTHDATA] == null))
            {
                // Request came from XBOX or LiveCache. Only the stats of users that were logged on can be modified. We get 
                // the list of logged users from SGInfo.
                
                for(int i=0; i < SGInfo.Current.LogonUsers.Length; i++)
                {
                    if(SGInfo.Current.LogonUsers[i].qwUserID != 0)
                        puids.Add(SGInfo.Current.LogonUsers[i].qwUserID);
                }
                
                ulMachineId = SGInfo.Current.MachineId;
            }
            else
            {
                // Request came from Arbitration server. The request should contain a HTTP header with encoded
                // information and among it the list of users that participated in the session.
                
                string base64string = (string) ctx.Request.Headers[XHttpHdr.BUNDLEDAUTHDATA];
                
                if(base64string == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_70,
                        "Request from arbitration server does not have bundled auth data http header.");
                        
                BundledAuthData bundledAuthData = new BundledAuthData(base64string);
                
                for(int i=0; i < bundledAuthData.users.Length; i++)
                {
                    if(bundledAuthData.users[i].qwUserID != 0)
                        puids.Add(bundledAuthData.users[i].qwUserID);
                }
            
                ulMachineId = 0;
            }
            
            return new StatAuth(ulMachineId, (ulong[]) puids.ToArray(typeof(ulong)));
        }
        
        public static void EnableContextDebuggingBasedOnSGInfo()
        {
            XomLogArea theArea = Xom.GetAreaByName(XomAreaName.ctxDebug);
            if (theArea != null && theArea.FilterLevel != XomLogLevel.Muted && theArea.ContextOnly )
            {
                // Context debug is enabled but we don't have enough information to decide weather or not to log.
                // We're particularly interested in the users logged on but we usually don't do SG auth for read-only
                // requests. But we need one now, so let's do it.
                try
                {
                    SGInfo sginfo = SGInfo.Current;
                    
                    if(sginfo != null)
                    {
                        for(int iUser=0; iUser < sginfo.LogonUsers.Length; iUser++)
                        {
                            StatsUtil.EnableContextDebugging(sginfo.LogonUsers[iUser].qwUserID);
                        }
                        StatsUtil.EnableContextDebugging(sginfo.MachineId);
                        StatsUtil.EnableContextDebugging((ulong)sginfo.TitleId);
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_WARNING, "No SG auth");
                    }
                }
                catch
                {
                    // We did what we could.
                }
            }
        }
    }
    
#if false
    public class LeakTrack
    {
        static LeakTrack()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(LeakTrack.OnControlRequest);
        }
        
        static public void Add(SqlConnection sql)
        {
            Monitor.Enter(_tracking);
            
            try
            {
                _tracking.Add(sql, Environment.StackTrace);
            }
            finally
            {
                Monitor.Exit(_tracking);
            }
        }
        
        static public void Remove(SqlConnection sql)
        {
            Monitor.Enter(_tracking);
            
            try
            {
                _tracking.Remove(sql);
            }
            finally
            {
                Monitor.Exit(_tracking);
            }
        }

        static protected void ClearLeak()
        {
            Monitor.Enter(_tracking);
            
            try
            {
                _tracking.Clear();
            }
            finally
            {
                Monitor.Exit(_tracking);
            }
        }
        
        static protected void DumpLeak()
        {
            Monitor.Enter(_tracking);
            
            try
            {
                foreach(string stack in _tracking.Values)
                {
                    Xom.Trace(XomAreaName.statdb, LogLevel.L_NORMAL, stack);
                }
            }
            finally
            {
                Monitor.Exit(_tracking);
            }
        }
        
        static public void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command)
            {
            case "clearleak":
                ClearLeak();
                args.Handled = true;
                break;
            case "dumpleak":
                DumpLeak();
                args.Handled = true;
                break;
            }
        }        
        
        static protected Hashtable _tracking = new Hashtable(200);
    }
#endif    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlAvatarAssetEnum.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAvatarAssetEnum.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class XRLAvatarAssetEnum : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>True/False</retruns>
        /// <remarks>
        /// Returns if this object can be reused. Since the object doesn't hold
        /// any state, this method always returns true.
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP input context</param>
        /// <remarks>
        /// Process incoming AvatarAsset enum request.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.E_FAIL;

            EnumAvatarAssetsCounters counters = new EnumAvatarAssetsCounters();
            AvatarAssetEnumRequest req = new AvatarAssetEnumRequest();
            AvatarAssetEnumResponse resp = new AvatarAssetEnumResponse();

            ArrayList avatarAssets = new ArrayList();
            ArrayList assetIds = new ArrayList();
            TitleConfig titlecfg = null;
            Friend[] friends = null;
            string[] locales;

            // If the database query returns assets marked with the 'NOT_ACHIEVABLE' or 'WAS_NOT_ACHIEVABLE'
            // flags, we pull them put of the list and save the flags so we can sort with the unachieved assets.
            // This means the user was caught cheating and had awarded assets removed from their profile.
            // Since this is a rare occurance, allocate this list on-demand.
            SortedList unachievable = null;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyUserId(req.Puid);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.Puid, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                hr = Profile.CheckPermissions(req.Puid, req.ForPuid, XOn.XPROFILE_SETTING_ENFORCE_ACTIVITY, ref friends);

                if (HResult.Failed(hr))
                {
                    goto end;
                }

                // Still assume something went wrong until the end
                hr = HResult.E_FAIL;

                // TitleId == 0 is a special case that indicates that the client wants to
                // enumerate all of the awards for the user regardless of title.
                // For that case, we'll load the correct title config as we get awards
                // back from the database.
                if (req.TitleId != 0)
                {
                    titlecfg = TitleConfig.GetTitle(req.TitleId, false /* throwOnNotFound */);

                    if (null == titlecfg)
                    {
                        // It's possible to attempt to enumerate avatar assets for a title that
                        // has no XLAST file.  For example, if the last title a profile played
                        // was an Xbox 1 title then the guide will attempt to get the
                        // avatar assets for that title.  It can't tell what titleids are valid
                        // for enumerating and which are not.  So we silently return no
                        // avatar assets if there is no XLAST file.
                        goto end;
                    }
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();

                    ws.StoredProc = "p_avatar_asset_enum";
                    ws.Partition = ws.CalcPartition(req.ForPuid);

                    ws.AddParameter("@bi_user_puid", req.ForPuid);
                    ws.AddParameter("@i_title_id", req.TitleId);

                    WstDataReader reader = ws.Execute();

                    while (reader.Read())
                    {
                        uint assetTitleId = (uint)(int)reader["i_title_id"];
                        uint assetOrdinal = (uint)(int)reader["i_asset_ordinal"];
                        byte assetBodyTypeMask = (byte)(int)reader["i_body_type_mask"];
                        DateTime awarded = (DateTime)reader["dt_awarded"];
                        int status = (int)reader["i_status"];
                        int flags = status | ((int)reader["i_platform"]);
                        uint sequence = (uint)(int)reader["i_sequence"];

                        if ((status & XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE) != 0)
                        {
                            // Create a new unachievable list if needed and add this asset to the list.
                            // When an asset is marked with XAVATAR_DETAILS_NOT_ACHIEVABLE, we keep
                            // the achieved and achieved online flags in case we want to reset the
                            // XAVATAR_DETAILS_NOT_ACHIEVABLE, but we don't want to return the achieved flags to
                            // the client - to clients, the asset is considered unachieved.
                            if (unachievable == null)
                            {
                                unachievable = new SortedList();
                            }
                            unachievable.Add(new TitleAvatarAssetKey(assetTitleId, assetOrdinal, assetBodyTypeMask), (int)XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE);
                        }
                        else
                        {
                            AvatarAsset a = new AvatarAsset();

                            // If the avatar asset was not earned online then we set an
                            // invalid date.  Use SQL's minimum date.
                            if (0 == (flags & XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE))
                            {
                                awarded = new DateTime(1753, 1, 1);
                            }

                            a.AvatarAssetOrdinal = assetOrdinal;
                            a.Awarded = awarded;
                            a.Flags = flags;
                            a.Sequence = sequence;

                            // The client will pass title id == 0 to indicate that it wants all awards for the user
                            // regardless of title. If that's the case, we might need to get a new title config here
                            if (titlecfg == null || titlecfg.TitleId != assetTitleId)
                            {
                                titlecfg = TitleConfig.GetTitle(assetTitleId, true /* throwOnNotFound */);
                            }

                            TitleAvatarAssetKey key = new TitleAvatarAssetKey(assetTitleId, assetOrdinal, assetBodyTypeMask);
                            TitleAvatarAsset tasset = (TitleAvatarAsset)titlecfg.AvatarAssets[key];

                            if (tasset != null)
                            {
                                a.AvatarAssetId = tasset.Id.Bytes;
                                a.ImageId = tasset.ImageId;
                                a.Title = tasset.Title[locales];
                                a.Description = tasset.Description[locales];
                                a.HowTo = tasset.Unachieved[locales];
                                a.BodyTypeMask = tasset.Id.BodyTypeMask;
                                a.BodyComponent = tasset.Id.BodyComponent;
                                a.SubCategory = tasset.SubCategory;
                                a.Flags |= (int)(tasset.ShowUnachieved ? XOn.XAVATAR_DETAILS_SHOWUNACHIEVED : 0);
                            }
                            else
                            {
                                a.Title = "ERROR: Missing Avatar Asset!";
                                a.Description = "ERROR: Missing Avatar Asset!";
                                a.HowTo = "ERROR: Missing Avatar Asset!";
                                a.Flags = (int)XOn.XAVATAR_DETAILS_SHOWUNACHIEVED;
                            }

                            avatarAssets.Add(a);

                            if (avatarAssets.Count >= req.StartingIndex + req.MaxAssets)
                            {
                                break;
                            }

                            assetIds.Add(key);
                        }
                    }

                    if (avatarAssets.Count < req.StartingIndex + req.MaxAssets && req.TitleId != 0)
                    {
                        // we still need more, add on the list of unawarded
                        // avatar assets
                        assetIds.Sort();

                        // now populate the rest of the returned list with any
                        // unawarded avatar assets
                        //
                        for (int i = 0; i < titlecfg.AvatarAssets.Count; i++)
                        {
                            TitleAvatarAsset tasset = (TitleAvatarAsset)titlecfg.AvatarAssets.GetByIndex(i);
                            TitleAvatarAssetKey key = new TitleAvatarAssetKey(titlecfg.TitleId, tasset.Id.AwardOrdinal, tasset.Id.BodyTypeMask);

                            if (assetIds.BinarySearch(key) < 0)
                            {
                                AvatarAsset a = new AvatarAsset();

                                a.AvatarAssetId = tasset.Id.Bytes;
                                a.AvatarAssetOrdinal = tasset.Id.AwardOrdinal;
                                a.Awarded = XOn.MinDateTime;
                                a.BodyComponent = tasset.Id.BodyComponent;
                                a.BodyTypeMask = tasset.Id.BodyTypeMask;
                                a.Description = tasset.Description[locales];
                                a.Flags = (int)(tasset.ShowUnachieved ? XOn.XAVATAR_DETAILS_SHOWUNACHIEVED : 0);
                                a.HowTo = tasset.Unachieved[locales];
                                a.ImageId = tasset.ImageId;
                                a.Sequence = 0;
                                a.SubCategory = tasset.SubCategory;
                                a.Title = tasset.Title[locales];

                                // If we noted this asset as unachievable in the database query results,
                                // add the flags from those results.
                                if (unachievable != null)
                                {
                                    object flags = unachievable[key];
                                    if (flags != null)
                                    {
                                        a.Flags |= (int)flags;
                                    }
                                }

                                avatarAssets.Add(a);

                                if (avatarAssets.Count >= req.StartingIndex + req.MaxAssets)
                                {
                                    break;
                                }
                            }
                        }
                    }

                    resp.AvatarAssetsCount = (ushort) Math.Max(avatarAssets.Count - req.StartingIndex, 0);
                    resp.AvatarAssets = new AvatarAsset[resp.AvatarAssetsCount];

                    if (resp.AvatarAssetsCount > 0)
                    {
                        avatarAssets.CopyTo(req.StartingIndex, resp.AvatarAssets, 0, resp.AvatarAssets.Length);
                    }
                }

                hr = HResult.S_OK;

end:
                ;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUV|{0:x}|{1:x}|{2:x}|{3:x}",
                    hr,
                    req.Puid,
                    req.TitleId,
                    req.ForPuid);

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }
    }


    public class EnumAvatarAssetsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            EnumAvatarAssetsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            EnumAvatarAssetsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(
                new PerformanceCounter[]{
                    EnumAvatarAssetsCountersCategory.Current(titleId).FailuresPerSecond,
                    EnumAvatarAssetsCountersCategory.Current(titleId).FailuresTotal
                    });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
            {
                EndRequestWorker(hexTitleId, failed);
            }
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            EnumAvatarAssetsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            EnumAvatarAssetsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                EnumAvatarAssetsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                EnumAvatarAssetsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: EnumAvatarAssets", "Stats FD: EnumAvatarAssets" )]
    public class EnumAvatarAssetsCountersCategory: XomPerformanceCounterCategory
    {

        static public EnumAvatarAssetsCountersCategory _instance = new EnumAvatarAssetsCountersCategory();
        static public EnumAvatarAssetsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(EnumAvatarAssetsCountersCategory)_instance.GetInstance(titleId);
        }

        // EnumAvatarAssets request counters

        [XomPerformanceCounterAttr(
                                 "EnumAvatarAssets requests/sec",
                                 "EnumAvatarAssets requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumAvatarAssets total",
                                 "Total EnumAvatarAssets requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "EnumAvatarAssets failures/sec",
                                 "Number of unsuccessful results returned by EnumAvatarAssets per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumAvatarAssets total failures",
                                 "Total number unsuccessful results returned by EnumAvatarAssets in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "EnumAvatarAssets avg. execution time",
                                 "EnumAvatarAssets Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlAchievementEnum.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAchievementEnum.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class XRLAchievementEnum : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>True/False</retruns>
        /// <remarks>
        /// Returns if this object can be reused. Since the object doesn't hold
        /// any state, this method always returns true.
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP input context</param>
        /// <remarks>
        /// Process incoming Achievement enum request.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.E_FAIL;

            EnumAchievementsCounters counters = new EnumAchievementsCounters();
            AchievementEnumRequest req = new AchievementEnumRequest();
            AchievementEnumResponse resp = new AchievementEnumResponse();

            ArrayList achievements = new ArrayList();
            ArrayList achIds = new ArrayList();
            TitleConfig titlecfg;
            Friend[] friends = null;
            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyUserId(req.Puid);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.Puid, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                hr = Profile.CheckPermissions(req.Puid, req.ForPuid, XOn.XPROFILE_SETTING_ENFORCE_ACTIVITY, ref friends);

                if (HResult.Failed(hr))
                    goto end;

                // Still assume something went wrong until the end
                hr = HResult.E_FAIL;

                titlecfg = TitleConfig.GetTitle(req.TitleId, false /* throwOnNotFound */);

                if (null == titlecfg)
                {
                    // It's possible to attempt to enumerate achievements for a title that
                    // has no XLAST file.  For example, if the last title a profile played
                    // was an Xbox 1 title then the guide will attempt to get the
                    // achievements for that title.  It can't tell what titleids are valid
                    // for enumerating and which are not.  So we silently return no
                    // achievements if there is no XLAST file.
                    goto end;
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();

                    ws.StoredProc = "p_achievement_enum";
                    ws.Partition = ws.CalcPartition(req.ForPuid);

                    ws.AddParameter("@bi_puid", req.ForPuid);
                    ws.AddParameter("@i_title_id", req.TitleId);

                    WstDataReader reader = ws.Execute();

                    while (reader.Read())
                    {
                        uint     achievementId = (uint) (int) reader["i_achievement_id"];
                        DateTime achieved      = (DateTime) reader["dt_achieved"];
                        int      flags         = (int) reader["i_flags"];
                        uint     sequence     = (uint) (int) reader["i_sequence"];

                        Achievement a = new Achievement();

                        // If the achievement was not earned online then we set an
                        // invalid date.  That date is SQL's minimum date because
                        // that's what legacy achievements have.
                        if (0 == (flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE))
                            achieved = new DateTime(1753, 1, 1);

                        a.AchievementId = achievementId;
                        a.Achieved = achieved;
                        a.Flags = flags;
                        a.Sequence = sequence;

                        TitleAchievement tach = (TitleAchievement)titlecfg.Achievements[achievementId];

                        if (tach != null)
                        {
                            a.Type = (byte)tach.Type;
                            a.Cred = tach.Cred;
                            a.ImageId = tach.ImageId;
                            a.Title = tach.Title[locales];
                            a.Description = tach.Description[locales];
                            a.HowTo = tach.Unachieved[locales];
                            a.NextIds = tach.NextIds;
                            a.ReplaceIds = tach.ReplaceIds;
                            a.Flags |= (int)(tach.ShowUnachieved ? XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED : 0 );
                        }
                        else
                        {
                            a.Title = "ERROR: Missing Achievement!";
                            a.Description = "ERROR: Missing Achievement!";
                            a.HowTo = "ERROR: Missing Achievement!";
                            a.Flags = (int)XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                        }

                        achievements.Add(a);

                        if (achievements.Count >= req.StartingIndex + req.MaxAchievements)
                            break;

                        achIds.Add(achievementId);
                    }

                    if (achievements.Count < req.StartingIndex + req.MaxAchievements)
                    {
                        // we still need more, add on the list of unachieved
                        // achievements
                        achIds.Sort();

                        // now populate the rest of the returned list with any
                        // unachived achievements
                        //
                        for (int i = 0; i < titlecfg.Achievements.Count; i++)
                        {
                            TitleAchievement tach = (TitleAchievement)titlecfg.Achievements.GetByIndex(i);

                            if (achIds.BinarySearch((uint)tach.Id) < 0)
                            {
                                Achievement a = new Achievement();

                                a.AchievementId = tach.Id;
                                a.Achieved = XOn.MinDateTime;
                                a.Flags = (int)(tach.ShowUnachieved ? XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED : 0 );
                                a.Type = (byte)tach.Type;
                                a.Cred = tach.Cred;
                                a.Sequence = 0;
                                a.ImageId = tach.ImageId;
                                a.Title = tach.Title[locales];
                                a.Description = tach.Description[locales];
                                a.HowTo = tach.Unachieved[locales];
                                a.NextIds = tach.NextIds;
                                a.ReplaceIds = tach.ReplaceIds;

                                achievements.Add(a);

                                if (achievements.Count >= req.StartingIndex + req.MaxAchievements)
                                    break;
                            }
                        }
                    }

                    resp.AchievementsCount = (ushort) Math.Max(achievements.Count - req.StartingIndex, 0);
                    resp.Achievements = new Achievement[resp.AchievementsCount];

                    achievements.CopyTo(req.StartingIndex, resp.Achievements, 0, resp.Achievements.Length);
                }

                hr = HResult.S_OK;

end:
                ;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUA|{0:x}|{1:x}|{2:x}|{3:x}",
                    hr,
                    req.Puid,
                    req.TitleId,
                    req.ForPuid);

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }
    }


    public class EnumAchievementsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            EnumAchievementsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            EnumAchievementsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(
                new PerformanceCounter[]{
                    EnumAchievementsCountersCategory.Current(titleId).FailuresPerSecond,
                    EnumAchievementsCountersCategory.Current(titleId).FailuresTotal
                    });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            EnumAchievementsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            EnumAchievementsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                EnumAchievementsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                EnumAchievementsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: EnumAchievements", "Stats FD: EnumAchievements" )]
    public class EnumAchievementsCountersCategory: XomPerformanceCounterCategory
    {

        static public EnumAchievementsCountersCategory _instance = new EnumAchievementsCountersCategory();
        static public EnumAchievementsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(EnumAchievementsCountersCategory)_instance.GetInstance(titleId);
        }

        // EnumAchievements request counters

        [XomPerformanceCounterAttr(
                                 "EnumAchievements requests/sec",
                                 "EnumAchievements requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumAchievements total",
                                 "Total EnumAchievements requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "EnumAchievements failures/sec",
                                 "Number of unsuccessful results returned by EnumAchievements per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumAchievements total failures",
                                 "Total number unsuccessful results returned by EnumAchievements in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "EnumAchievements avg. execution time",
                                 "EnumAchievements Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\statdb.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Globalization;
using System.Net;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Web;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;

namespace xonline.server.stats.fd
{
    // StatDb
    public class StatDb : IStatDb
    {
        private static Object platforVisibleLeaderboardMapLock = new Object();

        // InitializeBucketMap
        static public void InitializeDbMap()
        {
            lock(typeof(StatDb))
            {
                // Initialize bucket map. Creating the object will also initialize it.
                StatsDbMap dbSqlMap = new StatsDbMap();

                // If it got this far, the new map is good for use.
                _dbSqlMap = dbSqlMap; // BUGBUG: interlockedexchange?
            }
        }

        // InitializePlatformVisibleLeaderboardMap
        static public void InitializePlatformVisibleLeaderboardMap()
        {
            lock (platforVisibleLeaderboardMapLock)
            {
                // Initialize bucket map. Creating the object will also initialize it.
                PlatformVisibleLeaderboardMap dbPlatformVisibleLeaderboardMap = new PlatformVisibleLeaderboardMap();

                // If it got this far, the new map is good for use.                
                _dbPlatformVisibleLeaderboardMap = dbPlatformVisibleLeaderboardMap; // BUGBUG: interlockedexchange?
            }
        }

        // CreateStatUpdate
        public IStatDbStatUpdate CreateStatUpdate(uint uiTitleId, DateTime sessionStarted, bool fLog)
        {
            return (IStatDbStatUpdate)(new StatDbStatUpdate(this, uiTitleId, sessionStarted, fLog));
        }

        // CreateStatRead
        public IStatDbRead CreateStatRead(uint uiTitleId, bool fLog)
        {
            return (IStatDbRead)(new StatDbRead(this, uiTitleId, fLog, true));
        }

        public IStatDbRead CreateStatReadWithoutReadLimit(uint uiTitleId, bool fLog)
        {
            return (IStatDbRead)(new StatDbRead(this, uiTitleId, fLog, false));
        }

        // GetLbInfo
        public ILeaderboardInfo GetLbInfo(
            uint uiTitleId,
            uint uiLbId )
        {
            return (ILeaderboardInfo) _dbSqlMap.GetLeaderboardInfo(uiTitleId, uiLbId);
        }

        public TitleLbKey[] GetLbListForTitleId(
            uint uiTitleId
        )
        {
            return _dbSqlMap.GetLbListForTitleId(uiTitleId);
        }

        public void RegisterPendingAttachment(
            uint                uiTitleId,
            uint                uiLb,
            ulong               ulUser,
            string              attPathName,
            out uint            uiMaxAttSize )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(uiTitleId, uiLb);

                // If there is a row there already, get the rating. This is
                // necessary to get attachments working with lightweight leaderboards (top100)
                client.BeginRequest(1);
                client.CallProc(LbsvrClientConnection.LbProcIdStatRead, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiLb,
                    (Int64) ulUser
                });

                client.SendRequest();

                object rating = null;

                if(client.NextRowset() && client.Read())
                {
                    int statCount = (client.GetColumnCount() - 3) / 2;

                    for(int i=0; i < statCount; i++)
                    {
                        UInt16 usStatId = (UInt16)(Int16) client.GetColumn(3 + (i*2));
                        object val      = (object)        client.GetColumn(3 + (i*2) + 1);

                        if(usStatId == SpecialAttrib.Rating)
                            rating = (Int64) val;
                    }
                }

                client.Reset();

                // Write the attachment name on the leaderboard. Also initialize
                // the size of the attachment as zero.
                client.BeginRequest(1);
                client.CallProc(LbsvrClientConnection.LbProcIdStatWrite, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiLb,
                    (Int64) ulUser,
                    (Int64) 0,
                    (Int16) 3,
                    unchecked((Int16) SpecialAttrib.AttachmentSize),
                    (Int32) 0,
                    unchecked((Int16) SpecialAttrib.AttachmentPathName),
                    (string) attPathName,
                    unchecked((Int16) SpecialAttrib.Rating),
                    rating
                });

                client.SendRequest();

                if(client.NextRowset())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatWrite", "Response not expected");

                ILeaderboardInfo lbinfo = _dbSqlMap.GetLeaderboardInfo(uiTitleId, uiLb);

                uiMaxAttSize = lbinfo.MaxAttachSize;
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        //returns Rank For Ratings in the same order
        public Int32 [] EstimateRanksForRatings(Int32 nTitleId, Int32 nLbId, UInt64 [] arrulRatings)
        {
            Int32 [] arrnRet = new Int32[arrulRatings.Length];
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;            

            try
            {
                client = dbMap.GetServerConnection((uint)nTitleId, (uint)nLbId);
                client.BeginRequest(1);

                int nCount      = 2 + (arrulRatings.Length);
                object[] arrObj = new object[nCount];

                arrObj[0] = (Int32) nTitleId;
                arrObj[1] = (Int32) nLbId;

                for(int j=0; j < arrulRatings.Length; j++)
                {
                    arrObj[2+(j)]   = (Int64)arrulRatings[j];
                }

                client.CallProc(LbsvrClientConnection.LbProcIdEstimateRankForRatings, arrObj);

                client.SendRequest();

                LbsvrClientResult result;

                if ((result = client.NextResult()) == LbsvrClientResult.Rowset)
                {
                    int nCountItem = 0;
                    while(client.Read())
                    {
                        arrnRet[nCountItem] = (Int32)client.GetColumn(0);
                        nCountItem++;
                    }
                }

                if(client.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdEstimateRankForRatings", "Response not expected");

            }
            catch
            {
                throw;
            }
            finally
            {
                if (client != null)
                {
                    client.Close();
                }
            }

            return arrnRet;
        }

        public void CommitAttachment(
            uint                uiTitleId,
            uint                uiLb,
            ulong               ulUser,
            string              attPathName,
            uint                uiAttSize )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            ILeaderboardInfo lbInfo = dbMap.GetLeaderboardInfo(uiTitleId, uiLb);

            // Check for maximum attachment size violation
            if(uiAttSize > lbInfo.MaxAttachSize)
                throw new XRLException(HResult.XONLINE_E_STAT_INVALID_ATTACHMENT, XEvent.Id.STATS_CODE_104, "Attachment exceeds maximum attachment size allowed for this leaderboard");

            try
            {
                client = dbMap.GetServerConnection(uiTitleId, uiLb);

                // Retrieve the record from the database first
                client.BeginRequest(1);
                client.CallProc(LbsvrClientConnection.LbProcIdStatRead, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiLb,
                    (Int64) ulUser
                });

                client.SendRequest();

                if(!client.NextRowset() || !client.Read())
                    throw new XRLException(HResult.XONLINE_E_STAT_INVALID_ATTACHMENT, XEvent.Id.STATS_CODE_105, "Invalid attachment or attachment not found.");

                UInt32 uiLbId = (UInt32)(Int32) client.GetColumn(0);
                UInt64 puid   = (UInt64)(Int64) client.GetColumn(1);
                object rank   = client.GetColumn(2);
                int statCount = (client.GetColumnCount() - 3) / 2;
                int iAttachSize = 0;
                string attachName = null;
                object rating = null;

                for(int i=0; i < statCount; i++)
                {
                    UInt16 usStatId = (UInt16)(Int16) client.GetColumn(3 + (i*2));
                    object val      = (object)        client.GetColumn(3 + (i*2) + 1);

                    if(usStatId == SpecialAttrib.AttachmentSize)
                        iAttachSize = (Int32) val;
                    else if(usStatId == SpecialAttrib.AttachmentPathName)
                        attachName = (string) val;
                    else if(usStatId == SpecialAttrib.Rating)
                        rating = (Int64) val;
                }

                client.Reset();

                // Verify request against record
                if(attPathName != attachName)
                    throw new XRLException(HResult.XONLINE_E_STAT_INVALID_ATTACHMENT, XEvent.Id.STATS_CODE_106, "Invalid attachment or attachment not found.");

                // Now we can commit the attachment by setting its size in the
                // database
                client.BeginRequest(1);
                client.CallProc(LbsvrClientConnection.LbProcIdStatWrite, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiLb,
                    (Int64) ulUser,
                    (Int64) 0,
                    (Int16) 2,
                    unchecked((Int16) SpecialAttrib.AttachmentSize),
                    unchecked((Int32) uiAttSize),
                    unchecked((Int16) SpecialAttrib.Rating),
                    rating
                });

                client.SendRequest();

                if(client.NextRowset())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatWrite", "Response not expected");
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        public void ResetUser(
            uint                uiTitleId,
            ulong               ulUserId,
            uint                uiLbId )
        {
            if(uiLbId == 0)
            {
                StatsDbMap dbMap = _dbSqlMap;

                TitleLbKey[] lbList = dbMap.GetLbListForTitleId(uiTitleId);

                for(int i=0; i < lbList.Length; i++)
                {
                    ResetPuid(uiTitleId, lbList[i]._uiLbId, ulUserId);
                }
            }
            else
            {
                ResetPuid(uiTitleId, uiLbId, ulUserId);
            }
        }

        public void ResetLeaderboard(
            uint                titleId,
            uint                lbId)
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(titleId, lbId);
                client.BeginRequest(1);

                client.CallProc(LbsvrClientConnection.LbProcIdResetLb, new object[] {
                    (Int32) titleId,
                    (Int32) lbId
                });

                client.SendRequest();

                if(client.NextRowset())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdResetLb", "Response not expected");
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }


        public List<ServerStatusInfo> VerifyConnectionToLeaderboards()
        {
            List<ServerStatusInfo> serverStatusInfo = new List<ServerStatusInfo>();
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;
            ServerInfo[] allServers = null;
            int serverState = 0;

            if (dbMap != null)
                allServers = dbMap.GetAllServerInfo();

            if (allServers != null)
            {
                foreach (ServerInfo serverInfo in allServers)
                {
                    try
                    {
                        client = dbMap.GetServerConnection(serverInfo);

                        client.BeginRequest(1);
                        client.CallProc(LbsvrClientConnection.LbProcIdCheckConnection, new object[] {
                        //No Params
                    });
                        client.SendRequest();

                        LbsvrClientResult result;
                        if ((result = client.NextResult()) == LbsvrClientResult.Rowset)
                        {
                            client.Read(); //We expect only one return value
                            serverState = Convert.ToInt32((object)client.GetColumn(0));
                            serverStatusInfo.Add( new ServerStatusInfo(serverInfo.ServerName, (ServerStatus)serverState, "Connection Successful" ));
                        }
                        else
                        {
                            serverStatusInfo.Add(new ServerStatusInfo(serverInfo.ServerName, ServerStatus.UnableToConnect, "Connection UnSuccessful. Leaderboard server did not return the expected result"));

                        }

                        if (client != null)
                            client.Close();
                    }
                    catch (Exception ex)
                    {
                        serverStatusInfo.Add(new ServerStatusInfo(serverInfo.ServerName, ServerStatus.UnableToConnect, ex.ToString()));

                    }
                    finally
                    {
                        if (client != null)
                            client.Close();
                    }
                }
            }

            return serverStatusInfo;
        }


        public void ResetTitle(
            uint            uiTitleId )
        {
            StatsDbMap dbMap = _dbSqlMap;

            TitleLbKey[] lbList = dbMap.GetLbListForTitleId(uiTitleId);

            for(int i=0; i < lbList.Length; i++)
            {
                ResetLeaderboard(uiTitleId, lbList[i]._uiLbId);
            }
        }

        public void RemoveAttachment(
            uint            uiTitleId,
            string          attachPathName,
            out ulong[]     puids )
        {
            throw new Exception("Not implemented");
        }

        protected struct EnumRow
        {
            public UInt32 uiRank;
            public UInt64 ulPuid;
            public string name;
            public Int64  lRating;
            public EnumStat[] stats;
            public Int32 iAttachSize;
            public bool  fAttachSizeNull;
        };

        protected struct EnumStat
        {
            public UInt16 usStatId;
            public object val;
        };

        public enum EnumType
        {
            User,
            Rank,
            Rating
        }

        /// <summary>
        /// EnumPlatformVisibleLeaderboardsForTitleIdAndLocale
        /// </summary>
        /// <param name="titleId">titleId</param>
        /// <param name="locale">locale</param>
        /// <remarks>
        /// Request platform visible leaderboard data from the in-memory PlatformVisibleLeaderboardMap map.  Try to return only the
        /// leaderboard data for rows that match the provide locale.  If the provided locale is not found (or not provideD), return 
        /// "en-US" instead.  If "en-US" is not found for the provided titleID either, then an object with only the title id filled
        /// out, in which case, a response will be returned with no platform visible leaderboard data for the request.        
        /// </remarks>
        public PlatformLeaderboardResponse EnumPlatformVisibleLeaderboardsForTitleIdAndLocale
        (
            UInt32 titleId, 
            string locale             
        )
        {
            PlatformVisibleLeaderboardMap dbPlatformVisibleLeaderboardMap = _dbPlatformVisibleLeaderboardMap;

            if (dbPlatformVisibleLeaderboardMap == null)
            {
                lock (platforVisibleLeaderboardMapLock)
                {
                    // Initialize bucket map. Creating the object will also initialize it.
                    dbPlatformVisibleLeaderboardMap = new PlatformVisibleLeaderboardMap();

                    // If it got this far, the new map is good for use.                
                    _dbPlatformVisibleLeaderboardMap = dbPlatformVisibleLeaderboardMap; // BUGBUG: interlockedexchange?
                }                
            }

            return dbPlatformVisibleLeaderboardMap.GetPlatformVisibleLeaderboardsForLocale(titleId, locale);
        }

        /// <summary>
        /// GetPlatformLeaderboardData
        /// </summary>
        /// <param name="titleId">titleId</param>
        /// <param name="lbId">lbId</param>
        /// <param name="locale">locale</param>       
        /// <remarks>
        /// If a platform visible leaderboard exists for the requested titleID, lbId, return it, else return null.
        /// If the requested locale is not found, it's "en-US" equivalent is returned instead
        /// </remarks>
        public PlatformVisibleLeaderboardMetadata GetPlatformLeaderboardData
        (
            UInt32 titleId,
            UInt32 lbId,
            string locale
        )
        {            
            PlatformLeaderboardResponse response = null;
            PlatformVisibleLeaderboardMap dbPlatformVisibleLeaderboardMap = _dbPlatformVisibleLeaderboardMap;

            if (dbPlatformVisibleLeaderboardMap == null)
            {
                return null; // no map == no leaderboard
            }

            // protect NDPB by first checking the in-memory cache for support for this request
            if (!dbPlatformVisibleLeaderboardMap.IsLeaderboardPlatformVisible(titleId, locale, lbId))
            {
                return null;
            }

            // Now that we *know* that the title supports PVL data for this title's requested leaderboard, we can feel
            // confident to ask NDPB for the data.
            response = dbPlatformVisibleLeaderboardMap.GetPlatformVisibleLeaderboardsForLocale(titleId, locale);

            if (response == null)
            {
                return null; // no response == no PVL leaderboard metadata
            }
                
            foreach (PlatformVisibleLeaderboardMetadata pvlMetadata in response.leaderboards)
            {
                if (pvlMetadata.id == lbId)
                {
                    return pvlMetadata; // found it!
                }
            }

            return null; // didn't find it!
        }

        /// <summary>
        /// EnumLeaderBoard
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="lbId">Leaderboard ID</param>
        /// <param name="enumType">Enumeration type (user, rank, rating)</param>
        /// <param name="pivot">Pivot value (user id, rank, or rating)</param>
        /// <param name="pageSize">Count of rows to return in enum</param>
        /// <param name="statIds">List of attribute id's</param>
        /// <param name="callback">Leaderboard callback object</param>
        /// <param name="fLog"></param>
        /// <param name="ulCallerPuid"></param>
        /// <param name="uiLbSize">Leaderboard size [OUT]</param>
        /// <param name="uiAttachCount">Max attachment count [OUT]</param>
        /// <param name="uiMaxAttachSize">Max attachment size [OUT]</param>
        /// <remarks>
        /// Send enumeration request to leaderboard server
        /// </remarks>
        public void EnumLeaderBoard
        (
            uint                  titleId,
            uint                  lbId,
            EnumType              enumType,
            ulong                 pivot,
            uint                  pageSize,
            ushort[]              statIds,
            IStatDbEnumLbCallback callback,
            bool                  fLog,
            ulong                 ulCallerPuid,
            out uint              uiLbSize,
            out uint              uiAttachCount,
            out uint              uiMaxAttachSize
        )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            // Get leaderboard info. This is needed to enforce the attachment limits
            ILeaderboardInfo lbInfo = dbMap.GetLeaderboardInfo(titleId, lbId);

            // Build lookup table for stat ids
            Hashtable statIdLookup = new Hashtable(statIds.Length);
            for(int i=0; i < statIds.Length; i++)
                statIdLookup[statIds[i]] = null;

            StatisticsCounters.Counters.StatsEnumPerSecond.Increment(); //Keep a counter of the number of enumerations per leaderboard

            try
            {
                client = dbMap.GetServerConnection(titleId, lbId);
                client.BeginRequest(1);

                switch(enumType)
                {
                    case EnumType.User:
                        client.CallProc(LbsvrClientConnection.LbProcIdStatEnumNearPuid,
                                        new object[]
                                        {
                                            (Int32) titleId,
                                            (Int32) lbId,
                                            (Int64) pivot,
                                            (Int32) pageSize,
                                            (sbyte) 1 // centralize results
                                        });
                        break;

                    case EnumType.Rank:
                        client.CallProc(LbsvrClientConnection.LbProcIdStatEnum,
                                        new object[]
                                        {
                                            (Int32) titleId,
                                            (Int32) lbId,
                                            (Int32) pivot,
                                            (Int32) pageSize
                                        });
                        break;
                    case EnumType.Rating:
                        client.CallProc(LbsvrClientConnection.LbProcIdStatEnumNearRating,
                                        new object[]
                                        {
                                            (Int32) titleId,
                                            (Int32) lbId,
                                            (Int64) pivot,
                                            (Int32) pageSize
                                        });
                        break;
                }

                client.SendRequest();

                // First rowset contains rows
                LbsvrClientResult result = client.NextResult();

                if(result == LbsvrClientResult.None && enumType == EnumType.User)
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_USER_NOT_FOUND, XEvent.Id.STATS_CODE_107,
                        "User not found");
                }

                if(result != LbsvrClientResult.Rowset)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdStatEnum", "Rowset expected");

                EnumRow[] rows = new EnumRow[pageSize];
                int rowcount   = 0;

                while(client.Read())
                {
                    rows[rowcount].uiRank  = (UInt32)(Int32) client.GetColumn(0);
                    rows[rowcount].ulPuid  = (UInt64)(Int64) client.GetColumn(1);
                    rows[rowcount].lRating = -1;
                    rows[rowcount].iAttachSize = 0;
                    rows[rowcount].fAttachSizeNull = true;

                    int statcount = (client.GetColumnCount() - 2) / 2;
                    rows[rowcount].stats = new EnumStat[statcount];

                    for(int i=0; i < statcount; i++)
                    {
                        UInt16 usStatId = (UInt16)(Int16) client.GetColumn(2 + (i*2));
                        object val      = client.GetColumn(2 + (i*2) + 1);

                        rows[rowcount].stats[i].usStatId = usStatId;

                        if( usStatId == SpecialAttrib.AttachmentSize)
                        {
                            // Only return attachment references if puid's rank is within the limit of attachments
                            // configured for this leaderboard or if there are no limit in the attachment count
                            if (lbInfo.AttachCount >= XOn.XONLINE_MAX_STATS_ATTACHMENT_COUNT || rows[rowcount].uiRank <= lbInfo.AttachCount)
                            {
                                rows[rowcount].stats[i].val = val;
                            }
                            else
                            {
                                rows[rowcount].stats[i].val = (Int32)0;
                            }
                        }
                        else if(usStatId == SpecialAttrib.AttachmentPathName)
                        {
                            // Only return attachment references if puid's rank is within the limit of attachments
                            // configured for this leaderboard or if there are no limit in the attachment count
                            if (lbInfo.AttachCount >= XOn.XONLINE_MAX_STATS_ATTACHMENT_COUNT || rows[rowcount].uiRank <= lbInfo.AttachCount)
                            {
                                rows[rowcount].stats[i].val = val;
                            }
                            else
                            {
                                rows[rowcount].stats[i].val = null;
                            }
                        }
                        else
                        {
                            // Other stats
                            rows[rowcount].stats[i].usStatId = usStatId;
                            rows[rowcount].stats[i].val      = val;
                        }

                        if(usStatId == SpecialAttrib.Rating)
                        {
                            rows[rowcount].lRating = (Int64) val;
                        }
                        else if(usStatId == SpecialAttrib.AttachmentSize)
                        {
                            rows[rowcount].iAttachSize = (Int32) val;
                            rows[rowcount].fAttachSizeNull = false;
                        }
                    }

                    rowcount++;
                }

                // Second rowset contains the leaderboard size
                if(!client.NextRowset() || !client.Read())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdStatEnum", "Rowset expected");

                uiLbSize = (uint)(Int32) client.GetColumn(0);
                // TODO: get correct values
                uiAttachCount   = 0;
                uiMaxAttachSize = 0;

                if(client.NextRowset())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatEnum", "Unexpected response");

                client.Close();
                client = null;

                // The leaderboard server contain only puids. It's time to
                // convert the puids to names using XCache. First fill out an
                // array with all puids
                ulong[] puids = new ulong[rowcount];
                string[] names = null;
                for(int i=0; i < rowcount; i++)
                {
                    puids[i] = rows[i].ulPuid;
                }

                // Are these team puids or gamer puids? XCache needs to know
                if (puids!= null && puids.Length > 0)
                {
                    if(lbInfo.IsTeam)
                    {
                        ResolveTeamNames(titleId, puids, out names);
                    }
                    else
                    {
                        ResolvePlayerNames(puids, out names);
                    }
                }

                // Resolve*Names return the names in the corresponding order to
                // the puids. So we just have to do another pass to fill out
                // the names
                for(int i=0; i < rowcount; i++)
                {
                    rows[i].name = names[i];
                }

                for(int i=0; i < rowcount; i++)
                {
                    callback.OnNewRow(rows[i].ulPuid, rows[i].name, rows[i].lRating, rows[i].uiRank);

                    EnumStat[] stats = rows[i].stats;

                    for(int j=0; j < stats.Length; j++)
                    {
                        // BUGBUG: this statId lookup business should be extremely inneficient. Consider exploring stat id sort order.
                        if(statIdLookup.ContainsKey(stats[j].usStatId))
                        {
                            if(stats[j].usStatId == SpecialAttrib.AttachmentPathName &&
                               rows[i].iAttachSize == 0)
                            {
                                continue;
                            }

                            callback.OnAttribute(stats[j].usStatId, stats[j].val);
                        }
                    }

                    // PGR2 legacy issue. If there's no attachment, always return size zero if the
                    // attachment size attribute was requested
                    if(rows[i].fAttachSizeNull && statIdLookup.ContainsKey(SpecialAttrib.AttachmentSize))
                        callback.OnAttribute(SpecialAttrib.AttachmentSize, (Int32)0);
                }
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        public void WebEnumLb(
            uint        titleId, // TitleId
            uint        lbId, // leaderboard
            object      pivotUserId, // User to use as a pivot. If specified, pageStart will be ignored
            uint        pageStart, // Page start
            uint        pageSize, // Size of the page
            IStatDbEnumLbCallback callback,
            out uint    uiLbSize, // [OUT] leaderboard size
            out DateTime lastResetTime // [OUT] last reset time
            )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(titleId, lbId);
                client.BeginRequest(1);

                if(pivotUserId == null)
                {
                    client.CallProc(LbsvrClientConnection.LbProcIdStatEnum, new object[] {
                        (Int32) titleId,
                        (Int32) lbId,
                        (Int32) pageStart,
                        (Int32) pageSize
                    });
                }
                else
                {
                    client.CallProc(LbsvrClientConnection.LbProcIdStatEnumNearPuid, new object[] {
                        (Int32) titleId,
                        (Int32) lbId,
                        (Int64)(UInt64) pivotUserId,
                        (Int32) pageSize,
                        (sbyte) 0 // align results
                    });
                }

                client.SendRequest();

                // First rowset contains rows
                LbsvrClientResult result = client.NextResult();

                if(result == LbsvrClientResult.None && pivotUserId != null)
                {
                    throw new XRLException(HResult.XONLINE_E_STAT_USER_NOT_FOUND, XEvent.Id.STATS_CODE_108,
                        "User not found");
                }

                if(result != LbsvrClientResult.Rowset)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdStatEnum", "Rowset expected");

                EnumRow[] rows = new EnumRow[pageSize];
                int rowcount   = 0;

                while(client.Read())
                {
                    rows[rowcount].uiRank  = (UInt32)(Int32) client.GetColumn(0);
                    rows[rowcount].ulPuid  = (UInt64)(Int64) client.GetColumn(1);
                    rows[rowcount].lRating = -1;

                    int statcount = (client.GetColumnCount() - 2) / 2;
                    rows[rowcount].stats = new EnumStat[statcount];

                    for(int i=0; i < statcount; i++)
                    {
                        UInt16 usStatId = (UInt16)(Int16) client.GetColumn(2 + (i*2));
                        object val      = client.GetColumn(2 + (i*2) + 1);

                        rows[rowcount].stats[i].usStatId = usStatId;
                        rows[rowcount].stats[i].val      = val;

                        if(usStatId == SpecialAttrib.Rating)
                        {
                            rows[rowcount].lRating = (Int64) val;
                        }
                    }

                    rowcount++;
                }

                // Second rowset contains the leaderboard size and last reset time
                if(client.NextResult() != LbsvrClientResult.Rowset || !client.Read())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdStatEnum", "Rowset expected");

                uiLbSize      = (uint)(Int32) client.GetColumn(0);
                lastResetTime = DateTime.FromFileTimeUtc((Int64)client.GetColumn(1));

                if(client.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatEnum", "Unexpected response");

                client.Close();
                client = null;

                for(int i=0; i < rowcount; i++)
                {
                    callback.OnNewRow(rows[i].ulPuid, null, rows[i].lRating, rows[i].uiRank);

                    EnumStat[] stats = rows[i].stats;

                    for(int j=0; j < stats.Length; j++)
                    {
                        if((stats[j].usStatId & 0x8000)==0)
                        {
                            callback.OnAttribute(stats[j].usStatId, stats[j].val);
                        }
                    }
                }
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        // CreateCompetitionLeaderboard
        public void CreateCompetitionLeaderboard(
                uint uiTitleId,
                uint uiTemplateId,
            out uint uiNewLbId )
        {
            SqlConnection sql = null;
            LbsvrClientConnection lbsvrcli = null;
            StatsDbMap dbMap = _dbSqlMap;

            // Get template information
            ILeaderboardInfo lbInfo = GetLbInfo(uiTitleId, (uiTemplateId << StatLbIdParser.TemplateShift));

            try
            {
                // Create new competition leaderboard id
                sql = new SqlConnection(Config.NpdbConnectionString);

                sql.Open();

                SqlCommand cmd   = new SqlCommand("dbo.p_stats_competition_leaderboard_create", sql);

                cmd.CommandType = CommandType.StoredProcedure;

                SqlParameter ret = new SqlParameter();
                ret.Direction    = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);
                cmd.Parameters.Add("@i_title_id",      SqlDbType.Int).Value = (Int32) uiTitleId;
                cmd.Parameters.Add("@i_comp_templ_id", SqlDbType.Int).Value = (Int32) uiTemplateId;

                SqlParameter paramLbId = new SqlParameter("@@i_lb_id", SqlDbType.Int);
                paramLbId.Direction = ParameterDirection.Output;
                cmd.Parameters.Add(paramLbId);

                cmd.ExecuteNonQuery();

                switch((int)ret.Value)
                {
                case 0:
                    break;

                case 1:
                case 2:
                    throw new InvalidCompetitionTemplateStatsException(uiTitleId, uiTemplateId);

                default:
                    throw new UnexpectedReturnCodeFromStoredProcedureStatsException(
                        "p_stats_competition_leaderboard_create", (int)ret.Value);
                }

                // New leaderboard id should be in this output parameter
                uiNewLbId = (UInt32)(Int32)paramLbId.Value;

                // Tell the lbsvr to load the leaderboard
                lbsvrcli = dbMap.GetServerConnection(uiTitleId, uiNewLbId);
                lbsvrcli.BeginRequest(1);

                lbsvrcli.CallProc(LbsvrClientConnection.LbProcIdLoadLb, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiNewLbId
                });

                lbsvrcli.SendRequest();

                if(lbsvrcli.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdLoadLb", "Response not expected");
            }
            finally
            {
                if(sql != null)
                    sql.Close();

                if(lbsvrcli != null)
                    lbsvrcli.Close();
            }
        }

        // DeleteCompetitionLeaderboard
        public void DeleteCompetitionLeaderboard(
            uint uiTitleId,
            uint uiLbId )
        {
            LbsvrClientConnection lbsvrcli = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                lbsvrcli = dbMap.GetServerConnection(uiTitleId, uiLbId);
                lbsvrcli.BeginRequest(1);

                lbsvrcli.CallProc(LbsvrClientConnection.LbProcIdDeleteLb, new object[] {
                    (Int32) uiTitleId,
                    (Int32) uiLbId
                });

                lbsvrcli.SendRequest();

                if(lbsvrcli.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdDeleteLb", "Response not expected");
            }
            catch(LbsvrClientRequestFailureException e)
            {
                if(e.Error == LbsvrClientConnection.LbspErrorLbDoesntExist)
                {
                    throw new InvalidTitleOrLeaderboardStatsException(uiTitleId, uiLbId);
                }
                else
                {
                    throw;
                }
            }
            finally
            {
                if(lbsvrcli != null)
                    lbsvrcli.Close();
            }
        }

        public bool FindRating(
            uint uiTitleId,
            uint uiLbId,
            long lRating,
            ref ulong ulReadPuid,
            ref uint  uiReadRank,
            ref long  lReadRating )
        {
            throw new Exception("Not implemented");
        }

        public void LogReset(ulong ulPuid)
        {
            throw new Exception("Not implemented");
        }

        public CertLogEntry[] LogVerify(ulong ulPuid)
        {
            throw new Exception("Not implemented");
        }

        protected void StatWrite(
            ServerInfo serverInfo,
            uint uiTitleId,
            PlayerLbEntry[] lbEntries,
            IStatDbStatUpdateCallback callback,
            DateTime sessionStarted,
            bool fLog )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(serverInfo);

                client.BeginRequest(lbEntries.Length);

                for(int i=0; i < lbEntries.Length; i++)
                {
                    Attrib[] stats = lbEntries[i].GetSortedStats();

                    int prmcount  = 5 + (stats.Length*2);
                    object[] prms = new object[prmcount];

                    // Fixed parameters:
                    // TitleId
                    prms[0] = (Int32) uiTitleId;
                    // LbId
                    prms[1] = (Int32) lbEntries[i]._lbUserKey.leaderBoardType;
                    // Puid
                    prms[2] = (Int64) lbEntries[i]._lbUserKey.userId;
                    // LogonTime
                    prms[3] = (Int64) sessionStarted.ToFileTimeUtc();
                    // StatCount
                    prms[4] = (Int16) stats.Length;

                    // Variable parameters (the stats):
                    for(int j=0; j < stats.Length; j++)
                    {
                        prms[5+(j*2)]   = (Int16) stats[j]._usStatId;
                        prms[5+(j*2)+1] = stats[j]._val;
                    }

                    client.CallProc(LbsvrClientConnection.LbProcIdStatWrite, prms);
                }

                client.SendRequest();

                if(client.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatWrite", "Response not expected");

                // TODO: modify StatWrite proc to return previous and new rank and rating.
                // The way we're going to do this now, it's going to be kind of a hack

                for(int i=0; i < lbEntries.Length; i++)
                {
                    ILeaderboardInfo lbinfo = _dbSqlMap.GetLeaderboardInfo(uiTitleId,
                        lbEntries[i]._lbUserKey.leaderBoardType);

                    if(lbinfo.AttachCount != 0)
                    {
                        // leaderboard support attachments. Check if entry
                        // qualifies.

                        client.BeginRequest(1);
                        client.CallProc(LbsvrClientConnection.LbProcIdStatRead, new object[] {
                            (Int32) uiTitleId,
                            (Int32) lbEntries[i]._lbUserKey.leaderBoardType,
                            (Int64) lbEntries[i]._lbUserKey.userId
                        });

                        client.SendRequest();

                        if(client.NextResult() != LbsvrClientResult.Rowset || !client.Read())
                            throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdStatRead", "Rowset expected");

                        object rank = client.GetColumn(2);

                        if(client.NextResult() != LbsvrClientResult.None)
                            throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatRead", "Response not expected");

                        if(rank != null && ((UInt32)(Int32)rank) <= lbinfo.AttachCount)
                        {
                            callback.OnQualifyForAttachment(lbEntries[i]._lbUserKey.leaderBoardType,
                                lbEntries[i]._lbUserKey.userId);
                        }
                    }
                }
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        protected void StatRead(
            ServerInfo serverInfo,
            uint uiTitleId,
            LbUserKey[] lbAndUsers,
            IStatDbReadCallback callback,
            bool fLog
        )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(serverInfo);
                client.BeginRequest(lbAndUsers.Length);

                for(int i=0; i < lbAndUsers.Length; i++)
                {
                    client.CallProc(LbsvrClientConnection.LbProcIdStatRead, new object[] {
                        (Int32) uiTitleId,
                        (Int32) lbAndUsers[i].leaderBoardType,
                        (Int64) lbAndUsers[i].userId
                    });
                }

                client.SendRequest();
                LbsvrClientResult result;

                while((result = client.NextResult()) == LbsvrClientResult.Rowset)
                {
                    if(!client.Read())
                        new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatRead", "Empty rowset not expected");

                    UInt32 uiLbId = (UInt32)(Int32) client.GetColumn(0);
                    UInt64 puid   = (UInt64)(Int64) client.GetColumn(1);
                    object rank   = client.GetColumn(2);

                    ILeaderboardInfo lbInfo = dbMap.GetLeaderboardInfo(uiTitleId, uiLbId);

                    callback.OnPlayerLbEntry(puid, uiLbId);

                    if(rank != null)
                        callback.OnPlayerStat(SpecialAttrib.Rank, rank);

                    int statCount = (client.GetColumnCount() - 3) / 2;

                    int iAttachSize   = 0;
                    string attachName = null;

                    for(int i=0; i < statCount; i++)
                    {
                        UInt16 usStatId = (UInt16)(Int16) client.GetColumn(3 + (i*2));
                        object val      = (object)        client.GetColumn(3 + (i*2) + 1);

                        // Can't send attachment size and name yet. We'll store it and make the decision
                        // after this loop
                        if(usStatId == SpecialAttrib.AttachmentSize)
                        {
                            iAttachSize = (Int32) val;
                            continue;
                        }
                        else if(usStatId == SpecialAttrib.AttachmentPathName)
                        {
                            attachName = (string)val;
                            continue;
                        }
                        else
                        {
                            // Process all other stats immediatelly
                            callback.OnPlayerStat(usStatId, val);
                        }
                    }

                    // Only return attachment references if puid's rank is within the limit of attachments
                    // configured for this leaderboard and attachment size > 0
                    if(iAttachSize > 0 && (lbInfo.AttachCount >= XOn.XONLINE_MAX_STATS_ATTACHMENT_COUNT || (rank != null && ((Int32)rank) <= lbInfo.AttachCount)))
                    {
                        callback.OnPlayerStat(SpecialAttrib.AttachmentSize, iAttachSize);
                        callback.OnPlayerStat(SpecialAttrib.AttachmentPathName, attachName);
                    }
                }

                if(result != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdStatRead", "Response not expected");
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        protected void GetLbSize(
            uint titleId,
            uint lbId,
            out uint lbSize
        )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(titleId, lbId);
                client.BeginRequest(1);

                client.CallProc(LbsvrClientConnection.LbProcIdGetLbRankedEntryCount, new object[] {
                    (Int32) titleId,
                    (Int32) lbId
                });

                client.SendRequest();

                if(client.NextResult() != LbsvrClientResult.Rowset || !client.Read())
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_MISSING_RESULTS, "LbProcIdGetLbRankedEntryCount", "Rowset expected");

                lbSize = (uint) (Int32) client.GetColumn(0);

                if(client.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdGetLbRankedEntryCount", "Response not expected");
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        protected void ResetPuid(
            uint titleId,
            uint lbId,
            ulong puid
        )
        {
            LbsvrClientConnection client = null;
            StatsDbMap dbMap = _dbSqlMap;

            try
            {
                client = dbMap.GetServerConnection(titleId, lbId);
                client.BeginRequest(1);

                client.CallProc(LbsvrClientConnection.LbProcIdResetPuid, new object[] {
                    (Int32) titleId,
                    (Int32) lbId,
                    (Int64) puid
                });

                client.SendRequest();

                if(client.NextResult() != LbsvrClientResult.None)
                    throw new LbsvrRequestException(HResult.XONLINE_E_STAT_EXTRA_RESULTS, "LbProcIdResetPuid", "Response not expected");
            }
            finally
            {
                if(client != null)
                    client.Close();
            }
        }

        // Get the corresponding team names to a bunch of team puids
        protected void ResolveTeamNames(
            uint titleId,
            ulong[] puids,
            out string[] names
        )
        {
            try
            {
                 names = XCache.LookupTeamNames(titleId, puids);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.STATS_COMM_7, e, "Call to XCache failed.");

                // Return a bunch of empty strings
                names = new string[puids.Length];

                for(int i=0; i < names.Length; i++)
                {
                    names[i] = string.Empty;
                }
            }
        }

        // Get the corresponding player names to a bunch of player puids
        protected void ResolvePlayerNames(
            ulong[] puids,
            out string[] names
        )
        {
            try
            {
                names = XCache.LookupGamerTags(puids);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.STATS_COMM_8, e, "Call to XCache failed");

                // Return a bunch of empty strings
                names = new string[puids.Length];

                for(int i=0; i < names.Length; i++)
                {
                    names[i] = string.Empty;
                }
            }
        }

        // StatDb members
        static protected            PlatformVisibleLeaderboardMap   _dbPlatformVisibleLeaderboardMap = null;
        static protected            StatsDbMap                      _dbSqlMap = null;
        static private              Mutex                           _initMutex = new Mutex();

        public struct CertLogEntry
        {
            public CertLogEntry(byte bLevel, string description)
            {
                _bLevel         = bLevel;
                _description    = description;
            }

            public byte    _bLevel;
            public string  _description;
        }

        // Attrib
        protected class Attrib : IComparable
        {
            public Attrib(ushort usStatId, object val)
            {
                _usStatId = usStatId;
                _val = val;
            }

            // CompareTo
            public int CompareTo(object obj)
            {
                // When sorting, order by _usStatId ascending
                return _usStatId.CompareTo(((Attrib)obj)._usStatId);
            }

            public ushort _usStatId;
            public object _val;
        }

        // StatDbAttribEncoder
        protected class StatDbAttribEncoder
        {
            // WriteInDbFormat
            static public void WriteInDbFormatForUpdate(
                BinaryWriter    bw,
                ushort          usStatId,
                object          val)
            {
                bw.Write(usStatId);

                if(val == null)
                {
                    bw.Write((ushort)AttrType.None);
                    bw.Write((long)0);
                }
                else if(val is int)
                {
                    bw.Write((ushort)AttrType.Long);
                    bw.Write((long)((int)val));
                }
                else if(val is long)
                {
                    bw.Write((ushort)AttrType.LongLong);
                    bw.Write((long)val);
                }
                else if(val is double)
                {
                    bw.Write((ushort)AttrType.Double);
                    bw.Write((double)val);
                }
            }

            // ReadFromDbFormat
            static public void ReadFromDbFormat(
                BinaryReader    br,
                out ushort      usStatId,
                out object      val )
            {
                usStatId = br.ReadUInt16();
                AttrType attrType = (AttrType) br.ReadUInt16();
                switch(attrType)
                {
                    case AttrType.Long:
                        val = (int)br.ReadInt64();
                        break;
                    case AttrType.LongLong:
                        val = br.ReadInt64();
                        break;
                    case AttrType.Double:
                        val = br.ReadDouble();
                        break;
                    default:
                        throw new Exception("Bad encoding. Data corruption?");
                }
            }
        }

        protected class LbEntry
        {
            public Attrib[] GetSortedStats()
            {
                Attrib[] attribs = new Attrib[_attribs.Count];
                _attribs.Values.CopyTo(attribs, 0);
                Array.Sort(attribs);
                return attribs;
            }

            public bool SetStat(ushort usStatId, object val)
            {
                bool fFirstStat = (_attribs.Count == 0);

                if((usStatId & 0x8000) != 0)
                {
                    if(usStatId != SpecialAttrib.Rating &&
                       usStatId != SpecialAttrib.Nickname &&
                       usStatId != SpecialAttrib.AttachmentSize)
                    {
                        throw new Exception("Invalid use of stat id " + usStatId);
                    }
                }

                _attribs[usStatId] = new Attrib(usStatId, val);

                return fFirstStat;
            }

            public Hashtable        _attribs    = new Hashtable(70);
        }

        protected class PlayerLbEntry : LbEntry
        {
            public PlayerLbEntry(LbUserKey lbUserKey)
            {
                _lbUserKey = lbUserKey;
            }

            public LbUserKey    _lbUserKey;
        }

        // StatDbStatUpdate
        protected class StatDbStatUpdate : IStatDbStatUpdate
        {
            public StatDbStatUpdate(StatDb statDb, uint uiTitleId, DateTime sessionStarted, bool fLog)
            {
                _statDb         = statDb;
                _uiTitleId      = uiTitleId;
                _sessionStarted = sessionStarted;
                _fLog           = fLog;
            }

            public void PlayerLbStart(LbUserKey lbUserKey)
            {
                _currentLbEntry = (PlayerLbEntry) _playerLbEntries[lbUserKey];
                if(_currentLbEntry == null)
                {
                    _currentLbEntry = new PlayerLbEntry(lbUserKey);
                    _playerLbEntries[lbUserKey] = _currentLbEntry;
                }
            }

            public void PlayerUpdateStat(ushort usStatId, object val)
            {
                if(_currentLbEntry.SetStat(usStatId, val))
                    IncrementWriteCounter(_currentLbEntry._lbUserKey.userId);
            }

            public void Process(IStatDbStatUpdateCallback callback)
            {
                VerifyWriteLimit();

                StatisticsCounters.Counters.StatsWritePerSecond.IncrementBy(_playerLbEntries.Values.Count);

                // A title can have leaderboards in different databases. Separate them by server so we can batch
                // requests to each server.
                Hashtable servers = new Hashtable(4);
                foreach(PlayerLbEntry lbEntry in _playerLbEntries.Values)
                {
                    ServerInfo serverInfo = StatDb._dbSqlMap.GetServerInfo(_uiTitleId,
                        lbEntry._lbUserKey.leaderBoardType);

                    ArrayList lbEntryList = (ArrayList) servers[serverInfo];

                    if(lbEntryList == null)
                    {
                        lbEntryList = new ArrayList(_playerLbEntries.Count);
                        servers[serverInfo] = lbEntryList;
                    }

                    lbEntryList.Add(lbEntry);
                }

                // Now batch update requests for each server
                foreach(DictionaryEntry dicentry in servers)
                {
                    ServerInfo serverInfo = (ServerInfo)dicentry.Key;
                    ArrayList lbEntryList = (ArrayList)dicentry.Value;

                    // Prepare lb entries for update.
                    ArrayList statUpdates = new ArrayList(lbEntryList.Count);
                    foreach(PlayerLbEntry lbEntry in lbEntryList)
                    {
                        if(lbEntry._attribs.Count != 0)
                            statUpdates.Add(lbEntry);
                    }

                    _statDb.StatWrite(serverInfo, _uiTitleId,
                        (PlayerLbEntry[]) statUpdates.ToArray(typeof(PlayerLbEntry)), callback, _sessionStarted, _fLog);
                }
            }

            protected void IncrementWriteCounter(ulong ulUserId)
            {
                object writecount = _writesPerUser[ulUserId];

                if(writecount == null)
                {
                    _writesPerUser[ulUserId] = 1;
                }
                else
                {
                    _writesPerUser[ulUserId] = ((int)writecount + 1);
                }
            }

            protected void IncrementWriteCounter(UnitMembersKey members)
            {
                for(int i=0; i < members._members.Length; i++)
                {
                    IncrementWriteCounter(members._members[i]);
                }
            }

            protected void VerifyWriteLimit()
            {
                StatsTitleConfig StatsTitleConfig = StatDb._dbSqlMap.GetStatsTitleConfig(_uiTitleId);

                if(StatsTitleConfig != null)
                {
                    foreach(int iWrites in _writesPerUser.Values)
                    {
                        if(iWrites > StatsTitleConfig._uiMaxWrites)
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_EXCEEDED_WRITE_READ_LIMIT,
                                XEvent.Id.XSTATSFD_INVALID_REQUEST_68, "Request exceeded maximum number of writes per user. "+
                                "TitleID is: " +_uiTitleId + ". Current maximum is: " + StatsTitleConfig._uiMaxWrites +
                               " Write Count Requested is: " + iWrites);
                        }
                    }
                }
            }

            protected StatDb        _statDb;
            protected uint          _uiTitleId;
            protected DateTime      _sessionStarted;
            protected bool          _fLog;
            protected PlayerLbEntry _currentLbEntry     = null;
            protected Hashtable     _playerLbEntries    = new Hashtable(20);
            protected Hashtable     _writesPerUser      = new Hashtable();
        }

        // StatDbRead
        protected class StatDbRead : IStatDbRead
        {
            public StatDbRead(StatDb statDb, uint uiTitleId, bool fLog, bool fVerifyAndUpdateReadLimit)
            {
                _statDb     = statDb;
                _uiTitleId  = uiTitleId;
                _fLog       = fLog;
                _fVerifyAndUpdateReadLimit = fVerifyAndUpdateReadLimit;
            }


            // IStatDbRead::RequestDataForUser
            public void RequestDataForUser(
                LbUserKey       key,
                ushort[]        stats,
                bool            fForcedException)
            {
                // Find out which types of stats were requested.
                bool fReqAttribs    = false;
                bool fReqLbSize     = false;
                for(int i=0; i < stats.Length; i++)
                {
                    if((stats[i] & 0x8000) != 0)
                    {
                        // Special stat. Only rating and rank are currently supported.
                        if( stats[i] == SpecialAttrib.Rating
                            || stats[i] == SpecialAttrib.Rank
                            || stats[i] == SpecialAttrib.AttachmentPathName
                            || stats[i] == SpecialAttrib.AttachmentSize
                            || stats[i] == SpecialAttrib.Nickname )
                        {
                            fReqAttribs = true;
                        }
                        else if( stats[i] == SpecialAttrib.LeaderboardSize )
                        {
                            fReqLbSize = true;
                        }
                        else
                        {
                            // Unsupported special stat.
                            throw new Exception("ASSERT FAILED: invalid special stat "+stats[i]+" requested.");
                        }
                    }
                    else
                    {
                        fReqAttribs = true;
                    }
                }

                ServerInfo serverInfo;

                try
                {
                    serverInfo = StatDb._dbSqlMap.GetServerInfo(_uiTitleId, key.leaderBoardType);
                }
                catch(InvalidTitleOrLeaderboardStatsException)
                {
                    // For backward compability purposes, the old GetData API cannot puke if the title or leaderboard
                    // is invalid. Instead, it just doesn't return any data.
                    if ( fForcedException || !SGInfo.IsXbox() )
                    {
                        throw;//in Xenon we want exception
                    }
                    else
                    {
                        return;
                        //Else do as before
                    }
                }

                ServerDataRequest serverDataRequest = (ServerDataRequest)_serverDataRequests[serverInfo];

                if(serverDataRequest == null)
                {
                    serverDataRequest = new ServerDataRequest(serverInfo);
                    _serverDataRequests[serverInfo] = serverDataRequest;
                }

                if(fReqAttribs)
                {
                    if(!serverDataRequest._playerAttribs.ContainsKey(key))
                    {
                        serverDataRequest._playerAttribs[key] = null;
                        if (_fVerifyAndUpdateReadLimit)
                        {
                            IncrementReadCounter(key.userId);
                        }
                    }
                }

                if(fReqLbSize)
                    serverDataRequest._playerLbSize[key] = null;
            }

            public void Process(IStatDbReadCallback callback)
            {
                if (_fVerifyAndUpdateReadLimit)
                {
                    VerifyReadLimit();
                }

                foreach(ServerDataRequest serverDataRequest in _serverDataRequests.Values)
                {
                    // Batch attribs, rating and attachments
                    if(serverDataRequest._playerAttribs.Count > 101)
                        throw new Exception("ASSERT FAILED: _playerAttribs.Count > 101");

                    if(serverDataRequest._playerAttribs.Count > 0)
                    {
                        LbUserKey[] keys = new LbUserKey[serverDataRequest._playerAttribs.Count];
                        serverDataRequest._playerAttribs.Keys.CopyTo(keys, 0);

                        _statDb.StatRead(serverDataRequest._serverInfo, _uiTitleId, keys, callback, _fLog);

                        StatisticsCounters.Counters.StatsReadPerSecond.IncrementBy(serverDataRequest._playerAttribs.Count);
                    }

                    if(serverDataRequest._playerLbSize.Count > 0)
                    {
                        foreach(LbUserKey key in serverDataRequest._playerLbSize.Keys)
                        {
                            uint lbSize;
                            _statDb.GetLbSize(_uiTitleId, key.leaderBoardType, out lbSize);
                            callback.OnPlayerLbEntry(key.userId, key.leaderBoardType);
                            callback.OnPlayerStat(SpecialAttrib.LeaderboardSize, (Int32) lbSize);
                        }
                    }
                }
            }

            protected void IncrementReadCounter(ulong ulUserId)
            {
                object readcount = _readsPerUser[ulUserId];

                if(readcount == null)
                {
                    _readsPerUser[ulUserId] = 1;
                }
                else
                {
                    _readsPerUser[ulUserId] = ((int)readcount + 1);
                }
            }

            protected void IncrementReadCounter(UnitMembersKey members)
            {
                for(int i=0; i < members._members.Length; i++)
                {
                    IncrementReadCounter(members._members[i]);
                }
            }

            protected void VerifyReadLimit()
            {
                StatsTitleConfig StatsTitleConfig = StatDb._dbSqlMap.GetStatsTitleConfig(_uiTitleId);

                if(StatsTitleConfig != null)
                {
                    foreach(int iReads in _readsPerUser.Values)
                    {
                        if(iReads > StatsTitleConfig._uiMaxReads)
                        {
                            throw new XRLException(HResult.XONLINE_E_STAT_EXCEEDED_WRITE_READ_LIMIT,
                                XEvent.Id.XSTATSFD_INVALID_REQUEST_69, "Request exceeded maximum number of reads per user. "+
                                "Current maximum is: " + StatsTitleConfig._uiMaxReads + " Read Count Requested: " + iReads);
                        }
                    }
                }
            }

            public StatDb       _statDb;
            public uint         _uiTitleId;
            public bool         _fLog;
            public bool         _fVerifyAndUpdateReadLimit;
            public Hashtable    _units = new Hashtable();
            public Hashtable    _serverDataRequests = new Hashtable();
            public Hashtable    _readsPerUser = new Hashtable();

            public class ServerDataRequest
            {
                public ServerDataRequest(ServerInfo serverInfo)
                {
                    _serverInfo = serverInfo;
                }

                public ServerInfo    _serverInfo;
                public Hashtable        _playerAttribs = new Hashtable();
                public Hashtable        _playerLbSize = new Hashtable();
            }
        }
    }

    public class ServerInfo
    {
        public ServerInfo(string server, IInterfaceInfo face)
        {
            _server = server.ToLower();
            _face   = face;
        }

        public override string ToString()
        {
            return
                "\n(LbsvrInfo)"+
                "\n_server: " + _server +
                "\n_face: "+_face.IPAddress.ToString()+","+_face.Port.ToString();
        }

        public string ServerName        { get { return _server; }  }
        public IInterfaceInfo Interface { get { return _face; } }

        protected string _server;
        protected IInterfaceInfo _face;
    }

    public class StatsTitleConfig
    {
        public StatsTitleConfig(uint uiTitleId, uint uiMaxWrites, uint uiMaxReads)
        {
            _uiTitleId      = uiTitleId;
            _uiMaxWrites    = uiMaxWrites;
            _uiMaxReads     = uiMaxReads;
        }

        public uint     _uiTitleId;
        public uint     _uiMaxWrites;
        public uint     _uiMaxReads;
    }    

    // PlatformVisibleLeaderboardMap
    public class PlatformVisibleLeaderboardMap
    {
        const string DefaultLocale = "en-US";

        protected Dictionary<PlatformVisibleTitleLocKey, List<UInt32>> _platformVisibleLeaderboards = new Dictionary<PlatformVisibleTitleLocKey, List<UInt32>>();
        
        public PlatformVisibleLeaderboardMap()
        {
            Initialize();
        }

        protected void Initialize()
        {
            BuildPlatformVisibleLeaderboardMap();
        }

        public bool IsLeaderboardPlatformVisible(UInt32 titleId, string locale, UInt32 lbid)
        {
            return (_platformVisibleLeaderboards.ContainsKey(new PlatformVisibleTitleLocKey(titleId, locale)) ||
                    _platformVisibleLeaderboards.ContainsKey(new PlatformVisibleTitleLocKey(titleId, DefaultLocale)));
        }

        /// <summary>
        /// Get all current platform visible leaderboard data for a given titleId and locale within NPDB, and 
        /// return that in a pre-formatted response data structure that can be serialized to a client.
        /// </summary>
        /// <param name="titleID">titleId</param>
        /// <param name="locale">locale</param>
        static private PlatformLeaderboardResponse GetPlatformLeaderboardMetadataFromNDPB(uint titleId, string locale)
        {
            PlatformLeaderboardResponse response = null;

            using (SqlConnection leaderboardConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                leaderboardConn.Open();
                SqlCommand lbCmd = leaderboardConn.CreateCommand();
                lbCmd.CommandType = CommandType.StoredProcedure;
                lbCmd.CommandText = "dbo.p_stats_platform_visible_leaderboards_get_title_metadata_for_locale";
                lbCmd.Parameters.AddWithValue("@i_title_id", (int)titleId);
                lbCmd.Parameters.AddWithValue("@vc_locale", (string)locale);

                SqlDataReader lbReader = lbCmd.ExecuteReader();

                // do we have results?
                while (lbReader.Read())
                {
                    uint lbid = (uint)lbReader.GetInt32(lbReader.GetOrdinal("i_lb_id"));
                    ushort ratingAttrId = (ushort)lbReader.GetInt16(lbReader.GetOrdinal("si_rating_attr_id"));
                    byte flags = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_flags"));
                    byte type = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_type"));
                    byte format = (byte)lbReader.GetByte(lbReader.GetOrdinal("ti_format"));
                    string name = lbReader.GetString(lbReader.GetOrdinal("vc_name"));
                    string rating = lbReader.GetString(lbReader.GetOrdinal("vc_rating"));

                    if (response == null)
                    {
                        response = new PlatformLeaderboardResponse();
                        response.titleid = titleId;
                    }

                    response.AddLeaderboard(lbid, ratingAttrId, name, rating, flags, type, format);

                } // while rows
            } // using

            return response;
        }

        /// <summary>
        /// GetPlatformVisibleLeaderboardsForLocale
        /// </summary>
        /// <param name="uiTitleId">uiTitleId</param>
        /// <param name="locale">locale</param>
        /// <param name="response">response</param>
        /// <remarks>
        /// Given a uiTitleId and a locale string, return a PlatformLeaderboardResponse object consisting of 
        /// PlatformVisibleLeaderboardMetadata that titleID and locale within the platform visible leaderboard 
        /// map, if any.  If the provided locale has no matches, return all en-US PlatformVisibleLeaderboardMetadata 
        /// for that titleID instead, if any.  The _platformVisibleLeaderboards map acts as a buffer against 
        /// needlessly hitting NPDB for data.  If the titleid/locale key is not found in the 
        /// _platformVisibleLeaderboards map, then the data is *not* in NPDB, so no lookup is necessary.
        /// </remarks>
        public PlatformLeaderboardResponse GetPlatformVisibleLeaderboardsForLocale(UInt32 uiTitleId, string locale)
        {
            PlatformLeaderboardResponse response = null;

            if (_platformVisibleLeaderboards.ContainsKey(new PlatformVisibleTitleLocKey(uiTitleId, locale)))
            {
                response = GetPlatformLeaderboardMetadataFromNDPB(uiTitleId, locale);
            }
            else if (_platformVisibleLeaderboards.ContainsKey(new PlatformVisibleTitleLocKey(uiTitleId, DefaultLocale)))
            {
                response = GetPlatformLeaderboardMetadataFromNDPB(uiTitleId, DefaultLocale);                
            }

            return response;
        }

        /// <summary>
        /// BuildPlatformVisibleLeaderboardMap
        /// </summary>
        /// <remarks>
        /// Connect to NPDB and extract all platform visible leaderboard information therein.  Put all platform visible 
        /// leaderboard meata data into a local cache that calls to the StatDb.EnumPlatformVisibleLeaderboardsForTitleIdAndLocale 
        /// method can use to find platform leaderboard data without having to hit NPDB again.  This method should only be called
        /// on service startup, or by the "reloadplatformvisibleleaderboards" xmgmnt command which is typically called by
        /// mixstats during title ingestion.
        /// </remarks>
        protected void BuildPlatformVisibleLeaderboardMap()
        {
            SqlConnection sql = null;
            SqlDataReader reader = null;

            try
            {
                // Open connection to config db
                sql = new SqlConnection(Config.NpdbConnectionString);
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_stats_platform_visible_leaderboards_get_all", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    try
                    {
                        UInt32 uiTitleId = (UInt32)(Int32)reader.GetValue(0);
                        UInt32 uiLbId = (UInt32)(Int32)reader.GetValue(1);
                        string locale = (string)reader.GetValue(2);
                        
                        PlatformVisibleTitleLocKey key = new PlatformVisibleTitleLocKey(uiTitleId, locale);
                        
                        try
                        {
                            if (!_platformVisibleLeaderboards.ContainsKey(key))
                            {
                                _platformVisibleLeaderboards[key] = new List<UInt32>();                                
                            }

                            _platformVisibleLeaderboards[key].Add(uiLbId);
                        }
                        catch (Exception e)
                        {
                            Xom.NtEvent(XEvent.Id.STATS_PLATFORM_VISIBLE_LEADERBOARDS_ADD_TO_MAP_FAILURE, e,
                                           "BuildPlatformVisibleLeaderboardMap  - p_stats_platform_visible_leaderboards_get_all");
                        }
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_PLATFORM_VISIBLE_LEADERBOARDS_GET_ALL_FAILURE, e,
                                           "BuildPlatformVisibleLeaderboardMap  - p_stats_platform_visible_leaderboards_get_all");
                    }
                }
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.STATS_PLATFORM_VISIBLE_LEADERBOARDS_LOAD_FAILURE, e,     
                                           "The platform visible leaderboard map failed to load");                
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }

                if (sql != null)
                {
                    sql.Close();
                    sql = null;
                }
            }
        }

    }

    // StatsDbMap
    public class StatsDbMap
    {
        public StatsDbMap()
        {
            Initialize();
        }

        public TitleLbKey[] GetLbListForTitleId(
            uint uiTitleId
        )
        {
            ArrayList lbList = new ArrayList(_playerLbs.Count);

            foreach(TitleLbKey key in _playerLbs.Keys)
            {
                if(key._uiTitleId == uiTitleId)
                    lbList.Add(key);
            }

            return (TitleLbKey[]) lbList.ToArray(typeof(TitleLbKey));
        }

        // Returns the LbsvrInfo object that a leaderboards maps to.
        public ServerInfo GetServerInfo(uint uiTitleId, uint uiLbId)
        {
            LeaderboardInfo lbInfo;

            if(!StatLbIdParser.IsCompetition(uiLbId))
            {
                lbInfo = (LeaderboardInfo) _playerLbs[new TitleLbKey(uiTitleId, uiLbId)];

                if(lbInfo == null)
                    throw new InvalidTitleOrLeaderboardStatsException(uiTitleId, uiLbId);

                return lbInfo.ServerInfo;
            }
            else
            {
                // uiLbId is a competition leaderboard. Since they can be dynamically created we don't keep information
                // about each one of them in memory. But encoded in the id itself there should be a partition id which
                // we can actually map to a specific sql server.

                CompetitionPartition part = (CompetitionPartition) _partitions[
                    new TitleIdPartitionKey(uiTitleId, StatLbIdParser.GetPartition(uiLbId))];

                if(part == null)
                    throw new InvalidCompetitionPartitionStatsException(uiTitleId, uiLbId);

                return part._server;
            }
        }


        // Returns the LbsvrInfo object for all leaderboards servers.
        public ServerInfo[] GetAllServerInfo()
        {
                return _servers;

        }



        // Get a ServerInfo object for a competition partition for a given title. If the title has more
        public ServerInfo GetServerInfoForRandomPartition(uint uiTitleId)
        {
            byte bPartition = (byte) ((new Random()).Next() % StatLbIdParser.MaxCompetitionPartitions);

            for(int iTry=0; iTry < StatLbIdParser.MaxCompetitionPartitions; iTry++)
            {
                CompetitionPartition part = (CompetitionPartition) _partitions[
                    new TitleIdPartitionKey(uiTitleId, bPartition)];

                if(part != null)
                {
                    // Partition exists. Return it
                    return part._server;
                }
                else
                {
                    // Doesn't exist. Try again.
                    bPartition = (byte)((bPartition + 1) % StatLbIdParser.MaxCompetitionPartitions);

                    // BUGBUG: obviously we support games with less than the maximum number of partitions configured. In
                    // such cases we will be doing extra hashtable lookups in average because currently there is no easy
                    // way to figure out which partitions are available. That should be fixed.
                }
            }

            throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD,
                XEvent.Id.STATS_CONFIG_17,
                "Title id 0x"+uiTitleId.ToString("x")+" either does not exist or doesn't have any partitions "+
                "configured. If the partition has been created recently, it was probably not updated in the "+
                "front-door's dbmap. Use 'e :xstatsfd reloaddbmap' on xmgmtc to reload the dbmap.");
        }

        // Creates connection to the Lbsvr that a leaderboard maps to.
        public LbsvrClientConnection GetServerConnection(uint uiTitleId, uint uiLbId)
        {
            ServerInfo serverinfo = GetServerInfo(uiTitleId, uiLbId);
            return GetServerConnection(serverinfo);
        }

        public int ServerCount
        {
            get { return _servers.Length; }
        }

        public ServerInfo GetServerInfo(int iIndex)
        {
            return _servers[iIndex];
        }

        public ServerInfo GetServerInfoForName(string server)
        {
            server = server.ToLower();
            for(int i=0; i < _servers.Length; i++)
            {
                if(server == _servers[i].ServerName)
                    return _servers[i];
            }

            throw new XRLException(HResult.XONLINE_E_STAT_SERVER_NOT_FOUND, XEvent.Id.STATS_CONFIG_18,
                "Server " + server + " not found.");
        }

        public LbsvrClientConnection GetServerConnection(ServerInfo serverInfo)
        {
            try
            {
                // Fix for bug# 19066
                StatisticsCounters.Counters[serverInfo.Interface.ServerName].FD2LBSConnectPerSecond.Increment();
                StatisticsCounters.Counters[serverInfo.Interface.ServerName].FD2LBSConnectFailPercentagePerSecondBase.Increment();

                LbsvrClientConnection client = LbsvrClientConnection.OpenConnection(
                    new IPEndPoint(serverInfo.Interface.IPAddress, serverInfo.Interface.Port));
                return client;
            }
            catch (Exception e)
            {
                // Fix for bug# 19066
                // Ideally this would be a SocketException for transport failures but we don't
                // get that at this level. We do get the below exception even if there is a
                // Handshake error but that corresponds to a transport level failure for us.
                // Note that the perf counter will NOT catch all errors, for instance
                // memory pressure that may cause Queue objects to fail. So there could be cases where
                // we get XSTATSFD_SQL_CONNECT_FAILED but not LbsvrClientNetworkException, but in those
                // cases we're hosed anyway.
                LbsvrClientNetworkException lce = e as LbsvrClientNetworkException;
                if (lce != null)
                {
                    StatisticsCounters.Counters[serverInfo.Interface.ServerName].FD2LBSConnectFailPerSecond.Increment();
                    StatisticsCounters.Counters[serverInfo.Interface.ServerName].FD2LBSConnectFailPercentagePerSecond.Increment();
                }
                //Don't worry, we can continue through and use EventFiltering to filter out XSTATSFD_SQL_CONNECT_FAILED.

                XRLException se = e as XRLException;
                if (se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.XSTATSFD_SQL_CONNECT_FAILED,
                        "Failed to connect to Lbsvr. Message: " + e.Message, e);

                try { se.AppendInfo(serverInfo.ToString()); }
                catch (Exception) { }
                if (se != e) throw se; else throw;
            }
        }

        public ILeaderboardInfo GetLeaderboardInfo(uint uiTitleId, uint uiLbId)
        {
            if(!StatLbIdParser.IsCompetition(uiLbId))
            {
                LeaderboardInfo lbInfo = (LeaderboardInfo) _playerLbs[new TitleLbKey(uiTitleId, uiLbId)];

                if(lbInfo == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD,
                        XEvent.Id.STATS_CONFIG_19,
                        "Can't find mapping for title 0x"+uiTitleId.ToString("x")+" leaderboard "+uiLbId+
                        ". If the leaderboard exists in the server, try reloading the stat db map. ");
                        // BUGBUG: maybe include instructions on how to reload db map

                return (ILeaderboardInfo) lbInfo;
            }
            else
            {
                // We don't store leaderboard information for competition leaderboards because they can be dynamically
                // created. We do store information about the competition templates. The template used to create a
                // competition leaderboard can be extracted from the leaderboard id.

                LeaderboardInfo lbInfo = (LeaderboardInfo) _templates[
                    new TitleLbKey(uiTitleId, StatLbIdParser.GetTemplateId(uiLbId))];

                if(lbInfo == null)
                    throw new XRLException(HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD,
                        XEvent.Id.STATS_CONFIG_20,
                        "Can't find mapping for title 0x"+uiTitleId.ToString("x")+" leaderboard "+uiLbId+
                        ". The template for this leaderboard was not found. Verify that the template " +
                        StatLbIdParser.GetTemplateId(uiLbId) + " exists in the sql server and force the front-doors to " +
                        "reload using the xmgmtc command: 'e :xstatsfd reloaddbmap'" );

                return (ILeaderboardInfo) lbInfo;
            }
        }

        public StatsTitleConfig GetStatsTitleConfig(uint uiTitleId)
        {
            return (StatsTitleConfig) _StatsTitleConfig[uiTitleId];
        }

        protected void Initialize()
        {
            string[] serverNames = Config.GetServerListByInterface(Interface.lbsvr);
            ArrayList servers = new ArrayList(serverNames.Length);

            for(int i=0; i < serverNames.Length; i++)
            {
                IInterfaceInfo face = Config.GetInterface(serverNames[i], Interface.lbsvr);
                ServerInfo serverInfo = new ServerInfo(serverNames[i], face);
                servers.Add(serverInfo);
            }

            _servers = (ServerInfo[]) servers.ToArray(typeof(ServerInfo));

            BuildLeaderboardMap();
        }

        protected void BuildLeaderboardMap()
        {
            SqlConnection sql = null;
            SqlDataReader reader = null;

            try
            {
                // Open connection to config db
                sql = new SqlConnection(Config.NpdbConnectionString);
                sql.Open();

                SqlCommand cmd = new SqlCommand("p_stats_lb_get_all", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = "ALL";
                reader = cmd.ExecuteReader();

                while(reader.Read())
                {
                    try
                    {
                        string server          = (string)       reader.GetValue(0);
                        UInt32 uiTitleId       = (UInt32)(Int32)reader.GetValue(1);
                        UInt32 uiLbId          = (UInt32)(Int32)reader.GetValue(2);
                        UInt32 uiResetType     = (UInt32)(Int32)reader.GetValue(3);
                        UInt32 uiTop100        = (UInt32)(Int32)reader.GetValue(4);
                        UInt32 uiIsTeamLb      = (UInt32)(Int32)reader.GetValue(5);
                        UInt32 uiReqArb        = (UInt32)(Int32)reader.GetValue(6);
                        UInt32 uiDecayDays     = (UInt32)(Int32)reader.GetValue(7);
                        string eloE            = (string)       reader.GetValue(8);
                        Int32  iEloK           = (Int32)        reader.GetValue(9);
                        Int32  iEloNew         = (Int32)        reader.GetValue(10);
                        string eloCtable       = (string)       reader.GetValue(11);
                        UInt32 uiAttachCount   = (UInt32)(Int32)reader.GetValue(12);
                        UInt32 uiMaxAttachSize = (UInt32)(Int32)reader.GetValue(13);

                        if(StatLbIdParser.IsCompetition(uiLbId))
                        {
                            // Skip competition leaderboards. They can be created dinamically so
                            // we're not bothering storing them in the lb-to-server map. It would
                            // be hard to keep it in sync. Instead, we know about in which partition
                            // that leaderboard was create by parsing the competition leaderboard id.

                            continue;
                        }

                        LeaderboardInfo lbInfo = new LeaderboardInfo(
                            GetServerInfoForName(server),
                            uiTitleId,
                            uiLbId,
                            false,
                            uiIsTeamLb != 0,
                            uiReqArb != 0,
                            (eloE.ToLower().Trim() == "e") ? ((float) Math.E) : ((float) 10.0),
                            (float) iEloK,
                            iEloNew,
                            eloCtable,
                            uiAttachCount,
                            uiMaxAttachSize);

                        _playerLbs.Add(new TitleLbKey(uiTitleId, uiLbId), lbInfo);
                    }
                    catch (Exception e)
                    {
                         Xom.NtEvent(XEvent.Id.STATS_CODE_16, e,
                                            "BuildLeaderboardMap  - p_stats_lb_get_all");
                    }
                }

                reader.Close();
                reader = null;

                cmd = new SqlCommand("dbo.p_stats_title_get_limits", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                reader = cmd.ExecuteReader();

                // Title config
                while(reader.Read())
                {
                    try
                    {
                        uint    uiTitleId       = (uint) reader.GetInt32(0);
                        uint    uiMaxWrites     = (uint) reader.GetInt32(1);
                        uint    uiMaxReads      = (uint) reader.GetInt32(2);

                        _StatsTitleConfig[uiTitleId] = new StatsTitleConfig(uiTitleId, uiMaxWrites, uiMaxReads);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CODE_17, e, "BuildLeaderboardMap - p_stats_title_get_limits"); 
                    }
                }

                reader.Close();
                reader = null;

                // Competition partitions
                cmd = new SqlCommand("dbo.p_stats_competition_template_get_all", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                reader = cmd.ExecuteReader();

                while(reader.Read())
                {
                    try
                    {
                        UInt32 uiTitleId       = (UInt32)(Int32)reader.GetValue(0);
                        UInt32 uiLbId          = (UInt32)(Int32)reader.GetValue(1);
                        UInt32 uiResetType     = (UInt32)(Int32)reader.GetValue(2);
                        UInt32 uiTop100        = (UInt32)(Int32)reader.GetValue(3);
                        UInt32 uiIsTeamLb      = (UInt32)(Int32)reader.GetValue(4);
                        UInt32 uiReqArb        = (UInt32)(Int32)reader.GetValue(5);
                        UInt32 uiDecayDays     = (UInt32)(Int32)reader.GetValue(6);
                        string eloE            = (string)       reader.GetValue(7);
                        Int32  iEloK           = (Int32)        reader.GetValue(8);
                        Int32  iEloNew         = (Int32)        reader.GetValue(9);
                        string eloCtable       = (string)       reader.GetValue(10);
                        UInt32 uiAttachCount   = (UInt32)(Int32)reader.GetValue(11);
                        UInt32 uiMaxAttachSize = (UInt32)(Int32)reader.GetValue(12);

                        LeaderboardInfo lbInfo = new LeaderboardInfo(
                            null,
                            uiTitleId,
                            uiLbId,
                            false,
                            uiIsTeamLb != 0,
                            uiReqArb != 0,
                            (eloE.ToLower().Trim() == "e") ? ((float) Math.E) : ((float) 10.0),
                            (float) iEloK,
                            iEloNew,
                            eloCtable,
                            uiAttachCount,
                            uiMaxAttachSize);

                        _templates[new TitleLbKey(uiTitleId, uiLbId)] = lbInfo;
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CODE_18, e,
                                            "BuildLeaderboardMap - p_stats_competition_template_get_all");
                    }
                }

                reader.Close();
                reader = null;

                cmd = new SqlCommand("dbo.p_stats_competition_partition_get_all", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                reader = cmd.ExecuteReader();

                while(reader.Read())
                {
                    try
                    {
                        string server      = (string)       reader.GetValue(0);
                        uint   uiTitleId   = (UInt32)(Int32)reader.GetValue(1);
                        uint   uiPartition = (UInt32)(Int32)reader.GetValue(2);

                        // The partition id returned from the database is already shifted to
                        // avoid collisions with regular leaderboard ids. But here we need to
                        // store it unshifted, as a value between 0 - 3.

                        uiPartition >>= StatLbIdParser.PartitionShift;

                        _partitions.Add(new TitleIdPartitionKey(uiTitleId, (byte)uiPartition),
                            new CompetitionPartition(uiTitleId, (byte)uiPartition, GetServerInfoForName(server)));
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.STATS_CODE_19, e,
                                            "BuildLeaderboardMap - p_stats_competition_partition_get_all");
                    }
                }
            }
            finally
            {
                if(reader != null)
                    reader.Close();

                if(sql != null)
                {
                    sql.Close();
                    sql = null;
                }
            }
        }

        protected ServerInfo[]   _servers = null;
        protected Hashtable      _playerLbs   = new Hashtable();
        protected Hashtable      _partitions  = new Hashtable();
        protected Hashtable      _templates   = new Hashtable();
        protected Hashtable      _StatsTitleConfig = new Hashtable();

        protected struct TitleIdPartitionKey
        {
            public TitleIdPartitionKey(uint uiTitleId, byte bPartition)
            {
                _uiTitleId  = uiTitleId;
                _bPartition = bPartition;
            }

            public override int GetHashCode()
            {
                return (int)(_uiTitleId + _bPartition);
            }

            public override bool Equals(object obj)
            {
                TitleIdPartitionKey otherObj = (TitleIdPartitionKey) obj;

                return (
                    otherObj._uiTitleId == _uiTitleId
                    && otherObj._bPartition == _bPartition );
            }

            public uint             _uiTitleId;
            public byte             _bPartition;
        }

        protected class CompetitionPartition
        {
            public CompetitionPartition(uint uiTitleId, byte bPartition, ServerInfo server)
            {
                _uiTitleId  = uiTitleId;
                _bPartition = bPartition;
                _server     = server;
            }

            public uint             _uiTitleId;
            public byte             _bPartition;
            public ServerInfo    _server;
        }

        protected class LeaderboardInfo : ILeaderboardInfo
        {
            public LeaderboardInfo(
                ServerInfo   server,
                uint            uiTitleId,
                uint            uiLbId,
                bool            fIsUnitLb,
                bool            fIsTeam,
                bool            fReqArbitration,
                float           eloE,
                float           eloK,
                int             eloNew,
                string          eloC,
                uint            uiAttachCount,
                uint            uiMaxAttachSize )
            {
                _server     = server;
                _uiTitleId  = uiTitleId;
                _uiLbId     = uiLbId;
                _fIsUnitLb  = fIsUnitLb;
                _fIsTeam    = fIsTeam;
                _fReqArbitration = fReqArbitration;
                _fEloE      = eloE;
                _fEloK      = eloK;
                _iEloNew    = eloNew;
                ParseEloC(eloC);
                _uiAttachCount = uiAttachCount;
                _uiMaxAttachSize = uiMaxAttachSize;
            }

            public uint             TitleId         { get { return _uiTitleId; } }
            public uint             LbId            { get { return _uiLbId; } }
            public bool             IsUnitLb        { get { return _fIsUnitLb; } }
            public bool             IsTeam          { get { return _fIsTeam; }  }
            public bool             ReqArbitration  { get { return _fReqArbitration; } }
            public bool             IsEloEnabled    { get { return true; } }
            public float            Elo_E           { get { return _fEloE; } }
            public float            Elo_K           { get { return _fEloK; } }
            public int              Elo_New         { get { return _iEloNew; } }
            public uint             AttachCount     { get { return _uiAttachCount; } }
            public uint             MaxAttachSize   { get { return _uiMaxAttachSize; } }

            public long GetElo_C(long lRating, out int iBucket)
            {
                // Find the right C for this lRating
                int i;
                for(i=1; i < _eloC.Length; i++)
                {
                    if(_eloC[i]._lStartRating > lRating)
                        break;
                }

                iBucket = Math.Max(i-1, 0);

                return _eloC[i-1]._iC;
            }

            public ServerInfo    ServerInfo      { get { return _server; } }

            protected void ParseEloC(string eloCvalue)
            {
                // The ELO_C parameter contains an array that maps rating ranges to C constants.
                // Ex: ELO_C=0:40,1000:20,1500:10
                // The example above means that from 0 to 999 C = 40, 1000 to 1499 C = 20 and 1500 ahead C = 10

                if(eloCvalue != String.Empty)
                {
                    string[] elocpairs = eloCvalue.Split(new char[]{','});
                    _eloC = new ELO_C[elocpairs.Length];

                    for(int iElocNdx=0; iElocNdx < _eloC.Length; iElocNdx++)
                    {
                        string[] ratingAndC = elocpairs[iElocNdx].Split(new char[]{':'});
                        _eloC[iElocNdx]._lStartRating = Convert.ToInt64(ratingAndC[0]);
                        _eloC[iElocNdx]._iC = Convert.ToInt32(ratingAndC[1]);
                    }
                }
                else
                {
                    _eloC = new ELO_C[1];
                    _eloC[0]._lStartRating = 0;
                    _eloC[0]._iC = 0;
                }


                Array.Sort(_eloC);
            }

            protected struct ELO_C : IComparable
            {
                public ELO_C(long lStartRating, int iC)
                {
                    _lStartRating = lStartRating;
                    _iC = iC;
                }

                public long     _lStartRating;
                public int      _iC;

                // IComparable.CompareTo
                public int CompareTo(object obj)
                {
                    return _lStartRating.CompareTo(((ELO_C)obj)._lStartRating);
                }
            }

            protected   uint            _uiTitleId;
            protected   uint            _uiLbId;
            protected   bool            _fIsUnitLb;
            protected   bool            _fIsTeam;
            protected   bool            _fReqArbitration;
            protected   ServerInfo   _server;
            protected   float           _fEloE      = 10.0F;
            protected   float           _fEloK      = 120.0F;
            protected   int             _iEloNew    = 500;
            protected   ELO_C[]         _eloC       = new ELO_C[] { new ELO_C(0, 40) };
            protected   uint            _uiAttachCount;
            protected   uint            _uiMaxAttachSize;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlCommitAtt.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlCommitAtt.cs
 * 
 * Implementation of CommitAtt request
 * 
 * */

using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.stats.fd 
{
    // XRLCommitAtt
    // HTTP handler for Commit Attachment request
    public class XRLCommitAtt : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            uint            hr = HResult.S_OK;
            StatDb          db = new StatDb();
            uint            uiTitleId = 0;

            BinaryReader               reader  = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper        writer  = new BinaryWriterWrapper(ctx.Response.OutputStream);
            MsgCommitAttachment        req     = new MsgCommitAttachment();;

            // Read request
            try
            {
                req.ReadFrom(reader);
            }
            catch(Exception e)
            {
                hr = HResult.XONLINE_E_INVALID_REQUEST;

                Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_REQUEST_71, e,
                    "Invalid Commit Attachment request. "
                );

                goto lDone;
            }
                
            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "XRLCommitAtt:"+req);
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_LOW, SGInfo.ToStr());
                
            uiTitleId = req._uiTitleId;

            // Commit attachment
            foreach(MsgCommitAttachmentReference reference in req._refs)
            {
                try
                {
                    db.CommitAttachment(req._uiTitleId, reference._uiLb, reference._ulUser, req._pathName, 
                        req._uiAttSize);
                }
                catch(Exception e)
                {
                    if(e is XRLException)
                        hr = ((XRLException) e).HResult;
                    else
                        hr = HResult.XONLINE_E_STAT_ERROR;
                    
                    if(hr == HResult.XONLINE_E_STAT_INVALID_ATTACHMENT)
                    {
                        Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_ATTACHMENT, e, "Invalid attachment. MsgCommitAttachment: " + req.ToString());
                    }
                    else
                    {
                        Xom.NtEvent(XEvent.Id.XSTATSFD_DATABASE_ERROR_1, e, "CommitAttachment failed. MsgCommitAttachment: "+req.ToString());
                    }
                    goto lDone;
                }
            }

            // Log
            string logentry = 
                "COMMITATT"+
                "|"+req._uiTitleId.ToString("x")+
                "|"+req._pathName+
                "|"+req._uiAttSize.ToString("x");
                
            Xom.Log(XomAreaName.statslog, logentry);

        lDone:
            
            // Update performance counters
            StatisticsCounters.Counters.CommitAttPerSecond.Increment();
            StatisticsCounters.Counters.CommitAttTotal.Increment();
            if(uiTitleId != 0)
            {
                StatisticsCounters.Counters[uiTitleId.ToString("x")].CommitAttPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")].CommitAttTotal.Increment();
            }
            
            if(HResult.Failed(hr))
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req._uiTitleId, hr);

                // Counters
                StatisticsCounters.Counters.CommitAttFailedPerSecond.Increment();
                StatisticsCounters.Counters.CommitAttFailedTotal.Increment();
                if(uiTitleId != 0)
                {
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].CommitAttFailedPerSecond.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].CommitAttFailedTotal.Increment();
                }
            }

            // Set response and exit
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req._uiTitleId, hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlAchievementClear.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAchievementClear.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class XRLAchievementClear : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>True/False</retruns>
        /// <remarks>
        /// Returns if this object can be reused. Since the object doesn't hold
        /// any state, this method always returns true.
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP input context</param>
        /// <remarks>
        /// Process incoming Achievements write request.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.E_FAIL;

            AchievementClearRequest  req  = new AchievementClearRequest();
            AchievementClearResponse resp = new AchievementClearResponse();

            WSClient ws;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                // SGInfo.VerifyTitleId is intentionally omitted so any system app
                // can clear any title.

                SGInfo.VerifyUserId(req.Puid);

                using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();

                    ws.StoredProc = "p_achievement_clear";
                    ws.Partition = ws.CalcPartition(req.Puid);

                    ws.AddParameter("@bi_puid", (long) req.Puid);
                    ws.AddParameter("@i_title_id", (int) req.TitleId);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                resp.TitleId = req.TitleId;
                resp.Puid    = req.Puid;

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"CLA|{0:x}|{1:x}|{2:x}",
                    hr,
                    req.TitleId,
                    req.Puid);

                Xom.Log(XomAreaName.statslog, sb.ToString());

            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlEstimateRankForRatings.cs ===
/*
 * Copyright (c) 2006 Microsoft Corporation
 * 
 * Stats Front-Door (xstatsfd)
 * 
 * XRLEstimateRankForRatings.cs
 * 
 * Implementation of XRLEstimateRankForRatings request
 * 
 * */

using System;
using System.IO;
using System.Web;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using System.Collections;
using System.Text;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    public class XRLEstimateRankForRatings : IHttpHandler
    {
        public const uint DEFAULT_RANK = 0; //rank 0 should indicate an error
        public bool IsReusable
        {
            get { return true; }
        }

        public void ProcessRequest(HttpContext ctx)
        {
            StringBuilder logentry = new StringBuilder("XRLEstimateRankForRatings");

            uint                       hr      = HResult.S_OK;
            BinaryReader               reader  = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper        writer  = new BinaryWriterWrapper(ctx.Response.OutputStream);
            
            StatsEstimateRankForRatingsRequest  req = new StatsEstimateRankForRatingsRequest();
            StatsEstimateRankForRatingsResponse rep = new StatsEstimateRankForRatingsResponse();

            Hashtable htLb = null; 
            
            try
            { 
                req.ReadStream(reader);

                logentry.Append(                
                    "|"+req.m_nTitleId.ToString("x")+
                    "|"+req.m_uRatingRequestCount.ToString()
                );

                for (int i=0;i<req.m_arrRatingStruct.Length;i++)
                {
                    StatsEstimateRankRequestStruct ratingStruct = req.m_arrRatingStruct[i];
                    logentry.Append("|" + ratingStruct.m_nLbId +
                                    "|" + ratingStruct.m_ulRating);
                }
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_INVALID_REQUEST;
                Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_REQUEST_77, e, "Cannot Deserialize StatsEstimateRankForRatingsRequest");
                goto lDone;
            }

            //if the title contains no leaderboards, we abort round trips to the LBSVR and consistently return XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD
            if (!TitleContainsLb(req.m_nTitleId))
            {
                hr = HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD;
                Xom.NtEvent(XEvent.Id.XSTATSFD_ESTIMATE_RANK_ERROR_2, "Invalid Title for XRLEstimateRankForRatings.");
                goto lDone;
            }

            //pre processing
            htLb = AggregateRequestByLeaderboards(req);

            //calling the leaderboard server
            GetEstimatedRankFromDb(req.m_nTitleId , htLb);

            //building response - order of return should be same as request
            rep.m_arruiRankForRating       = new uint[req.m_arrRatingStruct.Length];
            rep.m_uRankForRatingReplyCount = (uint)rep.m_arruiRankForRating.Length;
            
            for (int i=0;i<req.m_arrRatingStruct.Length;i++)
            {
                StatsEstimateRankRequestStruct ratingStruct = req.m_arrRatingStruct[i];
                Hashtable htRatingsPerLb    = (Hashtable)htLb[ratingStruct.m_nLbId];
                rep.m_arruiRankForRating[i] = (uint)htRatingsPerLb[ratingStruct.m_ulRating];  

                logentry.Append("|" + rep.m_arruiRankForRating[i]);
            }
                
        lDone:

            Xom.Log(XomAreaName.statslog, logentry.ToString());
            
            // Set response and exit
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, (uint)req.m_nTitleId, hr);
            if (HResult.S_OK == hr)
            {
                rep.WriteStream(writer);
            }
        }


        //organize the request by leaderboards
        protected Hashtable AggregateRequestByLeaderboards(StatsEstimateRankForRatingsRequest req)
        {
            Hashtable ht = new Hashtable();
            
            foreach (StatsEstimateRankRequestStruct ratingStruct in req.m_arrRatingStruct)
            {
                Hashtable subht = (Hashtable)ht[ratingStruct.m_nLbId];
                if (null == subht)    
                {
                    subht = new Hashtable();
                    ht.Add(ratingStruct.m_nLbId, subht);
                }

                if (null == subht[ratingStruct.m_ulRating])
                {
                    subht.Add(ratingStruct.m_ulRating, DEFAULT_RANK); //store a dummy result first
                }
            }

            return ht;
        }   

        protected bool TitleContainsLb(int nTitleId)
        {
            StatDb  db = new StatDb();           

            TitleLbKey[] arrLbKey = db.GetLbListForTitleId((uint) nTitleId);
            
            return !((arrLbKey  == null) || (arrLbKey.Length == 0));
        }


        //Call the LBSVR
        protected void GetEstimatedRankFromDb(int nTitleId, Hashtable htOrganizedByLbId)
        {
            StatDb  db = new StatDb();
            foreach (int nLbId in htOrganizedByLbId.Keys)
            {
                try
                {
                    Hashtable htRatings = (Hashtable)htOrganizedByLbId[nLbId];
                    UInt64 [] arrulRatings = new UInt64[htRatings.Values.Count];
                    
                    htRatings.Keys.CopyTo(arrulRatings, 0);
                     
                    int [] arrnRanks     = db.EstimateRanksForRatings(nTitleId, nLbId, arrulRatings);

                    if (arrnRanks == null || arrulRatings.Length != arrnRanks.Length)
                    {
                        throw new Exception("UnExpected Result From db.EstimateRanksForRatings");   
                    }

                    for (int i=0;i<arrulRatings.Length;i++)
                    {
                        htRatings[arrulRatings[i]] = (uint)arrnRanks[i]; //remember the result
                    }
                }
                catch (Exception e)
                {
                    //log the event but continue processing other leaderboards
                    Xom.NtEvent(XEvent.Id.XSTATSFD_ESTIMATE_RANK_ERROR_1, e, "Title ID {0} Lb ID {1}", (TitleId) (uint) nTitleId , nLbId);
                }
            }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlContextEnum.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlContextEnum.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class XRLContextEnum : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.XONLINE_E_STAT_ERROR;

            ContextEnumCounters counters = new ContextEnumCounters();
            ContextEnumRequest req = new ContextEnumRequest();
            ContextEnumResponse resp = new ContextEnumResponse();
            string[] locales = new string[0];

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                if (req.LocaleId == 0)
                {
                    // use the locale of the 1st logged in user
                    ulong userId = 0;

                    for (int i = 0; i < 4; i++)
                    {
                        if (SGInfo.Current.LogonUsers[i].qwUserID != 0)
                        {
                            userId = SGInfo.Current.LogonUsers[i].qwUserID;
                            break;
                        }
                    }

                    if (userId != 0)
                        locales = SGInfo.GetUserLocaleList(userId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                TitleConfig tcfg = TitleConfig.GetTitle(req.TitleId, false /* throwOnNotFound */);

                if (null == tcfg)
                {
                    resp.TotalContexts = 0;
                    resp.Contexts = null;
                }
                else
                {
                    TitleContext context = (TitleContext)tcfg.Contexts[req.ContextId];
                    XRLUtil.VerifyParam(context != null, "Unknonwn context id requested: 0x" + req.ContextId.ToString("x") );

                    resp.TotalContexts = (uint)context.Values.Count;

                    if (req.StartingIndex >= resp.TotalContexts)
                    {
                        resp.Contexts = new ContextString[0];
                    }
                    else
                    {
                        resp.Contexts = new ContextString[Math.Min(req.MaxContexts, resp.TotalContexts - req.StartingIndex)];
                    }

                    for (int i = 0; i < resp.Contexts.Length; i++)
                    {
                        resp.Contexts[i] = new ContextString();
                        resp.Contexts[i].ContextId = ((TitleContextValue)context.Values[(uint)(req.StartingIndex + i)]).Id;
                        resp.Contexts[i].Name = ((TitleContextValue)context.Values[(uint)(req.StartingIndex + i)]).Name[locales];
                    }
                }

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat("CXE|{0:x}|{1:x}|{2:x}|{3:x}|{4:x}|{5:x}",
                    hr,
                    req.TitleId,
                    req.ContextId,
                    req.StartingIndex,
                    req.MaxContexts,
                    (resp.Contexts == null ? 0 : resp.Contexts.Length));

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }

        public bool IsReusable
        {
            get { return true; }
        }
    }


    public class ContextEnumCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            ContextEnumCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            ContextEnumCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         ContextEnumCountersCategory.Current(titleId).FailuresPerSecond,
                                         ContextEnumCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            ContextEnumCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ContextEnumCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                ContextEnumCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                ContextEnumCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: ContentEnum", "Stats FD: ContentEnum" )]
    public class ContextEnumCountersCategory : XomPerformanceCounterCategory
    {

        static public ContextEnumCountersCategory _instance = new ContextEnumCountersCategory();
        static public ContextEnumCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(ContextEnumCountersCategory)_instance.GetInstance(titleId);
        }


        // ContentEnum request counters

        [XomPerformanceCounterAttr(
                                 "ContentEnum requests/sec",
                                 "ContentEnum requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "ContentEnum total",
                                 "Total ContentEnum requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "ContentEnum failures/sec",
                                 "Number of unsuccessful results returned by ContentEnum per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "ContentEnum total failures",
                                 "Total number unsuccessful results returned by ContentEnum in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "ContentEnum avg. execution time",
                                 "ContentEnum Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlReadSettings.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlReadSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Web;

using Microsoft.Webstore.WstClient;
using Microsoft.Xbox.Privacy.Client;
using Microsoft.Xbox.Privacy.Interfaces;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.server.stats.common;
using System.Net;

namespace xonline.server.stats.fd
{
    public class XRLReadSettings : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        internal class ProfileLookupItem
        {
            public uint _settingId;
            public uint _titleId;
            public ulong _userId;
            public uint _index;
            public byte[] _value;

            public ProfileLookupItem(uint settingId, uint titleId, ulong userId, uint index)
            {
                _settingId = settingId;
                _titleId = titleId;
                _userId = userId;
                _index = index;
            }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            ReadSettingsCounters counters = new ReadSettingsCounters();
            ReadSettingsRequest req = new ReadSettingsRequest();
            ReadSettingsResponse resp = new ReadSettingsResponse();
            WSClient ws;
            uint hr = HResult.E_FAIL;
            Friend[] friends = null;
            WstDataReader reader;
            UserSetting[] publicPictureSettings;
            UserSetting[] personalPictureSettings;
            UserSetting[] privacySettings; 
            bool[] checkPrivs;
            User[] uacsUsers;
            int indexPictureKey = -1;
            bool personalPictureRequested = false;
            bool privacyRequested = false;
            bool fUseLocalCache = true;

            ArrayList alDatabaseLookups;
            ArrayList alCacheLookups = new ArrayList();;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyFamilyTitleId(req.TitleId);
                SGInfo.VerifyUserId(req.UserId);

                // disable local caching if LiveCache already has it covered.
                fUseLocalCache = !SGInfo.IsFromLiveCache();
                resp.Settings = new UserSetting[req.ForUserIdsLen * req.SettingIdsLen];
                publicPictureSettings = new UserSetting[req.ForUserIdsLen];
                personalPictureSettings = new UserSetting[req.ForUserIdsLen];
                privacySettings = new UserSetting[req.ForUserIds.Length];

                checkPrivs = new bool[req.ForUserIdsLen];
                uacsUsers = new User[req.ForUserIdsLen];

                // apply the parental controls for the requesting user to each of
                // the other users.
                for (uint i = 0; i < req.ForUserIds.Length; i++)
                {
                    checkPrivs[i] = false;
                    
                    // initialize the source on each of the settings
                    for (uint j = 0; j < req.SettingIds.Length; j++)
                    {
                        uint index = (i * (uint)req.SettingIds.Length) + j;
                        UserSetting setting = new UserSetting(req.ForUserIds[i], req.SettingIds[j]);
                        resp.Settings[index] = setting;
                        
                        setting.Source = XOn.XSOURCE_NO_VALUE;

                        bool isTitleWriteable = false;

                        if (!InitializeSetting(
                            setting,
                            req.UserId,
                            setting.UserId,
                            ref uacsUsers[i],
                            ref friends,
                            ref checkPrivs[i],
                            ref isTitleWriteable))
                        {
                            continue;
                        }

                        if (ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY == setting.SettingId)
                        {
                            indexPictureKey = (int)j;
                            publicPictureSettings[i] = setting;
                        }
                        else if (ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE == setting.SettingId)
                        {
                            personalPictureRequested = true;
                            personalPictureSettings[i] = setting;
                            index = i;
                        }
                        else if (XOn.XPROFILE_PERMISSIONS == setting.SettingId) // Requesting privacy permissions, set up a privacy check
                        {
                            privacyRequested = true;
                            privacySettings[i] = setting; // Track this so we can index back into it later
                        }

                        if (setting.Source != XOn.XSOURCE_PERMISSION_DENIED)
                        {
                            // add it to the list of cache lookups.
                            alCacheLookups.Add(new ProfileLookupItem(setting.SettingId, XOn.XENON_DASH_TITLE_ID, setting.UserId, index));

                            if (isTitleWriteable)
                            {
                                // check for title override.
                                alCacheLookups.Add(new ProfileLookupItem(setting.SettingId, req.TitleId, setting.UserId, index));
                            }
                        }
                    }   // for each setting id

                    if ((indexPictureKey != -1) && !personalPictureRequested)
                    {
                        personalPictureSettings[i] = new UserSetting(req.ForUserIds[i], ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE);
                        personalPictureSettings[i].Source = XOn.XSOURCE_NO_VALUE;

                        bool isTitleWriteable = false;

                        if (InitializeSetting(
                            personalPictureSettings[i],
                            req.UserId,
                            req.ForUserIds[i],
                            ref uacsUsers[i],
                            ref friends,
                            ref checkPrivs[i],
                            ref isTitleWriteable))
                        {
                            if (personalPictureSettings[i].Source != XOn.XSOURCE_PERMISSION_DENIED)
                            {
                                // add it to the list of cache lookups.
                                alCacheLookups.Add(new ProfileLookupItem(ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE, XOn.XENON_DASH_TITLE_ID, req.ForUserIds[i], i));
                            }
                        }
                    }
                }

                // If Privacy Rules have been requested, make a GetPrivacyRules request.
                if (privacyRequested)
                {
                    IVirtualInterfaceInfo vInt = Config.GetVirtualInterface("privacy_int");
                    IPEndPoint endpoint = new IPEndPoint(vInt.IPAddress, vInt.Port);

                    PrivacyClientInternal internalClient = new PrivacyClientInternal(endpoint);

                    for (int i = 0; i < req.ForUserIds.Length; i++)
                    {
                        ProfilePrivacyGetResponse response = internalClient.GetProfilePrivacy(req.ForUserIds[i]);

                        privacySettings[i].Value = BitConverter.GetBytes(response.Settings);
                    }
                }

                // make the cache query.
                alDatabaseLookups = QueryCache(alCacheLookups, resp.Settings, personalPictureSettings, fUseLocalCache);

                using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    StringBuilder xml = new StringBuilder();
                    int cParamsLeft = alDatabaseLookups.Count;

                    for (int p = 0; (p < ws.PhysicalPartitions) && (cParamsLeft > 0); p++)
                    {
                        xml.Length = 0;

                        foreach (ProfileLookupItem dbParam in alDatabaseLookups)
                        {
                            // grab the list of settings that are on this partition
                            if (!SGInfo.IsGuestXuid(dbParam._userId) &&
                                 ws.GetPhysicalPartition(ws.CalcPartition(dbParam._userId)) == p)
                            {
                                cParamsLeft--;
                                
                                // list of settings expressed as <a user="" title="" setting=""/>
                                xml.AppendFormat(@"<a user=""{0}"" title=""{1}"" setting=""{2}""/>",
                                    (long)dbParam._userId,
                                    (int)dbParam._titleId,
                                    (int)dbParam._settingId);
                            }
                        }

                        if (xml.Length == 0)
                        {
                            continue;
                        }
                        
                        //
                        // Grab the setting values for people on this partition
                        //

                        ws.ClearParameters();

                        ws.StoredProc = "dbo.p_stats_get_user_settings_2";
                        ws.PhysicalPartition = p;

                        ws.AddParameter("@xml_data", xml.ToString());

                        reader = ws.Execute();

                        while (reader.Read())
                        {
                            ulong   userId = (ulong)(long)reader["bi_user_puid"];
                            uint    settingId = (uint)(int)reader["i_setting_id"];
                            uint    titleId = (uint)(int)reader["i_title_id"];
                            byte[]  value = reader.GetSqlBinary(reader.GetOrdinal("vb_value")).Value;

                            int userIndex = Array.IndexOf(req.ForUserIds, userId);
                            Assert.IsTrue(userIndex != -1);

                            // anything we get back from sql needs to go into cache.
                            UpdateLookupData(alDatabaseLookups, userId, titleId, settingId, value);

                            // Only return the permissions if they were explicitly requested
                            if (settingId != XOn.XPROFILE_PERMISSIONS || privacyRequested)
                            {
                                // Process the personal picture info to our own array and only pass control
                                // on to the normal processing if the setting was explicitly requested.
                                if (ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE == settingId)
                                {
                                    // Find the entry in our side array of settings
                                    foreach (UserSetting personalPictureSetting in personalPictureSettings)
                                    {
                                        if (personalPictureSetting.UserId == userId &&
                                            personalPictureSetting.Source != XOn.XSOURCE_PERMISSION_DENIED)
                                        {
                                            personalPictureSetting.Source = (titleId == XOn.XENON_DASH_TITLE_ID ? XOn.XSOURCE_DEFAULT : XOn.XSOURCE_TITLE);
                                            personalPictureSetting.Value = value;
                                            personalPictureSetting.ValueLen = (ushort)value.Length;
                                        }
                                    }

                                    if (!personalPictureRequested)
                                        continue;
                                }

                                while (userIndex != -1)
                                {
                                    int settingIndex = Array.IndexOf(req.SettingIds, settingId);

                                    // Either the setting was requested by the user or we added it
                                    // in order to fixup the picture keys
                                    Assert.IsTrue(settingIndex != -1 ||
                                        (ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE == settingId && !personalPictureRequested));

                                    while (settingIndex != -1)
                                    {
                                        UserSetting setting = resp.Settings[(userIndex * req.SettingIdsLen) + settingIndex];
                                        Assert.IsTrue(setting.SettingId == settingId);

                                        uint source = (titleId == XOn.XENON_DASH_TITLE_ID ? XOn.XSOURCE_DEFAULT : XOn.XSOURCE_TITLE);

                                        // Don't overwrite information set by ApplyProfilePermissions
                                        if (setting.Source < source)
                                        {
                                            setting.Source = source;
                                            setting.Value = value;
                                            setting.ValueLen = (ushort)value.Length;
                                        }

                                        settingIndex = Array.IndexOf(req.SettingIds, settingId, settingIndex + 1);
                                    }

                                    userIndex = Array.IndexOf(req.ForUserIds, userId, userIndex + 1);
                                }
                            }
                        }

                        reader.Close();

                    }   // for users on partition
                }   // using WSClient

                PerformPrivacyChecks(req, indexPictureKey == -1 ? null : personalPictureSettings, resp.Settings);

                // update cache with everything we learned from the database
                PopulateCache(alDatabaseLookups, fUseLocalCache);

                // Fix up the picture key based on personal picture setting, friend status and UCC setting
                if (indexPictureKey != -1)
                {
                    FixupPictureKeys(indexPictureKey, req.UserId, resp.Settings, publicPictureSettings, personalPictureSettings, WireData.GetSchemaVersion(ctx.Request));
                }
                
                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"RUS|{0:x}|{1:x}|{2:x}|",
                                    hr,
                                    req.TitleId,
                                    req.UserId);

                if (req.ForUserIds != null)
                {
                    for (int i = 0; i < req.ForUserIds.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", req.ForUserIds[i]);

                        if (i != req.ForUserIds.Length-1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (req.SettingIds != null)
                {
                    for (int i = 0; i < req.SettingIds.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", req.SettingIds[i]);

                        if (i != req.SettingIds.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }

        /// <summary>
        /// Perform privacy checks on all of the settings being requested.  This checks all privacy
        /// at the cost of making many checks that are unneccessary in order to save processing
        /// time when calculating the location of the results.
        /// </summary>
        /// <param name="req">Request header containing all of the parameters</param>
        /// <param name="personalPictureSettings">Settings related to personal pictures</param>
        /// <param name="responseSettings">Repsonses being returned to the user</param>
        private void PerformPrivacyChecks(ReadSettingsRequest req, UserSetting[] personalPictureSettings, UserSetting[] responseSettings)
        {
            PrivacyDataCheckRequest[] privacyRequests = GetPrivacyChecks(req, personalPictureSettings);

            IVirtualInterfaceInfo vInt = Config.GetVirtualInterface("privacy_int");
            IPEndPoint endpoint = new IPEndPoint(vInt.IPAddress, vInt.Port);

            PrivacyClientInternal internalClient = new PrivacyClientInternal(endpoint, Component.xstatsfd);

            bool[] privacyCheckResults = internalClient.CheckPrivacy(privacyRequests);

            // The 'picMod' is the number of rows reserved for picture settings.
            // If there are no picture settings, this is 0.  Otherwise, 1.
            int picMod = personalPictureSettings != null ? 1 : 0;

            int index = 0;
            int settingIndex = 0;

            for (int i = 0; i < req.ForUserIds.Length; i++)
            {
                for (int j = 0; j < req.SettingIds.Length; j++)
                {
                    // If the privacy check failed, mark the setting as not allowed
                    if (!privacyCheckResults[index])
                    {
                        responseSettings[settingIndex].Source = XOn.XSOURCE_PERMISSION_DENIED; // Flag it for not being delivered.

                        Xom.Trace(
                            XomAreaName.ctxDebug,
                            LogLevel.L_NORMAL,
                            "Permission denied for user 0x{0:x} to read settingId 0x{2:x} of user 0x{1:x}.",
                            req.UserId,
                            req.ForUserIds[i],
                            req.SettingIds[j]);
                    }

                    index++;
                    settingIndex++;
                }

                if (picMod == 1)
                {
                    if (!privacyCheckResults[index])
                    {
                        personalPictureSettings[i].Source = XOn.XSOURCE_PERMISSION_DENIED; // Flag it for not being delivered.

                        Xom.Trace(
                            XomAreaName.ctxDebug,
                            LogLevel.L_NORMAL,
                            "Permission denied for user 0x{0:x} to read settingId 0x{2:x} of user 0x{1:x}.",
                            req.UserId,
                            req.ForUserIds[i],
                            personalPictureSettings[i].SettingId);
                    }

                    index++;
                }
            }
        }

        /// <summary>
        /// Collate all of the privacy checks into an array
        /// </summary>
        /// <param name="req"></param>
        /// <param name="picSettings"></param>
        /// <returns></returns>
        private PrivacyDataCheckRequest[] GetPrivacyChecks(ReadSettingsRequest req, UserSetting[] picSettings)
        {
            int picMod = picSettings == null ? 0 : 1; // Number of elements to add per user

            PrivacyDataCheckRequest[] checks = new PrivacyDataCheckRequest[req.ForUserIds.Length * (req.SettingIds.Length + picMod)];

            int index = 0;

            for (int i = 0; i < req.ForUserIds.Length; i++)
            {
                for (int j = 0; j < req.SettingIds.Length; j++)
                {
                    checks[index++] = new PrivacyDataCheckRequest(req.UserId, req.ForUserIds[i], (int)req.SettingIds[j]);
                }

                // If we're looking at the picture settings too, add a check at the end of the list for this user
                if (picSettings != null)
                {
                    // Add the picture setting to the privacy check as well
                    checks[index++] = new PrivacyDataCheckRequest(req.UserId, req.ForUserIds[i], (int)picSettings[i].SettingId);
                }

            }

            return checks;
        }

        private void UpdateLookupData(ArrayList alDatabaseLookups, ulong userId, uint titleId, uint settingId, byte[] value)
        {
            foreach (ProfileLookupItem pli in alDatabaseLookups)
            {
                if ((pli._userId == userId) && (pli._titleId == titleId) && (pli._settingId == settingId))
                {
                    pli._value = value;
                    return;
                }
            }
        }

        private ArrayList QueryCache(ArrayList alCacheLookups, UserSetting[] responses, UserSetting[] pictures, bool fUseLocalCache)
        {
            ArrayList alDatabaseLookups = new ArrayList();

            if ((alCacheLookups ==  null) || (alCacheLookups.Count == 0))
            {
                return alDatabaseLookups;
            }
            
            byte[][] keys = new byte[alCacheLookups.Count][];
            byte[][] values;
            uint[] validSeconds;
            uint[] retVals;

            for (int iKey = 0; iKey < alCacheLookups.Count; iKey++)
            {
                ProfileLookupItem pli = (ProfileLookupItem)(alCacheLookups[iKey]);
                keys[iKey] = ProfileDefs.BuildCacheKey(pli._settingId, pli._titleId, pli._userId);
            }
            
            retVals = Profile.Cache.Query(keys, out values, out validSeconds);

            for (int iKey = 0; iKey < retVals.Length; iKey++)
            {
                ProfileLookupItem pli = (ProfileLookupItem)(alCacheLookups[iKey]);
                if (retVals[iKey] == HResult.S_OK)
                {
                    if (Acceleration.CompareByteArrays(values[iKey], ProfileDefs.CacheNoValue))
                    {
                        // found emptiness.
                        continue;
                    }
                    
                    // found it in cache.
                    if (pli._settingId == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE)
                    {
                        if (pictures[pli._index].Source < XOn.XSOURCE_DEFAULT)
                        {
                            pictures[pli._index].Source = XOn.XSOURCE_DEFAULT;
                            pictures[pli._index].Value = values[iKey];
                            pictures[pli._index].ValueLen = (ushort)(values[iKey].Length);
                        }
                    }
                    else
                    {
                        uint source = (pli._titleId == XOn.XENON_DASH_TITLE_ID ? XOn.XSOURCE_DEFAULT : XOn.XSOURCE_TITLE);
                        if (responses[pli._index].Source < source)
                        {
                            responses[pli._index].Source = source;
                            responses[pli._index].Value = values[iKey];
                            responses[pli._index].ValueLen = (ushort)(values[iKey].Length);
                        }
                    }
                }
                else
                {
                    // didnt find it in cache.  is this setting transient only?
                    SettingInfo sinfo = SettingIds.Item(pli._settingId);

                    // shouldnt have to check for null here.  any setting that makes it this far should already have been found in the cache.
                    if (sinfo.IsDatabasePersisted())
                    {
                        // add it to the database lookups list.
                        alDatabaseLookups.Add(pli);
                    }
                }
            }

            return alDatabaseLookups;
        }

        private void PopulateCache(ArrayList alDatabaseLookups, bool fUseLocalCache)
        {
            if ((alDatabaseLookups != null) && (alDatabaseLookups.Count > 0))
            {
                byte[][] keys = new byte[alDatabaseLookups.Count][];
                byte[][] values = new byte[alDatabaseLookups.Count][];

                for (int iKey = 0; iKey < keys.Length; iKey++)
                {
                    ProfileLookupItem pli = (ProfileLookupItem)(alDatabaseLookups[iKey]);
                    keys[iKey] = ProfileDefs.BuildCacheKey(pli._settingId, pli._titleId, pli._userId);
                    values[iKey] = (pli._value == null) ? ProfileDefs.CacheNoValue : pli._value;
                }

                Profile.Cache.Insert(keys, values, new uint[keys.Length], new uint[keys.Length]);
            }
        }

        private bool InitializeSetting(UserSetting setting, ulong userIdRequestor, ulong userIdRequestee, ref User uacsUser, ref Friend[] friends, ref bool checkPrivs, ref bool isTitleWriteable)
        {
            SettingInfo sinfo = SettingIds.Item(setting.SettingId);

            if (sinfo == null)
                return false;
            
            uint newSource = XOn.XSOURCE_NO_VALUE;

            // do video enforcement
            if ((sinfo.Permissions & XOn.XPROFILE_SETTING_ENFORCE_VIDEO) != 0)
            {
                // we'll need to check privileges with each of the users..
                checkPrivs = true;
            }

            // do activity enforcement
            if (userIdRequestee != userIdRequestor &&
                ((sinfo.Permissions & XOn.XPROFILE_SETTING_ENFORCE_NOT_SHARED) != 0))
            {
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "User 0x" + userIdRequestor.ToString("x") + " attempted to read a " +
                    "setting from user 0x" + userIdRequestee.ToString("x") + " that has the XOn.XPROFILE_SETTING_ENFORCE_NOT_SHARED bit set! " +
                    " Attempt to read profile denied.");

                newSource = XOn.XSOURCE_PERMISSION_DENIED;
            }

            // do activity enforcement
            if (userIdRequestee != userIdRequestor &&
                ((sinfo.Permissions & XOn.XPROFILE_SETTING_ENFORCE_ACTIVITY) != 0))
            {
                // we'll need to check privileges with each of the users..
                checkPrivs = true;

                // check this user's ability to see other people's stuff
                if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING) == false)
                {
                    if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY) == true)
                    {
                        if (!ProfileUtil.IsFriendInList(userIdRequestor, userIdRequestee, ref friends, true))
                        {
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "User 0x" + userIdRequestor.ToString("x") + " attempted to read a " +
                                "non-friend's profile (0x" + userIdRequestee.ToString("x") + ", but has the XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY bit set! " +
                                " Attempt to read setting denied.");

                            // not a true friend, they can't see this user's settings
                            newSource = XOn.XSOURCE_PERMISSION_DENIED;
                        }
                    }
                    else
                    {
                        // user has said they shouldn't be able to view anyone else's profile
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "User 0x" + userIdRequestor.ToString("x") + " doesn't have " +
                            "the XOn.XPRIVILEGE_PROFILE_VIEWING or the  XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY " +
                            "bit set!  Attempt to read setting denied.");

                        newSource = XOn.XSOURCE_PERMISSION_DENIED;
                    }
                }
            }

            // do ucc enforcement
            if (userIdRequestee != userIdRequestor &&
               (sinfo.Permissions & XOn.XPROFILE_SETTING_ENFORCE_UCC) != 0)
            {
                // we'll need to check privileges with each of the users..
                checkPrivs = true;

                // check this user's ability to see other people's stuff
                if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT) == false)
                {
                    if (SGInfo.HasPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY) == true)
                    {
                        if (!ProfileUtil.IsFriendInList(userIdRequestor, userIdRequestee, ref friends, true))
                        {
                            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "User 0x" + userIdRequestor.ToString("x") + " attempted to read a " +
                                "non-friend's profile (0x" + userIdRequestee.ToString("x") + "), but has the XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY bit set! " +
                                " Attempt to read profile denied.");

                            // not a true friend, they can't see this user's settings
                            newSource = XOn.XSOURCE_PERMISSION_DENIED;
                        }
                    }
                    else
                    {
                        // user has said they shouldn't be able to view anyone else's profile
                        Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "User 0x" + userIdRequestor.ToString("x") + " doesn't have " +
                            "the XOn.XPRIVILEGE_PROFILE_VIEWING or the  XOn.XPRIVILEGE_USER_CREATED_CONTENT " +
                            "bit set!  Attempt to read profile " +
                            "denied.");

                        newSource = XOn.XSOURCE_PERMISSION_DENIED;
                    }
                }
            }

            if (userIdRequestee != userIdRequestor &&
                (sinfo.Permissions & XOn.XPROFILE_SETTING_ENFORCE_FRIENDS_ONLY) != 0)
            {
                // Users must be true, mutually-accepted friends
                if (!ProfileUtil.IsFriendInList(userIdRequestor, userIdRequestee, ref friends, false /* acceptRequest */))
                {
                    Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "Permission denied in reading settingId 0x" + setting.SettingId.ToString("x") +
                        " for user 0x" + userIdRequestee.ToString("x") + " by user 0x" + userIdRequestor.ToString("x") +
                        ": setting is readable by friends only.");

                    newSource = XOn.XSOURCE_PERMISSION_DENIED;
                }
            }

            isTitleWriteable = sinfo.IsTitleWritable();

            setting.Source = newSource;

            if ((newSource == XOn.XSOURCE_PERMISSION_DENIED) || SGInfo.IsGuestXuid(userIdRequestee))
            {
                // we're done here.
                return true;
            }

            // settings that don't come from t_user_settings
            if (sinfo.Id == ProfileDefs.XPROFILE_GAMER_TIER)
            {
                if (uacsUser == null)
                {
                    uacsUser = new User();
                    uacsUser.Load(userIdRequestee);
                }

                Assert.IsTrue(uacsUser.Tier < UInt16.MaxValue);
                setting.Value = BitConverter.GetBytes((uint)uacsUser.Tier);
                setting.ValueLen = (ushort)setting.Value.Length;
                setting.Source = XOn.XSOURCE_DEFAULT;

                // NOTE: we return false here because we dont require the normal settings lookup engine (cache, t_user_settings) to
                // obtain the value for this setting.  we've already got the only value we need.
                return false;
            }
            
            // settings that don't come from t_user_settings
            if (sinfo.Id == ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS)
            {
                if (uacsUser == null)
                {
                    uacsUser = new User();
                    uacsUser.Load(userIdRequestee);
                }

                uint serviceFlags = 0;

                foreach (KeyValuePair<ServiceTypeEnum, PerServiceTypeData> kvp in uacsUser.ServiceTypeData)
                {
                    serviceFlags |= (uint)((0x1 << (int)kvp.Key) & 0xFFFFFFF);
                }

                // make serviceFlags look like a byte array.
                setting.Value = new byte[4];
                setting.Value[0] = (byte)(serviceFlags & 0xFF);
                setting.Value[1] = (byte)((serviceFlags >> 8) & 0xFF);
                setting.Value[2] = (byte)((serviceFlags >> 16) & 0xFF);
                setting.Value[3] = (byte)((serviceFlags >> 24) & 0xFF);
                    
                setting.ValueLen = (ushort)setting.Value.Length;
                setting.Source = XOn.XSOURCE_DEFAULT;

                // NOTE: we return false here because we dont require the normal settings lookup engine (cache, t_user_settings) to
                // obtain the value for this setting.  we've already got the only value we need.
                return false;
            }

            return true;
        }

        /// <summary>
        /// Fixup the requested picture keys with personal picture information.
        /// </summary>
        /// <remarks>
        /// The personal picture info is only included in the key if the user being
        /// requested is a friend, the requestee hasn't blocked sharing and the
        /// requestor is allowed to see user created content.  Most of these checks
        /// are performed by ApplyProfilePermissions which is why the personal
        /// picture settings come in an array of UserSettings, much like the response
        /// settings do.
        /// </remarks>
        /// <param name="requestingUserId">The user making the profile read request</param>
        /// <param name="responseSettings">The settings that are being returned</param>
        /// <param name="friends">The requestor's friends</param>
        /// <param name="personalPictureSettings">An array of personal picture settings</param>
        private void FixupPictureKeys(
            int indexPictureKey,
            ulong           requestingUserId,
            UserSetting[]   responseSettings,
            UserSetting[]   publicPictureSettings,
            UserSetting[]   personalPictureSettings,
            uint schemaVersion)
        {
            const int   bytesPerChar = 2;
            const int   charsPerDword = 8;
            const int   keyLengthInCharacters = 3 * charsPerDword;                  // NumDwords * Chars/DWORD

            string customPictureTitleid = String.Format("{0:X8}", XOn.X_CUSTOM_PICTURE_TITLEID);
            string avatarPictureTitleid = String.Format("{0:X8}", XOn.X_AVATAR_PICTURE_TITLEID);

            // assumptions that should be good:
            int cUsers = personalPictureSettings.Length;
            int cSettings = responseSettings.Length / cUsers;

            // check integer math.
            Debug.Assert(cUsers * cSettings == responseSettings.Length);

            ulong[] xuids = new ulong[cUsers];
            for (int iUser = 0; iUser < cUsers; iUser++)
            {
                xuids[iUser] = publicPictureSettings[iUser].UserId;
            }
            string[] gamertags = XCache.LookupGamerTags(xuids);

            for (int iUser = 0; iUser < cUsers; iUser++)
            {
                UserSetting responseSetting = responseSettings[(iUser * cSettings) + indexPictureKey];

                Debug.Assert(responseSetting.UserId == publicPictureSettings[iUser].UserId);
                Debug.Assert(responseSetting.UserId == personalPictureSettings[iUser].UserId);
                Debug.Assert(responseSetting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY);

                if ((publicPictureSettings[iUser].Source == XOn.XSOURCE_PERMISSION_DENIED) ||
                    (publicPictureSettings[iUser].Source == XOn.XSOURCE_NO_VALUE) ||
                    (null == publicPictureSettings[iUser].Value) ||
                    (publicPictureSettings[iUser].Value.Length < keyLengthInCharacters * bytesPerChar))
                {
                    // skip.
                    continue;
                }

                // if we got this far, then we have a public picture.
                UnicodeEncoding ue = new UnicodeEncoding();
                string publicSettingString = ue.GetString(publicPictureSettings[iUser].Value);
                string personalSettingString = "";

                if (0 == String.Compare(
                    publicSettingString,
                    0,                      // indexA
                    avatarPictureTitleid,
                    0,                      // indexB
                    avatarPictureTitleid.Length,
                    true /* ignoreCase */))
                {
                    if (schemaVersion < WireData.MakeSchemaVersion(4, 4))
                    {
                        // prior to schema version 4.4, clients will not understand avatar picture key fixups.
                        // for avatar public picture keys, set the entire value to no_value and give up.
                        responseSetting.Source = XOn.XSOURCE_NO_VALUE;
                        responseSetting.Value = null;
                        responseSetting.ValueLen = 0;
                        continue;
                    }
                    else
                    {
                        // This is an avatar picture, fix the key to include the gamertag of the requestee
                        // and the unique id of this picture.
                        publicSettingString = String.Format("{0}{1}",
                            publicSettingString.Substring(charsPerDword /* start */, charsPerDword /* length */),
                            gamertags[iUser]);

                        // pad string length out to the desired size.  add a null character.
                        while (publicSettingString.Length < (keyLengthInCharacters + 1))
                        {
                            publicSettingString += '\0';
                        }
                    }
                }

                // now check for a personal picture
                if ((personalPictureSettings[iUser].Source != XOn.XSOURCE_PERMISSION_DENIED) &&
                    (personalPictureSettings[iUser].Source != XOn.XSOURCE_NO_VALUE) &&
                    (null != personalPictureSettings[iUser].Value) &&
                    (personalPictureSettings[iUser].Value.Length >= keyLengthInCharacters * bytesPerChar))
                {
                    // we have a personal picture.
                    personalSettingString = ue.GetString(personalPictureSettings[iUser].Value);

                    if (0 == String.Compare(
                        personalSettingString,
                        0,                      // indexA
                        customPictureTitleid,
                        0,                      // indexB
                        customPictureTitleid.Length,
                        true /* ignoreCase */))
                    {
                        // This is a custom picture, fix the key to include the xuid of the requestee
                        // and the unique id of this picture.
                        personalSettingString = String.Format("{0}{1:X16}",
                            personalSettingString.Substring(charsPerDword /* start */, charsPerDword /* length */),
                            personalPictureSettings[iUser].UserId);
                    }
                    else if (0 == String.Compare(
                        personalSettingString,
                        0,                      // indexA
                        avatarPictureTitleid,
                        0,                      // indexB
                        avatarPictureTitleid.Length,
                        true /* ignoreCase */))
                    {
                        if (schemaVersion < WireData.MakeSchemaVersion(4, 4))
                        {
                            // prior to schema version 4.4, clients will not understand avatar picture key fixups.
                            // for avatar pictures in the personal field, just throw it away.  we'll just use the public picture.
                            personalSettingString = "";
                        }
                        else
                        {
                            // This is a avatar picture, fix the key to include the gamertag of the requestee
                            // and the unique id of this picture.
                            personalSettingString = String.Format("{0}{1}",
                                personalSettingString.Substring(charsPerDword /* start */, charsPerDword /* length */),
                                gamertags[iUser]);

                            // pad string length out to the desired size.  add a null character.
                            while (personalSettingString.Length < (keyLengthInCharacters + 1))
                            {
                                personalSettingString += '\0';
                            }
                        }
                    }
                }

                string responseSettingString = publicSettingString;
                if (personalSettingString.Length >= keyLengthInCharacters)
                {
                    // Build the new response value.  Take the substrings because
                    // we don't want to mess up the offsets or included null terminators.
                    responseSettingString = 
                        publicSettingString.Substring(0, keyLengthInCharacters) + 
                        personalSettingString.Substring(0, keyLengthInCharacters) + 
                        '\0';
                }

                // Convert the response setting back to bytes and put those
                // bytes back in the response
                responseSetting.Value = ue.GetBytes(responseSettingString);
                responseSetting.ValueLen = (ushort)ue.GetByteCount(responseSettingString);

                // Make sure we stayed within the max size of the setting
                Assert.IsTrue(100 >= responseSetting.ValueLen);
            }

        }
    }   // class XRLReadSettings


    public class ReadSettingsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            ReadSettingsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            ReadSettingsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         ReadSettingsCountersCategory.Current(titleId).FailuresPerSecond,
                                         ReadSettingsCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            ReadSettingsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ReadSettingsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                ReadSettingsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                ReadSettingsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: ReadSetting", "Stats FD: ReadSetting" )]
    public class ReadSettingsCountersCategory : XomPerformanceCounterCategory
    {

        static public ReadSettingsCountersCategory _instance = new ReadSettingsCountersCategory();
        static public ReadSettingsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(ReadSettingsCountersCategory)_instance.GetInstance(titleId);
        }


        // ReadSetting request counters

        [XomPerformanceCounterAttr(
                                  "ReadSetting requests/sec",
                                  "ReadSetting requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                  "ReadSetting total",
                                  "Total ReadSetting requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                  "ReadSetting failures/sec",
                                  "Number of unsuccessful results returned by ReadSetting per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                  "ReadSetting total failures",
                                  "Total number unsuccessful results returned by ReadSetting in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                  "ReadSetting avg. execution time",
                                  "ReadSetting Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlCompCreateLb.cs ===
/******************************************************************************
  Copyright (c) 2003 Microsoft Corporation

  XBox Live Statistics
  
  xrlCompCreateLb.cs
******************************************************************************/

using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.stats.fd 
{
    // XRLCompCreateLb
    // HTTP handler for CompCreateLb request
    public class XRLCompCreateLb : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            // Read request
            BinaryReader               reader  = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper        writer  = new BinaryWriterWrapper(ctx.Response.OutputStream);
            ReqCompCreateLb            req     = new ReqCompCreateLb();
            
            try
            {
                // This is an internal port request only
                CallSource.Check(VirtualInterface.xstatsfd_int);
                
                // Read request                
                try
                {
                    req.ReadFrom(reader);
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_72,
                            "Failed to parse XRLCompCreateLb. Reason: " + e.Message, e);
                    if(se != e) throw se; else throw;
                }
                
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "ReqCompCreateLb:"+req);
                
                // Create the competition leaderboard
                uint uiLbId;
                StatDb statDb = new StatDb();
                statDb.CreateCompetitionLeaderboard(req._uiTitleId, req._uiTemplateId, out uiLbId);
                
                // Succeeded. Return the new leaderboard id in the response.
                RepCompCreateLb rep = new RepCompCreateLb();
                rep._uiLbId = uiLbId;
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, HResult.S_OK);
                rep.WriteTo(writer);
                
                // Log
                string logentry = 
                    "COMPCREATELB"+
                    "|"+req._uiTitleId.ToString("x")+
                    "|"+req._uiTemplateId.ToString("x")+
                    "|"+rep._uiLbId.ToString("x");
                
                Xom.Log(XomAreaName.statslog, logentry);
                
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepCompCreateLb:"+rep);
            }
            catch(Exception e)
            {
                // Catch the exception so we can add more stuff to it.
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.MC_APPLICATION_ERROR_11,
                        "Unhandled exception. Message: " + e.Message, e);
                    
                try { se.AppendInfo("\nReqCompCreateLb: "+req.ToString()); } catch(Exception){}
                if(se != e) throw se; else throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlReloadDbMap.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlReloadDbMap.cs
 * 
 * 
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.service;

namespace xonline.server.stats.fd 
{
    public class XRLReloadDbMap : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            CallSource.Check(VirtualInterface.xstatsfd_int);

            StatDb.InitializeDbMap();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlCompDeleteLb.cs ===
/******************************************************************************
  Copyright (c) 2003 Microsoft Corporation

  XBox Live Statistics
  
  xrlCompDeleteLb.cs
******************************************************************************/

using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.stats.fd 
{
    // XRLCompDeleteLb
    // HTTP handler for CompCreateLb request
    public class XRLCompDeleteLb : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            // Read request
            BinaryReader               reader  = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper        writer  = new BinaryWriterWrapper(ctx.Response.OutputStream);
            ReqCompDeleteLb            req     = new ReqCompDeleteLb();
            
            try
            {
                // This is an internal port request only
                CallSource.Check(VirtualInterface.xstatsfd_int);

                // Read request                
                try
                {
                    req.ReadFrom(reader);
                }
                catch(Exception e)
                {
                    XRLException se = e as XRLException;
                    if(se == null)
                        se = new XRLException(HResult.XONLINE_E_STAT_BAD_REQUEST, XEvent.Id.XSTATSFD_INVALID_REQUEST_73,
                            "Failed to parse XRLCompDeleteLb. Reason: " + e.Message, e);
                    if(se != e) throw se; else throw;
                }
                
                Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "ReqCompDeleteLb:"+req);
                
                // Delete the competition leaderboard
                StatDb statDb = new StatDb();
                statDb.DeleteCompetitionLeaderboard(req._uiTitleId, req._uiLbId);
                
                // Succeeded. Return the new leaderboard id in the response.
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, HResult.S_OK);
                
                // Log
                string logentry = 
                    "COMPDELETELB"+
                    "|"+req._uiTitleId.ToString("x")+
                    "|"+req._uiLbId.ToString("x");
                    
                Xom.Log(XomAreaName.statslog, logentry);
            }
            catch(Exception e)
            {
                // Catch the exception so we can add more stuff to it.
                XRLException se = e as XRLException;
                if(se == null)
                    se = new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.MC_APPLICATION_ERROR_12,
                        "Unhandled exception. Message: " + e.Message, e);
                    
                try { se.AppendInfo("\nReqCompCreateLb: "+req.ToString()); } catch(Exception){}
                if(se != e) throw se; else throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlEnumTitles.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlEnumTitles.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLEnumTitles : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            EnumTitlesCounters counters = new EnumTitlesCounters();
            EnumTitlesRequest req = new EnumTitlesRequest();
            EnumTitlesResponse resp = new EnumTitlesResponse();
            uint hr = HResult.XONLINE_E_STAT_ERROR;
            string vi = VirtualInterface.xstatsfd;
            Friend[] friends = null;
            ArrayList titleList;
            string[] locales;

            try
            {
                counters.StartRequest();

                vi = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                hr = Profile.CheckPermissions(req.UserId, req.ForUserId, XOn.XPROFILE_SETTING_ENFORCE_ACTIVITY, ref friends);

                if (HResult.Failed(hr))
                    goto end;

                // Still assume something went wrong until the end
                hr = HResult.XONLINE_E_STAT_ERROR;

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                //
                // read list of titles
                //

                titleList = new ArrayList();

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "p_xmsg_user_title_enumerate";
                    ws.Partition = ws.CalcPartition(req.ForUserId);

                    ws.AddParameter("@bi_user_puid", req.ForUserId);

                    WstDataReader reader = ws.Execute();

                    int i = 0;

                    while (reader.Read())
                    {
                        // Make sure it is an Xbox 360 Full title (as opposed to an Xbox 1,
                        // demo or system app).
                        if (((int)reader["i_flags"] & 0x00010000) == 0)
                            continue;

                        // Skip titles that we would have returned until we get to the requested offset
                        if (i++ < req.StartingIndex)
                            continue;

                        UserTitle title = new UserTitle();

                        // User-specific fields from the database
                        title.TitleId = (uint)(int)reader["i_title_id"];
                        title.LastPlayed = (DateTime)reader["dt_last_logon"];
                        title.Sequence = (uint)(int)reader["i_sequence"];
                        title.NumCreds = (uint)(int)reader["i_creds"];
                        title.NumAchievements = (ushort)(int)reader["i_achievements"];

                        // Title-specific fields from the XLAST file
                        xonline.common.config.TitleConfig tcfg = xonline.common.config.TitleConfig.GetTitle(title.TitleId, false /* throwWhenNotFound */);

                        if (null == tcfg)
                        {
                            Xom.NtEvent(XEvent.Id.STATS_CONFIG_23, "Error loading title config for titleId = " + (TitleId) title.TitleId + ". Skipping enum of title.");

                            // If we're still skipping titles because we're not at the
                            // requested offset yet then we have to adjust the offset
                            // by 1 to remove the increment done on the StartingIndex
                            // check above.  This is because this title would not have
                            // been returned and therefore doesn't count when skipping
                            // returned titles.  We could just put the StartingIndex
                            // check after the GetTitle call, but that would do all the
                            // GetTitle work even for title that otherwise would be
                            // easily skipped.
                            if (i < req.StartingIndex)
                            {
                                Debug.Assert(0 < i);
                                i--;
                            }

                            continue;
                        }

                        title.TitleName = tcfg.Names[locales];
                        title.TotalAchievements = (ushort)tcfg.Achievements.Count;
                        title.TotalCred = tcfg.MaxCred;

                        titleList.Add(title);

                        if (titleList.Count >= req.MaxTitles)
                            break;
                    }
                }

                if (titleList.Count > 0)
                {
                    resp.Titles = new UserTitle[titleList.Count];
                    titleList.CopyTo(resp.Titles);
                }

                // todo: copy title names, other metadata to protocol

                hr = HResult.S_OK;

end:
                ;

            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUT|{0:x}|{1:x}|{2:x}|{3:x}|",
                    hr,
                    req.UserId,
                    req.ForUserId,
                    (null == resp.Titles ? 0 : resp.Titles.Length));

                if (resp.Titles != null)
                {
                    for (int i = 0; i < resp.Titles.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Titles[i].TitleId);

                        if (i != resp.Titles.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }


    public class EnumTitlesCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        public void StartRequest()
        {
            StartRequestWorker(null);
        }

        private void StartRequestWorker(string titleId)
        {
            EnumTitlesCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            EnumTitlesCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         EnumTitlesCountersCategory.Current(titleId).FailuresPerSecond,
                                         EnumTitlesCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);
        }

        public void EndRequestWorker(string titleId, bool failed)
        {
            EnumTitlesCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            EnumTitlesCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                EnumTitlesCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                EnumTitlesCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }




    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: EnumTitles", "Stats FD: EnumTitles" )]
    public class EnumTitlesCountersCategory : XomPerformanceCounterCategory
    {

        static public EnumTitlesCountersCategory _instance = new EnumTitlesCountersCategory();
        static public EnumTitlesCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(EnumTitlesCountersCategory)_instance.GetInstance(titleId);
        }


        // EnumTitles request counters

        [XomPerformanceCounterAttr(
                                 "EnumTitles requests/sec",
                                 "EnumTitles requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumTitles total",
                                 "Total EnumTitles requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "EnumTitles failures/sec",
                                 "Number of unsuccessful results returned by EnumTitles per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "EnumTitles total failures",
                                 "Total number unsuccessful results returned by EnumTitles in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "EnumTitles avg. execution time",
                                 "EnumTitles Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlStatPost.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlStatPost.cs
 * 
 * Implementation of ReqStatPost request
 * 
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    public class XRLStatPost : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            string viface = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            
            StatPost statPost = new StatPost(
                (IStatIO) new StatsFdIO(ctx), 
                (IStatDb) new StatDb(),
                StatsFdUtil.BuildStatAuth(ctx, viface));
                
            if(Config.GetBoolSetting(Setting.stats_AllowAlternateDestination))
            {
                if(ctx.Request.Headers["AlternateSignUrl"] != null)
                {
                    statPost.SetAltSignUrl(ctx.Request.Headers["AlternateSignUrl"]);
                }
            }

            statPost.ParseRequest();
            statPost.Process();
            statPost.SendResponse();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlStatPostXe.cs ===
/*
 * Copyright (c) 2005 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlStatPostXe.cs
 * 
 * Implementation of StatPost Xenon request
 * 
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    public class XRLStatPostXe : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            string viface = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            
            StatPost statPost = new StatPost(
                (IStatIO) new StatsFdIO(ctx), 
                (IStatDb) new StatDb(),
                StatsFdUtil.BuildStatAuth(ctx, viface));
                
            if(Config.GetBoolSetting(Setting.stats_AllowAlternateDestination))
            {
                if(ctx.Request.Headers["AlternateSignUrl"] != null)
                {
                    statPost.SetAltSignUrl(ctx.Request.Headers["AlternateSignUrl"]);
                }
            }

            StatsPostRequest req = new StatsPostRequest();
            req.ReadFromRequest(ctx.Request);
            statPost.ParseRequest(req);
            statPost.Process();
            statPost.SendResponseXe();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlStatRead.cs ===
/*
 * Copyright (c) 2005 Microsoft Corporation
 *
 * Storage Front-Door (stfd)
 *
 * xrlStatRead.cs
 *
 * Implementation of StatRead Xenon request
 *
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd
{
    public class XRLStatRead : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>If object can be reused (true or false)</returns>
        /// <remarks>
        /// Since the object doesn hold any state, this method always returns true
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP request context</param>
        /// <remarks>
        /// Process input HTTP request f or StatReadRequests.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            
            BinaryReader           reader      = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper    writer      = new BinaryWriterWrapper(ctx.Response.OutputStream);


            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();
            StatGet statGet = new StatGet(reader, (IStatDb) new StatDb());

            StatsReadRequest  req  = new StatsReadRequest();
            StatsReadResponse resp = new StatsReadResponse();

            // Read the input request
            req.ReadStream(reader);

            WriteLog(req);

            // Initialize results buffer
            ArrayList results = new ArrayList((int) req.Specs.Length);

            ArrayList ids = new ArrayList();

            // For each stat spec, run a stat get query
            foreach (StatsSpec spec in req.Specs)
            {

                // build the list of unique column ids to query for
                //
                ids.Clear();
                ids.Add(SpecialAttrib.Rank);
                ids.Add(SpecialAttrib.Rating);
                ids.Add(SpecialAttrib.LeaderboardSize);

                for (int i = 0; i < spec.ColumnCount; i++)
                {
                    if (!ids.Contains(spec.ColumnIds[i]))
                        ids.Add(spec.ColumnIds[i]);
                }

                // Convert to V1 protocol request
                ReqGetData reqGetData = new ReqGetData();
                reqGetData._messages = new MsgGetData[req.Users.Length];

                for (int i = 0; i < req.Users.Length; i++)
                {
                    MsgGetData msg = new MsgGetData();
                    msg._uiTitleId   = req.TitleId;
                    msg._ulUserId    = req.Users[i];
                    msg._uiLbId      = (uint) spec.ViewId;

                    // Add Rating and Rank to the list of columns requested
                    msg._uiAttrCount = (uint)ids.Count;
                    msg._attrIds     = new ushort[ids.Count];
                    ids.CopyTo(msg._attrIds);

                    reqGetData._messages[i] = msg;
                }


                // Send request
                statGet.ProcessRequest(reqGetData);

                // Convert V1 response
                results.Add(GenerateResponse(spec, statGet.Reply));
            }

            // Put resultsets into response object
            resp.Results = new StatsResultSet[results.Count];
            results.CopyTo(resp.Results);

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req.TitleId, HResult.S_OK);
            resp.WriteStream(writer);
        }

        /// <summary>
        /// GenerateResponse
        /// </summary>
        /// <param name="reply">V1 stats get data response</param>
        /// <returns>StatsResultSet</returns>
        /// <remarks>
        /// Generate a result set from a V1 get data reply.
        // Result set is ready to be added to a Xenon read reply.
        /// </remarks>
        protected StatsResultSet GenerateResponse(StatsSpec spec, RepGetData reply)
        {
            //ArrayList rows = new ArrayList(reply._reps.Length);
            StatsResultSet result = new StatsResultSet();
            result.Rows = new StatsRow[reply._reps.Length];
            ulong[] xuids = new ulong[reply._reps.Length];


            // Initialize result set
            if (reply._reps.Length > 0)
            {
                result.ViewId = reply._reps[0]._uiLbId;
            }


            for (int r = 0; r < reply._reps.Length; r++)
            {
                MsgRepGetData rep = reply._reps[r];

                StatsRow row = new StatsRow();
                row.Columns = new StatsColumn[spec.ColumnCount];

                // initialize the list of columns for this row
                for (int i = 0; i < row.Columns.Length; i++)
                {
                    row.Columns[i] = new StatsColumn();
                    row.Columns[i].ColumnId = spec.ColumnIds[i];
                    row.Columns[i].Type = StatParam.Null;
                }

                // now copy over the data from the v1 reseponse
                row.Puid     = rep._ulUserId;
                xuids[r]     = rep._ulUserId;

                foreach (MsgAttribData attrib in rep._attribs)
                {
                    switch(attrib._usAttrId)
                    {
                        case SpecialAttrib.Rank:
                            if (attrib._value == null)
                            {
                                row.Rank = 0;
                            }
                            else
                            {
                                Int32 value = (Int32) attrib._value;
                                row.Rank    = (uint) value;
                            }
                            break;

                        case SpecialAttrib.Rating:
                            if (attrib._value == null)
                            {
                                row.Rating = 0;
                            }
                            else
                            {
                                Int64 value = (Int64) attrib._value;
                                row.Rating  = (ulong) value;
                            }
                            break;

                        case SpecialAttrib.LeaderboardSize:
                            if (attrib._value == null)
                            {
                                row.Rating = 0;
                            }
                            else
                            {
                                Int32 value = (Int32) attrib._value;
                                result.ViewSize = (uint)value;
                            }
                            break;

                        default:
                            {
                                for (int i = 0; i < row.Columns.Length; i++)
                                {
                                    if (row.Columns[i].ColumnId == attrib._usAttrId)
                                    {
                                        row.Columns[i].Type = StatParam.MapFromAttrType((AttrType) attrib._bAttrType);
                                        row.Columns[i].Data = attrib._value;
                                    }
                                }
                            }
                            break;
                    }
                }

                result.Rows[r] = row;
            }

            // resolve gamertags
            string[] names;
            try
            {
                names = XCache.LookupGamerTags(xuids);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.STATS_COMM_10, e, "Call to XCache failed.");

                // Return a bunch of empty strings
                names = new string[xuids.Length];

                for(int i=0; i < names.Length; i++)
                {
                    names[i] = string.Empty;
                }
            }

            // copy the gamertags to the final results
            for (int i = 0; i < result.Rows.Length; i++)
            {
                result.Rows[i].GamerTag = names[i];
            }


            return result;
        }

        protected void WriteLog(StatsReadRequest req)
        {
            StringBuilder logentry = new StringBuilder("XRLStatRead|");
            logentry.Append(req.TitleId.ToString("x"));

            foreach (StatsSpec spec in req.Specs)
            {
                logentry.Append("|" + spec.ViewId.ToString("x"));
                logentry.Append("|" + spec.ColumnIds.Length.ToString("x"));
            }

            foreach (ulong userid in req.Users)
            {
                logentry.Append("|" + userid.ToString("x"));
            }

            Xom.Log(XomAreaName.statslog, logentry.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlSyncAchievements.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncAchievements.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLSyncAchievements : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncAchievementsCounters counters = new SyncAchievementsCounters();
            SyncAchievementsRequest req = new SyncAchievementsRequest();
            SyncAchievementsResponse resp = new SyncAchievementsResponse();
            uint hr = HResult.E_FAIL;
            string vi = VirtualInterface.xstatsfd;
            string[] locales;

            try
            {
                vi = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);
                bool isServerPort = (vi == VirtualInterface.xstatsfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyUserId(req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                Profile.SyncAchievements(
                            req.UserId,
                            req.TitleId,
                            locales,
                            req.Version,
                            req.StartingIndex,
                            req.Achievements,
                            isServerPort,
                            out resp.Version,
                            out resp.Achievements,
                            out resp.TotalAchievements);

                // Recalc the gamerscore and achievements for this title and across all titles
                if (req.Achievements.Length > 0)
                {
                    Profile.RecalcGamerscore(
                        req.UserId,
                        req.TitleId);
                }

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUA|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Achievements != null)
                {
                    for (int i = 0; i < req.Achievements.Length; i++)
                    {
                        if (req.Achievements[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Achievements[i].AchievementId);

                        if (i != req.Achievements.Length-1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Achievements != null)
                {
                    for (int i = 0; i < resp.Achievements.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Achievements[i].AchievementId);

                        if (i != resp.Achievements.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }

    public class SyncAchievementsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            SyncAchievementsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            SyncAchievementsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         SyncAchievementsCountersCategory.Current(titleId).FailuresPerSecond,
                                         SyncAchievementsCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            SyncAchievementsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SyncAchievementsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                SyncAchievementsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                SyncAchievementsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }




    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: SyncAchievements", "Stats FD: SyncAchievements" )]
    public class SyncAchievementsCountersCategory : XomPerformanceCounterCategory
    {

        static public SyncAchievementsCountersCategory _instance = new SyncAchievementsCountersCategory();
        static public SyncAchievementsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(SyncAchievementsCountersCategory)_instance.GetInstance(titleId);
        }


        // SyncAchievements request counters

        [XomPerformanceCounterAttr(
                                 "SyncAch requests/sec",
                                 "SyncAch requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncAch total",
                                 "Total SyncAch requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "SyncAch failures/sec",
                                 "Number of unsuccessful results returned by SyncAch per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncAch total failures",
                                 "Total number unsuccessful results returned by SyncAch in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "SyncAch avg. execution time",
                                 "SyncAch Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlReloadPlatformVisibleLeaderboardMap.cs ===
/*
 * Copyright (c) 2011 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlReloadPlatformVisibleLeaderboardMap.cs
 * 
 * This handler exists to allow the platform visible leaderboard map to be initialized by the
 * new "reloadplatformvisibleleaderboards" xmgmnt command.
 * 
 * */

using System;
using System.Web;

using xonline.common.config;
using xonline.common.service;

namespace xonline.server.stats.fd 
{
    public class XRLReloadPlatformVisibleLeaderboardMap : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold 
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            CallSource.Check(VirtualInterface.xstatsfd_int);

            StatDb.InitializePlatformVisibleLeaderboardMap();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlStatEnum.cs ===
/*
 * Copyright (c) 2005 Microsoft Corporation
 * 
 * Storage Front-Door (stfd)
 * 
 * xrlStatEnum.cs
 * 
 * Implementation of StatEnum* Xenon requests
 * 
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Threading;


using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd 
{
    #region XRL Enum protocol handler classes
    
    public class XRLStatEnumByUser : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>If object can be reused (true or false)</returns>
        /// <remarks>
        /// Since the object doesn hold any state, this method always returns true
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP request context</param>
        /// <remarks>
        /// Process input HTTP request for StatEnumByUserRequests.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            BinaryReader        reader = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper writer = new BinaryWriterWrapper(ctx.Response.OutputStream);

            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();

            StatsEnumByUserRequest req  = new StatsEnumByUserRequest();
            StatsEnumResponse      resp = null;

            CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            
            // Read the input request
            req.ReadStream(reader);

            // Execute enumeration
            resp = EnumLbCallback.ExecuteMultiSpecs(StatDb.EnumType.User,
                                                  req.TitleId,
                                                  req.PageSize,
                                                  req.UserId,
                                                  req.Specs);

            // Return results
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req.TitleId, HResult.S_OK);
            resp.WriteStream(writer);
        }
    }

    public class XRLStatEnumByRank : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>If object can be reused (true or false)</returns>
        /// <remarks>
        /// Since the object doesn hold any state, this method always returns true
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP request context</param>
        /// <remarks>
        /// Process input HTTP request for StatEnumByRankRequests.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            BinaryReader        reader = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper writer = new BinaryWriterWrapper(ctx.Response.OutputStream);

            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();

            StatsEnumByRankRequest req  = new StatsEnumByRankRequest();
            StatsEnumResponse      resp = null;
            
            CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);
            

            // Read the input request
            req.ReadStream(reader);

            // Execute enumeration
            resp = EnumLbCallback.ExecuteMultiSpecs(StatDb.EnumType.Rank,
                                          req.TitleId,
                                          req.PageSize,
                                          req.Rank,
                                          req.Specs);
                                          

            // Return results
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req.TitleId, HResult.S_OK);
            resp.WriteStream(writer);
        }
    }

    public class XRLStatEnumByRating : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>If object can be reused (true or false)</returns>
        /// <remarks>
        /// Since the object doesn hold any state, this method always returns true
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP request context</param>
        /// <remarks>
        /// Process input HTTP request for StatEnumByRatingRequests.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            BinaryReader        reader = new BinaryReader(ctx.Request.InputStream);
            BinaryWriterWrapper writer = new BinaryWriterWrapper(ctx.Response.OutputStream);

            StatsFdUtil.EnableContextDebuggingBasedOnSGInfo();

            StatsEnumByRatingRequest req  = new StatsEnumByRatingRequest();
            StatsEnumResponse        resp = null;
            
            CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);


            // Read the input request
            req.ReadStream(reader);

            // Execute enumeration
            resp = EnumLbCallback.ExecuteMultiSpecs(StatDb.EnumType.Rating,
                                          req.TitleId,
                                          req.PageSize,
                                          req.Rating,
                                          req.Specs);

            // Return results
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, req.TitleId, HResult.S_OK);
            resp.WriteStream(writer);
        }
    }

    #endregion

    #region Enum support class
    
    public class EnumLbCallback : IStatDbEnumLbCallback
    {
        public ushort[]          _columnIds   = null;
        public Hashtable         _columnIdMap = null;
        public StatsRow          _row         = null;
        public ArrayList         _rows        = null;
        
        public StatDb.EnumType   _type        = StatDb.EnumType.Rank;
        public ulong             _userId      = 0;
        public uint              _titleId     = 0;
        public uint              _pageSize    = 0;
        public ulong             _pivot       = 0;
        public StatsSpec         _spec        = null;
        public ManualResetEvent  _signal      = null;
        
        public uint              _viewSize    = 0;
        public StatsResultSet    _resultSet   = null;
        
        public Exception         _exception   = null;
        
        
        public EnumLbCallback(StatDb.EnumType enumType, ulong userId, uint titleId, uint pageSize, ulong pivot, StatsSpec spec, ManualResetEvent signal)
        {
            _type = enumType;
            _titleId = titleId;
            _pageSize = pageSize;
            _pivot = pivot;
            _spec = spec;
            _signal = signal;
            

            _columnIds = (ushort[]) spec.ColumnIds.Clone();
            //Array.Sort(_columnIds);


            _row  = null;
            _rows = new ArrayList((int) _pageSize);

            _resultSet = new StatsResultSet();
            _resultSet.ViewId = _spec.ViewId;
        }

        /// <summary>
        /// OnNewRow
        /// </summary>
        /// <param name="userId">User PUID</param>
        /// <param name="name">Gamertag</param>
        /// <param name="rating">Rating value</param>
        /// <param name="rank">Rank value</param>
        /// <remarks>
        /// This method is called for each new row returned from the leaderboard server
        /// </remarks>
        public void OnNewRow(ulong userId, string name, long rating, uint rank)
        {
            _row = new StatsRow(userId, rank, (ulong) rating, name, (uint) _columnIds.Length);

            for(int i=0; i < _columnIds.Length; i++)
            {
                _row.Columns[i] = new StatsColumn(_columnIds[i], (byte) AttrType.None, null);
            }

            _rows.Add(_row);
        }

        /// <summary>
        /// OnAttribute
        /// </summary>
        /// <param name="columnId">Column ID</param>
        /// <param name="value">Column value</param>
        /// <remarks>
        /// This method is called for each column on a returned row
        /// </remarks>
        public void OnAttribute(ushort columnId, object value)
        {
            for (int i = 0; i < _columnIds.Length; i++)
            {
                StatsColumn column = _row.Columns[i];

                if(column.ColumnId != columnId)
                {
                        continue;
                }

                column.Data = value;

                if(value == null)
                {
                	column.Type = (byte) StatParam.Null;
                }
                else if(value is int)
                {
                    column.Type = (byte) StatParam.Int32;
                }
                else if (value is long)
                {
                    column.Type = (byte) StatParam.Int64;
                }
                else if (value is double)
                {
                    column.Type = (byte) StatParam.Float;
                }
                else if(value is string)
                {
                    column.Type = (byte) StatParam.Utf8string;
                }
                else
                {
                    throw new Exception("Invalid column type");
                }
            }
        }

        /// <summary>
        /// PrepareResponse
        /// </summary>
        /// <remarks>
        /// Formats leaderboard enum response into StatsReadResponse object
        /// </remarks>
        public void PrepareResponse()
        {
            _resultSet.Rows = (StatsRow[]) _rows.GetRange(0, Math.Min((int) _pageSize, _rows.Count)).ToArray(typeof(StatsRow));
            _resultSet.RowCount = (uint) _resultSet.Rows.Length;           
        }

        /// <summary>
        /// Execute
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="viewId">Leaderboard ID</param>
        /// <param name="enumType">Enum type (user, rank, rating)</param>
        /// <param name="pivot">Pivot value (user id, rank, or rating)</param>
        /// <param name="pageSize">Count of rows in enumeration</param>
        /// <param name="columnIds">List of column id's</param>
        /// <returns>StatsEnumResponse</returns>
        /// <remarks>
        /// Executes enumeration request.
        /// Results handled by callback and processed into a StatsEnumResponse object.
        /// </remarks>
        public static StatsEnumResponse ExecuteMultiSpecs
            (
                StatDb.EnumType enumType,
                uint            titleId,
                uint            pageSize,
                ulong           pivot,
                StatsSpec[]     specs
            )
        {
            StatsEnumResponse resp      = new StatsEnumResponse();
            EnumLbCallback[]  callbacks = null;
            ulong ulCallerPuid          = 0;
            
            bool fLog = Config.GetBoolSetting(Setting.stats_enableCertificationMode) && AuthToggle.On;
            
            if (fLog)
            {
                ulCallerPuid = SGInfo.Current.LogonUsers[0].qwUserID;
            }
            
            callbacks = new EnumLbCallback[specs.Length];
            for (int i = 0; i < specs.Length; i++)
            {
                // last one, execute on this thread
                callbacks[i] = new EnumLbCallback(enumType, ulCallerPuid, titleId, pageSize, pivot, specs[i], null);
                EnumLbCallback.ExecuteSingleEnum(callbacks[i]);
            }                               

            // Format results into response
            resp.Results = new StatsResultSet[callbacks.Length];
            for (int i = 0; i < resp.Results.Length; i++)
            {
                if (callbacks[i]._exception != null)
                {
                    // This is not ideal, but the end effect isn't actually that bad. I removed WrapperException
                    // because it was sprinkled throughout our code and has very little in the way of valid uses.
                    // This is the one place where we are throwing the baby out with the bathwater. By wrapping
                    // this in a plain old Exception, we maintain the original stack trace, but we will end up 
                    // with an extra stack trace being put in our event log. I'm OK with that.
                    throw new Exception("Background call failed. See inner exception for details.", callbacks[i]._exception);
                }

                callbacks[i].PrepareResponse();
                resp.Results[i] = callbacks[i]._resultSet;
            }
            
            resp.StatsResultSetLen = (ushort)resp.Results.Length;    
            
            return resp;
        }
        
        static void ExecuteSingleEnum(object o)
        {
            EnumLbCallback callback = (EnumLbCallback)o;            
            
            try
            {
                StatDb            db       = new StatDb();
                
                uint  attachCount     = 0;
                uint  maxAttachSize   = 0;
    
                //
                // try/catch is to make sure we catch the case
                // when the user isn't found.  (17282)
                //
                // yeah, this would be more efficient to return
                // an hr instead of throwing an exception, but 
                // we don't want to change xbox 1 behavior.   
                //
                try
                {
                    db.EnumLeaderBoard(callback._titleId,
                                       callback._spec.ViewId,
                                       callback._type,
                                       callback._pivot,
                                       callback._pageSize,
                                       callback._columnIds,
                                       callback,
                                       (callback._userId == 0),
                                       callback._userId,
                                       out callback._viewSize,
                                       // -- IGNORE for Xenon --
                                       out attachCount,
                                       out maxAttachSize);
                                   
                    callback._resultSet.ViewSize = callback._viewSize;                                  
                }
                catch(XRLException e)
                {
                    if (e.HResult != HResult.XONLINE_E_STAT_USER_NOT_FOUND)
                    {
                        throw;
                    }
                    // else no user found, just return empty resultset
                }                           
                        
                if (callback._viewSize == 0 && callback._type == StatDb.EnumType.User)
                {
                    // this happens if the user isn't found.  
                    // Hack: try getting the value by doing a simple enumbyrank.
                    // (really lbsvr should be fixed to return view size with the
                    // first query.. (20900)
                    //
                    StatsSpec spec = new StatsSpec();
                    spec.ColumnCount = 0;
                    spec.ColumnIds = new ushort[0];
                    spec.ViewId = callback._spec.ViewId;
                    
                    StatsEnumResponse viewSizeResp;
                    viewSizeResp = ExecuteMultiSpecs(
                                        StatDb.EnumType.Rank, 
                                        callback._titleId, 
                                        1, // page size 
                                        1, // pivot
                                        new StatsSpec[] { spec }
                                   );
                                   
                    if (viewSizeResp.StatsResultSetLen != 1)
                    {
                        throw new XRLException(HResult.XONLINE_E_STAT_ERROR, XEvent.Id.STATS_CODE_24, 
                            "Failed to get the view size from a request for an non-existant user! " + 
                            "The StatsResult from an EnumByRank returned " + viewSizeResp.StatsResultSetLen + 
                            " results.");
                    }
                            
                    callback._viewSize = viewSizeResp.Results[0].ViewSize;
                    callback._resultSet.ViewSize = callback._viewSize;                                  
                }    
                
            }        
            catch(Exception e)
            {
                callback._exception = e;
            }
            finally
            {
                // set the waithandle, if any
                if (callback._signal != null)
                { 
                    callback._signal.Set();
                }
            }            
            
        }    
            
            
        
    }
    

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlSyncAvatarAssets.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncAvatarAssets.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLSyncAvatarAssets : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncAvatarAssetsCounters counters = new SyncAvatarAssetsCounters();
            SyncAvatarAssetRequest req = new SyncAvatarAssetRequest();
            SyncAvatarAssetResponse resp = new SyncAvatarAssetResponse();
            uint hr = HResult.E_FAIL;
            string vi = VirtualInterface.xstatsfd;
            string[] locales;

            try
            {
                vi = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);
                bool isServerPort = (vi == VirtualInterface.xstatsfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyUserId(req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                Profile.SyncAvatarAssets(
                            req.UserId,
                            req.TitleId,
                            locales,
                            req.Version,
                            req.StartingIndex,
                            req.AvatarAssets,
                            isServerPort,
                            out resp.Version,
                            out resp.AvatarAssets,
                            out resp.AvatarAssetCount,
                            out resp.MoreAvatarAssetPending);

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUV|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.AvatarAssets != null)
                {
                    for (int i = 0; i < req.AvatarAssets.Length; i++)
                    {
                        if (req.AvatarAssets[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}({1:x})", req.AvatarAssets[i].AvatarAssetOrdinal, req.AvatarAssets[i].BodyTypeMask);

                        if (i != req.AvatarAssets.Length-1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.AvatarAssets != null)
                {
                    for (int i = 0; i < resp.AvatarAssets.Length; i++)
                    {
                        sb.AppendFormat("{0:x}({1:x})", resp.AvatarAssets[i].AvatarAssetOrdinal, resp.AvatarAssets[i].BodyTypeMask);

                        if (i != resp.AvatarAssets.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }

    public class SyncAvatarAssetsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            SyncAvatarAssetsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            SyncAvatarAssetsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         SyncAvatarAssetsCountersCategory.Current(titleId).FailuresPerSecond,
                                         SyncAvatarAssetsCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            SyncAvatarAssetsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SyncAvatarAssetsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                SyncAvatarAssetsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                SyncAvatarAssetsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }




    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: SyncAvatarAssets", "Stats FD: SyncAvatarAssets" )]
    public class SyncAvatarAssetsCountersCategory : XomPerformanceCounterCategory
    {

        static public SyncAvatarAssetsCountersCategory _instance = new SyncAvatarAssetsCountersCategory();
        static public SyncAvatarAssetsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(SyncAvatarAssetsCountersCategory)_instance.GetInstance(titleId);
        }


        // SyncAvatarAssets request counters

        [XomPerformanceCounterAttr(
                                 "SyncAvatarAssets requests/sec",
                                 "SyncAvatarAssets requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncAvatarAssets total",
                                 "Total SyncAvatarAssets requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "SyncAvatarAssets failures/sec",
                                 "Number of unsuccessful results returned by SyncAvatarAssets per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncAvatarAssets total failures",
                                 "Total number unsuccessful results returned by SyncAvatarAssets in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "SyncAvatarAssets avg. execution time",
                                 "SyncAvatarAssets Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlUsageQueryByAttributes.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Web;
using System.Diagnostics;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using xonline.common.diagnostics;
using xonline.common.user;

namespace xonline.server.stats.fd
{
    public class XRLUsageQueryByAttributes : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlUploadConsoleAuditList.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlUploadConsoleAuditList.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLUploadConsoleAuditList : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            UploadConsoleAuditListCounters counters = new UploadConsoleAuditListCounters();
            UploadConsoleListRequest req = new UploadConsoleListRequest();
            uint hr = HResult.E_FAIL;
            string vi = VirtualInterface.xstatsfd;

            try
            {
                vi = CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest();

                SGInfo.VerifyUserId(req.UserId);

                Profile.UploadConsoleAuditList(
                            req.UserId,
                            req.UploadingConsoleId,
                            req.SigningConsoleId,
                            req.ConsoleIdList);

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"CAL|{0:x}|{1:x}|{2:x}|{3:x}|",
                    hr,
                    req.UserId,
                    ConsoleIdData.GetDecimalValue(req.UploadingConsoleId.ConsoleId),
                    ConsoleIdData.GetDecimalValue(req.SigningConsoleId.ConsoleId));

                if (req.ConsoleIdList != null)
                {
                    for (int i = 0; i < req.ConsoleIdList.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", ConsoleIdData.GetDecimalValue(req.ConsoleIdList[i].ConsoleId));

                        if (i != req.ConsoleIdList.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }

    public class UploadConsoleAuditListCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        public void StartRequest()
        {
            StartRequestWorker();
        }

        private void StartRequestWorker()
        {
            UploadConsoleAuditListCountersCategory.Current().RequestsPerSecond.Increment();
            UploadConsoleAuditListCountersCategory.Current().RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         UploadConsoleAuditListCountersCategory.Current().FailuresPerSecond,
                                         UploadConsoleAuditListCountersCategory.Current().FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(failed);
        }

        private void EndRequestWorker(bool failed)
        {
            UploadConsoleAuditListCountersCategory.Current().AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            UploadConsoleAuditListCountersCategory.Current().AvgExecTimeBase.Increment();

            if (failed)
            {
                UploadConsoleAuditListCountersCategory.Current().FailuresPerSecond.Increment();
                UploadConsoleAuditListCountersCategory.Current().FailuresTotal.Increment();
            }
        }
    }




    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: UploadConsoleAuditList", "Stats FD: UploadConsoleAuditList" )]
    public class UploadConsoleAuditListCountersCategory : XomPerformanceCounterCategory
    {

        static public UploadConsoleAuditListCountersCategory _instance = new UploadConsoleAuditListCountersCategory();
        static public UploadConsoleAuditListCountersCategory Current()
        {
            return (UploadConsoleAuditListCountersCategory)_instance.GetInstance(XomPerformanceCounterCategory.DEFAULT_INSTANCE);
        }


        // UploadConsoleAuditList request counters

        [XomPerformanceCounterAttr(
                                 "UploadConsoleAuditList requests/sec",
                                 "UploadConsoleAuditList requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "UploadConsoleAuditList total",
                                 "Total UploadConsoleAuditList requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "UploadConsoleAuditList failures/sec",
                                 "Number of unsuccessful results returned by UploadConsoleAuditList per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "UploadConsoleAuditList total failures",
                                 "Total number unsuccessful results returned by UploadConsoleAuditList in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "UploadConsoleAuditList avg. execution time",
                                 "UploadConsoleAuditList Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlUsageStore.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Web;
using System.Diagnostics;
using System.Xml;               // For XmlTextReader
using System.Xml.Schema;        // For ValidationEventArgs
using System.Globalization;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using xonline.common.diagnostics;
using xonline.common.user;

[assembly: XomAreaDefinition(XomAreaName.Reporting)]

namespace xonline.server.stats.fd
{
    public class XRLUsageStore : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            UsageStoreRequest req = new UsageStoreRequest();
            UsageStoreResponse resp = new UsageStoreResponse();
            resp.hr = HResult.E_FAIL;
            ArrayList alDatabaseRows = new ArrayList();

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int);

                req.ReadFromRequest(ctx.Request);

                Validate(req.XML);

                // Create the XmlReader object.
                XmlReader reader = XmlReader.Create(new StringReader(req.XML));

                // Parse the file. 
                reader.MoveToContent();

                // find User tags.
                while (reader.Read())
                {
                    if ((reader.NodeType != XmlNodeType.Element) ||
                        (!reader.Name.Equals("User", StringComparison.OrdinalIgnoreCase)))
                    {
                        // dont puke on header or footer tags.
                        continue;
                    }

                    // get the userid.
                    ulong userid = UInt64.Parse(reader.GetAttribute("Id"), NumberStyles.HexNumber);

                    // find Media tags
                    while (reader.Read())
                    {
                        if (reader.NodeType == XmlNodeType.EndElement)
                        {
                            break;
                        }
                        
                        if ((reader.NodeType != XmlNodeType.Element) ||
                            (!reader.Name.Equals("Media", StringComparison.OrdinalIgnoreCase)))
                        {
                            continue;
                        }
                        
                        // get the mediaid
                        Guid mediaid = new Guid(reader.GetAttribute("Id"));
                        int mediatype = 0;
                        string adid = null;
                        string providerid = null;
                        try
                        {
                            // try to get a media type.
                            mediatype = Int32.Parse(reader.GetAttribute("Type"));
                        }
                        catch (Exception) {}
                        try
                        {
                            // try to get an ad id.
                            adid = reader.GetAttribute("AdId");
                        }
                        catch (Exception) {}
                        try
                        {
                            // try to get a provider id.
                            providerid = reader.GetAttribute("ProviderId");
                        }
                        catch (Exception) {}

                        // find attribute tags
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.EndElement)
                            {
                                break;
                            }
                            if ((reader.NodeType != XmlNodeType.Element) ||
                                (!reader.Name.Equals("Attribute", StringComparison.OrdinalIgnoreCase)))
                            {
                                continue;
                            }

                            // get the attributeid
                            ushort attributeid = UInt16.Parse(reader.GetAttribute("Id"));
                            ushort source =  0;
                            DateTime date = DateTime.UtcNow;
                            string binaryValue = null;
                            int intValue = 0;
                            try
                            {
                                // try to get a date.
                                date = DateTime.Parse(reader.GetAttribute("Date"));
                            }
                            catch (Exception) {}

                            try
                            {
                                // try to get a source.
                                source = UInt16.Parse(reader.GetAttribute("Source"));
                            }
                            catch (Exception) {}
                            
                            // get the value.
                            if (UsageDefs.IsIntegerValueAttribute(attributeid))
                            {
                                intValue = Int32.Parse(reader.GetAttribute("Value"));
                            }
                            else
                            {
                                binaryValue = reader.GetAttribute("Value");
                            }

                            StringBuilder sb = new StringBuilder();
                            sb.AppendFormat("USAGE_STORE|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}",
                                userid.ToString("X"),
                                mediaid.ToString(),
                                (adid == null) ? "" : adid,
                                (providerid == null) ? "" : providerid,
                                attributeid.ToString(),
                                UsageDefs.IsIntegerValueAttribute(attributeid) ? intValue.ToString() : binaryValue,
                                date.ToString(),
                                source.ToString());

                            Xom.Log(XomAreaName.Reporting, sb.ToString());

                            UsageStoreRowData rowdata = new UsageStoreRowData();
                            rowdata.userid = (long)userid;
                            rowdata.mediaid = mediaid.ToString();
                            rowdata.mediatype = mediatype;
                            rowdata.attributeid = (int)attributeid;
                            rowdata.ivalue = intValue;
                            rowdata.bvalue = binaryValue;
                            rowdata.date = date.ToString();

                            alDatabaseRows.Add(rowdata);
                        }
                    }
                }

                using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(VirtualInterface.uodb), CmdType.WRITEONLY_COMMANDTYPE))
                {
                    while (alDatabaseRows.Count > 0)
                    {
                        UsageStoreRowData rowdata = (UsageStoreRowData)alDatabaseRows[0];
                        int hash = ws.CalcPartition(rowdata.userid);
                        string xml = rowdata.GetXML(hash);

                        alDatabaseRows.Remove(rowdata);

                        // find other rows on the same partition.
                        for (int iRow = 0; iRow < alDatabaseRows.Count; iRow++)
                        {
                            rowdata = (UsageStoreRowData)alDatabaseRows[iRow];
                            if (ws.GetPhysicalPartition(hash) == ws.GetPhysicalPartition(ws.CalcPartition(rowdata.userid)))
                            {
                                xml += rowdata.GetXML(ws.CalcPartition(rowdata.userid));
                                alDatabaseRows.Remove(rowdata);
                                iRow--;
                            }
                        }

                        // call stored proc
                        ws.ClearParameters();
                        ws.StoredProc = "p_usage_store_media_attribute_data";
                        ws.PhysicalPartition = ws.GetPhysicalPartition(hash);
                        ws.AddParameter("@xml_data", xml);

                        WstDataReader wsreader = ws.Execute();
                        wsreader.Close();
                    }
                }
                
                resp.hr = HResult.S_OK;
            }
            catch (XRLException xrle)
            {
                resp.hr = xrle.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"UST|{0:x}|{1:x}",
                                    resp.hr,
                                    req.XMLSize);

                Xom.Log(XomAreaName.statslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, resp.hr, resp);
        }
        
        private void Validate(string szXML)
        {
            string XSDPath = AppDomain.CurrentDomain.BaseDirectory;
            
            // Create the XmlSchemaSet class.
            XmlSchemaSet sc = new XmlSchemaSet();
            // Add the schema to the collection.
            sc.Add(null, XSDPath + _szXSDFile);

            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;

            settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallback);
            settings.Schemas = sc;

            // Create the XmlReader object.
            XmlReader reader = XmlReader.Create(new StringReader(szXML), settings);

            // Parse the file. 
            while (reader.Read()) ;

            if (null != _validationException)
            {
                throw _validationException;
            }
        }
        private void ValidationCallback(object sender, ValidationEventArgs args)
        {
            if (null == _validationException)
            {
                // Save the validation exception
                _validationException = args.Exception;
            }
        }   // ValidationCallback

        private struct UsageStoreRowData
        {
            public long userid;
            public string mediaid;
            public int attributeid;
            public int mediatype;
            public int ivalue;
            public string bvalue;
            public string date;

            public string GetXML(int hash)
            {
                // <a user="" media="" attribute="" intvalue="" binvalue="" hash=""/>
                return "<a user=\"" + userid.ToString() +
                    "\" media=\"" + mediaid.ToString() +
                    "\" attribute=\"" + attributeid.ToString() +
                    "\" mediatype=\"" + mediatype.ToString() +
                    "\" intvalue=\"" + ivalue.ToString() +
                    "\" binvalue=\"" + bvalue +
                    "\" hash=\"" + hash.ToString() +
                    "\" />";
            }
        }

        private string _szXSDFile = "UsageStore.xsd";
        private Exception _validationException = null;
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlSyncSettings.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;
using Microsoft.Xbox.Privacy.Client;
using System.Net;


namespace xonline.server.stats.fd
{
    public class XRLSyncSettings : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncSettingsCounters counters = new SyncSettingsCounters();
            SyncSettingsRequest req = new SyncSettingsRequest();
            SyncSettingsResponse resp = new SyncSettingsResponse();
            uint hr = HResult.E_FAIL;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                SGInfo.VerifyUserId(req.UserId);

                uint titleId = req.TitleId;
                if (titleId == XOn.WEB_TITLE_ID)
                {
                    // web should really be treated like the dash when writing..
                    titleId = XOn.XENON_DASH_TITLE_ID;
                }

                Profile.SyncSettings(req.UserId, titleId, req.Version, req.StartinIndex, req.Settings, out resp.Version, out resp.Settings, out resp.TotalSettings);

                // Update the privacy settings for the privacy service

                UserSetting setting = req.Settings.FirstOrDefault(x => x.SettingId == ProfileDefs.XPROFILE_PERMISSIONS);

                if (setting != null)
                {
                    IVirtualInterfaceInfo vInt = Config.GetVirtualInterface("privacy_int");
                    IPEndPoint endpoint = new IPEndPoint(vInt.IPAddress, vInt.Port);

                    uint settingValue;

                    if (setting.Value.Length == 1)
                    {
                        settingValue = (uint)setting.Value[0];
                    }
                    else
                    {
                        settingValue = BitConverter.ToUInt32(setting.Value, 0);
                    }

                    new PrivacyClientInternal(endpoint).SetProfilePrivacy(req.UserId, settingValue);
                }

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUS|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Settings != null)
                {
                    for (int i = 0; i < req.Settings.Length; i++)
                    {
                        if (req.Settings[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Settings[i].SettingId);

                        if (i != req.Settings.Length-1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Settings != null)
                {
                    for (int i = 0; i < resp.Settings.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Settings[i].SettingId);

                        if (i != resp.Settings.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }

    public class SyncSettingsCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);
            
            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            SyncSettingsCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            SyncSettingsCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         SyncSettingsCountersCategory.Current(titleId).FailuresPerSecond,
                                         SyncSettingsCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            SyncSettingsCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SyncSettingsCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                SyncSettingsCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                SyncSettingsCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: SyncSettings", "Stats FD: SyncSettings" )]
    public class SyncSettingsCountersCategory : XomPerformanceCounterCategory
    {

        static public SyncSettingsCountersCategory _instance = new SyncSettingsCountersCategory();
        static public SyncSettingsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(SyncSettingsCountersCategory)_instance.GetInstance(titleId);
        }


        // SyncSetting request counters

        [XomPerformanceCounterAttr(
                                  "SyncSetting requests/sec",
                                  "SyncSetting requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                  "SyncSetting total",
                                  "Total SyncSetting requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                  "SyncSetting failures/sec",
                                  "Number of unsuccessful results returned by SyncSetting per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                  "SyncSetting total failures",
                                  "Total number unsuccessful results returned by SyncSetting in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                  "SyncSetting avg. execution time",
                                  "SyncSetting Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlSyncTitles.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncTitles.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLSyncTitles : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncTitlesCounters counters = new SyncTitlesCounters();
            SyncTitlesRequest req = new SyncTitlesRequest();
            SyncTitlesResponse resp = new SyncTitlesResponse();
            uint hr = HResult.E_FAIL;
            string[] locales;

            try
            {
                counters.StartRequest();

                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    // convert localeid to the string representation
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                hr = Profile.SyncTitles(req.UserId, locales, req.Version, req.StartingIndex, req.Titles, out resp.Version, out resp.Titles, out resp.TotalTitles);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUT|{0:x}|{1:x}|{2}|{3}|",
                    hr,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Titles != null)
                {
                    for (int i = 0; i < req.Titles.Length; i++)
                    {
                        if (req.Titles[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Titles[i].TitleId);

                        if (i != req.Titles.Length-1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Titles != null)
                {
                    for (int i = 0; i < resp.Titles.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Titles[i].TitleId);

                        if (i != resp.Titles.Length-1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }


    public class SyncTitlesCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        public void StartRequest()
        {
            StartRequestWorker(null);
        }

        private void StartRequestWorker(string titleId)
        {
            SyncTitlesCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            SyncTitlesCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         SyncTitlesCountersCategory.Current(titleId).FailuresPerSecond,
                                         SyncTitlesCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            SyncTitlesCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SyncTitlesCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                SyncTitlesCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                SyncTitlesCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }



    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: SyncTitles", "Stats FD: SyncTitles" )]
    public class SyncTitlesCountersCategory : XomPerformanceCounterCategory
    {

        static public SyncTitlesCountersCategory _instance = new SyncTitlesCountersCategory();
        static public SyncTitlesCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(SyncTitlesCountersCategory)_instance.GetInstance(titleId);
        }


        // SyncTitles request counters

        [XomPerformanceCounterAttr(
                                 "SyncTitles requests/sec",
                                 "SyncTitles requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncTitles total",
                                 "Total SyncTitles requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "SyncTitles failures/sec",
                                 "Number of unsuccessful results returned by SyncTitles per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "SyncTitles total failures",
                                 "Total number unsuccessful results returned by SyncTitles in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "SyncTitles avg. execution time",
                                 "SyncTitles Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlTitleClear.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlTitleClear.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.server.stats.fd
{
    public class XRLTitleClear : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.XONLINE_E_STAT_ERROR;

            TitleClearCounters counters = new TitleClearCounters();
            TitleClearRequest req = new TitleClearRequest();

            WSClient ws;

            try
            {
                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                counters.StartRequest(req.TitleId);

                // SGInfo.VerifyTitleId is intentionally omitted so any system app
                // can clear any title.

                SGInfo.VerifyUserId(req.UserId);

                using (ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "p_stats_clear_title";
                    ws.Partition = ws.CalcPartition(req.UserId);

                    ws.AddParameter("@bi_user_id", req.UserId);
                    ws.AddParameter("@i_title_id", req.TitleId);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                // make a list of stuff to remove from cache.
                ArrayList alCacheRemoves = new ArrayList();
                
                alCacheRemoves.Add(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLES_PLAYED, XOn.XENON_DASH_TITLE_ID, req.UserId));
                alCacheRemoves.Add(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_CRED, XOn.XENON_DASH_TITLE_ID, req.UserId));
                alCacheRemoves.Add(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED, XOn.XENON_DASH_TITLE_ID, req.UserId));
                
                Hashtable allSettings = SettingIds.AllItems;
                
                foreach (SettingInfo sinfo in allSettings.Values)
                {
                    if (sinfo.IsTitleWritable())
                    {
                        alCacheRemoves.Add(ProfileDefs.BuildCacheKey(sinfo.Id, req.TitleId, req.UserId));
                    }
                }

                byte[][] keys = (byte[][])alCacheRemoves.ToArray(typeof(byte[]));
                
                Profile.Cache.Remove(keys);

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat("CLT|{0:x}|{1:x}|{2:x}",
                    hr,
                    req.TitleId,
                    req.UserId);

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr);
        }

        public bool IsReusable
        {
            get { return true; }
        }
    }


    public class TitleClearCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        string hexTitleId;

        public void StartRequest(uint titleId)
        {
            hexTitleId = null;

            StartRequestWorker(null);

            if (Config.GetBoolSetting(Setting.stats_enableTitlePerfCounters))
            {
                hexTitleId = titleId.ToString("x8");

                StartRequestWorker(hexTitleId);
            }
        }

        private void StartRequestWorker(string titleId)
        {
            TitleClearCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            TitleClearCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         TitleClearCountersCategory.Current(titleId).FailuresPerSecond,
                                         TitleClearCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);

            if (null != hexTitleId)
                EndRequestWorker(hexTitleId, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            TitleClearCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            TitleClearCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                TitleClearCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                TitleClearCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }


    [XomPerformanceCounterCategoryAttr( "Stats (Profile) FD: ClearTitle", "Stats FD: ClearTitle" )]
    public class TitleClearCountersCategory : XomPerformanceCounterCategory
    {
        static public TitleClearCountersCategory _instance = new TitleClearCountersCategory();
        static public TitleClearCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(TitleClearCountersCategory)_instance.GetInstance(titleId);
        }


        // ClearTitle request counters

        [XomPerformanceCounterAttr(
                                 "ClearTitle requests/sec",
                                 "ClearTitle requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "ClearTitle total",
                                 "Total ClearTitle requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "ClearTitle failures/sec",
                                 "Number of unsuccessful results returned by ClearTitle per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "ClearTitle total failures",
                                 "Total number unsuccessful results returned by ClearTitle in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "ClearTitle avg. execution time",
                                 "ClearTitle Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlValidateAvatarManifest.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlValidateAvatarManifest.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;


using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.stats.fd
{
    public class XRLValidateAvatarManifest : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            ValidateAvatarManifestCounters counters = new ValidateAvatarManifestCounters();
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest();
            ValidateAvatarManifestResponse resp = new ValidateAvatarManifestResponse();
            uint hr = HResult.E_FAIL;

            try
            {
                counters.StartRequest();

                CallSource.Check(VirtualInterface.xstatsfd, VirtualInterface.xstatsfd_int, VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                resp.ValidationResult = (byte)(Avatar.ValidateAvatarManifest(req.UserId, req.AvatarManifest, req.ValidationFlags) ? 1 : 0);

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"VAM|{0:x}|{1:x}|{2:x}|{3}",
                    hr,
                    req.UserId,
                    req.ValidationFlags,
                    resp.ValidationResult);

                Xom.Log(XomAreaName.statslog, sb.ToString());

                counters.EndRequest(HResult.Failed(hr));
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }


    public class ValidateAvatarManifestCounters
    {
        private XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        public void StartRequest()
        {
            StartRequestWorker(null);
        }

        private void StartRequestWorker(string titleId)
        {
            ValidateAvatarManifestCountersCategory.Current(titleId).RequestsPerSecond.Increment();
            ValidateAvatarManifestCountersCategory.Current(titleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                         ValidateAvatarManifestCountersCategory.Current(titleId).FailuresPerSecond,
                                         ValidateAvatarManifestCountersCategory.Current(titleId).FailuresTotal
                                         });
        }

        public void EndRequest(bool failed)
        {
            EndRequestWorker(null, failed);
        }

        private void EndRequestWorker(string titleId, bool failed)
        {
            ValidateAvatarManifestCountersCategory.Current(titleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            ValidateAvatarManifestCountersCategory.Current(titleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                ValidateAvatarManifestCountersCategory.Current(titleId).FailuresPerSecond.Increment();
                ValidateAvatarManifestCountersCategory.Current(titleId).FailuresTotal.Increment();
            }
        }
    }



    [XomPerformanceCounterCategoryAttr("Stats (Profile) FD: ValidateAvatarManifest", "Stats FD: ValidateAvatarManifest")]
    public class ValidateAvatarManifestCountersCategory : XomPerformanceCounterCategory
    {

        static public ValidateAvatarManifestCountersCategory _instance = new ValidateAvatarManifestCountersCategory();
        static public ValidateAvatarManifestCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(ValidateAvatarManifestCountersCategory)_instance.GetInstance(titleId);
        }


        // ValidateAvatarManifest request counters

        [XomPerformanceCounterAttr(
                                 "ValidateAvatarManifest requests/sec",
                                 "ValidateAvatarManifest requests per second",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
                                 "ValidateAvatarManifest total",
                                 "Total ValidateAvatarManifest requests recorded in the the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
                                 "ValidateAvatarManifest failures/sec",
                                 "Number of unsuccessful results returned by ValidateAvatarManifest per second in the current AppDomain.",
                                  PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
                                 "ValidateAvatarManifest total failures",
                                 "Total number unsuccessful results returned by ValidateAvatarManifest in the current AppDomain.",
                                  PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
                                 "ValidateAvatarManifest avg. execution time",
                                 "ValidateAvatarManifest Total requests failed",
                                  PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;

        [XomPerformanceCounterAttr(
                                  "Avg waiting time base",
                                  "Avg waiting time base",
                                  PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\buffer.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * buffer.cpp
 * Implementation of leaderboard server buffer manager
 * Header: buffer.h
 * 
 */
                   
#include "lbs.h"

/*****************************************************************************
  CBufferManager
*****************************************************************************/

// Constructor
CBufferManager::CBufferManager() 
{
    _pConfig                  = NULL;
    _dwBufferManagerPageSize  = 0;
    _ullMaximumPhysicalMemory = 0LL;
    _dwMaxAllocations         = 0;
    _dwPhysicalMemoryPageSize = 0;
    _dwVirtualAllocSize       = 0;
    _dwLastPageId             = 0;
    _pageTable                = NULL;
    _prgPriQueues             = NULL;
    _pCtrl                    = NULL;
    _dwAccessCounter          = 0;
    _hPagingThread            = NULL;
    _hPagingThreadWakeUp      = NULL;
    _fPagingThreadShutdown    = FALSE;
    _hPagingFile              = NULL;
    _uiPageCount              = 0;
    _uiPageInDiskCount        = 0;
    _pPerfCounters            = NULL;
}

CBufferManager::~CBufferManager() 
{
    DBGASSERT(NULL == _pageTable);
    DBGASSERT(NULL == _prgPriQueues);
    DBGASSERT(NULL == _pCtrl);
    DBGASSERT(NULL == _hPagingThread);
    DBGASSERT(NULL == _hPagingThreadWakeUp);
    DBGASSERT(NULL == _hPagingFile);
}

bool CBufferManager::Init(
    CConfig* pConfig, 
    UMS* pUMS,
    CPerfCounters* pPerfCounters
)
{
    DBGASSERT(_pConfig == NULL); 
    
    bool fRet = false;
    SYSTEM_INFO sSysInfo;
    MEMORYSTATUSEX  sMemoryStatus;
    
    _pConfig                 = pConfig;
    _pUMS                    = pUMS;
    _dwBufferManagerPageSize = _pConfig->GetBufferManagerPageSize();
    _pPerfCounters           = pPerfCounters;
    
    // Find out how much physical memory the system has
    sMemoryStatus.dwLength = sizeof(sMemoryStatus);
    if(!GlobalMemoryStatusEx(&sMemoryStatus))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "GlobalMemoryStatusEx failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    // Establish the maximum amount of memory we are allowed to allocate.
    // Use the lesser of the two: the total amount of memory in the machine
    // minus a constant or the configured amount.
    _ullMaximumPhysicalMemory = __min(
        sMemoryStatus.ullTotalPhys - _pConfig->GetReservedPhysicalMemory(),
        _pConfig->GetMaximumPhysicalMemory() - _pConfig->GetReservedPhysicalMemory()); //use min(system max, configured max)
    
    // Use GetSystemInfo to find out the size of memory pages 
    GetSystemInfo(&sSysInfo);
    _dwPhysicalMemoryPageSize = sSysInfo.dwPageSize;
    
    // Make sure we allocate multiples of _dwPhysicalMemoryPageSize from VirtualAlloc
    _dwVirtualAllocSize = (_pConfig->GetVirtualAllocSize() / 
        _dwPhysicalMemoryPageSize) * _dwPhysicalMemoryPageSize;

    _dwMaxAllocations = (DWORD) (_ullMaximumPhysicalMemory / _dwVirtualAllocSize);

    _dwLastPageId = 0;
        
    // Create paging file
    _hPagingFile = ::CreateFileW(_pConfig->GetFullNamePagingFile()->cstr(),
        GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, NULL);
        
    if(INVALID_HANDLE_VALUE == _hPagingFile)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateFileW failed. Filename = %s. Error = %u", 
            _pConfig->GetFullNamePagingFile()->cstr(), ::GetLastError());
        goto lDone;
    }
    
    // Grow file to initial size
    LARGE_INTEGER liSize;
    liSize.QuadPart = (LONGLONG) _pConfig->GetPagingFileInitialSize();
    
    ::SetLastError(NO_ERROR);
    ::SetFilePointer(_hPagingFile, liSize.LowPart, &liSize.HighPart, FILE_BEGIN);
    if(GetLastError() != NO_ERROR)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "SetFilePointer failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    if(!::SetEndOfFile(_hPagingFile))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "SetEndOfFile failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    // Initialize memory pool based data structures
    if(!_allocList.Init("_allocList", BM_INITIAL_ALLOC_LIST_SIZE, true, &g_MemAlloc))
        goto lDone;
    
    if(!_poolPageInfoEntry.Init("_poolPageInfoEntry", sizeof(PAGE_INFO_ENTRY), 
        BM_INITIAL_PAGE_INFO_ENTRY_POOL_SIZE, true, &g_MemAlloc))
    {
        goto lDone;
    }
    
    // Allocate page table
    _pageTable = new PAGE_INFO_SLOT[BM_SIZE_PAGE_TABLE];
    if(NULL == _pageTable)
        goto lDone;
    
    // Allocate priority queues
    _prgPriQueues = new PagePriorityQueue[BM_NUMBER_OF_PRIORITY_QUEUES];
    if(NULL == _prgPriQueues)
        goto lDone;
        
    if(!_pageRequests.Init("_pagesRequests", 100, true, &g_MemAlloc))
        goto lDone;
    
    // Initialize free file slots list
    if(!_freeSlots.Grow(BM_INITIAL_FREE_SLOT_LIST_SIZE))
        goto lDone;
    
    // Create UMS client for paging thread
    if(!_pUMS->CreateUmsClient(&_pCtrl))
        goto lDone;
    
    // Create event to control thread
    _hPagingThreadWakeUp = ::CreateEventW(NULL, TRUE, FALSE, NULL);
    if(NULL == _hPagingThreadWakeUp)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateEventW failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    // Create thread
    DWORD dwThreadId;
    _fPagingThreadShutdown = FALSE;
    _hPagingThread = ::CreateThread(NULL, 0, StaticThreadProc, this,
        0, &dwThreadId);
    
    if(NULL == _hPagingThreadWakeUp)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Create thread failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    fRet = true;
     
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

void CBufferManager::Term()
{
    if(_hPagingThread != NULL)
    {
        do
        {
            ::InterlockedExchange(&_fPagingThreadShutdown, TRUE);
            ::SetEvent(_hPagingThreadWakeUp);
        } 
        while(::WaitForSingleObject(_hPagingThread, 100) == WAIT_TIMEOUT);
    
        ::CloseHandle(_hPagingThread);
        _hPagingThread = NULL;
    }
    
    if(_hPagingThreadWakeUp != NULL)
    {
        ::CloseHandle(_hPagingThreadWakeUp);
        _hPagingThreadWakeUp = NULL;
    }

    _freePageBufferList.Reset();
    
    if(_pageTable != NULL)
    {
        for(DWORD i=0; i < BM_SIZE_PAGE_TABLE; i++)
        {
            PAGE_INFO_ENTRY* pPageInfo = _pageTable[i].pNext;
            
            while(pPageInfo != NULL)
            {
                PAGE_INFO_ENTRY* pNext = pPageInfo->pNext;
                pPageInfo->~PAGE_INFO_ENTRY();
                _poolPageInfoEntry.Free(pPageInfo);
                pPageInfo = pNext;
            }
        }
        
        delete [] _pageTable;
        _pageTable = NULL;
    }
    
    _poolPageInfoEntry.Term();
    
    // Release all VirtualAlloc allocations. 
    BYTE* pAlloc;
    while((pAlloc = _allocList.Pop()) != NULL)
    {
        BOOL fSucceeded = VirtualFree(pAlloc, 0, MEM_RELEASE);
        DBGASSERT(fSucceeded);
    }
    
    _allocList.Term();
    
    if(_prgPriQueues != NULL)
    {
        for(DWORD i=0; i < BM_NUMBER_OF_PRIORITY_QUEUES; i++)
        {
            _prgPriQueues[i].Term();
        }
        
        delete[] _prgPriQueues;
        _prgPriQueues = NULL;
    }
    
    _pageRequests.Term();
    
    _freeSlots.Term();
    
    if(_hPagingFile != NULL)
    {
        ::CloseHandle(_hPagingFile);
        _hPagingFile = NULL;
    }
    
    if(_pCtrl)
    {
        _pUMS->ReleaseUmsClient(_pCtrl);
        _pCtrl = NULL;
    }
}

bool CBufferManager::CreateNewPage(
    IN IUmsClient* pUmsClient,
    IN UMSLockCookie* pLockPageCookie,
    OUT BM_PAGE** ppPage
)
{
    bool fRet      = false;
    PAGE_INFO_ENTRY* pPageInfo = NULL;
    
    DBGASSERT(ppPage != NULL);
    
    // Allocate and fill out a new page info struct
    pPageInfo = new (_poolPageInfoEntry.Alloc(sizeof(PAGE_INFO_ENTRY))) PAGE_INFO_ENTRY;
    if(NULL == pPageInfo)
        goto lDone;
        
    ZeroMemory(pPageInfo, sizeof(PAGE_INFO_ENTRY));
    BM_PAGEID pageId = (BM_PAGEID) InterlockedIncrement((LONG*)&_dwLastPageId);
    pPageInfo->pageId = pageId;
    pPageInfo->inMemory.dwLastAccess = GetAccessCounter();
    pPageInfo->inMemory.dwPriQueueIndex = ~0;

    // Try to allocate a new buffer for this page. A new buffer might actually
    // be allocated or, hopefully, we can get one from the free list. One last
    // possibility is that we have run out of memory and we must use the buffer
    // of another less often used page
    pPageInfo->pPage = (BM_PAGE*) AllocPageBuffer();
    
    if(pPageInfo->pPage != NULL)
    {
        // Get the lock for the caller
        if(!AcquirePageLock(pUmsClient,pageId,LOCK_MODE_X, pLockPageCookie))
            goto lDone;

        pPageInfo->pPage->pageId = pPageInfo->pageId;
        
        // *** Begin critical section ***
        DWORD dwPriQueueSlot = pPageInfo->pageId % BM_NUMBER_OF_PRIORITY_QUEUES;
        _prgPriQueues[dwPriQueueSlot].lock.Lock();
        
        // Put PAGE_INFO struct in priority queue
        if(!_prgPriQueues[dwPriQueueSlot]._priqueue.Insert(pPageInfo))
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "_priqueue.Insert failed");
            _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            goto lDone;
        }
        
        // Put PAGE_INFO struct in the hashtable
        DWORD dwPageSlot = pPageInfo->pageId % BM_SIZE_PAGE_TABLE;
        pPageInfo->pNext = _pageTable[dwPageSlot].pNext;
        _pageTable[dwPageSlot].pNext = pPageInfo;
        
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        // *** End critical section ***
        
        *ppPage = pPageInfo->pPage;
    }
    else
    {
        // There is no more memory available. But we can still get the buffer
        // from a page that's not being used in the moment. So we're going to
        // create the page just like as if it was in disk (but not really) and
        // use GetPage to resolve this problem for us.

        pPageInfo->inDisk.dwFileSlotIndex = BmNewPageSlotIndex;
        
        // *** Begin critical section ***
        DWORD dwPriQueueSlot = pPageInfo->pageId % BM_NUMBER_OF_PRIORITY_QUEUES;
        _prgPriQueues[dwPriQueueSlot].lock.Lock();
        
        // Put PAGE_INFO struct in the hashtable
        DWORD dwPageSlot = pPageInfo->pageId % BM_SIZE_PAGE_TABLE;
        pPageInfo->pNext = _pageTable[dwPageSlot].pNext;
        _pageTable[dwPageSlot].pNext = pPageInfo;
        
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        // *** End critical section ***
        
        pPageInfo = NULL;
        
        if(!GetPage(pUmsClient, pageId, LOCK_MODE_X, ppPage, pLockPageCookie))
            goto lDone;
    }

    ::InterlockedIncrement((volatile LONG*)&_uiPageCount);
    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SetCurrentValue32(LBPERF_SERVER_TOTAL_PAGES_COUNTER, _uiPageCount);
    }
    
    pPageInfo = NULL;
    fRet      = true;
    
lDone:

    if(pPageInfo != NULL)
    {
        if(pPageInfo->pPage != NULL)
        {
            _freePageBufferList.Push(new ((void*)pPageInfo->pPage) PAGE_BUFFER);
        }
        
        pPageInfo->~PAGE_INFO_ENTRY();
        _poolPageInfoEntry.Free(pPageInfo);
    }

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p, %p)", pUmsClient, ppPage);
        
    return fRet;
}

bool CBufferManager::DeletePage(
    IN IUmsClient* pUmsClient,
    BM_PAGEID pageId
)
{
    bool fRet = false;
    bool fPageLock = false;
    UMSLockCookie lockCookie;
    BM_PAGE* pPage;
    
    // Use GetPage to get a hold of the page. GetPage will behave correctly
    // if the page is in disk
    if(!GetPage(pUmsClient,pageId,LOCK_MODE_X,&pPage,&lockCookie))
        goto lDone;
    
    fPageLock = true;

    // *** Begin critical section ***
    DWORD dwPriQueueSlot = pageId % BM_NUMBER_OF_PRIORITY_QUEUES;
    _prgPriQueues[dwPriQueueSlot].lock.Lock();
    
    // Find entry in hashtable
    DWORD dwSlot = pageId % BM_SIZE_PAGE_TABLE;
    PAGE_INFO_ENTRY* pPrevPageInfo = NULL;
    PAGE_INFO_ENTRY* pPageInfo     = _pageTable[dwSlot].pNext;
    while(pPageInfo != NULL && pPageInfo->pageId != pageId)
    {
        pPrevPageInfo = pPageInfo;
        pPageInfo     = pPageInfo->pNext;
    }
    
    if(pPageInfo == NULL)
    {
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Page does not exist!");
        DBGASSERT(!"Page does not exist!");
        goto lDone;
    }

    // Remove it from the hashtable
    if(pPrevPageInfo != NULL)
        pPrevPageInfo->pNext = pPageInfo->pNext;
    else
        _pageTable[dwSlot].pNext = pPageInfo->pNext;
    
    // Remove it from the priority queue
    if(pPageInfo->pPage != NULL)
    {
        PAGE_INFO_ENTRY* pRef = _prgPriQueues[dwPriQueueSlot]._priqueue.Remove(
            pPageInfo->inMemory.dwPriQueueIndex);
            
        if(pRef != pPageInfo)
        {
            _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "CRITICAL ERROR: pRef != pPageInfo");
            DBGASSERT(false);
            goto lDone;
        }
        
        pPageInfo->inMemory.dwPriQueueIndex = ~0;
    }
        
    _prgPriQueues[dwPriQueueSlot].lock.Unlock();
    // *** End critical section ***
    
    // Page is being deleted. Add the page's buffer to the free buffer list.
    _freePageBufferList.Push(new ((void*)pPageInfo->pPage) PAGE_BUFFER);
    
    // Release page info struct
    pPageInfo->~PAGE_INFO_ENTRY();
    _poolPageInfoEntry.Free(pPageInfo);
    
    ::InterlockedDecrement((volatile LONG*)&_uiPageCount);
    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SetCurrentValue32(LBPERF_SERVER_TOTAL_PAGES_COUNTER, _uiPageCount);
    }
    
    fRet = true;
    
lDone:

    if(fPageLock)
        pUmsClient->ReleaseLock(&lockCookie);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p, %u)", pUmsClient, pageId);
        
    return fRet;
}

bool CBufferManager::GetPage(
    IN IUmsClient* pUmsClient, 
    IN BM_PAGEID pageId,
    IN LOCK_MODE lm,
    OUT BM_PAGE** ppPage,
    OUT UMSLockCookie* pLockCookie
)
{
    bool fRet                  = false;
    bool fPageLock             = false;
    DWORD dwPriQueueSlot       = 0;
    DWORD dwSlot               = 0;
    PAGE_INFO_ENTRY* pPageInfo = NULL;
    
    for(;;)
    {
        if(!AcquirePageLock(pUmsClient,pageId,lm, pLockCookie))
            goto lDone;
            
        fPageLock = true;
        
        dwPriQueueSlot = pageId % BM_NUMBER_OF_PRIORITY_QUEUES;
        _prgPriQueues[dwPriQueueSlot].lock.Lock();
        
        // Find entry in hashtable
        dwSlot = pageId % BM_SIZE_PAGE_TABLE;
        
        pPageInfo = _pageTable[dwSlot].pNext;
        while(pPageInfo != NULL && pPageInfo->pageId != pageId)
        {
            pPageInfo = pPageInfo->pNext;
        }
            
        if(pPageInfo == NULL)
        {
            _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Page does not exist!");
            goto lDone;
        }
        
        if(pPageInfo->pPage == NULL)
        {
            // This page is in disk. Make sure it's in the list of pages to be
            // read from disk and try again.
            
            _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            
            pPageInfo = NULL;
         
            pUmsClient->ReleaseLock(pLockCookie);
            fPageLock = false;
            
            // RequestPageRead will grab a lock on the page. So, on the next
            // run, AcquirePageLock should block until the thread that reads
            // the data from disk wakes up again.
            
            if(!RequestPageRead(pageId))
                goto lDone;
        
            continue;
        }
        else
        {
            break;
        }
    } 
    
    DBGASSERT(pPageInfo->pPage->pageId == pageId);
    
    // Remove from priority queue
    PAGE_INFO_ENTRY* pRef = _prgPriQueues[dwPriQueueSlot]._priqueue.Remove(
        pPageInfo->inMemory.dwPriQueueIndex);
        
    if(pRef != pPageInfo)
    {
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CRITICAL ERROR: pRef != pPageInfo");
        DBGASSERT(false);
        goto lDone;
    }
    
    // Update access counter
    pPageInfo->inMemory.dwLastAccess = GetAccessCounter();
    
    // Put it back in
    if(!_prgPriQueues[dwPriQueueSlot]._priqueue.Insert(pPageInfo))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "_priqueue.Insert failed");
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        goto lDone;
    }
    
    *ppPage = pPageInfo->pPage;
    
    _prgPriQueues[dwPriQueueSlot].lock.Unlock();
    // *** End critical section ***
    
    // Lock now belongs to caller
    fPageLock = false;
    fRet      = true; 

lDone:

    if(fPageLock)
        pUmsClient->ReleaseLock(pLockCookie);

    return fRet;
}

BYTE* CBufferManager::AllocPageBuffer()
{
    bool fRet = false;
    BYTE* pBuffer = NULL;
    
    // First try to get a page from the free page list
    pBuffer = (BYTE*) _freePageBufferList.Pop();
    if(pBuffer == NULL)
    {
        if((DWORD)_allocList.GetCount() < _dwMaxAllocations)
        {
            // No cigar. We need to allocate more buffers. Use VirtualAlloc to 
            // allocate a big chunk of memory.
            BYTE* pVABuffer = (BYTE*) VirtualAlloc(NULL, _dwVirtualAllocSize, MEM_COMMIT, PAGE_READWRITE);
            
            if(NULL == pVABuffer)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "VirtualAlloc failed. Error=%d", 
                    GetLastError());
                goto lDone;
            }

            if (NULL != _pPerfCounters)
            {
                _pPerfCounters->SafeIncrement32(LBPERF_SERVER_TOTAL_PHYSICAL_PAGES_COUNTER);
            }
            
            // Remember this big buffer for when we terminate
            _allocList.Push(pVABuffer);
            
            // Break the big buffer into smaller ones (pages)
            DWORD dwPageCount = _dwVirtualAllocSize / _dwBufferManagerPageSize;
            
            // Store all pages but one into the free page list
			DWORD i;
            for(i=0; i < dwPageCount-1; i++)
            {
                pBuffer = pVABuffer + (i * _dwBufferManagerPageSize);
                _freePageBufferList.Push(new (pBuffer) PAGE_BUFFER);
            }
            
            // Return last buffer
            pBuffer = pVABuffer + (i * _dwBufferManagerPageSize);
        }
        else
        {
            goto lDone;
        }
    }
    
    fRet = true;
    
lDone:
        
    return pBuffer;
}

bool CBufferManager::AcquirePageLock(
    IUmsClient* pUmsClient,
    IN BM_PAGEID pageId,
    IN LOCK_MODE lm,
    UMSLockCookie* pCookie
)
{
        return pUmsClient->AcquireLock(GetLockIdForPageId(pageId), lm, pCookie);
}

bool CBufferManager::RequestPageRead(BM_PAGEID pageId)
{
    bool fRet = false;
    WaitingPage* pWaitingPage = NULL;
    bool fPageLock = false;
    
    // Allocate a new WaitingPage structure which we're going to queue
    pWaitingPage = new WaitingPage();
    if(NULL == pWaitingPage)
        goto lDone;

    pWaitingPage->pageid = pageId;
    
    // Get an exclusive lock on the page. This lock not only will prevent other 
    // threads from accessing the page but it will also be used to awake those
    // threads once the page has been read
    bool fLockAcquired = false;

    //_lockCtrl is a Spin lock - don't hold on to it too long
    while (!fLockAcquired)
    {
        _lockCtrl.Lock();

        fLockAcquired = _pCtrl->TryAcquireLock(GetLockIdForPageId(pageId),LOCK_MODE_X, &pWaitingPage->pageLock);
            
        _lockCtrl.Unlock();
    }
    
    fPageLock = true;
   
    // Put this page in the queue
    if(!_pageRequests.Enqueue(pWaitingPage))
        goto lDone;

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SafeIncrement32(LBPERF_SERVER_TOTAL_PAGE_REQUESTS_IN_QUEUE);
    }
    
    pWaitingPage = NULL;

    // Make sure thread is aware
    ::SetEvent(_hPagingThreadWakeUp);
    
    fRet = true;
        
lDone:
    
    if(pWaitingPage != NULL)
    {
        if(fPageLock)
        {
            _lockCtrl.Lock();
            _pCtrl->ReleaseLock(&pWaitingPage->pageLock);
            _lockCtrl.Unlock();
        }
    
        delete pWaitingPage;
        pWaitingPage = NULL;
    }
    
    return fRet;
}

// Wrapper for ThreadProc. Just basic initialization and call ThreadProc
DWORD CBufferManager::StaticThreadProc(LPVOID pRawThis)
{
    CGlobalError::Init();
    reinterpret_cast<CBufferManager*>(pRawThis)->ThreadProc();
    CGlobalError::Term();
    return 0;
}

// This is the Paging thread procedure. 
void CBufferManager::ThreadProc()
{
    DWORD dwQueue = 0;
    UMSLockCookie pagelock;
    for(;;)
    {
        if(_pageRequests.GetCount() == 0)
        {
            ::ResetEvent(_hPagingThreadWakeUp);
            
            if(_pageRequests.GetCount() == 0)
            {
                // Sleep until we have stuff to do
                ::WaitForSingleObject(_hPagingThreadWakeUp, INFINITE);
                
                if(_fPagingThreadShutdown)
                    break;

                continue;
            }
        }
        
        // Distribute free buffers
        DistributeBuffers();
        
        // Find a non-empty queue
        dwQueue = (dwQueue + 1) % BM_NUMBER_OF_PRIORITY_QUEUES;
        
		int iTry;
        for(iTry=0; 
            iTry < BM_NUMBER_OF_PRIORITY_QUEUES && 
                _prgPriQueues[dwQueue]._priqueue.GetCount() == 0; 
            iTry++)
        {
            dwQueue = (dwQueue + 1) % BM_NUMBER_OF_PRIORITY_QUEUES;
        }
        
        if(iTry == BM_NUMBER_OF_PRIORITY_QUEUES)
        {
            // Nothing else is available
            continue;
        }
        
        _prgPriQueues[dwQueue].lock.Lock();
  
        if(_prgPriQueues[dwQueue]._priqueue.GetCount() == 0)
        {
            // Looks like this changed since before the lock. This is a rare 
            // case but it will happen, specially during shutdown
            
            _prgPriQueues[dwQueue].lock.Unlock();
            continue;
        }

        PAGE_INFO_ENTRY* pPageInfo = 
            _prgPriQueues[dwQueue]._priqueue.Remove(0);
            



        _lockCtrl.Lock();
        bool fRes = _pCtrl->TryAcquireLock(GetLockIdForPageId(pPageInfo->pageId), 
            LOCK_MODE_X, &pagelock);
        _lockCtrl.Unlock();
        
        if(!fRes)
        {
            // No cigar. Bad timing I guess or maybe this is a page that
            // has been acquired by somebody for a long time. Put it back
            // in the queue but update its access counter.
            pPageInfo->inMemory.dwLastAccess = GetAccessCounter();

            if(!_prgPriQueues[dwQueue]._priqueue.Insert(pPageInfo))
            {
                XomNtEvent(XEVENT_STATS_CODE_26, 
                    "CRITICAL ERROR: _priqueue.Insert failed. \n%s",
                    CGlobalError::GetCurrentMessage());
                DBGASSERT(false);
            }
            
            _prgPriQueues[dwQueue].lock.Unlock();

            continue;
        }

        _prgPriQueues[dwQueue].lock.Unlock();
        
        DumpPage(pPageInfo->pageId);
        _lockCtrl.Lock();
        _pCtrl->ReleaseLock(&pagelock);
        _lockCtrl.Unlock();
    }

}

void CBufferManager::DistributeBuffers()
{
    bool fRet = false;
    BYTE* pPageBuffer = NULL;
    WaitingPage* pWaiting = NULL;
    
    for(;;)
    {
        pPageBuffer = AllocPageBuffer();
        if(NULL == pPageBuffer)
            break; // We ran out of buffers
    
        pWaiting = (WaitingPage*) _pageRequests.Dequeue();
        if(NULL == pWaiting)
            break; // We ran out of waiters

        if (NULL != _pPerfCounters)
        {
            _pPerfCounters->SafeDecrement32(LBPERF_SERVER_TOTAL_PAGE_REQUESTS_IN_QUEUE);
        }
        
        // Lock
        DWORD dwPriQueueSlot = pWaiting->pageid % BM_NUMBER_OF_PRIORITY_QUEUES;
        _prgPriQueues[dwPriQueueSlot].lock.Lock();
        
        // Get page info struct
        DWORD dwSlot = pWaiting->pageid % BM_SIZE_PAGE_TABLE;
        
        PAGE_INFO_ENTRY* pPageInfo = _pageTable[dwSlot].pNext;
        while(pPageInfo != NULL && pPageInfo->pageId != pWaiting->pageid)
        {
            pPageInfo = pPageInfo->pNext;
        }
        
        // it's OK to leave the critical section now. We hold an exclusive lock
        // to the page in pWaiting.
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            
        if(pPageInfo == NULL)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Page does not exist!");
            DBGASSERT(false);
            goto lDone;
        }
        
        if(pPageInfo->pPage != NULL)
        {
            //this page is already in memory - do nothing
            fRet = true;
            goto lDone;
        }
        
        pPageInfo->pPage = (BM_PAGE*) pPageBuffer;

        if(pPageInfo->inDisk.dwFileSlotIndex != BmNewPageSlotIndex)
        {
            // Read page from disk
            if(!ReadPageFromDisk(pPageInfo->inDisk.dwFileSlotIndex, pPageBuffer))
                goto lDone;
                
            if(pPageInfo->pPage->pageId != pPageInfo->pageId)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
                    "pPageInfo->pPage->pageId != pPageInfo->pageId");
                DBGASSERT(false);
                goto lDone;
            }
            
            // Slot in disk is now available
            _freeSlots.Add(pPageInfo->inDisk.dwFileSlotIndex);
            
            pPageBuffer = NULL;
        }
        else
        {
            pPageInfo->pPage->pageId = pPageInfo->pageId;
        }
        
        // Put the buffer back to the priority queue
        pPageInfo->inMemory.dwLastAccess = GetAccessCounter();
        
        _prgPriQueues[dwPriQueueSlot].lock.Lock();
        
        if(!_prgPriQueues[dwPriQueueSlot]._priqueue.Insert(pPageInfo))
        {
            _prgPriQueues[dwPriQueueSlot].lock.Unlock();
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "_priqueue.Insert failed");
            DBGASSERT(false);
            goto lDone;
        }
        
        _prgPriQueues[dwPriQueueSlot].lock.Unlock();
        
        // Release lock to the buffer. This will unblock whatever thread was 
        // waiting for it.

        _lockCtrl.Lock();   
        _pCtrl->ReleaseLock(&pWaiting->pageLock);
        _lockCtrl.Unlock();
        
        delete pWaiting;
        pWaiting = NULL;
    }
    
    fRet = true;

lDone:

    if(pPageBuffer)
    {
        _freePageBufferList.Push(new ((void*)pPageBuffer) PAGE_BUFFER);
    }
    
    if(pWaiting != NULL)
    {
        _lockCtrl.Lock();
        _pCtrl->ReleaseLock(&pWaiting->pageLock);
        _lockCtrl.Unlock();
        delete pWaiting;
    }
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        XomNtEvent(XEVENT_STATS_CODE_27, 
            "CRITICAL ERROR: DistributeBuffers failed.\n%s",
            CGlobalError::GetCurrentMessage());
    }
    
    return;
}

void CBufferManager::DumpPage(
    BM_PAGEID pageId
)
{
    bool fRet = false;
    DWORD dwFileSlot = 0;
    
    // Get the page struct
    DWORD dwPriQueueSlot = pageId % BM_NUMBER_OF_PRIORITY_QUEUES;
    _prgPriQueues[dwPriQueueSlot].lock.Lock();
    
    // Find entry in hashtable
    DWORD dwSlot = pageId % BM_SIZE_PAGE_TABLE;
    
    PAGE_INFO_ENTRY* pPageInfo = _pageTable[dwSlot].pNext;
    while(pPageInfo != NULL && pPageInfo->pageId != pageId)
    {
        pPageInfo = pPageInfo->pNext;
    }
    
    // it's OK to leave the critical section now. We hold an exclusive lock
    // on the page with the caller
    _prgPriQueues[dwPriQueueSlot].lock.Unlock();
    
    if(pPageInfo == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Page does not exist!");
        DBGASSERT(false);
        goto lDone;
    }
    
    if(pPageInfo->pPage == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "pPageInfo->pPage");
        DBGASSERT(false);
        goto lDone;
    }
    
    // Get a slot
    if(_freeSlots.GetSize() > 0)
    {
        // Get an 'used' slot
        dwFileSlot = _freeSlots.Get(_freeSlots.GetSize()-1);
        _freeSlots.SetSize(_freeSlots.GetSize()-1);
    }
    else
    {
        // Get a 'new' slot
        dwFileSlot = _dwPagingFileTotalSlots++;
    }
    
    // Calculate position on the file
    LARGE_INTEGER liPos;
    liPos.QuadPart = ((LONGLONG)dwFileSlot) * _dwBufferManagerPageSize;
    
    ::SetLastError(NO_ERROR);
    ::SetFilePointer(_hPagingFile, liPos.LowPart, &liPos.HighPart, FILE_BEGIN);
    if(::GetLastError() != NO_ERROR)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "SetFilePointer failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    // Write
    DWORD dwWritten;
    if(!::WriteFile(_hPagingFile, pPageInfo->pPage, _dwBufferManagerPageSize,
        &dwWritten, NULL))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "WriteFile failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    if(dwWritten != _dwBufferManagerPageSize)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "WriteFile wrote less bytes than requested", ::GetLastError());
        goto lDone;
        
    }
    
    // Page has been dumped. The buffer can now be reused
    if(!_freePageBufferList.Push(new ((void*)pPageInfo->pPage) PAGE_BUFFER))
        goto lDone;
    
    // Make it official
    pPageInfo->pPage = NULL;
    pPageInfo->inDisk.dwFileSlotIndex = dwFileSlot;
    
    ::InterlockedIncrement((volatile LONG*)&_uiPageInDiskCount);

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue32(LBPERF_SERVER_PAGE_IO_RATE, 1);
    }

    fRet = true;

lDone:    

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        XomNtEvent(XEVENT_STATS_CODE_28, 
            "CRITICAL ERROR: DumpPage failed.\n%s",
            CGlobalError::GetCurrentMessage());
    }
}

bool CBufferManager::ReadPageFromDisk(
    DWORD dwFileSlot, 
    BYTE* pPageBuffer
)
{
    bool fRet = false;
    
    // Calculate position in the file
    LARGE_INTEGER liPos;
    liPos.QuadPart = ((LONGLONG)dwFileSlot) * _dwBufferManagerPageSize;
    
    ::SetLastError(NO_ERROR);
    ::SetFilePointer(_hPagingFile, liPos.LowPart, &liPos.HighPart, FILE_BEGIN);
    if(::GetLastError() != NO_ERROR)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "SetFilePointer failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    // Read
    DWORD dwRead;
    if(!::ReadFile(_hPagingFile, pPageBuffer, _dwBufferManagerPageSize, 
        &dwRead, NULL))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ReadFile failed. Error = %u", ::GetLastError());
        goto lDone;
    }
    
    ::InterlockedDecrement((volatile LONG*)&_uiPageInDiskCount);

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue32(LBPERF_SERVER_PAGE_IO_RATE, 1);
    }
    
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Dump (to trace callback) stats about the buffer manager
bool CBufferManager::DumpStats(
    ITraceCallback* pOut
)
{
    pOut->Write(
        "\n***"
        "\n*** Buffer Manager Stats"
        "\n***\n");

    #define BMDSF(field, fmt) \
        TraceCallbackFormattedWrite(pOut, "\n%-30s = " fmt, #field, field);
        
    BMDSF(_dwBufferManagerPageSize        , "%u"    );
    BMDSF(_ullMaximumPhysicalMemory       , "%I64u" );
    BMDSF(_dwMaxAllocations               , "%u"    );
    BMDSF(_dwMaxPages                     , "%u"    );
    BMDSF(_dwPhysicalMemoryPageSize       , "%u"    );
    BMDSF(_dwVirtualAllocSize             , "%u"    );
    BMDSF(_dwLastPageId                   , "%u"    );
    BMDSF(_allocList.GetCount()           , "%u"    );
    BMDSF(_freePageBufferList.GetCount()  , "%u"    );
    BMDSF(_dwAccessCounter                , "%u"    );
    BMDSF(_dwPagingFileTotalSlots         , "%u"    );
    BMDSF(_freeSlots.GetSize()            , "%u"    );
    BMDSF(_uiPageCount                    , "%u"    );
    BMDSF(_uiPageInDiskCount              , "%u"    );
    
    #undef BMDSF
    
    pOut->Write(
        "\n"
        "\n***"
        "\n*** End of Buffer Manager Stats"
        "\n***\n");

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\btree.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * btree.cpp
 * Implementation of leaderboard server btree 
 * Header: btree.h
 * 
 */

#include "lbs.h"

CFastLock g_pLock;

#define DBGPRINT(x)
// #define DBGPRINT(x) g_pLock.Lock();printf("[%d, %d] ",GetCurrentThreadId(),__LINE__); printf x; g_pLock.Unlock();

/*****************************************************************************
  BPTPage
*****************************************************************************/
void BPTPage::Init(WORD wPageFlags, WORD wPageSize)
{
    _wPageFlags  = wPageFlags;
    _wPageSize   = wPageSize;
    _wEntryCount = 0;
    _wFreeOffset = _wPageSize;
    _wFreeSpace  = _wPageSize - offsetof(BPTPage, _endOfHeader);
    _wAvailSpace = _wFreeSpace;
    _pidLLink    = 0;
    _pidRLink    = 0;
    
#if _DEBUG
    FillMemory(_endOfHeader, _wAvailSpace, 0xFA);
#endif        
}

void BPTPage::Clear()
{
    _wEntryCount = 0;
    _wFreeOffset = _wPageSize;
    _wFreeSpace  = _wPageSize - offsetof(BPTPage, _endOfHeader);
    _wAvailSpace = _wFreeSpace;

#if _DEBUG
    FillMemory(_endOfHeader, _wAvailSpace, 0xFA);
#endif        
}

BPTPage::ADDENTRYSTATUS BPTPage::AddEntry(
    BTree* pbtree,
    void* pKey,
    WORD  cbKey,
    void* pData, 
    WORD cbData,
    DWORD dwSizeSubtree
)
{
    ADDENTRYSTATUS status = ADDENTRYSTATUS_OTHER_ERROR;
    
    DBGASSERT(cbKey == pbtree->GetKeySize());
    
    DWORD wSpaceRequired = cbKey + cbData + sizeof(ENTRY_META) + sizeof(DATA_SIZE);
    
    if(wSpaceRequired > _wAvailSpace)
    {
        status = ADDENTRYSTATUS_ERROR_NOT_ENOUGH_SPACE;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "ERROR_NOT_ENOUGH_SPACE");
        goto lDone;
    }
    
    if(wSpaceRequired > _wFreeSpace)
    {
        // Not enough space at the free space region. Time to compact the 
        // node.
        CompactPage();
    }   
    
    // Get a slot in the Record Offsets array. The array is sorted so
    // we might have to move stuff around to open up space.
    WORD wKeyIndex;
    if(GetEntryIndexGE(pbtree,pKey,&wKeyIndex))
    {
        status = ADDENTRYSTATUS_KEY_ALREADY_EXISTS;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "KEY_ALREADY_EXISTS");
        goto lDone;
    }
        
    ENTRY_META* rgOffsets = GetPointerToOffsets();
    
#if 1
    for(int i=_wEntryCount; i > wKeyIndex; i--)
        rgOffsets[i] = rgOffsets[i-1];
#else
    
    memmove(&rgOffsets[wKeyIndex+1],&rgOffsets[wKeyIndex], 
        (sizeof(ENTRY_META) * (_wEntryCount - wKeyIndex)));

#endif        
    
    rgOffsets[wKeyIndex].wOffset       = _wFreeOffset;
    rgOffsets[wKeyIndex].wReserved     = 0x0000;// pad with zeros
    rgOffsets[wKeyIndex].dwSizeSubtree = dwSizeSubtree;
    
    // Finally, copy data over
    BYTE* pEntry = OffsetToPointer(_wFreeOffset);
    *((DATA_SIZE*)(pEntry - sizeof(DATA_SIZE))) = cbKey + cbData;
    CopyMemory(pEntry - sizeof(DATA_SIZE) - cbKey - cbData, pKey, cbKey);
    CopyMemory(pEntry - sizeof(DATA_SIZE) - cbData, pData, cbData);
    
    _wEntryCount++;
    _wFreeOffset -= cbKey + cbData + sizeof(DATA_SIZE);
    _wAvailSpace -= cbKey + cbData + sizeof(DATA_SIZE) + sizeof(ENTRY_META);
    _wFreeSpace  -= cbKey + cbData + sizeof(DATA_SIZE) + sizeof(ENTRY_META);

    status = ADDENTRYSTATUS_SUCCEEDED;
    
lDone:
    
#if 0 // _DEBUG
    DBGASSERT(IntegrityCheck(pbtree, _wPageSize));
#endif
    
    if(status != ADDENTRYSTATUS_SUCCEEDED)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return status;
}

void BPTPage::CompactPage()
{
    TStackHashtable<THashtable<WORD, WORD>, 2351> _newOffsets;

    WORD  cbUsed = 0;
    BYTE* pData  = OffsetToPointer(_wPageSize);
    BYTE* pMove  = pData;
    WORD  wSize  = 0;
    
    for(DWORD i=0; i < _wEntryCount; i++)
    {
        do
        {
            wSize = *(DATA_SIZE*)(pData - sizeof(DATA_SIZE));
            
            if(!(wSize & FREE_FLAG))
            {
                if(pMove != pData)
                {
                    bool fResult = _newOffsets.Set(PointerToOffset(pData), PointerToOffset(pMove));
                    DBGASSERT(fResult);

                    MoveMemory(pMove - sizeof(DATA_SIZE) - wSize, pData - sizeof(DATA_SIZE) - wSize, wSize + sizeof(DATA_SIZE));
                }
                
                pMove -= sizeof(DATA_SIZE) + wSize;
                cbUsed += wSize + sizeof(DATA_SIZE);
            }

            pData -= (wSize & SIZE_MASK) + sizeof(DATA_SIZE);
        
        } while(wSize & FREE_FLAG);
    }

    // Adjust offsets
    ENTRY_META* rgOffsets = GetPointerToOffsets();

    for(DWORD i=0; i < _wEntryCount; i++)
    {
        WORD wNewOffset;
        if(_newOffsets.Get((WORD)rgOffsets[i].wOffset, &wNewOffset))
            rgOffsets[i].wOffset = wNewOffset;
    }

    _wFreeOffset = _wPageSize - cbUsed;
    _wFreeSpace  = (_wPageSize - GetHeaderSize()) - cbUsed - (sizeof(ENTRY_META) * _wEntryCount);

    DBGASSERT(_wFreeSpace == _wAvailSpace);
}

int BPTPage::BinarySearch(BTree* pbtree, void* pKey, WORD* pwSlot)
{
    DBGASSERT(_wEntryCount > 0);

    BTreeKeyCompare KeyCompare = pbtree->GetKeyCompare();
    WORD wKeySize = pbtree->GetKeySize();
    
    int  l = 0;
    int  r = _wEntryCount - 1;
    int  m;
    int  cmp = -1;

    do
    {
        m = (l + r) / 2;

        BYTE* pSlotKey;
        GetEntry(pbtree, (WORD)m, &pSlotKey, NULL, NULL, NULL, NULL);

        cmp = KeyCompare(NULL, pKey, wKeySize, pSlotKey, wKeySize);

        if(cmp < 0)
            r = m - 1;
        else
            l = m + 1;

    } while(l <= r && cmp != 0);

    *pwSlot = (WORD) m;

    return cmp;
}

bool BPTPage::GetEntryIndexGE(BTree* pbtree, void* pKey, WORD* pwSlot)
{
    if(_wEntryCount == 0)
    {
        *pwSlot = 0;
        return false;
    }
    
    WORD wSlot;
    int cmp = BinarySearch(pbtree,pKey,&wSlot);
    
    if (cmp > 0)
        wSlot++;
	
    *pwSlot = wSlot;
    
    return cmp == 0;
}

bool BPTPage::GetEntryIndexLE(BTree* pbtree, void* pKey, WORD* pwSlot)
{
    if(_wEntryCount == 0)
    {
        *pwSlot = 0;
        return false;
    }
    
    WORD wSlot;
    int cmp = BinarySearch(pbtree,pKey,&wSlot);
    
    if(cmp < 0 && wSlot > 0)
          wSlot--;

    *pwSlot = wSlot;
    
    return cmp == 0;    
}

DWORD BPTPage::GetEntryIndexForRankLookup(
    IN BTree* pInfo,
    IN DWORD  dwRank,
    OUT WORD* pwIndex
)
{
    ENTRY_META* rgMeta = GetPointerToOffsets();

	WORD i;
    for(i=0; i < _wEntryCount-1; i++)
    {
        if(dwRank <= rgMeta[i].dwSizeSubtree)
            break;
            
        dwRank -= rgMeta[i].dwSizeSubtree;
    }
    
    *pwIndex = i;
    
    return dwRank;    
}

void BPTPage::RemoveEntry(BTree* pbtree, WORD wKeyIndex)
{
    DBGASSERT(wKeyIndex < _wEntryCount);

    // Free space in the data section
    BYTE* pEntry = GetPointerToEntry(wKeyIndex);
    DATA_SIZE size = *(DATA_SIZE*)(pEntry - sizeof(DATA_SIZE));
    *(DATA_SIZE*)(pEntry - sizeof(DATA_SIZE)) = size | FREE_FLAG;

#if _DEBUG
    FillMemory(pEntry - sizeof(DATA_SIZE) - size, size, 0xFF);
#endif
    
    // Remove offset
    ENTRY_META* pOffsets = GetPointerToOffsets();
    
#if 1
    for(int i=wKeyIndex; i < _wEntryCount-1; i++)
        pOffsets[i] = pOffsets[i+1];
#else
    
    if(wKeyIndex  < _wEntryCount)
    {
        memmove(&pOffsets[wKeyIndex], &pOffsets[wKeyIndex+1], 
            sizeof(ENTRY_META) * (_wEntryCount - wKeyIndex - 1));
    }

#endif        
    
    _wFreeSpace  += sizeof(ENTRY_META);
    _wAvailSpace += sizeof(ENTRY_META);
    
    // If data portion is adjacent to free area, consolidate the space
    // by adjusting _wFreeOffset 
    if((WORD)(PointerToOffset(pEntry) - sizeof(DATA_SIZE) - size) == _wFreeOffset)
    {
        _wFreeOffset += size + sizeof(DATA_SIZE);
        _wFreeSpace  += size + sizeof(DATA_SIZE);
    }
    
    _wAvailSpace += size + sizeof(DATA_SIZE);
    _wEntryCount--;
    
#if 0 // _DEBUG
    DBGASSERT(IntegrityCheck(pbtree, _wPageSize));
#endif
}

bool BPTPage::CopyTo(
    IN BTree* pbtree,
    IN WORD wKeyIndex,
    IN BPTPage* pDestPage
)
{
    DBGASSERT(wKeyIndex < _wEntryCount);
    
    BYTE* pKey;
    WORD  cbKey;
    BYTE* pData;
    WORD  cbData;
    DWORD dwSizeSubtree;
    
    GetEntry(pbtree, wKeyIndex, &pKey, &cbKey, &pData, &cbData, &dwSizeSubtree);
    DBGASSERT(pDestPage->HasRoomFor(cbKey + cbData));

    ADDENTRYSTATUS status = pDestPage->AddEntry(pbtree, pKey, cbKey, pData,
        cbData, dwSizeSubtree);
    DBGASSERT(status == ADDENTRYSTATUS_SUCCEEDED);
    
    if(status != ADDENTRYSTATUS_SUCCEEDED)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status == ADDENTRYSTATUS_SUCCEEDED;
}

bool BPTPage::IntegrityCheck(BTree* pbtree, WORD wPageSize)
{
#define INTEGRITY_CHECK(x) \
    { \
        bool sUcCeEdEd = (x); \
        if(!sUcCeEdEd) \
        { \
            DBGASSERT(false); \
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Integrity check failed: " #x); \
            fRet = false; \
            goto lDone; \
        } \
    } \
    
    bool fRet = false;
    TStackHashtable<THashtable<WORD, WORD>, 5003> offsets;
    
    INTEGRITY_CHECK(_wPageSize == wPageSize);
    
    // Check data
    BYTE* pEOP        = (BYTE*)this + _wPageSize;
    BYTE* pEntry      = pEOP;
    WORD  cbSize      = 0;
    WORD  wUsed       = 0;
    WORD  wFreeOffset = _wPageSize;
    
    for(int i=0; i < _wEntryCount; i++)
    {
        do
        {
            INTEGRITY_CHECK(pEntry - sizeof(DATA_SIZE) > _endOfHeader);
            
            cbSize = *(DATA_SIZE*)(pEntry - sizeof(DATA_SIZE));
            
            if(! (cbSize & FREE_FLAG))
            {
                offsets.Set((WORD)(pEntry - ((BYTE*)this)), 0);
                wUsed += cbSize + sizeof(DATA_SIZE);
                wFreeOffset = (WORD) (pEntry - ((BYTE*)this) - sizeof(DATA_SIZE) - cbSize);
            }
            
            pEntry -= (cbSize & SIZE_MASK) + sizeof(DATA_SIZE);
        }
        while(cbSize & FREE_FLAG);
    }
    
    INTEGRITY_CHECK(offsets.GetCount() == _wEntryCount);
    
    // Check offsets
    ENTRY_META* pOffsets = GetPointerToOffsets();
    for(int i=0; i < _wEntryCount; i++)
    {
        INTEGRITY_CHECK(((BYTE*)pOffsets+i) < pEOP);
        
        WORD offset = (WORD)pOffsets[i].wOffset;
        WORD wSet;
        
        INTEGRITY_CHECK(offsets.Get(offset, &wSet));
        INTEGRITY_CHECK(wSet == 0);
        
        offsets.Set(offset, 1);
    }
    
    // Check order
    BYTE* pKey = NULL;
    BYTE* pPrevKey = NULL;
    
    for(int i=0; i < _wEntryCount; i++)
    {
        GetEntry(pbtree, (WORD) i, &pKey, NULL, NULL, NULL, NULL);
        
        if(pPrevKey != NULL)
        {
            INTEGRITY_CHECK(pbtree->GetKeyCompare()(NULL, pPrevKey, 
                pbtree->GetKeySize(), pKey, pbtree->GetKeySize()) < 0);
        }
        
        pPrevKey = pKey;
    }
    
    // Check header
    INTEGRITY_CHECK(_wFreeOffset <= wFreeOffset);
    INTEGRITY_CHECK(_wFreeSpace  <= wFreeOffset - offsetof(BPTPage,_endOfHeader) - sizeof(ENTRY_META)*_wEntryCount);
    INTEGRITY_CHECK(_wAvailSpace == _wPageSize - offsetof(BPTPage,_endOfHeader) - wUsed - sizeof(ENTRY_META)*_wEntryCount);
    
    fRet = true;

lDone:

    return fRet;
    
#undef INTEGRITY_CHECK
}

/*****************************************************************************
  BTree
*****************************************************************************/
bool BTree::Init(
    IUmsClient* pUmsClient, 
    CBufferManager* pBM, 
    BTreeKeyCompare pKeyCompare,
    WORD wKeySize
)
{
    bool fRet          = false;
    CBPTPageRef rootPage;
    
    _pBM         = pBM;
    _pKeyCompare = pKeyCompare;
    _wKeySize    = wKeySize;
    
    // Create the root page
    if(!CreateNewPage(pUmsClient,&rootPage))
        goto lDone;
    
    rootPage.GetPage()->Init(BPT_PAGE_FLAG_EXTERNAL, (WORD)_pBM->GetPageSize());

    // Nodes will be considered for merging when 65% of their free space or
    // more is unused
    _wConsiderMerge = (WORD)(rootPage.GetPage()->GetMaxAvailableSpace() * 
        BtreePerFreeSpaceToConsiderMerge);

    _pidRoot  = rootPage.GetPage()->pageId;
    
    rootPage.Release(pUmsClient);
    
    fRet = true;
        
lDone:

    if(!rootPage.IsNull())
        DeletePage(pUmsClient,&rootPage);
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
       
    return fRet;
}

void BTree::Term(IUmsClient* pUmsClient)
{
    UMSSafeLockCookie lockTree(pUmsClient);
    CBPTPageRef pageref;
    BM_PAGEID pid;
    
    if(_pidRoot == 0)
        return;
        
    TEasyList<BM_PAGEID> stack;
    
    if(!stack.Init("tempstack",1,true,&g_MemAlloc))
        goto lDone;
    
    if(!GetRootPage(pUmsClient,LOCK_MODE_X,&pageref,&lockTree))
        goto lDone;
        
    if(!stack.Push(pageref.GetPage()->pageId))
        goto lDone;
        
    pageref.Release(pUmsClient);
        
    while(stack.Pop(&pid))
    {
        if(!GetPage(pUmsClient,pid,LOCK_MODE_X,&pageref))
            goto lDone;
        
        if(pageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            for(DWORD i=0; i < pageref.GetPage()->_wEntryCount; i++)
            {
                CBPTPageRef child;
                
                GetChildPageFromParent(pUmsClient,&pageref,(WORD)i, LOCK_MODE_X, &child); 
                
                if(!stack.Push(child.GetPage()->pageId))
                    goto lDone;
                    
                child.Release(pUmsClient);
            }
        }
        
        DeletePage(pUmsClient,&pageref);
    }
    
lDone:

    stack.Term();
    
    return;
}

// Removes all entries
bool BTree::Reset(
    IUmsClient* pUmsClient
)
{
    bool fRet = false;
    
    UMSSafeLockCookie lockTree(pUmsClient);
    CBPTPageRef pageref;
    BM_PAGEID pid;
    
    // We need a stack to traverse the b-tree
    TEasyList<BM_PAGEID> stack;
    if(!stack.Init("tempstack",1,true,&g_MemAlloc))
        goto lDone;
    
    // Get the root page
    if(!GetRootPage(pUmsClient,LOCK_MODE_X,&pageref,&lockTree))
        goto lDone;
        
    // And put it in the stack
    if(!stack.Push(pageref.GetPage()->pageId))
        goto lDone;
        
    pageref.Release(pUmsClient);
        
    // Traverse the b-tree depth first, deleting each page in pre-order
    while(stack.Pop(&pid))
    {
        if(!GetPage(pUmsClient,pid,LOCK_MODE_X,&pageref))
            goto lDone;
        
        if(pageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            for(DWORD i=0; i < pageref.GetPage()->_wEntryCount; i++)
            {
                CBPTPageRef child;
                
                GetChildPageFromParent(pUmsClient,&pageref,(WORD)i, LOCK_MODE_X, 
                    &child); 
                
                if(!stack.Push(child.GetPage()->pageId))
                    goto lDone;
                    
                child.Release(pUmsClient);
            }
        }
        
        DeletePage(pUmsClient,&pageref);
    }
    
    // Now recreate an empty root
    if(!CreateNewPage(pUmsClient,&pageref))
        goto lDone;
    
    pageref.GetPage()->Init(BPT_PAGE_FLAG_EXTERNAL, (WORD)_pBM->GetPageSize());

    _pidRoot  = pageref.GetPage()->pageId;
    
    pageref.Release(pUmsClient);
    
    fRet = true;
    
lDone:

    stack.Term();
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

BTree::SEARCHSTATUS BTree::SearchLE(
    IUmsClient* pUmsClient,
    void*       pKey,
    WORD        cbKey,
    bool        fWrite,
    Iterator*   pIterator
)
{
    return BTree::Search(pUmsClient, pKey, cbKey, fWrite, pIterator, false);
}

BTree::SEARCHSTATUS BTree::SearchGE(
    IUmsClient* pUmsClient,
    void*       pKey,
    WORD        cbKey,
    bool        fWrite,
    Iterator*   pIterator
)
{
    return BTree::Search(pUmsClient, pKey, cbKey, fWrite, pIterator, true);
}

BTree::SEARCHSTATUS BTree::Search(
    IUmsClient* pUmsClient,
    void*       pKey,
    WORD        cbKey,
    bool        fWrite,
    Iterator*   pIterator,
    bool        fGreater
)
{
	return BTree::SearchEx(pUmsClient, pKey, cbKey, fWrite, pIterator, fGreater, NULL);
}

BTree::SEARCHSTATUS BTree::SearchEx(
    IUmsClient* pUmsClient,
    void*       pKey,
    WORD        cbKey,
    bool        fWrite,//fwrite will determine lock mode
    Iterator*   pIterator,
    bool        fGreater,
    ITraceCallback* pOut
)
{
    SEARCHSTATUS status = SEARCHSTATUS_OTHER_ERROR;
    CBPTPageRef pageref;
    DWORD dwRank        = 1;
    WORD  wPrevChildIndex = 0;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);


    if(!GetRootPage(pUmsClient, LOCK_MODE_IS, &pageref,&lockTreeRoot))
    {
        goto lDone;
    }
        
    for(;;)
    {

        if (NULL != pOut) DumpRawPage(pOut, wPrevChildIndex, pageref.GetPage());
		
        if(pageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            WORD wChildIndex;
            
            pageref.GetPage()->GetEntryIndexLE(this,pKey,&wChildIndex); //always use LE to traverse internal node.
            
            if (wChildIndex >= pageref.GetPage()->GetEntryCount())
                wChildIndex = pageref.GetPage()->GetEntryCount() - 1;
            
            if(wChildIndex > 0)
                dwRank += pageref.GetPage()->GetSizeLeftSubtree(wChildIndex-1);
            
            CBPTPageRef nextpageref;
            
            if(!GetChildPageFromParent(pUmsClient, &pageref, wChildIndex, LOCK_MODE_IS, 
                &nextpageref))
            {
                goto lDone;
            }

            if(fWrite && nextpageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_EXTERNAL)
            {
                // Caller wants an X lock on the leaf. The safe way to do this 
                // is to release the IS lock on the leaf and try again with the 
                // X lock.

                nextpageref.Release(pUmsClient);
                
                if(!GetChildPageFromParent(pUmsClient, &pageref, wChildIndex, LOCK_MODE_X, 
                    &nextpageref))
                {
                    goto lDone;
                }
            }
            
            pageref.Release(pUmsClient);
            pageref = nextpageref;
            nextpageref.Reset();

            wPrevChildIndex = wChildIndex;
        }
        else
        {
            WORD wSlot;
            
            if(pageref.GetPage()->GetEntryCount() != 0)
            {
                bool fEntry;

                if (fGreater)
                {
                    fEntry = pageref.GetPage()->GetEntryIndexGE(this, pKey, &wSlot);
                }
                else
                {
                    fEntry = pageref.GetPage()->GetEntryIndexLE(this, pKey, &wSlot);
                }

                if(fEntry)
                    status = SEARCHSTATUS_SUCCEEDED;
                else
                    status = SEARCHSTATUS_NOT_FOUND;
                    
                dwRank += min(wSlot, pageref.GetPage()->GetEntryCount()- 1);
            }
            else
            {
                DBGASSERT(dwRank==1);
                dwRank = 0;
                status = SEARCHSTATUS_NOT_FOUND;
                pageref.Release(pUmsClient);
            }
                
            pIterator->Init(pUmsClient,this,&pageref,wSlot,dwRank);
            
            pageref.Reset();
            break;
        }
    }
    
lDone:
    
    if(status != SEARCHSTATUS_SUCCEEDED &&
       status != SEARCHSTATUS_NOT_FOUND)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }
                  
    return status;
}

bool BTree::SearchByRank(
    IUmsClient* pUmsClient,
    DWORD dwSearchRank,
    bool fWrite,
    Iterator* pIterator
)
{
    bool fRet = false;
    CBPTPageRef pageref;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);

    if(dwSearchRank == 0)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "dwSearchRank cannot be zero.");
        goto lDone;
    }
    
    if(!GetRootPage(pUmsClient, LOCK_MODE_IS, &pageref,&lockTreeRoot))
    {
        goto lDone;
    }
    
    DWORD dwRank = dwSearchRank;
        
    for(;;)
    {
        if(pageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            WORD wChildIndex;
            
            dwRank = pageref.GetPage()->GetEntryIndexForRankLookup(this,dwRank,&wChildIndex);
            
            CBPTPageRef nextpageref;
            if(!GetChildPageFromParent(pUmsClient, &pageref, wChildIndex, LOCK_MODE_IS, 
                &nextpageref))
            {
                goto lDone;
            }

            if(fWrite && nextpageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_EXTERNAL)
            {
                // Caller wants an X lock on the leaf. The safe way to do this 
                // is to release the IS lock on the leaf and try again with the 
                // X lock.

                nextpageref.Release(pUmsClient);
                
                if(!GetChildPageFromParent(pUmsClient, &pageref, wChildIndex, LOCK_MODE_X, 
                    &nextpageref))
                {
                    goto lDone;
                }
            }
            
            pageref.Release(pUmsClient);
            pageref = nextpageref;
            nextpageref.Reset();
        }
        else
        {
            WORD wSlot;
            DWORD dwEntryCount = pageref.GetPage()->GetEntryCount();
            
            if(dwEntryCount != 0)
            {
                if(dwRank <= dwEntryCount)
                {
                    wSlot = (WORD)(dwRank != 0 ? dwRank-1 : 0);
                    dwRank = dwSearchRank;
                }
                else
                {
                    wSlot  = (WORD)(dwEntryCount-1);
                    dwRank = dwSearchRank - dwRank + dwEntryCount;
                }
            }
            else
            {
                DBGASSERT(dwRank == dwSearchRank);
                dwRank = 0;
                pageref.Release(pUmsClient);
            }
            
            pIterator->Init(pUmsClient,this,&pageref,wSlot,dwRank);
            
            pageref.Reset();
            break;
        }
    }
    
    fRet = true;
    
lDone:
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }
                  
    return fRet;
}

BTree::INSERTSTATUS BTree::Insert(IUmsClient* pUmsClient, void* pKey, WORD cbKey, void* pData, WORD cbData)
{
    INSERTSTATUS status = INSERTSTATUS_OTHER_ERROR;
    CBPTPageRef rootref;
    CBPTPageRef newrootref;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);

    BTREE_INC_STAT(cInsert);

    if(!GetRootPage(pUmsClient,LOCK_MODE_IX,&rootref,&lockTreeRoot))
        goto lDone;
        
    status = InsertRecursive(pUmsClient, &rootref, pKey, cbKey, pData, cbData, true);
    
    if(INSERTSTATUS_OPTIMISTIC_RUN_FAILED == status)
    {
        BTREE_INC_STAT(cInsertOptimisticFailed);
        
        for(;;)
        {
            rootref.Release(pUmsClient);
            lockTreeRoot.Release();
            
            if(!GetRootPage(pUmsClient,LOCK_MODE_SIX,&rootref,&lockTreeRoot))
                goto lDone;
                
            if(!ShouldSplit(&rootref,cbKey,cbData))
            {
                // We've got both the tree and root locks and the root doesn't 
                // need to split. We're ready.
                break;
            }
            
            // It looks like the root needs to split. Convert the tree and the 
            // root locks to Xs.  Unfortunatelly we can't just upgrade both of 
            // them without violating the down-right rule and therefore risking 
            // deadlocks. So the plan is to release root lock, upgrade the tree 
            // lock and re-acquire the root lock.
            
            rootref.Release(pUmsClient);
            
            if(!pUmsClient->UpgradeLockFromSIXtoX(&lockTreeRoot))
                goto lDone;
            
            if(!GetPage(pUmsClient, _pidRoot, LOCK_MODE_X, &rootref))
                goto lDone;
            
            DBGASSERT(ShouldSplit(&rootref,cbKey,cbData));
                
            // Proceed with the 'splitting'
            // Create a page that's going to be the new root
            if(!CreateNewPage(pUmsClient,&newrootref))
                goto lDone;
                
            newrootref.GetPage()->Init(BPT_PAGE_FLAG_INTERNAL, (WORD)_pBM->GetPageSize());
            
            // Create a reference on the new root to the old root
            if(!AddChildReferenceToParent(&newrootref, &rootref))
            {
                DBGASSERT(false);
                goto lDone;
            }
            
            // Replace the old root with the new root
            _pidRoot = newrootref.GetPage()->pageId;
            newrootref.Release(pUmsClient);

            // We're done. Let's start from the beginning so we can start the 
            // decent with the SIX lock
        }
            
        status = InsertRecursive(pUmsClient, &rootref, pKey, cbKey, pData, cbData, false);
        
        if(status != INSERTSTATUS_SUCCEEDED)
            goto lDone;
    }
    
lDone:

    rootref.Release(pUmsClient);
    newrootref.Release(pUmsClient);

    if(status != INSERTSTATUS_SUCCEEDED)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

BTree::INSERTSTATUS BTree::InsertRecursive(
    IUmsClient* pUmsClient,
    CBPTPageRef* pPageRef,
    void* pKey,
    WORD cbKey,
    void* pData,
    WORD cbData,
    bool fOptimistic
)
{
    INSERTSTATUS status = INSERTSTATUS_OTHER_ERROR;
    CBPTPageRef childref;
    WORD wChildIndex;
    
    if(pPageRef->GetPage()->_wPageFlags & BPT_PAGE_FLAG_EXTERNAL)
    {
        if(!pPageRef->ReleaseAndAcquireLock(pUmsClient,LOCK_MODE_X))
            goto lDone;
        
        BPTPage::ADDENTRYSTATUS addstatus = pPageRef->GetPage()->AddEntry(this,pKey,cbKey,pData,cbData,1);
        
        if(addstatus == BPTPage::ADDENTRYSTATUS_KEY_ALREADY_EXISTS)
        {
            status = INSERTSTATUS_PRIMARY_KEY_VIOLATION;
            goto lDone;
        }
        else if(addstatus == BPTPage::ADDENTRYSTATUS_ERROR_NOT_ENOUGH_SPACE && fOptimistic)
        {
            status = INSERTSTATUS_OPTIMISTIC_RUN_FAILED;
            goto lDone;
        }
        else if(addstatus != BPTPage::ADDENTRYSTATUS_SUCCEEDED)
        {
            goto lDone;
        }
    }
    else
    {
        // Which node this goes into? 
        pPageRef->GetPage()->GetEntryIndexLE(this,pKey,&wChildIndex);
        
        if(!GetChildPageFromParent(pUmsClient,pPageRef,wChildIndex,
            fOptimistic ? LOCK_MODE_IX : LOCK_MODE_SIX, &childref))
        {
            goto lDone;
        }
        
        if(childref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            if(!fOptimistic && ShouldSplit(&childref,cbKey,cbData))
            {
                childref.Release(pUmsClient);
                
                if(!SplitPage(pUmsClient,pPageRef,wChildIndex,cbKey+sizeof(BM_PAGEID), NULL, 0, NULL, 0))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pPageRef->GetPage()->GetEntryIndexLE(this,pKey,&wChildIndex);
                
                if(!GetChildPageFromParent(pUmsClient,pPageRef,wChildIndex,
                    fOptimistic ? LOCK_MODE_IX : LOCK_MODE_SIX, &childref))
                {
                    goto lDone;
                }
            
                DBGASSERT(!ShouldSplit(&childref,cbKey,cbData));
            }
            
            status = InsertRecursive(pUmsClient,&childref,pKey,cbKey,pData,cbData,fOptimistic);
            
            if(status != INSERTSTATUS_SUCCEEDED)
                goto lDone;
                
            pPageRef->GetPage()->IncSizeSubtree(wChildIndex);
        }
        else
        {
            DBGASSERT(childref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_EXTERNAL);
            
            if(ShouldSplit(&childref,cbKey,cbData))
            {
                if(fOptimistic)
                {
                    status = INSERTSTATUS_OPTIMISTIC_RUN_FAILED;
                    goto lDone;
                }
                
                // Before splitting the page it's necessary to check if we're
                // not inserting a dup key. Otherwise, SplitPage will fail and
                // leave the tree in a bad state.
                WORD wYay;
                if(childref.GetPage()->GetEntryIndexLE(this, pKey, &wYay))
                {
                    status = INSERTSTATUS_PRIMARY_KEY_VIOLATION;
                    goto lDone;
                }
                
                childref.Release(pUmsClient);

                if(!SplitPage(pUmsClient,pPageRef,wChildIndex,0,(BYTE*)pKey,cbKey,(BYTE*)pData,cbData))
                    goto lDone;
            }
            else
            {
                status = InsertRecursive(pUmsClient,&childref,pKey,cbKey,pData,cbData,fOptimistic);
                
                if(status != INSERTSTATUS_SUCCEEDED)
                    goto lDone;
            
                pPageRef->GetPage()->IncSizeSubtree(wChildIndex);
            }
        }
    }
    
    status = INSERTSTATUS_SUCCEEDED;
    
lDone:

    childref.Release(pUmsClient);
    
    if(status != INSERTSTATUS_SUCCEEDED &&
       status != INSERTSTATUS_OPTIMISTIC_RUN_FAILED)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}

bool BTree::SplitPage(
    IN IUmsClient* pUmsClient, 
    IN CBPTPageRef* pParentRef,
    WORD wChildIndex,
    IN BYTE cbMinRequired,
    IN BYTE* pKey,
    IN WORD cbKey,
    IN BYTE* pData,
    IN WORD cbData
)
{
    bool fRet = false;
    CBPTPageRef childref;
    CBPTPageRef newpageref;
    CBPTPageRef child2ref;
    
    BTREE_INC_STAT(cInsertSplit);
    
    // Get a X lock on the parent
    if(!pParentRef->UpgradeLockFromSIXtoX(pUmsClient))
        goto lDone;
        
    // Get child to be split
    if(!GetChildPageFromParent(pUmsClient,pParentRef,wChildIndex,LOCK_MODE_X,&childref))
        goto lDone;
        
    // Get child immediately at the splitting child's right
    if(childref.GetPage()->_pidRLink != 0)
    {
        if(!GetPage(pUmsClient,childref.GetPage()->_pidRLink,LOCK_MODE_X,&child2ref))
            goto lDone;
    }
    
    // Create a new page to be inserted at the right of splitting child
    if(!CreateNewPage(pUmsClient,&newpageref))
        goto lDone;
        
    newpageref.GetPage()->Init(childref.GetPage()->_wPageFlags, (WORD)_pBM->GetPageSize());
    
    // Good so here's what we have:
    //        ->
    //  child    child2     newpageref 
    //        <-
    //
    // And we want:
    //        ->            ->
    // child     newpageref    child2
    //        <-            <-
    
    childref.GetPage()->_pidRLink   = newpageref.GetPage()->pageId;
    newpageref.GetPage()->_pidLLink = childref.GetPage()->pageId;
    
    if(!child2ref.IsNull())
    {
        newpageref.GetPage()->_pidRLink = child2ref.GetPage()->pageId;
        child2ref.GetPage()->_pidLLink  = newpageref.GetPage()->pageId;
    }
    else
    {
        newpageref.GetPage()->_pidRLink = 0;
    }
    
    // Now balance entries between child and newpage
    CBPTPageRef* rgChildren[2];
    rgChildren[0] = &childref;
    rgChildren[1] = &newpageref;
    
    if(BalanceNodes(pUmsClient,pParentRef,rgChildren,2,cbMinRequired,pKey,
        cbKey,pData,cbData) != BALANCENODESSTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    fRet = true;

lDone:
    
    childref  .Release(pUmsClient);
    newpageref.Release(pUmsClient);
    child2ref .Release(pUmsClient);
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

bool BTree::GetChildPageFromParent(
    IN IUmsClient* pUmsClient,
    IN CBPTPageRef* pParent,
    IN WORD wChildIndex,
    IN LOCK_MODE lm,
    OUT CBPTPageRef* pChild
)
{
    DBGASSERT(pParent->GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL);
    
    bool fRet = false;
    
    BM_PAGEID* pPageId;
    pParent->GetPage()->GetEntry(this,wChildIndex,NULL,NULL,(BYTE**)&pPageId,NULL,NULL);
    
    if(!GetPage(pUmsClient,*pPageId,lm,pChild))
        goto lDone;
    
    fRet = true;
    
lDone:

    DBGASSERT(fRet);
    
    return fRet;
}

BTree::BALANCENODESSTATUS BTree::BalanceNodes(
    IUmsClient* pUmsClient, 
    CBPTPageRef* pParent,
    CBPTPageRef* rgChildren[],
    DWORD cChildren,
    WORD wMinSpaceAllowed,
    void* pKey,
    WORD cbKey,
    void* pData,
    WORD cbData
)
{
    DBGASSERT(cChildren >= 2 && cChildren <= 3);
    
    BALANCENODESSTATUS status = BALANCENODESTATUS_OTHER_ERROR;
    BPTPage* pBigPage;

    // Verify that parent already has an X
    if(pParent->GetCurrentLockMode() != LOCK_MODE_X)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "BalanceNodes must be called with the parent page with a X lock");
        DBGASSERT(false);
        goto lDone;
    }

    // Verify that all the children have Xs
    for(DWORD i=0; i < cChildren; i++)
    {
        if(rgChildren[i]->GetCurrentLockMode() != LOCK_MODE_X)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "BalanceNodes must be called with all the children with X locks");
            DBGASSERT(false);
            goto lDone;
        }
    }

    // Allocate one big temporary page 
    DWORD dwBigPageSize = _pBM->GetPageSize() * cChildren;
    
    pBigPage = new (g_MemAlloc.Alloc(dwBigPageSize)) BPTPage;
    if(NULL == pBigPage)
        goto lDone;
        
    pBigPage->Init(0, (WORD)dwBigPageSize);
    
    // Copy all entries to temporary page
    for(DWORD i = 0; i < cChildren; i++)
    {
        for(DWORD j = 0; j < rgChildren[i]->GetPage()->_wEntryCount; j++)
        {
            if(!rgChildren[i]->GetPage()->CopyTo(this, (WORD)j, pBigPage))
            {
                DBGASSERT(false);
                goto lDone;
            }
        }
    }
    
    // Copy new key if provided
    if(pKey != NULL)
    {
        if(pBigPage->AddEntry(this, pKey, cbKey, pData, cbData, 1) 
            != BPTPage::ADDENTRYSTATUS_SUCCEEDED)
        {
            DBGASSERT(false);
            goto lDone;
        }
    }
    
    // It's time to do the balancing, but before we mess with the children
    // do a first run to see if the rebalancing is even possible.
    WORD rgChildSize[3] = {0, 0, 0};
    WORD wMaxSize       = rgChildren[0]->GetPage()->GetMaxAvailableSpace() - wMinSpaceAllowed;
    DWORD dwChildIndex  = 0;
    WORD wEstimatedSize = (pBigPage->GetMaxAvailableSpace() - pBigPage->_wAvailSpace) / (WORD)cChildren;

    for(DWORD i = 0; i < pBigPage->_wEntryCount; i++)
    {
        WORD cbTempKeySize;
        WORD cbTempDataSize;
        pBigPage->GetEntry(this,(WORD)i,NULL,&cbTempKeySize,NULL,&cbTempDataSize,NULL);

        WORD cbTotalSize = cbTempKeySize + cbTempDataSize + BPTPage::GetEntryOverhead();
        
        while(dwChildIndex < cChildren &&
                ( (dwChildIndex < cChildren-1 && 
                    rgChildSize[dwChildIndex] >= wEstimatedSize) ||
                  rgChildSize[dwChildIndex] + cbTotalSize > wMaxSize ) 
             )
        {
            dwChildIndex++;
        }
        
        if(dwChildIndex == cChildren)
        {
            status = BALANCENODESSTATUS_NOT_ENOUGH_SPACE;
            goto lDone; 
        }
        
        rgChildSize[dwChildIndex] += cbTotalSize;
    }

    // OK, let's try this again, this time with the real children.
    // Since we might mess with the children's reference keys in the 
    // process, let's remove their references from the parent's node.
    // We'll add them back when we're done. In the process, let's 
    // reset the children's state.
    for(DWORD i=0; i < cChildren; i++)
    {
        if(rgChildren[i]->GetPage()->_wEntryCount > 0)
        {
            RemoveChildReferenceFromParent(pParent,rgChildren[i]);
            rgChildren[i]->GetPage()->Clear();
        }
    }

    // Let's do it.
    dwChildIndex = 0;
    for(DWORD i = 0; i < pBigPage->_wEntryCount; i++)
    {
        BYTE* pTempKey;
        WORD cbTempKeySize;
        BYTE* pTempData;
        WORD cbTempDataSize;
        DWORD dwSizeSubtree;
        pBigPage->GetEntry(this,(WORD)i,&pTempKey,&cbTempKeySize,&pTempData,&cbTempDataSize,
            &dwSizeSubtree);
        
        WORD cbTotalSize = cbTempKeySize + cbTempDataSize + BPTPage::GetEntryOverhead();
        
        while(dwChildIndex < cChildren &&
                ( (dwChildIndex < cChildren-1 && 
                    rgChildren[dwChildIndex]->GetPage()->GetUsedSpace() >= wEstimatedSize) ||
                  rgChildren[dwChildIndex]->GetPage()->GetUsedSpace() + cbTotalSize > wMaxSize ) 
             )
        {
            dwChildIndex++;
        }
        
        if(dwChildIndex == cChildren)
        {
            DBGASSERT(false);
            status = BALANCENODESTATUS_OTHER_ERROR;
            goto lDone; 
        }
        
        if(rgChildren[dwChildIndex]->GetPage()->AddEntry(this,pTempKey,cbTempKeySize,
            pTempData,cbTempDataSize, dwSizeSubtree) != BPTPage::ADDENTRYSTATUS_SUCCEEDED)
        {
            DBGASSERT(false);
            goto lDone;
        }
    }
    
    // Add references back to parent
    for(DWORD i=0; i < cChildren; i++)
    {
        if(!AddChildReferenceToParent(pParent,rgChildren[i]))
        {
            DBGASSERT(false);
            goto lDone;
        }
    }
    
    status = BALANCENODESSTATUS_SUCCEEDED;
    
lDone:

    if(pBigPage != NULL)
        g_MemAlloc.Free(pBigPage);
    
    if(status != BALANCENODESSTATUS_SUCCEEDED &&
       status != BALANCENODESSTATUS_NOT_ENOUGH_SPACE)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}

bool BTree::AddChildReferenceToParent(CBPTPageRef* pParent, CBPTPageRef* pChild)
{
    DBGASSERT(pChild->GetPage()->_wEntryCount > 0);
    
    bool fRet = false;
    
    BYTE* pChildKey;
    DWORD dwSizeSubtree;
    
    pChildKey     = GetReferenceKeyFromNode(pChild);
    dwSizeSubtree = pChild->GetPage()->GetSizeTree();
    
    if(pParent->GetPage()->AddEntry(this,pChildKey,this->GetKeySize(),
        &pChild->GetPage()->pageId, sizeof(BM_PAGEID), dwSizeSubtree) != BPTPage::ADDENTRYSTATUS_SUCCEEDED)
    {
        goto lDone;
    }
    
    fRet = true;
    
lDone:
    
    return fRet;        
}

void BTree::RemoveChildReferenceFromParent(CBPTPageRef* pParent, CBPTPageRef* pChild)
{
    WORD wChildIndex;
    BYTE* pChildKey;
     
    pChildKey = GetReferenceKeyFromNode(pChild);
    pParent->GetPage()->GetEntryIndexLE(this,pChildKey,&wChildIndex);
    pParent->GetPage()->RemoveEntry(this, wChildIndex);
}

BYTE* BTree::GetReferenceKeyFromNode(CBPTPageRef* pPage)
{
    DBGASSERT(pPage->GetPage()->_wEntryCount > 0);
    
    BYTE* pKey;
    WORD  cbKey;
    
    pPage->GetPage()->GetEntry(this,0,&pKey,&cbKey,NULL,NULL,NULL);
    DBGASSERT(cbKey == this->GetKeySize());
    
    return pKey;
}

bool BTree::GetPage(
    IUmsClient* pUmsClient,
    BM_PAGEID pid,
    LOCK_MODE lm,
    CBPTPageRef* pPageRef
)
{
    bool fRet = false;
    
    BPTPage* pPage;
    UMSLockCookie lock;
    
    if(!_pBM->GetPage(pUmsClient,pid,lm,(BM_PAGE**)&pPage,&lock))
        goto lDone;
        
    pPageRef->Set(pPage,&lock);
    
    fRet = true;
    
lDone:

    DBGASSERT(fRet);
    
    return fRet;
}

bool BTree::CreateNewPage(
    IUmsClient* pUmsClient,
    CBPTPageRef* pPageRef
)
{
    bool fRet = false;
    
    BPTPage* pPage;
    UMSLockCookie lock;

    if(!_pBM->CreateNewPage(pUmsClient,&lock,(BM_PAGE**)&pPage))
        goto lDone;
        
    pPageRef->Set(pPage,&lock);
    
    fRet = true;
    
lDone:

    DBGASSERT(fRet);

    return fRet;        
}

bool BTree::DeletePage(
    IUmsClient* pUmsClient,
    CBPTPageRef* pPageRef
)
{
    bool fRet = false;
    
    DBGASSERT(!pPageRef->IsNull());
    
    if(!_pBM->DeletePage(pUmsClient,pPageRef->GetPage()->pageId))
        goto lDone;
        
    pPageRef->Release(pUmsClient);
    
    fRet = true;
    
lDone:

    DBGASSERT(fRet);

    return fRet;
}


bool BTree::ShouldSplit(CBPTPageRef* pPage, WORD cbKey, WORD cbData)
{
    if(pPage->GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
    {
        return !pPage->GetPage()->HasRoomFor(cbKey + sizeof(BM_PAGEID));
    }
    else
    {
        DBGASSERT(pPage->GetPage()->_wPageFlags & BPT_PAGE_FLAG_EXTERNAL);
        return !pPage->GetPage()->HasRoomFor(cbKey + cbData);
    }
}

bool BTree::GetRootPage(
    IUmsClient* pUmsClient, 
    LOCK_MODE lmRoot,
    CBPTPageRef* pRootPage,
    UMSLockCookie* pLockRoot
)
{
    bool fRet      = false;
    BPTPage* pRoot = NULL;
    UMSLockCookie lockPage;
    
    if(!pUmsClient->AcquireLock(GetLockIdForTreeRoot(), lmRoot, pLockRoot))
        goto lDone; // TODO: fatal error
    
    if(!GetPage(pUmsClient,_pidRoot,lmRoot,pRootPage))
        goto lDone;
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

BTree::DELETESTATUS BTree::Delete(
    IUmsClient* pUmsClient,
    void* pKey,
    WORD cbKey,
    void* pData,
    WORD* pcData
)
{
    DELETESTATUS status = DELETESTATUS_OTHER_ERROR;
    CBPTPageRef root;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);

    BTREE_INC_STAT(cDelete);
    
    if(!GetRootPage(pUmsClient,LOCK_MODE_IX,&root,&lockTreeRoot))
        goto lDone;
    
    if(root.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
    {
        status = DeleteRecursive(pUmsClient,&root,pKey,cbKey,true,pData,pcData);
        
        if(DELETESTATUS_OPTIMISTIC_RUN_FAILED == status)
        {
            BTREE_INC_STAT(cDeleteOptimisticFailed);
            
            root.Release(pUmsClient);
            lockTreeRoot.Release();
            
            if(!GetRootPage(pUmsClient,LOCK_MODE_SIX,&root,&lockTreeRoot))
                goto lDone;
        
            status = DeleteRecursive(pUmsClient,&root,pKey,cbKey,false,pData,
                pcData);
            
            if(status != DELETESTATUS_SUCCEEDED && 
               status != DELETESTATUS_NOT_FOUND)
            {
                goto lDone;
            }
        
            // Reduce the root if necessary
            if(root.GetPage()->_wEntryCount == 1 &&
               (root.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL))
            {
                // Convert the tree and the root locks to Xs. Unfortunatelly we 
                // can't just upgrade both of them without violating the 
                // down-right rule and therefore risking deadlocks. So the plan 
                // is to release root lock, upgrade the tree lock and 
                // re-acquire the root lock.
                
                root.Release(pUmsClient);

                if(!pUmsClient->UpgradeLockFromSIXtoX(&lockTreeRoot))
                    goto lDone;

                if(!GetPage(pUmsClient, _pidRoot, LOCK_MODE_X, &root))
                    goto lDone;

                // Reduce: the root's only child become the new root
                CBPTPageRef newroot;
                
                if(!GetChildPageFromParent(pUmsClient,&root,0,LOCK_MODE_X,&newroot))
                    goto lDone;
                    
                _pidRoot = newroot.GetPage()->pageId;
                newroot.Release(pUmsClient);

                // Delete the old root's page
                if(!DeletePage(pUmsClient, &root))
                    goto lDone;
            }
        }
    }
    else
    {
        WORD wIndex;
        
        if(!root.ReleaseAndAcquireLock(pUmsClient, LOCK_MODE_X))
            goto lDone; // TODO: fatal
        
        if(!root.GetPage()->GetEntryIndexLE(this,pKey,&wIndex))
        {
            status = DELETESTATUS_NOT_FOUND;
            goto lDone;
        }
        
        if(pData != NULL)
        {
            void* pEntryData;
            WORD  cbEntryData;
            
            root.GetPage()->GetEntry(this, wIndex, NULL, NULL, 
                (BYTE**)&pEntryData,&cbEntryData, NULL);
                
            CopyMemory(pData, pEntryData, __min(cbEntryData, *pcData));
            
            *pcData = cbEntryData;
        }
        
        root.GetPage()->RemoveEntry(this, wIndex);
        
        status = DELETESTATUS_SUCCEEDED;
    }
    
lDone:

    root.Release(pUmsClient);

    if(status != DELETESTATUS_SUCCEEDED &&
       status != DELETESTATUS_NOT_FOUND )
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}

BTree::DELETESTATUS BTree::DeleteRecursive(
    IUmsClient* pUmsClient,
    CBPTPageRef* pPage,
    void* pKey,
    WORD cbKey,
    bool fOptimistic,
    void* pData,
    WORD* pcData
)
{
    DBGASSERT(pPage->GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL);
    
    DELETESTATUS status = DELETESTATUS_OTHER_ERROR;
    CBPTPageRef child;
    WORD wIndex;
    
    bool fUpdateRef = pPage->GetPage()->GetEntryIndexLE(this,pKey,&wIndex);
    
    if(fUpdateRef)
    {
        if(!pPage->ReleaseAndAcquireLock(pUmsClient, LOCK_MODE_SIX))
            goto lDone;
    }
    
    if(!GetChildPageFromParent(pUmsClient, pPage, wIndex, 
        fOptimistic ? LOCK_MODE_IX : LOCK_MODE_SIX, &child))
    {
        goto lDone;
    }
    
    if(child.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
    {
        if(!fOptimistic && 
           (child.GetPage()->_wEntryCount <= 3 || child.GetPage()->_wAvailSpace >= _wConsiderMerge))
        {
            child.Release(pUmsClient);
            
            if(!MergeAndDelete(pUmsClient,pPage,wIndex,NULL,0))
                goto lDone;
            
            fUpdateRef = pPage->GetPage()->GetEntryIndexLE(this,pKey,&wIndex);
            
            if(fUpdateRef)
            {
                if(!pPage->ReleaseAndAcquireLock(pUmsClient, LOCK_MODE_SIX))
                    goto lDone;
            }
            
            if(!GetChildPageFromParent(pUmsClient, pPage, wIndex, LOCK_MODE_SIX, 
                &child))
            {
                goto lDone;
            }
        }
        
        status = DeleteRecursive(pUmsClient,&child,pKey,cbKey,fOptimistic,pData,
            pcData);
        
        if(status != DELETESTATUS_SUCCEEDED)
            goto lDone;
            
        pPage->GetPage()->DecSizeSubtree(wIndex);    
    }
    else
    {
        if(child.GetPage()->_wEntryCount == 1 || child.GetPage()->_wAvailSpace >= _wConsiderMerge)
        {
            WORD wDataIndex;

            if(!child.GetPage()->GetEntryIndexLE(this,pKey,&wDataIndex))
            {
                status = DELETESTATUS_NOT_FOUND;
                goto lDone;
            }

            if(fOptimistic)
            {
                status = DELETESTATUS_OPTIMISTIC_RUN_FAILED;
                goto lDone;
            }
            
            if(pData != NULL)
            {
                void* pEntryData;
                WORD  cbEntryData;
                
                child.GetPage()->GetEntry(this, wDataIndex, NULL, NULL, 
                    (BYTE**)&pEntryData, &cbEntryData, NULL);
                    
                CopyMemory(pData, pEntryData, __min(cbEntryData, *pcData));
                
                *pcData = cbEntryData;
            }
            
            child.Release(pUmsClient);
            
            if(!MergeAndDelete(pUmsClient,pPage,wIndex,pKey,cbKey))
                goto lDone;
                
            fUpdateRef = false;
        }
        else
        {
            if(!child.ReleaseAndAcquireLock(pUmsClient,LOCK_MODE_X))
                goto lDone;

            DBGASSERT(child.GetPage()->_wEntryCount > 1);
            
            WORD wDataIndex;
            
            if(!child.GetPage()->GetEntryIndexLE(this,pKey,&wDataIndex))
            {
                status = DELETESTATUS_NOT_FOUND;
                goto lDone;
            }
            
            if(pData != NULL)
            {
                void* pEntryData;
                WORD  cbEntryData;
                
                child.GetPage()->GetEntry(this, wDataIndex, NULL, NULL, 
                    (BYTE**)&pEntryData, &cbEntryData, NULL);
                    
                CopyMemory(pData, pEntryData, __min(cbEntryData, *pcData));
                
                *pcData = cbEntryData;
            }
            
            child.GetPage()->RemoveEntry(this,wDataIndex);
            pPage->GetPage()->DecSizeSubtree(wIndex);
        }
    }
    
    if(fUpdateRef)
    {
        child.Release(pUmsClient);
        
        BTREE_INC_STAT(cDeleteReReference);
        
        UpdateReference(pUmsClient,pPage,wIndex);
    }
    
    status = DELETESTATUS_SUCCEEDED;
    
lDone:

    child.Release(pUmsClient);
    
    if(status != DELETESTATUS_SUCCEEDED &&
       status != DELETESTATUS_NOT_FOUND && 
       status != DELETESTATUS_OPTIMISTIC_RUN_FAILED )
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }
    
    return status;
}

bool BTree::UpdateReference(
    IUmsClient* pUmsClient,
    CBPTPageRef* pParent,
    WORD wChildIndex
)
{
    bool fRet = false;
    CBPTPageRef child;
    
    // UpdateReference must be called with a SIX lock on pParent.
    DBGASSERT(pParent->GetCurrentLockMode() == LOCK_MODE_SIX);
    
    // Lock parent and child
    if(!pParent->UpgradeLockFromSIXtoX(pUmsClient))
        goto lDone;
    
    if(!GetChildPageFromParent(pUmsClient,pParent,wChildIndex,LOCK_MODE_IS,
        &child))
    {
        goto lDone;
    }

    // Update reference by removing previous reference and adding a new 
    // reference
    RemoveChildReferenceFromParent(pParent,&child);
    
    if(!AddChildReferenceToParent(pParent,&child))
        goto lDone;
        
    fRet = true;
        
lDone:

    child.Release(pUmsClient);
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}
    
// Get page references to a page and it's immediate siblings given the pid of
// the page
bool BTree::GetChildAndSiblings(
    IUmsClient* pUmsClient,
    BM_PAGEID pidChild,
    CBPTPageRef* plsib,
    CBPTPageRef* pchild,
    CBPTPageRef* prsib
)
{
    bool fRet = false;
    CBPTPageRef childref;
    
    // We need to get lsib, child and rsib in this order. The order is 
    // really important to avoid deadlocks. It also makes it extremely tricky
    // because we will not know who lsib is until we get child. So the plan is 
    // to get child, find out who lsib is, release child, get lsib and then 
    // get child. If they don't match (because of a racing condition, hopefully)
    // we drop everything and start from scratch
    
    const int MaxTries = 5; 
    
	int iTry;
    for(iTry=0; iTry < MaxTries; iTry++)
    {
        BM_PAGEID pidlsib = 0;
        
        // Get Child just so we can figure out who lsib is
        if(!GetPage(pUmsClient, pidChild, LOCK_MODE_SIX, &childref))
            goto lDone;
            
        pidlsib = childref.GetPage()->_pidLLink;
        
        // Release child. Let's try to get lsib and child in order
        childref.Release(pUmsClient);
        
        if(pidlsib != 0)
        {
            if(!GetPage(pUmsClient, pidlsib, LOCK_MODE_X, plsib))
                continue; // Retry 
        }
            
        if(!GetPage(pUmsClient, pidChild, LOCK_MODE_X, pchild))
            goto lDone;
        
        if(pchild->GetPage()->_pidLLink != pidlsib)
        {
            // Race condition (hopefully)
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "pchild->GetPage()->_pidLLink != plsib->GetPage()->pageId");
                
            pchild->Release(pUmsClient);
            plsib ->Release(pUmsClient);
            continue;
        }
        
        // The hard part is over. We don't need fancy tricks to get rsib
        if(pchild->GetPage()->_pidRLink != 0)
        {
            if(!GetPage(pUmsClient, pchild->GetPage()->_pidRLink, LOCK_MODE_X, prsib))
                goto lDone;
        }

        // If we got here, we're done
        break;
    }
    
    if(MaxTries == iTry)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Failed too many times to get a consistent read. It cannot be "
            "because of racing conditions. We must have bad data somewhere. ");
        goto lDone;
    }
    
    fRet = true;
    
lDone:

    childref.Release(pUmsClient);
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "pidChild = %u", (DWORD)pidChild);
            
        plsib ->Release(pUmsClient);
        pchild->Release(pUmsClient);
        prsib ->Release(pUmsClient);
    }

    return fRet;
}

bool BTree::MergeAndDelete(
    IUmsClient* pUmsClient,
    CBPTPageRef* pParent,
    WORD wChildIndex,
    void* pKey,
    WORD cbKey
)
{
    DBGASSERT(pParent->GetCurrentLockMode() == LOCK_MODE_SIX);
    
    bool fRet = false;
    CBPTPageRef lsib;
    CBPTPageRef child;
    CBPTPageRef rsib;
    BM_PAGEID pidChild = 0;
    
    // Upgrade parent's lock
    if(!pParent->UpgradeLockFromSIXtoX(pUmsClient))
        goto lDone;
    
    // Get the page id of the child
    if(!GetChildPageFromParent(pUmsClient,pParent,wChildIndex,LOCK_MODE_SIX,&child))
        goto lDone;
        
    pidChild = child.GetPage()->pageId;
    
    child.Release(pUmsClient);
    
    // Get the child and siblings
    if(!GetChildAndSiblings(pUmsClient,pidChild,&lsib,&child,&rsib))
        goto lDone;
        
    DBGASSERT(!lsib.IsNull() || !rsib.IsNull());
    
    // Remove key if applicable
    if(pKey != NULL)
    {
        if(child.GetPage()->_wEntryCount == 1)
        {
            // If it's the last entry of the page, remove the page altogether.
            // First fix the links of lsib and rsib. We have:
            //        ->       ->
            //   lsib    child    rsib
            //        <-       <-
            // 
            // And we want:
            //
            //        ->       
            //   lsib    rsib
            //        <-       
            
            if(!lsib.IsNull())
                lsib.GetPage()->_pidRLink = rsib.IsNull() ? 0 : rsib.GetPage()->pageId;
                
            if(!rsib.IsNull())
                rsib.GetPage()->_pidLLink = lsib.IsNull() ? 0 : lsib.GetPage()->pageId;
            
            // Remove the reference to child from parent
            RemoveChildReferenceFromParent(pParent,&child);
            
            // Delete the page used by child
            if(!_pBM->DeletePage(pUmsClient,child.GetPage()->pageId))
                goto lDone; 
                                
            child.Release(pUmsClient);
        }
        else
        {
            // Just remove the specific entry
            WORD wIndex;
            if(!child.GetPage()->GetEntryIndexLE(this,pKey,&wIndex))
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }
            
            child.GetPage()->RemoveEntry(this,wIndex);
        }
    }
    
    if(!child.IsNull())
    {
        if( wChildIndex > 0 &&  // Has a left sibling from the same parent
            lsib.GetPage()->GetUsedSpace() + child.GetPage()->GetUsedSpace() < child.GetPage()->GetMaxAvailableSpace())
        {
            BTREE_INC_STAT(cDeleteLeftMerge);
            
            if(!MergeNodes(pUmsClient,pParent,&lsib,&child))
                goto lDone;
        }
        else if(
            wChildIndex < pParent->GetPage()->_wEntryCount-1 && // Has a right sibling from the same parent
            rsib.GetPage()->GetUsedSpace() + child.GetPage()->GetUsedSpace() < child.GetPage()->GetMaxAvailableSpace())
        {
            BTREE_INC_STAT(cDeleteRightMerge);
            
            if(!MergeNodes(pUmsClient,pParent,&child,&rsib))
                goto lDone;
        }
        else if(
            wChildIndex > 0 &&  // Has a left sibling from the same parent
            lsib.GetPage()->GetUsedSpace() > child.GetPage()->GetUsedSpace())
        {
            BTREE_INC_STAT(cDeleteLeftBalance);
            
            CBPTPageRef* rgChildren[2];
            rgChildren[0] = &lsib;
            rgChildren[1] = &child;
            
            if(BalanceNodes(pUmsClient,pParent,rgChildren,2,0,NULL,
                0,NULL,0) != BALANCENODESSTATUS_SUCCEEDED)
            {
                goto lDone;
            }
        }
        else if(
            wChildIndex < pParent->GetPage()->_wEntryCount-1 && // Has a right sibling from the same parent
            rsib.GetPage()->GetUsedSpace() > child.GetPage()->GetUsedSpace())
        {
            BTREE_INC_STAT(cDeleteRightBalance);
            
            CBPTPageRef* rgChildren[2];
            rgChildren[0] = &child;
            rgChildren[1] = &rsib;
            
            if(BalanceNodes(pUmsClient,pParent,rgChildren,2,0,NULL,
                0,NULL,0) != BALANCENODESSTATUS_SUCCEEDED)
            {
                goto lDone;
            }
        }
        else
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
        }
    }
    
    fRet = true;
    
lDone:

    child.Release(pUmsClient);
    lsib .Release(pUmsClient);
    rsib .Release(pUmsClient);
        
    if(!fRet)            
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;    
}

bool BTree::MergeNodes(
    IUmsClient* pUmsClient,
    CBPTPageRef* pParent,
    CBPTPageRef* pChild1,
    CBPTPageRef* pChild2
)
{
    DBGASSERT(pChild1->GetPage()->GetUsedSpace() + pChild2->GetPage()->GetUsedSpace() < pChild1->GetPage()->GetMaxAvailableSpace());
    DBGASSERT(pChild1->GetPage()->_pidRLink == pChild2->GetPage()->pageId );
    
    bool fRet = false;
    CBPTPageRef rchildref;
    
    // Remove parent references for pChild1 and pChild2. We're going to move
    // data around dramatically and it's easier to remove the references now,
    // do the moving and adding new references
    if(pChild1->GetPage()->_wEntryCount > 0)
        RemoveChildReferenceFromParent(pParent,pChild1);
        
    if(pChild2->GetPage()->_wEntryCount > 0)
        RemoveChildReferenceFromParent(pParent,pChild2);
        
    // We're going to need the rightmost sibling of pChild2 when we remove it
    if(pChild2->GetPage()->_pidRLink != 0)
    {
        if(!GetPage(pUmsClient,pChild2->GetPage()->_pidRLink,LOCK_MODE_X,&rchildref))
            goto lDone;
    }
    
    // Move all data from pChild2 to pChild1
    for(DWORD j = 0; j < pChild2->GetPage()->_wEntryCount; j++)
    {
        if(!pChild2->GetPage()->CopyTo(this, (WORD)j, pChild1->GetPage()))
        {
            DBGASSERT(false);
            goto lDone;
        }
    }
    
    // Here is what we have:
    //           ->       ->
    //    pChild1  pChild2  rchildref
    //           <-       <-
    // 
    // We're going to delete pChild2, so we must update references in pChild1
    // and rchildref so we can have:
    //           ->
    //    pChild1  rchildref
    //           <-
    
    if(rchildref.IsNull())
    {
        pChild1->GetPage()->_pidRLink  = 0;
    }
    else
    {
        pChild1->GetPage()->_pidRLink  = rchildref.GetPage()->pageId;
        rchildref.GetPage()->_pidLLink = pChild1->GetPage()->pageId;
    }
    
    // pChild2 can now be deleted
    if(!DeletePage(pUmsClient,pChild2))
        goto lDone;
    
    // Re-reference child
    if(!AddChildReferenceToParent(pParent,pChild1))
        goto lDone; // TODO: fatal error            
        
    fRet = true;
        
lDone:

    rchildref.Release(pUmsClient);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

void BTree::DumpStats()
{
#if USE_BTREE_STATS

    printf("\n\n **** Dumping stats for btree %p ****\n", this);
    
    printf(
        "\ncInsert                 = %u"
        "\ncInsertOptimisticFailed = %u"    
        "\ncInsertSplit            = %u"
        "\ncDelete                 = %u"
        "\ncDeleteOptimisticFailed = %u"
        "\ncDeleteReReference      = %u"
        "\ncDeleteLeftBalance      = %u"
        "\ncDeleteRightBalance     = %u"
        "\ncDeleteLeftMerge        = %u"
        "\ncDeleteRightMerge       = %u",
        _stats.cInsert                ,
        _stats.cInsertOptimisticFailed,
        _stats.cInsertSplit           ,
        _stats.cDelete                ,
        _stats.cDeleteOptimisticFailed,
        _stats.cDeleteReReference     ,
        _stats.cDeleteLeftBalance     ,
        _stats.cDeleteRightBalance    ,
        _stats.cDeleteLeftMerge       ,
        _stats.cDeleteRightMerge);
        
    printf("\n\n **** End of stats for btree %p ****\n\n", this);

#endif
    
}

// Dump (send to trace callback) stats about memory utilization of the b-tree
bool BTree::DumpMemoryStats(IUmsClient* pUmsClient, ITraceCallback* pOut)
{
    bool fRet = false;
    TEasyList<BM_PAGEID> queue;
    CBPTPageRef rootref;
    CBPTPageRef pageRef;
    CBPTPageRef childPageRef;
    BM_PAGEID pid;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);

    // Counters
    #define DMSFS() \
        DMSF(INT64  ,cpagint    ,"%I64d", "Total internal nodes")               \
        DMSF(INT64  ,centint    ,"%I64d", "Total entries in internal nodes")    \
        DMSF(INT64  ,cbyteint   ,"%I64d", "Total bytes in internal nodes")      \
        DMSF(INT64  ,cpagext    ,"%I64d", "Total external nodes ")              \
        DMSF(INT64  ,centext    ,"%I64d", "Total entries in external nodes")    \
        DMSF(INT64  ,cbyteext   ,"%I64d", "Total bytes in external nodes")      \
        DMSF(INT64  ,cpagebyte  ,"%I64d", "Total bytes consumed by all pages")  \
        DMSF(INT64  ,cpage      ,"%I64d", "Total pages")                        \
        DMSF(INT64  ,cbytes     ,"%I64d", "Total bytes")                        \
        DMSF(INT64  ,cempty     ,"%I64d", "Total empty space")                  \
        DMSF(INT64  ,coverh     ,"%I64d", "Total overhead")                     \
        DMSF(INT64  ,cdata      ,"%I64d", "Total data")                         \
        DMSF(double ,perdata    ,"%.2f" , "Percentage of data stored")          \
        DMSF(double ,peroverh   ,"%.2f" , "Percentage of overhead")             \
        DMSF(double ,perempty   ,"%.2f" , "Percentage of empty space")          \
        DMSF(double ,aventint   ,"%.2f" , "Avg entries in internal nodes")      \
        DMSF(double ,avbyteint  ,"%.2f" , "Avg bytes in internal nodes")        \
        DMSF(double ,aventext   ,"%.2f" , "Avg entries in external nodes")      \
        DMSF(double ,avbyteext  ,"%.2f" , "Avg bytes in external nodes")        \
        // End of DMSFS()
    
    // declare fields
    #define DMSF(type, field, fmt, desc) \
        type field;
    
    struct {
        DMSFS()
    } s;

    #undef DMSF
    
    ZeroMemory(&s, sizeof(s));
    
    if(!queue.Init("tempqueue", 1, true, &g_MemAlloc))
        goto lDone;
    
    // Get exclusive access to the tree first
    if(!GetRootPage(pUmsClient, LOCK_MODE_X, &rootref,&lockTreeRoot))
        goto lDone;
    
    // Queue the root 
    if(!queue.Enqueue(_pidRoot))
        goto lDone;

    // Breadth first traversal: get next item from the queue, process it 
    // and insert all its children in the queue. Repeat until the queue is 
    // empty.
    while(queue.Dequeue(&pid))
    {
        if(!GetPage(pUmsClient,pid,LOCK_MODE_IS,&pageRef))
            goto lDone;
        
        if(pageRef.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            s.cpagint++;
            s.centint  += pageRef.GetPage()->_wEntryCount;
            s.cbyteint += pageRef.GetPage()->GetUsedSpace();
        }
        else
        {
            s.cpagext++;
            s.centext  += pageRef.GetPage()->_wEntryCount;
            s.cbyteext += pageRef.GetPage()->GetUsedSpace();
        }

        if(pageRef.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            for(DWORD i=0; i < pageRef.GetPage()->_wEntryCount; i++)
            {
                if(!GetChildPageFromParent(pUmsClient,&pageRef,(WORD)i,LOCK_MODE_IS,&childPageRef))
                    goto lDone;
                
                if(!queue.Enqueue(childPageRef.GetPage()->pageId))
                    goto lDone;
                    
                childPageRef.Release(pUmsClient);
            }
        }
        
        pageRef.Release(pUmsClient);
    }

    // Calculate remaining stats from the information we gathered
    s.cpage     = s.cpagint + s.cpagext;
    s.cpagebyte = (s.cpage * ((INT64)_pBM->GetPageSize()));
    s.cbytes    = s.cbyteint + s.cbyteext;
    s.coverh    = (s.cpage * BPTPage::GetHeaderSize()) + ((s.centint + s.centext) * BPTPage::GetEntryOverhead());
    s.cdata     = s.cbytes - s.coverh;
    s.cempty    = s.cpagebyte - s.coverh - s.cdata;
    s.aventint  = ((double)s.centint)  / ((double)s.cpagint);
    s.avbyteint = ((double)s.cbyteint) / ((double)s.cpagint);
    s.aventext  = ((double)s.centext)  / ((double)s.cpagext);
    s.avbyteext = ((double)s.cbyteext) / ((double)s.cpagext);
    s.perdata   = ((double)s.cdata)    / (double)((s.cpage * ((INT64)_pBM->GetPageSize()))) * 100;
    s.peroverh  = ((double)s.coverh)   / (double)((s.cpage * ((INT64)_pBM->GetPageSize()))) * 100;
    s.perempty  = ((double)s.cempty)   / (double)((s.cpage * ((INT64)_pBM->GetPageSize()))) * 100;
    
    // Dump stats
    #define DMSF(type, field, fmt, desc) \
        TraceCallbackFormattedWrite(pOut, "\n%-10s = "fmt, #field, s.field);
    
    TraceCallbackFormattedWrite(pOut, 
        "\n****"
        "\n**** Stats for tree %p"
        "\n****\n",
        this);

    DMSFS();

    TraceCallbackFormattedWrite(pOut, 
        "\n\n****"
        "\n**** End of Stats for tree %p"
        "\n****\n",
        this);

    #undef DMSF
    #undef DMSFS
    
    fRet = true;
    
lDone:

    // Clean up
    rootref     .Release(pUmsClient);
    pageRef     .Release(pUmsClient);
    childPageRef.Release(pUmsClient);
    queue       .Term();
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        pOut->Write(CGlobalError::GetCurrentMessage());
    }
        
    return fRet;
}

bool BTree::Verify(
    IUmsClient* pUmsClient
)
{
    bool fRet = false;
    
    UMSSafeLockCookie lockTree(pUmsClient);
    CBPTPageRef pageref;
    BM_PAGEID pid;
    
    TEasyList<BM_PAGEID> stack;
    
    if(!stack.Init("tempstack_verify",1,true,&g_MemAlloc))
        goto lDone;
    
    if(!GetRootPage(pUmsClient,LOCK_MODE_X,&pageref,&lockTree))
        goto lDone;
        
    if(!stack.Push(pageref.GetPage()->pageId))
        goto lDone;
        
    pageref.Release(pUmsClient);
        
    while(stack.Pop(&pid))
    {
        if(!GetPage(pUmsClient,pid,LOCK_MODE_X,&pageref))
            goto lDone;

        pageref.GetPage()->IntegrityCheck(this, (WORD)_pBM->GetPageSize());
        
        if(pageref.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            for(DWORD i=0; i < pageref.GetPage()->_wEntryCount; i++)
            {
                CBPTPageRef child;
                
                GetChildPageFromParent(pUmsClient,&pageref,(WORD)i, LOCK_MODE_X, &child); 
                
                if(!stack.Push(child.GetPage()->pageId))
                    goto lDone;
                    
                child.Release(pUmsClient);
            }
        }

        pageref.Release(pUmsClient);
    }
    
    fRet = true;
    
lDone:

    // Cleanup
    pageref.Release(pUmsClient);
    stack  .Term();
    
    return fRet;
}

// Dump the binary contents of the tree including internal pages to a trace
// callback interface. Each page is dumped in breadth first order starting with
// the root.
bool BTree::DumpTree(
    IUmsClient* pUmsClient, 
    ITraceCallback* pOut
)
{
    bool fRet = false;
    TEasyList<BM_PAGEID> queue;
    CBPTPageRef rootref;
    CBPTPageRef pageRef;
    CBPTPageRef childPageRef;
    BM_PAGEID pid;
    UMSSafeLockCookie lockTreeRoot(pUmsClient);
    
    if(!queue.Init("tempqueue", 1, true, &g_MemAlloc))
        goto lDone;
    
    // Get exclusive access to the tree first
    if(!GetRootPage(pUmsClient, LOCK_MODE_X, &rootref,&lockTreeRoot))
        goto lDone;
    
    TraceCallbackFormattedWrite(pOut, "\n>>>>> Dumping tree %p\n\n", (void*)this);
    
    // Queue the root 
    if(!queue.Enqueue(_pidRoot))
        goto lDone;
    
    // Breadth first traversal: get next item from the queue, process it (dump)
    // and insert all its children in the queue. Repeat until the queue is 
    // empty.
    while(queue.Dequeue(&pid))
    {
        if(!GetPage(pUmsClient,pid,LOCK_MODE_IS,&pageRef))
            goto lDone;
        
        DumpPage(pOut, pageRef.GetPage());
        
        if(pageRef.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
        {
            for(DWORD i=0; i < pageRef.GetPage()->_wEntryCount; i++)
            {
                if(!GetChildPageFromParent(pUmsClient,&pageRef,(WORD)i,LOCK_MODE_IS,&childPageRef))
                    goto lDone;
                
                if(!queue.Enqueue(childPageRef.GetPage()->pageId))
                    goto lDone;
                    
                childPageRef.Release(pUmsClient);
            }
        }
        
        pageRef.Release(pUmsClient);
    }

    TraceCallbackFormattedWrite(pOut, "\n>>>>> End of tree %p\n\n", (void*)this);

    fRet = true;
    
lDone:

    // Clean up
    rootref     .Release(pUmsClient);
    pageRef     .Release(pUmsClient);
    childPageRef.Release(pUmsClient);
    queue       .Term();
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        pOut->Write(CGlobalError::GetCurrentMessage());
    }
        
    return fRet;
}

//Given a key - dump the binary of every node in the search path
bool BTree::DumpTreePath( IUmsClient*       pUmsClient, 
                          ITraceCallback*   pOut, 
                          void*             pKey,
                          WORD              cbKey)
{
	BTree::Iterator it;
	SEARCHSTATUS searchStatus = SearchEx(pUmsClient,
        								 pKey,
        								 cbKey,
       	 								 false,
        								 &it,
        								 true,
        								 pOut
   							 			 );

    //TODO: we can dump out the searchStatus
    return (searchStatus != SEARCHSTATUS_OTHER_ERROR);
}

// Dump the entries of a page to a trace callback interface
void BTree::DumpPage(
    ITraceCallback* pOut, 
    BPTPage* pPage)
{
    TraceCallbackFormattedWrite(
        pOut, 
        "\n\n********* Page: %u"
        "\n* _pidLLink=%d"
        "\n* _pidRLink=%d\n\n",
        pPage->pageId,
        pPage->_pidLLink,
        pPage->_pidRLink);
                                  
    for(DWORD i=0; i < pPage->_wEntryCount; i++)
    {
        BYTE* pKey;
        WORD  cbKey;
        BYTE* pData;
        WORD  cbData;
        
        pPage->GetEntry(this,(WORD)i,&pKey,&cbKey,&pData,&cbData,NULL);
        
        TraceCallbackFormattedWrite(
            pOut, "\n%4d(%d): ", 
            i, pPage->GetSizeSubtree((WORD)i));
        
        TraceCallbackWriteBinary(pOut, pKey, cbKey);
        TraceCallbackFormattedWrite(pOut, " ");
        TraceCallbackWriteBinary(pOut, pData, cbData);
    }
}


void BTree::DumpRawPage(
    ITraceCallback* pOut, WORD wChildIndex,
    BPTPage* pPage)
{
    if (pOut != NULL && pPage != NULL)
    {
        TraceCallbackWriteBinary(pOut, (BYTE *)&wChildIndex, sizeof(WORD));
        //dumping the whole page not only the header - 
        TraceCallbackWriteBinary(pOut, (BYTE *)pPage, pPage->_wPageSize); 
    }
}

/*****************************************************************************
  BTree::Iterator
*****************************************************************************/
void BTree::Iterator::Init(
    IUmsClient* pUmsClient,
    BTree* pBTree,
    CBPTPageRef* pPageRef, 
    WORD wNodeNdx,
    DWORD dwRank
)
{
    DBGASSERT(_pageref.IsNull());
    
    _pControl     = pUmsClient;
    _pBTree       = pBTree;
    _pageref      = *pPageRef;
    _wNodeNdx     = wNodeNdx;
    _dwRank       = dwRank;
    _fFirstRead   = true;
}

void BTree::Iterator::Get(
    void** ppKey, 
    WORD* pcbKey, 
    void** ppData, 
    WORD* pcbData
)
{
    DBGASSERT(!_pageref.IsNull());
    DBGASSERT(_wNodeNdx < _pageref.GetPage()->_wEntryCount);
    DBGASSERT(!_fFirstRead);
    
    _pageref.GetPage()->GetEntry(_pBTree,_wNodeNdx,(BYTE**)ppKey,pcbKey,
        (BYTE**)ppData,pcbData,NULL);
}

bool BTree::Iterator::Read()
{
    if(_pageref.IsNull())
        return false;

        
    if(_fFirstRead)
    {
        _fFirstRead = false;
        //DBGASSERT(_wNodeNdx < _pageref.GetPage()->_wEntryCount);        
        if (_wNodeNdx < _pageref.GetPage()->_wEntryCount)
        {
            return true;
        }
        else if (_wNodeNdx == _pageref.GetPage()->_wEntryCount)
        {
            //The first time we are reading, it happens that the element is in the adjacent node.
            _wNodeNdx = _pageref.GetPage()->_wEntryCount - 1;
        }
        else
        {
            return false;
        }
    }
    if(_wNodeNdx == _pageref.GetPage()->_wEntryCount-1)
    {
        if(_pageref.GetPage()->_pidRLink != 0)
        {
            CBPTPageRef linkpageref;
            LOCK_MODE lmPrev = _pageref.GetCurrentLockMode();
            
            if(!_pBTree->GetPage(_pControl,_pageref.GetPage()->_pidRLink,lmPrev,&linkpageref))
                return false;
            
            DBGASSERT(_pageref.GetPage()->_wEntryCount > 0);
            
            _pageref.Release(_pControl);
            _pageref = linkpageref;
            
            linkpageref.Reset();
            
            _wNodeNdx = 0;
            _dwRank++;
            
            return true;
        }
        else
        {
            _pageref.Release(_pControl);
            return false;
        }
        
        _pageref.Release(_pControl);
    }
    else
    {
        _wNodeNdx++;
        _dwRank++;
        return true; 
    }
}

void BTree::Iterator::Reset()
{
    if(!_pageref.IsNull())
    {
        _pageref.Release(_pControl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\buffer.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * buffer.h
 * Header of leaderboard server buffer manager
 * Source: buffer.cpp
 * 
 */

#pragma once

#include "util.h"
#include "config.h"
#include "ums.h"

const DWORD BM_SIZE_PAGE_TABLE                   = 29959; // (prime)
const DWORD BM_PRIORITY_QUEUE_SIZE               = 10000;
const DWORD BM_NUMBER_OF_PRIORITY_QUEUES         = 5;
const DWORD BM_INITIAL_PAGE_INFO_ENTRY_POOL_SIZE = 1; // TODO: tweak
const DWORD BM_INITIAL_ALLOC_LIST_SIZE           = 1; // TODO: tweak
const DWORD BM_INITIAL_FREE_BUFFER_LIST_SIZE     = 1; // TODO: tweak
const DWORD BM_INITIAL_FREE_SLOT_LIST_SIZE       = 10000; // TODO: tweak
const DWORD BM_PAGE_DUMPS_PER_ROUND              = 100;

// This constant, when assigned to PAGE_INFO_ENTRY::dwFileSlotIndex.dwFileIndex,
// means that the page is new so don't bother trying to get it from disk
const DWORD BmNewPageSlotIndex                   = ~0; 


typedef DWORD BM_PAGEID;

struct BM_PAGE
{
    BM_PAGEID pageId;
};
 
class CBufferManager
{
public:
    
    USE_GLOBAL_ALLOC;
    
    CBufferManager();
    
    ~CBufferManager();
    
    // Init
    bool Init(
        CConfig* pConfig,
        UMS* pUMS,
        CPerfCounters* pPerfCounters
    );
    
    // Term
    void Term();
    
    DWORD GetPageSize() const { return _dwBufferManagerPageSize; }
    
    bool CreateNewPage(
        IN IUmsClient* pUmsClient, 
        IN UMSLockCookie* pLockPageCookie,
        OUT BM_PAGE** ppPage
    );
    
    bool DeletePage(
        IN IUmsClient* pUmsClient,
        IN BM_PAGEID pageId
    );
    
    bool GetPage(
        IN IUmsClient* pUmsClient, 
        IN BM_PAGEID pageId,
        IN LOCK_MODE lm,
        OUT BM_PAGE** ppPage,
        OUT UMSLockCookie* pLockCookie
    );
    
    bool AcquirePageLock(
        IN IUmsClient* pUmsClient,
        IN BM_PAGEID pageId,
        IN LOCK_MODE lm,
        OUT UMSLockCookie* pCookie
    );
    
    static LOCK_ID GetLockIdForPageId(BM_PAGEID pid)
    {
        LOCK_ID lid = { LOCK_TYPE_PAGE, pid };
        return lid;
    }

    bool DumpStats(
        ITraceCallback* pOut
    );
    
protected:

    // Get the current access counter and also increment it
    INLINE DWORD GetAccessCounter()
    {
        // Pages don't have to get unique access counters. We don't have to
        // bother using Interlocked functions to do the increment.
        return _dwAccessCounter++;
    }

    BYTE* AllocPageBuffer();
    
    bool RequestPageRead(BM_PAGEID pageId);
    
    void DistributeBuffers();
    
    void DumpPage(
        BM_PAGEID pageId 
    );
    
    bool ReadPageFromDisk(
        DWORD dwFileSlot, 
        BYTE* pPageBuffer
    );
    
    static DWORD StaticThreadProc(LPVOID pRawThis);
    
    void ThreadProc();
    
    struct PAGE_INFO_ENTRY 
    {
        // Page identifier
        BM_PAGEID pageId; 

        // Pointer to next entry
        PAGE_INFO_ENTRY* pNext;
        
        // Pointer to the page buffer itself if the page is not in disk, in
        // which case, this will be NULL
        BM_PAGE* pPage;
            
        union
        {
            struct
            {
                // Last access counter. This is assigned by CBufferManager and 
                // will be used to prioritize which pages should stay in memory
                // and which pages should be dumped to disk
                DWORD dwLastAccess;
                
                // Index in the priority queue. It's needed if we want to 
                // be able to remove the entry from the queue at any time in 
                // an efficient way
                DWORD dwPriQueueIndex;
            } 
            inMemory;
            
            struct
            {
                // The slot index in the file where this page is being stored
                DWORD dwFileSlotIndex;
            } 
            inDisk;
        };
        
        
        PAGE_INFO_ENTRY() :
            pageId(0),
            pPage(NULL),
            pNext(NULL)
        {}
    };
    
    struct PAGE_INFO_SLOT
    {
        USE_GLOBAL_ALLOC;
            
        PAGE_INFO_ENTRY* pNext;
        
        PAGE_INFO_SLOT() : pNext(NULL) {}
    };
    
    struct PAGE_BUFFER : public CSingleLink
    {
    };
    
    struct WaitingPage : public CSingleLink
    {
        USE_GLOBAL_ALLOC; // TODO: pool
        
        BM_PAGEID pageid;
        UMSLockCookie pageLock;
    };

    // Page priority queue. It will be used to prioritize which page stays 
    // in memory and which get dumped to disk. It also comes with a lock that
    // will be used to control access to both the priority queue and the page
    // table
    struct PagePriorityQueue
    {
        USE_GLOBAL_ALLOC;
    
        CFastLock lock;
        THeap<
            PAGE_INFO_ENTRY*, 
            BM_PRIORITY_QUEUE_SIZE, 
            PagePriorityQueue,
            PagePriorityQueue> _priqueue;
    
        // Release resources
        void Term()
        {
            _priqueue.Term();
        }
        
        // Used by _priqueue to sort pages by their last access in a way that
        // least accessed pages go to the top of the queue
        INLINE static int HeapCompare(PAGE_INFO_ENTRY* p1, PAGE_INFO_ENTRY* p2)
        {
            DBGASSERT(p1->pPage != NULL && p2->pPage != NULL);
            return WrapDWORDCompare(
                p1->inMemory.dwLastAccess,
                p2->inMemory.dwLastAccess,
                NULL
            );
        }
        
        // Used by _priqueue to update the page's dwPriQueueIndex
        INLINE static void OnHeapNewPosition(PAGE_INFO_ENTRY* p, DWORD nNewPos)
        {
            DBGASSERT(p->pPage != NULL);
            p->inMemory.dwPriQueueIndex = nNewPos;
        }
    };

    // Configuration object
    CConfig* _pConfig;
    
    // UMS
    UMS* _pUMS;
    
    // Size of buffer manager memory pages
    DWORD _dwBufferManagerPageSize;
    
    // Maximum memory we're allowed to allocated
    ULONGLONG _ullMaximumPhysicalMemory;
    
    // Based on _ullMaximumPhysicalMemory and on _dwVirtualAllocSize, this 
    // is the maximum number of memory allocations.
    DWORD _dwMaxAllocations;
    
    // Maximum number of pages that will be allocated and handed out. If zero,
    // the maximum is dictated by _dwMaxAllocations instead. This is only used
    // for debugging purposes.
    DWORD _dwMaxPages;
    
    // Size of physical memory pages
    DWORD _dwPhysicalMemoryPageSize; 
    
    // Size of memory chunks we're going to alloc with VirtualAlloc
    DWORD _dwVirtualAllocSize;
    
    // Page Id of the last page created. Used to create new page ids.
    DWORD _dwLastPageId;
    
    // List of VirtualAlloc allocations
    TEasyLFStack<BYTE> _allocList;
    
    // List of available page buffers
    TLFStack<PAGE_BUFFER> _freePageBufferList;
    
    // Page table - maps page ids to corresponding pages
    PAGE_INFO_SLOT* _pageTable;
    
    // Memory pool for PAGE_INFO_ENTRY objects
    CFixedSizeMemPool _poolPageInfoEntry;
    
    // Priority queues will be used to prioritize which page stays in memory
    // and which get dumped to disk. They also have the locks that will be
    // used to access _pageTable
    PagePriorityQueue* _prgPriQueues;    
    
    // A global counter that will be used to classify pages by last usage. 
    // We'll just increment it with every page requested and update the page's
    // own counter with it. 
    volatile DWORD _dwAccessCounter; 
    
    // UMS client for the Paging thread
    IUmsClient* _pCtrl;
    
    // Control access to _pCtrl
    CFastLock _lockCtrl;
    
    // Queue of pages requested to be retrieved from disk
    CLFQueue _pageRequests;
    
    // Handle of the thread that will take care of paging
    HANDLE _hPagingThread;
    
    // Event to wake up paging thread
    HANDLE _hPagingThreadWakeUp;
    
    // Flag to indicate that paging thread should shutdown
    volatile LONG _fPagingThreadShutdown;
    
    // Paging file. This is where we dump the pages.
    HANDLE _hPagingFile;
    
    // Total number of slots allocated in the file
    DWORD _dwPagingFileTotalSlots;
    
    // Slots in the file that have been freed and are now available
    TArray<DWORD, 1> _freeSlots;

    // Total number of active pages including pages in disk but not pages 
    // in the free list
    volatile UINT32 _uiPageCount;

    // Total number of pages in disk
    volatile UINT32 _uiPageInDiskCount;

    CPerfCounters* _pPerfCounters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\config.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 *
 * Leaderboard Server
 *
 * config.cpp
 * Implementation of leaderboard server configuration
 * Source: config.cpp
 *
 */

#include "lbs.h"

bool CConfig::LoadConfig()
{
    bool fRet = false;
    CComPtr<XblConfig::IConfig> pIConfig = NULL;
    CComBSTR bstr;
    HRESULT hr;

    // Get computer name
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    szComputerName[0]='\0';
    DWORD cchComputerName = ARRAY_SIZE(szComputerName);

    if(!GetComputerNameW(szComputerName, &cchComputerName))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "GetComputerNameW failed. error=%u", GetLastError());
        goto lDone;
    }
    _computerName.Assign(szComputerName);

    // Create instance of common config class
    if(FAILED(hr = pIConfig.CoCreateInstance( __uuidof( XblConfig::ConfigInterop ))))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig.CoCreateInstance failed. hr=0x%08x", hr);
        goto lDone;
    }

    // Get environment name
    if(FAILED(hr = pIConfig->get_Environment(&bstr)))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig->get_Environment failed. hr=0x%08x", hr);
        goto lDone;
    }
    _environment.Assign(bstr);

    // Load interface
    if(!LoadInterface(pIConfig))
        goto lDone;

    // Load config sql interface
    if(!LoadConfigSqlInterface(pIConfig))
        goto lDone;

    if (!LoadWebStoreSqlInterface(pIConfig))
        goto lDone;

    // Settings
    if(!LoadWStr(pIConfig, Setting_lbsvr_FullNamePagingFile,
        "lbsvr_FullNamePagingFile", &_fullNamePagingFile))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_0, "Page File Location: %ws", GetFullNamePagingFile()->cstr());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_BufferManagerPageSize,
        "lbsvr_BufferManagerPageSize", (UINT32 *)&_dwBufferManagerPageSize))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_1, "Buffer Manager Page Size: %u", GetBufferManagerPageSize());   

    if(!LoadUINT32(pIConfig, Setting_lbsvr_VirtualAllocSize,
        "lbsvr_VirtualAllocSize", (UINT32 *)&_dwVirtualAllocSize))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_2, "Virtual Alloc Size: %u", GetVirtualAllocSize());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_ReservedPhysicalMemory,
        "lbsvr_ReservedPhysicalMemory", (UINT32 *)&_dwReservedPhysicalMemory))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_3, "Reserved Physical Memory: %u", GetReservedPhysicalMemory());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_IOThreadCount,
        "lbsvr_IOThreadCount", (UINT32 *)&_dwIOThreadCount))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_4, "IO Thread Count: %u", GetIOThreadCount());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_SizeRcvBuffer,
        "lbsvr_SizeRcvBuffer", (UINT32 *)&_dwSizeRcvBuffer))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_5, "Net Receive Buffer Size: %u", GetSizeRcvBuffer());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_SizeSndBuffer,
        "lbsvr_SizeSndBuffer", (UINT32 *)&_dwSizeSndBuffer))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_6, "Net Send Buffer Size: %u", GetSizeSndBuffer());
	

    if(!LoadUINT32(pIConfig, Setting_lbsvr_MaxCSndBuffer,
        "lbsvr_MaxCSndBuffer", (UINT32 *)&_dwMaxCSndBuffer))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_7, "Net Max Receive Buffer: %u", GetMaxCSndBuffer());

    if(!LoadUINT32(pIConfig, Setting_lbsvr_NetHelloTimeout,
        "lbsvr_NetHelloTimeout", (UINT32 *)&_dwNetHelloTimeout))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_8, "Net Hello Time Out: %u", GetNetHelloTimeout());    	

     if(!LoadUINT32(pIConfig, Setting_lbsvr_PersisterRetryInterval,
        "lbsvr_PersisterRetryInterval", (UINT32 *)&_dwPersisterRetryInterval))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_9, "DB Retry Interval: %u", GetPersisterRetryInterval());    

    if(!LoadUINT32(pIConfig, Setting_lbsvr_DbLoadingThreadCount,
        "lbsvr_DbLoadingThreadCount", (UINT32 *)&_dwLoadingThread))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_10, "Number of Concurrent Loading Thread: %u", GetNumberOfLoadingThread());    

    if(!LoadUINT32(pIConfig, Setting_lbsvr_NetMaxConnections,
        "lbsvr_NetMaxConnections", (UINT32 *)&_lMaxConnections))
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_11, "Maximum Inet Connections Allowed: %d", GetMaxInetConnections());    

    if(!LoadUINT32(pIConfig, Setting_lbsvr_JobResetHour,
        "lbsvr_JobResetHour", (UINT32 *)&_dwResetHour)) 
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_12, "Reset Hour: %u", GetResetHour());    

    if(!LoadUINT64(pIConfig, Setting_lbsvr_PagingFileInitialSize,
        "lbsvr_PagingFileInitialSize", (UINT64 *)&_ullPagingFileInitialSize)) 
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_13, "Initial Paging File Size: %I64u", GetPagingFileInitialSize());    

    if(!LoadUINT32(pIConfig, Setting_lbsvr_DatabaseWriteThreads,
        "lbsvr_DatabaseWriteThreads", (UINT32 *)&_dwDatabaseWriteThread)) 
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_STATS_INFO_26, "Database Write Thread: %u", GetDataBaseWriteThreads()); 

    if(!LoadUINT32(pIConfig, Setting_lbsvr_DbLoadRetryCount,
        "lbsvr_DbLoadRetryCount", (UINT32 *)&_dwDbLoadNumRetry)) 
    {
        goto lDone;
    }

    XomNtEvent(XEVENT_LBSVR_DB_LOAD_NUM_RETRY_SETTING, "DB Load Retry Count: %u", GetDBLoadNumRetry()); 

    if(!LoadUINT32(pIConfig, Setting_lbsvr_DbLoadIntervalSeconds,
        "lbsvr_DbLoadIntervalSeconds", (UINT32 *)&_dwDbRetryIntervalSeconds)) 
    {
        goto lDone;
    }    

    XomNtEvent(XEVENT_LBSVR_DB_LOAD_INTERVAL_SECONDS_SETTING, "DB Load Interval Seconds: %u", GetDBRetryIntervalSeconds()); 

    
    // TODO: validation

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}


bool CConfig::LoadLbInfo(
    CArenaMemAlloc* pAlloc,
    TList<ConfigLbInfo>* pList
)
{
    static CWSProcCache pc;
    return LoadLbInfoCommon(pAlloc, pList, &pc, L"p_stats_lb_get_all %64W", _computerName.cstr());
}

bool CConfig::LoadLbInfoForOneTitle(
    CArenaMemAlloc* pAlloc,
    TList<ConfigLbInfo>* pList,
    DWORD dwTitleID,
    UINT32 *pLbCountProcessed
)
{
    static CWSProcCache pc;
    return LoadLbInfoCommon(pAlloc, pList, &pc, L"p_stats_get_all_lb_for_title %I, %64W", dwTitleID, _computerName.cstr());
}


bool CConfig::LoadLbInfoCommon(
    CArenaMemAlloc* pAlloc,
    TList<ConfigLbInfo>* pList,
    CWSProcCache *pPc,
    LPCWSTR pwszProc,
    ...
)
{
    bool fRet = false;
    HRESULT hr;
    CODBWSession sql;

    va_list arg_list;
    va_start(arg_list, pwszProc);

    if(FAILED(hr = sql.InitializeEx(_configSqlConnectionStr.cstr())))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to connect. sql.InitializeEx failed. hr=0x%08x", hr);
        goto lDone;
    }
    
	// Execute stored procedure
    if(FAILED(hr = sql.VCallProc(pPc, pwszProc, arg_list)))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Call to %ws Failed hr=0x%08x", pwszProc, hr);
        goto lDone;
    }

    struct LbInfo
    {
        UINT32 dwTitleId;
        UINT32 dwLbId;
        UINT32 lbReset;
        UINT32 fTop100;
        UINT32 uiDecayDays;
        DATE   dtLastReset;
    };

    // Bind rowset columns to the ConfigLbInfo struct
    static DBBINDING bind[] = {
        WSBIND(2, offsetof(LbInfo, dwTitleId)  , DBTYPE_I4,  0),
        WSBIND(3, offsetof(LbInfo, dwLbId)     , DBTYPE_I4,  0),
        WSBIND(4, offsetof(LbInfo, lbReset)    , DBTYPE_I4,  0),
        WSBIND(5, offsetof(LbInfo, fTop100)    , DBTYPE_I4,  0),
        WSBIND(8, offsetof(LbInfo, uiDecayDays), DBTYPE_I4,  0),
        WSBIND(15, offsetof(LbInfo, dtLastReset), DBTYPE_DATE,  0)
    };

    if(FAILED(hr = sql.SetBindings(bind, ARRAY_SIZE(bind))))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "sql.SetBindings failed. hr=0x%08x", hr);
        goto lDone;
    }

    // Process the rowset
    LbInfo dbLbInfo;
    for(;;)
    {
        ZeroMemory(&dbLbInfo, sizeof(dbLbInfo));

        DBCOUNTITEM cRows=1;

        // Read one row
        if(FAILED(hr = sql.GetRows(&cRows, &dbLbInfo, sizeof(dbLbInfo))))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "sql.GetRows failed. hr=0x%08x", hr);
            goto lDone;
        }

        if(cRows == 0)
            break;

        // Store the information in a ConfigLbInfo object. We're allocating
        // these objects using the arena allocator provided. There is no need
        // to worry about releasing memory.
        ConfigLbInfo* plbInfo = new (*pAlloc) ConfigLbInfo;
        if(NULL == plbInfo)
            goto lDone;

        plbInfo->dwTitleId    = dbLbInfo.dwTitleId;
        plbInfo->dwLbId       = dbLbInfo.dwLbId;
        plbInfo->lbReset      = dbLbInfo.lbReset;
        plbInfo->fTop100      = dbLbInfo.fTop100;
        plbInfo->uiDecayDays  = dbLbInfo.uiDecayDays;

        // Convert last-reset timestamp from OLEDB format to filetime
        SYSTEMTIME systime;
        ::VariantTimeToSystemTime(dbLbInfo.dtLastReset, &systime);
        ::SystemTimeToFileTime(&systime, reinterpret_cast<FILETIME*>(&plbInfo->lastReset));

        // Add ConfigLbInfo object to the list
        pList->Enqueue(plbInfo);
    }

    fRet = true;

lDone:

    va_end(arg_list);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CConfig::LoadInterface(
    XblConfig::IConfig* pIConfig
)
{
    bool fRet = false;
    CComPtr<XblConfig::IInterfaceInfo> pIInterfaceInfo = NULL;
    CComBSTR bstr;
    HRESULT hr;

    // Get interface information for this server
    bstr = _computerName.cstr();
    if(FAILED(hr = pIConfig->GetInterface(bstr,
        Interface_lbsvr, &pIInterfaceInfo)))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig->GetInterface failed. hr=0x%08x", hr);
        goto lDone;
    }

     // Get the IP we should bind to
     bstr.Empty();
     if(FAILED(hr = pIInterfaceInfo->get_IPAddressString(&bstr)))
     {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIInterfaceInfo->get_IPAddressString failed. hr = 0x%08x", hr);
        goto lDone;
     }

     // Convert the IP string
     if(!BstrToInaddr(bstr, &_inaNetListenAddr))
        goto lDone;

     // Get the port we should listen on
     long lPort = 0;
     if(FAILED(hr = pIInterfaceInfo->get_Port(&lPort)))
     {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIInterfaceInfo->get_IPAddressString failed. hr = 0x%08x", hr);
        goto lDone;
     }
     _dwNetListenPort = (DWORD)lPort;

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CConfig::LoadConfigSqlInterface(
    XblConfig::IConfig* pIConfig
)
{
    bool fRet = false;
    CComBSTR bstr;
    HRESULT hr;

    // Get the connection string of the config server
    if(FAILED(hr = pIConfig->get_NpdbConnectionString(&bstr)))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIconfig->get_NpdbConnectionString failed. hr = 0x%08x", hr);
        goto lDone;
    }

    _configSqlConnectionStr.Assign(bstr);

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CConfig::LoadWebStoreSqlInterface(
    XblConfig::IConfig* pIConfig
)
{
    bool fRet = false;
    CComPtr<XblConfig::IVirtualInterfaceInfo> pVirtualIInterfaceInfo = NULL;

    CComBSTR bstrWebStoreName;
    HRESULT hr;

    hr = pIConfig->get_SiteId(&_lSiteId);
    if (FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig->get_SiteId failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    hr = pIConfig->GetVirtualInterface(VirtualInterface_uodb, _lSiteId, &pVirtualIInterfaceInfo);
    if (FAILED(hr) || (NULL == pVirtualIInterfaceInfo))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig->GetVirtualInterface failed. hr=0x%08x", hr);
        goto lDone;
    }

    hr = pVirtualIInterfaceInfo->get_WebstoreApp(&bstrWebStoreName);
    if (FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pVirtualIInterfaceInfo->get_WebstoreApp failed. hr=0x%08x", hr);
        goto lDone;
    }

    _webstoreSqlDbName.Assign(bstrWebStoreName);

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}




bool CConfig::LoadWStr(
    XblConfig::IConfig* pIConfig,
    CComBSTR setting,
    LPCSTR pszSettingName,
    CWStr* pSetting
)
{
    bool fRet = false;
    HRESULT hr;
    CComBSTR strSetting;

    if(FAILED(hr = pIConfig->GetSetting(setting, &strSetting)))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "pIConfig->GetSetting failed. hr=0x%08x", hr);
        goto lDone;
    }

    if(strSetting == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Setting not found %s", pszSettingName);
        goto lDone;
    }
    else
    {
        if(!pSetting->Assign(strSetting))
            goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Failed to load setting %s(%ws)", pszSettingName, static_cast<wchar_t *> (setting));
    }

    return fRet;
}


bool CConfig::LoadStr(
    XblConfig::IConfig* pIConfig,
    CComBSTR setting,
    LPCSTR pszSettingName,
    CStr* pSetting
)
{
    bool fRet = false;
    CHAR* pszAnsiStr = NULL;
    CLargeWStr str;
    str.SetAutoGrow(true);

    if(!LoadWStr(pIConfig,setting,pszSettingName,&str))
        goto lDone;

    // Convert unicode string to ASCII
    if(str.GetLength() == 0)
    {
        pSetting->Reset();
        fRet = true;
        goto lDone;
    }

    int cchMaxAnsiStr = str.GetLength()+1;

    pszAnsiStr = (CHAR*) g_MemAlloc.Alloc(sizeof(CHAR) * cchMaxAnsiStr);

    if(NULL == pszAnsiStr)
        goto lDone;

    if(WideCharToMultiByte(CP_ACP, 0, str.cstr(), str.GetLength(),
        pszAnsiStr, cchMaxAnsiStr, NULL, NULL) != cchMaxAnsiStr)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Could not convert string %S to ANSI. Error=%u",
            str.cstr(), GetLastError());
        goto lDone;
    }

    pSetting->Reset();
    if(!pSetting->Concat(pszAnsiStr, str.GetLength()))
        goto lDone;

    fRet = true;

lDone:

    if(pszAnsiStr != NULL)
        g_MemAlloc.Free(pszAnsiStr);

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Failed to load setting %s(%ws)", pszSettingName, static_cast<wchar_t *> (setting));
    }

    return fRet;
}

bool CConfig::LoadUINT32(
    XblConfig::IConfig* pIConfig,
    CComBSTR setting,
    LPCSTR pszSettingName,
    UINT32* pSetting
)
{
    bool fRet = false;
    CLargeWStr str;

    if(!LoadWStr(pIConfig,setting,pszSettingName,&str))
    {
        goto lDone;
    }

    UINT32 dwSetting;

    if(!swscanf(str.cstr(), L"%u", &dwSetting))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to convert %S to UINT32", str.cstr());
        goto lDone;
    }

    *pSetting = dwSetting;

    fRet = true;
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Failed to load setting %s(%ws)", pszSettingName, static_cast<wchar_t *> (setting));
    }

    return fRet;
}

bool CConfig::LoadUINT64(
    XblConfig::IConfig* pIConfig,
    CComBSTR setting,
    LPCSTR pszSettingName,
    UINT64* pSetting
)
{
    bool fRet = false;
    CLargeWStr str;

    if(!LoadWStr(pIConfig,setting,pszSettingName,&str))
    {
        goto lDone;
    }

    UINT64 qwSetting;

    if(!swscanf(str.cstr(), L"%I64u", &qwSetting))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to convert %S to UINT64", str.cstr());
        goto lDone;
    }

    *pSetting = qwSetting;

    fRet = true;

lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Failed to load setting %s(%ws)", pszSettingName, static_cast<wchar_t *> (setting));
    }

    return fRet;
}

bool CConfig::BstrToInaddr(
    BSTR bstr,
    IN_ADDR* pina
)
{
    bool fRet = false;

     CHAR szAddr[128];
     if(!WideCharToMultiByte(CP_ACP, 0, bstr, -1,
        szAddr, ARRAY_SIZE(szAddr), NULL, NULL))
     {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "WideCharToMultiByte. Error = %u", GetLastError());
        goto lDone;
     }

     pina->S_un.S_addr = inet_addr(szAddr);

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

CConfig::GetLbInfoStatus CConfig::GetLbInfo(
    UINT32 dwTitleId,
    UINT32 dwLbId,
    ConfigLbInfo* plbinfo
)
{
    GetLbInfoStatus status = GetLbInfoStatusOtherError;
    HRESULT hr;
    CODBWSession sql;
    static CWSProcCache pc;

    if(FAILED(hr = sql.InitializeEx(_configSqlConnectionStr.cstr())))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to connect. sql.InitializeEx failed. hr=0x%08x", hr);
        goto lDone;
    }

    // Execute stored procedure 'p_stats_lb_add'
    hr = sql.CallProc(&pc,
        L"exec dbo.p_stats_lb_get %I, %I",
        dwTitleId,
        dwLbId);

    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Call to p_stats_lb_get failed. hr=0x%08x", hr);
        goto lDone;
    }

    struct LbInfo
    {
        WCHAR  szServer[65];
        UINT32 dwTitleId;
        UINT32 dwLbId;
        UINT32 lbReset;
        UINT32 fTop100;
        UINT32 uiDecayDays;
        DATE   dtLastReset;
    } dbLbInfo;

    static DBBINDING bind[] = {
        WSBIND(1, offsetof(LbInfo, szServer)   , DBTYPE_WSTR, ARRAY_SIZE(dbLbInfo.szServer)),
        WSBIND(2, offsetof(LbInfo, dwTitleId)  , DBTYPE_I4,  0),
        WSBIND(3, offsetof(LbInfo, dwLbId)     , DBTYPE_I4,  0),
        WSBIND(4, offsetof(LbInfo, lbReset)    , DBTYPE_I4,  0),
        WSBIND(5, offsetof(LbInfo, fTop100)    , DBTYPE_I4,  0),
        WSBIND(8, offsetof(LbInfo, uiDecayDays), DBTYPE_I4,  0),
        WSBIND(15, offsetof(LbInfo, dtLastReset), DBTYPE_DATE,0)
    };

    if(FAILED(hr = sql.SetBindings(bind, ARRAY_SIZE(bind))))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "sql.SetBindings failed. hr=0x%08x", hr);
        goto lDone;
    }

    // If leaderboard exists, the stored procedure will return one row with
    // the leaderboard information.

    ZeroMemory(&dbLbInfo, sizeof(dbLbInfo));

    DBCOUNTITEM cRows=1;
    if(FAILED(hr = sql.GetRows(&cRows, &dbLbInfo, sizeof(dbLbInfo))))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "sql.GetRows failed. hr=0x%08x", hr);
        goto lDone;
    }

    if(cRows == 0)
    {
        status = GetLbInfoStatusNotFound;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard titleId=0x%08x, lbId=0x%08x not found in config db",
            dwTitleId, dwLbId);
        goto lDone;
    }

    plbinfo->dwTitleId    = dbLbInfo.dwTitleId;
    plbinfo->dwLbId       = dbLbInfo.dwLbId;
    plbinfo->lbReset      = dbLbInfo.lbReset;
    plbinfo->fTop100      = dbLbInfo.fTop100;
    plbinfo->uiDecayDays  = dbLbInfo.uiDecayDays;

    // Convert last-reset timestamp from OLEDB format to filetime
    SYSTEMTIME systime;
    ::VariantTimeToSystemTime(dbLbInfo.dtLastReset, &systime);
    ::SystemTimeToFileTime(&systime, reinterpret_cast<FILETIME*>(&plbinfo->lastReset));

    //During a leaderboard moves, it is possible that an LB is configured on a different server
    //We should allow loading - but we should do it cautiously
    if(_computerName.IgnoreCaseCompareTo(dbLbInfo.szServer) != 0)
    {
        status = GetLbInfoStatusDifferentServer;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard titleId=0x%08x, lbId=0x%08x exists however it "
            "is bound to a different server (%S)", dbLbInfo.dwTitleId,
            dbLbInfo.dwLbId, dbLbInfo.szServer);
        goto lDone;
    }

    status = GetLbInfoStatusSucceeded;

lDone:

    if(status != GetLbInfoStatusSucceeded)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

CConfig::DeleteLbStatus CConfig::DeleteLb(
    DWORD dwTitleId,
    DWORD dwLbId
)
{
    DeleteLbStatus status = DeleteLbStatusOtherError;
    HRESULT hr;
    CODBWSession sql;
    static CWSProcCache pc;

    if(FAILED(hr = sql.InitializeEx(_configSqlConnectionStr.cstr())))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to connect. sql.InitializeEx failed. hr=0x%08x", hr);
        goto lDone;
    }

    // Execute stored procedure 'p_stats_lb_delete'
    hr = sql.CallProc(&pc,
        L"exec %T = p_stats_lb_delete %I, %I",
        dwTitleId,
        dwLbId );

    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Call to p_stats_lb_delete failed. hr=0x%08x", hr);
        goto lDone;
    }

    if(FAILED(hr = sql.CleanUpResult()))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "sql.CleanUpResult failed. hr=0x%08x", hr);
        goto lDone;
    }

    if(sql.GetStatus() != 0)
    {
        if(sql.GetStatus() == 1)
        {
            status = DeleteLbStatusLbNotFound;
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "The request failed because leaderboard does not exist in"
                "config server. TitleId=0x%08x, LbId=%u",
                dwTitleId, dwLbId);
            goto lDone;
        }
    }

    status = DeleteLbStatusSucceeded;

lDone:

    if(status != DeleteLbStatusSucceeded)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

bool CConfig::UpdateLbLastResetTime(
    DWORD  dwTitleId,
    DWORD  dwLbId,
    UINT64 lastReset
)
{
    bool fRet = false;
    HRESULT hr;
    CODBWSession sql;
    static CWSProcCache pc;

    if(FAILED(hr = sql.InitializeEx(_configSqlConnectionStr.cstr())))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to connect. sql.InitializeEx failed. hr=0x%08x", hr);
        goto lDone;
    }

    // Convert lastReset, which is in UTC filetime format to OLEDB date format
    SYSTEMTIME systime;
    DATE dtLastResetTime;
    ::FileTimeToSystemTime(reinterpret_cast<FILETIME*>(&lastReset), &systime );
    ::SystemTimeToVariantTime(&systime, &dtLastResetTime);

    // Execute stored procedure 'p_stats_update_last_reset'
    hr = sql.CallProc(&pc,
        L"exec %T = dbo.p_stats_update_last_reset %I, %I, %D",
        dwTitleId,
        dwLbId,
        dtLastResetTime );

    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Call to p_stats_update_last_reset failed. hr=0x%08x", hr);
        goto lDone;
    }

    if(FAILED(hr = sql.CleanUpResult()))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "sql.CleanUpResult failed. hr=0x%08x", hr);
        goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\btree.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * btree.h
 * Header of leaderboard server btree 
 * Source: btree.cpp
 * 
 */

#include "util.h"
#include "ums.h"
#include "buffer.h"

#define USE_BTREE_STATS 1

class  BTree;
struct BPTPage;
class  CBPTPageRef;

const double BtreePerFreeSpaceToConsiderMerge = 0.65; // Percentage of a page that's free before the btree considers it for merge

const WORD  BPT_PAGE_FLAG_INTERNAL = 0x01;
const WORD  BPT_PAGE_FLAG_EXTERNAL = 0x02;

typedef int (*BTreeKeyCompare)(
    void* pParam,
    void* pKey1, 
    DWORD cbKey1, 
    void* pKey2, 
    DWORD cbKey2);

#if USE_BTREE_STATS

struct BTREE_STATS
{
    DWORD cInsert;
    DWORD cInsertOptimisticFailed;
    DWORD cInsertSplit;
    
    DWORD cDelete;
    DWORD cDeleteOptimisticFailed;
    DWORD cDeleteReReference;
    DWORD cDeleteLeftBalance;
    DWORD cDeleteRightBalance;
    DWORD cDeleteLeftMerge;
    DWORD cDeleteRightMerge;
    
    BTREE_STATS()
    {
        Reset();
    }
    
    void Reset()
    {
        cInsert                 = 0;
        cInsertOptimisticFailed = 0;
        cInsertSplit            = 0;
        
        cDelete                 = 0;
        cDeleteOptimisticFailed = 0;
        cDeleteReReference      = 0;
        cDeleteLeftBalance      = 0;
        cDeleteRightBalance     = 0;
        cDeleteLeftMerge        = 0;
        cDeleteRightMerge       = 0;
    }
};

#define BTREE_INC_STAT(x) _stats.x++;

#else

#define BTREE_INC_STAT(x)

#endif

class CBPTPageRef
{
public:

    CBPTPageRef() :
        _pPage(NULL)
    {
    }
    
    ~CBPTPageRef()
    {
        DBGASSERT(_pPage == NULL);
    }
    
    void Set(BPTPage* pPage, UMSLockCookie* pLock)
    {
        DBGASSERT(_pPage == NULL);
    
        _pPage = pPage;
        _lock  = *pLock;
    }
    
    void Reset()
    {
        _pPage = NULL;
    }
    
    void Release(IUmsClient* pUmsClient)
    {
        if(_pPage != NULL)
        {
            pUmsClient->ReleaseLock(&_lock);
            _pPage = NULL;
        }
    }

    BPTPage* GetPage() 
    {
        return _pPage;
    }
    
    bool IsNull()
    {
        return _pPage == NULL;
    }
    
    bool ReleaseAndAcquireLock(IUmsClient* pUmsClient, LOCK_MODE lm)
    {
        DBGASSERT(_pPage != NULL);
        return pUmsClient->ReleaseAndAcquireLock(&_lock,lm);
    }

    bool UpgradeLockFromSIXtoX(IUmsClient* pUmsClient)
    {
        DBGASSERT(_pPage != NULL);
        return pUmsClient->UpgradeLockFromSIXtoX(&_lock);
    }
    
    LOCK_MODE GetCurrentLockMode()
    {
        DBGASSERT(_pPage != NULL);
        return _lock.lm;
    }
    
protected:

    BPTPage* _pPage;
    UMSLockCookie _lock;
};

/***************************************************************************/
/*                                                                         */
/* BTree                                                                   */
/*                                                                         */
/*                                                                         */
/*                                                                         */
/*                                                                         */
/*                                                                         */
/***************************************************************************/
class BTree
{
public:

    USE_GLOBAL_ALLOC;

    class Iterator;
    
    BTree() :
        _pBM(NULL),
        _pKeyCompare(NULL),
        _pidRoot(0),
        _wKeySize(0),
        _wConsiderMerge(0)
    {}
    
    bool Init(
        IUmsClient* pUmsClient, 
        CBufferManager* pBM, 
        BTreeKeyCompare pKeyCompare,
        WORD wKeySize
    );
    
    void Term(
        IUmsClient* pUmsClient
    );
             
    bool Reset(
        IUmsClient* pUmsClient
    );
             
    enum SEARCHSTATUS
    {
        SEARCHSTATUS_SUCCEEDED = 0,
        SEARCHSTATUS_NOT_FOUND = 1,
        SEARCHSTATUS_OTHER_ERROR = 2
    };
    
    SEARCHSTATUS SearchLE(
        IUmsClient* pUmsClient,
        void*       pKey,
        WORD        cbKey,
        bool        fWrite,
        Iterator*   pIterator
    );

    SEARCHSTATUS SearchGE(
        IUmsClient* pUmsClient,
        void*       pKey,
        WORD        cbKey,
        bool        fWrite,
        Iterator*   pIterator
    );

    SEARCHSTATUS Search(
        IUmsClient* pUmsClient,
        void*       pKey,
        WORD        cbKey,
        bool        fWrite,
        Iterator*   pIterator,
        bool        fGreater
    );

    SEARCHSTATUS SearchEx(
        IUmsClient* pUmsClient,
        void*       pKey,
        WORD        cbKey,
        bool        fWrite,
        Iterator*   pIterator,
        bool        fGreater,
        ITraceCallback* pOut
    );

    bool SearchByRank(
        IUmsClient* pUmsClient,
        DWORD dwSearchRank,
        bool  fWrite,
        Iterator* pIterator
    );
    
    enum INSERTSTATUS
    {
        INSERTSTATUS_SUCCEEDED             = 0,
        INSERTSTATUS_OPTIMISTIC_RUN_FAILED = 1,
        INSERTSTATUS_PRIMARY_KEY_VIOLATION = 2,
        INSERTSTATUS_OTHER_ERROR           = 3
    };
    
    INSERTSTATUS Insert(
        IUmsClient* pUmsClient, 
        void* pKey, 
        WORD cbKey, 
        void* pData, 
        WORD cbData
    );
    
    enum DELETESTATUS
    {
        DELETESTATUS_SUCCEEDED = 0,
        DELETESTATUS_NOT_FOUND = 1,
        DELETESTATUS_OPTIMISTIC_RUN_FAILED = 2,
        DELETESTATUS_OTHER_ERROR = 3
    };
    
    DELETESTATUS Delete(
        IN IUmsClient* pUmsClient,
        IN void* pKey,
        IN WORD cbKey,
        OUT void* pData = NULL,
        OUT WORD* pcData = NULL
    );

    bool Verify(
        IN IUmsClient* pUmsClient
    );
    
    bool DumpTree(
        IUmsClient* pUmsClient,
        ITraceCallback* pOut
    );


    bool DumpTreePath(
                            IUmsClient* pUmsClient,
                            ITraceCallback* pOut,
                            void*       pKey,
                            WORD        cbKey);
	
    void DumpStats();

    bool DumpMemoryStats(IUmsClient* pUmsClient, ITraceCallback* pOut);

    BTreeKeyCompare GetKeyCompare() const { return _pKeyCompare; }
    WORD            GetKeySize ()   const { return _wKeySize; }
    
#if _TEST

    void TestInit(BTreeKeyCompare pKeyCompare, WORD wKeySize)
    {
        _pKeyCompare = pKeyCompare;
        _wKeySize    = wKeySize;
    }

#endif
    
    class Iterator
    {
    public:
        
        Iterator() :
            _pControl(NULL),
            _pBTree(NULL),
            _wNodeNdx(0),
            _dwRank(0),
            _fFirstRead(false)
        {}
        
        ~Iterator()
        {
            Reset();
        }
        
        void Get(
            void** ppKey, 
            WORD* pcbKey, 
            void** ppData, 
            WORD* pcbData
        );
        
        bool Read();
        
        void Reset();
        
        DWORD GetRank() const { return _dwRank; }

    protected:
    
        void Init(
            IUmsClient* pUmsClient,
            BTree* pBTree,
            CBPTPageRef* pPage, 
            WORD wNodeNdx,
            DWORD dwRank
        );
        
        IUmsClient* _pControl;
        BTree*           _pBTree;
        CBPTPageRef      _pageref;
        WORD             _wNodeNdx;
        DWORD            _dwRank;
        bool             _fFirstRead;
    
        friend BTree;
    };
    
protected:
    
    LOCK_ID GetLockIdForTree()
    {
        LOCK_ID lid = {LOCK_TYPE_BTREE, PtrToUlong(this)};
        return lid;
    }
    
    LOCK_ID GetLockIdForTreeRoot()
    {
        LOCK_ID lid = {LOCK_TYPE_BTREE_ROOT, PtrToUlong(this)};
        return lid;
    }
    
    bool GetPage(
        IUmsClient* pUmsClient,
        BM_PAGEID pid,
        LOCK_MODE lm,
        CBPTPageRef* pPageRef
    );
    
    bool CreateNewPage(
        IUmsClient* pUmsClient,
        CBPTPageRef* pPageRef
    );
    
    bool DeletePage(
        IUmsClient* pUmsClient,
        CBPTPageRef* pPageRef
    );
    
    bool ShouldSplit(
        CBPTPageRef* pPage, 
        WORD cbKey, 
        WORD cbData
    );
    
    bool GetRootPage(
        IUmsClient* pUmsClient, 
        LOCK_MODE lmRoot,
        CBPTPageRef* pRootPage,
        UMSLockCookie* pLockRoot
    );
    
    INSERTSTATUS InsertRecursive(
        IUmsClient* pUmsClient,
        CBPTPageRef* pPage,
        void* pKey,
        WORD cbKey,
        void* pData,
        WORD cbData,
        bool fOptimistic
    );
    
    bool SplitPage(
        IN IUmsClient* pUmsClient, 
        IN CBPTPageRef* pParent,
        WORD wChildIndex,
        IN BYTE cbMinRequired,
        IN BYTE* pKey,
        IN WORD cbKey,
        IN BYTE* pData,
        IN WORD cbData
    );
    
    bool GetChildPageFromParent(
        IN IUmsClient* pUmsClient,
        IN CBPTPageRef* pParent,
        IN WORD wChildIndex,
        IN LOCK_MODE lm,
        OUT CBPTPageRef* pChild
    );
    
    enum BALANCENODESSTATUS
    {
        BALANCENODESSTATUS_SUCCEEDED,
        BALANCENODESSTATUS_NOT_ENOUGH_SPACE,
        BALANCENODESTATUS_OTHER_ERROR
    };
    
    BALANCENODESSTATUS BalanceNodes(
        IUmsClient* pUmsClient, 
        CBPTPageRef* pParent,
        CBPTPageRef* rgChildren[],
        DWORD cChildren,
        WORD wMinSpaceAllowed,
        void* pKey,
        WORD cbKey,
        void* pData,
        WORD cbData
    );
    
    bool AddChildReferenceToParent(
        CBPTPageRef* pParent, 
        CBPTPageRef* pChild
    );
    
    void RemoveChildReferenceFromParent(
        CBPTPageRef* pParent, 
        CBPTPageRef* pChild
    );
    
    BYTE* GetReferenceKeyFromNode(
        CBPTPageRef* pPage
    );
    
    void DumpPage(
        ITraceCallback* pOut,
        BPTPage* pPage
    );

    void DumpRawPage(
        ITraceCallback* pOut,WORD wChildIndex,
        BPTPage* pPage
    );
    
    DELETESTATUS DeleteRecursive(
        IN IUmsClient* pUmsClient,
        IN CBPTPageRef* pPage,
        IN void* pKey,
        IN WORD cbKey,
        IN bool fOptimistic,
        void* pData,
        WORD* pcData
    );
    
    bool UpdateReference(
        IN IUmsClient* pUmsClient,
        IN CBPTPageRef* pParent,
        IN WORD wChildIndex
    );
        
    bool MergeAndDelete(
        IUmsClient* pUmsClient,
        CBPTPageRef* pParent,
        WORD wChildIndex,
        void* pKey,
        WORD cbKey
    );
    
    bool MergeNodes(
        IUmsClient* pUmsClient,
        CBPTPageRef* pParent,
        CBPTPageRef* pChild1,
        CBPTPageRef* pChild2
    );
    
    bool GetChildAndSiblings(
        IUmsClient* pUmsClient,
        BM_PAGEID pidChild,
        CBPTPageRef* plsib,
        CBPTPageRef* pchild,
        CBPTPageRef* prsib
    );
    
    friend Iterator;
    
    CBufferManager*  _pBM;
    BTreeKeyCompare  _pKeyCompare;
    BM_PAGEID        _pidRoot;
    CFastLock        _lockRoot;
    WORD             _wKeySize;
    WORD             _wConsiderMerge;    // Necessary avail. space in a node before it's considered for a merge
    
#if USE_BTREE_STATS
    
    BTREE_STATS _stats;

#endif

};

/***************************************************************************/
/*                                                                         */
/* BPTPage                                                                 */
/*                                                                         */
/* B-Tree page. It's used by B-Trees to store the nodes, both internal and */
/* external. Notice that it actually inherits from BM_PAGE so it comes with*/
/* all the cool stuff that the Buffer Manager provides like paging and     */
/* sophisticated lock modes. Oh, and it can also be used to store data!    */
/*                                                                         */
/* Here is what the page actually looks like:                              */
/*                                                                         */
/*     ------------------------                                            */
/*     |                      | The header contains global information     */
/*     |        HEADER        | about the page. The header fields are      */
/*     |                      | actually declared in BPTPage.              */
/*     ------------------------                                            */
/*     |                      | This is an array of ENTRY_OFFSETs which    */
/*     |       OFFSETS        | store the offsets of data entries in the   */
/*     |                      | data section. The order of the offsets is  */
/*     |                      | actually the sort order of the data.       */
/*     ------------------------                                            */
/*     |                      | This is the contiguous free space of the   */
/*     |   FREE CONT. SPACE   | page. New entries are allocated from here. */
/*     |                      |                                            */
/*     ------------------------                                            */
/*     |                      | Where all the data is stored. The data is  */
/*     |         DATA         | allocated from the free space area from the*/
/*     |                      | bottom of the page up. The data is not     */
/*     |                      | stored in sorted order. The sort order is  */
/*     |                      | defined by the offsets.                    */
/*     ------------------------                                            */
/*                                                                         */
/***************************************************************************/
struct BPTPage : public BM_PAGE
{
    // *** Page Header ***
    
    // Page flags. Combination of BPT_PAGE_FLAG_* constants
    WORD _wPageFlags;
    
    // Page size in bytes
    WORD  _wPageSize;
    
    // Number of entries stored in the page.
    WORD  _wEntryCount;
    
    // Offset to the 'free area'
    WORD  _wFreeOffset;
    
    // Size of 'free area'
    WORD  _wFreeSpace;
    
    // Number of bytes of storage available *counting* with fragmented space
    WORD  _wAvailSpace;
    
    // Links
    BM_PAGEID _pidLLink; 
    BM_PAGEID _pidRLink;
    
    // *** End of Page Header *** 
    
    // used as a placeholder to mark the end of the header
    BYTE  _endOfHeader[1]; 
    
    struct ENTRY_META
    {
        WORD  wOffset;
        WORD  wReserved; //We don't let the compiler pad it
        DWORD dwSizeSubtree;
    };
    
    typedef UINT16 DATA_SIZE;
    
    enum
    {
        SIZE_MASK = 0x7FFF,
        FREE_FLAG = 0x8000
    };

    // The following are pointer helper functions
    
    // PointerToOffset
    // Takes a pointer to an area in the page and converts to an offset
    WORD PointerToOffset(void* p)
    {
        return (WORD) (((BYTE*)p) - ((BYTE*)this));
    }

    // OffsetToPointer
    // Takes an offset and converts to a pointer to the page
    BYTE* OffsetToPointer(WORD wOffset)
    {
        return (((BYTE*)this) + wOffset);
    }
    
    // GetHeaderSize
    // Returns the size in bytes of the header portion of the page
    static WORD GetHeaderSize()
    {
        return offsetof(BPTPage, _endOfHeader);
    }
    
    // GetPointerToOffsets
    // Return a pointer to the offsets array
    ENTRY_META* GetPointerToOffsets()
    {
        return (ENTRY_META*) OffsetToPointer(GetHeaderSize());
    }
    
    // GetPointerToEntry
    // Return a pointer to an entry given a key index
    BYTE* GetPointerToEntry(WORD wKeyIndex)
    {
        return OffsetToPointer((WORD)GetPointerToOffsets()[wKeyIndex].wOffset);
    }
    
    WORD GetEntryCount() const
    {
        return _wEntryCount;
    }
    
    // GetEntry
    // Retrieve the key and the data or an entry given it's key index.
    void GetEntry(
        IN BTree* pbtree, 
        IN WORD wKeyIndex,
        OUT BYTE** ppKey, 
        OUT WORD* pcbKey, 
        OUT BYTE** ppData,
        OUT WORD* pcbData,
        OUT DWORD* pdwSizeSubtree
    )
    {
        ENTRY_META* pMeta = &GetPointerToOffsets()[wKeyIndex];
        BYTE* pEntry      = OffsetToPointer((WORD)pMeta->wOffset);
        DATA_SIZE size    = *(DATA_SIZE*) (pEntry - sizeof(DATA_SIZE));
        
        if(ppKey != NULL)
            *ppKey = pEntry - sizeof(DATA_SIZE) - size ;
            
        if(pcbKey != NULL)
            *pcbKey = pbtree->GetKeySize();
            
        if(ppData != NULL)
            *ppData = pEntry - sizeof(DATA_SIZE) - size + pbtree->GetKeySize();
            
        if(pcbData != NULL)
            *pcbData = size - pbtree->GetKeySize();
            
        if(pdwSizeSubtree)
            *pdwSizeSubtree = pMeta->dwSizeSubtree;
    }
    
    // GetEntryOverhead
    // Returns the overhead in bytes of each entry stored or to be stored in 
    // the page.
    static WORD GetEntryOverhead()
    {
        return (WORD) (sizeof(ENTRY_META) + sizeof(DATA_SIZE)); 
    }
    
    // GetMaxAvailableSpace
    // Returns the maximum possible available space in the page
    WORD GetMaxAvailableSpace()
    {
        return _wPageSize - GetHeaderSize();
    }
    
    // GetUsedSpace
    // Returns the number of bytes used in the page
    WORD GetUsedSpace()
    {
        return GetMaxAvailableSpace() - _wAvailSpace;
    }
    
    // HasRoomFor
    // Returns true if the page has enough space for cbBytes. False otherwise.
    bool HasRoomFor(WORD cbBytes, WORD cbExtraSpace=0)
    {
        DBGASSERT(cbExtraSpace + _wAvailSpace <= _wPageSize - GetHeaderSize());
        return _wAvailSpace + cbExtraSpace >= cbBytes + GetEntryOverhead();
    }
    
    void SetSizeSubtree(WORD wIndex, DWORD dwSizeSubtree)
    {
        DBGASSERT(wIndex < _wEntryCount);
        GetPointerToOffsets()[wIndex].dwSizeSubtree = dwSizeSubtree;
    }
    
    void IncSizeSubtree(WORD wIndex)
    {
        DBGASSERT(wIndex < _wEntryCount);
        InterlockedIncrement((LONG*)&(GetPointerToOffsets()[wIndex].dwSizeSubtree));
    }
    
    void DecSizeSubtree(WORD wIndex)
    {
        DBGASSERT(wIndex < _wEntryCount);
        InterlockedDecrement((LONG*)&(GetPointerToOffsets()[wIndex].dwSizeSubtree));
    }
    
    DWORD GetSizeTree()
    {
        return _wEntryCount > 0 ? GetSizeLeftSubtree(_wEntryCount-1) : 0;
    }
    
    DWORD GetSizeLeftSubtree(WORD wIndex)
    {
        DBGASSERT(wIndex < _wEntryCount);
        
        DWORD       dwSize = 0;
        ENTRY_META* rgMeta = GetPointerToOffsets();
        
        for(WORD i=0; i <= wIndex; i++)
            dwSize += rgMeta[i].dwSizeSubtree;
        
        return dwSize;
    }
    
    DWORD GetSizeSubtree(WORD wIndex)
    {
        DBGASSERT(wIndex < _wEntryCount);
        return GetPointerToOffsets()[wIndex].dwSizeSubtree;
    }
    
    // Init
    // Initialize the page 
    void Init(
        IN WORD wPageFlags, 
        IN WORD wPageSize
    );
    
    // Clear
    // Delete all data
    void Clear();
    
    // ADDENTRYSTATUS
    // Status code returned by AddEntry
    enum ADDENTRYSTATUS 
    {
        ADDENTRYSTATUS_SUCCEEDED = 0,
        ADDENTRYSTATUS_ERROR_NOT_ENOUGH_SPACE = 1,
        ADDENTRYSTATUS_KEY_ALREADY_EXISTS = 2,
        ADDENTRYSTATUS_OTHER_ERROR = 3
    };
    
    // AddEntry
    // Add an entry to the page.
    ADDENTRYSTATUS AddEntry(
        BTree* pbtree,
        void* pKey,
        WORD  cbKey,
        void* pData, 
        WORD cbData,
        DWORD dwSizeSubtree
    );
    
    // CompactPage
    // Consolidate page's free space
    void CompactPage();
    
    // BinarySearch
    // Performs a binary search on the page using pKey as the searching key.
    // Returns in pwSlot the index of the entry where the search stopped.
    // Returns the result of the last comparison. 
    int BinarySearch(
        IN BTree* pInfo, 
        IN void* pKey, 
        OUT WORD* pwSlot);
    
    // GetEntryIndexGE
    // Returns in pwSlot the index of the entry with key greater or equal to 
    // pKey. Returns pwSlot = _wEntrycount if the last entry is less than 
    // pKey. The function returns true if the key is a perfect match and false
    // otherwise.
    bool GetEntryIndexGE(
        IN BTree* pInfo, 
        IN void* pKey, 
        OUT WORD* pwSlot
    );
    
    // GetEntryIndexLE
    // Returns in pwSlot the index of the entry with key less or equal to 
    // pKey. Returns pwSlot = 0 if the first entry is greater than pKey.
    // The function returns true if the key is a perfect match and false
    // otherwise.
    bool GetEntryIndexLE(
        IN BTree* pInfo, 
        IN void* pKey, 
        OUT WORD* pwSlot
    );

    DWORD GetEntryIndexForRankLookup(
        IN BTree* pInfo,
        IN DWORD  dwRank,
        OUT WORD* pwIndex
    );
    
    // RemoveEntry
    // Remove entry from page
    void RemoveEntry(
        IN BTree* pInfo, 
        IN WORD wKeyIndex
    );
    
    // CopyTo
    // Copy entry to another page
    bool CopyTo(
        IN BTree* pInfo,
        IN WORD wKeyIndex,
        IN BPTPage* pDestPage
    );
    
    // IntegrityCheck
    // Check page for structure problems. Returns true if check succeeded,
    // false otherwise.
    bool IntegrityCheck(
        IN BTree* pbtree, 
        IN WORD wPageSize
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\fd\xrlWebEnumLb.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.stats.common;

namespace xonline.server.stats.fd
{
    // XRLEnumLB
    // HTTP handler for Enumerate leaderboard request
    public class XRLWebEnumLB : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            MsgWebEnumLB        msgEnumLB = new MsgWebEnumLB();
            Stream              inputStream = ctx.Request.InputStream;
            BinaryReader               reader = new BinaryReader(inputStream);
            BinaryWriterWrapper        writer = new BinaryWriterWrapper(ctx.Response.OutputStream);
            object              pivotUserId;
            uint                pageStart;
            uint                leaderboardSize;
            DateTime            lastResetTime;
            uint                uiTitleId = 0;
            uint                hr = HResult.S_OK;

            // Check to make sure call is from DataCenter
            CallSource.Check(VirtualInterface.xstatsfd_int);

            // Read request
            try
            {
                msgEnumLB.ReadFrom(reader);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.XSTATSFD_INVALID_REQUEST_74, e,
                    "Invalid message WebEnumLb.");
                hr = HResult.XONLINE_E_STAT_BAD_REQUEST;
                goto lDone;
            }

            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "MsgWebEnumLB: "+msgEnumLB.ToString());

            uiTitleId = msgEnumLB._uiTitleId;

            if(Config.GetBoolSetting(Setting.stats_trackCountersPerLb))
            {
                // Track counters per leaderboard
                StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgEnumLB._uiLb].WebEnumLbPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")+"-"+msgEnumLB._uiLb].WebEnumLbTotal.Increment();
            }

            // Decide what _ulPivotOrPageStart really is. Pivot or page start.
            if(msgEnumLB._bIsPivotUser != 0)
            {
                // _ulPivotOrPageStart is the user pivot
                pivotUserId = msgEnumLB._ulPivotOrPageStart;
                pageStart = 0;
            }
            else
            {
                // _ulPivotOrPageStart is the page start
                pivotUserId = null;
                pageStart = (uint) msgEnumLB._ulPivotOrPageStart;

                // pageStart = 0 should be invalid considering the ranks start
                // at 1. However, for V1 backward-compability, we must handle
                // 0 as well.
                if(pageStart == 0)
                    pageStart = 1;
            }

            StatDb db = new StatDb();
            RepWebEnumLB rep = new RepWebEnumLB();
            EnumLbCallback callback = new EnumLbCallback(rep, msgEnumLB._uiPageSize);

            try
            {
                db.WebEnumLb(msgEnumLB._uiTitleId, msgEnumLB._uiLb, pivotUserId, pageStart,
                    msgEnumLB._uiPageSize, callback, out leaderboardSize, out lastResetTime);
            }
            catch(Exception e)
            {
                if(e is XRLException)
                    hr = ((XRLException)e).HResult;
                else
                    hr = HResult.XONLINE_E_STAT_ERROR;

                if(hr != HResult.XONLINE_E_STAT_USER_NOT_FOUND) // This is not really an error. Logging it would be spam.
                {
                    Xom.NtEvent(XEvent.Id.XSTATSFD_DATABASE_ERROR_2, e, "EnumLeaderBoard failed. MsgEnumLeaderBoard: " + msgEnumLB.ToString());
                }

                goto lDone;
            }

            callback.PrepareResponse();
            rep._uiLbSize = leaderboardSize;
            rep._ulLastResetTime = (ulong) lastResetTime.ToUniversalTime().ToFileTime();

            // Write response
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, HResult.S_OK);
            rep.WriteTo(writer);

            string logentry =
                "WEBENUMLB"+
                "|"+msgEnumLB._uiTitleId.ToString("x")+
                "|"+msgEnumLB._uiLb.ToString("x")+
                "|"+msgEnumLB._ulPivotOrPageStart.ToString("x")+
                "|"+msgEnumLB._bIsPivotUser.ToString("x")+
                "|"+msgEnumLB._uiPageSize.ToString("x")+
                "|"+rep._uiRepUserCount.ToString("x");

            Xom.Log(XomAreaName.statslog, logentry);
            Xom.Trace(XomAreaName.ctxDebug, LogLevel.L_NORMAL, "RepWebEnumLB:"+rep.ToString());

        lDone:

            // Update performance counters
            StatisticsCounters.Counters.WebEnumLbPerSecond.Increment();
            StatisticsCounters.Counters.WebEnumLbTotal.Increment();

            if(uiTitleId != 0)
            {
                StatisticsCounters.Counters[uiTitleId.ToString("x")].WebEnumLbPerSecond.Increment();
                StatisticsCounters.Counters[uiTitleId.ToString("x")].WebEnumLbTotal.Increment();
            }

            if(HResult.Failed(hr))
            {
                // Write response
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr);

                // Update performance counters
                StatisticsCounters.Counters.WebEnumLbFailedPerSecond.Increment();
                StatisticsCounters.Counters.WebEnumLbFailedTotal.Increment();

                if(uiTitleId != 0)
                {
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].WebEnumLbFailedPerSecond.Increment();
                    StatisticsCounters.Counters[uiTitleId.ToString("x")].WebEnumLbFailedTotal.Increment();
                }
            }
        }

        protected class EnumLbCallback : IStatDbEnumLbCallback
        {
            public EnumLbCallback(RepWebEnumLB rep, uint uiPageSize)
            {
                _rep = rep;
                _uiPageSize = uiPageSize;

                _lbEntry = null;
                _entries = new ArrayList((int)_uiPageSize);
                _attribs = new ArrayList(70);
            }

            public void OnNewRow(ulong ulUserId, string name, long lRating, uint uiRank)
            {
                if(_lbEntry != null)
                {
                    _lbEntry._attribs = (MsgAttribData[]) _attribs.ToArray(typeof(MsgAttribData));
                    _lbEntry._bAttribCount = (byte) _lbEntry._attribs.Length;
                }

                _lbEntry = new RepWebEnumLBUser();
                _lbEntry._ulUser = ulUserId;
                _lbEntry._uiRank = uiRank;
                _lbEntry._lRating = lRating;
                _lbEntry._attribs = null;
                _entries.Add(_lbEntry);
                _attribs.Clear();
            }

            public void OnAttribute(ushort usStatId, object val)
            {
                MsgAttribData attrib = new MsgAttribData();
                attrib._usAttrId = usStatId;

                if(val == null)
                {
                    attrib._bAttrType = (byte) AttrType.None;
                    attrib._value = val;
                }
                else if(val is int)
                {
                    attrib._bAttrType = (byte) AttrType.Long;
                    attrib._value = val;
                }
                else if (val is long)
                {
                    attrib._bAttrType = (byte) AttrType.LongLong;
                    attrib._value = val;
                }
                else if (val is double)
                {
                   attrib._bAttrType = (byte) AttrType.Double;
                   attrib._value = val;
                }
                else if(val is string)
                {
                    attrib._bAttrType = (byte) AttrType.String;
                    attrib._value = val;
                }

                _attribs.Add(attrib);
            }

            public void PrepareResponse()
            {
                if(_lbEntry != null)
                {
                    _lbEntry._attribs = (MsgAttribData[]) _attribs.ToArray(typeof(MsgAttribData));
                    _lbEntry._bAttribCount = (byte) _lbEntry._attribs.Length;
                }

                _rep._users = (RepWebEnumLBUser[]) _entries.GetRange(0, Math.Min((int)_uiPageSize, _entries.Count)).ToArray(
                    typeof(RepWebEnumLBUser));
                _rep._uiRepUserCount = (uint) _rep._users.Length;
            }

            public RepWebEnumLB _rep;
            public uint _uiPageSize;
            public RepWebEnumLBUser _lbEntry;
            public ArrayList _attribs;
            public ArrayList _entries;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\config.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * config.h
 * Header of leaderboard server configuration
 * Source: config.cpp
 * 
 */

#pragma once

enum ConfigLbReset
{
    ConfigLbResetNever        = 0,    
    ConfigLbResetWeekly       = 1,    
    ConfigLbResetMonthly      = 2,    
    ConfigLbResetBimonthly    = 3,    
    ConfigLbResetQuarterly    = 4,    
    ConfigLbResetSemiannually = 5,    
    ConfigLbResetAnnually     = 6     
};

enum ConfigLbEloBase
{
    ConfigLbEloBaseE,
    ConfigLbEloBase10
};

const DWORD ConfigMaxEloCtable = 64;

struct ConfigLbInfo : public CDoubleLink
{
    UINT32 dwTitleId;
    UINT32 dwLbId;
    UINT32 lbReset;
    UINT32 fTop100;
    UINT32 uiDecayDays;
    UINT64 lastReset;
};


class CConfig
{
public:
    
    CConfig() 
    {
        _dwBufferManagerPageSize  = 8192;
        _ullMaximumPhysicalMemory = 107374182400;//setting to some arbitrarily large number - 100 Gig
#ifdef _X86_
        _ullMaximumPhysicalMemory = 3221225472; //3GB is in fact the maximum on x86
#endif 
        _dwVirtualAllocSize       = 8388608;
        _dwReservedPhysicalMemory = 1048576000;
        _dwIOThreadCount          = 10;
        _inaNetListenAddr.S_un.S_addr = inet_addr("127.0.0.1");
        _dwNetListenPort          = 11111;
        _dwSizeRcvBuffer          = 16384;
        _dwSizeSndBuffer          = 16384;
        _dwMaxCSndBuffer          = 3;
        _dwNetHelloTimeout        = 5000;
        _dwPersisterThreadCount   = 1;
        _dwPersisterRetryInterval = 15000;
        _fullNamePagingFile.Assign(L"c:\\temp\\lbsvr_paging.big");
        _ullPagingFileInitialSize = 8192;
        _dwPagingFileGrow         = 10485760;
        _dwResetHour              = 12;
        _dwDatabaseWriteThread    = 1;

        _dwLoadingThread          = 10;
        _lMaxConnections          = 5000;

        _lSiteId                  = 0;
    }
    
    DWORD     GetBufferManagerPageSize()  { return _dwBufferManagerPageSize; }
    ULONGLONG GetMaximumPhysicalMemory()  { return _ullMaximumPhysicalMemory;  }
    DWORD     GetVirtualAllocSize()       { return _dwVirtualAllocSize; }
    DWORD     GetReservedPhysicalMemory() { return _dwReservedPhysicalMemory; }
    DWORD     GetIOThreadCount()          { return _dwIOThreadCount; }
    DWORD     GetNetListenPort()          { return _dwNetListenPort; }
    IN_ADDR   GetNetListenAddress()       { return _inaNetListenAddr; }
    DWORD     GetSizeRcvBuffer()          { return _dwSizeRcvBuffer; }
    DWORD     GetSizeSndBuffer()          { return _dwSizeSndBuffer; }
    DWORD     GetMaxCSndBuffer()          { return _dwMaxCSndBuffer; }
    DWORD     GetNetHelloTimeout()        { return _dwNetHelloTimeout; }
    DWORD     GetPersisterRetryInterval() { return _dwPersisterRetryInterval; }
    CWStr*    GetFullNamePagingFile()     { return &_fullNamePagingFile; }
    ULONGLONG GetPagingFileInitialSize()  { return _ullPagingFileInitialSize; }
    DWORD     GetPagingFileGrow()         { return _dwPagingFileGrow; }
    DWORD     GetResetHour()              { return _dwResetHour; }
    DWORD     GetDataBaseWriteThreads()   { return _dwDatabaseWriteThread; }

    LONG     GetMaxInetConnections()   { return _lMaxConnections; }

    DWORD     GetNumberOfLoadingThread() { return _dwLoadingThread;}

    DWORD     GetDBLoadNumRetry() { return _dwDbLoadNumRetry;}
    DWORD     GetDBRetryIntervalSeconds() { return _dwDbRetryIntervalSeconds;}
    LONG      GetSiteID() { return _lSiteId;}
    CWStr*    GetWebStoreName()     { return &_webstoreSqlDbName; }

    virtual bool LoadConfig();
    
    virtual bool LoadLbInfo(
        CArenaMemAlloc* pAlloc, 
        TList<ConfigLbInfo>* pList
    );

    virtual bool LoadLbInfoForOneTitle(
        CArenaMemAlloc* pAlloc,
        TList<ConfigLbInfo>* pList,
        DWORD dwTitleID,
        UINT32 *pLbCountProcessed
    );
    
    bool LoadLbInfoCommon(
        CArenaMemAlloc* pAlloc,
        TList<ConfigLbInfo>* pList,
        CWSProcCache *pPc,
        LPCWSTR pwszProc,
        ...
    );
    
    enum GetLbInfoStatus
    {
        GetLbInfoStatusSucceeded,
        GetLbInfoStatusNotFound,
        GetLbInfoStatusDifferentServer,
        GetLbInfoStatusOtherError
    };
    
    virtual GetLbInfoStatus GetLbInfo(
        UINT32 dwTitleId,
        UINT32 dwLbId,
        ConfigLbInfo* pInfo 
    );

    enum DeleteLbStatus
    {
        DeleteLbStatusSucceeded,
        DeleteLbStatusLbNotFound,
        DeleteLbStatusOtherError
    };
    
    virtual DeleteLbStatus DeleteLb(
        DWORD dwTitleId,
        DWORD dwLbId
    );
    
    virtual bool UpdateLbLastResetTime(
        DWORD  dwTitleId,
        DWORD  dwLbId,
        UINT64 lastReset
    );

    
#if !_TEST
protected:
#endif
    
    bool LoadInterface(
        XblConfig::IConfig* pIConfig
    );
    
    bool LoadConfigSqlInterface(
        XblConfig::IConfig* pIConfig
    );

    bool LoadWebStoreSqlInterface(
        XblConfig::IConfig* pIConfig
    );
    
    bool LoadWStr(
        XblConfig::IConfig* pIConfig,
        CComBSTR setting,
        LPCSTR pszSettingName,
        CWStr* pSetting
    );
    
    bool LoadStr(
        XblConfig::IConfig* pIConfig,
        CComBSTR setting,
        LPCSTR pszSettingName,
        CStr* pSetting
    );
    
    bool LoadUINT32(
        XblConfig::IConfig* pIConfig,
        CComBSTR setting,
        LPCSTR pszSettingName,
        UINT32* pSetting
    );
    
    bool LoadUINT64(
        XblConfig::IConfig* pIConfig,
        CComBSTR setting,
        LPCSTR pszSettingName,
        UINT64* pSetting
    );
    
    bool BstrToInaddr(
        BSTR bstr, 
        IN_ADDR* pina
    );

    DWORD     _dwBufferManagerPageSize;
    ULONGLONG _ullMaximumPhysicalMemory;
    DWORD     _dwVirtualAllocSize;
    DWORD     _dwReservedPhysicalMemory;
    DWORD     _dwIOThreadCount;
    DWORD     _dwNetListenPort;
    IN_ADDR   _inaNetListenAddr;
    DWORD     _dwSizeRcvBuffer;
    DWORD     _dwSizeSndBuffer;
    DWORD     _dwMaxCSndBuffer;
    DWORD     _dwNetHelloTimeout;
    DWORD     _dwPersisterThreadCount;
    DWORD     _dwPersisterRetryInterval;
    CSmallWStr _fullNamePagingFile;
    ULONGLONG _ullPagingFileInitialSize;
    DWORD     _dwPagingFileGrow;
    DWORD     _dwResetHour;
    DWORD     _dwDatabaseWriteThread;
    DWORD     _dwLoadingThread;
    DWORD     _dwDbLoadNumRetry;
    DWORD     _dwDbRetryIntervalSeconds;

    LONG      _lSiteId;
    
    TStackStr<UnicodeStrCharTrait, 512> _configSqlConnectionStr;
    CSmallWStr      _webstoreSqlDbName;
    CSmallWStr      _environment;
    CSmallWStr      _computerName;

    LONG           _lMaxConnections;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\health.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * health.h
 * Header (and implementation) to wrap the native health check infrastructure
 * Source: right here
 * 
 */

#pragma once

class CHealthChecks
{
public:
    
    CHealthChecks() :
      _pHealthInterop(NULL)
    {
    }

    ~CHealthChecks()
    {
        Term();
    }

    // Fires up the health check infrastructure.
    bool Init()
    {
        HRESULT hr = S_OK;
        bool fRet = true;

        // create the health interop instances 
        hr = _pHealthInterop.CoCreateInstance( __uuidof(HealthInterop) );
        if ( FAILED(hr) )
        {
            XomNtEvent(
                XEVENT_STATS_CODE_HEALTHINTEROP_CREATE_FAILED,
                "CHealthChecks::Init() failed to instantiate HealthInterop "
                "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
                "has been registered with regasm. Also verify the various XBL "
                "platform DLLs are in the GAC as well.", 
                hr
                );
            fRet = false;
            goto lDone;
        }

        // and fire up the http health listener
        hr = _pHealthInterop->Initialize(Component_lbsvr, (LONG_PTR)::GetModuleHandle(NULL));
        if ( FAILED(hr) )
        {
            XomNtEvent(
                XEVENT_STATS_CODE_HEALTHINTEROP_INIT_FAILED,
                "CHealthChecks::Init() failed to call Initialize on the "
                "HealthInterop instance with hr: 0x%08X. Verify xblhealthcheck.dll "
                "is installed correclty in the GAC",
                hr
                );
            fRet = false;
            goto lDone;
        }

lDone:
        return fRet;
    }
    
    void Term()
    {
        if (!!_pHealthInterop)
        {
            _pHealthInterop.Release();
            _pHealthInterop = NULL;
        }
    }

    CComPtr<IHealthInterop> _pHealthInterop;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\jobs.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * jobs.cpp
 * Implementation of leaderboard server jobs manager 
 * Header: jobs.h
 * 
 */
 
 #include "lbs.h"
 
CJobs::CJobs()
{
    _pUMS    = NULL;
    _pLbList = NULL;
    _pTimer  = NULL;
    _hThread = NULL;    
    _pAppt   = NULL;
    _lRef    = 0;
    _timeLastScheduled = 0;
}

CJobs::~CJobs()
{
    DBGASSERT(NULL == _hThread);
    DBGASSERT(NULL == _pAppt);
    DBGASSERT(0    == _lRef);
}

bool CJobs::Init(
    CConfig* pConfig,
    UMS* pUMS,
    CLbList* pLbList,
    CServerTimer* pTimer
)
{
    bool fRet = false;
    
    _pConfig = pConfig;
    _pUMS    = pUMS;
    _pLbList = pLbList;
    _pTimer  = pTimer;
    
    if(!ScheduleNextRun())
        goto lDone;
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CJobs::Term()
{
    if(_pAppt != NULL)
    {
        _pTimer->CancelAppointment(_pAppt);
        _pAppt->Release();
        _pAppt = NULL;
    }
    
    while(_lRef != 0)
    {
        ::Sleep(50);
    }
    
    if(_hThread != NULL)
    {
        ::WaitForSingleObject(_hThread, INFINITE);
        CloseHandle(_hThread);
        _hThread = NULL;
    }
}

ULONG CJobs::AddRef()
{
    return ::InterlockedIncrement(&_lRef);
}

ULONG CJobs::Release()
{
    return ::InterlockedDecrement(&_lRef);
}

void CJobs::OnTimer(void* pParam)
{
    SYSTEMTIME st;
    
    // First schedule the next run
    while(!ScheduleNextRun())
    {
        XomNtEvent(XEVENT_STATS_CODE_31, "ScheduleNextRun failed.\n%s",
            CGlobalError::GetCurrentMessage());
        CGlobalError::Reset();
        DBGASSERT(false);
        ::Sleep(5000);
    }
    
    if(_hThread != NULL)
    {
        if(::WaitForSingleObject(_hThread, 0) == WAIT_TIMEOUT)
        {
            // Job still running
            XomNtEvent(XEVENT_STATS_CODE_32, 
                "Skipping job because previous job is still running");
            
            return;
        }
        else
        {
            ::CloseHandle(_hThread);
            _hThread = NULL;
        }
    }
    
    // Start the job
    DWORD dwThreadId;
    _hThread = ::CreateThread(NULL, 0, StaticThreadProc, this, 0, 
        &dwThreadId);
        
    if(NULL == _hThread)
    {
        XomNtEvent(XEVENT_STATS_CODE_33, "::CreateThread failed. Error = %u",
            ::GetLastError());
        return;
    }
}

bool CJobs::ScheduleNextRun()
{
    UINT64 ct;
    UINT64 nt;
    SYSTEMTIME st;
    
    bool fRet = false;
    
    fRet = true;

    // Calculate time of next run 
    ct = ::GetUTCTimeAsUint64();
    if (ct < (UINT64)_timeLastScheduled)
    {
        ct = (UINT64)_timeLastScheduled; 
    }
    
    ::FileTimeToSystemTime((FILETIME*)&ct, &st);
    st.wHour   = (WORD)_pConfig->GetResetHour();
    st.wMinute = 0;
    st.wSecond = 0;
    st.wMilliseconds = 0;
    
    // Convert it to filetime (easier for math)
    ::SystemTimeToFileTime(&st, (FILETIME*)&nt);
    
    if(nt <= ct)
    {
        nt += 
            1ULL  *  // 1 day
            24ULL *  // 24 Hours
            60ULL *  // 60 minutes
            60ULL *  // 60 seconds
            10000000ULL; // 100 nano-seconds
    }
    
    // Now we calculate how much time we should 'sleep'
    UINT64 diff = nt - ct;
    
    // Convert it to milliseconds
    DWORD dwDiffMs = (DWORD) (diff / 10000);
    
    if(dwDiffMs > (48 * 60 * 60 * 1000))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: dwDiffMs > (48 * 60 * 60 * 1000)");
        goto lDone;
    }
    
    // Close previous appointment
    if(_pAppt != NULL)
    {
        _pTimer->CancelAppointment(_pAppt);
        _pAppt->Release();
        _pAppt = NULL;
    }
    
    // Create new appointment
    if(!_pTimer->CreateAppointment(this, NULL, dwDiffMs, false, &_pAppt))
        goto lDone;

    _timeLastScheduled = nt; //last succesfully scheduled time
        
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;        
}

DWORD CJobs::StaticThreadProc(void* pThis)
{
    CGlobalError::Init();
    ((CJobs*)pThis)->ThreadProc();
    CGlobalError::Term();
    return 0;
}

void CJobs::ThreadProc()
{
    bool fRet = false;
    IUmsClient* pUmsClient = NULL;
    UINT64 ct = ::GetUTCTimeAsUint64();

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    XomNtEvent(XEVENT_STATS_INFO_17, "Executing Job AutoReset");
        
    if(!_pLbList->AutoReset(pUmsClient, ct))
        goto lDone;

    XomNtEvent(XEVENT_STATS_INFO_18, "Executing Job AutoDecay");
        
    if(!_pLbList->AutoDecay(pUmsClient, ct))
        goto lDone;

    XomNtEvent(XEVENT_STATS_INFO_19, "Executing Job AutoTrim");
        
    if(!_pLbList->AutoTrim(pUmsClient))
        goto lDone;

    XomNtEvent(XEVENT_STATS_INFO_20, "All Jobs executed with success");
    
    fRet = true;
    
lDone:

    if(pUmsClient != NULL)
    {
        _pUMS->ReleaseUmsClient(pUmsClient);
    }

    if(!fRet)
    {
        XomNtEvent(XEVENT_STATS_CODE_34, "Job failed.\n%s",
            CGlobalError::GetCurrentMessage());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\db.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * db.h
 * Header of leaderboard server database classes
 * Source: db.cpp
 * 
 */

#pragma once

// Number of entries to be deleted in a single pass during a ResetLb
const DWORD DbMaxStatBlobSize       = 4000;

// Stores a reference to modified leaderboard rows. To be used with CChangeList
struct ChangeListKey
{
    UINT32 uiTitleId;
    UINT32 uiLbId;
    UINT64 ui64Puid;
    
    static int KeyCompare(
        void* pParam,
        void* pRawKey1, 
        DWORD cbRawKey1,
        void *pRawKey2,
        DWORD cbRawKey2
    )
    {
        ChangeListKey* pKey1 = (ChangeListKey*) pRawKey1;
        ChangeListKey* pKey2 = (ChangeListKey*) pRawKey2;
        
        int cmp;
        
        if((cmp = UINT32Compare(pKey1->uiTitleId, pKey2->uiTitleId)) == 0)
        {
            if((cmp = UINT32Compare(pKey1->uiLbId, pKey2->uiLbId)) == 0)
            {
                cmp = UINT64Compare(pKey1->ui64Puid, pKey2->ui64Puid);
            }
        }
        
        return cmp;
    }
};

// And this is the data associated with ChangeListKey
struct ChangeListData
{
    UINT8 operation; // One of the ChangeListOperationType* constants
};

const UINT8 ChangeListOperationTypeUpdate  = 1; // Update leaderboard row
const UINT8 ChangeListOperationTypeResetLb = 2; // Reset entire leaderboard

// A structure with title id and leaderboard id
struct DbTitleAndLb
{
    UINT32 uiTitleId;
    UINT32 uiLbId;
};

// CDb callback. Pass it in to CDb::Load to receive data back
class _declspec(novtable) IDbCallback
{
public:
    virtual bool OnRow(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid,
        LbStat rgStats[],
        DWORD  cStats,
        UINT64 lastModified
    ) = 0;
};

// Provides an interface with the database where we're storing leaderboard (
// not configuration) data
class CDb
{
public:
    
    USE_GLOBAL_ALLOC;
    
    CDb()
    {
        _pUMS = NULL;
        _lLogicalPartitions = 0;
    }
    
    ~CDb()
    {
    }
    
    virtual bool Init(
        CConfig* pConfig,
        UMS* pUMS,
        CPerfCounters* pPerfCounters
    );
    
    virtual void Term();
    
    virtual bool UpdateLbRow(
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid,
        LbStat rgStats[],
        DWORD  cStats,
        UINT64 ui64LastUpdt
    );
    
    virtual bool RemoveLbRow(
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid
    );
    
    virtual bool ResetLb(
        UINT32 uiTitleId,
        UINT32 uiLbId
    );
    
    virtual bool Load(
        DbTitleAndLb rgLb[],
        DWORD cLb,
        IDbCallback* pCallback
    );


    typedef struct 
    {
        DbTitleAndLb * rgLb;
        DWORD cLb;
        IDbCallback* pCallback;
        DWORD lPartCount;
        CDb *pDb;
        volatile LONG  lLbIndex;
        volatile LONG  lMaxRetry;
        volatile LONG  lRetrySeconds;
        volatile LONG  lUnRecoverableError;
        volatile LONG  lDbLoadRetryCount;
    } ThreadParam;
    
protected:
    
    bool BlobifyStats(
        LbStat rgStats[],
        DWORD cStats,
        BYTE rgbStatBlob[],
        DWORD* pcbStatBlob
    );
    
    bool DeblobifyStats(
        CArenaMemAlloc* pAlloc,
        BYTE* pBlob,
        DWORD cbBlob,
        LbStat rgStats[],
        DWORD* pcStats
    );

    void SetupSafeArray( 
        SAFEARRAY *pSA, 
        DWORD dwElements, 
        PVOID pAddr 
    );
    
    bool CallProcLbLoad(
        LONG lPhysicalPartition,
        BYTE* pBlob,
        DWORD cbBlob,
        IDbCallback* pCallback
    );
    
    bool CallProcLbRemove(
        LONG lPartition,
        UINT32 uiTitleId,
        UINT32 uiLbId
    );

    static DWORD LoadingThreadProc(void* pRaw);
    void  ThreadProc(ThreadParam *pThreadParam);
    
    UMS* _pUMS;

    CComPtr<lbwsinterop::ILbWsInterface> _pLbWsInterop;
    
    LONG _lLogicalPartitions;

    CConfig*         _pConfig;
    CPerfCounters* _pPerfCounters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\db.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * db.cpp
 * Implementation of leaderboard server database classes
 * Header: db.cpp
 * 
 */

#include "lbs.h"
namespace lbwsinterop { struct ILbWsInterface;};

HRESULT ErrorCallback(HRESULT hr, LPCSTR szInfo)
{
    return S_OK;
}

/******************************************************************************
* CDb
******************************************************************************/

// Initialize Db object and initialize webstore
bool CDb::Init(
    CConfig* pConfig,
    UMS* pUMS,
    CPerfCounters* pPerfCounters
)
{
    HRESULT hr;
    bool fRet = false;
    
    _pLbWsInterop = NULL;
    if(FAILED(hr = _pLbWsInterop.CoCreateInstance( __uuidof( lbwsinterop::CLbWsInterop ))))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "_pLbWsInterop.CoCreateInstance failed. hr=0x%08x. "
            "\nHint: Check if the LbWsInterop AND Managed Webstore 5.5 client was installed correctly.",hr);
    
        goto lDone;
    }
    
    _pConfig = pConfig;
    _pUMS = pUMS;
    _pPerfCounters = pPerfCounters;

    fRet = true;
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Terminate Db object and deinitialize webstore
void CDb::Term()
{
    //nothing to do - the Interop would be released when it goes out of scope because it is a CComPtr
}

// Update leaderboard row in database
bool CDb::UpdateLbRow(
    UINT32 uiTitleId,
    UINT32 uiLbId,
    UINT64 ui64Puid,
    LbStat rgStats[],
    DWORD  cStats,
    UINT64 ui64LastUpdt
)
{
    bool fRet = false;
    DWORD cbStatBlob = DbMaxStatBlobSize;
    HRESULT hr = S_OK;
    HRESULT hrfrominterop = S_OK;
    BYTE blob[DbMaxStatBlobSize];

    // Convert LbStat array to blob
    if(!BlobifyStats(rgStats, cStats, blob, &cbStatBlob))
        goto lDone;

    {
        SAFEARRAY sa;
        SetupSafeArray(&sa, cbStatBlob, blob);
	 XTimeElapsed xteTimeElapsed;
        hr = _pLbWsInterop->UpdateStatsForUser(uiTitleId, uiLbId, ui64Puid, &sa, (DWORD *)&hrfrominterop);
        if (NULL != _pPerfCounters)
	 {
            _pPerfCounters->IncrementValue64(LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME, xteTimeElapsed.MillisecondsElapsed());
            _pPerfCounters->IncrementValue32(LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME_BASE, 1);
        }
        if(FAILED(hr) || FAILED(hrfrominterop))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Failed to call p_stats_update through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
            CGlobalError::ProcessComError();
            goto lDone;
        }
    }

    fRet = true;
    
lDone:

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_ROWUPDATE_RATE, 1);
        if(!fRet)
        {
            _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_ROWUPDATE_FAIL_RATE, 1);
        }
    }

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CDb::RemoveLbRow(
    UINT32 uiTitleId,
    UINT32 uiLbId,
    UINT64 ui64Puid
)
{
    bool fRet = false;
    HRESULT hr;
    HRESULT hrfrominterop = S_OK;
    XTimeElapsed xteTimeElapsed;        

    hr = _pLbWsInterop->RemoveStatsForUser(uiTitleId, uiLbId, ui64Puid, (DWORD *)&hrfrominterop);

    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call p_stats_remove through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }

    fRet = true;

lDone:

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue64(LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME, xteTimeElapsed.MillisecondsElapsed());
        _pPerfCounters->IncrementValue32(LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME_BASE, 1);		
        _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_ROWREMOVE_RATE, 1);
	 if(!fRet)
	 {
            _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_ROWREMOVE_FAIL_RATE, 1);
	 }
    }

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}



bool CDb::Load(
    DbTitleAndLb rgLb[],
    DWORD cLb,
    IDbCallback* pCallback
)
{
    bool fRet = false;
    LONG lPartCount = 0;
    HRESULT hr;
    HRESULT hrfrominterop = S_OK;
    HANDLE * pThreadArray = NULL;
    DWORD dwLoadingThread = 0;
    
    hr = _pLbWsInterop->GetUODBPhysicalPartitionCount(&lPartCount, (DWORD *)&hrfrominterop);
    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call GetUODBPhysicalPartitionCount through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }
    
    XomNtEvent(XEVENT_STATS_INFO_14, "Start Loading LBSVR Data: Total LeaderBoards %d", cLb);

    //starting loading thread
    dwLoadingThread = _pConfig->GetNumberOfLoadingThread();
    if(0 == dwLoadingThread)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: Number of Loading Thread can't be 0");
        DBGASSERT(false);
        goto lDone;
    }

    if (dwLoadingThread > cLb)
    {
        dwLoadingThread = MAX(cLb, 1);
    }

    ThreadParam threadParam; //this will be the same for all threads
    threadParam.rgLb       = rgLb;
    threadParam.cLb        = cLb;
    threadParam.pCallback  = pCallback;
    threadParam.lPartCount = lPartCount;
    threadParam.pDb        = this;
    threadParam.lLbIndex   = 0;
    threadParam.lMaxRetry  = _pConfig->GetDBLoadNumRetry();
    threadParam.lRetrySeconds = _pConfig->GetDBRetryIntervalSeconds();
    threadParam.lUnRecoverableError = 0;
    threadParam.lDbLoadRetryCount = 0;

    pThreadArray = new HANDLE[dwLoadingThread];
    if (NULL == pThreadArray)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: allocating Handle structure fails");
        goto lDone;
    }

    for (DWORD dwThreadIndex=0;dwThreadIndex<dwLoadingThread;dwThreadIndex++)
    {
        DWORD dwThreadId = 0;
        pThreadArray[dwThreadIndex] = ::CreateThread(NULL, 0, LoadingThreadProc, &threadParam, 0,
                                                  &dwThreadId);

        if(NULL == pThreadArray[dwThreadIndex])
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "CreateThread failed. Error=%u", GetLastError());
            goto lDone;
        }
    }

    //wait until all thread terminates
    ::WaitForMultipleObjectsEx(   dwLoadingThread,
                                  pThreadArray,
                                  TRUE,
                                  INFINITE,
                                  FALSE
                                );

    if (threadParam.lUnRecoverableError > 0)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "Unsuccesful to load user data even after retry \r\n Check UODB Performance \r\n Number of threads Errored %d", threadParam.lUnRecoverableError);

        goto lDone;
    }
    
    XomNtEvent(XEVENT_LBSVR_LOAD_SUCCESS_INFO_1, "Loading Done! Total Lb Loaded %d Total Retry Failure %d", cLb, threadParam.lDbLoadRetryCount);
    fRet = true;

lDone:

    if (NULL != pThreadArray)
    {
        for (DWORD dwThreadIndex=0;dwThreadIndex<dwLoadingThread;dwThreadIndex++)
        {
            if (NULL != pThreadArray[dwThreadIndex])
            {
                ::CloseHandle(pThreadArray[dwThreadIndex]);
                pThreadArray[dwThreadIndex] = NULL;
            }
        }
    
        delete [] pThreadArray;
        pThreadArray = NULL;
    }

        
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

DWORD CDb::LoadingThreadProc(void* pRaw)
{
    ThreadParam *pThreadParam = (ThreadParam *)pRaw;
    DBGASSERT(pThreadParam != NULL);
    CDb *pDb = (CDb*)pThreadParam->pDb;

    HRESULT hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CGlobalError::Init();
    pDb->ThreadProc(pThreadParam);
    CGlobalError::Term();
    if (SUCCEEDED(hr))
    {    
        ::CoUninitialize();
    }
    return 0;
}

void CDb::ThreadProc(ThreadParam *pThreadParam)
{
    DbTitleAndLb *rgLb     = pThreadParam->rgLb; //every thread will access this structure - but the trick is to ensure they don't access the same index
    DWORD cLb              = pThreadParam->cLb;
    IDbCallback* pCallback = pThreadParam->pCallback;
    DWORD lPartCount       = pThreadParam->lPartCount;
    DWORD dwMaxRetryCount  = pThreadParam->lMaxRetry;
    DWORD dwRetrySeconds   = pThreadParam->lRetrySeconds;

    DWORD dwLbIndex = (DWORD)InterlockedIncrement(&(pThreadParam->lLbIndex));
    bool fRet = false;

    // The p_stats_lb_load stored procedure takes only one parameter with a 
    // bunch of title and leaderboard id pairs concatenated in one single blob
    struct BlobEntry
    {
        UINT32 uiTitleId;
        UINT32 uiLbId;
    };
    
    //Each thread can randomly pick up any leaderboard from any partition
    while (dwLbIndex <= cLb*lPartCount)
    {
        BlobEntry blob;

        //Important to calculate the real index for the array
        //Since we jump every lPartCount amount within one leaderboard
        //we need to adjust accordingly
        DWORD realIndex = (dwLbIndex-1)/lPartCount;
        
        blob.uiTitleId = RevertDword(rgLb[realIndex].uiTitleId);
        blob.uiLbId    = RevertDword(rgLb[realIndex].uiLbId);

        //The partition being worked on for this loop, we already have the leaderboard
        //above, the remainder gives us the partition number
        LONG part = (dwLbIndex-1)%lPartCount;
        bool fSuccess = false;

        for (DWORD dwTry=0;dwTry<dwMaxRetryCount;dwTry++)
        {
            if (pThreadParam->lUnRecoverableError > 0)
            {
                fRet = true; //this thread did not error
                goto lDone;
            }
        
            fSuccess = CallProcLbLoad(part, (BYTE*)&blob, sizeof(BlobEntry), pCallback);
            //BUG#31952, the access to dwLbIndex-1 overshoots bounds of the array. Leads to an exception
            if (fSuccess)
            {
                XomNtEvent(XEVENT_STATS_INFO_16, "%u/%u Processed Title ID 0x%08x LBID 0x%08x on Physical Partition %u", realIndex + 1, cLb , rgLb[realIndex].uiTitleId, rgLb[realIndex].uiLbId, part);
                break;
            }
            else
            {
                XomNtEvent(XEVENT_LBS_LOAD_THREAD_WARNING_1, "Failed but will Retry - %u/%u Processing Title ID 0x%08x LBID 0x%08x on Physical Partition %u\r\n%s", realIndex + 1, cLb , rgLb[realIndex].uiTitleId, rgLb[realIndex].uiLbId, part, CGlobalError::GetCurrentMessage());                   
                CGlobalError::Reset();
                ::Sleep(dwRetrySeconds * 1000);
            }
        }

        if (!fSuccess)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                                         "CallProcLbLoad failed on LbIndex %u. and Physical Partition %u", realIndex + 1, part);

            InterlockedIncrement(&(pThreadParam->lUnRecoverableError));
            
            goto lDone;
        }

        dwLbIndex = InterlockedIncrement(&(pThreadParam->lLbIndex));
    }

    fRet = true;
    
lDone:
    if(!fRet)
    {
        XomNtEvent(XEVENT_LBS_LOAD_THREAD_ERROR_1, "\n%s", 
            CGlobalError::GetCurrentMessage());
    }
    return;
}

bool CDb::ResetLb(
    UINT32 uiTitleId,
    UINT32 uiLbId
)
{
    bool fRet = false;
    LONG lPartCount = 0;
    HRESULT hr;
    HRESULT hrfrominterop;

    hr = _pLbWsInterop->GetUODBPhysicalPartitionCount(&lPartCount, (DWORD *)&hrfrominterop);
    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call GetUODBPhysicalPartitionCount through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }
    
    for(LONG part=0; part < lPartCount; part++)
    {
        if(!CallProcLbRemove(part,uiTitleId, uiLbId))
        {
            goto lDone;
        }
    }
    
    fRet = true;

lDone:

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_LBRESET_RATE, 1);
	 if(!fRet)
	 {
            _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_LBRESET_FAIL_RATE, 1);  
	 }
    }

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}


bool CDb::CallProcLbLoad(
    LONG lPhysicalPartition,
    BYTE* pBlob,
    DWORD cbBlob,
    IDbCallback* pCallback
)
{
    bool fRet = false;
    IUmsClient* pUmsClient = NULL;
    CArenaMemAlloc alloc;
    HRESULT hr;
    HRESULT hrfrominterop;
    CComPtr<lbwsinterop::ILbWsReadLbRow> pLbWsReadLbRow;

    SAFEARRAY sa;
    SetupSafeArray(&sa, cbBlob, pBlob);

    struct Results
    {
        LONG uiTitleId;
        LONG uiLbId;
        UINT64 ui64Puid;
        BYTE   rgStatBlob[DbMaxStatBlobSize];
        LONG  cbBlob;
        DATE   dtLastModified;
    } results; 

    SAFEARRAY saRow; //This will hold the LB Raw Data
    SetupSafeArray(&saRow, DbMaxStatBlobSize, &results.rgStatBlob);
        
    hr = _pLbWsInterop->LoadStats(&sa, lPhysicalPartition , &pLbWsReadLbRow, (DWORD *)&hrfrominterop);
    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call LoadStats through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }  
    
    if(NULL == pLbWsReadLbRow)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "pLbWsReadLbRow is NULL");
        goto lDone;
    }
    
    // One last thing. We're going to need a IUmsClient object for
    // the callback
    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;
        
    VARIANT_BOOL bStillHaveRow = VARIANT_FALSE;

    hr = pLbWsReadLbRow->Read(&bStillHaveRow, (DWORD *)&hrfrominterop);
    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call pLbWsReadLbRow->Read through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }  

    while (bStillHaveRow != VARIANT_FALSE)
    {
    
    #ifdef DEBUG
        ZeroMemory(&results, sizeof(Results));
    #endif
    
        hr = pLbWsReadLbRow->GetNextRow(&results.uiTitleId, &results.uiLbId, &results.ui64Puid, &saRow, &results.cbBlob, &results.dtLastModified, (DWORD *)&hrfrominterop);
        if(FAILED(hr) || FAILED(hrfrominterop))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Failed to pLbWsReadLbRow->GetNextRow . hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
            CGlobalError::ProcessComError();
            goto lDone;
        }

        // Parse stats blob
        LbStat rgStats[LbMaxStatsInBuffer];
        DWORD cStats = LbMaxStatsInBuffer;
        
        alloc.Reset();
        if(!DeblobifyStats(&alloc, (BYTE *)saRow.pvData, results.cbBlob, 
            rgStats, &cStats))
        {
            goto lDone;
        }
        
        // Convert last-modified timestamp from OLEDB format to filetime
        SYSTEMTIME systime;
        UINT64 lastModified;
        ::VariantTimeToSystemTime(results.dtLastModified, &systime);
        ::SystemTimeToFileTime(&systime, reinterpret_cast<FILETIME*>(&lastModified));
        
        // Callback
        if(!pCallback->OnRow(pUmsClient, results.uiTitleId, results.uiLbId, 
            results.ui64Puid, rgStats, cStats, lastModified))
        {
            goto lDone;
        }

        hr = pLbWsReadLbRow->Read(&bStillHaveRow, (DWORD *)&hrfrominterop);
        if(FAILED(hr) || FAILED(hrfrominterop))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Failed to call pLbWsReadLbRow->Read through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
            CGlobalError::ProcessComError();
            goto lDone;
        }

        // do some tracking of how many rows we're reading per second
        // since we have no instances, this counter will be shared across all threads that are reading.
        if(NULL != _pPerfCounters)
        {
            _pPerfCounters->IncrementValue32 (LBPERF_SERVER_DB_ROWREAD_RATE, 1);
        }
    }
        
    fRet = true;

lDone:

    if (NULL != pLbWsReadLbRow)
    {
        pLbWsReadLbRow->Close((DWORD *)&hrfrominterop);
    }
    
    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CDb::CallProcLbRemove(
    LONG lPartition,
    UINT32 uiTitleId,
    UINT32 uiLbId
)
{
    bool fRet = false;
    HRESULT hr;
    HRESULT hrfrominterop;

    XTimeElapsed xteTimeElapsed;
    hr = _pLbWsInterop->RemoveLb(uiTitleId, uiLbId, lPartition, (DWORD *)&hrfrominterop);
    // track the execution time of the call to the DB.  This is done as close to the DB as practical,
    // so that other factors don't muddy the waters.
    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->IncrementValue64(LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME, xteTimeElapsed.MillisecondsElapsed());
        _pPerfCounters->IncrementValue32(LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME_BASE, 1);			
    }

    if(FAILED(hr) || FAILED(hrfrominterop))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Failed to call p_stats_lb_remove through the interop. hr = 0x%08x, hrinternal = 0x%08x", hr, hrfrominterop);
        CGlobalError::ProcessComError();
        goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Encode array of LbStat in a blob to be stored in the database
bool CDb::BlobifyStats(
    LbStat rgStats[],
    DWORD cStats,
    BYTE rgbStatBlob[],
    DWORD* pcbStatBlob
)
{
    bool fRet = false;
    DWORD i=0;
    
    DWORD cbMax = *pcbStatBlob;
    DWORD cbUsed = 0;
    BYTE* p = rgbStatBlob;
    
    for(i=0; i < cStats; i++)
    {
        // This should be the minimum space left necessary to write any stat
        // in the blob. In reality, most of the time we won't need the 8 bytes
        // for the INT64 but it simplifies the code a bit checking for the 
        // available space just once.
        if(cbMax - cbUsed < sizeof(WORD) + sizeof(BYTE) + sizeof(INT64))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Not enough space in the blob for the stat");
            goto lDone;
        }
        
        // Write Stat Id
        *reinterpret_cast<WORD*>(p) = rgStats[i].statId;
        p += sizeof(WORD);
        
        // Write Type
        *reinterpret_cast<BYTE*>(p) = rgStats[i].bType;
        p += sizeof(BYTE);
        
        cbUsed += sizeof(WORD)+sizeof(BYTE);
        
        // Write data
        switch(rgStats[i].bType)
        {
        case LbspTypeIdInt8:
            *reinterpret_cast<INT8*>(p) = rgStats[i].i8;
            p += sizeof(INT8);
            cbUsed += sizeof(INT8);
            break;
            
        case LbspTypeIdInt16:
            *reinterpret_cast<INT16*>(p) = rgStats[i].i16;
            p += sizeof(INT16);
            cbUsed += sizeof(INT16);
            break;
        
        case LbspTypeIdInt32:
            *reinterpret_cast<INT32*>(p) = rgStats[i].i32;
            p += sizeof(INT32);
            cbUsed += sizeof(INT32);
            break;
        
        case LbspTypeIdInt64:
            *reinterpret_cast<INT64*>(p) = rgStats[i].i64;
            p += sizeof(INT64);
            cbUsed += sizeof(INT64);
            break;
        
        case LbspTypeIdDouble:
            *reinterpret_cast<double*>(p) = rgStats[i].d;
            p += sizeof(double);
            cbUsed += sizeof(double);
            break;
        
        case LbspTypeIdString:
        {
            if(cbMax - cbUsed < sizeof(WORD) + rgStats[i].str.wStrLen)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "Not enough space in the blob for the stat");
                goto lDone;
            }
            
            *reinterpret_cast<WORD*>(p) = rgStats[i].str.wStrLen;
            p += sizeof(WORD);
            
            CopyMemory(p, rgStats[i].str.pstr, rgStats[i].str.wStrLen);
            p += rgStats[i].str.wStrLen;
            
            cbUsed += sizeof(WORD) + rgStats[i].str.wStrLen; 
            break;
        }
        
        default:
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Invalid type");
            goto lDone;
        }
    }
    
	DBGASSERT(p >= rgbStatBlob);
    DBGASSERT((DWORD)(p - rgbStatBlob) < cbMax);
    
    *pcbStatBlob = cbUsed;

    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CDb::DeblobifyStats(
    CArenaMemAlloc* pAlloc,
    BYTE* pBlob,
    DWORD cbBlob,
    LbStat rgStats[],
    DWORD* pcStats
)
{
    bool fRet = false;
    
    DWORD cMaxStats = *pcStats;
    int   cbLeft    = cbBlob;
    BYTE* p         = pBlob;
    DWORD i         = 0;
    
    for(i=0; i < cMaxStats; i++)
    {
        if(cbLeft == 0)
            break;
        
        cbLeft -= sizeof(WORD) + sizeof(BYTE);
        if(cbLeft <= 0)
            break;
            
        rgStats[i].statId = *reinterpret_cast<WORD*>(p);
        p += sizeof(WORD);
        
        rgStats[i].bType  = *reinterpret_cast<BYTE*>(p);
        p += sizeof(BYTE);
        
        switch(rgStats[i].bType)
        {
        case LbspTypeIdInt8:
            cbLeft -= sizeof(INT8);
            if(cbLeft < 0) goto lDone;
            rgStats[i].i8 = *reinterpret_cast<INT8*>(p);
            p += sizeof(INT8);
            break;
            
        case LbspTypeIdInt16:
            cbLeft -= sizeof(INT16);
            if(cbLeft < 0) goto lDone;
            rgStats[i].i16 = *reinterpret_cast<INT16*>(p);
            p += sizeof(INT16);
            break;
        
        case LbspTypeIdInt32:
            cbLeft -= sizeof(INT32);
            if(cbLeft < 0) goto lDone;
            rgStats[i].i32 = *reinterpret_cast<INT32*>(p);
            p += sizeof(INT32);
            break;
        
        case LbspTypeIdInt64:
            cbLeft -= sizeof(INT64);
            if(cbLeft < 0) goto lDone;
            rgStats[i].i64 = *reinterpret_cast<INT64*>(p);
            p += sizeof(INT64);
            break;
        
        case LbspTypeIdDouble:
            cbLeft -= sizeof(double);
            if(cbLeft < 0) goto lDone;
            rgStats[i].d = *reinterpret_cast<double*>(p);
            p += sizeof(double);
            break;
        
        case LbspTypeIdString:
        {
            // String length
            cbLeft -= sizeof(UINT16);
            if(cbLeft < 0) goto lDone;
            rgStats[i].str.wStrLen = *reinterpret_cast<INT16*>(p);
            p += sizeof(INT16);
            
            // String itself
            cbLeft -= rgStats[i].str.wStrLen;
            if(cbLeft < 0) goto lDone;
            
            rgStats[i].str.pstr = (CHAR*)pAlloc->Alloc(rgStats[i].str.wStrLen);
            if(NULL == rgStats[i].str.pstr)
                goto lDone;
                
            CopyMemory(rgStats[i].str.pstr, p, rgStats[i].str.wStrLen);
            p += rgStats[i].str.wStrLen;
            break;
        }
        
        default:
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Invalid type");
            goto lDone;
        }
    }
    
    if(cbLeft < 0)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough data left to parse value");
        goto lDone;
    }
    else if(cbLeft > 0)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Too many attributes in blob");
    }
    
    *pcStats = i;
    
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

//Note FADF_AUTO means the memory pointed to by pAddr is allocated in the stack
void CDb::SetupSafeArray( SAFEARRAY *pSA, DWORD dwElements, PVOID pAddr )
{
    pSA->cbElements = sizeof(BYTE);
    pSA->cDims = 1;
    pSA->rgsabound[0].cElements = dwElements;
    pSA->rgsabound[0].lLbound = 0;
    pSA->cLocks = 0;
    pSA->fFeatures = FADF_AUTO;

    // assign the pointer value.
    pSA->pvData = pAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\lb.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 *
 * Leaderboard Server
 *
 * lb.cpp
 * Implementation of leaderboard server leaderboard classes
 * Header: lb.h
 *
 */

#include "lbs.h"
/*****************************************************************************
  LbBlob
*****************************************************************************/

bool LbBlob::UpdateStats(
    LbStat rgStats[],
    DWORD  cStats,
    BYTE*  pOrigBlob,
    DWORD  cbOrigBlob,
    BYTE*  pNewBlob,
    DWORD* pcbNewBlob
)
{
    bool  fRet            = false;
    DWORD cbOrigRemg      = cbOrigBlob;
    DWORD cbNewRemg       = *pcbNewBlob - sizeof(LbBlob);
    DWORD dwCopied        = 0;
    WORD  cStat           = 0;
    LbBlob* pLbBlob       = (LbBlob*) pNewBlob;

    // Skip the stat count at the beginning of the blobs
    pNewBlob += sizeof(LbBlob);

    if(cbOrigBlob >= sizeof(LbBlob))
    {
        pOrigBlob  += sizeof(LbBlob);
        cbOrigRemg -= sizeof(LbBlob);
    }

    for(DWORD dwStatNdx = 0; dwStatNdx < cStats; dwStatNdx++)
    {
        // Copy all stats from original blob that preceed current stat
        while(cbOrigRemg > 0)
        {
            LbBlobStat* pBlobStat = (LbBlobStat*)pOrigBlob;

            if(pBlobStat->statId < rgStats[dwStatNdx].statId)
            {
                // Copy stat
                dwCopied = CopyStatBetweenBlobs(pOrigBlob,cbOrigRemg,pNewBlob,cbNewRemg);

                if(0 == dwCopied)
                    goto lDone;

                pOrigBlob  += dwCopied;
                cbOrigRemg -= dwCopied;
                pNewBlob   += dwCopied;
                cbNewRemg  -= dwCopied;

                cStat++;
            }
            else if(pBlobStat->statId == rgStats[dwStatNdx].statId)
            {
                // Skip stat
                dwCopied = GetBlobStatSize(pBlobStat, cbOrigRemg);

                if(0 == dwCopied)
                    goto lDone;

                pOrigBlob  += dwCopied;
                cbOrigRemg -= dwCopied;

                break;
            }
            else
            {
                break;
            }
        }

        // Copy stat if not null. Don't copy the rating either. It's
        // a special case. The rating is stored in the key of the btree
        // instead of in the blob

        if(!rgStats[dwStatNdx].IsNull()
           && rgStats[dwStatNdx].statId != LbStatIdRating)
        {
            dwCopied = CopyStatFromLbStatToBlob(&rgStats[dwStatNdx], pNewBlob, cbNewRemg);

            if(0 == dwCopied)
                goto lDone;

            pNewBlob  += dwCopied;
            cbNewRemg -= dwCopied;

            cStat++;
        }
    }

    // Copy remaining stats from original blob
    while(cbOrigRemg > 0)
    {
        dwCopied = CopyStatBetweenBlobs(pOrigBlob,cbOrigRemg,pNewBlob,cbNewRemg);

        if(0 == dwCopied)
            goto lDone;

        pOrigBlob  += dwCopied;
        cbOrigRemg -= dwCopied;
        pNewBlob   += dwCopied;
        cbNewRemg  -= dwCopied;

        cStat++;
    }

    pLbBlob->wStatCount = cStat;

    *pcbNewBlob -= cbNewRemg;

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool LbBlob::ParseStats(
    BYTE* pBlob,
    DWORD cbBlob,
    CArenaMemAlloc* pAlloc,
    LbStat rgStats[],
    DWORD* pcStats
)
{
    bool fRet = false;
    WORD cStats;

    if(cbBlob < sizeof(LbBlob))
    {
        *pcStats = 0;
        fRet = true;
        goto lDone;
    }

    cStats  = ((LbBlob*)pBlob)->wStatCount;
    pBlob  += sizeof(LbBlob);
    cbBlob -= sizeof(LbBlob);

    for(int i=0; i < cStats; i++)
    {
        LbBlobStat* pStat = (LbBlobStat*) pBlob;

        DWORD dwStatSize = GetBlobStatSize(pStat,cbBlob);

        if(dwStatSize == 0)
            goto lDone;

        rgStats[i].statId = pStat->statId;
        rgStats[i].bType  = pStat->bType;

        switch(pStat->bType)
        {
        case LbspTypeIdInt8:
            rgStats[i].i8  = pStat->i8;
            break;
        case LbspTypeIdInt16:
            rgStats[i].i16 = pStat->i16;
            break;
        case LbspTypeIdInt32:
            rgStats[i].i32 = pStat->i32;
            break;
        case LbspTypeIdInt64:
            rgStats[i].i64 = pStat->i64;
            break;
        case LbspTypeIdDouble:
            rgStats[i].d   = pStat->d;
            break;
        case LbspTypeIdString:
            rgStats[i].str.wStrLen = pStat->str.wStrLen;
            rgStats[i].str.pstr    = (CHAR*) pAlloc->Alloc(rgStats[i].str.wStrLen+1);

            if(NULL == rgStats[i].str.pstr)
                goto lDone;

            CopyMemory(rgStats[i].str.pstr, pStat->str.str,
                pStat->str.wStrLen);

            break;
        default:
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Invalid Stat type %u", (DWORD) pStat->bType);
            goto lDone;
        }

        pBlob  += dwStatSize;
        cbBlob -= dwStatSize;
    }

    DBGASSERT(cbBlob == 0);

    *pcStats = cStats;

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

DWORD LbBlob::CopyStatBetweenBlobs(
    BYTE*  pOrigBlob,
    DWORD  cbOrigBlob,
    BYTE*  pNewBlob,
    DWORD  cbNewBlob
)
{
    DWORD dwSize = 0;
    LbBlobStat* pBlobStat = (LbBlobStat*) pOrigBlob;
    LbBlobStat* pNewStat  = (LbBlobStat*) pNewBlob;

    // Check if there is space in the blob for our biggest
    // fixed-length Stat. We may not be 100% efficient in using
    // the blob but it's a lot simpler this way.

    if(cbNewBlob < sizeof(LbBlobStat))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough space in the blob for all Stats");
        goto lDone;
    }

    // Write stat from old blob to new blob

    pNewStat->statId = pBlobStat->statId;
    pNewStat->bType  = pBlobStat->bType;

    switch(pBlobStat->bType)
    {
    case LbspTypeIdInt8:
        pNewStat->i8 = pBlobStat->i8;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT8);
        break;
    case LbspTypeIdInt16:
        pNewStat->i16= pBlobStat->i16;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT16);
        break;
    case LbspTypeIdInt32:
        pNewStat->i32= pBlobStat->i32;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT32);
        break;
    case LbspTypeIdInt64:
        pNewStat->i64= pBlobStat->i64;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT64);
        break;
    case LbspTypeIdDouble:
        pNewStat->d  = pBlobStat->d;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(double);
        break;
    case LbspTypeIdString:

        if(cbNewBlob < sizeof(LbBlobStat) + pBlobStat->str.wStrLen)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Not enough space in the blob for all Stats");
            goto lDone;
        }

        pNewStat->str.wStrLen = pBlobStat->str.wStrLen;
        CopyMemory(pNewStat->str.str, pBlobStat->str.str,
            pBlobStat->str.wStrLen);

        dwSize = offsetof(LbBlobStat, i8) + sizeof(pNewStat->str.wStrLen)
            + pNewStat->str.wStrLen;

        break;
    default:

        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Invalid Stat type %u", (DWORD) pBlobStat->bType);
        goto lDone;
    }

    DBGASSERT(cbOrigBlob >= dwSize);

lDone:

    return dwSize;
}

DWORD LbBlob::CopyStatFromLbStatToBlob(
    LbStat* pStat,
    BYTE*   pBlob,
    DWORD   cbBlob
)
{
    DWORD dwSize = 0;
    LbBlobStat* pBlobStat = (LbBlobStat*) pBlob;

    DBGASSERT((pStat->bType & LbspTypeIdNullFlag) == 0);

    if(cbBlob < sizeof(LbBlobStat))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough space in the blob for all Stats");
        goto lDone;
    }

    pBlobStat->statId = pStat->statId;
    pBlobStat->bType  = pStat->bType;

    switch(pStat->bType)
    {
    case LbspTypeIdInt8:
        pBlobStat->i8 = pStat->i8;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT8);
        break;
    case LbspTypeIdInt16:
        pBlobStat->i16= pStat->i16;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT16);
        break;
    case LbspTypeIdInt32:
        pBlobStat->i32= pStat->i32;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT32);
        break;
    case LbspTypeIdInt64:
        pBlobStat->i64= pStat->i64;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(INT64);
        break;
    case LbspTypeIdDouble:
        pBlobStat->d  = pStat->d;
        dwSize = offsetof(LbBlobStat, i8) + sizeof(double);
        break;
    case LbspTypeIdString:

        if(cbBlob < sizeof(LbBlobStat) + pStat->str.wStrLen)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Not enough space in the blob for all Stats");
            goto lDone;
        }

        pBlobStat->str.wStrLen = pStat->str.wStrLen;
        CopyMemory(pBlobStat->str.str, pStat->str.pstr,
            pStat->str.wStrLen);

        dwSize = offsetof(LbBlobStat, i8) + sizeof(pBlobStat->str.wStrLen)
            + pBlobStat->str.wStrLen;

        break;
    default:

        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Invalid Stat type %u", (DWORD) pStat->bType);
        goto lDone;
    }

lDone:

    return dwSize;
}

DWORD LbBlob::GetBlobStatSize(LbBlobStat* pStat, DWORD cbBlob)
{
    static const DWORD StatSize[LbspTypeIdString + 1] =
    {
        0,
        offsetof(LbBlobStat, i8) + sizeof(INT8),     // LbspTypeIdInt8
        offsetof(LbBlobStat, i8) + sizeof(INT16),    // LbspTypeIdInt16
        offsetof(LbBlobStat, i8) + sizeof(INT32),    // LbspTypeIdInt32
        offsetof(LbBlobStat, i8) + sizeof(INT64),    // LbspTypeIdInt64
        offsetof(LbBlobStat, i8) + sizeof(double),   // LbspTypeIdDouble
        offsetof(LbBlobStat, i8) + sizeof(WORD)      // LbspTypeIdString
    };

    if(cbBlob < sizeof(LbStatId))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "cbBlob < sizeof(LbStatId)");
        return 0;
    }

    DWORD dwSize;

    if(pStat->bType >= LbspTypeIdInt8
       && pStat->bType <= LbspTypeIdDouble)
    {
        dwSize = StatSize[pStat->bType];
    }
    else if(pStat->bType == LbspTypeIdString)
    {
        if(cbBlob < offsetof(LbBlobStat, i8) + sizeof(WORD))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "cbBlob < offsetof(LbBlobStat, i8) + sizeof(WORD)");
            return 0;
        }

        dwSize = offsetof(LbBlobStat, i8) + sizeof(WORD) +
            pStat->str.wStrLen;
    }
    else
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Invalid blob stat type %u", (DWORD) pStat->bType);
    }

    if(dwSize > cbBlob)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "dwSize > cbBlob");
        return 0;
    }

    return dwSize;
}

/*****************************************************************************
  CLb
*****************************************************************************/

CLb::CLb(
    DWORD dwTitleId,
    DWORD dwLbId,
    LbResetType resetType,
    UINT uiDecayDays,
    UINT uiMaxEntryCount,
    UINT64 lastResetTime,
    CLbList * plblistParent
)
{
    _pConfig           = NULL;
    _pPersister        = NULL;
    _dwTitleId         = dwTitleId;
    _dwLbId            = dwLbId;
    _eResetType        = resetType;
    _dwDecayDays       = uiDecayDays;
    _dwMaxEntryCount   = uiMaxEntryCount;
    _ui64Untier          = 0;
    _lRefCount         = 0;
    _lRankedEntryCount = 0;
    _fPersist          = TRUE;
    _lastResetTime     = lastResetTime;
    _perfInstancePerLB.dwInstanceID = (DWORD)-1;
    _perfInstancePerLB.pbDataStart = NULL;
    _plblistParent = plblistParent;
}

bool CLb::Init(
    IUmsClient* pUmsClient,
    CBufferManager*  pBM,
    CPersister* pPersister,
    CConfig* pConfig
)
{
    bool fRet = false;

    _pConfig    = pConfig;
    _pPersister = pPersister;

    if(!_userIndex.Init(pUmsClient, pBM, LbPuidIndexKey::KeyCompare,
        sizeof(LbPuidIndexKey)))
    {
        goto lDone;
    }

    if(!_leaderboard.Init(pUmsClient, pBM,
        LbKey::DescendingKeyCompare, sizeof(LbKey)))
    {
        goto lDone;
    }

    _lbStatus = Created;

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CLb::GetLbStatus(
        LbStatus *  pLbStatus
    )
{
    bool  fRet      = false;
    if (NULL == pLbStatus)
        goto lDone;

    /*
        The purpose is to eventually stop all Stat Write or Read. This does not have to happen instanteneously.
    */
  
    _LbStatusFastLock.Lock();

    *pLbStatus = _lbStatus;

    _LbStatusFastLock.Unlock();

    fRet = true;

lDone:

    return fRet;
}

bool CLb::SetLbStatus(
    LbStatus    lbStatus
)
{
    bool  fRet      = false;

    _LbStatusFastLock.Lock();

    _lbStatus = lbStatus;

    _LbStatusFastLock.Unlock();

    fRet = true;

    return fRet;
}

void CLb::Term(IUmsClient* pUmsClient)
{
    Term(pUmsClient, false);
}

void CLb::Term(IUmsClient* pUmsClient, bool fApplicationTerminates)
{
    if (!fApplicationTerminates)
    {
        _userIndex.Term(pUmsClient);
        _leaderboard.Term(pUmsClient);
    }
}

// Update/Insert leaderboard row
bool CLb::StatWrite(
    IUmsClient* pUmsClient,
    UINT64 puid,
    LbStat rgStat[],
    DWORD  cStat
)
{
    UINT64 lastUpdateTime = ::GetUTCTimeAsUint64();
    return StatWriteEx(pUmsClient,puid,rgStat,cStat,lastUpdateTime);
}

// Update/Insert leaderboard row
bool CLb::StatWriteEx(
    IUmsClient* pUmsClient,
    UINT64 puid,
    LbStat rgStat[],
    DWORD  cStat,
    UINT64 lastUpdateTime
)
{
    bool  fRet      = false;
    bool  fNewLbKey = false;
    bool  fNewEntry = false;
    LbKey newLbKey;
    LbKey curLbKey;
    UMSSafeLockCookie puidLock(pUmsClient);
    UMSSafeLockCookie lbLock(pUmsClient);
    LOCK_ID lidPuid;
    LOCK_ID lidLb;

    if(!GetIndexedStats(rgStat,cStat,&newLbKey,&fNewLbKey))
    {
        goto lDone;
    }

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone;

    if(_dwMaxEntryCount != 0)
    {
        // If this is a lightweight leaderboard or, in other words, a
        // leaderboard with a rank cap, the entry needs a rating to qualify

        if(!fNewLbKey // If the key was not specified
           || newLbKey.IsNull() // Of if it's null
           || !CheckForRankCap(pUmsClient, &newLbKey)) // Or if it doesnt qualify
        {
            // Entry does not qualify
            fRet = true;
            goto lDone;
        }
    }

    // Get lock on puid
    lidPuid.type = LOCK_TYPE_PUID;
    lidPuid.id   = puid;
    if(!pUmsClient->AcquireLock(lidPuid, LOCK_MODE_X, &puidLock))
        goto lDone;

    if(!UpdatePuidIndex(pUmsClient, puid, fNewLbKey ? &newLbKey : NULL,
        &curLbKey, &fNewEntry, lastUpdateTime))
    {
        goto lDone;
    }

    if(!UpdateLeaderboard(pUmsClient, puid, &curLbKey,
        fNewLbKey ? &newLbKey : NULL, fNewEntry, rgStat, cStat))
    {
        goto lDone;
    }

    // Adjust ranked entry count accordingly. This is not the number of
    // entries in the leaderboard but the number of entries which don't
    // have a NULL rating
    if(fNewLbKey)
    {
        if(fNewEntry)
        {
            if(!newLbKey.IsNull())
            {
                // Entry is new and it's ranked
                InterlockedIncrement(&_lRankedEntryCount);
            }
        }
        else
        {
            if(curLbKey.IsNull() && !newLbKey.IsNull())
            {
                // Entry is not new and changed from unranked to ranked
                InterlockedIncrement(&_lRankedEntryCount);
            }
            else if(!curLbKey.IsNull() && newLbKey.IsNull())
            {
                // Entry is not new and changed from ranked to unranked
                InterlockedDecrement(&_lRankedEntryCount);
            }
        }
    }

    // Mark the row in the persister as 'changed'. It will update the external
    // database on the background
    if(_fPersist)
    {
        if(!_pPersister->MarkLbRowForUpdate(pUmsClient,_dwTitleId,_dwLbId, puid))
            goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}
bool CLb::EnumByRating(
    IUmsClient* pUmsClient,
    LbKey key,
    DWORD dwEntryCount,
    ILbEnumCallback* pCallback
)
{
    bool fRet = false;
    BTree::Iterator it;
    CArenaMemAlloc alloc;
    UMSSafeLockCookie lbLock(pUmsClient);
    LbStat rgStats[LbMaxStatBuffer + 1];
    DWORD cStats;
    LOCK_ID lidLb;

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone;

    if(!_leaderboard.SearchEx(pUmsClient, (void *)&key, sizeof(LbKey), false,&it, true, NULL))
        goto lDone;

    for(DWORD i=0; i < dwEntryCount && it.Read(); i++)
    {
        LbKey*  pLbKey;
        WORD    cbLbKey;
        LbBlob* pLbBlob;
        WORD    cbLbBlob;

        it.Get((void**)&pLbKey, &cbLbKey,(void**)&pLbBlob,&cbLbBlob);

        if(cbLbKey != sizeof(LbKey) ||
           cbLbBlob < sizeof(LbBlob) ||
           pLbBlob->wStatCount > LbMaxStatsInBuffer)
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Data corruption detected!");


            goto lDone;
        }

        if(pLbKey->IsNull() ||
           LbKey::DescendingKeyCompare(NULL, (void *)pLbKey, cbLbKey, &key,
           sizeof(LbKey)) < 0)
            break;

        if(_dwMaxEntryCount > 0 && it.GetRank() > _dwMaxEntryCount)
        {
            // This leaderboard has a rank cap (lightweight leaderboard) and
            // we cannot enumerate past it
            break;
        }

        if(!LbBlob::ParseStats((BYTE*)pLbBlob, cbLbBlob, &alloc, rgStats, &cStats))
            goto lDone;

        rgStats[cStats].statId = LbStatIdRating;
        rgStats[cStats].bType  = LbspTypeIdInt64;
        rgStats[cStats].i64    = pLbKey->i64Rating;
        cStats++;

        if(!pCallback->OnNewRow(it.GetRank(),pLbBlob->puid,rgStats,cStats))
            goto lDone;

        alloc.Reset();
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}


bool CLb::EnumByRank(
    IUmsClient* pUmsClient,
    DWORD dwRank,
    DWORD dwEntryCount,
    ILbEnumCallback* pCallback
)
{
    bool fRet = false;
    BTree::Iterator it;
    CArenaMemAlloc alloc;
    UMSSafeLockCookie lbLock(pUmsClient);
    LbStat rgStats[LbMaxStatBuffer + 1];
    DWORD cStats;
    LOCK_ID lidLb;

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone;

    if(0 == dwRank)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "dwRank cannot be zero.");
        goto lDone;
    }

    if(!_leaderboard.SearchByRank(pUmsClient, dwRank, false ,&it))
        goto lDone;


    for(DWORD i=0; i < dwEntryCount && it.Read(); i++)
    {
        LbKey*  pLbKey;
        WORD    cbLbKey;
        LbBlob* pLbBlob;
        WORD    cbLbBlob;

        it.Get((void**)&pLbKey, &cbLbKey,(void**)&pLbBlob,&cbLbBlob);

        if(cbLbKey != sizeof(LbKey) ||
           cbLbBlob < sizeof(LbBlob) ||
           pLbBlob->wStatCount > LbMaxStatsInBuffer)
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Data corruption detected!");

            goto lDone;
        }

        if(pLbKey->IsNull() || it.GetRank() < dwRank)
            break;

        if(_dwMaxEntryCount > 0 && it.GetRank() > _dwMaxEntryCount)
        {
            // This leaderboard has a rank cap (lightweight leaderboard) and
            // we cannot enumerate past it
            break;
        }

        if(!LbBlob::ParseStats((BYTE*)pLbBlob, cbLbBlob, &alloc, rgStats, &cStats))
            goto lDone;

        rgStats[cStats].statId = LbStatIdRating;
        rgStats[cStats].bType  = LbspTypeIdInt64;
        rgStats[cStats].i64    = pLbKey->i64Rating;
        cStats++;

        if(!pCallback->OnNewRow(it.GetRank(),pLbBlob->puid,rgStats,cStats))
            goto lDone;

        alloc.Reset();
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}



bool CLb::UpdateLeaderboard(
    IUmsClient* pUmsClient,
    UINT64 puid,
    LbKey* pCurLbKey,
    LbKey* pNewLbKey,
    bool   fNewLbEntry,
    LbStat rgStat[],
    DWORD  cStat
)
{
    bool fRet = false;
    BTree::SEARCHSTATUS searchStatus;
    BTree::INSERTSTATUS insertStatus;
    BTree::DELETESTATUS deleteStatus;
    BTree::Iterator it;
    BYTE rgNewLbBlob[LbMaxStatBuffer];
    LbBlob* pNewLbBlob = (LbBlob*) rgNewLbBlob;
    DWORD cNewLbBlob = 0;

    if(!fNewLbEntry)
    {
        bool fDeleteInsert = true;

        if(pNewLbKey == NULL ||
             (pNewLbKey->i64Rating  == pCurLbKey->i64Rating
             && pNewLbKey->IsNull() == pCurLbKey->IsNull()))
        {
            searchStatus = _leaderboard.SearchLE(pUmsClient, pCurLbKey,
                sizeof(LbKey), true, &it);

            if(searchStatus != BTree::SEARCHSTATUS_SUCCEEDED)
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

            BYTE* pData;
            WORD cbData;

            if(!it.Read())
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

            it.Get(NULL, NULL, (void**)&pData, &cbData);

            if(cbData < sizeof(LbBlob) || cbData > LbMaxStatBuffer)
            {
                DBGASSERT(false);
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "Data corruption detected!");

                goto lDone;
            }

            pNewLbBlob->puid = puid;

            cNewLbBlob = sizeof(rgNewLbBlob);
            if(!LbBlob::UpdateStats(rgStat, cStat, pData,
                cbData, (BYTE*)pNewLbBlob, &cNewLbBlob))
            {
                goto lDone;
            }

            if(cNewLbBlob == cbData)
            {
                // Lock must be X
                CopyMemory(pData, pNewLbBlob, cNewLbBlob);
                fDeleteInsert = false;
            }

            it.Reset();
        }

        if(fDeleteInsert)
        {
            BYTE rgOrigLbBlob[LbMaxStatBuffer];
            LbBlob* pOrigLbBlob = (LbBlob*) rgOrigLbBlob;
            WORD cOrigLbBlob = 0;

            cOrigLbBlob = sizeof(rgOrigLbBlob);
            deleteStatus = _leaderboard.Delete(pUmsClient, pCurLbKey,
                sizeof(LbKey), rgOrigLbBlob, &cOrigLbBlob);

            if(deleteStatus != BTree::DELETESTATUS_SUCCEEDED)
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

            if(cOrigLbBlob > sizeof(rgOrigLbBlob))
            {
                DBGASSERT(false);
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "Data corruption detected\n");
                goto lDone;
            }

            pNewLbBlob->puid = puid;

            cNewLbBlob = sizeof(rgNewLbBlob);
            if(!LbBlob::UpdateStats(rgStat, cStat, rgOrigLbBlob,
                cOrigLbBlob, (BYTE*)pNewLbBlob, &cNewLbBlob))
            {
                goto lDone;
            }

            DBGASSERT(cNewLbBlob >= sizeof(LbBlob) && cNewLbBlob <= LbMaxStatBuffer);

            insertStatus = _leaderboard.Insert(pUmsClient,
                pNewLbKey != NULL ? pNewLbKey : pCurLbKey,
                sizeof(LbKey), pNewLbBlob, (WORD)cNewLbBlob);

            if(insertStatus != BTree::INSERTSTATUS_SUCCEEDED)
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

        }
    }
    else
    {
        pNewLbBlob->puid = puid;

        cNewLbBlob = sizeof(rgNewLbBlob);
        if(!LbBlob::UpdateStats(rgStat, cStat, NULL,
            0, (BYTE*)pNewLbBlob, &cNewLbBlob))
        {
            goto lDone;
        }

        DBGASSERT(cNewLbBlob >= sizeof(LbBlob) && cNewLbBlob <= LbMaxStatBuffer);

        insertStatus = _leaderboard.Insert(pUmsClient,
            pNewLbKey != NULL ? pNewLbKey : pCurLbKey,
            sizeof(LbKey), pNewLbBlob, (WORD)cNewLbBlob);

        if(insertStatus != BTree::INSERTSTATUS_SUCCEEDED)
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
            goto lDone;
        }

    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CLb::UpdatePuidIndex(
    IUmsClient* pUmsClient,
    UINT64 puid,
    LbKey* pNewLbKey,
    LbKey* pCurLbKey,
    bool*  pfNewLbEntry,
    UINT64 lastUpdateTime
)
{
    bool fRet = false;
    BTree::SEARCHSTATUS searchStatus;
    BTree::INSERTSTATUS insertStatus;
    BTree::Iterator it;
    LbPuidIndexKey puidKey = { puid };

    searchStatus = _userIndex.SearchLE(pUmsClient,&puidKey,sizeof(puidKey),
        true, &it);

    if(BTree::SEARCHSTATUS_SUCCEEDED == searchStatus)
    {
        LbPuidIndexBlob* pPuidIndexBlob;
        WORD             cPuidIndexBlob;

        if(!it.Read())
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
            goto lDone;
        }

        it.Get(NULL,NULL,(void**)&pPuidIndexBlob,&cPuidIndexBlob);

        if(cPuidIndexBlob != sizeof(LbPuidIndexBlob))
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Data corruption detected!");
            goto lDone;
        }

        // Update 'last update time'
        pPuidIndexBlob->lastUpdateTime = lastUpdateTime;

        *pfNewLbEntry = false;
        *pCurLbKey    = pPuidIndexBlob->lbKey;

        if(pNewLbKey != NULL)
        {
            if(pNewLbKey->i64Rating != pCurLbKey->i64Rating
               || pNewLbKey->IsNull() != pCurLbKey->IsNull())
            {
                pPuidIndexBlob->lbKey = *pNewLbKey;
            }
            else
            {
                *pNewLbKey = *pCurLbKey;
            }
        }

        // Release search lock
        it.Reset();
    }
    else if(BTree::SEARCHSTATUS_NOT_FOUND == searchStatus)
    {
        LbPuidIndexBlob puidIndexBlob;

        // Release search lock
        it.Reset();

        // Set the last updated time to now
        puidIndexBlob.lastUpdateTime = lastUpdateTime;

        *pfNewLbEntry = true;
        if(pNewLbKey != NULL)
        {
            puidIndexBlob.lbKey = *pNewLbKey;
        }
        else
        {
            DefaultLbKey(&puidIndexBlob.lbKey);
        }

        *pCurLbKey = puidIndexBlob.lbKey;

        insertStatus = _userIndex.Insert(pUmsClient, &puidKey, sizeof(puidKey),
            &puidIndexBlob, sizeof(puidIndexBlob));

        if(insertStatus != BTree::INSERTSTATUS_SUCCEEDED)
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
            goto lDone;
        }
    }
    else
    {
        *pfNewLbEntry = false;
        goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CLb::GetIndexedStats(
    IN LbStat rgStat[],
    IN DWORD  cStats,
    OUT LbKey* pNewLbKey,
    OUT bool* pfNewLbKey
)
{
    bool fRet = false;

    *pfNewLbKey = false;

    for(int iStat=0; (DWORD)iStat < cStats; iStat++)
    {
        if(LbStatIdRating == rgStat[iStat].statId)
        {
            DBGASSERT(!(*pfNewLbKey));

            *pfNewLbKey = true;

            if(!rgStat[iStat].IsNull())
            {
                if(rgStat[iStat].GetType() != LbspTypeIdInt64)
                {
                    CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                        "Wrong type for rating (%u). The type is %u and "
                        "expected type is INT64(%u)",
                        (DWORD)rgStat[iStat].statId,
                        (DWORD)rgStat[iStat].bType,
                        (DWORD)LbspTypeIdInt64);
                    goto lDone;
                }

                pNewLbKey->i64Rating = rgStat[iStat].i64;
                pNewLbKey->ui64Untier  = InterlockedIncrement64(
                    (volatile LONGLONG*)&_ui64Untier) & LbUntierValueMask;
            }
            else
            {
                DefaultLbKey(pNewLbKey);
            }
        }
    }

    fRet = true;

lDone:

    return fRet;
}

CLb::GetRankForLbkeyStatus CLb::GetRankForLbkey(
    IUmsClient* pUmsClient,
    LbKey lbKey,
    CArenaMemAlloc* pAlloc,
    DWORD* pdwRank
)
{
    GetRankForLbkeyStatus status = GetRankForLbkeyStatusOtherError;
    UMSSafeLockCookie lbLock(pUmsClient);
    BTree::SEARCHSTATUS searchStatus;
    BTree::Iterator itLb;
    DWORD dwRank = 0;
    LOCK_ID lidLb;

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone; 
   
    // Search leaderboard
    searchStatus = _leaderboard.SearchGE(pUmsClient,&lbKey,sizeof(LbKey), false, &itLb);

    if(BTree::SEARCHSTATUS_OTHER_ERROR == searchStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "GetRankForLbkey - Error While Performing Search GE ");
        goto lDone;
    }

    if(!itLb.Read())
    {
        //Either we are at the end of the leaderboard or the leaderboard is empty
        *pdwRank = MAX(itLb.GetRank() + 1, 1);
    }
    else
    {
        *pdwRank = itLb.GetRank();
    }
    
    status = GetRankForLbkeyStatusSucceeded;

lDone:

    if(status != GetRankForLbkeyStatusSucceeded)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}


CLb::StatReadStatus CLb::StatRead(
    IUmsClient* pUmsClient,
    UINT64 puid,
    CArenaMemAlloc* pAlloc,
    LbStat** ppStats,
    DWORD* pcStats,
    DWORD* pdwRank,
    UINT64* pui64lastUpdateTime
)
{
    StatReadStatus status = StatReadStatusOtherError;
    UMSSafeLockCookie puidLock(pUmsClient);
    UMSSafeLockCookie lbLock(pUmsClient);
    BTree::SEARCHSTATUS searchStatus;
    BTree::Iterator itUser;
    BTree::Iterator itLb;
    DWORD dwRank = 0;
    LOCK_ID lidPuid;
    LOCK_ID lidLb;

    *ppStats = NULL;
    *pcStats = 0;

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone;

    // Get lock on puid
    lidPuid.type = LOCK_TYPE_PUID;
    lidPuid.id   = puid;
    if(!pUmsClient->AcquireLock(lidPuid, LOCK_MODE_IS, &puidLock))
    {
        goto lDone;
    }

    // Search puid index
    LbPuidIndexKey userKey;
    userKey.ui64Puid = puid;
    searchStatus = _userIndex.SearchLE(pUmsClient, &userKey, sizeof(userKey),
        false, &itUser);

    if(BTree::SEARCHSTATUS_NOT_FOUND == searchStatus)
    {
        status = StatReadStatusNotFound;
        goto lDone;
    }
    else if(searchStatus != BTree::SEARCHSTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    if(!itUser.Read())
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    LbKey lbKey;
    LbPuidIndexBlob* pPuidIndexBlob;
    WORD cbPuidIndexBlob;
    itUser.Get(NULL,NULL,(void**)&pPuidIndexBlob, &cbPuidIndexBlob);

    if(cbPuidIndexBlob != sizeof(LbPuidIndexBlob))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "cbPuidIndexBlob != sizeof(LbPuidIndexBlob)");
        goto lDone;
    }

    if(pui64lastUpdateTime != NULL)
    {
        *pui64lastUpdateTime = pPuidIndexBlob->lastUpdateTime;
    }

    lbKey = pPuidIndexBlob->lbKey;
    itUser.Reset();

    // Search leaderboard
    searchStatus = _leaderboard.SearchLE(pUmsClient,&lbKey,sizeof(lbKey),
        false, &itLb);

    if(BTree::SEARCHSTATUS_NOT_FOUND == searchStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Did not find row in leaderboard when it should be there "
            "according to user index");
        goto lDone;
    }
    else if(searchStatus != BTree::SEARCHSTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    if(!itLb.Read())
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    if(_dwMaxEntryCount > 0 && itLb.GetRank() > _dwMaxEntryCount)
    {
        // This leaderboard has a rank cap (lightweight leaderboard) and this
        // entry does not qualify (it's in the reserve)
        status = StatReadStatusNotFound;
        goto lDone;
    }

    LbBlob* pStatBlob;
    WORD  cbStatBlob;
    itLb.Get(NULL,NULL,(void**)&pStatBlob, &cbStatBlob);
    dwRank = itLb.GetRank();

    // Parse stat blob
    if(cbStatBlob < sizeof(LbBlob) ||
       pStatBlob->puid != puid)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Data corruption detected!");

        goto lDone;
    }

    DWORD cStats = pStatBlob->wStatCount;

    if(!lbKey.IsNull())
        cStats += 1;

    LbStat* rgStats;

    if(cStats > 0)
    {
        rgStats = (LbStat*) pAlloc->Alloc(sizeof(LbStat) * cStats);

        if(NULL == rgStats)
            goto lDone;
    }
    else
    {
        rgStats = NULL;
    }

    DWORD cParsedStats;
    if(!LbBlob::ParseStats((BYTE*)pStatBlob, cbStatBlob,pAlloc,
        rgStats,&cParsedStats))
    {
        goto lDone;
    }

    DBGASSERT(cParsedStats == pStatBlob->wStatCount);

    itLb.Reset(); //the earliest time i can release the read lock

    if(!lbKey.IsNull())
    {
        rgStats[cStats-1].statId = LbStatIdRating;
        rgStats[cStats-1].bType  = LbspTypeIdInt64;
        rgStats[cStats-1].i64    = lbKey.i64Rating;

        *pdwRank = dwRank;
    }
    else
    {
        *pdwRank = 0;
    }

    *ppStats = rgStats;
    *pcStats = cStats;

    status = StatReadStatusSucceeded;

lDone:

    if(status != StatReadStatusSucceeded &&
       status != StatReadStatusNotFound)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}

CLb::GetRankForPuidStatus CLb::GetRankForPuid(
    IUmsClient* pUmsClient,
    UINT64 puid,
    DWORD* pdwRank
)
{
    GetRankForPuidStatus status = GetRankForPuidStatusOtherError;
    UMSSafeLockCookie puidLock(pUmsClient);
    BTree::SEARCHSTATUS searchStatus;
    BTree::Iterator itUser;
    BTree::Iterator itLb;
    DWORD dwRank = 0;
    LOCK_ID lid = {LOCK_TYPE_PUID, puid};

    // Get lock on puid
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_IS, &puidLock))
    {
        goto lDone;
    }

    // Search puid index
    LbPuidIndexKey userKey;
    userKey.ui64Puid = puid;
    searchStatus = _userIndex.SearchLE(pUmsClient, &userKey, sizeof(userKey),
        false, &itUser);

    if(BTree::SEARCHSTATUS_NOT_FOUND == searchStatus)
    {
        status = GetRankForPuidStatusPuidNotFound;
        goto lDone;
    }
    else if(searchStatus != BTree::SEARCHSTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    if(!itUser.Read())
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    LbKey lbKey;

    LbPuidIndexBlob* pPuidData;
    WORD cbPuidData;
    itUser.Get(NULL,NULL,(void**)&pPuidData, &cbPuidData);

    if(cbPuidData != sizeof(LbPuidIndexBlob))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "cbPuidData != sizeof(LbPuidIndexBlob)");
        goto lDone;
    }

    lbKey = pPuidData->lbKey;
    itUser.Reset();

    if(lbKey.IsNull())
    {
        // Rating is NULL. Entry is not ranked
        status = GetRankForPuidStatusPuidNotFound;
        goto lDone;
    }

    // Search leaderboard
    searchStatus = _leaderboard.SearchLE(pUmsClient,&lbKey,sizeof(lbKey),
        false, &itLb);

    if(BTree::SEARCHSTATUS_NOT_FOUND == searchStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Did not find row in leaderboard when it should be there "
            "according to user index");
        goto lDone;
    }
    else if(searchStatus != BTree::SEARCHSTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    *pdwRank = itLb.GetRank();

    status = GetRankForPuidStatusSucceeded;

lDone:

    if(status != GetRankForPuidStatusSucceeded &&
       status != GetRankForPuidStatusPuidNotFound)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return status;
}

// Dump (to trace callback) memory statistics for the btrees used by this
// leaderboard
bool CLb::DumpMemoryStats(
    IUmsClient* pUmsClient,
    ITraceCallback* pOut
)
{
    return _userIndex.DumpMemoryStats(pUmsClient,pOut) &&
           _leaderboard.DumpMemoryStats(pUmsClient,pOut);
}

bool CLb::DumpLbBinary(
    IUmsClient* pUmsClient,
    ITraceCallback* pOut
)
{
    return _userIndex.DumpTree(pUmsClient, pOut) &&
           _leaderboard.DumpTree(pUmsClient, pOut);
}

bool CLb::DumpLbSearchPath(
    IUmsClient* pUmsClient,
    ITraceCallback* pOut,
    void *pKey, WORD cbKey, bool bUserIndex
)
{
    if (bUserIndex)
    {
        return _userIndex.DumpTreePath(pUmsClient, pOut, (void *)pKey, cbKey);
    }
    else
    {
        return _leaderboard.DumpTreePath(pUmsClient, pOut, (void *)pKey, cbKey);
    }
}

bool CLb::ResetPuid(
    IUmsClient* pUmsClient,
    UINT64 puid
)
{
    bool fRet = false;
    UMSSafeLockCookie puidLock(pUmsClient);
    UMSSafeLockCookie lbLock(pUmsClient);
    BTree::DELETESTATUS deleteStatus;
    LbPuidIndexBlob puidIndexBlob;
    WORD cbPuidIndexBlob;
    LOCK_ID lidLb;
    LOCK_ID lidPuid;

    // Lock leaderboard
    GetLockId(&lidLb);
    if(!pUmsClient->AcquireLock(lidLb, LOCK_MODE_IS, &lbLock))
        goto lDone;

    // Get lock on puid
    lidPuid.type = LOCK_TYPE_PUID;
    lidPuid.id   = puid;
    if(!pUmsClient->AcquireLock(lidPuid, LOCK_MODE_X, &puidLock))
    {
        goto lDone;
    }

    // Search puid index
    LbPuidIndexKey userKey;
    userKey.ui64Puid = puid;
    cbPuidIndexBlob = sizeof(LbPuidIndexBlob);
    deleteStatus = _userIndex.Delete(pUmsClient, &userKey, sizeof(userKey),
        &puidIndexBlob, &cbPuidIndexBlob);

    if(BTree::DELETESTATUS_NOT_FOUND == deleteStatus)
    {
        fRet = true;
        goto lDone;
    }
    else if(deleteStatus != BTree::DELETESTATUS_SUCCEEDED)
    {
        goto lDone;
    }

    if(cbPuidIndexBlob != sizeof(LbPuidIndexBlob))
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "cbPuidIndexBlob != sizeof(LbPuidIndexBlob)");
        goto lDone;
    }

    // Search leaderboard
    deleteStatus = _leaderboard.Delete(pUmsClient,&puidIndexBlob.lbKey,
        sizeof(puidIndexBlob.lbKey));

    if(deleteStatus != BTree::DELETESTATUS_SUCCEEDED)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    // Adjust ranked entry count accordingly
    if(!puidIndexBlob.lbKey.IsNull())
        InterlockedDecrement(&_lRankedEntryCount);

    if(_fPersist)
    {
        if(!_pPersister->MarkLbRowForUpdate(pUmsClient, _dwTitleId, _dwLbId, puid))
        {
            goto lDone;
        }
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Decay will remove all rows that are older than the configured decay of the
// leaderboard. If leaderboard decay is set to zero, no rows will be removed.
bool CLb::DecayLb(
    IUmsClient* pUmsClient,
    UINT64 timeNow
)
{
    bool fRet = false;
    UMSSafeLockCookie lbLock(pUmsClient);
    TArray<UINT64, LbDecayChunkSize> puids;
    BTree::Iterator it;

    if(0 == _dwDecayDays)
    {
        // Leaderboard is not configured for decay
        fRet = true;
        goto lDone;
    }

    // Get exclusive access to leaderboard
    LOCK_ID lid;
    GetLockId(&lid);
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_X, &lbLock))
        goto lDone;

    // Calculate minimum qualifying last-update-time
    UINT64 minTime = timeNow - (
        ((UINT64)_dwDecayDays) * // days
        24ULL * // 24 hours
        60ULL * // 60 minutes
        60ULL * // 60 seconds
        10000000LL // 100 nano-seconds
    );

    // Delete rows in chunks of LbDecayChunkSize entries
    for(;;)
    {
        if(!_userIndex.SearchByRank(pUmsClient, 1, true, &it))
            goto lDone;

        puids.SetSize(0);
        for(;;)
        {
            if(!it.Read())
            {
                // End of the leaderboard was reached
                break;
            }

            LbPuidIndexKey* pKey;
            LbPuidIndexBlob* pData;
            it.Get((void**)&pKey, NULL,(void**)(&pData), NULL);

            if(pData->lastUpdateTime >= minTime)
            {
                // Row qualifies to stay
                continue;
            }

            puids.Add(pKey->ui64Puid);

            if(puids.GetSize() == LbDecayChunkSize)
            {
                // We reached the maximum size of the chunk. We'll delete what
                // we have and repeat
                break;
            }
        }

        it.Reset();

        if(puids.GetSize() == 0)
        {
            // We reached the end of the leaderboard and there are no more rows
            // to remove
            break;
        }

        // Remove rows
        for(int i=0; i < puids.GetSize(); i++)
        {
            if(!ResetPuid(pUmsClient, puids.Get(i)))
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                    "puid = 0x%08I64x", puids.Get(i));
                goto lDone;
            }
        }
    }

    fRet = true;

lDone:

    lbLock.Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Artificially age leaderboard rows by uiDays. In case you wonder, this is
// useful to test the Decay function
bool CLb::ChangeLastUpdateTimeOfAll(
    IUmsClient* pUmsClient,
    UINT uiDays
)
{
    bool fRet = false;
    UMSSafeLockCookie lbLock(pUmsClient);
    TArray<UINT64, LbDecayChunkSize> puids;
    BTree::Iterator it;

    // new last-update-time
    UINT64 newTime = ::GetUTCTimeAsUint64() - (
        ((UINT64)uiDays) * // days
        24ULL * // 24 hours
        60ULL * // 60 minutes
        60ULL * // 60 seconds
        10000000LL // 100 nano-seconds
    );

    // Get exclusive access to leaderboard
    LOCK_ID lid;
    GetLockId(&lid);
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_X, &lbLock))
        goto lDone;

    // Enumerate all rows, starting with the first row
    if(!_userIndex.SearchByRank(pUmsClient, 1, true, &it))
        goto lDone;

    while(it.Read())
    {
        // Update lastUpdateTime
        LbPuidIndexBlob* pData;
        it.Get(NULL, NULL, (void**)&pData, NULL);
        pData->lastUpdateTime = newTime;
    }

    fRet = true;

lDone:

    lbLock.Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Remove all rows from a leaderboard leaving it on a clean state
bool CLb::ResetLb(
    IUmsClient* pUmsClient
)
{
    bool fRet = false;
    UMSSafeLockCookie lbLock(pUmsClient);

    // Get exclusive access to leaderboard
    LOCK_ID lid;
    GetLockId(&lid);
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_X, &lbLock))
        goto lDone;

    // Reset user index
    if(!_userIndex.Reset(pUmsClient))
        goto lDone;

    // Reset leaderboard
    if(!_leaderboard.Reset(pUmsClient))
        goto lDone;

    // Reset leaderboard size
    _lRankedEntryCount = 0;

    // Reset leaderboard in database (UODB)
    if(_fPersist)
    {
        if(!_pPersister->ResetLb(pUmsClient,_dwTitleId,_dwLbId))
            goto lDone;
    }

    // Update last reset time. It will also update the leaderboard metadata in
    // the database (NPDB)
    if(!SetLastResetTime(::GetUTCTimeAsUint64()))
    {
        goto lDone;
    }

    lbLock.Release();
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Update leaderboard's last-reset timestamp. If leaderboard persist flag is
// set, the last-reset timestamp will also be updated in the database
bool CLb::SetLastResetTime(
    UINT64 lastReset
)
{
    bool fRet = false;

    _lastResetTime = lastReset;

    if(_fPersist)
    {
        if(!_pConfig->UpdateLbLastResetTime(_dwTitleId, _dwLbId, lastReset))
        {
            goto lDone;
        }
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Check if key qualifies to be inserted in the leaderboard with a rank cap (
// lightweight leaderboard)
bool CLb::CheckForRankCap(
    IUmsClient* pUmsClient,
    LbKey* pKey
)
{
    bool fRet = false;
    LbKey* pBottomKey = NULL;
    BTree::Iterator it;

    if((DWORD)_lRankedEntryCount < _dwMaxEntryCount)
    {
        // Leaderboard size hasn't even reached the cap size yet.
        fRet = true;
        goto lDone;
    }

    // Get the key of the last qualifying row of the leaderboard
    if(!_leaderboard.SearchByRank(pUmsClient, _dwMaxEntryCount, false, &it))
        goto lDone;

    if(!it.Read())
    {
        // Leaderboard probably shrunk while we were on this. Let's approve the
        // insert. It's too close to the cap anyways.
        fRet = true;
        goto lDone;
    }

    it.Get((void**)&pBottomKey, NULL, NULL, NULL);

    if(LbKey::DescendingKeyCompare(NULL, pKey, sizeof(LbKey), pBottomKey,
        sizeof(LbKey)) <= 0)
    {
        // Entry qualifies
        fRet = true;
    }

lDone:

    return fRet;
}

// Trim non-qualifying rows from a leaderboard with a rank cap
bool CLb::TrimLb(
    IUmsClient* pUmsClient
)
{
    bool fRet = false;
    UMSSafeLockCookie lbLock(pUmsClient);
    TArray<UINT64, LbDecayChunkSize> puids;
    BTree::Iterator it;

    if(0 == _dwMaxEntryCount                                        // Leaderboard is not lightweight (no rank cap)
       || _lRankedEntryCount <= (int)(_dwMaxEntryCount + LbReserveSize))   // or it does not neeed trimming
    {
        fRet = true;
        goto lDone;
    }

    // Get exclusive access to leaderboard
    LOCK_ID lid;
    GetLockId(&lid);
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_X, &lbLock))
        goto lDone;

    // Delete rows in chunks of LbDecayChunkSize entries
    for(;;)
    {
        if(!_leaderboard.SearchByRank(pUmsClient, _dwMaxEntryCount + LbReserveSize + 1, true, &it))
            goto lDone;

        puids.SetSize(0);
        for(;;)
        {
            if(!it.Read())
            {
                // End of the leaderboard was reached
                break;
            }

            if(it.GetRank() <= _dwMaxEntryCount + LbReserveSize)
                continue;

            LbBlob* pData;
            it.Get(NULL,NULL,(void**)&pData, NULL);

            puids.Add(pData->puid);

            if(puids.GetSize() == LbDecayChunkSize)
            {
                // We reached the maximum size of the chunk. We'll delete what
                // we have and repeat
                break;
            }
        }

        it.Reset();

        if(puids.GetSize() == 0)
        {
            // We reached the end of the leaderboard and there are no more rows
            // to remove
            break;
        }

        // Remove rows
        for(int i=0; i < puids.GetSize(); i++)
        {
            if(!ResetPuid(pUmsClient, puids.Get(i)))
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                    "puid = 0x%08I64x", puids.Get(i));
                goto lDone;
            }
        }
    }

    fRet = true;

lDone:

    lbLock.Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}


    bool CLb::ToggleInstancePerfCounters(bool fEnable, CPerfCounters* pPerfCounters)
    {
        // only do work if the new "enabled" state is different from the old one.
        // we consider a perf instance with a non-null data pointer to already be enabled.
        if(fEnable != (_perfInstancePerLB.pbDataStart != NULL))
        {
            if(fEnable == true) // turn 'em on
            {
                WCHAR wszName[MAX_INSTANCE_NAME];
                PVOID pvNameTrash = NULL; // CreateInstance insists on giving us back a pointer to the resulting name.  We won't use it.
                swprintf_s(wszName, MAX_INSTANCE_NAME, L"%#lx-%04lu", _dwTitleId, _dwLbId);
                _perfInstancePerLB.dwInstanceID = pPerfCounters->CreateInstance(wszName, &pvNameTrash, (PVOID*)(&(_perfInstancePerLB.pbDataStart)));
                if(_perfInstancePerLB.dwInstanceID == DWORD(-1) || _perfInstancePerLB.dwInstanceID == E_INVALIDARG)
                {
                    CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Failed to create a perf instance for title (%u).", _dwTitleId);
                    return false; // don't consider it enabled.
                }
            }
            else if(fEnable == false) // turn 'em off
            {
                BOOL fRet = pPerfCounters->DeleteInstance(_perfInstancePerLB.dwInstanceID);
                if(fRet == FALSE)
                {
                    CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Failed to delete a perf instance for title (%u).", _dwTitleId);
                    return false; // don't consider it disabled. 
                }
                // the memory pointed to by pbDataStart was freed during DeleteInstance
                // we now set it to null to indicate that this leaderboard no longer has an instance.
                _perfInstancePerLB.pbDataStart = NULL; 
            }
        }
        return true;
    }


    void CLb::InstancedPerfCounterIncrementValue32(CPerfCounters * pPerfCounters, DWORD dwCounterID, DWORD dwAmount)
    {
        if (NULL != pPerfCounters)
        {
            // update the fixed "_total" instance, which should always exist.
            pPerfCounters->IncrementValue32 (dwCounterID, dwAmount, _plblistParent->GetTotalPerfInstancePtr());

            // update the title instance, if it exists
            LbTitlePerfInfo titlePerfInfo;
            if(_plblistParent->GetTitleInstanceHashPtr()->Get(_dwTitleId, &titlePerfInfo) && titlePerfInfo.perfInstance.dwInstanceID != (DWORD)-1)
            {
                pPerfCounters->IncrementValue32 (dwCounterID, dwAmount, &titlePerfInfo.perfInstance);
            }

            //update the leaderboard instance, if it exists
            if(_perfInstancePerLB.pbDataStart != NULL)
            {
                pPerfCounters->IncrementValue32 (dwCounterID, dwAmount, &_perfInstancePerLB);
            }
        }
    }

   void CLb::InstancedPerfCounterIncrementValue64(CPerfCounters * pPerfCounters, DWORD dwCounterID, QWORD qwAmount)
    {
        if (NULL != pPerfCounters)
        {
            // update the fixed "_total" instance, which should always exist.
            pPerfCounters->IncrementValue64(dwCounterID, qwAmount, _plblistParent->GetTotalPerfInstancePtr());

            // update the title instance, if it exists
            LbTitlePerfInfo titlePerfInfo;
            if(_plblistParent->GetTitleInstanceHashPtr()->Get(_dwTitleId, &titlePerfInfo) && titlePerfInfo.perfInstance.dwInstanceID != (DWORD)-1)
            {
                pPerfCounters->IncrementValue64 (dwCounterID, qwAmount, &titlePerfInfo.perfInstance);
            }

            //update the leaderboard instance, if it exists
            if(_perfInstancePerLB.pbDataStart != NULL)
            {
                pPerfCounters->IncrementValue64(dwCounterID, qwAmount, &_perfInstancePerLB);
            }
        }
    }



/*****************************************************************************
  CLbList
*****************************************************************************/

bool CLbList::Init(
    CConfig* pConfig,
    CBufferManager* pBM,
    UMS* pUMS,
    CPersister* pPersister,
    CDb* pDb,
    CPerfCounters* pPerfCounters
)
{
    DBGASSERT(_pConfig == NULL);

    bool fRet = false;

    _pConfig    = pConfig;
    _pBM        = pBM;
    _pUMS       = pUMS;
    _pPersister = pPersister;
    _pDb        = pDb;
    _pPerfCounters = pPerfCounters;

    // Grow the leaderboard hash table
    _lbTable.SetLoadFactor(1.0);
    if(!_lbTable.Grow(LbInfoSizeLbInfoTable))
        goto lDone;

    // Grow the title hash table (used only for tracking per-title perf instances)
    _titlePerfTable.SetLoadFactor(1.0);
    if(!_titlePerfTable.Grow(LbInfoSizeTitlePerfTable))
        goto lDone;

    // in addition, create a default "_total" counter instance for this LBList
    PVOID pvNameTrash = NULL; // CreateInstance insists on giving us back a point to the resulting name.  We won't use it.
    _perfInstanceTotal.dwInstanceID = (DWORD)-1;
    if(_pPerfCounters != NULL)
    {
        _perfInstanceTotal.dwInstanceID = pPerfCounters->CreateInstance(L"_Total", &pvNameTrash, (PVOID*)(&_perfInstanceTotal.pbDataStart));
    }
    if(_perfInstanceTotal.dwInstanceID == DWORD(-1) || _perfInstanceTotal.dwInstanceID == E_INVALIDARG)
    {
        // write an event here, since this condition shouldn't stop the service from running
        // TODOTHEOM: new event code
        XomNtEvent(XEVENT_STATS_CODE_PERF_CREATE_FAILED, "Failed to create _Total perf counter instance for leaderboard service. ");
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

void CLbList::Term()
{
    Term(false);
}

void CLbList::Term(bool fApplicationShutDown)
{
    bool fRet = false;
    IUmsClient* pUmsClient = NULL;
    THashtable<LbTitleLbIdKey,CLb*,LbTitleLbIdKey>::Iterator it;
    TArray<LbTitleLbIdKey, 1> lbList;

    // Release leaderboards (or the resources associated with them)
    if(_lbTable.GetCount() > 0)
    {
        // First, store all leaderboard references in a array
        if(!lbList.Grow(_lbTable.GetCount()))
            goto lDone;

        _lbTable.InitializeIterator(&it);

        LbTitleLbIdKey key;
        while(it.GetNext(&key, NULL))
        {
            lbList.Add(key);
        }

        // To delete the leaderboards we need a UmsClient
        if(!_pUMS->CreateUmsClient(&pUmsClient))
            goto lDone;

        // Delete each leaderboard in the array
        for(int i=0; i < lbList.GetSize(); i++)
        {
            key = lbList.Get(i);

            DeleteLbStatus deleteStatus = DeleteLb(pUmsClient, key.dwTitleId,
                key.dwLbId, false, fApplicationShutDown);

            if(deleteStatus != DeleteLbStatusSucceeded)
            {
                DBGASSERT(false);
            }
        }
    }

    // clean up the _Total_ perf counter instance, just for cleanliness
    // the per-title and per-lb instances should have been cleaned up when the
    // leaderboards were deleted
    if(_pPerfCounters != NULL)
    {
        _pPerfCounters->DeleteInstance(_perfInstanceTotal.dwInstanceID);
    }
    
    _lbTable.Term();

    fRet = true;

lDone:

    // Clean up
    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        XomNtEvent(XEVENT_STATS_CODE_35, "%s", CGlobalError::GetCurrentMessage());
        DBGASSERT(false);
    }
}

// Simply get all data from the database and call Stat Write
// Note: There will be no checking whether this LB belongs to this server
// This is usually used during a LB Move
CLbList::CreateLbStatus CLbList::CreateAndLoadOneLB(
    IUmsClient * pUmsClient, 
    ConfigLbInfo * plbInfo)
{
    CreateLbStatus status = CreateLbStatusOtherError;
    DbTitleAndLb dbTitleLb;
    CLb* pLb = NULL;

    if (NULL == pUmsClient || NULL == plbInfo)
        goto lDone;
   
    CreateLbStatus createStatus = CreateLb(pUmsClient,
                plbInfo->dwTitleId, plbInfo->dwLbId,
                (LbResetType)plbInfo->lbReset, plbInfo->uiDecayDays,
                plbInfo->fTop100 ? LbTop100 : 0, plbInfo->lastReset, NULL);

    if(createStatus != CreateLbStatusSucceeded)
    {
        status = createStatus;
        goto lDone;
    }
    
    if(GetLb(plbInfo->dwTitleId, plbInfo->dwLbId, &pLb) != GetLbStatusSucceeded)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    pLb->SetPersist(false);
    pLb->Release();
    pLb = NULL;

    dbTitleLb.uiLbId = plbInfo->dwLbId;
    dbTitleLb.uiTitleId = plbInfo->dwTitleId;

    if(!_pDb->Load(&dbTitleLb, 1 , this))
        goto lDone;

    if(GetLb(plbInfo->dwTitleId, plbInfo->dwLbId, &pLb) != GetLbStatusSucceeded)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        goto lDone;
    }

    pLb->SetPersist(true);
    pLb->Release();
    pLb = NULL;

    status = CreateLbStatusSucceeded;

lDone:

    if(pLb != NULL)
        pLb->Release();

    if(CreateLbStatusSucceeded != status)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;

}

//this is only called during startup
bool CLbList::Load(
    bool fDelete
)
{
    bool fRet = false;
    IUmsClient* pUmsClient = NULL;
    CArenaMemAlloc alloc;
    TList<ConfigLbInfo> lbList;
    TList<ConfigLbInfo>::Iterator it;
    THashtable<LbTitleLbIdKey,CLb*,LbTitleLbIdKey> lbTable;
    THashtable<LbTitleLbIdKey,CLb*,LbTitleLbIdKey>::Iterator itTable;
    DbTitleAndLb* prgLb = NULL;
    CLb* pLb = NULL;

    // This operation needs a UmsClient
    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    // Get the list of leaderboards from config
    lbList.Reset();
    if(!_pConfig->LoadLbInfo(&alloc,&lbList))
        goto lDone;

    // Create hashtable with current leaderboards
    _lockLbTable.ReadLock();
    if(_lbTable.GetCount() > 0)
    {
        _lbTable.InitializeIterator(&itTable);

        if(!lbTable.Grow(_lbTable.GetCount()))
        {
            _lockLbTable.ReadUnlock();
            goto lDone;
        }

        LbTitleLbIdKey key;
        while(itTable.GetNext(&key, NULL))
        {
            if(!lbTable.Set(key, (CLb*)1))
            {
                _lockLbTable.ReadUnlock();
                goto lDone;
            }
        }
    }
    _lockLbTable.ReadUnlock();

    // Create leaderboards
    lbList.Begin(&it);

    ConfigLbInfo* pLbInfo;
    while((pLbInfo = it.Next()) != NULL)
    {
        LbTitleLbIdKey key = { pLbInfo->dwTitleId, pLbInfo->dwLbId };

        if(!lbTable.Get(key, NULL))
        {
            CreateLbStatus createStatus = CreateLb(pUmsClient,
                pLbInfo->dwTitleId, pLbInfo->dwLbId,
                (LbResetType)pLbInfo->lbReset, pLbInfo->uiDecayDays,
                pLbInfo->fTop100 ? LbTop100 : 0, pLbInfo->lastReset, NULL);

            if(createStatus != CreateLbStatusSucceeded)
                goto lDone;
        }
        else
        {
            if(!lbTable.Set(key, NULL))
                goto lDone;
        }
    }

    // Delete leaderboards
    if(fDelete)
    {
        lbTable.InitializeIterator(&itTable);

        LbTitleLbIdKey key;
        CLb* flag;
        while(itTable.GetNext(&key, &flag))
        {
            if(flag != NULL)
            {
                DeleteLbStatus deleteStatus = DeleteLb(pUmsClient, pLbInfo->dwTitleId,
                    pLbInfo->dwLbId, true);

                if(deleteStatus != DeleteLbStatusSucceeded)
                    goto lDone;
            }
        }
    }

    // Populate leaderboards with data from the database
    if(lbList.GetCount() > 0)
    {
        // Turn off persistance on these leaderboards otherwise each row we
        // load from the database would be marked to be written back to the
        // database
        lbList.Begin(&it);
        for(int i=0; i < lbList.GetCount(); i++)
        {
            ConfigLbInfo* pLbInfo = it.Next();

            CGlobalError::Reset();
            if(GetLb(pLbInfo->dwTitleId, pLbInfo->dwLbId, &pLb) != GetLbStatusSucceeded)
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

            pLb->SetPersist(false);
            pLb->Release();
            pLb = NULL;
        }

        // Build array with title and leaderboard ids
        prgLb = (DbTitleAndLb*) g_MemAlloc.Alloc(sizeof(DbTitleAndLb)
            * lbList.GetCount());

        if(NULL == prgLb)
            goto lDone;

        lbList.Begin(&it);
        for(int i=0; i < lbList.GetCount(); i++)
        {
            ConfigLbInfo* pLbInfo = it.Next();

            if(NULL == pLbInfo)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "ASSERT: list should have more items");
                DBGASSERT(false);
                goto lDone;
            }

            prgLb[i].uiTitleId = pLbInfo->dwTitleId;
            prgLb[i].uiLbId    = pLbInfo->dwLbId;
        }

        // Load leaderboards from database. The data will be be passed via
        // the callback method OnRow
        if(!_pDb->Load(prgLb, lbList.GetCount(), this))
            goto lDone;

        // Turn persistance back on - and set state to Read Write
        lbList.Begin(&it);
        for(int i=0; i < lbList.GetCount(); i++)
        {
            ConfigLbInfo* pLbInfo = it.Next();

            CGlobalError::Reset();
            if(GetLb(pLbInfo->dwTitleId, pLbInfo->dwLbId, &pLb) !=
                GetLbStatusSucceeded)
            {
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
                goto lDone;
            }

            pLb->SetPersist(true);

            pLb->SetLbStatus(CLb::ReadWrite);
            
            pLb->Release();
            pLb = NULL;
        }
    }

    fRet = true;

lDone:

    lbList.Reset();

    if(pLb != NULL)
        pLb->Release();

    if(prgLb != NULL)
        g_MemAlloc.Free(prgLb);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    return fRet;
}

CLbList::CreateLbStatus CLbList::CreateLb(
    IUmsClient* pUmsClient,
    DWORD dwTitleId,
    DWORD dwLbId,
    LbResetType resetType,
    UINT uiDecayDays,
    UINT uiMaxEntryCount,
    UINT64 lastResetTime,
    CLb** ppLb
)
{
    CreateLbStatus status = CreateLbStatusOtherError;
    DWORD dwSlot;
    CLb* pLb = NULL;

    _lockLbTable.WriteLock();

    LbTitleLbIdKey key = { dwTitleId, dwLbId };

    if(_lbTable.Get(key, NULL))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard already exists. TitleId=0x%08x, LbId=0x%08x",
            dwTitleId, dwLbId);

        status = CreateLbStatusLbExists;
        goto lDone;
    }

    // Create a new leaderboard object (CLb) and initialize it
    pLb = new CLb(dwTitleId, dwLbId, resetType, uiDecayDays, uiMaxEntryCount,
        lastResetTime, this);

    if(NULL == pLb)
        goto lDone;

    if(!pLb->Init(pUmsClient, _pBM, _pPersister, _pConfig))
        goto lDone;

    if (!pLb->SetLbStatus(CLb::ReadWrite))
        goto lDone;

    // Add leaderboard to table
    if(!_lbTable.Set(key, pLb))
        goto lDone;

    if(ppLb != NULL)
    {
        pLb->AddRef();
        *ppLb = pLb;
    }

    _lockTitlePerfTable.WriteLock();
    
    // if this is the first leaderboard for the title, we may need an entry in the title table
    // otherwise track the number of LBs for the title.
    LbTitlePerfInfo titlePerfInfo;
    if(!_titlePerfTable.Get(dwTitleId, &titlePerfInfo))
    {
        titlePerfInfo.perfInstance.dwInstanceID = (DWORD)-1;
        titlePerfInfo.perfInstance.pbDataStart = NULL;
        titlePerfInfo.dwLBCount = 1;
        _titlePerfTable.Set(dwTitleId, titlePerfInfo);
    }
    else
    {
        // this is not the first LB for the title.
        titlePerfInfo.dwLBCount++;
        _titlePerfTable.Set(dwTitleId, titlePerfInfo);
    }

    _lockTitlePerfTable.WriteUnlock();

    pLb = NULL;
    status = CreateLbStatusSucceeded;

lDone:

    _lockLbTable.WriteUnlock();

    if(pLb != NULL)
    {
        pLb->Term(pUmsClient);
        delete pLb;
    }

    if(status != CreateLbStatusSucceeded)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

CLbList::DeleteLbStatus CLbList::DeleteLb(
    IUmsClient* pUmsClient,
    DWORD dwTitleId,
    DWORD dwLbId,
    bool fPersist
)
{
    return DeleteLb(pUmsClient, dwTitleId, dwLbId, fPersist, false);
}

CLbList::DeleteLbStatus CLbList::DeleteLb(
    IUmsClient* pUmsClient,
    DWORD dwTitleId,
    DWORD dwLbId,
    bool fPersist,
    bool fApplicationTerminates
)
{
    DeleteLbStatus status = DeleteLbStatusOtherError;
    CLb* pLb = NULL;
    bool fLock = false;
    UMSSafeLockCookie lbLock(pUmsClient);

    // Remove leaderboard from directory
    _lockLbTable.WriteLock();
    fLock = true;

    LbTitleLbIdKey key;
    key.dwTitleId = dwTitleId;
    key.dwLbId    = dwLbId;

    if(!_lbTable.Remove(key, &pLb))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=0x%08x",
            dwTitleId, dwLbId);

        status = DeleteLbStatusNotFound;
        goto lDone;
    }

    _lockLbTable.WriteUnlock();
    fLock = false;

    // Drain references
    while(pLb->GetRefCount() > 0)
    {
        Sleep(1);
    }

    // at this point, nobody has a reference to this lb and nobody can get it anymore - does not exist in the lb table
    // Note: I don't really need to lock it but it won't hurt
    LOCK_ID lid;
    CLb::GetLockId(dwTitleId, dwLbId, &lid);
    if(!pUmsClient->AcquireLock(lid, LOCK_MODE_X, &lbLock))
        goto lDone;

    // Remove leaderboard from database
    if(fPersist)
    {
        if(!_pDb->ResetLb(dwTitleId, dwLbId))
        {
            goto lDone;
        }
    }

    _lockTitlePerfTable.WriteLock();

    // clean up the tracking of title perf instances for this LB.
    // if there are no more leaderboards for the title, remove the title from the title hash
    LbTitlePerfInfo titlePerfInfo;
    if(_pPerfCounters != NULL && _titlePerfTable.Get(dwTitleId, &titlePerfInfo))
    {
        if(--titlePerfInfo.dwLBCount <= 0)
        {
            _titlePerfTable.Remove(dwTitleId, &titlePerfInfo);
            // also delete the associated perf instance, but only if there is one
            if(titlePerfInfo.perfInstance.dwInstanceID != (DWORD)-1)
            {
                _pPerfCounters->DeleteInstance(titlePerfInfo.perfInstance.dwInstanceID);
            }
            // There's no good way to deal with an error here, since we can't hold up
            // the leaderboard delete.  Worst case, we end up with a stale perf counter instance.
        }
        else
        {
            _titlePerfTable.Set(dwTitleId, titlePerfInfo); // put the decremented dwLBCount back into the table.
        }
    }
    
    _lockTitlePerfTable.WriteUnlock();

    // get rid of any per-leaderboard perf instances, for this leaderboard
    if(_pPerfCounters)
    {
        pLb->ToggleInstancePerfCounters(false /*disable*/, _pPerfCounters);
    }
    
    // Release resources
    pLb->Term(pUmsClient, fApplicationTerminates);
    delete pLb;
    pLb = NULL;

    status = DeleteLbStatusSucceeded;

lDone:

    if(fLock)
        _lockLbTable.WriteUnlock();

    if(status != DeleteLbStatusSucceeded)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

bool CLbList::IsPersisterThreadSleeping()
{
    return _pPersister->IsPersisterThreadSleeping();
}

DWORD CLbList::GetSwapCount()
{   
    UINT32 dwSwapCount = 0;
    
    if (_pPersister != NULL)
    {
        if (_pPersister->GetSwapCount(&dwSwapCount))
        {
            return dwSwapCount;
        }
    }

    DBGASSERT(false);
    return 0;
}


CLbList::ResetLbStatus CLbList::ResetLb(
    IUmsClient* pUmsClient,
    DWORD dwTitleId,
    DWORD dwLbId
)
{
    ResetLbStatus status = ResetLbStatusOtherError;
    CLb* pLb    = NULL;

    // Get reference to leaderboard
    GetLbStatus getstatus = GetLb(dwTitleId,dwLbId,&pLb);
    if(GetLbStatusNotFound == getstatus)
    {
        status = ResetLbStatusNotFound;
        goto lDone;
    }

    // Reset leaderboard
    if(!pLb->ResetLb(pUmsClient))
        goto lDone;

    status = ResetLbStatusSucceeded;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(status != ResetLbStatusSucceeded)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\n dwTitleId = 0x%08x"
            "\n dwLbId = %u",
            dwTitleId,
            dwLbId );
    }

    return status;
}

bool CLbList::ReloadSettingForLb(   DWORD dwTitleId,
                                    DWORD dwLbId,
                                    IUmsClient* pUmsClient,
                                    ConfigLbInfo *pConfigLbInfo
                                )                 
{
    bool fRet = false;
    CLb* pLb  = NULL;
    ConfigLbInfo lbinfo;

    if(GetLb(dwTitleId, dwLbId, &pLb) != CLbList::GetLbStatusSucceeded)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
           "GetLb Failed For TitleId=0x%08x, LbId=0x%08x",
           dwTitleId, dwLbId);
           
        goto lDone;
    }

    if (NULL == pConfigLbInfo)
    {
        ZeroMemory(&lbinfo, sizeof(ConfigLbInfo));

        CConfig::GetLbInfoStatus getLbConfigStatus = _pConfig->GetLbInfo(dwTitleId, dwLbId, &lbinfo);

        if(CConfig::GetLbInfoStatusSucceeded != getLbConfigStatus)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
               "Could not Retrieve LbInfo From Config Database TitleId=0x%08x, LbId=0x%08x",
               dwTitleId, dwLbId);
                
            goto lDone;
        }
    }
    else
    {
        memcpy(&lbinfo, pConfigLbInfo, sizeof(ConfigLbInfo)); //use the one passed in
    }

    pLb->SetDecayDays(lbinfo.uiDecayDays);
    pLb->SetResetType((LbResetType)lbinfo.lbReset);
    pLb->SetMaxEntryCount(lbinfo.fTop100 ? LbTop100 : 0);

    fRet = true;
lDone:

    if(pLb != NULL)
        pLb->Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CLbList::ReloadSettingForTitle(  DWORD dwTitleId,
                                      IUmsClient* pUmsClient,
                                      UINT32 *pLbCountProcessed
                                   )                 
{
    bool fRet = false;
    CArenaMemAlloc alloc;
    TList<ConfigLbInfo> lbList;
    TList<ConfigLbInfo>::Iterator it;
    
    // Get the list of leaderboards for the title
    lbList.Reset();
    if(!_pConfig->LoadLbInfoForOneTitle(&alloc,&lbList, dwTitleId, pLbCountProcessed))
        goto lDone;

    lbList.Begin(&it);
    ConfigLbInfo* pLbInfo;
    while((pLbInfo = it.Next()) != NULL)
    {
        if (!ReloadSettingForLb(pLbInfo->dwTitleId, pLbInfo->dwLbId, pUmsClient, pLbInfo))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
               "Could not ReloadSettingForLb for TitleId=0x%08x, LbId=0x%08x",
               pLbInfo->dwTitleId, pLbInfo->dwLbId);

            goto lDone;
        }
        
        if (NULL != pLbCountProcessed)
        {
            *pLbCountProcessed = *pLbCountProcessed + 1;
        }
    }

    fRet = true;
lDone:

    lbList.Reset();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}



CLbList::GetLbStatus CLbList::GetLb(
    DWORD dwTitleId,
    DWORD dwLbId,
    CLb** ppLb
)
{
    GetLbStatus status = GetLbStatusOtherError;
    LbTitleLbIdKey key = { dwTitleId, dwLbId };
    bool fLock = false;

    _lockLbTable.ReadLock();
    fLock = true;

    if(!_lbTable.Get(key, ppLb))
    {
        status = GetLbStatusNotFound;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=0x%08x",
            dwTitleId, dwLbId);
        goto lDone;
    }

    (*ppLb)->AddRef();

    status = GetLbStatusSucceeded;

lDone:

    if(fLock)
        _lockLbTable.ReadUnlock();

    if(status != GetLbStatusSucceeded)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return status;
}

// Get list with all leaderboards
bool CLbList::GetLbList(
    IMemAlloc* pAlloc,
    LbTitleLbIdKey** prgLbList,
    DWORD* pdwLbCount
)
{
    bool fRet = false;
    LbTitleLbIdKey* rgLbList = NULL;
    THashtable<LbTitleLbIdKey,CLb*,LbTitleLbIdKey>::Iterator it;

    _lockLbTable.ReadLock();

    DWORD dwLbCount = _lbTable.GetCount();

    if(dwLbCount > 0)
    {
        rgLbList = (LbTitleLbIdKey*) pAlloc->Alloc(sizeof(LbTitleLbIdKey) * dwLbCount);

        if(NULL == rgLbList)
            goto lDone;

        _lbTable.InitializeIterator(&it);

        DWORD dwNdx=0;
        while(it.GetNext(&rgLbList[dwNdx], NULL))
        {
            DBGASSERT(dwNdx < dwLbCount);
            dwNdx++;
        }

        *prgLbList  = rgLbList;
        *pdwLbCount = dwLbCount;
        rgLbList    = NULL;
    }
    else
    {
        *prgLbList  = NULL;
        *pdwLbCount = 0;
    }

    fRet = true;

lDone:

    _lockLbTable.ReadUnlock();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Reset leaderboards according to their reset type (weekly, monthly, etc...)
bool CLbList::AutoReset(
    IUmsClient* pUmsClient,
    UINT64 uiTimeNow
)
{
    bool fRet = false;
    LbTitleLbIdKey* prglbs = NULL;
    DWORD clbs;
    CLb* pLb = NULL;

    // Convert time to systemtime for the math that follows
    SYSTEMTIME st;
    ::FileTimeToSystemTime(reinterpret_cast<FILETIME*>(&uiTimeNow), &st);

    // Get the list of leaderboards
    if(!GetLbList(&g_MemAlloc, &prglbs, &clbs))
        goto lDone;

    for(DWORD i=0; i < clbs; i++)
    {
        if(GetLb(prglbs[i].dwTitleId, prglbs[i].dwLbId, &pLb)
            != GetLbStatusSucceeded)
        {
            goto lDone;
        }

        bool fReset = false;
        switch(pLb->GetResetType())
        {
        case LbResetTypeNever:
            // This leaderboard never resets
            break;

        case LbResetTypeWeekly:
            // Reset if it's Sunday
            if(st.wDayOfWeek == 0)
                fReset = true;
            break;

        case LbResetTypeMonthly:
            // Reset if it's the first of the month
            if(st.wDay == 1)
                fReset = true;
            break;

        case LbResetTypeBimonthly:
            // Reset if it's the first of the January, March, May, July,
            // September or November
            if(st.wDay == 1 && (
                st.wMonth == 1 ||
                st.wMonth == 3 ||
                st.wMonth == 5 ||
                st.wMonth == 7 ||
                st.wMonth == 9 ||
                st.wMonth == 11 ))
            {
                fReset = true;
            }
            break;

        case LbResetTypeQuarterly:
            // Reset if it's the first of January, April, July or October
            if(st.wDay == 1 && (
                st.wMonth == 1 ||
                st.wMonth == 4 ||
                st.wMonth == 7 ||
                st.wMonth == 10))
            {
                fReset = true;
            }
            break;

        case LbResetTypeSemiannually:
            // Reset if it's the first of January or July
            if(st.wDay == 1 && (
                st.wMonth == 1 ||
                st.wMonth == 7))
            {
                fReset = true;
            }
            break;

        case LbResetTypeAnnually:
            // Reset if it's the first of January
            if(st.wDay == 1 && st.wMonth == 1)
            {
                fReset = true;
            }

            break;
        default:
            XomNtEvent(XEVENT_STATS_CODE_36,
                "Invalid leaderboard reset type. "
                "TitleId=0x%08x LbId=%u Reset=%u",
                pLb->GetTitleId(), pLb->GetLbId(), (DWORD)pLb->GetResetType());
            break;
        }

        if(!fReset)
        {
            pLb->Release();
            pLb = NULL;
            continue;
        }

        // Reset leaderboard
        if(!pLb->ResetLb(pUmsClient))
            goto lDone;

        pLb->Release();
        pLb = NULL;
    }

    fRet = true;

lDone:

    if(prglbs != NULL)
        g_MemAlloc.Free(prglbs);

    if(pLb != NULL)
        pLb->Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CLbList::AutoDecay(
    IUmsClient* pUmsClient,
    UINT64 uiTimeNow
)
{
    bool fRet = false;
    LbTitleLbIdKey* prglbs = NULL;
    DWORD clbs;
    CLb* pLb = NULL;

    // Convert time to systemtime for the math that follows
    SYSTEMTIME st;
    ::FileTimeToSystemTime(reinterpret_cast<FILETIME*>(&uiTimeNow), &st);

    // Get the list of leaderboards
    if(!GetLbList(&g_MemAlloc, &prglbs, &clbs))
        goto lDone;

    for(DWORD i=0; i < clbs; i++)
    {
        if(GetLb(prglbs[i].dwTitleId, prglbs[i].dwLbId, &pLb)
            != GetLbStatusSucceeded)
        {
            goto lDone;
        }

        if(pLb->GetDecayDays() != 0)
        {
            if(!pLb->DecayLb(pUmsClient, uiTimeNow))
                goto lDone;
        }

        pLb->Release();
        pLb = NULL;
    }

    fRet = true;

lDone:

    if(prglbs != NULL)
        g_MemAlloc.Free(prglbs);

    if(pLb != NULL)
        pLb->Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Trim all leaderboards that have a rank cap
bool CLbList::AutoTrim(
    IUmsClient* pUmsClient
)
{
    bool fRet = false;
    LbTitleLbIdKey* prglbs = NULL;
    DWORD clbs;
    CLb* pLb = NULL;

    // Get the list of leaderboards
    if(!GetLbList(&g_MemAlloc, &prglbs, &clbs))
        goto lDone;

    for(DWORD i=0; i < clbs; i++)
    {
        if(GetLb(prglbs[i].dwTitleId, prglbs[i].dwLbId, &pLb)
            != GetLbStatusSucceeded)
        {
            goto lDone;
        }

        if(pLb->GetMaxEntryCount() != 0)
        {
            if(!pLb->TrimLb(pUmsClient))
                goto lDone;
        }

        pLb->Release();
        pLb = NULL;
    }

    fRet = true;

lDone:

    if(prglbs != NULL)
        g_MemAlloc.Free(prglbs);

    if(pLb != NULL)
        pLb->Release();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Db callback. It's called for each row received during a call to CDb::LoadLb
// or CDb::LoadAll
bool CLbList::OnRow(
    IUmsClient* pUmsClient,
    UINT32 uiTitleId,
    UINT32 uiLbId,
    UINT64 ui64Puid,
    LbStat rgStats[],
    DWORD  cStats,
    UINT64 lastModified
)
{
    bool fRet     = false;
    bool fWarning = false;
    CLb* pLb  = NULL;

    if(uiTitleId == 0 ||
       ui64Puid  == 0)
    {
        fWarning = true;
        fRet     = true;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard row contains invalid data");
        goto lDone;
    }

    // Get leaderboard
    GetLbStatus getstatus = GetLb(uiTitleId, uiLbId, &pLb);

    if(GetLbStatusNotFound == getstatus)
    {
        fWarning = true;
        fRet     = true;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Ignoring row. Leaderboard does not exist.");
        goto lDone;
    }
    else if(getstatus != GetLbStatusSucceeded)
    {
        goto lDone;
    }

    // Write stats
    if(!pLb->StatWriteEx(pUmsClient, ui64Puid, rgStats, cStats, lastModified))
        goto lDone;

    fRet = true;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(!fRet || fWarning)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\n uiTitleId = 0x%08x"
            "\n uiLbId = %u"
            "\n ui64Puid = 0x%016I64x",
            uiTitleId,
            uiLbId,
            ui64Puid);

        XomNtEvent(XEVENT_STATS_CONFIG_24, "%s",
            CGlobalError::GetCurrentMessage());
    }

    return fRet;
}

// Dump (to trace callback) the list of leaderboards
bool CLbList::DumpLbList(
    ITraceCallback* pOut,
    UINT32 uiTitleId
)
{
    bool fRet = false;
    LbTitleLbIdKey* prglbs = NULL;
    DWORD clbs;
    CLb* pLb = NULL;

    // Get the list of leaderboards
    if(!GetLbList(&g_MemAlloc, &prglbs, &clbs))
        goto lDone;

    TraceCallbackFormattedWrite(pOut, "%10s%10s%10s%10s%10s%10s%10s\n",
                                "Title-Id",
                                "Lb-Id",
                                "Reset",
                                "Decay",
                                "Cap",
                                "Count",
                                "PCtr(ttl/lb)");

    for(DWORD i=0; i < clbs; i++)
    {
        // If uiTitleId was specified (anything but zero) then filter leaderboards
        // from other title-Ids
        if(uiTitleId != 0 && prglbs[i].dwTitleId != uiTitleId)
            continue;

        if(GetLb(prglbs[i].dwTitleId, prglbs[i].dwLbId, &pLb)
            != GetLbStatusSucceeded)
        {
            goto lDone;
        }

        _lockTitlePerfTable.ReadLock();

        LbTitlePerfInfo titlePerfInfo;
        bool fTitlePerfEnabled = false;
        if(_titlePerfTable.Get(pLb->GetTitleId(), &titlePerfInfo))
        {
            if(titlePerfInfo.perfInstance.dwInstanceID != (DWORD)-1)
            {
                fTitlePerfEnabled = true;
            }
        }

        _lockTitlePerfTable.ReadUnlock();

        TraceCallbackFormattedWrite(pOut, "0x%08x%10u%10u%10u%10u%10u%8u/%u\n",
                                    pLb->GetTitleId(),
                                    pLb->GetLbId(),
                                    (unsigned int) pLb->GetResetType(),
                                    pLb->GetDecayDays(),
                                    pLb->GetMaxEntryCount(),
                                    pLb->GetRankedEntryCount(),
                                    fTitlePerfEnabled,
                                    pLb->GetPerLBPerfCountersEnabled());

        pLb->Release();
        pLb = NULL;
    }

    fRet = true;

lDone:

    if(pLb != NULL)
        pLb->Release();

    if(prglbs != NULL)
        g_MemAlloc.Free(prglbs);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}


bool CLbList::ToggleInstancePerfCountersForLBs(
                                    UINT uiTitleId,
                                    bool fEnable)
{
    bool fRet = false;
    LbTitleLbIdKey* prglbs = NULL;
    DWORD clbs;
    CLb* pLb = NULL;
    DWORD cLBsFound = 0;

    if(_pPerfCounters == NULL)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Can't toggle perf counters if there are none for the LBList.");
        goto lDone;
    }

    // Get the list of leaderboards
    if(!GetLbList(&g_MemAlloc, &prglbs, &clbs))
        goto lDone;

    for(DWORD i=0; i < clbs; i++)
    {
        // If uiTitleId was specified (anything but zero) then filter leaderboards
        // from other title-Ids
        if(uiTitleId != 0 && prglbs[i].dwTitleId != uiTitleId)
            continue;

        cLBsFound++; // keep track of how many leaderboards we've found, for now purely to make sure we found some.

        if(GetLb(prglbs[i].dwTitleId, prglbs[i].dwLbId, &pLb)
            != GetLbStatusSucceeded)
        {
            goto lDone;
        }

        fRet = pLb->ToggleInstancePerfCounters(fEnable, _pPerfCounters);
        pLb->Release();
        pLb = NULL;
        // if one of the instances failed to toggle, something's very wrong.  Bail.
        if(fRet == FALSE)
        {
            goto lDone;
        }
    }

    if(cLBsFound < 1)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "No leaderboards found for title.  Maybe you have a bad title id?");
        fRet = false;
        goto lDone;
    }

    fRet = true;

lDone:

    if(pLb != NULL)
        pLb->Release();

    if(prglbs != NULL)
        g_MemAlloc.Free(prglbs);

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// This method either toggles the instance perf counter for 1 title, or for all titles, given a titleid
bool CLbList::ToggleInstancePerfCountersForTitles(
                                    UINT uiTitleId,
                                    bool fEnable)
{
    bool fRet = false;
    LbTitlePerfInfo titlePerfInfo;

    if(_pPerfCounters == NULL)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Can't toggle perf counters if there are none for the LBList.");
        goto lDone;
    }
        
    _lockTitlePerfTable.WriteLock();

    if(uiTitleId == 0) // caller wants all titles to be toggled
    {
        // grab an iterator over the title hash, and toggle each
        THashtable<UINT,LbTitlePerfInfo>::Iterator it;
        UINT uiCurrentTitleId = 0;

        DWORD dwTitleCount = _titlePerfTable.GetCount();

        _titlePerfTable.InitializeIterator(&it);
        while(it.GetNext(&uiCurrentTitleId, &titlePerfInfo))
        {
            fRet = ToggleInstancePerfCountersForTitle(uiCurrentTitleId, &titlePerfInfo, fEnable);
            if(fRet == false) goto lDone;
        }
    }
    else // caller just wants this one title toggled
    {
        fRet = _titlePerfTable.Get(uiTitleId, &titlePerfInfo);
        if(fRet == false) 
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "Title %#x was not found.  Either you have specified a non-propped title, or this is a code bug.", uiTitleId);
            goto lDone;
        }
        fRet = ToggleInstancePerfCountersForTitle(uiTitleId, &titlePerfInfo, fEnable);
        if(fRet == false) goto lDone;
    }

        fRet = true;

lDone:

    _lockTitlePerfTable.WriteUnlock();

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// toggles the instance counter for a specific title, using the LbTitlePerfInfo instance for the title
bool CLbList::ToggleInstancePerfCountersForTitle(
                                    UINT uiTitleId,
                                    LbTitlePerfInfo * pTitlePerfInfo,
                                    bool fEnable)
{
    bool fRet = false;
    if(pTitlePerfInfo == NULL)
    {
        goto lDone;
    }

    // check whether the title already has a perf instance.  If not, create one.
    if(pTitlePerfInfo->perfInstance.dwInstanceID != (DWORD)-1)  // the instance exists
    {
        if(!fEnable) // we need to get rid of it
        {
            BOOL fDeleted = _pPerfCounters->DeleteInstance(pTitlePerfInfo->perfInstance.dwInstanceID);
            if(fDeleted == FALSE)
            {
                fRet = false;
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Failed to delete a perf instance for title (%u).", uiTitleId);
                goto lDone;
            }
            // also need to remove the reference from the title perf instance tracking hash table
            pTitlePerfInfo->perfInstance.dwInstanceID = (DWORD)-1;
            pTitlePerfInfo->perfInstance.pbDataStart = NULL;
            _titlePerfTable.Set(uiTitleId, *pTitlePerfInfo); // set it back into the hash
        }
    }
    else // no perf counter instance for the title, yet
    {
        if(fEnable) // we need to create an instance for the title
        {
            // there's no entry in the hash for this title.  Must need an instance...
            WCHAR wszName[MAX_INSTANCE_NAME];
            PVOID pvNameTrash = NULL; // CreateInstance insists on giving us back a pointer to the resulting name.  We won't use it.
            swprintf_s(wszName, MAX_INSTANCE_NAME, L"%#lx_Total", uiTitleId);
            pTitlePerfInfo->perfInstance.dwInstanceID = _pPerfCounters->CreateInstance(wszName, &pvNameTrash, (PVOID*)(&(pTitlePerfInfo->perfInstance.pbDataStart)));
            if(pTitlePerfInfo->perfInstance.dwInstanceID == DWORD(-1) || pTitlePerfInfo->perfInstance.dwInstanceID == E_INVALIDARG)
            {
                fRet = false;
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER " Failed to create a perf instance for title (%u).", uiTitleId);
                goto lDone;
            }
            _titlePerfTable.Set(uiTitleId, *pTitlePerfInfo); // set it back into the hash
        }
    }
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

PERFINSTANCE * CLbList::GetTotalPerfInstancePtr()
{
    return &_perfInstanceTotal;
}

THashtable<UINT,LbTitlePerfInfo> * CLbList::GetTitleInstanceHashPtr()
{
    return &_titlePerfTable;
}


/******************************************************************************
* CPersister
******************************************************************************/

// Constructor
CPersister::CPersister()
{
    _pConfig        = NULL;
    _pUMS           = NULL;
    _pCtrl          = NULL;
    _pDb            = NULL;
    _pLbList        = NULL;
    _pCurrentList   = NULL;
    _pSpareList     = NULL;
    _hThread        = NULL;
    _hWakeUp        = NULL;
    _fShutdown      = FALSE;
    _fSleep         = FALSE;
    _fIsSleeping    = FALSE;
    _phDoneDatabaseWriteWork = NULL;
    _phDoDatabaseWriteWork   = NULL;
}

// Destructor
CPersister::~CPersister()
{
    DBGASSERT(NULL == _pCtrl);
    DBGASSERT(NULL == _pCurrentList);
    DBGASSERT(NULL == _pSpareList);
    DBGASSERT(NULL == _hThread);
    DBGASSERT(NULL == _hWakeUp);
    DBGASSERT(NULL == _phDoneDatabaseWriteWork);
    DBGASSERT(NULL == _phDoDatabaseWriteWork);
}

// Initialize resources and background thread. This method must be called
// before the object can be used.
bool CPersister::Init(
    CConfig* pConfig,
    UMS* pUMS,
    CDb* pDb,
    CLbList* pLbList,
    CBufferManager* pBM,
    CPerfCounters* pPerfCounters
)
{
    bool fRet = false;

    DBGASSERT(_pConfig == NULL && "Already initialized");

    _pConfig = pConfig;
    _pUMS    = pUMS;
    _pDb     = pDb;
    _pLbList = pLbList;
    _pPerfCounters = pPerfCounters;

    // Create UMS client object or task control object. It's needed in
    // order to deal with the b-tree objects
    if(!_pUMS->CreateUmsClient(&_pCtrl))
        goto lDone;

    // Create wake up event. Initial state is 'not set' so that the thread
    // starts doesn't wake up right off the bat.
    _hWakeUp = ::CreateEventW(NULL, TRUE /*bManualReset*/,
        FALSE /*bInitialState*/, NULL);

    if(NULL == _hWakeUp)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateEventW failed. Error=%u", GetLastError());
        goto lDone;
    }

    // Create Current and Spare change lists
    _pCurrentList = new CChangeList(pPerfCounters);
    if(NULL == _pCurrentList)
        goto lDone;

    if(!((CChangeList*)_pCurrentList)->Init(_pCtrl,pBM,ChangeListKey::KeyCompare,
            sizeof(ChangeListKey)))
    {
        goto lDone;
    }

    _pSpareList = new CChangeList(pPerfCounters);
    if(NULL == _pSpareList)
        goto lDone;

    if(!((CChangeList*)_pSpareList)->Init(_pCtrl,pBM,ChangeListKey::KeyCompare,
            sizeof(ChangeListKey)))
    {
        goto lDone;
    }

    _nDatabaseThreadCount = _pConfig->GetDataBaseWriteThreads();
    DBGASSERT(_nDatabaseThreadCount>0);

    // Initialize thread state and control variables. We want the thread to
    // go to sleep as soon as it starts.
    ::ResetEvent(_hWakeUp);
    ::InterlockedExchange(&_fShutdown,   FALSE);
    ::InterlockedExchange(&_fSleep,      TRUE);
    ::InterlockedExchange(&_fIsSleeping, FALSE);
    ::InterlockedExchange(&_lSwapCount, 0);
    ::InterlockedExchange(&_nThreadIndex, 0);

    _phDoneDatabaseWriteWork = new HANDLE[_nDatabaseThreadCount];
    if (NULL == _phDoneDatabaseWriteWork)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: allocating _phDoneDatabaseWriteWork Handle structure fails");
        goto lDone;
    }

    _phDoDatabaseWriteWork = new HANDLE[_nDatabaseThreadCount];
    if (NULL == _phDoDatabaseWriteWork)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: allocating _phDoDatabaseWriteWork Handle structure fails");
        goto lDone;
    }

    for (DWORD dwThreadIndex=0;dwThreadIndex<_nDatabaseThreadCount;dwThreadIndex++)
    {
         _phDoneDatabaseWriteWork[dwThreadIndex] = ::CreateEventW(NULL, TRUE /*bManualReset*/,
                                                                  FALSE /*bInitialState*/, NULL);                                   

        if(NULL == _phDoneDatabaseWriteWork[dwThreadIndex])
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "CreateEventW failed _phDoneDatabaseWriteWork. Error=%u", GetLastError());
            goto lDone;
        }

        _phDoDatabaseWriteWork[dwThreadIndex] = ::CreateEventW(NULL, TRUE /*bManualReset*/,
                                                                  FALSE /*bInitialState*/, NULL);  

        if(NULL == _phDoDatabaseWriteWork[dwThreadIndex])
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "CreateEventW failed _phDoDatabaseWriteWork. Error=%u", GetLastError());
            goto lDone;
        }
    }

    // Create thread
    DWORD dwThreadId;
    _hThread = ::CreateThread(NULL, 0, StaticThreadProc, this, 0,
        &dwThreadId);

    if(NULL == _hThread)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateThread failed. Error=%u", GetLastError());
        goto lDone;
    }

    fRet = true;

lDone:

    if(!fRet)
    {
        Term();
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return fRet;
}

// Drain background thread and then terminate and release all resources
void CPersister::Term()
{
    if(_hThread != NULL)
    {
        // Drain background thread first. Make sure all data is updated before
        // shutting down.
        while(((CChangeList*)_pCurrentList)->WasModified() ||
              ((CChangeList*)_pSpareList)  ->WasModified())
        {
            ::Sleep(100);
        }

        // Signal thread to shutdown
        ::InterlockedExchange(&_fShutdown, TRUE);

        // Wait until thread terminates
        do
        {
            ::SetEvent(_hWakeUp);
        }while(::WaitForSingleObject(_hThread, 1000) == WAIT_TIMEOUT);

        ::CloseHandle(_hThread);
        _hThread = NULL;
    }

    if(_hWakeUp != NULL)
    {
        ::CloseHandle(_hWakeUp);
        _hWakeUp = NULL;
    }

    if (NULL != _phDoneDatabaseWriteWork)
    {
        for (DWORD i=0;i<_nDatabaseThreadCount;i++)
        {
            if (NULL != _phDoneDatabaseWriteWork[i])
            {
                ::CloseHandle(_phDoneDatabaseWriteWork[i]);
                _phDoneDatabaseWriteWork[i] = NULL;
            }
        }

        delete [] _phDoneDatabaseWriteWork;
        _phDoneDatabaseWriteWork = NULL;
    }

    if (NULL != _phDoDatabaseWriteWork)
    {
        for (DWORD i=0;i<_nDatabaseThreadCount;i++)
        {
            if (NULL != _phDoDatabaseWriteWork[i])
            {
                ::CloseHandle(_phDoDatabaseWriteWork[i]);
                _phDoDatabaseWriteWork[i] = NULL;
            }
        }

        delete [] _phDoDatabaseWriteWork;
        _phDoDatabaseWriteWork = NULL;
    }

    if(_pCurrentList != NULL)
    {
        ((CChangeList*)_pCurrentList)->Term(_pCtrl);
        delete _pCurrentList;
        _pCurrentList = NULL;
    }

    if(_pSpareList != NULL)
    {
        ((CChangeList*)_pSpareList)->Term(_pCtrl);
        delete _pSpareList;
        _pSpareList = NULL;
    }

    if(_pCtrl != NULL)
    {
        _pUMS->ReleaseUmsClient(_pCtrl);
        _pCtrl = NULL;
    }
}

bool CPersister::MarkLbRowForUpdate(
    IUmsClient* pUmsClient,
    UINT32 uiTitleId,
    UINT32 uiLbId,
    UINT64 ui64Puid
)
{
    bool fRet = false;
    CChangeList* pList = NULL;

    // Get the current list
    _lockCurrentList.Lock();

    pList = (CChangeList*) _pCurrentList;
    pList->AddRef();

    _lockCurrentList.Unlock();

    // Insert reference
    ChangeListKey key   = { uiTitleId, uiLbId, ui64Puid  };
    ChangeListData data = { ChangeListOperationTypeUpdate };

    BTree::INSERTSTATUS insertres = pList->InsertIntoChangeList(pUmsClient, &key, sizeof(key),
        &data, sizeof(data));

    // Check returned status of the operation. If it failed because the key
    // was already there, it's OK. As long as it's there, we don't care.
    if(BTree::INSERTSTATUS_SUCCEEDED != insertres
       && BTree::INSERTSTATUS_PRIMARY_KEY_VIOLATION != insertres)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "pList->Insert returned %u", (DWORD) insertres);
        goto lDone;
    }

    pList->SetModifiedFlag();
    pList->Release();
    pList = NULL;

    // Make sure the processing thread is up and running
    if(_fIsSleeping)
        ::SetEvent(_hWakeUp);

    fRet = true;

lDone:

    if(pList != NULL)
    {
        pList->Release();
        pList = NULL;
    }

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\n uiTitleId = 0x%08x"
            "\n uiLbId = %u"
            "\n ui64Puid = 0x%08I64x",
            uiTitleId,
            uiLbId,
            ui64Puid);
    }

    return fRet;
}

// 1. Get Swap Count = n
// 2. At a later time, Get Swap Count = m
// 3. If m > n  && m  - n >=2, then it is safe to delete
//    or if m<n && (UInt.Max - n) + m > = 2 , then it is safe to delete 
bool CPersister::GetSwapCount(UINT32 * puSwapCount)
{
    bool  fRet = false;

    if (NULL == puSwapCount)
        goto lDone;

    *puSwapCount = _lSwapCount;

    fRet = true;

lDone:

    return fRet;
}


// Remove all rows of a given leaderboard from the database
bool CPersister::ResetLb(
    IUmsClient* pUmsClient,
    UINT32 uiTitleId,
    UINT32 uiLbId
)
{
    bool fRet = false;
    CChangeList* pList = NULL;
    TArray<ChangeListKey, PersisterResetChunkSize> refs;
    BTree::Iterator it;

    // Get the current list
    _lockCurrentList.Lock();
    bool fLock = true;

    pList = (CChangeList*) _pCurrentList;
    pList->AddRef();

    // Remove all the references to the given leaderboard.
    for(;;)
    {
        // Position the iterator on the first reference to the given
        // leaderboard
        ChangeListKey key = { uiTitleId, uiLbId, 0 };
        BTree::SEARCHSTATUS searchstatus = pList->SearchLE(pUmsClient, &key,
            sizeof(key), true, &it);

        if(searchstatus != BTree::SEARCHSTATUS_SUCCEEDED &&
           searchstatus != BTree::SEARCHSTATUS_NOT_FOUND)
        {
            goto lDone;
        }

        // Build list of references to delete. Since this number can be pretty
        // big, we'll delete it in chunks of 'PersisterResetChunkSize'
        refs.SetSize(0);
        for(int i=0; i < PersisterResetChunkSize; i++)
        {
            ChangeListKey* pKey;

            if(!it.Read())
            {
                // Reached end of the list
                break;
            }

            it.Get((void**)&pKey, NULL, NULL, NULL);

            if(pKey->uiTitleId != uiTitleId ||
               pKey->uiLbId    != uiLbId)
            {
                // No more references to the given leaderboard
                break;
            }

            // Add entry to array
            if(!refs.Add(*pKey))
                goto lDone;
        }

        it.Reset();

        if(refs.GetSize() == 0)
        {
            // That's it. All references (if any) have been deleted
            break;
        }

        // Delete references
        for(int i=0; i < refs.GetSize(); i++)
        {
            CGlobalError::Reset();
            BTree::DELETESTATUS deletestatus = pList->DeleteFromChangeList(pUmsClient,
                &refs.Get(i), sizeof(ChangeListKey), NULL, NULL);

            if(deletestatus != BTree::DELETESTATUS_SUCCEEDED)
            {
                // This should never have failed. The data was there, we saw
                // it. And we have exclusive access to the list

                DBGASSERT(false);
                CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                    "ASSERT: pList->Delete returned %u", (DWORD) deletestatus);
                goto lDone;
            }
        }

        // Repeat until we're done
    }

    // All references have been removed. Now we gotta insert a 'Leaderboard
    // Reset' item in the change list
    {
        ChangeListKey key   = { uiTitleId, uiLbId, 0 };
        ChangeListData data = { ChangeListOperationTypeResetLb };

        BTree::INSERTSTATUS insertres = pList->InsertIntoChangeList(pUmsClient, &key, sizeof(key),
            &data, sizeof(data));

        // Check returned status of the operation. If it failed because the key
        // was already there, it's OK. As long as it's there, we don't care.
        if(BTree::INSERTSTATUS_SUCCEEDED != insertres
           && BTree::INSERTSTATUS_PRIMARY_KEY_VIOLATION != insertres)
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                "pList->Insert returned %u", (DWORD) insertres);
            goto lDone;
        }
    }

    _lockCurrentList.Unlock();
    fLock = false;

    // List definitelly changed
    pList->SetModifiedFlag();
    pList->Release();
    pList = NULL;

    // Make sure the processing thread is up and running
    if(_fIsSleeping)
        ::SetEvent(_hWakeUp);

    fRet = true;

lDone:

    if(fLock)
        _lockCurrentList.Unlock();

    if(pList != NULL)
    {
        pList->Release();
        pList = NULL;
    }

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Just calls ThreadProc
DWORD CPersister::StaticThreadProc(void* pRawThis)
{
    HRESULT hr =::CoInitializeEx(NULL, COINIT_MULTITHREADED); // Needed for com related operation
    CGlobalError::Init();
    ((CPersister*)pRawThis)->ThreadProc();
    CGlobalError::Term();
    if (SUCCEEDED(hr))
    {    
        ::CoUninitialize();
    }
    return 0;
}

bool CPersister::IsPersisterThreadSleeping()
{
    if (_fIsSleeping)
        return true;
    else
        return false;
}


// This is the controller thread. It will detect when there are items to go to the database. 
// The actual data base update will be done by other n other threads. 
void CPersister::ThreadProc()
{
    HANDLE * pThreadArray;
    
    DBGASSERT(_nDatabaseThreadCount > 0);

    pThreadArray = new HANDLE[_nDatabaseThreadCount];
    if (NULL == pThreadArray)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: allocating Handle structure fails");
        goto lDone;
    }
    
    for (DWORD dwThreadIndex=0;dwThreadIndex<_nDatabaseThreadCount;dwThreadIndex++)
    {
        DWORD dwThreadId = 0;
        pThreadArray[dwThreadIndex] = ::CreateThread(NULL, 0, StaticDatabaseWriteThreadProc, this , 0,
                                                     &dwThreadId);

        if(NULL == pThreadArray[dwThreadIndex])
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "CreateThread failed. Error=%u", GetLastError());
            goto lDone;
        }
    }

    while(!_fShutdown)
    {
        // The background thread (us) processes the list referenced by
        // _pSpareList. Meanwhile other threads can add new references to
        // _pCurrentList. When we're done with _pSpareList, we'll swap it with
        // the other list
        CChangeList* pChangeList = const_cast<CChangeList*>(_pSpareList);

        // Wait until all references to change list go away
        while(pChangeList->GetReferenceCount() > 0)
        {
            Sleep(50);
        }

        //////// INTEGRITY CHECK
        #if _DEBUG
        if(!pChangeList->Verify(_pCtrl))
        {
            CTraceFile traceFile;
            traceFile.Init("c:\\lbsvr-trace.txt");
            traceFile.Write(CGlobalError::GetCurrentMessage());
            pChangeList->DumpTree(_pCtrl, &traceFile);
            traceFile.Term();
            DebugBreak();
        }
        #endif
        ////////

        DBGASSERT(NULL != _phDoneDatabaseWriteWork);

        //prepare to start the database write threads
        for (DWORD i=0;i<_nDatabaseThreadCount;i++)
        {
            DBGASSERT(NULL != _phDoneDatabaseWriteWork[i]);
            ::ResetEvent(_phDoneDatabaseWriteWork[i]);
        }

        //start all the database write threads
        for (DWORD i=0;i<_nDatabaseThreadCount;i++)
        {
            DBGASSERT(NULL != _phDoDatabaseWriteWork[i]);
            ::SetEvent(_phDoDatabaseWriteWork[i]);
        }

        //wait until all database write threads are done
        ::WaitForMultipleObjectsEx( _nDatabaseThreadCount,
                                    _phDoneDatabaseWriteWork,
                                    TRUE,
                                    INFINITE,
                                    FALSE
                                  );

        //at this point - all threads have scanned through the entire list
        //let reset the change list
        pChangeList->Reset(_pCtrl);
        pChangeList->ResetModifiedFlag();

        // Anything to be processed in the current list? (The current list is
        // the one available to other threads). If there is nothing, we're
        // going to sleep.
        if(!const_cast<CChangeList*>(_pCurrentList)->WasModified())
        {
            ::ResetEvent(_hWakeUp);
            ::InterlockedExchange(&_fIsSleeping, TRUE);

            // Last chance
            if(!((CChangeList*)_pCurrentList)->WasModified())
            {
                // Yup, the current list hasn't been modified. Whoever
                // updates it though, will make sure to wake us up.
                ::WaitForSingleObject(_hWakeUp, INFINITE);
            }

            ::InterlockedExchange(&_fIsSleeping, FALSE);
        }

        // So, do we have data or not? (If not, it's fine. We'll loop and
        // try again)
        if(const_cast<CChangeList*>(_pCurrentList)->WasModified())
        {
            // Swap _pSpareList with _pCurrentList
            _lockCurrentList.Lock();
            CChangeList* pTemp = const_cast<CChangeList*>(_pCurrentList);
            _pCurrentList      = _pSpareList;
            _pSpareList        = pTemp;
            _lockCurrentList.Unlock();
            
            InterlockedIncrement(&_lSwapCount); //BUG BUG - Do we really need interlockedIncrement
        }
    }


lDone:

    if (NULL != pThreadArray)
    {
        for (DWORD dwThreadIndex=0;dwThreadIndex<_nDatabaseThreadCount;dwThreadIndex++)
        {
            if (NULL != pThreadArray[dwThreadIndex])
            {
                ::CloseHandle(pThreadArray[dwThreadIndex]);
                pThreadArray[dwThreadIndex] = NULL;
            }
        }
    
        delete [] pThreadArray;
        pThreadArray = NULL;
    }
    
}

DWORD CPersister::StaticDatabaseWriteThreadProc(void* pRawThis)
{
    ::CoInitializeEx(NULL, COINIT_MULTITHREADED); // Needed for webstore
    CGlobalError::Init();
    ((CPersister*)pRawThis)->ThreadProcDatabaseWrite();
    CGlobalError::Term();
    ::CoUninitialize();
    return 0;
}

void CPersister::ThreadProcDatabaseWrite()
{
    CArenaMemAlloc alloc;
    CPersisterIterator * pPersisterIterator =  NULL;
    IUmsClient         * pCtrl              =  NULL;
    LONG nThreadIndex  = InterlockedIncrement(&_nThreadIndex) - 1;

    if(!_pUMS->CreateUmsClient(&pCtrl))
        goto lDone;

    pPersisterIterator = new CPersisterIterator(nThreadIndex, _nDatabaseThreadCount);
    if (NULL == pPersisterIterator)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Error creating CPersisterIterator. Error=%u", GetLastError());
        goto lDone;
    }

    while(!_fShutdown)
    {
        ::WaitForSingleObject(_phDoDatabaseWriteWork[nThreadIndex], INFINITE);
        ::ResetEvent(_phDoDatabaseWriteWork[nThreadIndex]); //work taken
        
        CChangeList* pChangeList = const_cast<CChangeList*>(_pSpareList);

        if(!pChangeList->SearchByRank(pCtrl, 1, false,(BTree::Iterator *)pPersisterIterator))
        {
            XomNtEvent(XEVENT_STATS_CODE_37,
                "ASSERT: this should never fail. \n %s",
                CGlobalError::GetCurrentMessage());

            DBGASSERT(false);

            // Unfortunatelly, there is not much we can do
            ::Sleep(5000);
            continue;
        }

        // Enumerate all entries in the list
        while(pPersisterIterator->Read())
        {
            // Get reference
            ChangeListKey* pKey;
            ChangeListData* pData;
            pPersisterIterator->Get((void**)&pKey, NULL, (void**)&pData, NULL);
            // Process reference according to operation type
            alloc.Reset();
            if(pData->operation == ChangeListOperationTypeUpdate)
            {
                // Update row
                UpdateLeaderboardRowInDatabase(pKey, &alloc, pCtrl);
            }
            else if(pData->operation == ChangeListOperationTypeResetLb)
            {
                // Reset leaderboard
                ResetLeaderboardInDatabase(pKey);
            }
            else
            {
                XomNtEvent(XEVENT_STATS_CODE_38,
                    "ASSERT: Invalid operation code %u",
                    (DWORD) pData->operation);

                DBGASSERT(false);
            }   

            if (NULL != _pPerfCounters)
            {
                _pPerfCounters->SafeDecrement32(LBPERF_SERVER_DBQUEUE_COUNTER);
            }
            
        }


        ::SetEvent(_phDoneDatabaseWriteWork[nThreadIndex]); //signal done to the controller thread
    }

lDone:

    if(NULL != pCtrl)
    {
        _pUMS->ReleaseUmsClient(pCtrl);
        pCtrl = NULL;
    }

    if (NULL != pPersisterIterator)
    {
        delete pPersisterIterator;
        pPersisterIterator = NULL;
    }
}


// Update leaderboard row in database
void CPersister::UpdateLeaderboardRowInDatabase(
    ChangeListKey* pKey,
    CArenaMemAlloc* pAlloc,
    IUmsClient * pCtrl
)
{
    bool fRet = false;
    CLb* pLb = NULL;
    LbStat* pStats = NULL;
    DWORD cStats = 0;
    DWORD dwRank;
    UINT64 ui64LastUpdt;

    // Get leaderboard
    CLbList::GetLbStatus getstatus = _pLbList->GetLb(pKey->uiTitleId,
        pKey->uiLbId, &pLb);

    if (getstatus == CLbList::GetLbStatusNotFound) //In the mean time, the leaderboard have been deleted, so this is a NO-OP
    {
        fRet = true;
        goto lDone;
    }

    if(getstatus != CLbList::GetLbStatusSucceeded)
        goto lDone;

    // Get stats
    CGlobalError::Reset();
    CLb::StatReadStatus readstatus = pLb->StatRead(pCtrl, pKey->ui64Puid,
        pAlloc, &pStats, &cStats, &dwRank, &ui64LastUpdt);

    pLb->Release();
    pLb = NULL;

    if(CLb::StatReadStatusSucceeded == readstatus)
    {
        // There is a row in the leaderboard. We must update it in the
        // database. If the databse is down and the operation fails, we're
        // going to keep retrying undefinitely until it succeeds.

        CGlobalError::Reset();
        while(!_pDb->UpdateLbRow(
            pKey->uiTitleId,
            pKey->uiLbId,
            pKey->ui64Puid,
            pStats,
            cStats,
            ui64LastUpdt)
        )
        {
            XomNtEvent(XEVENT_STATS_COMM_11,
                "Failed to update leaderboard row in the database. We'll try "
                "again in %u milliseconds. "
                "\n pKey->uiTitleId = 0x%08x"
                "\n pKey->uiLbId = %u"
                "\n pKey->ui64Puid = 0x%08I64x"
                "\n %s",
                _pConfig->GetPersisterRetryInterval(),
                pKey->uiTitleId,
                pKey->uiLbId,
                pKey->ui64Puid,
                CGlobalError::GetCurrentMessage());

            // We're going to wait a bit and try again
            ::Sleep(_pConfig->GetPersisterRetryInterval());
        }
    }
    else if(CLb::StatReadStatusNotFound == readstatus)
    {
        // The row was not found in the leaderboard. We're going to remove it
        // from the database.

        while(!_pDb->RemoveLbRow(
            pKey->uiTitleId,
            pKey->uiLbId,
            pKey->ui64Puid)
        )
        {
            XomNtEvent(XEVENT_STATS_COMM_12,
                "Failed to update leaderboard row in the database. We'll try "
                "again in %u milliseconds. "
                "\n pKey->uiTitleId = 0x%08x"
                "\n pKey->uiLbId = %u"
                "\n pKey->ui64Puid = 0x%08I64x"
                "\n %s",
                _pConfig->GetPersisterRetryInterval(),
                pKey->uiTitleId,
                pKey->uiLbId,
                pKey->ui64Puid,
                CGlobalError::GetCurrentMessage());

            // We're going to wait a bit and try again
            ::Sleep(_pConfig->GetPersisterRetryInterval());
        }
    }
    else
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "pLb->StatRead returned %u", (DWORD) readstatus);
        goto lDone;
    }

    fRet = true;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\n pKey->uiTitleId = 0x%08x"
            "\n pKey->uiLbId = %u"
            "\n pKey->ui64Puid = 0x%08I64x",
            pKey->uiTitleId,
            pKey->uiLbId,
            pKey->ui64Puid);

        XomNtEvent(XEVENT_STATS_CODE_39,
            "Failed to update leaderboard row in database.\n%s",
            CGlobalError::GetCurrentMessage());
    }
}

// Reset leaderboard in database
void CPersister::ResetLeaderboardInDatabase(
    ChangeListKey* pKey
)
{
    bool fRet = false;

    if(pKey->ui64Puid  != 0)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ASSERT: Invalid key");
        goto lDone;
    }

    while(!_pDb->ResetLb(
        pKey->uiTitleId,
        pKey->uiLbId)
    )
    {
        XomNtEvent(XEVENT_STATS_COMM_13,
            "Failed to reset leaderboard in the database. We'll try "
            "again in %u milliseconds. "
            "\n pKey->uiTitleId = 0x%08x"
            "\n pKey->uiLbId = %u"
            "\n %s",
            _pConfig->GetPersisterRetryInterval(),
            pKey->uiTitleId,
            pKey->uiLbId,
            CGlobalError::GetCurrentMessage());

        // We're going to wait a bit and try again
        ::Sleep(_pConfig->GetPersisterRetryInterval());
    }

    fRet = true;

lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\n pKey->uiTitleId = 0x%08x"
            "\n pKey->uiLbId = %u",
            pKey->uiTitleId,
            pKey->uiLbId);

        XomNtEvent(XEVENT_STATS_CODE_40,
            "Failed to reset leaderboard in database.\n%s",
            CGlobalError::GetCurrentMessage());
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\jobs.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * jobs.h
 * Header of leaderboard server jobs manager
 * Source: jobs.cpp
 * 
 */
 
 class CJobs : public IServerTimerCallback
 {
 public:
 
    CJobs();
    
    ~CJobs();
    
    bool Init(
        CConfig* pConfig,
        UMS* pUMS,
        CLbList* pLbList,
        CServerTimer* pTimer
    );
    
    void Term();
   
 protected:
 
    virtual ULONG AddRef();
    
    virtual ULONG Release();
    
    virtual void OnTimer(void* pParam);
    
    bool ScheduleNextRun();
    
    static DWORD __stdcall StaticThreadProc(void* pThis);
 
    void ThreadProc();
    
    CConfig* _pConfig;
    UMS* _pUMS;
    CLbList* _pLbList;
    CServerTimer* _pTimer;
    HANDLE _hThread;
    CServerTimerAppt* _pAppt;
    volatile LONG _lRef;
    INT64 _timeLastScheduled;
 };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\lbs.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * lbs.cpp
 * Leaderboard Server 
 * Header: lbs.h
 * 
 */

#include "lbs.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\lbs.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * lbs.h
 * Leaderboard Server main header
 * 
 */

#pragma once

// System includes
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <winsock2.h>
#include <windows.h>
#include <tchar.h>
#include <atlbase.h>
#include <atlcom.h>
#include <xalloc.h>
#include <addref.h>
#include <strsafe.h>

// Live includes
#include <xmgmt.h>
#include <compport.h>
#include <servsock.h>
#include <xeventids.h>
#include <xlocks.h>
#include <OleDbWrapper.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#include <commonconfig.h>

#import "lbwsinterop.tlb" raw_interfaces_only, no_smart_pointers

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblHealthcheck;

#include "perfapi.h"
#include "lbsvrperf.h"
#include "perfctrsLb.h"

// Local includes
#include "util.h"
#include "lbstat.h"
#include "config.h"
#include "ums.h"
#include "buffer.h"
#include "btree.h"
#include "net.h"
#include "db.h"
#include "lb.h"
#include "procs.h"
#include "jobs.h"
#include "health.h"

#include "XElapsed.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\lb.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * lb.h
 * Header of leaderboard server leaderboard classes
 * Source: lb.cpp
 * 
 */

#pragma once

struct LbStat;
struct LbKey;
struct LbBlobStat;
class  LbBlob;
struct LbPuidIndexKey;
struct LbPuidIndexBlob;
class  CLb;
class  CLbList;
class  CChangeList;
class  CPersister;

const DWORD LbInfoSizeLbInfoTable  = 29959; // this is a large prime near our guess for LBs per server.
const DWORD LbInfoSizeTitlePerfTable  = 109; // start out with room for ~100 titles worth of perf instances. (109 is nearest prime)
const UINT64 LbUntierFlagRatingNull = 0x8000000000000000;
const UINT64 LbUntierValueMask      = 0x7FFFFFFFFFFFFFFF;
const DWORD LbMaxStatBuffer        = 8192;
const INT64 LbSmallestRating       = 0x8000000000000000;
const DWORD LbMaxStatsInBuffer     = 300;
const DWORD LbDecayChunkSize       = 3000;
const DWORD PersisterResetChunkSize = 1000;
const DWORD LbTop100               = 100;
const DWORD LbReserveSize          = 100;                      // Amount of reserve rows that will not be deleted when the leaderboard gets trimmed

enum LbResetType
{
    LbResetTypeNever         = 0,
    LbResetTypeWeekly        = 1,
    LbResetTypeMonthly       = 2,
    LbResetTypeBimonthly     = 3,
    LbResetTypeQuarterly     = 4,
    LbResetTypeSemiannually  = 5,
    LbResetTypeAnnually      = 6
};

#pragma pack(push, 1)

struct LbKey
{
    INT64  i64Rating;
    UINT64  ui64Untier;
    
    static int DescendingKeyCompare(
        void* pParam,
        void* pRawKey1, 
        DWORD cbRawKey1,
        void *pRawKey2,
        DWORD cbRawKey2
    )
    {
        LbKey* pKey1 = (LbKey*) pRawKey1;
        LbKey* pKey2 = (LbKey*) pRawKey2;

        int cmp;

        if(pKey1->i64Rating < pKey2->i64Rating)
            cmp = 1;
        else if(pKey1->i64Rating > pKey2->i64Rating)
            cmp = -1;
        else
        {
            if(pKey1->ui64Untier < pKey2->ui64Untier)
                cmp = -1;
            else if(pKey1->ui64Untier > pKey2->ui64Untier)
                cmp = 1;
            else
                cmp = 0;
        }    
        
        return cmp;
    }
    
    bool IsNull() const { return (ui64Untier & LbUntierFlagRatingNull) != 0; }
};

struct LbBlobStat
{
    LbStatId statId;
    BYTE     bType;
    
    union
    {
        INT8   i8;
        INT16  i16;
        INT32  i32;
        INT64  i64;
        double d;
        
        struct
        {
            WORD wStrLen;
            CHAR str[1];
        } str;
    };  

    bool IsNull() const  { return (bType & LbspTypeIdNullFlag) != 0; }
    BYTE GetType() const { return (bType & LbspTypeIdTypeMask); }
};

class LbBlob
{
public:
    // Puid 
    UINT64 puid;
    
    // Number of stats in rgStats
    WORD   wStatCount;
    
    // The array of stats start here
    // LbBlobStat rgStats[];
    
    static bool UpdateStats(
        LbStat rgStats[], 
        DWORD  cStats, 
        BYTE*  pOrigBlob, 
        DWORD  cbOrigBlob,
        BYTE*  pNewBlob,
        DWORD* pcbNewBlob
    );
    
    static bool ParseStats(
        BYTE* pBlob,
        DWORD cbBlob,
        CArenaMemAlloc* pAlloc,
        LbStat rgStats[],
        DWORD* pcStats
    );

protected:

    static DWORD CopyStatBetweenBlobs(
        BYTE*  pOrigBlob, 
        DWORD  cbOrigBlob,
        BYTE*  pNewBlob,
        DWORD  cbNewBlob
    );
    
    static DWORD CopyStatFromLbStatToBlob(
        LbStat* pStat,
        BYTE*   pBlob,
        DWORD   cbBlob
    );
    
    static DWORD GetBlobStatSize(
        LbBlobStat* pStat, 
        DWORD cbBlob
    );
};

// Key stored in Puid index b-tree
struct LbPuidIndexKey
{
    UINT64 ui64Puid;
    
    static int KeyCompare(
        void* pParam,
        void* pRawKey1, 
        DWORD cbRawKey1,
        void* pRawKey2,
        DWORD cbRawKey2
    )
    {
        LbPuidIndexKey* pKey1 = (LbPuidIndexKey*) pRawKey1;
        LbPuidIndexKey* pKey2 = (LbPuidIndexKey*) pRawKey2;
        
        if(pKey1->ui64Puid < pKey2->ui64Puid)
            return -1;
        else if(pKey1->ui64Puid > pKey2->ui64Puid)
            return 1;
        else
            return 0;
    }
};

// Data stored in Puid index b-tree
struct LbPuidIndexBlob
{
    // Reference to the leaderboard b-tree
    LbKey lbKey;
    
    // Last update in UTC filetime 
    UINT64 lastUpdateTime;
};

#pragma pack(pop)

struct LbTitleLbIdKey
{
    DWORD dwTitleId;
    DWORD dwLbId;

    INLINE DWORD GetHash(LbTitleLbIdKey key)
    {
        return key.dwTitleId + key.dwLbId; // TODO: evaluate 
    }
    
    INLINE bool IsEqual(LbTitleLbIdKey keyA, LbTitleLbIdKey keyB)
    {
        return keyA.dwTitleId == keyB.dwTitleId
               && keyA.dwLbId == keyB.dwLbId;
    }
};

struct LbTitlePerfInfo
{
    PERFINSTANCE perfInstance;
    DWORD dwLBCount;
};

class __declspec(novtable) ILbEnumCallback
{
public:    
    virtual bool OnNewRow(
        DWORD  dwRank,
        UINT64 puid,
        LbStat* rgStats,
        DWORD cStats
    ) = 0;
};

class CLb 
{
friend CLbList;
public:    

    USE_GLOBAL_ALLOC;

    enum LbStatus
    {
        Created   = 1, //created - no operation can be performed
        Loading   = 2, //loading but not complete yet - no operation can be performed
        UnLoading = 3, //unloading - no operation can be performed
        ReadOnly  = 4, //can be read
        ReadWrite = 5  //can be read or written
    };

    bool GetLbStatus(
        LbStatus *  pLbStatus
    );

    bool SetLbStatus(
        LbStatus    lbStatus
    );

    bool StatWrite(
        IUmsClient* pUmsClient,
        UINT64 puid,
        LbStat rgStat[],
        DWORD  cStat
    );
    
    bool StatWriteEx(
        IUmsClient* pUmsClient,
        UINT64 puid,
        LbStat rgStat[],
        DWORD  cStat,
        UINT64 lastUpdateTime
    );
    
    enum StatReadStatus
    {
        StatReadStatusSucceeded,
        StatReadStatusNotFound,
        StatReadStatusOtherError
    };

    enum GetRankForLbkeyStatus
    {
        GetRankForLbkeyStatusSucceeded,
        GetRankForLbkeyStatusOtherError
    };
    
    StatReadStatus StatRead(
        IUmsClient* pUmsClient,
        UINT64 puid,
        CArenaMemAlloc* pAlloc,
        LbStat** ppStats,
        DWORD* pcStats,
        DWORD* pdwRank,
        UINT64* pui64lastUpdateTime
    );

    GetRankForLbkeyStatus GetRankForLbkey(
        IUmsClient* pUmsClient,
        LbKey lbKey,
        CArenaMemAlloc* pAlloc,
        DWORD* pdwRank
    );
    
    bool EnumByRank(
        IUmsClient* pUmsClient,
        DWORD dwRank,
        DWORD dwEntryCount,
        ILbEnumCallback* pCallback
    );

    bool EnumByRating(
        IUmsClient* pUmsClient,
        LbKey key,
        DWORD dwEntryCount,
        ILbEnumCallback* pCallback
    );
    
    bool ResetLb(
        IUmsClient* pUmsClient
    );
    
    bool ResetPuid(
        IUmsClient* pUmsClient,
        UINT64 puid
    );

    bool DecayLb(
        IUmsClient* pUmsClient,
        UINT64 timeNow
    );
    
    bool TrimLb(
        IUmsClient* pUmsClient
    );
    
    bool ChangeLastUpdateTimeOfAll(
        IUmsClient* pUmsClient,
        UINT uiDays
    );

    enum GetRankForPuidStatus
    {
        GetRankForPuidStatusSucceeded,
        GetRankForPuidStatusPuidNotFound,
        GetRankForPuidStatusOtherError
    };
     
    GetRankForPuidStatus GetRankForPuid(
        IUmsClient* pUmsClient,
        UINT64 puid,
        DWORD* pdwRank
    );
    
    bool DumpMemoryStats(
        IUmsClient* pUmsClient,
        ITraceCallback* pOut
    );

    bool DumpLbBinary(
        IUmsClient* pUmsClient,
        ITraceCallback* pOut
    );

    bool DumpLbSearchPath(
        IUmsClient* pUmsClient,
        ITraceCallback* pOut,
        void *pKey, WORD cbKey, bool bUserIndex
    );

    DWORD GetTitleId()          const { return _dwTitleId; }
    DWORD GetLbId()             const { return _dwLbId; }
    LbResetType GetResetType() const { return _eResetType; }

    void SetResetType(LbResetType resettype)
    {
        _eResetType = resettype;
        XomNtEvent(XEVENT_STATS_INFO_21, "SetResetType Title %u Lb %u ResetType %u", GetTitleId(), GetLbId(), GetResetType());
    }
    
    DWORD GetDecayDays()        const { return _dwDecayDays; }

    void SetDecayDays(DWORD dwDecayDays)
    {
        _dwDecayDays = dwDecayDays;
        XomNtEvent(XEVENT_STATS_INFO_22, "SetDecayDays Title %u Lb %u DecayDays %u", GetTitleId(), GetLbId(), GetDecayDays());
    }
    
    
    DWORD GetMaxEntryCount()    const { return _dwMaxEntryCount; }

    void SetMaxEntryCount(DWORD dwMaxEntryCount)
    {
        _dwMaxEntryCount = dwMaxEntryCount;
        XomNtEvent(XEVENT_STATS_INFO_23, "SetMaxEntryCount Title %u Lb %u MaxEntryDays %u", GetTitleId(), GetLbId(), GetMaxEntryCount());
    }
    
    UINT64 GetLastResetTime()   const { return _lastResetTime; }
    
    LONG GetRankedEntryCount()  const 
    { 
        LONG lRankedEntryCount = _lRankedEntryCount;
        
        if(_dwMaxEntryCount > 0 && lRankedEntryCount > (LONG)_dwMaxEntryCount)
        {
            // If this is a lightweight leaderboard, the world must never know
            // that it has more than _dwMaxEntryCount entries
            lRankedEntryCount = _dwMaxEntryCount;
        }
        
        return lRankedEntryCount; 
    }
    
    LONG AddRef()
    {
        return InterlockedIncrement(&_lRefCount);
    }
    
    LONG Release()
    {
        LONG lCount = InterlockedDecrement(&_lRefCount);
        DBGASSERT(lCount >= 0);
        return lCount;
    }
    
    void SetPersist(bool fPersist)
    {
        ::InterlockedExchange(&_fPersist, fPersist ? TRUE : FALSE);
    }
    
    bool SetLastResetTime(UINT64 lastReset);
    
    void GetLockId(LOCK_ID* plid)
    {
        GetLockId(_dwTitleId, _dwLbId, plid);
    }
    
    static void GetLockId(UINT32 uiTitleId, UINT32 uiLbId, LOCK_ID* plid)
    {
        plid->type = LOCK_TYPE_LB;
        plid->id   = (((UINT64)uiTitleId) << 32) | ((UINT64)uiLbId);
    }

    bool GetPerLBPerfCountersEnabled()
    {
        return _perfInstancePerLB.pbDataStart != NULL;
    }

    bool ToggleInstancePerfCounters(bool fEnable, CPerfCounters* pPerfCounters);
    void InstancedPerfCounterIncrementValue32(CPerfCounters * pPerfCounters, DWORD dwCounterID, DWORD dwAmount);
    void InstancedPerfCounterIncrementValue64(CPerfCounters * pPerfCounters, DWORD dwCounterID, QWORD qwAmount);
protected:    

    CLb(
        DWORD dwTitleId,
        DWORD dwLbId,
        LbResetType resetType,
        UINT uiDecayDays,
        UINT uiMaxEntryCount,
        UINT64 lastResetTime,
        CLbList * lblistParent
    );
    
    bool Init(
        IUmsClient* pUmsClient,
        CBufferManager*  pBM,
        CPersister* pPersister,
        CConfig* pConfig
    );

    void Term(
        IUmsClient* pUmsClient
    );

    void Term(
        IUmsClient* pUmsClient,
        bool fApplicationTerminates
    );
        
    bool UpdateLeaderboard(
        IUmsClient* pUmsClient,
        UINT64 puid,
        LbKey* pCurLbKey,
        LbKey* pNewLbKey,
        bool   fNewLbEntry,
        LbStat rgStat[],
        DWORD  cStat
    );
    
    bool UpdatePuidIndex(
        IUmsClient* pUmsClient,
        UINT64 puid,
        LbKey* pNewLbKey,
        LbKey* pCurLbKey,
        bool*  pfNewLbEntry,
        UINT64 lastUpdateTime
    );
    
    bool GetIndexedStats(
        IN LbStat rgStat[],
        IN DWORD  cStats,
        OUT LbKey* pNewLbKey,
        OUT bool* pfNewLbKey
    );
    
    bool CheckForRankCap(
        IUmsClient* pUmsClient,
        LbKey* pKey
    );
    
    void DefaultLbKey(LbKey* pKey)
    {
        pKey->i64Rating  = LbSmallestRating;
        pKey->ui64Untier   = LbUntierFlagRatingNull |
            (InterlockedIncrement64((volatile LONGLONG*)&_ui64Untier) 
                & LbUntierValueMask);
    }
    
    LONG GetRefCount() const { return _lRefCount; }
    
    CConfig*       _pConfig;
    CPersister*    _pPersister;
    DWORD          _dwTitleId;
    DWORD          _dwLbId;
    LbResetType    _eResetType;
    DWORD          _dwDecayDays;
    DWORD          _dwMaxEntryCount;
    BTree          _userIndex;
    BTree          _leaderboard;
    volatile UINT64 _ui64Untier;
    volatile LONG  _lRefCount;
    volatile LONG  _lRankedEntryCount;
    volatile LONG  _fPersist;

    LbStatus       _lbStatus; 
    CFastLock      _LbStatusFastLock;
    // Last time leaderboard was reset in UTC filetime
    UINT64         _lastResetTime;
    // store the info about the perf instance for this leaderboard
    PERFINSTANCE _perfInstancePerLB;
    CLbList * _plblistParent;
};

class CLbList
    : public IDbCallback 
{
public:

    CLbList()
    {
        _pConfig    = NULL;
        _pBM        = NULL;
        _pUMS       = NULL;
        _pPersister = NULL;
        _pDb        = NULL;
        _hTaskWait  = NULL;
    }
    
    ~CLbList()
    {
        DBGASSERT(NULL == _hTaskWait);
    }
    
    bool Init(
        CConfig* pConfig, 
        CBufferManager* pBM,
        UMS* pUMS,
        CPersister* pPersister,
        CDb* pDb,
        CPerfCounters* pPerfCounters
    );
    
    void Term(
        bool fApplicationShutDown);

    void Term();
    
    bool Load(
        bool fDelete);
    
    enum CreateLbStatus
    {
        CreateLbStatusSucceeded,
        CreateLbStatusLbExists,
        CreateLbStatusOtherError
    };

    CreateLbStatus CreateAndLoadOneLB(
        IUmsClient * pUmsClient, 
        ConfigLbInfo * plbInfo
    );

    CreateLbStatus CreateLb(
        IUmsClient* pUmsClient,
        DWORD dwTitleId,
        DWORD dwLbId,
        LbResetType resetType,
        UINT uiDecayDays,
        UINT uiMaxEntryCount,
        UINT64 lastResetTime,
        CLb** ppLb 
    );
    
    enum DeleteLbStatus
    {
        DeleteLbStatusSucceeded,
        DeleteLbStatusNotFound,
        DeleteLbStatusOtherError
    };
    
    DeleteLbStatus DeleteLb(
        IUmsClient* pUmsClient,
        DWORD dwTitleId,
        DWORD dwLbId,
        bool fPersist
    );

    DeleteLbStatus DeleteLb(
        IUmsClient* pUmsClient,
        DWORD dwTitleId,
        DWORD dwLbId,
        bool fPersist,
        bool fApplicationTerminates
    );

    enum ResetLbStatus
    {
        ResetLbStatusSucceeded,
        ResetLbStatusNotFound,
        ResetLbStatusOtherError
    };
    
    ResetLbStatus ResetLb(
        IUmsClient* pUmsClient,
        DWORD dwTitleId,
        DWORD dwLbId
    );
    
    enum GetLbStatus
    {
        GetLbStatusSucceeded,
        GetLbStatusNotFound,
        GetLbStatusOtherError
    };
    
    GetLbStatus GetLb(
        DWORD dwTitleId,
        DWORD dwLbId,
        CLb** ppLb
    );

    DWORD GetSwapCount(
    );

    bool IsPersisterThreadSleeping(
    );
    
    bool GetLbList(
        IMemAlloc* pAlloc,
        LbTitleLbIdKey** prgLbList,
        DWORD* pdwLbCount
    );
    
    bool AutoReset(
        IUmsClient* pUmsClient,
        UINT64 uiTimeNow
    );
    
    bool AutoDecay(
        IUmsClient* pUmsClient,
        UINT64 uiTimeNow
    );
    
    bool AutoTrim(
        IUmsClient* pUmsClient
    );
    
    bool DumpLbList(
        ITraceCallback* pOut,
        UINT32 uiTitleId
    );

    bool ReloadSettingForLb( 
         DWORD dwTitleId,
         DWORD dwLbId,
         IUmsClient* pUmsClient,
         ConfigLbInfo *pConfigLbInfo
    );

    bool ReloadSettingForTitle( 
        DWORD dwTitleId,
        IUmsClient* pUmsClient,
        UINT32 *pdwLbProcessed
    );

    bool ToggleInstancePerfCountersForLBs( 
        UINT uiTitleId,
        bool fEnable);

    bool ToggleInstancePerfCountersForTitles( 
        UINT uiTitleId,
        bool fEnable);

    bool ToggleInstancePerfCountersForTitle(
        UINT uiTitleId,
        LbTitlePerfInfo * pTitlePerfInfo,
        bool fEnable);
    
    PERFINSTANCE * GetTotalPerfInstancePtr();

    THashtable<UINT,LbTitlePerfInfo> * CLbList::GetTitleInstanceHashPtr();
    
protected:

    virtual bool OnRow(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid,
        LbStat rgStats[],
        DWORD  cStats,
        UINT64 lastModified
    );

    enum LbListTaskType
    {
        LbListTaskTypeInit,
        LbListTaskTypeTerm
    };
    
    CConfig*         _pConfig;
    CBufferManager*  _pBM;
    UMS*             _pUMS;
    
    // The persister is responsible to keep the external database up-to-date
    // with changes in leaderboards
    CPersister*     _pPersister;
    
    // Provides direct access to external database
    CDb* _pDb;
    
    THashtable<LbTitleLbIdKey,CLb*,LbTitleLbIdKey> _lbTable;
    xlocks::CReaderWriterLock3 _lockLbTable;
    THashtable<UINT,LbTitlePerfInfo> _titlePerfTable;
    xlocks::CReaderWriterLock3 _lockTitlePerfTable;
    HANDLE          _hTaskWait;
    volatile LbListTaskType  _taskType;
    volatile LONG   _fTaskSucceeded;
    CLargeStr       _taskMessage;
    CPerfCounters* _pPerfCounters;
    PERFINSTANCE _perfInstanceTotal;
};


// Stores references to changes in leaderboards. It's used by CPersister.
// It's basically a BTree plus some other stuff like refcounting
class CChangeList : public BTree, public CSingleLink
{
public:
    
    CChangeList(CPerfCounters* pPerfCounters)
        : _lRefCount(0), _lModified(0)
    {
        _pPerfCounters = pPerfCounters;
    }
    
    void AddRef()
    {
        InterlockedIncrement(&_lRefCount);
    }
    
    void Release()
    {
        InterlockedDecrement(&_lRefCount);
    }
    
    LONG GetReferenceCount()
    {
        return _lRefCount;
    }
    
    void ResetModifiedFlag()
    {
        ::InterlockedExchange(&_lModified, FALSE);
    }
    
    void SetModifiedFlag()
    {
        if(!_lModified)
            ::InterlockedExchange(&_lModified, TRUE);
    }
    
    bool WasModified()
    {
        return _lModified != NULL;
    }

    //we shall intercept theses call for counting
    //Note: No locking is necessary since list is locked before use
    BTree::INSERTSTATUS InsertIntoChangeList(IUmsClient* pUmsClient, void* pKey, WORD cbKey, void* pData, WORD cbData)
    {
        BTree::INSERTSTATUS res =  Insert(pUmsClient, pKey, cbKey, pData, cbData);
        if (res == BTree::INSERTSTATUS_SUCCEEDED)
        {
            if (NULL != _pPerfCounters)
            {
                _pPerfCounters->SafeIncrement32(LBPERF_SERVER_DBQUEUE_COUNTER);
            }
        }
        
        return res;
    }

    BTree::DELETESTATUS DeleteFromChangeList(IUmsClient* pUmsClient,void* pKey, WORD cbKey, void* pData, WORD *pcData)
    {
        BTree::DELETESTATUS res = Delete(pUmsClient, pKey, cbKey, pData);
        if (res == BTree::DELETESTATUS_SUCCEEDED)
        {
            if (NULL != _pPerfCounters)
            {
                _pPerfCounters->SafeDecrement32(LBPERF_SERVER_DBQUEUE_COUNTER);
            }
        }
        
        return res;
    }
    
protected:
    
    volatile LONG _lRefCount;
    volatile LONG _lModified;
    CPerfCounters* _pPerfCounters;
};

/*
    A BTree Iterator which will skip over leaderboard it is not interested in. 
    This will be partitioned using the usual modulo 

    leaderboard of interest = leaderboard id % thread index

*/
class CPersisterIterator:public BTree::Iterator
{ 
public:

    CPersisterIterator(int nIndex, int nCount)
    {
        _nIndex = nIndex;
        _nCount = nCount;
    }
  

    /*
        This advances the iterator until an item that belongs to this thread. Return false if we can't find any.
        In the worst case, the entire collection contains no items for a thread. So the thread will scan the entire collection without doing nothing. 
        The problem with this is that since there should be very little blocking doing the scanning, it might spike the CPU momentarily.
        Fortunately this is a far fetched case but i may consider putting some form of a sleep after n items.
   */
    bool Read()
    {
        bool bAnyItem = false;
        
        while ((bAnyItem = this->BTree::Iterator::Read()) == true)
        {
            ChangeListKey* pKey;    
            this->BTree::Iterator::Get((void **)&pKey, NULL , NULL, NULL);

            if ((pKey->uiLbId + pKey->uiTitleId) % _nCount == _nIndex)
            {
                bAnyItem = true;
                break;
            }

        }
        
        return bAnyItem;
    }
    
protected:
    
    int _nIndex; //usually means the thread index
    int _nCount; //usually means the total number of threads
};

// Handles the task of updating leaderboard data on the database
class CPersister
{
USE_GLOBAL_ALLOC;

public:

    CPersister();
    
    ~CPersister();
    
    bool Init(
        CConfig* pConfig,
        UMS* pUMS,
        CDb* pDb,
        CLbList* pLbList,
        CBufferManager* pBM,
        CPerfCounters*  pPerfCounters
    );
    
    void Term();
    
    virtual bool MarkLbRowForUpdate(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid
    );
    
    virtual bool ResetLb(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId
    );

    virtual bool GetSwapCount(
        UINT32 * puSwapCount
    );

    virtual bool IsPersisterThreadSleeping();

protected:

    static DWORD StaticThreadProc(
        void* pRawThis
    );
    
    void ThreadProc();

    static DWORD StaticDatabaseWriteThreadProc(void* pRawThis);

    void ThreadProcDatabaseWrite();
    
    void UpdateLeaderboardRowInDatabase(
        ChangeListKey* pKey,
        CArenaMemAlloc* pAlloc,
        IUmsClient *pUms
    );
    
    void ResetLeaderboardInDatabase(
        ChangeListKey* pKey
    );

    // Config object
    CConfig* _pConfig;
    
    // UMS
    UMS* _pUMS;
    
    // UMS client or task control. It's needed in order to play with b-trees
    IUmsClient* _pCtrl;
    
    // Database object
    CDb* _pDb;
    
    // Leaderboard directory. This is how we have access to the leaderboards.
    CLbList* _pLbList;
    
    // The change list is where we store references to the rows that have 
    // changed recently and therefore need to be updated in the database.
    // The 'current' list is the one where new references are inserted while
    // the 'spare' list can be processed in the background. When the spare list
    // is done being processed, it switches place with the current list
    volatile CChangeList* _pCurrentList;
    volatile CChangeList* _pSpareList;

    // Lock access to _pCurrentList and _pUpdatingList
    CFastLock _lockCurrentList;

    UINT32 _nDatabaseThreadCount;

    HANDLE _hThread; // Thread handle
    HANDLE _hWakeUp; // Event used to get the thread to wake up

    HANDLE * _phDoDatabaseWriteWork;
    HANDLE * _phDoneDatabaseWriteWork;
    
    volatile LONG _nThreadIndex;
    
    // Flag to tell the thread to shutdown
    volatile LONG _fShutdown;

    // Flag to tell the thread to sleep
    volatile LONG _fSleep; 
    
    // The thread will set this flag every time it goes to sleep and will 
    // reset it every time it awakes
    volatile LONG _fIsSleeping;
    volatile LONG _lSwapCount; //represent the number of times _pCurrentList and _pSpareList Swapped

    CPerfCounters* _pPerfCounters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\lbstat.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * lbstat.h
 * 
 * Defines the LbStat structure other related stuff.
 * 
 */

#pragma once

// Stat types
const BYTE  LbspTypeIdInt8   = 0x01;
const BYTE  LbspTypeIdInt16	 = 0x02;
const BYTE  LbspTypeIdInt32	 = 0x03;
const BYTE  LbspTypeIdInt64	 = 0x04;
const BYTE  LbspTypeIdDouble = 0x05;
const BYTE  LbspTypeIdString = 0x06;

// Special types
const BYTE  LbspTypeIdTypeMask     = 0x7F;
const BYTE  LbspTypeIdNullFlag     = 0x80;

typedef WORD LbStatId;

// Special stats
const WORD LbStatIdRank      = 0xffff;
const WORD LbStatIdRating    = 0xfffe;

struct LbStat
{
    LbStatId statId;
    BYTE     bType;
	
    union
	{
		INT8   i8;
		INT16  i16;
		INT32  i32;
		INT64  i64;
		double d;
		
		struct
		{
			WORD wStrLen;
			CHAR* pstr;
		} str;
	};
    
    bool IsNull() const  { return (bType & LbspTypeIdNullFlag) != 0; }
    BYTE GetType() const { return (bType & LbspTypeIdTypeMask); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\net.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * net.cpp
 * Implementation of leaderboard server network component 
 * Header: net.h
 * 
 */

#include "lbs.h"

/*****************************************************************************
  CNet
*****************************************************************************/

CNet::CNet()
{
    _lRef                 = 0;
    _lOutstandingCntCount = 0;
    _pConfig              = NULL;
    _pTimer               = NULL;  
    _pCompPort            = NULL;
    _pListenSocket        = NULL;
    _lMaxConnections      = 0;
    _dwCntIdSeed          = 0;
    _fSocketInit          = false;
    _fShutdown            = FALSE;
    _pCallback            = NULL;
}

CNet::~CNet()
{
    DBGASSERT(0    == _lRef);
    DBGASSERT(0    == _lOutstandingCntCount);
    DBGASSERT(NULL == _pListenSocket);
    DBGASSERT(NULL == _pCompPort);
    DBGASSERT(!_fSocketInit);
}

class CCompPortInit : public ICompletionPortThreadInit
{
IMPLEMENT_REFCOUNT;
USE_GLOBAL_ALLOC;
public:
    virtual void OnThreadInit()
    {
        CGlobalError::Init();
    }
    virtual void OnThreadTerm()
    {
        CGlobalError::Term();
    }
};

bool CNet::Init(
    CConfig* pConfig, 
    CServerTimer* pTimer,
    INetCallback* pCallback,
    CPerfCounters* pPerfCounters
)
{
    bool fRet = false;
    HRESULT hr;
    WSADATA wsaData;
    CCompPortInit* pCompPortInit = NULL;
    
    _lRef             = 0;
    _pConfig          = pConfig;
    _pTimer           = pTimer;
    _fShutdown        = FALSE;
    _pCallback        = pCallback;
    _pPerfCounters    = pPerfCounters;
    _lMaxConnections  = pConfig->GetMaxInetConnections();   //will be in config
    
    // Initialize sockets
    if(WSAStartup(MAKEWORD(2,2), &wsaData) != 0)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "WSAStartup failed.");
        goto lDone;
    }
    _fSocketInit = true;
    
    // Create IO thread pool and completion port
    pCompPortInit = new CCompPortInit();
    if(NULL == pCompPortInit)
        goto lDone;
    
    hr = CCompletionPort::CreateInstance(pConfig->GetIOThreadCount(), 
        pConfig->GetIOThreadCount(), THREAD_PRIORITY_NORMAL, &_pCompPort,
        pCompPortInit);
        
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CCompletionPort::CreateInstance failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    // Create a socket to listen for new connections
    if(!CreateListenSocket(pConfig))
        goto lDone;
        
    // Start accepting new connections
    hr = _pListenSocket->Accept(this, 0x12345678);
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "_pListenSocket->Accept failed. hr=0x%08x", hr);
        goto lDone;
    }

    fRet = true;
    
lDone:
    
    if(pCompPortInit != NULL)
        pCompPortInit->Release();
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CNet::Term()
{
    InterlockedExchange(&_fShutdown, TRUE);
    
    // Stop receiving connections
    if(_pListenSocket != NULL)
    {
        _lockListenSocket.Lock();
        _pListenSocket->Close();
        _lockListenSocket.Unlock();
    }
    
    // Shut connections down
    ShutdownConnections();
    
    // Wait until there are no more references
    while(_lRef != 0)
        Sleep(1);

    if(_pCompPort != NULL)
    {
        _pCompPort->Shutdown();
    }
    
    _pConfig = NULL;
    
    if(_pListenSocket != NULL)
    {
        _pListenSocket->Release();
        _pListenSocket = NULL;
    }
    
    if(_pCompPort != NULL)
    {
        _pCompPort->Release();
        _pCompPort = NULL;
    }
    
    if(_fSocketInit)
    {
        WSACleanup();
        _fSocketInit = false;
    }
    
    _cliCntTbl.Term();
}

void CNet::ShutdownConnections()
{
    bool fLock=false;
    
    // Create an array with all connections
    
    TArray<CNetCliCnt*,255> cnts;
    
    _lockCliCntTbl.Lock();
    fLock=true;
    
    if(!cnts.SetSize(_cliCntTbl.GetCount()))
        goto lDone;
    
    {
        THashtable<CNetCliCnt*,BYTE>::Iterator it(&_cliCntTbl);
        
        CNetCliCnt* pCnt;
        for(DWORD dwCntNdx=0; dwCntNdx < (DWORD)cnts.GetSize(); dwCntNdx++)
        {
            if(!it.GetNext(&pCnt, NULL))
                goto lDone;
            
            pCnt->AddRef();    
            
            cnts.Set(dwCntNdx, pCnt);    
        }
        
        DBGASSERT(!it.GetNext(NULL,NULL));
    }
    
    _lockCliCntTbl.Unlock();
    fLock=false;
    
    // Now shut them down
    
    for(DWORD dwCntNdx=0; dwCntNdx < (DWORD)cnts.GetSize(); dwCntNdx++)
    {
        CNetCliCnt* pCnt = cnts.Get(dwCntNdx);
        pCnt->Shutdown();
        pCnt->Release();
    }
    
    while(_cliCntTbl.GetCount() > 0)
        Sleep(1);
        
    while(_lOutstandingCntCount > 0)
        Sleep(1);
    
lDone:

    if(fLock)
    {
        DBGASSERT(false);
        _lockCliCntTbl.Unlock();
    }
    
    return;
}

bool CNet::CreateListenSocket(CConfig* pConfig)
{
    bool fRet  = false;
    HRESULT hr;
    
    sockaddr_in sa;
    ZeroMemory(&sa, sizeof(sa));
    
    sa.sin_family  = AF_INET;
    sa.sin_port    = htons((WORD)pConfig->GetNetListenPort());
    sa.sin_addr    = pConfig->GetNetListenAddress();

    hr = CServerSocket::CreateInstance(&_pListenSocket, _pCompPort, 
        _pCompPort);
        
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CServerSocket::CreateInstance failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    hr = _pListenSocket->Init(IPPROTO_TCP, &sa, FALSE);
    
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "_pListenSocket->Init failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    hr = _pListenSocket->Listen(SOMAXCONN);
    
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "_pListenSocket->Listen failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    fRet = true;
    
lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CNet::ReleaseReferenceToConnection(
    CNetCliCnt* pCnt
)
{
    _lockCliCntTbl.Lock();
    
    if(_cliCntTbl.Remove(pCnt, NULL))
    {
        pCnt->Release();
    }
    else
    {
        DBGASSERT(false);
    }
    
    _lockCliCntTbl.Unlock();
    
    return;
}

void CNet::OnSocketAccept(
    CServerSocket *pListenSocket,
    CServerSocket *pAcceptedSocket,
    sockaddr_in *pLocalAddr,
    sockaddr_in *pRemoteAddr,
    HRESULT hr,
    QWORD qwCallbackArg )
{
    bool fRet        = false;
    bool fAccept     = true;
    CNetCliCnt* pCnt = NULL;
    
    if( HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED ) == hr )
    {
        DBGASSERT(_fShutdown);
        fAccept = false;
        fRet    = true;
        goto lDone;
    }
    
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "OnSocketAccept failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    DBGASSERT(pListenSocket   == _pListenSocket);
    DBGASSERT(pAcceptedSocket != NULL);
    DBGASSERT(qwCallbackArg   == 0x12345678);

    if (InterlockedIncrement(&_lOutstandingCntCount) > _lMaxConnections)
    {
        InterlockedDecrement(&_lOutstandingCntCount);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Maximum Connections Exceeded - Max %u", _lMaxConnections);
        goto lDone;
    }
    
    // Get a new connection Id by incrementing the connection id seed
    DWORD dwNewCntId = (DWORD) InterlockedIncrement(
        (volatile LONG*)&_dwCntIdSeed);
    
    // Create a new client connection object
    pCnt = new CNetCliCnt(_pPerfCounters);
    if(NULL == pCnt)
    {
        InterlockedDecrement(&_lOutstandingCntCount);
        goto lDone;
    }
    // Store reference to connection 
    _lockCliCntTbl.Lock();
    if(!_cliCntTbl.Set(pCnt, 0))
    {
        _lockCliCntTbl.Unlock();
        goto lDone;
    }
    pCnt->AddRef();
    _lockCliCntTbl.Unlock();
    
    if(!pCnt->Init(this,_pConfig,_pTimer,pAcceptedSocket,dwNewCntId,_pCallback))
        goto lDone;
        
    pCnt = NULL;
    
    fRet = true;
    
lDone:

    if(pCnt != NULL)
        pCnt->Release();
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
        XomNtEvent(XEVENT_LBS_NETWORK_ERROR, "\n%s", 
            CGlobalError::GetCurrentMessage());
    }
    
    if(fAccept)
    {
        _lockListenSocket.Lock();
        
        if(!_fShutdown)
        {
            hr = _pListenSocket->Accept(this, 0x12345678);
            
            if(FAILED(hr))
            {
                DBGASSERT(false);
                XomNtEvent(XEVENT_LBS_FATAL_ERROR, GLOBAL_ERROR_HEADER
                    "_pListenSocket->Accept failed. Server will fail to "
                    "accept new connections. hr=0x%08x", hr);
            }
        }
        
        _lockListenSocket.Unlock();
    }

    return;
}

/*****************************************************************************
  CNetCliCnt
*****************************************************************************/

CNetCliCnt::CNetCliCnt(CPerfCounters* pPerfCounters)
{
    _fShutdown           = FALSE;
    _pNet                = NULL;
    _pSocket             = NULL;
    _dwCntId             = 0;
    _state               = StateNotInitialized;
    _szClientName[0]     = '\0';
    _dwSizeRcvBuffer     = 0;
    _dwSizeSndBuffer     = 0;
    _dwMaxCSndBuffer     = 0;
    _dwBytesInRcvBuffer  = 0;
    _pRcvBuffer          = NULL;
    _dwBytesInSndBuffer  = 0;
    _pSndBuffer          = NULL;
    _dwSndBuffersCreated = 0;
    _hWait               = NULL;
    _dwHelloTimeout      = 0;
    _pTimer              = NULL;
    _pAppt               = NULL;
    _fTimeout            = false;
    ZeroMemory(&_sinCnt, sizeof(_sinCnt));
    _pRequest            = NULL;
    _pCallback           = NULL;
    _pPerfCounters       = pPerfCounters;

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SafeIncrement32(LBPERF_SERVER_CONNECTION_COUNTER);
    }
    
}

CNetCliCnt::~CNetCliCnt()
{
    DBGASSERT(_fShutdown);
    DBGASSERT(NULL == _pAppt);
    
    if(_pSocket != NULL)
    {
        _pSocket->Release();
        _pSocket = NULL;
    }

    if(_hWait != NULL)
    {
        CloseHandle(_hWait);
        _hWait = NULL;
    }
    
    if(_pRcvBuffer != NULL)
    {
        g_MemAlloc.Free(_pRcvBuffer);
        _pRcvBuffer = NULL;
    }
    
    if(_pSndBuffer != NULL)
    {
        g_MemAlloc.Free((void*)_pSndBuffer);
        _pSndBuffer = NULL;
    }
    
    BYTE* pBuffer;
    while((pBuffer = (BYTE*)_sndBufferCache.Pop()) != NULL)
    {
        g_MemAlloc.Free(pBuffer);
    }
    
    if(_pNet != NULL)
    {
        _pNet->DecrementOutstandingConnectionCount();
        _pNet = NULL;
    }

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SafeDecrement32(LBPERF_SERVER_CONNECTION_COUNTER);
    }
    
}

bool CNetCliCnt::Init(
    CNet*          pNet,
    CConfig*       pConfig,
    CServerTimer*  pTimer,
    CServerSocket* pSocket,
    DWORD          dwCntId,
    INetCallback*  pCallback
)
{
    DBGASSERT(NULL == _pNet);
    DBGASSERT(NULL == _pSocket);
    
    bool fRet = false;
    HRESULT hr;
    
    _fShutdown       = FALSE;
    _pNet            = pNet;
    _pSocket         = pSocket;
    _pSocket->AddRef();
    _dwCntId         = dwCntId;
    _szClientName[0] = '\0';
    _dwSizeRcvBuffer = pConfig->GetSizeRcvBuffer();
    _dwSizeSndBuffer = pConfig->GetSizeSndBuffer();
    _dwMaxCSndBuffer = pConfig->GetMaxCSndBuffer();
    _dwHelloTimeout  = pConfig->GetNetHelloTimeout(); 
    _pTimer          = pTimer;
    _fTimeout        = false;
    _pCallback       = pCallback; 
   
    hr = _pSocket->GetPeerAddress(&_sinCnt);
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "_pSocket->GetPeerAddress failed. hr=0x%08x", hr);
        goto lDone;
    }
    
    _hWait = CreateEventA(NULL, TRUE, FALSE, NULL);
    if(NULL == _hWait)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CreateEventA failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    // Allocate receive buffer
    _dwBytesInRcvBuffer = 0;
    _pRcvBuffer         = (BYTE*) g_MemAlloc.Alloc(_dwSizeRcvBuffer);
    if(NULL == _pRcvBuffer)
        goto lDone;
    
    // Send buffer is allocated on demand
    _dwBytesInSndBuffer  = 0;
    _dwSndBuffersCreated = 0;
    _pSndBuffer          = NULL;
    
    // Listen for the hello message from the client. Setup a timer to time-out
    // if we don't receive the Hello message in a timely fashion. 
    if(!_pTimer->CreateAppointment(this, NULL, _dwHelloTimeout, false, &_pAppt))
    {
        goto lDone;
    }
    
    ::InterlockedExchange(&_state, StateWaitingForHello);
    
    if(!StartReceiving(_dwHelloTimeout))
        goto lDone;
    
    fRet = true;
    
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }
    
    return fRet;
}

void CNetCliCnt::Shutdown()
{
    // Signal shutdown
    if(InterlockedExchange(&_fShutdown, TRUE) == FALSE)
    {
        // Cancel pending socket operations
        if(_pSocket != NULL)
        {
            _lock.Lock();
            _pSocket->Close();
            _lock.Unlock();
        }
            
        // Awake any threads waiting on _hWait
        if(_hWait != NULL)
            SetEvent(_hWait);
            
        if(_pNet != NULL)
            _pNet->ReleaseReferenceToConnection(this);

         // Cancel pending appointments
        if(_pAppt != NULL)
        {
            _pTimer->CancelAppointment(_pAppt);
            _pAppt->Release();
            _pAppt = NULL;
        }
        
        // Release self-reference. As soon as all references are gone, the object
        // will self-destruct
        Release();
    }
}

bool CNetCliCnt::GetPointerToSendBuffer(DWORD dwSize, BYTE** ppBuffer)
{
    DBGASSERT(dwSize <= _dwSizeSndBuffer);
    DBGASSERT(_dwBytesInSndBuffer <= _dwSizeSndBuffer);
    
    bool fRet = false;
    
    if(_fShutdown)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Connection is shutting down.");
        goto lDone;
    }
    
    if(dwSize > _dwSizeSndBuffer)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "dwSize > _dwSizeSndBuffer");
        goto lDone;
    }
    
    if(_pSndBuffer != NULL)
    {
        DWORD dwSpaceAvail = _dwSizeSndBuffer - _dwBytesInSndBuffer;
        if(dwSpaceAvail < dwSize)
        {
            if(!Send())
                goto lDone;
                
            DBGASSERT(NULL == _pSndBuffer);
        }
    }
    
    if(NULL == _pSndBuffer)
    {
        if(!GetSendBuffer())
            goto lDone;
            
        DBGASSERT(_pSndBuffer != NULL);
        DBGASSERT(0 == _dwBytesInSndBuffer);
    }
    
    *ppBuffer = ((BYTE*)_pSndBuffer) + _dwBytesInSndBuffer;
    _dwBytesInSndBuffer += dwSize;
    
    DBGASSERT(_dwBytesInSndBuffer <= _dwSizeSndBuffer);
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;        
}

bool CNetCliCnt::Send()
{
    DBGASSERT(_pSndBuffer != NULL);
    
    bool fRet = false;
    HRESULT hr;
    
    if(_fShutdown)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Connection is shutting down.");
        goto lDone;
    }
    
    _lock.Lock();
    hr = _pSocket->Send((BYTE*)_pSndBuffer, _dwBytesInSndBuffer, this, 0);
    _lock.Unlock();
    
    if(FAILED(hr))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "_pSocket->Send failed. hr = 0x%08x.", hr);
        goto lDone;
    }
    
    _pSndBuffer         = NULL;
    _dwBytesInSndBuffer = 0;
    
    fRet = true;
    
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER"Closing connection.");
        Shutdown();
    }

    return fRet;
}

bool CNetCliCnt::StartReceiving(DWORD dwRcvTimeout)
{
    DBGASSERT(_dwBytesInRcvBuffer < _dwSizeRcvBuffer);
    
    bool fRet = false;
    HRESULT hr;
    
    DWORD dwAvailable = _dwSizeRcvBuffer - _dwBytesInRcvBuffer;
    
    _lock.Lock();
    hr = _pSocket->Receive(_pRcvBuffer+_dwBytesInRcvBuffer, dwAvailable,
        this, 0);
    _lock.Unlock();
        
    if(FAILED(hr))
    {
        if(_fShutdown)
        {
            // Socket was probably closed we're shutting down
            fRet = true;
            goto lDone;
        }
        
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "_pSocket->Receive failed. hr = 0x%08x", hr);
            
        goto lDone;
    }
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CNetCliCnt::GetSendBuffer()
{
    DBGASSERT(_pSndBuffer == NULL);
    
    bool fRet = false;
    
    for(;;)
    {
        // Try to get a buffer from the cache
        _pSndBuffer = (BYTE*) _sndBufferCache.Pop();
    
        if(_pSndBuffer != NULL)
        {
            break;
        }
        else
        {
            // No buffer available. Can we create another one or have we
            // reached maximum send concurrency?
            if(_dwSndBuffersCreated >= _dwMaxCSndBuffer)
            {
                // Prepare to wait
                ResetEvent(_hWait);
                
                // Are you sure? New buffers might have arrived
                // before _hWait was reset.
                _pSndBuffer = (BYTE*) _sndBufferCache.Pop();
                
                if(_pSndBuffer != NULL)
                {
                    break;
                }
                
                // Wait
                if(WaitForSingleObject(_hWait, INFINITE) != WAIT_OBJECT_0)
                {
                    CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                        "WaitForSingleObject failed. Error=%u", GetLastError());
                    goto lDone;
                }
                
                continue;
            }
            else
            {
                DWORD dwSndBuffersCreated = _dwSndBuffersCreated;
                
                if(dwSndBuffersCreated < _dwMaxCSndBuffer 
                   && InterlockedCompareExchange(
                        (volatile LONG*) &_dwSndBuffersCreated, 
                        (LONG)(dwSndBuffersCreated+1), 
                        (LONG)dwSndBuffersCreated) == 
                            (LONG)dwSndBuffersCreated)
                {
                    _pSndBuffer = (BYTE*) g_MemAlloc.Alloc(_dwSizeSndBuffer);
                    if(NULL == _pSndBuffer)
                        goto lDone;
                    
                    break;
                }
                else
                {
                    continue;
                }
            }
        }
    }
    
    DBGASSERT(_pSndBuffer != NULL);
    
    _dwBytesInSndBuffer = 0;
    
    fRet = true;

lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

bool CNetCliCnt::ProcessMessages()
{
    bool fRet = false;
    
    BYTE* pBuffer     = _pRcvBuffer;
    DWORD dwRemaining = _dwBytesInRcvBuffer;
    
    for(;;)
    {
        if(dwRemaining < sizeof(LbsMsgHeader))
            break;
        
        LbsMsgHeader* pHdr = (LbsMsgHeader*) pBuffer;
        
        if(pHdr->wMsgSize > _dwSizeRcvBuffer)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
                "Received message too big. wMsgType = %u, wMsgSize = %u",
                pHdr->wMsgType, pHdr->wMsgSize);
            goto lDone;
        }
        
        if(pHdr->wMsgSize < sizeof(LbsMsgHeader))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Received message too small. wMsgType = %u, wMsgSize = %u",
                pHdr->wMsgType, pHdr->wMsgSize);
            goto lDone;
        }
        
        if(pHdr->wMsgSize > dwRemaining)
            break;
        
        switch(pHdr->wMsgType)
        {
        
        case LbspIdReqHello:
            if(!ProcessReqHello(pHdr))
                goto lDone;
            break;
            
        case LbspIdReqBeginRequest:
            if(!ProcessReqBeginRequest(pHdr))
                goto lDone;
            break;
            
        case LbspIdReqProcCall:
            if(!ProcessReqProcCall(pHdr))
                goto lDone;
            break;
            
        case LbspIdReqPing:
            if(!ProcessReqPing(pHdr))
                goto lDone;
            break;
            
        default:
            
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Received invalid message type. wMsgType = %u, wMsgSize = %u",
                pHdr->wMsgType, pHdr->wMsgSize);
            
            goto lDone;
        };
        
        pBuffer += pHdr->wMsgSize;
        dwRemaining -= pHdr->wMsgSize;
    }
    
    // Compact buffer
    if(dwRemaining > 0)
    {
        MoveMemory(_pRcvBuffer, pBuffer, dwRemaining);
    }
    
    _dwBytesInRcvBuffer = dwRemaining;
     
    fRet = true;
    
lDone:
    
    if(!fRet)
    {   
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "\nCntId = %u"
            "\nClientName = %s",
            _dwCntId,
            _szClientName);
    }
    
    return fRet;
}

bool CNetCliCnt::ProcessReqHello(LbsMsgHeader* pHdr)
{
    bool fRet = false;
    
    if(!CheckState(StateWaitingForHello,0))
        goto lDone;
    
    LbspReqHello* pMsg = (LbspReqHello*) pHdr;
    
    if(pMsg->hdr.wMsgType != LbspIdReqHello
       || pMsg->hdr.wMsgSize < sizeof(LbspReqHello)
       || pMsg->hdr.wMsgSize > sizeof(LbspReqHello) + LbspMaxClientName - 1)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Received invalid LbspReqHello message");
        goto lDone;
    }
    
    // Copy client name from the message. The string is NOT null-
    // terminated
    StringCchCopyNA(_szClientName, ARRAY_SIZE(_szClientName), 
        pMsg->clientName, pMsg->wClientNameLen);
        
    // Send reply to client with the connection id
    LbspRepHello* pRepHello;
    if(!GetPointerToSendBuffer(sizeof(LbspRepHello), (BYTE**)&pRepHello))
        goto lDone;
        
    pRepHello->hdr.wMsgSize = sizeof(LbspRepHello);
    pRepHello->hdr.wMsgType = LbspIdRepHello;
    pRepHello->dwCid        = _dwCntId;
    
    // As soon as we send this we're ready. 
    ::InterlockedExchange(&_state, StateReady);
    
    // Send 
    if(!Send())
        goto lDone;
    
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

bool CNetCliCnt::ProcessReqBeginRequest(LbsMsgHeader* pHdr)
{
    bool fRet = false;
    
    if(!CheckState(StateReady, 0))
        goto lDone;
    
    DBGASSERT(_requestAlloc.GetUsed() == 0);
    DBGASSERT(_pRequest == NULL);
    
    _requestAlloc.Reset();
    
    _pRequest = new (_requestAlloc) CLBSPRequestParser();
    if(NULL == _pRequest)
        goto lDone;
        
    BYTE* pBuffer     = (BYTE*) pHdr;
    DWORD dwRemaining = pHdr->wMsgSize;
    
    if(!_pRequest->ParseBeginRequest(&_requestAlloc, &pBuffer, &dwRemaining))
        goto lDone;
        
    if(dwRemaining != 0)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Message too big. dwRemaining=%u", dwRemaining);
        goto lDone;
    }
    
    ::InterlockedExchange(&_state, StateBuildingRequest);
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

bool CNetCliCnt::ProcessReqProcCall(LbsMsgHeader* pHdr)
{
    bool fRet = false;
    
    if(!CheckState(StateBuildingRequest, 0))
        goto lDone;
    
    DBGASSERT(_pRequest != NULL);
    
    BYTE* pBuffer     = (BYTE*)pHdr;
    DWORD dwRemaining = pHdr->wMsgSize;
    
    if(!_pRequest->ParseProc(&_requestAlloc, &pBuffer, &dwRemaining))
        goto lDone;

    if(_pRequest->IsRequestReady())
    {
        // AddRef this object on behalf of the request handler. It will be 
        // released once ReplyDone is called.
        AddRef();
        
        ::InterlockedExchange(&_state, StateProcessingRequest);
        
        if(!_pCallback->OnNewRequest((CLBSPRequest*)_pRequest, this))
        {
            // Failed. ReplyDone will never get called. 
            Release();
            
            goto lDone;
        }
    }
        
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// Process the LbspReqPing message. Just replies with a LbspRepPing.
bool CNetCliCnt::ProcessReqPing(LbsMsgHeader* pHdr)
{
    bool fRet = false;
    
    // Ping can only be sent when the connection is in 'ready' state. No 
    // pinging while we're in the middle of processing a request.
    if(!CheckState(StateReady, 0))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Received LbspIdReqPing (%u) message when _state = %u",
            LbspIdReqPing, _state);
        goto lDone;
    }
    
    LbspReqPing* pMsg = (LbspReqPing*) pHdr;
    
    if(pMsg->hdr.wMsgType != LbspIdReqPing
       || pMsg->hdr.wMsgSize != sizeof(LbspReqPing))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Received invalid LbspReqPing message");
        goto lDone;
    }
    
    // Send reply to client 
    LbspRepPing* pRep;
    if(!GetPointerToSendBuffer(sizeof(LbspRepPing), (BYTE**)&pRep))
        goto lDone;
        
    pRep->hdr.wMsgSize = sizeof(LbspRepPing);
    pRep->hdr.wMsgType = LbspIdRepPing;
    pRep->dwPing       = pMsg->dwPing;
    
    // Send 
    if(!Send())
        goto lDone;
    
    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CNetCliCnt::OnSocketReceive(
    BYTE *pbFilledInBuffer,
    DWORD cbRead,
    HRESULT hr,
    QWORD qwCallbackArg 
)
{
    bool fRet = false;
    
    if(hr != S_OK)
    {
        if( HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED ) == hr )
        {
            if(_fTimeout)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "Server did not receive Hello message from Client in "
                    "the configured timeout interval(%u). Disconnecting.", _dwHelloTimeout);
            }
            else if(_fShutdown)
            {
                // We're already shutting down. Let's not log any more errors.
                fRet = true;
            }
            goto lDone;
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Receive operation failed with hr=0x%08x (error=%u)",
                hr, HRESULT_CODE(hr));
            goto lDone;
        }
    }

    if(cbRead > 0)
    {
        // Bytes have been read. Register that.
        _dwBytesInRcvBuffer += cbRead;
        
        if(_dwBytesInRcvBuffer > _dwSizeRcvBuffer)
        {
            DBGASSERT(false);
            goto lDone;
        }
        
        // Process
        if(!ProcessMessages())
            goto lDone;
        
        DBGASSERT(_dwBytesInRcvBuffer < _dwSizeRcvBuffer);
        
        if(!StartReceiving(0))
            goto lDone;
    }
    else
    {
        // Client disconnected gracefully. Let's do the same.
        Shutdown();
    }
    
    fRet = true;

lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "ClientId:%u\n"
            "ClientAddress:"DBGSINFMT,
            _dwCntId,
            DBGSINPRM(&_sinCnt));
        
        XomNtEvent(XEVENT_LBS_NETWORK_ERROR_1, "\n%s", 
            CGlobalError::GetCurrentMessage());
        
        Shutdown();
    }
    
    return;
}

void CNetCliCnt::OnSocketSend(
    BYTE *pbBufferSent,
    DWORD cbToSend,
    DWORD cbSent,
    HRESULT hr,
    QWORD qwCallbackArg )
{
    DBGASSERT(pbBufferSent != NULL);
    
    bool fRet = false;
    
    // Put buffer back on the cache
    CSingleLink* pBuffer = new (pbBufferSent) CSingleLink();
    if(!_sndBufferCache.Push(pBuffer))
        goto lDone;
        
    // Wake up thread that might be waiting for the buffer
    SetEvent(_hWait);
        
    if(FAILED(hr))
    {
        if(HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) == hr 
           && _fShutdown)
        {
            fRet = true;
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Send operation failed. hr=0x%08x", hr);
        }
        goto lDone;
    }
    
    if(cbSent != cbToSend)
    {
        DBGASSERT(false);
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "cbSent(%d) < cbToSend(%d)", cbSent, cbToSend);
        goto lDone;
    }

    fRet = true;
    
lDone:

    if(!fRet)
        Shutdown();

    return;
}

void CNetCliCnt::OnTimer(void* pParam)
{
    if(StateWaitingForHello == _state)
    {
        _fTimeout = true;
        Shutdown();
    }
}

bool CNetCliCnt::RowsetBegin()
{
    bool fRet = false;
    
    if(!CheckState(StateProcessingRequest, 0))
        goto lDone;
    
    DBGASSERT(_pRequest != NULL);
    
    LbspRepRowsetStart* pRowsetStart;
    if(!GetPointerToSendBuffer(sizeof(LbspRepRowsetStart), (BYTE**)&pRowsetStart))
        goto lDone;
        
    pRowsetStart->hdr.wMsgSize = sizeof(LbspRepRowsetStart);
    pRowsetStart->hdr.wMsgType = LbspIdRepRowsetStart;
        
    ::InterlockedExchange(&_state, StateSendingRowset);
    
    fRet = true;
    
lDone:
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        Shutdown();
    }

    return fRet;
}

bool CNetCliCnt::RowsetRow(
    LbStat* rgColumns, 
    DWORD cColumns
)
{
    bool fRet = false;
    
    if(!CheckState(StateSendingRowset, 0))
        goto lDone;
    
    DBGASSERT(_pRequest != NULL);
    
    DWORD dwMsgSize = sizeof(LbspRepRowsetRow);
    for(DWORD i=0; i < cColumns; i++)
    {
        dwMsgSize += sizeof(BYTE);
        
        if(rgColumns[i].bType & LbspTypeIdNullFlag)
            continue;
        
        switch(rgColumns[i].bType)
        {
        case LbspTypeIdInt8:
            dwMsgSize += sizeof(INT8);
            break;
        
        case LbspTypeIdInt16:
            dwMsgSize += sizeof(INT16);
            break;
        
        case LbspTypeIdInt32:
            dwMsgSize += sizeof(INT32);
            break;
        
        case LbspTypeIdInt64:
            dwMsgSize += sizeof(INT64);
            break;
        
        case LbspTypeIdDouble:
            dwMsgSize += sizeof(double);
            break;
            
        case LbspTypeIdString:
            DBGASSERT(rgColumns[i].str.wStrLen < LbspMaxSizeStringParam);
            dwMsgSize += sizeof(WORD) + rgColumns[i].str.wStrLen;
            break;
        
        default:
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Invalid column type %u", (DWORD) rgColumns[i].bType);
            goto lDone;
        }
    }

    BYTE* pBuffer;
    DWORD dwRemaining = dwMsgSize;    
    if(!GetPointerToSendBuffer(dwMsgSize, &pBuffer))
        goto lDone;
        
    LbspRepRowsetRow* pRow = (LbspRepRowsetRow*) pBuffer;
    pRow->hdr.wMsgSize = (WORD)dwMsgSize;
    pRow->hdr.wMsgType = LbspIdRepRowsetRow;
    pRow->wColCount    = (WORD)cColumns;
    
    pBuffer += sizeof(LbspRepRowsetRow);
    dwRemaining -= sizeof(LbspRepRowsetRow);
    
    for(DWORD i=0; i < cColumns; i++)
    {
        LbspColumnData* pColumn = (LbspColumnData*) pBuffer;
     
        pColumn->bType = rgColumns[i].bType;
        
        pBuffer     += sizeof(BYTE);
        dwRemaining -= sizeof(BYTE);
        
        if(rgColumns[i].bType & LbspTypeIdNullFlag)
        {
            continue;
        }
        
        switch(rgColumns[i].bType)
        {
        case LbspTypeIdInt8:
            pColumn->i8  = rgColumns[i].i8;
            pBuffer     += sizeof(INT8);
            dwRemaining -= sizeof(INT8);
            break;
        
        case LbspTypeIdInt16:
            pColumn->i16  = rgColumns[i].i16;
            pBuffer     += sizeof(INT16);
            dwRemaining -= sizeof(INT16);
            break;
        
        case LbspTypeIdInt32:
            pColumn->i32  = rgColumns[i].i32;
            pBuffer     += sizeof(INT32);
            dwRemaining -= sizeof(INT32);
            break;
        
        case LbspTypeIdInt64:
            pColumn->i64  = rgColumns[i].i64;
            pBuffer     += sizeof(INT64);
            dwRemaining -= sizeof(INT64);
            break;
        
        case LbspTypeIdDouble:
            pColumn->d   = rgColumns[i].d;
            pBuffer     += sizeof(double);
            dwRemaining -= sizeof(double);
            break;
            
        case LbspTypeIdString:
            pColumn->str.wStrLen = rgColumns[i].str.wStrLen;
            CopyMemory(pColumn->str.str, rgColumns[i].str.pstr, 
                rgColumns[i].str.wStrLen);
            pBuffer     += sizeof(WORD) + rgColumns[i].str.wStrLen;
            dwRemaining -= sizeof(WORD) + rgColumns[i].str.wStrLen;
            break;
        
        default:
            __assume(0);
        }
    }
    
    DBGASSERT(dwRemaining == 0);
    
    fRet = true;
    
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        Shutdown();
    }
        
    return fRet;
}

bool CNetCliCnt::RowsetEnd()
{
    bool fRet = false;
    
    if(!CheckState(StateSendingRowset, 0))
        goto lDone;
    
    DBGASSERT(_pRequest != NULL);
    
    LbspRepRowsetEnd* pRowsetEnd;
    if(!GetPointerToSendBuffer(sizeof(LbspRepRowsetEnd), (BYTE**)&pRowsetEnd))
        goto lDone;
        
    pRowsetEnd->hdr.wMsgSize = sizeof(LbspRepRowsetEnd);
    pRowsetEnd->hdr.wMsgType = LbspIdRepRowsetEnd;
        
    ::InterlockedExchange(&_state, StateProcessingRequest);
    
    fRet = true;
    
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        Shutdown();
    }

    return fRet;
}

bool CNetCliCnt::ReplyMessage(
    DWORD dwErrorId, 
    LPCSTR pszMessage
)
{
    bool fRet = false;
    HRESULT hr;
    
    // Close pending rowsets
    if(StateSendingRowset == _state)
    {
        if(!RowsetEnd())
            goto lDone;
    }
    
    if(!CheckState(StateProcessingRequest, 0))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ReplyMessage was called when _state (%u) != "
            "StateProcessingRequest (%u)", (DWORD)_state, 
            (DWORD)StateProcessingRequest);
        goto lDone;
    }
    
    DBGASSERT(_pRequest != NULL);

    size_t stStrLen;
    if(FAILED(hr = StringCchLengthA(pszMessage, LbspMaxSizeMessage, &stStrLen)))
    {
        if(FAILED(hr = StringCchLengthA(pszMessage, STRSAFE_MAX_CCH, &stStrLen)))
        {
            //there were really a problem
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "StringCchLengthA failed. hr =0x%08x", hr);
            goto lDone;
        }
        else
        {
            //pszMessage was just too long - truncate
            stStrLen = LbspMaxSizeMessage;
        }
    }
    
    DWORD dwMsgSize = sizeof(LbspRepMessage) - 1 + stStrLen;
    
    LbspRepMessage* pRep;
    if(!GetPointerToSendBuffer(dwMsgSize, (BYTE**) &pRep))
        goto lDone;
        
    pRep->hdr.wMsgSize = (WORD) dwMsgSize;
    pRep->hdr.wMsgType = LbspIdRepMessage;
    pRep->dwErrorId    = dwErrorId;
    pRep->wMsgLen      = (WORD) stStrLen;
    CopyMemory(pRep->message, pszMessage, stStrLen);
    
    if(dwErrorId != 0)
    {
        // Error messages must be sent immediatelly
        if(!Send())
            goto lDone;
    }
    
    fRet = true;
    
lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        Shutdown();
    }
    
    return fRet;
}

bool CNetCliCnt::ReplyDone()
{
    bool fRet = false;
    
    if(!CheckState(StateProcessingRequest,StateSendingRowset))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "ReplyDone was called when _state (%u) != "
            "StateProcessingRequest (%u)", (DWORD)_state, 
            (DWORD)StateProcessingRequest);
        goto lDone;
    }
    
    // If we were in the middle of sending a rowset, close it first
    if(StateSendingRowset == _state)
    {
        if(!RowsetEnd())
        {
            goto lDone;
        }
    }
    
    DBGASSERT(_pRequest != NULL);
    
    LbspRepEndRequest* pRep;
    
    if(!GetPointerToSendBuffer(sizeof(LbspRepEndRequest), (BYTE**) &pRep))
        goto lDone;
    
    pRep->hdr.wMsgSize = sizeof(LbspRepEndRequest);
    pRep->hdr.wMsgType = LbspIdRepEndRequest;
    pRep->dwReqId      = _pRequest->GetReqId();
    
    _requestAlloc.Reset();
    _pRequest = NULL;
    
    if(!Send())
        goto lDone;

    ::InterlockedExchange(&_state, StateReady);
    
    fRet = true;
      
lDone:
    
    if(!fRet)
    {
        Shutdown();
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    // Release reference acquired on ProcessReqProcCall
    Release();    

    return fRet;
}

// Wait until we reach state1 or state2 or until we timeout
bool CNetCliCnt::WaitForState(
    LONG state1,
    LONG state2
)
{
    const int timeout = 2000;
    
    DWORD started = ::GetTickCount();
    
    int spinbase = 2000;
    int spin     = spinbase;
    while(_state != state1 && _state != state2)
    {
        if(--spin == 0)
        {
            if(GetTickCount() - started >= timeout)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "WaitForStates(%u, %u) timed out. Current state=%u",
                    state1, state2, _state);
                return false;
            }
            
            if(!SwitchToThread())
            {
                ::Sleep(1);
            }
                
            spin = spinbase;
            spinbase--; // Backoff
        }
    }
    
    return true;
}

/*****************************************************************************
  CLBSPRequest
*****************************************************************************/

void CLBSPRequest::Dump(CStr* pStr)
{
    pStr->Format(
        "\n_dwReqId:    %u"
        "\n_wProcCount: %u"
        "\n"
        "\nProcedures:",
        _dwReqId,
        _wProcCount);

    for(int iProc=0; iProc < _procs.GetSize(); iProc++)
    {
        CLBSPProcedure* pProc = _procs.Get(iProc);
        
        pStr->Format(
            "\n"
            "\n  %3d: _dwProcId: 0x%x _wParamCount: %u",
            iProc,
            pProc->GetProcId(),
            pProc->GetParamCount());
            
        for(int iParam=0; iParam < pProc->GetParamCount(); iParam++)
        {
            CLBSPParam* pParam;
            
            if(!pProc->GetParam(iParam, &pParam))
            {
                DBGASSERT(false);
                break;
            }
            
            if(pParam->IsNull())
            {
                pStr->Format("\n    %3d: (null)", iParam);
            }
            
            switch(pParam->GetType())
            {
            case LbspTypeIdInt8:
            {
                INT8 i8;
                
                if(!pParam->GetInt8(&i8))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %d", 
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    (int)i8);
                    
                break;
            }
            
            case LbspTypeIdInt16:
            {
                INT16 i16;
                
                if(!pParam->GetInt16(&i16))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %d", 
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    (int)i16);
                    
                break;
            }
            
            case LbspTypeIdInt32:
            {
                INT32 i32;
                
                if(!pParam->GetInt32(&i32))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %d", 
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    (int)i32);
                    
                break;
            }
            
            case LbspTypeIdInt64:
            {
                INT64 i64;
                
                if(!pParam->GetInt64(&i64))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %I64d", 
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    i64);
                    
                break;
            }
                
            case LbspTypeIdDouble:
            {
                double d;
                
                if(!pParam->GetDouble(&d))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %f",
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    d);
                    
                break;
            }
            
            case LbspTypeIdString:
            {
                CConstStr str;
                
                if(!pParam->GetString(&str))
                {
                    DBGASSERT(false);
                    goto lDone;
                }
                
                pStr->Format("\n    %3d: (%u) %s",
                    iParam, 
                    (DWORD) pParam->GetType(), 
                    str.cstr());
                    
                break;
            }
            
            default:
                DBGASSERT(false);
                goto lDone;
            }
        }
    }
    
lDone:

    return;
}

/*****************************************************************************
  CLBSPParamParser
*****************************************************************************/

bool CLBSPParamParser::Parse(
    CArenaMemAlloc* pAlloc, 
    BYTE** ppBuffer, 
    DWORD* pdwRemaining
)
{
    bool fRet = false;
    
    LbspProcParam* pParam = (LbspProcParam*) *ppBuffer;
    DWORD dwRemaining       = *pdwRemaining;
    DWORD dwSize            = 0;

    if(dwRemaining < sizeof(BYTE)) 
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough bytes remaining (%u) in message to parse "
            "parameter", dwRemaining);
        goto lDone;
    }
    
    this->bType = pParam->bParamType;
    
    if(this->IsNull())
    {
        *ppBuffer     += sizeof(BYTE);
        *pdwRemaining  = dwRemaining - sizeof(BYTE);
        return true;
    }
    
    switch(pParam->bParamType)
    {
    case LbspTypeIdInt8:
        if(dwRemaining < sizeof(INT8)) break;
        this->i8 = pParam->i8Param;
        dwSize = sizeof(INT8); 
        break;
                       
    case LbspTypeIdInt16:
        if(dwRemaining < sizeof(INT16)) break;
        this->i16 = pParam->i16Param;
        dwSize = sizeof(INT16); 
        break;
        
    case LbspTypeIdInt32:
        if(dwRemaining < sizeof(INT32)) break;
        this->i32 = pParam->i32Param;
        dwSize = sizeof(INT32); 
        break;
        
    case LbspTypeIdInt64:
        if(dwRemaining < sizeof(INT64)) break;
        this->i64 = pParam->i64Param;
        dwSize = sizeof(INT64); 
        break;
        
    case LbspTypeIdDouble:
        if(dwRemaining < sizeof(double)) break;
        this->d = pParam->dParam;
        dwSize = sizeof(double); 
        break;
        
    case LbspTypeIdString:
    {
        if(dwRemaining < sizeof(WORD)) break;
        WORD wStrSize = pParam->strParam.wStrLen;
        if(dwRemaining < sizeof(WORD)+wStrSize) break;
        
        if(wStrSize > LbspMaxSizeStringParam)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Size (%u) of string parameter is greater than "
                "maximum allowed (%u)", (DWORD)wStrSize, 
                LbspMaxSizeStringParam);
            goto lDone;
        }
        
        this->str.wStrLen = wStrSize;
        this->str.pstr    = (CHAR*) pAlloc->Alloc(wStrSize+1);
        if(NULL == this->str.pstr)
            goto lDone;
        
        CopyMemory(this->str.pstr, pParam->strParam.str, wStrSize);
        this->str.pstr[wStrSize] = '\0';
        
        dwSize = wStrSize + sizeof(WORD);
        break;
    }
    
    default:
        
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Invalid parameter type %u", (DWORD)this->bType);
        goto lDone;
    }
    
    
    if(0 == dwSize)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough bytes remaining (%u) in message to parse "
            "parameter type %u", dwRemaining, (DWORD) pParam->bParamType);
        goto lDone;
    }
    
    DBGASSERT(dwSize < dwRemaining);
    
    *ppBuffer     += sizeof(BYTE) + dwSize;
    *pdwRemaining = dwRemaining - sizeof(BYTE) - dwSize;
    
    fRet = true;
    
lDone:
    
    return fRet;
}

/*****************************************************************************
  CLBSPProcedureParser
*****************************************************************************/
    
bool CLBSPProcedureParser::Parse(CArenaMemAlloc* pAlloc, BYTE** ppBuffer, DWORD* pdwRemaining)
{
    bool fRet = false;
    
    DWORD dwRemaining = *pdwRemaining;
    
    if(dwRemaining < sizeof(LbspReqProcCall))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough bytes remaining (%u) in message to parse "
            "Procedure", dwRemaining);
        goto lDone;
    }
    
    LbspReqProcCall* pProc = (LbspReqProcCall*) *ppBuffer;
    
    _dwProcId    = pProc->dwProcId;
    _wParamCount = pProc->wParamCount;
    
    if(_wParamCount > LbspMaxProcParamCount)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Number of parameters (%u) in procedure exceeds maximum (%u)",
            _wParamCount, LbspMaxProcParamCount);
        goto lDone;
    }
    
    *ppBuffer     += sizeof(LbspReqProcCall);
    *pdwRemaining -= sizeof(LbspReqProcCall);
    
    if(!_params.SetAllocator(pAlloc))
        goto lDone;
        
    if(!_params.SetSize(_wParamCount))
        goto lDone;
    
    for(int i=0; i < _params.GetSize(); i++)
        _params.Set(i, NULL);
        
    for(int i=0; i < _params.GetSize(); i++)
    {
        CLBSPParamParser* pParam = new (*pAlloc) CLBSPParamParser();
        if(NULL == pParam)
            goto lDone;
        
        if(!pParam->Parse(pAlloc,ppBuffer,pdwRemaining))
            goto lDone;
            
        _params.Set(i, pParam);
    }
    
    fRet = true;
    
lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

/*****************************************************************************
  CLBSPRequestParser
*****************************************************************************/

bool CLBSPRequestParser::ParseBeginRequest(
    CArenaMemAlloc* pAlloc, 
    BYTE** ppBuffer, 
    DWORD* pdwRemaining
)
{
    bool fRet = false;
    
    DWORD dwRemaining = *pdwRemaining;
    
    if(dwRemaining < sizeof(LbspReqBeginRequest))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Not enough bytes remaining (%u) in message to parse "
            "Request header", dwRemaining);
        goto lDone;
    }
    
    LbspReqBeginRequest* pBeginReq = (LbspReqBeginRequest*) *ppBuffer;
    
    _dwReqId    = pBeginReq->dwReqId;
    
    if(0 == _dwReqId)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "_dwReqId cannot be zero");
        goto lDone;
    }
    
    _wProcCount = pBeginReq->wProcCount;
    
    if(_wProcCount > LbspMaxProcCount)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Number of procedures (%u) in request exceeds maximum (%u)",
            _wProcCount, LbspMaxProcCount);
        goto lDone;
    }
    
    *ppBuffer     += sizeof(LbspReqBeginRequest);
    *pdwRemaining -= sizeof(LbspReqBeginRequest);
    
    if(!_procs.SetAllocator(pAlloc))
        goto lDone;
    
    // Grow array
    if(!_procs.Grow(_wProcCount))
        goto lDone;
        
    _procs.SetSize(0);
    
    fRet = true;
    
lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

bool CLBSPRequestParser::ParseProc(CArenaMemAlloc* pAlloc, BYTE** ppBuffer, DWORD* pdwRemaining)
{
    bool fRet = false;
    
    if(_procs.GetSize() == _wProcCount)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Number of procedures in request exceeds the number specified "
            "in LbspReqBeginRequest(%u).", (DWORD)_wProcCount);
        goto lDone;
    }
    
    CLBSPProcedureParser* pProc = new (*pAlloc) CLBSPProcedureParser();
    if(NULL == pProc)
        goto lDone;
    
    if(!pProc->Parse(pAlloc,ppBuffer,pdwRemaining))
        goto lDone;
        
    if(!_procs.Add(pProc))
        goto lDone;
        
    fRet = true;
        
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\perfctrsLb.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved
#include "xmgmt.h"
#include "xeventids.h"
#include "svrspec.h"

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

enum LBPC_TYPES
{
    LBPC_DWORD = 1,
    LBPC_QWORD = 2,
    LBPC_OBJECT
};

struct PERFCOUNTER
{
    LBPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    DWORD dwObjectIndex;
    LONG lDataScale;
    DWORD dwDataOffset;
};

struct PERFINSTANCE
{
    DWORD dwInstanceID;
    BYTE *pbDataStart;
};

struct PERFOBJECT
{
    DWORD dwPerfIndex;
    HANDLE hPerfObject;
    BYTE *pbPerfCtrDataStart;
};

#define DWORD_AVERAGE( INDEX ) \
{ LBPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, 0, 0, 0 }

#define DWORD_BASE( INDEX ) \
{ LBPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, 0, 0, 0 }

#define DWORD_COUNTER( INDEX ) \
{ LBPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, 0, 0, 0 }

#define DWORD_RATE( INDEX ) \
{ LBPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, 0, 0, 0 }

#define QWORD_AVERAGE( INDEX ) \
{ LBPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, 0, 0, 0 }

#define QWORD_COUNTER( INDEX ) \
{ LBPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, 0, 0, 0 }

#define QWORD_RATE( INDEX ) \
{ LBPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, 0, 0, 0 }

#define OBJECT( INDEX ) \
    { LBPC_OBJECT, 0, 0, 0, 0, 0 }

#ifndef PERFCTRS_H_INCLUDED
#define PERFCTRS_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000



//////////////////////////////////////////////////////////////////////////////
class CPerfCounters
{
public:

    
    CPerfCounters();

    ~CPerfCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32(DWORD dwCounterID);
    DWORD GetCurrentValue32(DWORD dwCounterID, PERFINSTANCE *pInstance );

    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal);
    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal, PERFINSTANCE *pInstance );

    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount);
    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance );

    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount);
    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance );

    void SafeIncrement32(DWORD dwCounterID);
    void SafeIncrement32(DWORD dwCounterID, PERFINSTANCE *pInstance );

    void SafeDecrement32(DWORD dwCounterID);
    void SafeDecrement32(DWORD dwCounterID, PERFINSTANCE *pInstance );

    void TrackSuccessfulMessage(DWORD dwServerCounterID);

    void TrackFailureMessage(DWORD dwServerCounterID);

    DWORD CreateInstance(PWCHAR pszName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart);

    BOOL DeleteInstance(DWORD dwInstanceID);


    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64(DWORD dwCounterID);
    QWORD GetCurrentValue64(DWORD dwCounterID, PERFINSTANCE *pInstance );

    void SetCurrentValue64(DWORD dwCounterID, QWORD qwVal);
    void SetCurrentValue64(DWORD dwCounterID, QWORD qwVal, PERFINSTANCE *pInstance );

    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount);
    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance );

    void DecrementValue64(DWORD dwCounterID, QWORD qwAmount);
    void DecrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance );

};

extern CPerfCounters g_Counters;


#endif  // PERFCTRS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\perfctrslb.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved
#include "lbs.h"

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs [] =
{
#include "lbsvrperf.cpp"
};

//////////////////////////////////////////////////////////////////////////////
PERFOBJECT s_LBServerPerfObjects[] =
{
    { LBPERF_SERVER_OBJECT, NULL, NULL },
    { LBPERF_SERVER_INSTANCES_OBJECT, NULL, NULL }
};

#define NUM_SERVER_PERF_COUNTERS (ARRAY_ELEMENTS(s_ServerPerfCtrs))

//////////////////////////////////////////////////////////////////////////////
CPerfCounters::CPerfCounters()
{
}

//////////////////////////////////////////////////////////////////////////////
CPerfCounters::~CPerfCounters()
{
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CPerfCounters::Init()
{
    BYTE *pbServCtrsStart = NULL;

    // Create the server perf objects.  To find the objects, we go through the counters array and
    // pick out the ones that happen to be objects.  Hackalacka.
    DWORD dwObj = 0;
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType == LBPC_OBJECT)
        {
            s_LBServerPerfObjects[dwObj].hPerfObject = CreatePerfObject(
                s_LBServerPerfObjects[dwObj].dwPerfIndex,
                0,
                (void **)&s_LBServerPerfObjects[dwObj].pbPerfCtrDataStart);
            
            if( NULL == s_LBServerPerfObjects[dwObj].hPerfObject )
            {
                XomNtEvent(XEVENT_STATS_CONFIG_25, "Error creating perf counter object.  Attempting to delete stale perf objects to recover.");
                
                DestroyAllPerfObjects();
                
                // try again.
               s_LBServerPerfObjects[dwObj].hPerfObject = CreatePerfObject(
                    s_LBServerPerfObjects[dwObj].dwPerfIndex,
                    0,
                    (void **)&s_LBServerPerfObjects[dwObj].pbPerfCtrDataStart);

                if (NULL == s_LBServerPerfObjects[dwObj].hPerfObject)
                {
                    // give up.
                    return E_UNEXPECTED;
                }        
            }
            dwObj++;
        }
    }

    // Now create all the counters
    dwObj = 0;
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType == LBPC_OBJECT)
        {
            // not a counter
            dwObj++;
            continue;
        }
        
        s_ServerPerfCtrs[dwCtr].dwObjectIndex = dwObj - 1;
        s_ServerPerfCtrs[dwCtr].dwDataOffset = CreatePerfCounter(
            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
            s_ServerPerfCtrs[ dwCtr ].lDataScale,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
            s_LBServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].hPerfObject,
            s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
            NULL );
        
        XOMASSERT( 0xffffffff != s_ServerPerfCtrs[dwCtr].dwDataOffset );

        // Zero every counter on startup
        ZeroMemory(
            s_LBServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].pbPerfCtrDataStart + s_ServerPerfCtrs[ dwCtr ].dwDataOffset,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CPerfCounters::CreateInstance(PWCHAR pszName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart)
{
    // TODOTHEOM: make this prettier... it may be ok for this class to "know" which object has instances,
    // but knowing the index is super-hacky.
    HANDLE hObject = s_LBServerPerfObjects[1].hPerfObject;
    return(CreateObjectInstance( hObject, pszName, ppvInstanceName, ppvInstanceStart ) );
}


//////////////////////////////////////////////////////////////////////////////
BOOL CPerfCounters::DeleteInstance(DWORD dwInstanceID)
{
    // TODOTHEOM: make this prettier... it may be ok for this class to "know" which object has instances,
    // but knowing the index is super-hacky.
    HANDLE hObject = s_LBServerPerfObjects[1].hPerfObject;
    return(DestroyObjectInstance( hObject, dwInstanceID ) );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CPerfCounters::GetCurrentValue32(DWORD dwCounterID)
{
    return GetCurrentValue32(dwCounterID, NULL);
}


//////////////////////////////////////////////////////////////////////////////
DWORD CPerfCounters::GetCurrentValue32(DWORD dwCounterID, PERFINSTANCE *pInstance )
{
    
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    return( *(DWORD *) pbDataStart );
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal)
{
    return SetCurrentValue32(dwCounterID, dwVal, NULL);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    // No need for thread safety
    //InterlockedExchange(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwVal );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    *(DWORD *) pbDataStart = dwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    return IncrementValue32(dwCounterID, dwAmount, NULL);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwAmount );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    *(DWORD *) pbDataStart += dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    return DecrementValue32(dwCounterID, dwAmount, NULL);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance )
{

    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    - (LONG) dwAmount );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    *(DWORD *) pbDataStart -= dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SafeIncrement32(DWORD dwCounterID)
{
    return SafeIncrement32(dwCounterID, NULL);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SafeIncrement32(DWORD dwCounterID, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    InterlockedIncrement((LONG *) pbDataStart);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SafeDecrement32(DWORD dwCounterID)
{
    return SafeDecrement32(dwCounterID, NULL);
}


//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SafeDecrement32(DWORD dwCounterID, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    InterlockedDecrement((LONG *) pbDataStart);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::TrackSuccessfulMessage(DWORD dwServerCounterID)
{
    // Increment the specific counter
    IncrementValue32(dwServerCounterID, 1);
    
    // Assume a rate counter after the count counter
    IncrementValue32(dwServerCounterID + 2, 1);

    // Increment the total counter
    IncrementValue32(LBPERF_SERVER_TOTAL_MSGS_COUNTER, 1);
    
    IncrementValue32(LBPERF_SERVER_TOTAL_MSGS_RATE, 1);
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::TrackFailureMessage(DWORD dwServerCounterID)
{
    // Increment the total failure counter
    IncrementValue32( LBPERF_SERVER_FAILED_MSGS_COUNTER, 1 );
    
    IncrementValue32( LBPERF_SERVER_FAILED_MSGS_RATE, 1 );   
}

//////////////////////////////////////////////////////////////////////////////
QWORD CPerfCounters::GetCurrentValue64(DWORD dwCounterID)
{
    return GetCurrentValue64(dwCounterID, NULL);
}


//////////////////////////////////////////////////////////////////////////////
QWORD CPerfCounters::GetCurrentValue64(DWORD dwCounterID, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    return( *(QWORD *) pbDataStart );
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SetCurrentValue64(DWORD dwCounterID, QWORD qwVal)
{
    return SetCurrentValue64(dwCounterID, qwVal, NULL);
}


//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::SetCurrentValue64(DWORD dwCounterID, QWORD qwVal, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    *(QWORD *) pbDataStart = qwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    IncrementValue64(dwCounterID, qwAmount, NULL);
}


//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;

    *(QWORD *) pbDataStart += qwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::DecrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    return DecrementValue64(dwCounterID, qwAmount, NULL);
}


//////////////////////////////////////////////////////////////////////////////
void CPerfCounters::DecrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( LBPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_LBServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    pbDataStart = pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset;
    
    *(QWORD *) pbDataStart -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\net.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * net.h
 * Header of leaderboard server network component 
 * Source: net.cpp
 * 
 */

#pragma once

// LBSP Constants
const DWORD LbspMaxClientName 	   = 32;
const DWORD LbspMaxProcCount       = 1000;
const DWORD LbspMaxProcParamCount  = 1000;
const DWORD LbspMaxSizeStringParam = 1024;
const DWORD LbspMaxSizeMessage     = 1024;
const DWORD LbspMaxRowsetColumns   = 1000;

// Low-level LBSP Message Ids
const WORD  LbspIdReqHello         = 1;
const WORD  LbspIdRepHello         = 2;
const WORD  LbspIdReqBeginRequest  = 3;
const WORD  LbspIdReqProcCall      = 5;
const WORD  LbspIdRepRowsetStart   = 8;
const WORD  LbspIdRepRowsetRow     = 9;
const WORD  LbspIdRepRowsetEnd     = 11;
const WORD  LbspIdRepMessage       = 12;
const WORD  LbspIdRepEndRequest    = 13;
const WORD  LbspIdReqPing          = 14;
const WORD  LbspIdRepPing          = 15;

// Errors
const DWORD LbspErrorInvalidProcId   = 0x00000001;
const DWORD LbspErrorLbWrongServer   = 0x00000002;
const DWORD LbspErrorLbDoesntExist   = 0x00000003;
const DWORD LbspErrorInvalidParam    = 0x00000004;
const DWORD LbspErrorFailureOccurred = 0xFFFFFFFE;
const DWORD LbspErrorUnexpected      = 0xFFFFFFFF;

const DWORD LbspErrorOperationNotPermitted = 0xF0000001;

//
// Low level LBSP messages
//

#pragma pack(push, 1)

// LbsMsgHeader
// All LBSP messages start with this header
struct LbsMsgHeader
{
    // Size of the message in bytes including header
    WORD wMsgSize;
    
    // Message type. One of the LbspId* constants
    WORD wMsgType;
};

// LbspReqHello
// Sent by the client upon establishing a connection
struct LbspReqHello
{
	// hdr.wMsgType = LbspIdReqHello
    LbsMsgHeader hdr;

	// Size in bytes of clientName. Maximum size is LbspMaxClientName
    WORD wClientNameLen;
    
    // Client name. ANSI string. Not null terminated
	CHAR clientName[1];
};

// LbspRepHello
// Sent by the server in response to a LbspReqHello
struct LbspRepHello
{
	//hdr.wMsgType = LbspIdRepHello;
	LbsMsgHeader hdr;
	
    // Connection id assigned by the Leaderboard Server. The client should 
    // include the connection id on its error messages and logs.  
	DWORD dwCid;
};

// LbspReqBeginRequest
// Sent by the client to start a request
struct LbspReqBeginRequest
{
    // hdr.wMsgType = LbspIdReqBeginRequest
    LbsMsgHeader hdr;
    
    // This is an arbitrary id assigned by the client. It will be used by
    // the server in error messages. It has no other purpose.
    DWORD dwReqId;
    
    // Number of procedures in the request
    WORD wProcCount;
};

// LbspReqProcCall
// A procedure in a request
struct LbspReqProcCall
{
	// hdr.wMsgType = LbspIdReqProcCall
    LbsMsgHeader hdr;
    
    // The id of the server procedure 
	DWORD dwProcId;
	
    // Number of parameters in rgParam
    WORD  wParamCount;
	
    // Procedure parameters
    // (this array is part of this message and should be taken in 
    // consideration when specifying the size of the message in the header)
    //LbspProcParam rgParam[];
};

// LbspProcParam
// A parameter in a procedure call
struct LbspProcParam
{
	// The type of the parameter. One of the LbspTypeId* constants.
    BYTE bParamType;

	// This is the value of the parameter. The value type and its size on the 
    // wire depends entirely on bParamType. For example, if bParamType ==
    // LbspTypeIdInt16, then the size of the parameter on the wire is 
    // sizeof(bParamType) + sizeof(i16Param) == 3.
    
    union
	{
		// LbspTypeIdInt8:
        INT8   i8Param;
		// LbspTypeIdInt16:
		INT16  i16Param;
		// LbspTypeIdInt32:
		INT32  i32Param;
		// LbspTypeIdInt64:
		INT64  i64Param;
		// LbspTypeIdDouble:
		double dParam;
		
		// LbspTypeIdString:
		struct
		{
			// Size of str in bytes. Max is LbspMaxSizeStringParam.
            WORD wStrLen;
            // String parameter. UTF8. Not null-terminated.
			CHAR str[1];
		} strParam;
	};	
};

struct LbspRepRowsetStart
{
    LbsMsgHeader hdr;
};

struct LbspRepRowsetRow
{
    LbsMsgHeader hdr;
    WORD wColCount;
    // LbspColumnData rgColumns[];
};

struct LbspColumnData
{
    BYTE bType;
    
	union
	{
		INT8   i8;
		INT16  i16;
		INT32  i32;
		INT64  i64;
		double d;
		
		struct
		{
			WORD wStrLen;
			CHAR str[1];
		} str;
	};	
};

struct LbspRepRowsetEnd
{
    LbsMsgHeader hdr;
};

struct LbspRepMessage
{
    LbsMsgHeader hdr;
    DWORD dwErrorId;
    WORD  wMsgLen;
    CHAR  message[1];
};

struct LbspRepEndRequest
{
    LbsMsgHeader hdr;
    DWORD dwReqId;
};

// the client can send this message to test the connection. It can only be
// sent during the 'Ready' state, though. It cannot be sent during the response
// of a request, for example
struct LbspReqPing
{
    // hdr.wMsgType = LbspIdReqPing
    LbsMsgHeader hdr;
    
    // Arbitrary DWORD. The server will return the same value in the response
    DWORD dwPing;
};

// this is the response to LbspReqPing
struct LbspRepPing
{
    // hdr.wMsgType = LbspIdRepPing
    LbsMsgHeader hdr;
    
    // Same value passed in the request
    DWORD dwPing;
};


#pragma pack(pop)

class CNet;
class CNetCliCnt;
class CLBSPRequest;
class CLBSPRequestParser;
class CLBSPProcedure;
class CLBSPProcedureParser;
class CLBSPParam;
class CLBSPParamParser;

class __declspec(novtable) INetReply
{
public:
    virtual bool  RowsetBegin() = 0;
    virtual bool  RowsetRow(LbStat* rgColumns, DWORD cColumns) = 0;
    virtual bool  RowsetEnd() = 0;
    virtual bool  ReplyMessage(DWORD dwErrorId, LPCSTR pszMessage) = 0;
    virtual bool  ReplyDone() = 0;
};

class __declspec(novtable) INetCallback
{
public:
    virtual bool OnNewRequest(CLBSPRequest* pRequest, INetReply* pReply) = 0;
};

class CNet : public CServerSocketCallback
{
friend CNetCliCnt;
USE_GLOBAL_ALLOC;
public:

    CNet();
    
    ~CNet();
    
    bool Init(
        CConfig* pConfig,
        CServerTimer* pTimer,
        INetCallback* pRequestCallback,
        CPerfCounters* pPerfCounters
    );
    
    void Term();
    
protected:

    void ShutdownConnections();

    bool CreateListenSocket(
        CConfig* pConfig
    );
    
    void ReleaseReferenceToConnection(
        CNetCliCnt* pCnt
    );
    
    void DecrementOutstandingConnectionCount()
    {
        if(InterlockedDecrement(&_lOutstandingCntCount) < 0)
        {
            DBGASSERT(false);
        }
    }

    // CServerSocketCallback
    
    virtual ULONG  AddRef()  
    { 
        ULONG lRet = (ULONG) InterlockedIncrement(&_lRef); 
        return lRet;
    }
    
    virtual ULONG  Release() 
    { 
        ULONG lRet = (ULONG) InterlockedDecrement(&_lRef); 
        return lRet;
    }

    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg 
    );
    
    // End of CServerSocketCallback

    CConfig*           _pConfig;
    CServerTimer*      _pTimer;
    CCompletionPort*   _pCompPort;
    CServerSocket*     _pListenSocket;
    LONG               _lRef;
    volatile LONG      _lOutstandingCntCount;
    LONG               _lMaxConnections;
    THashtable<CNetCliCnt*,BYTE> _cliCntTbl;
    CFastLock          _lockCliCntTbl;
    volatile DWORD     _dwCntIdSeed;
    bool               _fSocketInit;
    volatile LONG      _fShutdown;
    CFastLock          _lockListenSocket;
    INetCallback*      _pCallback;
    CPerfCounters*     _pPerfCounters;
};

class CNetCliCnt : 
    public CServerSocketCallback,
    public IServerTimerCallback,
    public INetReply
{
friend CNet;
IMPLEMENT_REFCOUNT;
USE_GLOBAL_ALLOC;
public:
    
    CNetCliCnt(CPerfCounters* pPerfCounters);
    
    bool Init(
        CNet*          pNet,
        CConfig*       pConfig,
        CServerTimer*  pTimer,
        CServerSocket* pSocket,
        DWORD          dwCntId,
        INetCallback*  pCallback
    );
    
    bool GetPointerToSendBuffer(
        DWORD dwSize, 
        BYTE** ppBuffer
    );
    
    bool Send();

    void Shutdown();
    
    enum State
    {
        StateNotInitialized,
        StateWaitingForHello,
        StateReady,
        StateBuildingRequest,
        StateProcessingRequest,
        StateSendingRowset
    };
    
    LONG GetState() const { return _state; }
    
protected:
    
    // Destructor
    // Call 'Release' to destroy object
    ~CNetCliCnt();
    
    bool StartReceiving(DWORD dwRcvTimeout);
    
    bool GetSendBuffer();
    
    bool ProcessMessages();
    
    bool ProcessReqHello(LbsMsgHeader* pHdr);
    
    bool ProcessReqBeginRequest(LbsMsgHeader* pHdr);
    
    bool ProcessReqProcCall(LbsMsgHeader* pHdr);
    
    bool ProcessReqPing(LbsMsgHeader* pHdr);
    
    // CServerSocketCallback
    virtual void OnSocketReceive(
        BYTE *pbFilledInBuffer,
        DWORD cbRead,
        HRESULT hr,
        QWORD qwCallbackArg 
    );
    
    virtual void OnSocketSend(
        BYTE *pbBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hr,
        QWORD qwCallbackArg 
    );
    
    // IServerTimerCallback
    virtual void OnTimer(void* pParam);

    // INetReply
    virtual bool  RowsetBegin();
    
    virtual bool  RowsetRow(
        LbStat* rgColumns, 
        DWORD cColumns
    );
    
    virtual bool  RowsetEnd();
    
    virtual bool ReplyMessage(
        DWORD dwErrorId, 
        LPCSTR pszMessage);
    
    virtual bool ReplyDone();
    
    // Check if state is state1 or state2. If it's not, call WaitForStates which
    // will give it a chance to reach either state
    INLINE bool CheckState(
        LONG state1,
        LONG state2
    )
    {
        if(_state == state1 || _state == state2)
            return true;
        else
            return WaitForState(state1, state2);
    }
    
    bool WaitForState(
        LONG state1,
        LONG state2
    );
    
    LONG           _fShutdown;
    CNet*          _pNet;
    CServerSocket* _pSocket;
    DWORD          _dwCntId;
    volatile LONG  _state;
    CHAR           _szClientName[LbspMaxClientName+1];
    DWORD          _dwSizeRcvBuffer;
    DWORD          _dwSizeSndBuffer;
    DWORD          _dwMaxCSndBuffer;
    DWORD          _dwBytesInRcvBuffer;
    BYTE*          _pRcvBuffer;
    DWORD          _dwBytesInSndBuffer;
    volatile BYTE* _pSndBuffer;
    TLFStack<CSingleLink> _sndBufferCache;
    volatile DWORD _dwSndBuffersCreated;
    HANDLE         _hWait;
    CFastLock      _lock;
    DWORD          _dwHelloTimeout;
    CServerTimer*  _pTimer;
    CServerTimerAppt* _pAppt;
    volatile bool  _fTimeout;
    sockaddr_in    _sinCnt;
    CArenaMemAlloc _requestAlloc;
    CLBSPRequestParser* _pRequest;
    INetCallback*  _pCallback;
    CPerfCounters* _pPerfCounters;
};

class CLBSPRequest  
{
public:
    
    DWORD GetReqId() const         { return _dwReqId; }
    WORD  GetProcCount() const     { return _wProcCount; }
    bool  IsRequestReady() const   { return _wProcCount == _procs.GetSize();}
    
    CLBSPProcedure* GetProcedure(int iProcNdx)
    { 
        return _procs.Get(iProcNdx); 
    }
    
    void Dump(CStr* pStr);
    
#if !_TEST
protected:
#endif
    
    CLBSPRequest() 
    {
        _dwReqId    = 0;
        _wProcCount = 0;
    }
    
    ~CLBSPRequest()
    {
    }
    
    DWORD _dwReqId;
    WORD  _wProcCount;
    TArray<CLBSPProcedure*, 1> _procs;
};

class CLBSPRequestParser : public CLBSPRequest
{
public:

    CLBSPRequestParser() {}
    
    bool ParseBeginRequest(
        CArenaMemAlloc* pAlloc, 
        BYTE** ppBuffer, 
        DWORD* pdwRemaining
    );
    
    bool ParseProc(
        CArenaMemAlloc* pAlloc, 
        BYTE** ppBuffer, 
        DWORD* pdwRemaining
    );

protected:
    
    ~CLBSPRequestParser()
    {
    }
};

class CLBSPParam : public LbStat
{
public:
    
    bool GetInt8(INT8* pParam)
    {
        if(this->bType != LbspTypeIdInt8)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected INT8. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pParam = this->i8;
        return true;
    }
    
    bool GetInt16(INT16* pParam)
    {
        if(this->bType != LbspTypeIdInt16)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected INT16. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pParam = this->i16;
        return true;
    }
    
    bool GetInt32(INT32* pParam)
    {
        if(this->bType != LbspTypeIdInt32)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected INT32. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pParam = this->i32;
        return true;
    }
    
    bool GetInt64(INT64* pParam)
    {
        if(this->bType != LbspTypeIdInt64)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected INT64. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pParam = this->i64;
        return true;
    }

    bool GetDouble(double* pParam)
    {
        if(this->bType != LbspTypeIdDouble)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected DOUBLE. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pParam = this->d;
        return true;
    }
    
    bool GetString(CConstStr* pStr)
    {
        if(this->bType != LbspTypeIdString)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Wrong parameter type. Expected STRING. Received type %u.",
                (DWORD)this->bType);
            return false;
        }
        
        *pStr = CConstStr(this->str.pstr, this->str.wStrLen);
        return true;
    }
    
protected:

    CLBSPParam()
    {
        ZeroMemory((LbStat*)this, sizeof(LbStat));
    }
    
    ~CLBSPParam()
    {
    }
};

class CLBSPParamParser : public CLBSPParam
{
public:
    bool Parse(
        CArenaMemAlloc* pAlloc, 
        BYTE** ppBuffer, 
        DWORD* pdwRemaining
    );
    
protected:

    ~CLBSPParamParser()
    {
    }
};

class CLBSPProcedure
{
public:
    DWORD GetProcId() const     { return _dwProcId; }
    WORD  GetParamCount() const { return _wParamCount; }
    
    bool GetParam(int iParamNdx, CLBSPParam** ppParam)
    {
        if(iParamNdx < _params.GetSize())
        {
            *ppParam = _params.Get(iParamNdx);
            return true;
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Insufficient number of parameters in procedure call (%u). "
                "At least %u parameters were expected", _params.GetSize(),
                iParamNdx+1);
            return false;
        }
    }
    
    bool GetInt8(int iParamNdx, INT8* pData)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetInt8(pData))
            goto lError;
            
        return true;
        
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }
    
    bool GetInt16(int iParamNdx, INT16* pData)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetInt16(pData))
            goto lError;
            
        return true;
        
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }

    bool GetInt32(int iParamNdx, INT32* pData)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetInt32(pData))
            goto lError;
            
        return true;
        
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }
    
    bool GetInt64(int iParamNdx, INT64* pData)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetInt64(pData))
            goto lError;
    
        return true;
        
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }
    
    bool GetDouble(int iParamNdx, double* pData)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetDouble(pData))
            goto lError;
            
        return true;
    
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }
    
    bool GetString(int iParamNdx, CConstStr* pStr)
    {
        CLBSPParam* pParam;
        
        if(!GetParam(iParamNdx, &pParam))
            goto lError;
            
        if(!pParam->GetString(pStr))
            goto lError;
            
        return true;
    
    lError:    
        
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Parameter Index (zero-based): %u", iParamNdx);
        return false;
    }
    
#if !_TEST
protected:
#endif
    
    CLBSPProcedure()
    {
        _dwProcId    = 0;
        _wParamCount = 0;
    }

    ~CLBSPProcedure()
    {
    }
    
    DWORD _dwProcId;
    WORD  _wParamCount;
    TArray<CLBSPParam*, 1> _params;
};

class CLBSPProcedureParser : public CLBSPProcedure
{
public:
    
    CLBSPProcedureParser() {}
    
    bool Parse(
        CArenaMemAlloc* pAlloc, 
        BYTE** ppBuffer, 
        DWORD* pdwRemaining
    );

protected:
    
    ~CLBSPProcedureParser()
    {
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\sources.inc ===
# MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=..\lbs.h

PRECOMPILED_PCH=lbs.pch
PRECOMPILED_OBJ=lbs.obj
PRECOMPILED_CXX=1

!if $(FREEBUILD) == 1
# MSC_OPTIMIZATION=/Ox
!endif        

USE_STL=1
USE_LIBCMT=1
USE_STATIC_ATL=1
NO_BUFFEROVERFLOW_CHECKS=1

#_NT_TARGET_VERSION=$(_NT_TARGET_VERSION_WS03)

# Set dependency on xblhealthcheck.tlb.
BUILD_CONSUMES=COMMON_HEALTH_DLL

XLUSE_XMGMT=1
XLUSE_NTSVC=1
XLUSE_CONFIG=1
XLUSE_DSTRUCT=1
XLUSE_OLEDBW=1
XLUSE_HEALTH=1

TARGETLIBS=\
    $(TARGETLIBS)    \
    $(INETROOT)\private\server\perfapp\lbsvrperf\$(O)\lbsvrperf.lib

INCLUDES=\
    $(INCLUDES); \
    $(INETROOT)\private\server\perfapp\lbsvrperf;\
    .\..\; \

INCLUDES=$(INCLUDES);    \
    $(INETROOT)\private\server\stats\lbwsinterop\$(O);    \

SOURCES=\
  ..\btree.cpp    \
  ..\buffer.cpp   \
  ..\ums.cpp      \
  ..\util.cpp     \
  ..\net.cpp      \
  ..\lb.cpp       \
  ..\config.cpp   \
  ..\procs.cpp    \
  ..\db.cpp       \
  ..\jobs.cpp     \
  ..\perfctrsLb.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\procs.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * procs.h
 * Header of leaderboard server remote procedures
 * 
 */

#pragma once

const DWORD LbProcIdLoadLb                = 1;
const DWORD LbProcIdDeleteLb              = 2;
const DWORD LbProcIdStatRead              = 3;
const DWORD LbProcIdStatWrite             = 4;
const DWORD LbProcIdStatEnum              = 5;
const DWORD LbProcIdDeleteTitle           = 6;
const DWORD LbProcIdGetLbRankedEntryCount = 7;
const DWORD LbProcIdResetPuid             = 8;
const DWORD LbProcIdStatEnumNearPuid      = 9;
const DWORD LbProcIdResetLb               = 10;
const DWORD LbProcIdStatEnumNearRating    = 11;

const DWORD LbProcIdDeleteLbFromMemoryOnly = 12;
const DWORD LbProcIdSetLbToReadOnly        = 13;
const DWORD LbProcIdSetLbToReadWrite       = 14; 
const DWORD LbProcIdIsSafeToDeleteLb       = 15; 
const DWORD LbProcIdCreateAndLoadOneLb     = 16;
const DWORD LbProcIdGetLbStatus            = 17;

const DWORD LbProcIdEstimateRankForRatings = 18;
const DWORD LbProcIdCheckConnection        = 19;

const DWORD LbProcIdTestAutoReset         = 1001;
const DWORD LbProcIdTestAutoDecay         = 1002;
const DWORD LbProcIdTestChangeLastUpdateTime = 1003;
const DWORD LbProcIdTestAutoTrim          = 1004;
const INT8	LbConstantConnected                =1;


class CRequestGlobalInfo;

typedef DWORD (*LbProcHandler)(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo, 
    CLBSPProcedure* pProc, 
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters*  pPerfCounters
);

class CRequestGlobalInfo 
{
public:
    
    CRequestGlobalInfo()
    {
        _pConfig = NULL;
        _pLbList = NULL;
    }
    
    CConfig* GetConfig() { return _pConfig; }
    CLbList* GetLbList() { return _pLbList; }
    
    LbProcHandler GetProcHandler(DWORD dwProcId)
    {
        LbProcHandler procHandler;
        
        if(_procs.Get(dwProcId, &procHandler))
            return procHandler;
        else
            return NULL;
    }

protected:
    CConfig* _pConfig;
    CLbList* _pLbList;
    THashtable<DWORD,LbProcHandler> _procs;
};

class CRequestTask : public UMSTask
{
public:
USE_GLOBAL_ALLOC; // TODO: pool
    
    CRequestTask(
        CRequestGlobalInfo* pInfo,
        CLBSPRequest* pRequest,
        INetReply*    pReply,
        CPerfCounters* pPerfCounters
    );
    
    ~CRequestTask();
    
    virtual void Execute(IUmsClient *pUmsClient);
    
    virtual void Free();
    
    CRequestGlobalInfo* _pInfo;
    CLBSPRequest*       _pRequest;
    INetReply*          _pReply;
    CPerfCounters*      _pPerfCounters;
};

class CRequestManager : 
    public CRequestGlobalInfo,
    public INetCallback
{
USE_GLOBAL_ALLOC;
public:
    
    CRequestManager();
    
    bool Init(
        CConfig* pConfig,
        UMS* pUMS,
        CLbList* pLbList,
        CPerfCounters* pPerfCounters
    );
    
    void Term();
    
    bool RegisterProc(
        DWORD dwProcId,
        LbProcHandler procHandler
    );
    
protected:

    // INetCallback
    
    virtual bool OnNewRequest(
        CLBSPRequest *pRequest, 
        INetReply *pReply
    );
    
    UMS*     _pUMS;
    CPerfCounters* _pPerfCounters;
};

class CLbRemoteProc
{
public:

//Methods to be used by operation maintainance (e.g. Lb Move)
    static DWORD SetLbToReadOnly( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD CLbRemoteProc::SetLbToReadWrite( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD GetLbStatus(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD EstimateRankForRatings(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    static DWORD DeleteLbFromMemoryOnly(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD IsSafeToDeleteLb( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

//end Operation    
    
    static bool Register(
        CRequestManager* pRM
    );

    static DWORD CreateLb(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD CreateAndLoadOneLb(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    static DWORD DeleteLb(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD DeleteTitle(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    static DWORD StatRead( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    static DWORD StatWrite( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    static DWORD StatEnum(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    static DWORD StatEnumNearPuid(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    static DWORD StatEnumNearRating(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD GetLbRankedEntryCount(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD ResetPuid(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD ResetLb(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
     static DWORD CheckConnection(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );
    
    
    // Support procedures
    
    static DWORD TestAutoReset(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD TestAutoDecay(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD TestAutoTrim(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

    static DWORD TestChangeLastUpdateTime(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    );

protected:
    static DWORD CLbRemoteProc::SetLbStatusCommon( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CLb::LbStatus newlbstatus
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\ums.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * ums.cpp
 * Implementation of leaderboard server User Mode Scheduler
 * Header: ums.h
 * 
 */

#include "lbs.h"

/*****************************************************************************
 UMS
*****************************************************************************/
bool UMS::Init(CPerfCounters* pPerfCounters)
{
    bool fRet        = false;
    
    _fShutdown = false;
    _pPerfCounters = pPerfCounters;
    
    if(!_poolLockResourceEntry.Init("_poolLockResourceEntry", sizeof(LOCK_RESOURCE_ENTRY), 
        UMS_INITIAL_SIZE_LOCK_RESOURCE_ENTRY_POOL, true, &g_MemAlloc))
    {
        goto lDone;
    }
    
    if(!_taskList.Init("_taskList", UMS_INITIAL_SIZE_TASK_LIST, true, &g_MemAlloc)) 
        goto lDone;

    _hSupervisorEvent = CreateEventA(NULL, /*ManualReset*/TRUE, 
        /*bInitialState*/FALSE, NULL);
        
    if(_hSupervisorEvent == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CreateEvent failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    // Create the supervisor thread
    _eSupervisorState = NOT_INITIALIZED;
    
    _hSupervisorThread = ::CreateThread(NULL, 0, SupervisorThreadProc, this, 0, NULL);
    if(_hSupervisorThread == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CreateThread failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    // The supervisor thread will run with a higher priority
    if(!::SetThreadPriority(_hSupervisorThread, THREAD_PRIORITY_ABOVE_NORMAL))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "SetThreadPriority failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    // Create workers
    _cWorkers = 60; // TODO: config
    
    _prgWorkers = new UMSWorker[_cWorkers];
    if(NULL == _prgWorkers)
        goto lDone;
        
    for(DWORD i=0; i < _cWorkers; i++)
    {
        if(!_prgWorkers[i].Init(this))
            goto lDone;
    }
    
    fRet = true;

lDone:

    
    if(!fRet)
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

void UMS::Shutdown()
{
    // Enter shutdown mode. Accept no more tasks.
    InterlockedExchange(&_fShutdown, TRUE);

    // Drain current tasks
    while(_taskList.GetCount() > 0 || _availableWorkerList.GetCount() < (LONG)_cWorkers)
    {
        Sleep(100);
    }
}

void UMS::Term()
{
    Shutdown();
    
    // Terminate supervisor thread
    if(_hSupervisorEvent != NULL)
    {
        _eSupervisorState = SHUTTING_DOWN;
        do
        {
            ::SetEvent(_hSupervisorEvent);
        } while(WaitForSingleObject(_hSupervisorThread, 500) == WAIT_TIMEOUT);
        
        CloseHandle(_hSupervisorThread);
        _hSupervisorThread = NULL;
        CloseHandle(_hSupervisorEvent);
        _hSupervisorEvent  = NULL;
    }
    
    DBGASSERT(_availableWorkerList.GetCount() == _cWorkers);
    _availableWorkerList.Reset();
    
    // Terminate workers
    if(_prgWorkers != NULL)
    {
        for(DWORD i=0; i < _cWorkers; i++)
        {
            _prgWorkers[i].Term();
        }
        
        delete[] _prgWorkers;
        _prgWorkers = NULL;
    }    
    
    // Clean up lists
    DBGASSERT(_taskList.GetCount() == 0);
    _taskList.Term();
    
    _poolLockResourceEntry.Term();
    
    return;
}

DWORD UMS::SupervisorThreadProc(LPVOID lpParam)
{
    CGlobalError::Init();
    ((UMS*)lpParam)->SupervisorProc();
    CGlobalError::Term();
    return 0;
}

void UMS::SupervisorProc()
{
    _eSupervisorState = INITIALIZED;
    
    while(_eSupervisorState == INITIALIZED)
    {
        
        // Do supervisor work
        SupervisorAssignTasks();
        
        // Quick check to see if we should keep spinning
        if(SupervisorGotWork())
            continue;
        
        _lockSupervisor.Lock();
        
        // Same check, but more restrictive
        if(SupervisorGotWork())
        {
            _lockSupervisor.Unlock();
            continue;
        }
        
        // Nothing to do. Let's sleep until something changes.
        _lSupervisorAwake = 0;
        ::ResetEvent(_hSupervisorEvent);
        _lockSupervisor.Unlock();
        
        WaitForSingleObject(_hSupervisorEvent, INFINITE);
    }
    
    _eSupervisorState = TERMINATED;
}

bool UMS::SupervisorGotWork()
{
    return (_taskList.GetCount() > 0 && _availableWorkerList.GetCount());
}

bool UMS::WaitForNewTask(UMSWorker* pWorker)
{
    bool fRet = false;
    
    // Shortcut
    UMSTask* pTask = (UMSTask*)_taskList.Dequeue();
    if(pTask != NULL)
    {
        pWorker->SetTask(pTask);
        fRet = true;
        goto lDone;
    }
    
    // Sleep until the supervisor wakes me up
    pWorker->GetUmsClient()->PrepareToSleep();
    
    if(!_availableWorkerList.Push(pWorker))
        goto lDone;

    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SafeIncrement32 (LBPERF_SERVER_TOTAL_FREE_UMS_THREAD_COUNTER);
    }
    
    pWorker->GetUmsClient()->Sleep();
    
    if (NULL != _pPerfCounters)
    {
        _pPerfCounters->SafeDecrement32 (LBPERF_SERVER_TOTAL_FREE_UMS_THREAD_COUNTER);
    }
        
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p)", pWorker);
    
    return fRet;
}

bool UMS::AddNewTask(UMSTask* pTask)
{
    bool fRet = false;
    
    if(_fShutdown)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "UMS is shutting down and it's not accepting new tasks.");
        goto lDone;
    }
    
    if(!_taskList.Enqueue(pTask))
        goto lDone;
    
    WakeUpSupervisor();
    
    fRet = true;

lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p)",pTask);
        
    return fRet;                   
}

bool UMS::CreateUmsClient(
    OUT IUmsClient** ppUmsClient
)
{
    bool fRet = false;
    UmsClient* pUmsClient = NULL;
    
    // Allocate new UmsClient 
    pUmsClient = new UmsClient();
    if(NULL == pUmsClient)
        goto lDone;
        
    // Initialize it
    if(!pUmsClient->Init(this))
        goto lDone;
        
    // Return interface pointer
    *ppUmsClient = (IUmsClient*)pUmsClient;
    
    // Caller owns it now
    pUmsClient = NULL;
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    // Clean up
    if(pUmsClient != NULL)
        delete pUmsClient;

    return fRet;
}

void UMS::ReleaseUmsClient(
    IN IUmsClient* pUmsClient
)
{
    // Terminate client first
    UmsClient* pClient = (UmsClient*)pUmsClient; 
    pClient->Term();
    
    // Release memory
    delete pClient;
}


void UMS::SupervisorAssignTasks()
{
    while(_taskList.GetCount() > 0 && _availableWorkerList.GetCount() > 0)
    {
        UMSTask* pTask = (UMSTask*) _taskList.Dequeue();
        
        if(pTask == NULL)
            break;
            
        UMSWorker* pWorker = _availableWorkerList.Pop();
        if(pWorker == NULL)
        {
            _taskList.Enqueue(pTask);
            break;
        }
        
        pWorker->SetTask(pTask);
        pWorker->GetUmsClient()->WakeUp();
    }
}

bool UMS::AcquireLock(
    UmsClient* pWorker, 
    LOCK_ID& lid, 
    LOCK_MODE lm,
    UMSLockCookie* pCookie,
    bool fBlock
)
{
    DBGASSERT(lm >= LOCK_MODE_IS && lm <=LOCK_MODE_LAST);
    DBGASSERT(pCookie->pWorker == NULL);
    
    bool fRet  = false;
    bool fLock = false;
    
    UMS_INC_STAT(cLockRequest);
    
    // Calculate the slot based on lid
    DWORD dwSlot = (DWORD) (LOCK_ID::GetHash(lid) % ARRAY_SIZE(_lockResourceTable));
    
    // Lock access to the slot
    _lockResourceTable[dwSlot]._lock.Lock();
    fLock = true;
    
    LOCK_RESOURCE_ENTRY* pEntry = _lockResourceTable[dwSlot].pNext;
    
    while(pEntry != NULL && !LOCK_ID::IsEqual(pEntry->_lid, lid))
        pEntry = pEntry->pNext;
        
    // If there is no entry for the resource id, create new entry
    if(pEntry == NULL)
    {
        pEntry = new (_poolLockResourceEntry.Alloc(sizeof(LOCK_RESOURCE_ENTRY))) LOCK_RESOURCE_ENTRY;
        if(NULL == pEntry)
            goto lDone; 
            
        pEntry->_lid = lid;

        // Add entry to the list in the slot
        pEntry->pNext = _lockResourceTable[dwSlot].pNext;
        _lockResourceTable[dwSlot].pNext = pEntry;
    }
    
    if(IsLockCompatible(pWorker, pEntry, lm))
    {
        // Increment reference on new lock mode
        IncrementLockReference(pEntry, lm);
        
        // Update worker's context
        if(!pWorker->IncrementLockCounter(lid, lm))
        {
            DecrementLockReference(pEntry, lm); // TODO: fatal error
            goto lDone;
        }
    }
    else if(fBlock)
    {
        pWorker->PrepareToSleep();
        
        // Have worker wait on lock
        if(!QueueContextOnLockQueue(pEntry,pWorker,lm))
            goto lDone;
        
        _lockResourceTable[dwSlot]._lock.Unlock();
        fLock = false;
        
        // Sleep until the lock is ours
        pWorker->Sleep();

        // When we wake up the lock must be already in our context    
        if(pWorker->GetLockCount(lid, lm) != 1)
        {
            DBGASSERT(false);
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "pWorker->GetLockCount(lid, lm) != 1");
            goto lDone;
        }
        
        UMS_INC_STAT(cWait);
    }
    else
    {
        // Failed to acquire lock but no big deal
        fRet = false;
        goto lDone;
    }
    
    pCookie->lid      = lid;
    pCookie->lm       = lm;
    pCookie->pWorker  = pWorker;
    
    fRet = true;
    
lDone:

    if(fLock)
        _lockResourceTable[dwSlot]._lock.Unlock();
        
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

// ReleaseAndAcquireLock
// Equivalent to release and re-acquiring the lock on a resource but it's a bit 
// faster than calling ReleaseLock followed by AcquireLock
bool UMS::ReleaseAndAcquireLock(
    IN UmsClient* pWorker,
    IN UMSLockCookie* pCookie,
    IN LOCK_MODE lm
)
{
    DBGASSERT(pCookie->pWorker == pWorker);
    
    bool fRet  = false;
    bool fLock = false;
    
    // Shortcut
    if(pCookie->lm == lm)
        return true;
        
    // Calculate the slot based on lid
    DWORD dwSlot = (DWORD) (LOCK_ID::GetHash(pCookie->lid) % 
        ARRAY_SIZE(_lockResourceTable));
    
    // Lock access to the slot
    _lockResourceTable[dwSlot]._lock.Lock();
    fLock = true;
    
    LOCK_RESOURCE_ENTRY* pPrevLockResource = NULL;
    LOCK_RESOURCE_ENTRY* pLockResource     = NULL;
    
    pLockResource = _lockResourceTable[dwSlot].pNext;
    
    while(pLockResource != NULL && !LOCK_ID::IsEqual(pLockResource->_lid, pCookie->lid))
    {
        pPrevLockResource = pLockResource;
        pLockResource     = pLockResource->pNext;
    }
    
    // The lock is in the worker's context. Therefore it MUST be in the global
    // lock table as well.
    if(NULL == pLockResource)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "NULL == pLockResource");
        goto lDone;
    }
    
    if(!pWorker->DecrementLockCounter(pCookie->lid, pCookie->lm))
        goto lDone;
    
    // DecrementReference
    DecrementLockReference(pLockResource, pCookie->lm);
    
    if(IsLockCompatible(pWorker, pLockResource, lm))
    {
        // Increment reference on new lock mode
        IncrementLockReference(pLockResource, lm);
        
        // Update worker's context
        if(!pWorker->IncrementLockCounter(pCookie->lid, lm))
        {
            DecrementLockReference(pLockResource, lm); // TODO: fatal error
            goto lDone;
        }
    
        if(pLockResource->_cQueueCount > 0)
        {
            if(!AwakeUnblockedWorkers(pLockResource))
                goto lDone;
        }
    }
    else
    {
        pWorker->PrepareToSleep();
        
        // Have worker wait on lock
        if(!QueueContextOnLockQueue(pLockResource,pWorker,lm))
            goto lDone;
        
        if(pLockResource->_cQueueCount > 0)
        {
            if(!AwakeUnblockedWorkers(pLockResource))
                goto lDone;
        }
        
        _lockResourceTable[dwSlot]._lock.Unlock();
        fLock = false;
        
        // Sleep until the lock is ours
        pWorker->Sleep();

        // When we wake up the lock must be already in our context    
        if(pWorker->GetLockCount(pCookie->lid, lm) != 1)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "pWorker->GetLockCount(pCookie->lid, lm) != 1");
            goto lDone;
        }
    }
    
    pCookie->lm       = lm;
    pCookie->pWorker  = pWorker;
    
    fRet = true;
    
lDone:

    if(fLock)
        _lockResourceTable[dwSlot]._lock.Unlock();

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return fRet;
}

// UpgradeLockFromSIXtoX
// Change a lock from SIX to X. In practice it acquires a new lock X before 
// releasing the SIX and returns the new lock cookie. Use it carefully as it 
// can cause deadlocks.
bool UMS::UpgradeLockFromSIXtoX(
    IN UmsClient* pWorker,
    IN UMSLockCookie* pCookie
)
{
    bool fRet = false;
    UMSSafeLockCookie newLock(pWorker);

    // this method was intended to upgrade only from SIX to X
    if(pCookie->lm != LOCK_MODE_SIX)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "UpgradeLockFromSIXtoX called for a previous lock-mode other than SIX");
        DBGASSERT(false);
    }
    
    // acquire a NEW lock X. Don't release existing SIX lock
    if(!AcquireLock(pWorker, 
                    pCookie->lid, 
                    LOCK_MODE_X,
                    &newLock,
                    true))
    {
        goto lDone;
    }

    // release SIX
    if(!ReleaseLock(pWorker, pCookie))
    {
        DBGASSERT(false);
        goto lDone;
    }

    // swap cookies
    newLock.Detach(pCookie);

    fRet = true;

lDone:

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return fRet;
}

bool UMS::ReleaseLock(
    UmsClient* pWorker, 
    UMSLockCookie* pCookie
)
{
    DBGASSERT(pCookie->pWorker == pWorker);
    
    bool fRet  = false;
    bool fLock = false;
    
    // Calculate the slot based on lid
    DWORD dwSlot = (DWORD) (LOCK_ID::GetHash(pCookie->lid) % ARRAY_SIZE(_lockResourceTable));
    
    // Lock access to the slot
    _lockResourceTable[dwSlot]._lock.Lock();
    fLock = true;
    
    LOCK_RESOURCE_ENTRY* pPrevLockResource = NULL;
    LOCK_RESOURCE_ENTRY* pLockResource     = NULL;
    
    pLockResource = _lockResourceTable[dwSlot].pNext;
    
    while(pLockResource != NULL && !LOCK_ID::IsEqual(pLockResource->_lid, pCookie->lid))
    {
        pPrevLockResource = pLockResource;
        pLockResource     = pLockResource->pNext;
    }
    
    // The lock is in the worker's context. Therefore it MUST be in the global
    // lock table as well.
    if(NULL == pLockResource)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "NULL == pLockResource");
        goto lDone;
    }
    
    if(!pWorker->DecrementLockCounter(pCookie->lid, pCookie->lm))
        goto lDone;
    
    // DecrementReference
    DecrementLockReference(pLockResource, pCookie->lm);
    
    if(pLockResource->_cQueueCount > 0)
    {
        // Lock mode count reached zero. See if this unblocked some workers.
        if(!AwakeUnblockedWorkers(pLockResource))
            goto lDone;
    }
    
    if(pLockResource->_cLockCount == 0)
    {
        // No locks referencing this resource (lock id) anymore.
        // Release resources.
        if(pPrevLockResource != NULL)
        {
            pPrevLockResource->pNext = pLockResource->pNext;
        }
        else
        {
            _lockResourceTable[dwSlot].pNext = pLockResource->pNext;
        }
        
        pLockResource->~LOCK_RESOURCE_ENTRY();
        _poolLockResourceEntry.Free(pLockResource);
    }
   
    pCookie->lid.type = 0;
    pCookie->lid.id   = 0;
    pCookie->lm       = 0;
    pCookie->pWorker  = NULL;
    
    fRet = true;
    
lDone:

    if(fLock)
        _lockResourceTable[dwSlot]._lock.Unlock();

    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }

    return fRet;
}

bool UMS::AwakeUnblockedWorkers(
    LOCK_RESOURCE_ENTRY* pLockResource
)
{
    bool fRet = false;

    for(DWORD lm=LOCK_MODE_LAST; lm >= LOCK_MODE_IS; lm--)
    {
        if(pLockResource->_rgLockModeQueue[lm-1].GetCount() > 0)
        {
            TList<UmsClient>::Iterator it;
            
            pLockResource->_rgLockModeQueue[lm-1].Begin(&it);
            
            UmsClient* pWorker;
            while((pWorker = it.Next()) != NULL)
            {
                if(IsLockCompatible(pWorker,pLockResource,lm))
                {
                    it.Remove();
                    
                    if(!pWorker->IncrementLockCounter(pLockResource->_lid, lm))
                        goto lDone;
                    
                    IncrementLockReference(pLockResource,lm);
                    pWorker->WakeUp();
                }
            }
        }
    }

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p)", pLockResource);

    return fRet;
}

bool UMS::QueueContextOnLockQueue(
    LOCK_RESOURCE_ENTRY* pLockResource, 
    UmsClient* pWorker, 
    LOCK_MODE lm
)
{
    DBGASSERT(lm >= LOCK_MODE_IS && lm <= LOCK_MODE_LAST);
     
    pLockResource->_rgLockModeQueue[lm-1].Enqueue(pWorker);
    pLockResource->_cQueueCount++;
    
    return true;
}

UMSWorker* UMS::DequeueContextFromLockQueue(
    LOCK_RESOURCE_ENTRY* pLockResource, 
    LOCK_MODE lm
)
{
    DBGASSERT(lm >= LOCK_MODE_IS && lm <= LOCK_MODE_LAST);
    
    UMSWorker* pWorker = (UMSWorker*) pLockResource->_rgLockModeQueue[lm-1].Dequeue();
    if(pWorker != NULL)
    {
        pLockResource->_cQueueCount--;
        return pWorker;
    }
    else
    {
        return NULL;
    }
}

void UMS::WakeUpSupervisor()
{
    _lockSupervisor.Lock();
    if(!_lSupervisorAwake)
    {
        _lSupervisorAwake = 1;
        ::SetEvent(_hSupervisorEvent);
    }
    _lockSupervisor.Unlock();
}

bool UMS::IsLockCompatible(
    UmsClient* pWorker,
    LOCK_RESOURCE_ENTRY* pLR, 
    LOCK_MODE lm
)
{
    DBGASSERT(lm >= LOCK_MODE_IS && lm <= LOCK_MODE_LAST);
    
    // The following array contains the maximum lock mode that is 
    // compatible with each lock mode. For example, IS is compatible
    // with every mode less or equal to SIX in other (IS, IX, SIX)
    // whereas IX is only compatible with 0 (no lock).
    static const LOCK_MODE rgMaxCompatibleLock[LOCK_MODE_LAST+1] = {
        /* no lock       */ LOCK_MODE_LAST,
        /* LOCK_MODE_IS  */ LOCK_MODE_SIX,
        /* LOCK_MODE_IX  */ LOCK_MODE_IX,
        /* LOCK_MODE_SIX */ LOCK_MODE_IS,
        /* LOCK_MODE_IX  */ 0
    };
    
    UmsClient::LOCK_COUNT contextLockCount = 
        pWorker->GetLockCountForAllModes(pLR->_lid);
    
    for(DWORD lmq=rgMaxCompatibleLock[lm]+1; lmq <= LOCK_MODE_LAST; lmq++)
    {
        // Check compability and give priority to high exclusivity lock modes.
        // For example we're not going to allow a IS lock if there is an X lock
        // pending. But we're going to allow an X lock even if there is another
        // X lock pending. Compability, however is not evaluated against the 
        // locks owned by the same context. For example, if a given context 
        // already has a lock X on a resource, a lock IS can be added to the 
        // same resource as long as it's in the same context.
        
        DBGASSERT(pLR->_rgLockMode[lmq-1] >= contextLockCount.rgLockCount[lmq-1]);
        
        if( pLR->_rgLockMode[lmq-1] != contextLockCount.rgLockCount[lmq-1] || 
            (lmq > lm && pLR->_rgLockModeQueue[lmq-1].GetCount() != 0))
        {
            return false;
        }
    }
    
    return true;
}

void UMS::IncrementLockReference(
    LOCK_RESOURCE_ENTRY* pLR, 
    LOCK_MODE lm
)
{
    DBGASSERT((lm-1) < ARRAY_SIZE(pLR->_rgLockMode));
    pLR->_rgLockMode[lm-1]++;
    pLR->_cLockCount++;
}

bool UMS::DecrementLockReference(
    LOCK_RESOURCE_ENTRY* pLR, 
    LOCK_MODE lm
)
{
    DBGASSERT((lm-1) < ARRAY_SIZE(pLR->_rgLockMode));
    DBGASSERT(pLR->_rgLockMode[(lm-1)] > 0);
    DBGASSERT(pLR->_cLockCount > 0);
    pLR->_rgLockMode[(lm-1)]--;
    pLR->_cLockCount--;
    
    return pLR->_rgLockMode[lm-1] == 0;
}

/*****************************************************************************
 UMSWorker
*****************************************************************************/
bool UMSWorker::Init(UMS* pScheduler)
{
    bool fRet = false;
    
    _pScheduler = pScheduler;
    _eState     = NOT_INITIALIZED;

    if(!_UmsClient.Init(pScheduler))
        goto lDone;
    
    _hThread = CreateThread(NULL, 0, ThreadProc, this, 0, &_dwThreadId);
    if(_hThread == NULL)
    {
        CGlobalError::SetMessage(
            GLOBAL_ERROR_HEADER "CreateThread failed. Error=%d", 
            GetLastError());
        goto lDone;
    }
    
    fRet = true;
    
lDone:
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%p)", pScheduler);
    }
    
    return fRet;
}

void UMSWorker::Term()
{
    // Enter shutdown mode
    _eState = SHUTTING_DOWN; // TODO: Use Interlocked
    
    // Terminate thread
    if(_hThread != NULL)
    {
        do
        {
            _UmsClient.WakeUp();
        } while(WaitForSingleObject(_hThread, 100) == WAIT_TIMEOUT);

        CloseHandle(_hThread);
        _hThread = NULL;
    }

    // Other resources
    _UmsClient.Term();
}
       
DWORD UMSWorker::ThreadProc(LPVOID lpParam)
{
    CGlobalError::Init();
    UMSWorker* pThis = (UMSWorker*) lpParam;
    pThis->WorkerProc();
    CGlobalError::Term();
    return 0;
}

void UMSWorker::WorkerProc()
{
    _eState = INITIALIZED;
                                               
    while(_eState == INITIALIZED)
    {
        if(!_pScheduler->WaitForNewTask(this))
        {
            DBGASSERT(_pScheduler->IsShuttingDown()); // TODO: evaluate failure scenario
        }
                
        if(GetTask() != NULL)
        {
            GetTask()->Execute((IUmsClient*)&_UmsClient);
            ReleaseTask();
        }
        else
        {
            DBGASSERT(_eState == SHUTTING_DOWN);
        }
    }
    
    _eState = TERMINATED;
}


/*****************************************************************************
 UmsClient
*****************************************************************************/
bool UmsClient::Init(UMS* pUms)
{
    DBGASSERT(NULL == _hControlEvent);
    
    bool fRet = false;
    
    _pUms = pUms;
    
    _hControlEvent = CreateEventA(NULL, /*ManualReset*/TRUE, 
        /*bInitialState*/FALSE, NULL);
        
    if(_hControlEvent == NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER 
            "CreateEvent failed. Error=%d", GetLastError());
        goto lDone;
    }
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}

void UmsClient::Term()
{
    if(_hControlEvent != NULL)
    {
        CloseHandle(_hControlEvent);
        _hControlEvent = NULL;
    }
}

bool UmsClient::AcquireLock(
    LOCK_ID& lid, 
    LOCK_MODE lm, 
    UMSLockCookie* pCookie)
{
    return _pUms->AcquireLock(this,lid, lm, pCookie, true);
}

bool UmsClient::TryAcquireLock(
    LOCK_ID& lid, 
    LOCK_MODE lm, 
    UMSLockCookie* pCookie)
{
    return _pUms->AcquireLock(this,lid, lm, pCookie, false);
}


bool UmsClient::ReleaseLock(UMSLockCookie* pCookie)
{
    return _pUms->ReleaseLock(this, pCookie);
}

bool UmsClient::ReleaseAndAcquireLock(UMSLockCookie* pCookie, LOCK_MODE lm)
{
    return _pUms->ReleaseAndAcquireLock(this, pCookie, lm);
}

bool UmsClient::UpgradeLockFromSIXtoX(UMSLockCookie* pCookie)
{
    return _pUms->UpgradeLockFromSIXtoX(this, pCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\perf\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\procs.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 *
 * Leaderboard Server
 *
 * procs.cpp
 * Implementation of leaderboard server remote procedures
 *
 */

#include "lbs.h"

XomDefineArea(LbsTrace);

/*****************************************************************************
  CRequestTask
*****************************************************************************/

CRequestTask::CRequestTask(
    CRequestGlobalInfo* pInfo,
    CLBSPRequest* pRequest,
    INetReply*    pReply,
    CPerfCounters*  pPerfCounters
)
{
    _pInfo    = pInfo;
    _pRequest = pRequest;
    _pReply   = pReply;
    _pPerfCounters = pPerfCounters;
}

CRequestTask::~CRequestTask()
{
    DBGASSERT(_pReply == NULL);
}

void CRequestTask::Execute(IUmsClient *pUmsClient)
{
    CArenaMemAlloc alloc;
    DWORD dwError = 0;
    CGlobalError::Reset();

    WORD wProcCount = _pRequest->GetProcCount();
    for(int iProc=0; iProc < wProcCount; iProc++)
    {
        CLBSPProcedure* pProc = _pRequest->GetProcedure(iProc);
        LbProcHandler procHandler = _pInfo->GetProcHandler(pProc->GetProcId());

        if(NULL == procHandler)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Invalid procedure id %u at index %d",
                pProc->GetProcId(), iProc);

            dwError = LbspErrorInvalidProcId;
            goto lDone;
        }

        alloc.Reset();

        dwError = procHandler(pUmsClient, _pInfo, pProc, _pReply, &alloc, _pPerfCounters);
        if(dwError != 0)
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                "Procedure index %d failed", iProc);
            goto lDone;
        }

        DBGASSERT(pUmsClient->GetAllLockCount()==0);
    }

lDone:

    if(dwError != 0)
    {
        // Add a dump of the request to the error message
        CLargeStr dump;
        _pRequest->Dump(&dump);

        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
            "Request dump:\n%s\n", dump.cstr());

        // Log error message to the event log
        XomNtEvent(XEVENT_STATS_CODE_41, "ErrorId:%u\n%s",
            dwError, CGlobalError::GetCurrentMessage());

        // Send error message
        _pReply->ReplyMessage(dwError, CGlobalError::GetCurrentMessage());
    }

    _pReply->ReplyDone();
    _pReply = NULL;
}

void CRequestTask::Free()
{
    delete this;
}


/*****************************************************************************
  CRequestManager
*****************************************************************************/

CRequestManager::CRequestManager()
{
    _pUMS = NULL;
}

bool CRequestManager::Init(
    CConfig* pConfig,
    UMS* pUMS,
    CLbList* pLbList,
    CPerfCounters* pPerfCounters
)
{
    _pConfig = pConfig;
    _pUMS    = pUMS;
    _pLbList = pLbList;
    _pPerfCounters = pPerfCounters;
    _procs.Reset();

    return true;
}

void CRequestManager::Term()
{
    _procs.Term();
}

bool CRequestManager::RegisterProc(
    DWORD dwProcId,
    LbProcHandler procHandler
)
{
    bool fRet = false;

    if(_procs.Get(dwProcId, NULL))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "There is already a procedure id %u", dwProcId);
        goto lDone;
    }

    if(!_procs.Set(dwProcId, procHandler))
        goto lDone;

    fRet = true;

lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return fRet;
}

bool CRequestManager::OnNewRequest(
    CLBSPRequest *pRequest,
    INetReply *pReply
)
{
    bool fRet = false;
    CRequestTask* pNewTask = new CRequestTask(this, pRequest,pReply,_pPerfCounters);

    if(NULL == pNewTask)
        goto lDone;

    if(!_pUMS->AddNewTask(pNewTask))
        goto lDone;

    pNewTask = NULL;

    fRet = true;

lDone:

    if(pNewTask != NULL)
    {
        delete pNewTask;
        pNewTask = NULL;
    }

    if(!fRet)
    {
        XomNtEvent(XEVENT_STATS_CODE_42, GLOBAL_ERROR_HEADER
            "%s", CGlobalError::GetCurrentMessage());
    }

    return fRet;
}


/*****************************************************************************
  CLbRemoteProc
*****************************************************************************/

bool CLbRemoteProc::Register(CRequestManager* pRM)
{
    if(!pRM->RegisterProc(LbProcIdLoadLb,                     CreateLb)                || 
       !pRM->RegisterProc(LbProcIdDeleteLb,                   DeleteLb)                ||
       !pRM->RegisterProc(LbProcIdDeleteLbFromMemoryOnly,     DeleteLbFromMemoryOnly)  ||
       !pRM->RegisterProc(LbProcIdStatRead,                   StatRead)                ||
       !pRM->RegisterProc(LbProcIdStatWrite,                  StatWrite)               ||
       !pRM->RegisterProc(LbProcIdStatEnum,                   StatEnum)                ||
       !pRM->RegisterProc(LbProcIdDeleteTitle,                DeleteTitle)             ||
       !pRM->RegisterProc(LbProcIdGetLbRankedEntryCount,      GetLbRankedEntryCount)   ||
       !pRM->RegisterProc(LbProcIdResetPuid,                  ResetPuid)               ||
       !pRM->RegisterProc(LbProcIdStatEnumNearPuid,           StatEnumNearPuid)        ||
       !pRM->RegisterProc(LbProcIdResetLb,                    ResetLb)                 ||
       !pRM->RegisterProc(LbProcIdStatEnumNearRating,         StatEnumNearRating)      ||
       !pRM->RegisterProc(LbProcIdSetLbToReadOnly,            SetLbToReadOnly )        ||
       !pRM->RegisterProc(LbProcIdSetLbToReadWrite,           SetLbToReadWrite )       ||
       !pRM->RegisterProc(LbProcIdIsSafeToDeleteLb,           IsSafeToDeleteLb)        ||
       !pRM->RegisterProc(LbProcIdCreateAndLoadOneLb,         CreateAndLoadOneLb)      ||
       !pRM->RegisterProc(LbProcIdGetLbStatus,                GetLbStatus)             ||
       !pRM->RegisterProc(LbProcIdEstimateRankForRatings,     EstimateRankForRatings)  ||
       !pRM->RegisterProc(LbProcIdCheckConnection,            CheckConnection)         ||
       !pRM->RegisterProc(LbProcIdTestAutoReset,              TestAutoReset)           ||
       !pRM->RegisterProc(LbProcIdTestAutoDecay,              TestAutoDecay)           ||
       !pRM->RegisterProc(LbProcIdTestAutoTrim,               TestAutoTrim)            ||
       !pRM->RegisterProc(LbProcIdTestChangeLastUpdateTime,   TestChangeLastUpdateTime))
    {
        return false;
    }

    return true;
}

//either the tree structure swapped twice or there is nothing for the persister to do
DWORD CLbRemoteProc::IsSafeToDeleteLb( 
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    )
{
    DWORD dwError = LbspErrorUnexpected;
    DWORD dwLastSwap = 0;
    bool  fSafe = false;

    if(   !pProc->GetInt32 (0, (INT32*)&dwLastSwap))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    bool fPersisterThreadSleeping = pInfo->GetLbList()->IsPersisterThreadSleeping();
    if (!fPersisterThreadSleeping)
    {
        DWORD dwCurrentSwap =
            pInfo->GetLbList()->GetSwapCount();

        if ((dwCurrentSwap > dwLastSwap) && (dwCurrentSwap-dwLastSwap >= 2))
        {
            fSafe = true;
        }
        else if ((dwCurrentSwap < dwLastSwap) && (0xFFFFFFFF - dwLastSwap + dwCurrentSwap >= 2)) //the 0xFFFFFFFF represent the MAX DWORD, not sure how else to get it
        {
            fSafe = true;
        }   
    }
    else
        fSafe = true;

    //time to send the size back    
    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumn;

    rgColumn.bType = LbspTypeIdInt8;
    rgColumn.i8    = (INT8) fSafe;

    if(!pReply->RowsetRow(&rgColumn, 1))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return dwError;

}



//OPS Proc
DWORD CLbRemoteProc::SetLbToReadOnly( 
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    return SetLbStatusCommon(pUmsClient, pInfo, pProc, pReply, pAlloc, CLb::ReadOnly);
}

//OPS Proc
DWORD CLbRemoteProc::SetLbToReadWrite( 
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    return SetLbStatusCommon(pUmsClient, pInfo, pProc, pReply, pAlloc, CLb::ReadWrite);
}

DWORD CLbRemoteProc::SetLbStatusCommon( 
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CLb::LbStatus newlbstatus
)
{
    DWORD dwError = LbspErrorUnexpected;

    DWORD     dwTitleId;
    DWORD     dwLbId;

    CLb* pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbStatus;

    if (!pLb->GetLbStatus(&lbStatus))
        goto lDone;

    if (lbStatus == CLb::Loading) //if it is loading you can't change its status - got to wait until it is complete
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard is still loading - Can't Change Status. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        goto lDone;
    }
    
    if (!pLb->SetLbStatus(newlbstatus))
        goto lDone;

    DWORD dwSwapCount =
            pInfo->GetLbList()->GetSwapCount();

    //time to send the swap Count, the user will call IsSafeToDeleteLb with this swap count   
    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumn;

    rgColumn.bType = LbspTypeIdInt32;
    rgColumn.i32   = (INT32) dwSwapCount;

    if(!pReply->RowsetRow(&rgColumn, 1))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

 lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }


    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return dwError;
}

DWORD CLbRemoteProc::EstimateRankForRatings(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    )
{
    XTimeElapsed timeElapsed;
    DWORD dwError = LbspErrorUnexpected;
    DWORD dwTitleId;
    DWORD dwLbId  = 0;
    CLb* pLb      = NULL;
    
    if(!pProc->GetInt32 (0, (INT32*)&dwTitleId) ||
       !pProc->GetInt32 (1, (INT32*)&dwLbId) 
       )
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    CLbList::GetLbStatus getLbStatus = pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for EstimateRankForRatings. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    DWORD dwParamCount = pProc->GetParamCount();
    DWORD dwParam      = 2;

    if(!pReply->RowsetBegin())
        goto lDone;

    for(; dwParam < dwParamCount; dwParam++)
    {
        INT64 i64Rating   = 0;

        if(!pProc->GetInt64(dwParam,(INT64*)&i64Rating))
        {
            dwError = LbspErrorInvalidParam;
            goto lDone;
        }

        LbKey lbkey;
        lbkey.ui64Untier  = 0;
        lbkey.i64Rating = i64Rating;
        DWORD dwExpectedRank = 0;
        
        pLb->GetRankForLbkey(pUmsClient, lbkey, pAlloc, &dwExpectedRank);

        LbStat rgColumn;

        rgColumn.bType = LbspTypeIdInt32;
        rgColumn.i32   = (INT32) dwExpectedRank;

        if(!pReply->RowsetRow(&rgColumn, 1))
            goto lDone;
    }

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

 lDone:

    if(pLb != NULL)
    {
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_ESTIMATE_RANK_RATE_INSTANCED, 1);
        pLb->InstancedPerfCounterIncrementValue64(pPerfCounters, LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_INSTANCED, timeElapsed.OneHundredNanoElapsed());
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_BASE_INSTANCED, 1);

        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return dwError;
}

DWORD CLbRemoteProc::GetLbStatus(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo,
        CLBSPProcedure* pProc,
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    )
{
    DWORD dwError = LbspErrorUnexpected;

    DWORD dwTitleId;
    DWORD dwLbId;

    CLb* pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }

    CLb::LbStatus lbStatus;

    if (!pLb->GetLbStatus(&lbStatus))
        goto lDone;

    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumn;

    rgColumn.bType = LbspTypeIdInt32;
    rgColumn.i32   = (INT32) lbStatus;

    if(!pReply->RowsetRow(&rgColumn, 1))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    return dwError;



}

//This is really Create LB
DWORD CLbRemoteProc::CreateLb(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    ConfigLbInfo lbInfo;


    DWORD     dwTitleId;
    DWORD     dwLbId;
    CConstStr strParam;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard information from config db
    ZeroMemory(&lbInfo, sizeof(ConfigLbInfo));

    CConfig::GetLbInfoStatus getLbStatus =
        pInfo->GetConfig()->GetLbInfo(dwTitleId, dwLbId, &lbInfo);

    if(CConfig::GetLbInfoStatusDifferentServer == getLbStatus)
    {
        dwError = LbspErrorLbWrongServer;
        goto lDone;
    }
    else if(CConfig::GetLbInfoStatusNotFound == getLbStatus)
    {
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CConfig::GetLbInfoStatusSucceeded)
    {
        goto lDone;
    }

    // Create leaderboard
    CLbList::CreateLbStatus createStatus =
        pInfo->GetLbList()->CreateLb(pUmsClient, dwTitleId, dwLbId,
        (LbResetType)lbInfo.lbReset, lbInfo.uiDecayDays,
        lbInfo.fTop100 ? LbTop100 : 0, lbInfo.lastReset, NULL);

    if(createStatus != CLbList::CreateLbStatusSucceeded)
        goto lDone;

    dwError = 0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "LoadLb -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId);

    return dwError;
}



////OPS Proc
DWORD CLbRemoteProc::CreateAndLoadOneLb(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    ConfigLbInfo lbInfo;

    DWORD     dwTitleId;
    DWORD     dwLbId;
    CConstStr strParam;

    CLb *pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound != getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard ALREADY exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        goto lDone;
    }

    // Get leaderboard information from config db
    ZeroMemory(&lbInfo, sizeof(ConfigLbInfo));

    CConfig::GetLbInfoStatus getLbConfigStatus =
        pInfo->GetConfig()->GetLbInfo(dwTitleId, dwLbId, &lbInfo);

    if(CConfig::GetLbInfoStatusNotFound == getLbConfigStatus)
    {
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }

    // Create leaderboard
    CLbList::CreateLbStatus createStatus =
        pInfo->GetLbList()->CreateAndLoadOneLB(pUmsClient, &lbInfo);

    if(createStatus != CLbList::CreateLbStatusSucceeded)
        goto lDone;

    getLbStatus = pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusSucceeded!= getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Can't be found. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        goto lDone;
    }

    if (!pLb->SetLbStatus(CLb::ReadOnly)) //Everything good - set it to Read Only by Default
        goto lDone;

    dwError = 0;

lDone:

    if (pLb != NULL)
    { 
        pLb->Release();
        pLb = NULL;
    }   

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "LoadLb -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId);

    return dwError;
}

/*
    This will not delete from database. It is only used during leaderboard moves
    Ops Proc
*/
DWORD CLbRemoteProc::DeleteLbFromMemoryOnly(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;

    DWORD dwTitleId;
    DWORD dwLbId;
    CLb   *pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    //The LB Status MUST be in Unloading Mode. This is different from Delete LB.
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard need to be set to ReadOnly for DeleteLbFromMemoryOnly. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    if (!pLb->SetLbStatus(CLb::UnLoading)) //now set it to unloading status so even read will start failing
        goto lDone;

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    //we are ready to unload the leaderboard without deleting it from the database
    //we just want to free the memory
    //the false in fPersist will do the trick
    CLbList::DeleteLbStatus deleteStatus =
        pInfo->GetLbList()->DeleteLb(pUmsClient,dwTitleId,dwLbId,false);

    if(CLbList::DeleteLbStatusNotFound == deleteStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(deleteStatus != CLbList::DeleteLbStatusSucceeded)
    {
        goto lDone;
    }

    dwError = 0;

lDone:

    if (pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    return dwError;
    
}


DWORD CLbRemoteProc::DeleteLb(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;

    DWORD dwTitleId;
    DWORD dwLbId;
    CLb   *pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

      // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for DeleteLb. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    // Delete from config server
    CConfig::DeleteLbStatus cfgDeleteStatus =
        pInfo->GetConfig()->DeleteLb(dwTitleId,dwLbId);

    if(cfgDeleteStatus != CConfig::DeleteLbStatusSucceeded &&
       cfgDeleteStatus != CConfig::DeleteLbStatusLbNotFound)
    {
        goto lDone;
    }

    CLbList::DeleteLbStatus deleteStatus =
        pInfo->GetLbList()->DeleteLb(pUmsClient,dwTitleId,dwLbId,true);

    if(CLbList::DeleteLbStatusNotFound == deleteStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(deleteStatus != CLbList::DeleteLbStatusSucceeded)
    {
        goto lDone;
    }

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "DeleteLb -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId);

    return dwError;
}

DWORD CLbRemoteProc::DeleteTitle(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;

    DWORD dwTitleId;

    if(!pProc->GetInt32 (0, (INT32*)&dwTitleId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get the list of leaderboards
    LbTitleLbIdKey* rgLbList = NULL;
    DWORD dwLbCount = 0;
    if(!pInfo->GetLbList()->GetLbList(&g_MemAlloc, &rgLbList, &dwLbCount))
        goto lDone;

    CLb *pLb = NULL;
    for(DWORD i=0; i < dwLbCount; i++)
    {
        if(rgLbList[i].dwTitleId != dwTitleId)
            continue;
    
         // Get leaderboard
        CLbList::GetLbStatus getLbStatus =
            pInfo->GetLbList()->GetLb(dwTitleId,rgLbList[i].dwLbId,&pLb);

        if(CLbList::GetLbStatusNotFound == getLbStatus)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
                dwTitleId, rgLbList[i].dwLbId, rgLbList[i].dwLbId);
            dwError = LbspErrorLbDoesntExist;
            goto lDone;
        }
        else if(getLbStatus != CLbList::GetLbStatusSucceeded)
        {
            goto lDone;
        }

        CLb::LbStatus lbstatus; 

        if (!pLb->GetLbStatus(&lbstatus))
            goto lDone;

        if (lbstatus != CLb::ReadWrite)
        {
            dwError = LbspErrorOperationNotPermitted;
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Leaderboard Not Ready for DeleteTitle. TitleId=0x%08x, LbId=%u(0x%08x)",
                dwTitleId, rgLbList[i].dwLbId, rgLbList[i].dwLbId);
                
            goto lDone;
        }

        if (pLb != NULL)
        {
            pLb->Release();
            pLb = NULL;
        }
    
    }


    // Delete all leaderboards of a title id
    for(DWORD i=0; i < dwLbCount; i++)
    {
        if(rgLbList[i].dwTitleId != dwTitleId)
            continue;

        // Delete from config server
        CConfig::DeleteLbStatus cfgDeleteStatus =
            pInfo->GetConfig()->DeleteLb(rgLbList[i].dwTitleId,
                rgLbList[i].dwLbId);

        if(cfgDeleteStatus != CConfig::DeleteLbStatusSucceeded)
        {
            if(cfgDeleteStatus != CConfig::DeleteLbStatusLbNotFound)
            {
                goto lDone;
            }
            else
            {
                XomNtEvent(XEVENT_STATS_CODE_43,
                    "This is just a warning: \n"
                    "DeleteLb returned DeleteLbStatusLbNotFound. "
                    "TitleId: 0x%08x LbId: %u", rgLbList[i].dwTitleId,
                    rgLbList[i].dwLbId);
            }
        }

        CLbList::DeleteLbStatus deleteStatus =
            pInfo->GetLbList()->DeleteLb(pUmsClient, rgLbList[i].dwTitleId,
                rgLbList[i].dwLbId, true);

        if(deleteStatus != CLbList::DeleteLbStatusSucceeded)
            goto lDone;
    }

    dwError = 0;

lDone:
    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if (NULL != rgLbList)
    {
        g_MemAlloc.Free(rgLbList);
        rgLbList = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "DeleteTitle -- dwError %x, dwExecTime: %d, TitleID: %08x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId);

    return dwError;
}

DWORD CLbRemoteProc::StatRead(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    XTimeElapsed timeElapsed;

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    DWORD dwTitleId;
    DWORD dwLbId;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    DWORD dwParamCount = pProc->GetParamCount();
    DWORD dwParam      = 2;

    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for StatRead. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }
    
    for(; dwParam < dwParamCount; dwParam++)
    {
        pAlloc->Reset();

        UINT64 puid;
        if(!pProc->GetInt64(dwParam,(INT64*)&puid))
        {
            dwError = LbspErrorInvalidParam;
            goto lDone;
        }

        LbStat* pStats = NULL;
        DWORD   cStats = 0;
        DWORD   dwRank = 0;
        CLb::StatReadStatus readStatus =
            pLb->StatRead(pUmsClient,puid,pAlloc,&pStats,&cStats, &dwRank, NULL);

        if(CLb::StatReadStatusNotFound == readStatus)
        {
            continue;
        }
        else if(readStatus != CLb::StatReadStatusSucceeded)
        {
            goto lDone;
        }

        if(cStats > 0)
        {
            if(!pReply->RowsetBegin())
                goto lDone;

            DWORD cColumns = 3 + (cStats*2);
            LbStat* rgColumns = new (*pAlloc) LbStat[cColumns];
            if(NULL == rgColumns)
                goto lDone;

            rgColumns[0].bType = LbspTypeIdInt32;
            rgColumns[0].i32   = (INT32) dwLbId;

            rgColumns[1].bType = LbspTypeIdInt64;
            rgColumns[1].i64   = (INT64) puid;

            if(dwRank != 0)
            {
                rgColumns[2].bType = LbspTypeIdInt32;
                rgColumns[2].i32   = dwRank;
            }
            else
            {
                rgColumns[2].bType = LbspTypeIdInt32 | LbspTypeIdNullFlag;
            }

            for(int iStat=0; (DWORD)iStat < cStats; iStat++)
            {
                rgColumns[3 + (iStat*2)].bType = LbspTypeIdInt16;
                rgColumns[3 + (iStat*2)].i16   = pStats[iStat].statId;
                rgColumns[3 + (iStat*2)+1]     = pStats[iStat];
            }

            if(!pReply->RowsetRow(rgColumns, cColumns))
                goto lDone;

            if(!pReply->RowsetEnd())
                goto lDone;
        }
    }

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_READ_RATE_INSTANCED, 1);
        pLb->InstancedPerfCounterIncrementValue64(pPerfCounters, LBPERF_SERVER_STAT_READ_EXEC_TIME_INSTANCED, timeElapsed.OneHundredNanoElapsed());
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_READ_EXEC_TIME_BASE_INSTANCED, 1);

        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "StatRead -- dwError %x, dwExecTime: %I64u, TitleID: %08x, dwLbId: %08x, dwParamCount: %d",
              dwError,
              timeElapsed.OneHundredNanoElapsed(),
              dwTitleId,
              dwLbId,
              dwParamCount);

    return dwError;
}

DWORD CLbRemoteProc::StatWrite(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    XTimeElapsed timeElapsed;
    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    DWORD  dwTitleId;
    DWORD  dwLbId;
    UINT64 puid;
    INT64  logonTime; // TODO: implement
    WORD   wStatCount;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt64 (2, (INT64*)&puid)
       || !pProc->GetInt64 (3, &logonTime)
       || !pProc->GetInt16 (4, (INT16*)&wStatCount))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    if(pProc->GetParamCount() != 5 + (wStatCount * 2))
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Number of parameters doesn't match number of stats specified"
            "in parameter wStatCount");
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    LbStat* rgStats = new (*pAlloc) LbStat[wStatCount];
    if(NULL == rgStats)
        goto lDone;

    int iLastStat = -1;
    for(int i=0; i < wStatCount; i++)
    {
        WORD wStatId;
        if(!pProc->GetInt16(5 + (i*2), (INT16*)&wStatId))
        {
            dwError = LbspErrorInvalidParam;
            goto lDone;
        }

        if(wStatId < iLastStat)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "Stats must be sorted by StatId.");
            dwError = LbspErrorInvalidParam;
            goto lDone;
        }

        iLastStat = wStatId;

        CLBSPParam* pParam;
        if(!pProc->GetParam(5 + (i*2)+1, &pParam))
        {
            dwError = LbspErrorInvalidParam;
            goto lDone;
        }

        rgStats[i]        = *(LbStat*)pParam;
        rgStats[i].statId = (LbStatId) wStatId;
    }

    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for StatWrite. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    if(!pLb->StatWrite(pUmsClient,puid,rgStats,wStatCount))
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_WRITE_RATE_INSTANCED, 1);
        pLb->InstancedPerfCounterIncrementValue64(pPerfCounters, LBPERF_SERVER_STAT_WRITE_EXEC_TIME_INSTANCED, timeElapsed.OneHundredNanoElapsed());
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_WRITE_EXEC_TIME_BASE_INSTANCED, 1);

        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "StatWrite -- dwError %x, dwExecTime: %I64u, TitleID: %08x, dwLbId: %08x, puid: %I64x, wStatCount: %d",
              dwError,
              timeElapsed.OneHundredNanoElapsed(),
              dwTitleId,
              dwLbId,
              puid,
              wStatCount);

    return dwError;
}

class CEnumCallback : public ILbEnumCallback
{
public:

    CEnumCallback(
        INetReply* pReply,
        CArenaMemAlloc* pAlloc)
    {
        _pReply = pReply;
        _pAlloc = pAlloc;
    }

protected:

    // ILbEnumCallback

    virtual bool OnNewRow(
        DWORD  dwRank,
        UINT64 puid,
        LbStat* rgStats,
        DWORD cStats
    )
    {
        bool fRet = false;

        DWORD cColumns = 2 + (cStats * 2) ;
        LbStat* rgColumns = new (*_pAlloc) LbStat[cColumns];
        if(NULL == rgColumns)
            goto lDone;

        rgColumns[0].bType = LbspTypeIdInt32;
        rgColumns[0].i32   = (INT32) dwRank;

        rgColumns[1].bType = LbspTypeIdInt64;
        rgColumns[1].i64   = (INT64) puid;

        for(int iStat=0; (DWORD)iStat < cStats; iStat++)
        {
            // Stat Id
            rgColumns[2 + (iStat*2)].bType = LbspTypeIdInt16;
            rgColumns[2 + (iStat*2)].i16   = rgStats[iStat].statId;

            // Stat value
            rgColumns[2 + (iStat*2) + 1] = rgStats[iStat];
        }

        if(!_pReply->RowsetRow(rgColumns, cColumns))
            goto lDone;

        fRet = true;

    lDone:

        _pAlloc->Reset();

        if(!fRet)
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER);

        return fRet;
    }

    INetReply* _pReply;
    CArenaMemAlloc* _pAlloc;
};

DWORD CLbRemoteProc::StatEnum(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    XTimeElapsed timeElapsed;

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    // Get parameters

    DWORD dwTitleId;
    DWORD dwLbId;
    DWORD dwStartingRank;
    DWORD dwEntryCount;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt32 (2, (INT32*)&dwStartingRank)
       || !pProc->GetInt32 (3, (INT32*)&dwEntryCount))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for Stat Enum. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }


    // First rowset contains the rows that were requested
    if(!pReply->RowsetBegin())
        goto lDone;

    {
        CEnumCallback enumCallback(pReply, pAlloc);

        if(!pLb->EnumByRank(pUmsClient,dwStartingRank,dwEntryCount,&enumCallback))
            goto lDone;
    }

    if(!pReply->RowsetEnd())
        goto lDone;

    // Second rowset contains one row with the leaderboard size (or the
    // number of ranked entries) and the datetime of the last time the
    // leaderboard was reset
    INT32 cRankedEntries = pLb->GetRankedEntryCount();

    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumns[2];
    rgColumns[0].bType = LbspTypeIdInt32;
    rgColumns[0].i32   = cRankedEntries;
    rgColumns[1].bType = LbspTypeIdInt64;
    rgColumns[1].i64   = (INT64) pLb->GetLastResetTime();

    if(!pReply->RowsetRow(rgColumns, ARRAY_SIZE(rgColumns)))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_ENUM_RATE_INSTANCED, 1);
        pLb->InstancedPerfCounterIncrementValue64(pPerfCounters, LBPERF_SERVER_STAT_ENUM_EXEC_TIME_INSTANCED, timeElapsed.OneHundredNanoElapsed());
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_ENUM_EXEC_TIME_BASE_INSTANCED, 1);

        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "StatEnum -- dwError %x, dwExecTime: %I64u, TitleID: %08x, dwLbId: %08x, dwStartingRank: %d, wStatCount: %d",
              dwError,
              timeElapsed.OneHundredNanoElapsed(),
              dwTitleId,
              dwLbId,
              dwStartingRank,
              dwEntryCount);

    return dwError;
}

DWORD CLbRemoteProc::StatEnumNearPuid(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    // Get parameters
    DWORD  dwTitleId;
    DWORD  dwLbId;
    UINT64 puid;
    DWORD  dwEntryCount;
    BYTE   fCenter;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt64 (2, (INT64*)&puid)
       || !pProc->GetInt32 (3, (INT32*)&dwEntryCount)
       || !pProc->GetInt8  (4, (INT8*) &fCenter))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for StatEnumNearPuid. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    DWORD dwRank;
    CLb::GetRankForPuidStatus getRankStatus =
        pLb->GetRankForPuid(pUmsClient,puid,&dwRank);

    if(getRankStatus == CLb::GetRankForPuidStatusPuidNotFound)
    {
        // The puid was not found or it's not ranked.
        // Succeed, but return no rowsets.
        dwError = 0;
        goto lDone;
    }
    else if(getRankStatus != CLb::GetRankForPuidStatusSucceeded)
    {
        goto lDone;
    }

    int iStartingEntry;
    INT32 cRankedEntries = pLb->GetRankedEntryCount();
    if(fCenter)
    {
        // The list is to be retrieved with the row referenced by puid in
        // the center.

        iStartingEntry = ((int)dwRank) - (((int)dwEntryCount)/2);

        if (iStartingEntry + (INT32)dwEntryCount > cRankedEntries)
        {
            iStartingEntry = max(1, (cRankedEntries - (INT32)dwEntryCount) + 1);
        }

        if(iStartingEntry <= 0)
            iStartingEntry = 1;
    }
    else
    {
        // The list is to be retrieved with the starting rank aligned to
        // dwEntryCount.

        iStartingEntry = ((((int)dwRank)-1) / ((int)dwEntryCount)) * ((int)dwEntryCount) + 1;
    }

    // First rowset contains the rows that were requested
    if(!pReply->RowsetBegin())
        goto lDone;

    {
        CEnumCallback enumCallback(pReply, pAlloc);

        if(!pLb->EnumByRank(pUmsClient,(DWORD)iStartingEntry,dwEntryCount,&enumCallback))
            goto lDone;
    }

    if(!pReply->RowsetEnd())
        goto lDone;

    // Second rowset contains one row with the leaderboard size (or the
    // number of ranked entries)

    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumns[2];
    rgColumns[0].bType = LbspTypeIdInt32;
    rgColumns[0].i32   = cRankedEntries;
    rgColumns[1].bType = LbspTypeIdInt64;
    rgColumns[1].i64   = (INT64) pLb->GetLastResetTime();

    if(!pReply->RowsetRow(rgColumns, ARRAY_SIZE(rgColumns)))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "StatEnumNearPuid -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x, puid: %I64x, dwEntryCount: %d, fCenter: %d",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId,
              puid,
              dwEntryCount,
              fCenter);

    return dwError;
}

DWORD CLbRemoteProc::StatEnumNearRating(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    // Get parameters
    DWORD  dwTitleId;
    DWORD  dwLbId;
    UINT64 rating;
    DWORD  dwEntryCount;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt64 (2, (INT64*)&rating)
       || !pProc->GetInt32 (3, (INT32*)&dwEntryCount))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus = pInfo->GetLbList()->GetLb(dwTitleId, dwLbId, &pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for StatEnumNearRating. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }


    // First rowset contains the rows that were requested
    if(!pReply->RowsetBegin())
    {
        goto lDone;
    }

    {
        LbKey key;
        key.ui64Untier = 0;
        key.i64Rating = rating;

        CEnumCallback enumCallback(pReply, pAlloc);

        if(!pLb->EnumByRating(pUmsClient,key, dwEntryCount,&enumCallback))
            goto lDone;
    }

    if(!pReply->RowsetEnd())
        goto lDone;


    // Second rowset contains one row with the leaderboard size (or the
    // number of ranked entries)
    INT32 cRankedEntries = pLb->GetRankedEntryCount();

    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rgColumns[2];
    rgColumns[0].bType = LbspTypeIdInt32;
    rgColumns[0].i32   = cRankedEntries;
    rgColumns[1].bType = LbspTypeIdInt64;
    rgColumns[1].i64   = (INT64) pLb->GetLastResetTime();

    if(!pReply->RowsetRow(rgColumns, ARRAY_SIZE(rgColumns)))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "StatEnumNearRating -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x, rating: %I64x, dwEntryCount: %d",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId,
              rating,
              dwEntryCount);

    return dwError;
}

DWORD CLbRemoteProc::GetLbRankedEntryCount(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    // Get parameters
    DWORD dwTitleId;
    DWORD dwLbId;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadOnly && lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for GetLbRankedEntryCount. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    // Read the ranked entry count from the leaderboard
    INT32 cRankedEntries = pLb->GetRankedEntryCount();

    // Return a rowset with a single row with just one column containing
    // the number of ranked entries in the leaderboard
    if(!pReply->RowsetBegin())
        goto lDone;

    LbStat rankedEntryCountColumn;
    rankedEntryCountColumn.bType = LbspTypeIdInt32;
    rankedEntryCountColumn.i32   = cRankedEntries;

    if(!pReply->RowsetRow(&rankedEntryCountColumn, 1))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "GetLbRankedEntryCount -- dwError %x, dwExecTime: %d, TitleID: %08x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId);

    return dwError;
}

DWORD CLbRemoteProc::ResetPuid(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    // Get parameters
    DWORD dwTitleId;
    DWORD dwLbId;
    UINT64 puid;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt64 (2, (INT64*)&puid))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for ResetPuid. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    if(!pLb->ResetPuid(pUmsClient, puid))
        goto lDone;

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "ResetPuid -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x, puid: %I64x",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId,
              puid);

    return dwError;
}

DWORD CLbRemoteProc::ResetLb(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    XTimeElapsed timeElapsed;

    DWORD dwError = LbspErrorUnexpected;

    DWORD dwTitleId;
    DWORD dwLbId;

    CLb* pLb = NULL;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    CLb::LbStatus lbstatus; 

    if (!pLb->GetLbStatus(&lbstatus))
        goto lDone;

    if (lbstatus != CLb::ReadWrite)
    {
        dwError = LbspErrorOperationNotPermitted;
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard Not Ready for ResetLb. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
            
        goto lDone;
    }

    CLbList::ResetLbStatus resetStatus =
        pInfo->GetLbList()->ResetLb(pUmsClient,dwTitleId,dwLbId);

    if(CLbList::ResetLbStatusNotFound == resetStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(resetStatus != CLbList::ResetLbStatusSucceeded)
    {
        goto lDone;
    }

    dwError = 0;

lDone:

    if(pLb != NULL)
    {
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_RESET_RATE_INSTANCED, 1);
        pLb->InstancedPerfCounterIncrementValue64(pPerfCounters, LBPERF_SERVER_STAT_RESET_EXEC_TIME_INSTANCED, timeElapsed.OneHundredNanoElapsed());
        pLb->InstancedPerfCounterIncrementValue32(pPerfCounters, LBPERF_SERVER_STAT_RESET_EXEC_TIME_BASE_INSTANCED, 1);

        pLb->Release();
        pLb = NULL;
    }

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "ResetLb -- dwError %x, dwExecTime: %I64u, TitleID: %08x, dwLbId: %08x",
              dwError,
              timeElapsed.OneHundredNanoElapsed(),
              dwTitleId,
              dwLbId);

    return dwError;
}


DWORD CLbRemoteProc::CheckConnection(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();
    DWORD dwError = LbspErrorUnexpected;	
    LbStat rgColumn;
	
    if(!pReply->RowsetBegin())
        goto lDone;

    rgColumn.bType = LbspTypeIdInt8;
    rgColumn.i8    = (INT8) LbConstantConnected;

    if(!pReply->RowsetRow(&rgColumn, 1))
        goto lDone;

    if(!pReply->RowsetEnd())
        goto lDone;

    dwError = 0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "CheckConnection -- dwError %x, dwExecTime: %d ",
              dwError,
              GetTickCount() - dwStartTicks);

    return dwError;

}



DWORD CLbRemoteProc::TestAutoReset(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();
    DWORD dwError = LbspErrorUnexpected;

    UINT64 timeNow;
    if(!pProc->GetInt64 (0, (INT64*)&timeNow))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    if(!pInfo->GetLbList()->AutoReset(pUmsClient, timeNow))
        goto lDone;

    dwError =0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "TestAutoReset -- dwError %x, dwExecTime: %d",
              dwError,
              GetTickCount() - dwStartTicks);

    return dwError;
}

DWORD CLbRemoteProc::TestAutoTrim(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();
    DWORD dwError = LbspErrorUnexpected;

    if(!pInfo->GetLbList()->AutoTrim(pUmsClient))
        goto lDone;

    dwError =0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "TestAutoTrim -- dwError %x, dwExecTime: %d",
              dwError,
              GetTickCount() - dwStartTicks);

    return dwError;
}


DWORD CLbRemoteProc::TestAutoDecay(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();
    DWORD dwError = LbspErrorUnexpected;

    UINT64 timeNow;
    if(!pProc->GetInt64 (0, (INT64*)&timeNow))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    if(!pInfo->GetLbList()->AutoDecay(pUmsClient, timeNow))
        goto lDone;

    dwError =0;

lDone:

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "TestAutoReset -- dwError %x, dwExecTime: %d",
              dwError,
              GetTickCount() - dwStartTicks);

    return dwError;
}


DWORD CLbRemoteProc::TestChangeLastUpdateTime(
    IUmsClient* pUmsClient,
    CRequestGlobalInfo* pInfo,
    CLBSPProcedure* pProc,
    INetReply* pReply,
    CArenaMemAlloc* pAlloc,
    CPerfCounters* pPerfCounters
)
{
    DWORD dwStartTicks = GetTickCount();

    DWORD dwError = LbspErrorUnexpected;
    CLb* pLb = NULL;

    DWORD dwTitleId;
    DWORD dwLbId;
    DWORD dwDays;

    if(   !pProc->GetInt32 (0, (INT32*)&dwTitleId)
       || !pProc->GetInt32 (1, (INT32*)&dwLbId)
       || !pProc->GetInt32 (2, (INT32*)&dwDays))
    {
        dwError = LbspErrorInvalidParam;
        goto lDone;
    }

    // Get leaderboard
    CLbList::GetLbStatus getLbStatus =
        pInfo->GetLbList()->GetLb(dwTitleId,dwLbId,&pLb);

    if(CLbList::GetLbStatusNotFound == getLbStatus)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "Leaderboard doesn't exist. TitleId=0x%08x, LbId=%u(0x%08x)",
            dwTitleId, dwLbId, dwLbId);
        dwError = LbspErrorLbDoesntExist;
        goto lDone;
    }
    else if(getLbStatus != CLbList::GetLbStatusSucceeded)
    {
        goto lDone;
    }

    if(!pLb->ChangeLastUpdateTimeOfAll(pUmsClient,dwDays))
        goto lDone;

    dwError =0;

lDone:

    if(pLb != NULL)
        pLb->Release();

    if(dwError != 0)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);

    XomTrace(LbsTrace, L_LOW, "TestChangeLastUpdateTime -- dwError %x, dwExecTime: %d, TitleID: %08x, dwLbId: %08x, dwDays: %d",
              dwError,
              GetTickCount() - dwStartTicks,
              dwTitleId,
              dwLbId,
              dwDays);

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\svc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\util.cpp ===
#include "lbs.h"

/* CGlobalError ****************************************************************/

DWORD CGlobalError::_dwTlsSlotLbsError = TLS_OUT_OF_INDEXES;

bool CGlobalError::Init()
{
    CGlobalError* plbsError = NULL;
    bool fRet = true;
    
    // On the first call we must allocate the TLS slot
    if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
    {
        _dwTlsSlotLbsError = TlsAlloc();
        
        if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
        {
            fRet = false;
            goto lDone;
        }
    }
    
    // We use the TLS slot to store an instance of CGlobalError
    plbsError = new CGlobalError();
    
    if(plbsError == NULL)
    {
        fRet = false;
        goto lDone;
    }
        
    // Assign the new instance of CGlobalError to the TLS slot
    if(!TlsSetValue(_dwTlsSlotLbsError, (LPVOID)plbsError))
    {
        fRet = false;
        goto lDone;
    }
    
    plbsError = NULL;
    
lDone:
    
    if(!fRet)
    {
        if(plbsError != NULL)
        {
            delete plbsError;
            plbsError = NULL;
        }
    }
    
    return fRet;
}

void CGlobalError::Term()
{
    if(_dwTlsSlotLbsError != TLS_OUT_OF_INDEXES)
    {
        CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
        
        if(plbsError != NULL)
        {
            delete plbsError;
            TlsSetValue(_dwTlsSlotLbsError, NULL);
        }
    }
}

void CGlobalError::Reset()
{
    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    plbsError->_strMessage.Reset();
}

void CGlobalError::SetMessage(LPCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    
    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    plbsError->_strMessage.Reset();
    plbsError->_strMessage.FormatWithVaList(pszMsg, args);
    plbsError->_strMessage.Concat("\n");
    
    va_end(args);
}

void CGlobalError::AddMessage(LPCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    
    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    plbsError->_strMessage.FormatWithVaList(pszMsg, args);
    plbsError->_strMessage.Concat("\n");
    
    va_end(args);
}

LPCSTR CGlobalError::GetCurrentMessage()
{
    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    return plbsError->_strMessage.cstr();
}

void CGlobalError::ProcessComError()
{
    LCID lcid = GetUserDefaultLCID();
    CComPtr<IErrorInfo> pErrorInfo;
    CComQIPtr<IErrorRecords> pErrorRecords;
    CComPtr<IErrorInfo> pRecord;
    ULONG cRecords = 0;
    
    if(FAILED(GetErrorInfo(0, &pErrorInfo)) || pErrorInfo == NULL)
    {
        AddMessage("(GetErrorInfo returned no information)");
        goto lDone;
    }
    
    pErrorRecords = pErrorInfo;
    if(pErrorRecords != NULL)
    {
        if(FAILED(pErrorRecords->GetRecordCount(&cRecords)))
        {
            AddMessage("pErrorRecords->GetRecordCount failed");
            goto lDone;
        }
        
        for(ULONG i=0; i < cRecords; i++)
        {
            if(FAILED(pErrorRecords->GetErrorInfo(i, lcid, &pRecord)))
            {
                AddMessage("pErrorRecords->GetErrorInfo failed");
                continue;
            }
            
            ProcessErrorInfo(pRecord);
            
            pRecord = NULL;
        }
    }
    else
    {
        ProcessErrorInfo(pErrorInfo);
    }
    
lDone:

    return;
}

void CGlobalError::ProcessErrorInfo(
    IErrorInfo* pErrorInfo
)
{
    CComBSTR bstrDescription;
    CComBSTR bstrSource;
    
    if(FAILED(pErrorInfo->GetDescription(&bstrDescription)) ||
       FAILED(pErrorInfo->GetSource(&bstrSource)))
    {
        AddMessage("Failed to get error description");
        goto lDone;
    }
    
    AddMessage(
        "\n>>Source:"
        "\n%S"
        "\n>>Description:"
        "\n%S"
        "\n",
        (LPCWSTR)bstrSource,
        (LPCWSTR)bstrDescription);
    
lDone:

    return;
}

/* CLFStack ****************************************************************/

void CLFStackBase::Reset()
{
    // Set the pNext pointer of all stack entries to NULL meaning that
    // they are not stacked. But the memory associated with these entries
    // is *NOT* being released.
    
    CSingleLink* pNext = *((CSingleLink**)&_pSingleLinkHead);
    CSingleLink* p;
    
    while(pNext != &_StackEndNode) 
    {
        p = pNext->pNext;
        pNext->pNext = NULL;
        pNext = p;
    }
    
    _pSingleLinkHead = &_StackEndNode;
    
    _lCount = 0;
}

bool CLFStackBase::Push(CSingleLink* pEntry)
{
    DBGASSERT(pEntry->pNext == NULL);
    
    if(pEntry->pNext != NULL)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER"pEntry->pNext != NULL. Entry is already on the stack.");
        return false;
    }

    _lock.Lock();

         // The new node points to the current head.
         pEntry->pNext = *((CSingleLink**)&_pSingleLinkHead);;

         // The new node becomes the current head
         _pSingleLinkHead = pEntry;

         _lCount = _lCount + 1;

    _lock.Unlock();
      
    return true;
}

CSingleLink* CLFStackBase::Pop()
{
    CSingleLink* pR = NULL;

    _lock.Lock();

    if (!IsEmpty())
    {
        DBGASSERT(_lCount > 0);
        pR = *((CSingleLink**)&_pSingleLinkHead);
        _pSingleLinkHead = _pSingleLinkHead->pNext;
        pR->pNext = NULL;
        _lCount = _lCount - 1;
    }
    
    _lock.Unlock();
   
    return pR;
}

/*****************************************************************************
 CListBase
*****************************************************************************/
void CListBase::Enqueue(CDoubleLink* pNewNode)
{
    InsertBefore(&_Tail,pNewNode);
}

CDoubleLink* CListBase::Dequeue()
{
    if(_Head.pNext != &_Tail)
    {
        CDoubleLink* pNode = _Head.pNext;
        Remove(pNode);
        return pNode;
    }
    else
    {
        return NULL;
    }
}

void CListBase::Reset()
{
    while(Dequeue() != NULL)
        ;
    
    DBGASSERT(_Head.pNext == &_Tail);
    DBGASSERT(_Tail.pPrev == &_Head);
    DBGASSERT(_lCount == 0);
}

/**** CMemAlloc *************************************************************/

CMemAlloc g_MemAlloc;

bool CMemAlloc::Init()
{
    return true;
}

void CMemAlloc::Term()
{
#if _DEBUG
    XDumpLeaks();
#endif    
}

void* CMemAlloc::Alloc(size_t size)
{
    void* pBuffer = XAlloc(size);
    
    if(!pBuffer)
        CGlobalError::SetMessage("Memory Allocation Failure!");
    
    return pBuffer;
}

void CMemAlloc::Free(void* memblock)
{
    XFree(memblock);
}

/**** CFixedSizeMemPool ********************************************************/

bool CFixedSizeMemPool::Init(LPCSTR pszName, DWORD cbObject, DWORD cObjects, bool fExpand, IMemAlloc* pAlloc)
{
    bool fRet = true;
    
    if(_cbObject != 0)
    {
        DBGASSERT(!"Pool already Initialized");
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Pool already initialized");
        fRet = false;
        goto lDone;
    }
    
    if(FAILED(StringCbCopyA(_szName, ARRAY_SIZE(_szName), pszName)))
    {
        DBGASSERT(!"StringCbCopy failed. Pool name too big?");
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "StringCbCopy failed. Pool name too big?");
        fRet = false;
        goto lDone;
    }
    
    _cbObject = cbObject;
    _fExpand  = fExpand;
    _pAlloc   = pAlloc;
    
    for(DWORD i=0; i < cObjects; i++)
    {
        CSingleLink* p = (CSingleLink*) AllocNewEntry();
        
        if(p == NULL)
        {
            fRet = false;
            goto lDone;
        }
        
        p->pNext = NULL;
                
        if(!_pool.Push(p))
        {
            fRet = false;
            goto lDone;
        }
    }
   
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "Init(%s, %d, %d, %d)", 
            pszName, cbObject, cObjects, fExpand ? 1 : 0);
    
    return fRet;
}

void CFixedSizeMemPool::Term()
{
    CSingleLink* p = NULL;
    
    while((p = (CSingleLink*)_pool.Pop()) != NULL)
    {
        FreeEntry(p);
    }
    
    _cbObject = 0; 
    _fExpand  = false;
    _pAlloc   = NULL;    
}

void* CFixedSizeMemPool::Alloc(size_t size)
{
    DBGASSERT(size == _cbObject);
    
    CSingleLink* pObject = NULL;
    
    // Try the pool first
    pObject = _pool.Pop();
    if(pObject == NULL)
    {
        // Pool is empty. Should we expand?
        if(_fExpand)
        {
            pObject = (CSingleLink*) AllocNewEntry();

            if(pObject == NULL)
                goto lDone;
        }
        else
        {
            // Pool was not configured to expand. 
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Object memory pool is empty");
            goto lDone;
        }
    }

lDone:
    
    if(pObject == NULL)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%d), PoolName=%s", size, _szName);    
    
    return pObject;
}

void CFixedSizeMemPool::Free(void* memblock)
{
    DBGASSERT(memblock != NULL);
    
    // Return memory to the pool
    CSingleLink* pObject = (CSingleLink*) memblock;
    
    pObject->pNext = NULL;
    
    _pool.Push(pObject);
}

/**** CArenaMemAlloc ********************************************************/

CFixedSizeMemPool CArenaMemAlloc::_pool;
DWORD CArenaMemAlloc::_cbPage = 0;

bool CArenaMemAlloc::GlobalInit(DWORD cbPage, DWORD cInitPages, bool fExpand)
{
    bool fRet = true;
    
    // Adjust cbPage to be a multiple of 1K 
    cbPage = ((cbPage + 1023 + sizeof(memory_page_t)) & ~1023) - sizeof(memory_page_t);
    
    if(!_pool.Init("CArenaMemAlloc", cbPage + sizeof(memory_page_t), 
        cInitPages, fExpand, &g_MemAlloc))
    {
        fRet = false;
        goto lDone;
    }
    
    _cbPage = cbPage;
    
lDone:
    
    if(!fRet)
    {
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%d, %d, %d)", 
            cbPage, cInitPages, fExpand ? 1 : 0);
     }
     
    return fRet;
}

void CArenaMemAlloc::GlobalTerm()
{
    _pool.Term();
}

CArenaMemAlloc::~CArenaMemAlloc()
{
    Term();
}

void CArenaMemAlloc::Term()
{
    // Release all pages
    while(_pCurrentPage != NULL)
    {
        memory_page_t* pNext = _pCurrentPage->pNext;        
        _pool.Free(_pCurrentPage);
        _pCurrentPage = pNext;
    }
}

void* CArenaMemAlloc::Alloc(size_t size)
{
    DBGASSERT(size <= _cbPage);
    DBGASSERT(_cbUsed <= _cbPage);
    
    void* pChunk = NULL;
        
    if(_cbPage == 0)
    {
        DBGASSERT(!"CArenaMemAlloc was not initialized");
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "CArenaMemAlloc was not initialized");
        goto lDone;
    }
    
    if(size > (_cbPage - _cbUsed) || _pCurrentPage == NULL)
    {
        if(size > _cbPage)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Buffer size is greater than page size");
            goto lDone;
        }
        
        // Memory page doesn't have enough space or this is the first page.
        // Allocate a new page.
        memory_page_t* pNewPage = (memory_page_t*) _pool.Alloc(_cbPage + sizeof(memory_page_t));
        
        if(pNewPage == NULL)
            goto lDone;
            
        // Link previous page to it
        pNewPage->pNext = _pCurrentPage;
        
        // And make it current
        _pCurrentPage = pNewPage;
        _cbUsed       = 0;
    }
    
    // Allocate memory by just advancing _cbUsed
    pChunk = &_pCurrentPage->rgBuffer[_cbUsed];
    
    // Advance _cbUsed but Make sure it is always pointer aligned
    _cbUsed = (_cbUsed + size + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);

lDone:
    
    if(pChunk == NULL)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%d)", size);
    
    return pChunk;
}

void CArenaMemAlloc::Free(void* memblock)
{
    // NOP
}

/*****************************************************************************
  CLFQueue
*****************************************************************************/
bool CLFQueue::Init(LPCSTR pszName, int cObjects, bool fExpand, IMemAlloc* pAlloc)
{
    if(!_freeList.Init(pszName, sizeof(node_t), cObjects, fExpand, pAlloc))
        return false;

    _lCount = 0;
    
    return true;
}

void CLFQueue::Term()
{
    if(_lCount > 0)
    {
        void* pData;
        while((pData = Dequeue()) != NULL);
    }
    
    _freeList.Term();
}

bool CLFQueue::Enqueue(void* pData)
{    
    node_t* pNode = NewNode();
    if(NULL == pNode)
        return false;
        
    pNode->pData = pData;
    pNode->pNext = NULL;

    _lock.Lock();
        if (isEmpty())
        {
            DBGASSERT(0 == _lCount);
            _pTail = pNode;
            _pHead = pNode;
        }
        else
        {
            _pTail->pNext = pNode;
            _pTail = pNode;
        }
        _lCount = _lCount + 1;
    _lock.Unlock();
                
    return true;
}

void* CLFQueue::Dequeue()
{
    void * pData = NULL;

    _lock.Lock();
        if (!isEmpty())
        {
            DBGASSERT(0 != _lCount);
            node_t * pNode = (node_t *)_pHead;
            pData = (void *)pNode->pData;
            _pHead = _pHead->pNext; 
            FreeNode(pNode);
            _lCount = _lCount -1;
        }
    _lock.Unlock();
    
    return pData;
}

      
/**** CArrayBase *************************************************************/


bool CArrayBase::SetAllocator(IMemAlloc* pAlloc)
{
    if((_pData == NULL || _pData == _pLocalData) && _iSize == 0)
    {
        _pAlloc = pAlloc;
        return true;
    }
    else
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER " Cannot set allocator after array has been used");
        return false;
    }
}
 
bool CArrayBase::Grow(int iNewCapacity)
{
    bool fRet        = false;
    void* pNewBuffer = NULL;
    
    if(iNewCapacity > _iCapacity)
    {
        pNewBuffer = _pAlloc->Alloc(iNewCapacity * _iDataSize);
        if(pNewBuffer == NULL)
            goto lDone;

        memcpy(pNewBuffer, _pData, _iSize * _iDataSize);

        if(_pData != _pLocalData)
            _pAlloc->Free(_pData);
    
        _pData     = pNewBuffer;
        _iCapacity = iNewCapacity;

        pNewBuffer = NULL;
    }
    
    fRet = true;
    
lDone:
    
    if(pNewBuffer != NULL)
        _pAlloc->Free(pNewBuffer);
        
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}
         
bool CArrayBase::SetSize(int iSize)
{
    bool fRet=false; 
    
    if(iSize > _iCapacity)
    {
        int iNewCapacity = __max(_iCapacity * 2, iSize);
        
        if(!Grow(iNewCapacity))
            goto lDone;
    }
    
    _iSize = iSize;
    fRet = true;

lDone:
    
    return fRet;
}

int THashtableGetPrime(DWORD dwTarget)
{
    static const DWORD rgPrimes[] = { 
        59, 73, 97, 109, 137, 157, 179, 197, 227, 241, 269, 283, 313, 347,
        367, 389, 419, 439, 461, 487, 509, 547, 571, 599, 617, 643, 661, 691, 727, 751,
        773, 811, 829, 859, 883, 919, 947, 977, 1009, 1031, 1051, 1087, 1103, 1129, 1171, 1201,
        1229, 1259, 1289, 1303, 1327, 1381, 1427, 1447, 1471, 1489, 1523, 1553, 1579, 1607, 1621, 1663,
        1697, 1723, 1753, 1787, 1823, 1867, 1879, 1913, 1951, 1993, 2011, 2039, 2081, 2099, 2131, 2153,
        2207, 2239, 2269, 2293, 2333, 2351, 2381, 2399, 2437, 2467, 2521, 2549, 2591, 2621, 2659, 2683,
        2699, 2719, 2749, 2789, 2803, 2843, 2879, 2909, 2953, 2971, 3019, 3049, 3083, 3121, 3169, 3203,
        3229, 3259, 3307, 3329, 3359, 3389, 3433, 3463, 3499, 3529, 3547, 3581, 3613, 3637, 3673, 3701,
        3733, 3769, 3803, 3847, 3877, 3911, 3929, 3967, 4007, 4027, 4073, 4099, 4133, 4159, 4217, 4241,
        4261, 4289, 4339, 4373, 4421, 4451, 4483, 4517, 4549, 4591, 4637, 4651, 4679, 4723, 4759, 4793,
        4817, 4877, 4919, 4943, 4969, 4999, 5003, 5023, 5077, 5101, 5147, 5179, 5227, 5261, 5297, 5333,
        5387, 5413, 5437, 5471, 5501, 5521, 5563, 5591, 5647, 5659, 5693, 5737, 5779, 5807, 5839, 5857,
        5879, 5923, 5981, 6029, 6053, 6089, 6121, 6151, 6199, 6221, 6263, 6287, 6317, 6343, 6367, 6397,
        6451, 6491, 6551, 6571, 6607, 6659, 6689, 6709, 6761, 6791, 6827, 6857, 6883, 6917, 6961, 6983,
        7013, 7043, 7103, 7129, 7187, 7213, 7243, 7297, 7331, 7369, 7433, 7477, 7499, 7529, 7549, 7577,
        7603, 7643, 7681, 7703, 7741, 7789, 7829, 7873, 7901, 7933, 7963, 8017, 8069, 8093, 8123, 8171,
        8219, 8237, 8273, 8297, 8353, 8387, 8429, 8461, 8521, 8543, 8597, 8627, 8663, 8689, 8713, 8741,
        8779, 8819, 8839, 8867, 8929, 8963, 9001, 9029, 9059, 9109, 9151, 9181, 9209, 9241, 9283, 9323,
        9349, 9397, 9421, 9439, 9473, 9511, 9547, 9613, 9631, 9677, 9719, 9743, 9781, 9811, 9839, 9871,
        9907, 9941, 10007, 10111, 10177, 10289, 10321, 10453, 10513, 10639, 10667, 10789, 10867, 10987, 11047, 11149,
        11239, 11329, 11383, 11491, 11587, 11717, 11777, 11863, 11933, 12041, 12073, 12197, 12263, 12379, 12413, 12511,
        12577, 12671, 12713, 12829, 12917, 13007, 13043, 13163, 13241, 13367, 13411, 13523, 13619, 13711, 13751, 13873,
        13921, 14057, 14087, 14249, 14341, 14447, 14489, 14593, 14669, 14767, 14797, 14897, 14983, 15013, 15161, 15299,
        15439, 15601, 15737, 15887, 16061, 16193, 16369, 16547, 16693, 16883, 17027, 17189, 17351, 17483, 17627, 17807,
        17959, 18119, 18251, 18397, 18539, 18743, 18947, 19139, 19289, 19433, 19559, 19751, 19913, 20011, 20147, 20327,
        20477, 20641, 20807, 20981, 21139, 21283, 21467, 21587, 21739, 21881, 22051, 22171, 22367, 22541, 22697, 22853,
        23017, 23143, 23311, 23531, 23633, 23801, 23929, 24083, 24223, 24419, 24611, 24799, 24971, 25013, 25171, 25343,
        25523, 25667, 25841, 25997, 26161, 26309, 26459, 26669, 26783, 26947, 27091, 27281, 27481, 27689, 27799, 27953,
        28109, 28307, 28493, 28619, 28751, 28909, 29101, 29243, 29401, 29581, 29761, 29959 };
    
    // Use binary search to find the prime immediatelly greater than dwTarget
    int l = 0;
    int r = ARRAY_SIZE(rgPrimes)-1;
    int m;
        
    for(;;)
    {
        if(r - l > 30)
        {
            m = (l + r) / 2;
            
            if(dwTarget < rgPrimes[m])
                r = m - 1;
            else
                l = m + 1;
                
            if(dwTarget == rgPrimes[m])
                break;
        }
        else
        {
            for(m=l; m < r && dwTarget > rgPrimes[m]; m++)
                ;
                
            break;
        }
    }
    
    if(dwTarget < rgPrimes[m])
    {
        return rgPrimes[m];
    }
    else
    {
        // iTarget is larger than what we have in our table so we'll just have to
        // use it instead. At least make sure it's not an even number.
        if((dwTarget & 1) == 0)
            dwTarget++;
            
        return dwTarget;
    }
}

/*****************************************************************************
  CServerTimerAppt
*****************************************************************************/

CServerTimerAppt::CServerTimerAppt()
{
    _pCallback   = NULL;
    _dwInterval  = 0;
    _dwWhen      = 0;
    _dwHeapIndex = NOT_QUEUED;
    _lRef        = 1;
    _fRecurring  = false;
    _pParam      = NULL;
}

CServerTimerAppt::~CServerTimerAppt()
{
    if(_pCallback != NULL)
        _pCallback->Release();
}

ULONG CServerTimerAppt::AddRef()
{
    return InterlockedIncrement(&_lRef);
}

ULONG CServerTimerAppt::Release()
{
    LONG lRef = InterlockedDecrement(&_lRef);
    
    if(0==lRef)
    {
        delete this;
    }
    
    return(lRef);
}

void CServerTimerAppt::Init(
    IServerTimerCallback* pCallback, 
    void* pParam, 
    DWORD dwInterval, 
    bool fRecurring,
    DWORD dwNow
)
{
    DBGASSERT(NULL == _pCallback);
    DBGASSERT(!fRecurring || dwInterval != 0);
    
    _pCallback = pCallback;
    _pCallback->AddRef();
    
    _dwInterval  = dwInterval;
    _dwWhen      = dwNow + _dwInterval;
    _dwHeapIndex = NOT_QUEUED;
    _fRecurring  = fRecurring;
    _pParam      = pParam;
}

void CServerTimerAppt::Cancel()
{
    _fRecurring = false;
}

void CServerTimerAppt::MarkAsNotQueued()
{
    _dwHeapIndex = NOT_QUEUED;
}

void CServerTimerAppt::CalcNextAppt(DWORD dwNow) 
{
    _dwWhen = dwNow + _dwInterval;
}

/*****************************************************************************
  CServerTimer
*****************************************************************************/

CServerTimer::CServerTimer()
{
    _hThread   = NULL;
    _hWait     = NULL;
    _fShutdown = FALSE;
    
#if _TEST
    _dwTimeAdjust = 0;
#endif
}

CServerTimer::~CServerTimer()
{
    DBGASSERT(NULL == _hThread);
    DBGASSERT(NULL == _hWait);
}

bool CServerTimer::Init()
{
    bool fRet = false;
    
    DBGASSERT(NULL == _hWait);
    
    _hWait = CreateEventA(NULL, true, false, NULL);
    if(NULL == _hWait)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateEventA failed. Error=%u", GetLastError());
        goto lDone;
    }
    
    DBGASSERT(NULL == _hThread);
    DWORD dwThreadId;
    _hThread = CreateThread(NULL, 0, StaticThreadProc, this, 0, &dwThreadId);
    if(NULL == _hThread)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateThread failed. Error=%u", GetLastError());
        goto lDone;
    }
    
//     if(!::SetThreadPriority(_hThread, THREAD_PRIORITY_ABOVE_NORMAL))
//     {
//         CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
//             "SetThreadPriority failed. Error=%d", GetLastError());
//         goto lDone;
//     }
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CServerTimer::Shutdown()
{
    InterlockedExchange(&_fShutdown, TRUE);
    
    if(_hThread != NULL)
    {
        do
        {
            SetEvent(_hWait);
        } while(WaitForSingleObject(_hThread, 100) == WAIT_TIMEOUT);
    }
}

void CServerTimer::Term()
{
    Shutdown();
    
    DBGASSERT(_heap.GetCount() == 0);
    
    if(_hWait != NULL)
    {
        CloseHandle(_hWait);
        _hWait = NULL;
    }
    
    if(_hThread != NULL)
    {
        CloseHandle(_hThread);
        _hThread = NULL;
    }
    
    _heap.Term();
}

bool CServerTimer::CreateAppointment(
    IServerTimerCallback* pCallback,
    void* pParam,
    DWORD dwInterval,
    bool fRecurring,
    CServerTimerAppt** ppAppt
)
{
    bool fRet = false;
    CServerTimerAppt* pAppt = NULL;

    DBGASSERT(!fRecurring || !"Not tested");
    
    fRet = true;
    
    pAppt = new CServerTimerAppt();
    if(NULL == pAppt)
        goto lDone;
        
    pAppt->Init(pCallback, pParam, dwInterval, fRecurring, GetNow());
    
    _lock.Lock();
    
    fRet = _heap.Insert(pAppt);

    if(!fRet)
    {
        _lock.Unlock();
        goto lDone;
    }
        
    if(pAppt->IsFirstInLine())
        SetEvent(_hWait);
        
    *ppAppt = pAppt;
    (*ppAppt)->AddRef();
    
    DBGASSERT(pAppt->_lRef == 2);
    
    pAppt = NULL;
    
    _lock.Unlock();
    
    fRet = true;
    
lDone:
    
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

void CServerTimer::CancelAppointment(
    CServerTimerAppt* pAppt
)
{
    _lock.Lock();
    
    if(pAppt->IsQueued())
    {
        CServerTimerAppt* pRemovedAppt = _heap.Remove(pAppt->GetHeapIndex());
        
        if(pRemovedAppt != pAppt)
        {   
            DBGASSERT(false);
        }
        
        pRemovedAppt->MarkAsNotQueued();
        pRemovedAppt->Cancel();
        pRemovedAppt->Release();
    }
    
    _lock.Unlock();
}

DWORD CServerTimer::StaticThreadProc(void* pRawThis)
{
    ((CServerTimer*)pRawThis)->ThreadProc();
    
    return 0;
}

void CServerTimer::ThreadProc()
{
    CServerTimerAppt* pAppt         = NULL;
    IServerTimerCallback* pCallback = NULL;
    void* pParam                    = NULL;
    DWORD dwSleep                   = 0;
    DWORD dwNow                     = 0;
    DWORD dwWhen                    = 0;
    
    while(!_fShutdown)
    {
        dwNow = GetNow();
        pAppt = NULL;
        
        // Get next appt
        _lock.Lock();
        
        if(_heap.GetCount() == 0)
        {
            dwSleep = INFINITE;
            ResetEvent(_hWait);
        }
        else
        {
            dwWhen = _heap.Peek(0)->GetWhen();
            
            int cmp = WrapDWORDCompare(dwNow, dwWhen,&dwSleep);
            
            if(cmp >= 0)
            {
                // Execute appointment right away
                dwSleep   = 0;
                pAppt     = _heap.Remove(0);
                pAppt->MarkAsNotQueued();
                pCallback = pAppt->GetCallback();
                pParam    = pAppt->GetParam();
            }
            else
            {
                ResetEvent(_hWait);
            }
        }
        
        _lock.Unlock();
        
        if(dwSleep != 0)
        {
            DBGASSERT(pAppt == NULL);
            
            WaitForSingleObject(_hWait, dwSleep);
            
            if(_fShutdown)
                break;
                
            continue;
        }
        
        DBGASSERT(pAppt != NULL);
        pCallback->OnTimer(pParam);
    
        if(pAppt->IsRecurring())
        {
            _lock.Lock();
            
            if(pAppt->IsRecurring())
            {
                pAppt->CalcNextAppt(GetNow());
                _heap.Insert(pAppt);
                pAppt = NULL;
            }
            
            _lock.Unlock();
        }
        
        if(pAppt != NULL)
        {
            pAppt->Release();
            pAppt = NULL;
        }
    }
}

UINT64 GetUTCTimeAsUint64()
{
    UINT64 ft;
    ::GetSystemTimeAsFileTime(reinterpret_cast<LPFILETIME>(&ft));
    return ft;
}

// Utility function to write to ITraceCallback::Write in printf style
void TraceCallbackFormattedWrite(
        ITraceCallback* pOut, 
        const char* pszFmt, 
        ... )
{
    CLargeStr str;
    va_list args;
    
    va_start(args, pszFmt);
    str.FormatWithVaList(pszFmt,args);
    va_end(args);

    pOut->Write(str.cstr());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\ums.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * ums.h
 * Header of leaderboard server User Mode Scheduler
 * Source: ums.cpp
 * 
 */

#pragma once

#include "util.h"
#include "config.h"

#define USE_UMS_STATS 1

// Forward declarations. This file declares the following classes:
class UMS;
class UMSTask;
class UmsClient;
class UMSWorker;
class IUmsClient;
struct UMSLockCookie;

// Data structure sizes and other misc. constants
const DWORD UMS_SIZE_LOCK_RESOURCE_TABLE = 10007; // (prime) // TODO: tweak
const DWORD UMS_INITIAL_SIZE_LOCK_RESOURCE_ENTRY_POOL = 1; // TODO: tweak
const DWORD UMS_INITIAL_SIZE_TASK_LIST = 1; // TODO: tweak
const DWORD UMS_INITIAL_SIZE_CONTEXT_TABLE = 509; // (prime) //TODO: tweak

// LOCK_ID - lock resource identifier
struct LOCK_ID
{
    UINT32 type;
    UINT64 id;
    
    static INLINE DWORD GetHash(LOCK_ID& lid)
    {
        return (lid.type << 1)  + ((DWORD)(lid.id >> 32)) + ((DWORD)lid.id);
    }
    
    static INLINE bool IsEqual(LOCK_ID& keyA, LOCK_ID& keyB)
    {
        return keyA.type == keyB.type &&
               keyA.id   == keyB.id;
    }
}; 

// LOCK_MODE - lock mode or type. Must be one one of the LOCK_MODE_* constants
typedef DWORD  LOCK_MODE;
const LOCK_MODE  LOCK_MODE_IS    = 1;  
const LOCK_MODE  LOCK_MODE_IX    = 2;  
const LOCK_MODE  LOCK_MODE_SIX   = 3;
const LOCK_MODE  LOCK_MODE_X     = 4;
const DWORD      LOCK_MODE_LAST  = LOCK_MODE_X;

const UINT32 LOCK_TYPE_PAGE       = 1;
const UINT32 LOCK_TYPE_BTREE      = 2;
const UINT32 LOCK_TYPE_BTREE_ROOT = 3;
const UINT32 LOCK_TYPE_PUID       = 4;
const UINT32 LOCK_TYPE_LB         = 5;

#if USE_UMS_STATS

struct UMS_STATS
{
    UMS_STATS() :
        cLockRequest(0),
        cWait       (0)
    {}
    
    DWORD cLockRequest;
    DWORD cWait;
};

#define UMS_INC_STAT(x) _stats.x++

#else

#define UMS_INC_STAT(x)

#endif

/***************************************************************************/
/*                                                                         */
/* UMS                                                                     */
/*                                                                         */
/* User Mode Scheduler.                                                    */
/* Provides a framework for threads, workitems and locks. It's ideal for   */
/* applications with complex types of locks and/or weird scheduling        */
/* requirements like, for example, the Leaderboard Server.                 */
/*                                                                         */
/***************************************************************************/

class UMS
{

friend UMSWorker;
friend UmsClient;

public:
///////////////////////////////////////

    // Constructor
    UMS() :
        _fShutdown(FALSE),
        _cWorkers(0),
        _prgWorkers(NULL),
        _hSupervisorThread(NULL),
        _hSupervisorEvent(NULL),
        _lSupervisorAwake(0),
        _eSupervisorState(NOT_INITIALIZED)
        
    {
    }
    
    // Destructor
    ~UMS()
    {
        DBGASSERT(_prgWorkers == NULL);
        DBGASSERT(_taskList.GetCount() == 0);
        DBGASSERT(_availableWorkerList.GetCount() == 0);
        DBGASSERT(_hSupervisorThread == NULL);
        DBGASSERT(_hSupervisorEvent == NULL);
    }
        
    // Init
    // Initialize UMS. Must be called before anything else.
    bool Init(CPerfCounters* pPerfCounters);
    
    // Shutdown
    // Enters shutdown mode where new tasks will be rejected. Blocks until all
    // existing tasks are completed.
    void Shutdown();
    
    // Term
    // Releases all resources. It calls Shutdown if it hasn't been called before.
    void Term();
    
    // AddNewTask
    // Add a new task
    bool AddNewTask(
        IN UMSTask* pTask        // Task to be executed. Tasks are objects that inherit from UMSTask.
    );
    
    bool CreateUmsClient(
        OUT IUmsClient** ppUmsClient
    );
    
    void ReleaseUmsClient(
        IN IUmsClient* pUmsClient
    );
    
    void DumpStats()
    {
#if USE_UMS_STATS
    
    printf("\n\n **** Dumping UMS stats ****\n");
    
    printf(
        "\ncLockRequest = %u"
        "\ncWait        = %u",
        _stats.cLockRequest,
        _stats.cWait);
        
    printf("\n\n **** End of UMS stats ****\n\n");

#endif
    }
    
#if LBSVR_ALL_PUBLIC
public:
#else
protected:
#endif

///////////////////////////////////////

    struct LOCK_RESOURCE_ENTRY;
    
    // IsShuttingDown
    // Returns true if UMS is shutting down
    bool IsShuttingDown() const { return _fShutdown != 0; }
    
    // WaitForNewTask
    // Called by a worker object to wait for new tasks.
    bool WaitForNewTask(
        IN UMSWorker* pWorker // Pointer to worker
    );
    
    // AcquireLock
    // Called by a worker object to acquire a lock on a resource. If the lock
    // requested is not compatible with existing locks on the resource, the 
    // worker is queued until the resource becomes available.
    bool AcquireLock(
        IN UmsClient* pWorker,   // Pointer to context object
        IN LOCK_ID& lid,          // Lock id (or resource id)
        IN LOCK_MODE lm,         // Lock mode (one of the LOCK_MODE_* constants)
        IN UMSLockCookie* pCookie,
        bool fBlock
    );
    
    // ReleaseAndAcquireLock
    // Equivalent to release and re-acquiring the lock on a resource but it's a 
    // bit faster than calling ReleaseLock followed by AcquireLock
    bool ReleaseAndAcquireLock(
        IN UmsClient* pWorker,
        IN UMSLockCookie* pCookie,
        IN LOCK_MODE lm
    );
    
    // UpgradeLockFromSIXtoX
    // Change a lock from SIX to X. In practice it acquires a new lock X before 
    // releasing the SIX and returns the new lock cookie. Use it carefully as it 
    // can cause deadlocks.
    bool UpgradeLockFromSIXtoX(
        IN UmsClient* pWorker,
        IN UMSLockCookie* pCookie
    );

    // ReleaseLock
    // Called by a worker object to release a previously acquired lock.
    bool ReleaseLock(
        IN UmsClient* pWorker, // Pointer to context object
        IN UMSLockCookie* pCookie
    );
    
    // SupervisorThreadProc
    // Supervisor's static thread proc. It just uses the pointer to UMS passed
    // in lpParam to call SupervisorProc.
    static DWORD WINAPI SupervisorThreadProc(
        IN LPVOID lpParam // Pointer to UMS
    );
    
    // SupervisorProc
    // Supervisor's thread proc. 
    void SupervisorProc();
    
    // SupervisorGotWork
    // Returns true if the supervisor thread has work to do. It returns false
    // otherwise (in which case the thread can go to sleep).
    bool SupervisorGotWork();
    
    // SupervisorAssignTasks
    // Called by the supervisor thread to assign tasks to available worker 
    // threads
    void SupervisorAssignTasks();
    
    // AwakeUnblockedWorkers
    // This method is called after a potential blocking lock have been 
    // released. It awakes workers that were queued waiting for the now 
    // available resource.
    bool AwakeUnblockedWorkers(
        IN LOCK_RESOURCE_ENTRY* pLockResource // pointer to lock resource
    );
    
    // QueueContextOnLockQueue
    // Queue a context (or worker) on a specific resource and lock mode.
    bool QueueContextOnLockQueue(
        IN LOCK_RESOURCE_ENTRY* pLockResource, // lock resource that the context object is interested on
        IN UmsClient* pWorker,                 // context object that is going to be queued
        IN LOCK_MODE lm                        // lock mode that the context object is interested on
    );
    
    // DequeueContextFromLockQueue
    // Returns a context from a lock mode queue of a lock resource.
    UMSWorker* DequeueContextFromLockQueue(
        IN LOCK_RESOURCE_ENTRY* pLockResource, 
        IN LOCK_MODE lm
    );
    
    // WakeUpSupervisor
    // Awakes the supervisor thread (if it's indeed sleeping). 
    void WakeUpSupervisor();

    bool IsLockCompatible(
        UmsClient* pWorker,
        IN LOCK_RESOURCE_ENTRY* pLR, 
        LOCK_MODE lm
    );
    
    void IncrementLockReference(
        IN LOCK_RESOURCE_ENTRY* pLR, 
        LOCK_MODE lm
    );
    
    bool DecrementLockReference(
        LOCK_RESOURCE_ENTRY* pLR, 
        LOCK_MODE lm
    );
    
    // SUPERVISOR_THREAD_STATE
    // Enumerates possible states of the supervisor thread.
    enum SUPERVISOR_THREAD_STATE
    {
        NOT_INITIALIZED,
        INITIALIZED,
        SHUTTING_DOWN,
        TERMINATED
    };
    
    // LOCK_RESOURCE_ENTRY
    // Contains lock data about a resource identified by _lid.
    struct LOCK_RESOURCE_ENTRY
    {
        // Identifies the resource being locked.
        LOCK_ID _lid; 
        
        // Contains the number of contexts that own a lock on this resource
        // grouped by LOCK_MODE.
        DWORD _rgLockMode[LOCK_MODE_LAST];
        
        // Queues with the contexts waiting for this resource grouped by
        // LOCK_MODE
        TList<UmsClient> _rgLockModeQueue[LOCK_MODE_LAST];
        
        // Total number of locks granted.
        DWORD     _cLockCount;
        
        // Total number of contexts queued waiting for a lock on this resource
        DWORD     _cQueueCount;
        
        // Pointer to the next LOCK_RESOURCE_ENTRY in the linked list. 
        LOCK_RESOURCE_ENTRY* pNext;
        
        LOCK_RESOURCE_ENTRY()
        {
            _lid.type = 0;
            _lid.id   = 0;
            
            ZeroMemory(_rgLockMode, sizeof(_rgLockMode));
            _cLockCount = 0;
            _cQueueCount = 0;
        }
        
        ~LOCK_RESOURCE_ENTRY()
        {
#if _DEBUG
            for(DWORD i=0; i < ARRAY_SIZE(_rgLockModeQueue); i++)
            {
                DBGASSERT(_rgLockModeQueue[i].GetCount() == 0);
            }
#endif
        }
    };
    
    struct LOCK_RESOURCE_SLOT
    {
        LOCK_RESOURCE_SLOT() : 
            pNext(NULL)
        {
        }
        
        ~LOCK_RESOURCE_SLOT()
        {
            DBGASSERT(pNext == NULL);
        }
        
        CFastLock _lock;
        LOCK_RESOURCE_ENTRY* pNext;
    };
    
    LONG               _fShutdown;
    DWORD              _cWorkers;
    UMSWorker* _prgWorkers;
    
    CFixedSizeMemPool  _poolLockResourceEntry;
    
    CLFQueue           _taskList;
    TLFStack<UMSWorker> _availableWorkerList;
    
    HANDLE             _hSupervisorThread;
    HANDLE             _hSupervisorEvent;
    LONG               _lSupervisorAwake;
    CFastLock          _lockSupervisor;
    volatile SUPERVISOR_THREAD_STATE _eSupervisorState;
    CPerfCounters *    _pPerfCounters;
    
    LOCK_RESOURCE_SLOT _lockResourceTable[UMS_SIZE_LOCK_RESOURCE_TABLE];
    
#if USE_UMS_STATS
    
    UMS_STATS _stats;

#endif

};


/***************************************************************************/
/*                                                                         */
/*  IUmsClient                                                             */
/*                                                                         */
/*                                                                         */
/***************************************************************************/

class _declspec(novtable) IUmsClient
{
public:

    virtual bool AcquireLock(
        LOCK_ID& lid, 
        LOCK_MODE lm, 
        UMSLockCookie* pCookie
    ) = 0;

    virtual bool TryAcquireLock(
        LOCK_ID& lid, 
        LOCK_MODE lm, 
        UMSLockCookie* pCookie
    ) = 0;
    
    virtual bool ReleaseLock(
        UMSLockCookie* pCookie
    ) = 0;
    
    virtual bool ReleaseAndAcquireLock(
        UMSLockCookie* pCookie, 
        LOCK_MODE lm
    ) = 0;

    virtual bool UpgradeLockFromSIXtoX(
        UMSLockCookie* pCookie
    ) = 0;
    
    virtual bool IsSleeping();

    virtual int GetAllLockCount();
};

/***************************************************************************/
/*                                                                         */
/*  UMSTask                                                                */
/*                                                                         */
/*                                                                         */
/***************************************************************************/

class __declspec(novtable) UMSTask
{
public:
    
    virtual void Execute(IUmsClient* pUmsClient) = 0;
    virtual void Free() = 0;
};

struct UMSLockCookie
{
    LOCK_ID    lid;
    LOCK_MODE  lm;
    UmsClient* pWorker;
    
    UMSLockCookie()
    {
        lid.type = 0;
        lid.id   = 0;
        lm       = 0;
        pWorker  = NULL;
    }
};

class UmsClient :
    public IUmsClient,
    public CDoubleLink
{
friend UMS;
USE_GLOBAL_ALLOC;
public:

    UmsClient() :
        _hControlEvent(NULL),
        _pUms(NULL),
        _fSleeping(FALSE)
    {}
    
    ~UmsClient()
    {
        DBGASSERT(NULL == _hControlEvent);
    }
    
    bool Init(
        UMS* pUms
    );

    void Term();
    
    INLINE void PrepareToSleep()
    {
        ::ResetEvent(_hControlEvent);
    }
    
    INLINE void Sleep()
    {
        InterlockedExchange(&_fSleeping, TRUE);
        ::WaitForSingleObject(_hControlEvent, INFINITE);
        InterlockedExchange(&_fSleeping, FALSE);
    }
    
    INLINE void WakeUp()
    {
        ::SetEvent(_hControlEvent);
    }
    
    virtual bool AcquireLock(
        LOCK_ID& lid, 
        LOCK_MODE lm, 
        UMSLockCookie* pCookie
    );
    
    virtual bool TryAcquireLock(
        LOCK_ID& lid, 
        LOCK_MODE lm, 
        UMSLockCookie* pCookie);
    
    virtual bool ReleaseLock(
        UMSLockCookie* pCookie
    );
    
    virtual bool ReleaseAndAcquireLock(
        UMSLockCookie* pCookie, 
        LOCK_MODE lm
    );
    
    virtual bool UpgradeLockFromSIXtoX(
        UMSLockCookie* pCookie
    );
    
    virtual bool IsSleeping()
    {
        return TRUE == _fSleeping;
    }
    
    bool HaveLock(
        LOCK_ID& lid, 
        LOCK_MODE lm
    )
    {
        DBGASSERT(lm >= LOCK_MODE_IS && lm <= LOCK_MODE_LAST);
        return GetLockCount(lid,lm) != 0;
    }

    //Used for verification
    int GetAllLockCount()
    {
        int nCount=0;

        CLockHashTable::Iterator it(&_locks);

        it.Reset();
        LOCK_ID lid;
        LOCK_COUNT lockCount;
        
        while(it.GetNext(&lid,&lockCount))
        {
            for (int lm=1;lm<=LOCK_MODE_LAST;lm++)
            {
                nCount = nCount + GetLockCount(lid, lm);
            }
        }   

        return nCount;
    }

    
#if LBSVR_ALL_PUBLIC
public:
#else
protected:
#endif

    struct LOCK_COUNT
    {
        UINT8 rgLockCount[LOCK_MODE_LAST];
        
        LOCK_COUNT()
        {
            ZeroMemory(rgLockCount, sizeof(rgLockCount));
        }
    };
    
    BYTE GetLockCount(LOCK_ID& lid, LOCK_MODE lm)
    {
        DBGASSERT(lm >= LOCK_MODE_IS && lm <= LOCK_MODE_LAST);
        
        LOCK_COUNT* plc;
        BYTE lc = 0;
        
        plc = _locks.GetReference(lid);
        
        if(plc != NULL)
        {
            lc = plc->rgLockCount[lm-1];
        }
        
        return lc;
    }
    
    LOCK_COUNT GetLockCountForAllModes(LOCK_ID& lid)
    {
        LOCK_COUNT* plc = NULL;
        
        plc = _locks.GetReference(lid);
        
        return plc != NULL ? *plc : LOCK_COUNT();
    }

    bool IncrementLockCounter(LOCK_ID& lid, LOCK_MODE lm)
    {
        bool fRet = false;
        LOCK_COUNT* plc;
        LOCK_COUNT lc;
        
        if( (plc = _locks.GetReference(lid)) != NULL )
        {
            if(plc->rgLockCount[lm-1] == 255)
            {
                CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                    "plc->rgLockCount[lm-1] == 255");
                goto lDone;
            }
            
            plc->rgLockCount[lm-1]++;
        }
        else
        {
            lc.rgLockCount[lm-1]++;
            
            if(!_locks.Set(lid, lc))
                goto lDone;
        }
        
        fRet = true;
        
    lDone:
        
        return fRet;
    }
    
    bool DecrementLockCounter(LOCK_ID& lid, LOCK_MODE lm)
    {
        bool fRet = false;
        LOCK_COUNT* plc;
        
        if(NULL == (plc = _locks.GetReference(lid)))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "NULL == (plc = _locks.GetReference(lid))");
            goto lDone;
        }
        
        if(plc->rgLockCount[lm-1] == 0)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "plc->rgLockCount[lm-1] == 0");
            goto lDone;
        }
        
        if(--plc->rgLockCount[lm-1] == 0)
        {
			int i;
            for(i=0; i < ARRAY_SIZE(plc->rgLockCount); i++)
            {
                if(plc->rgLockCount[i] != 0)
                    break;
            }
            
            if(i == ARRAY_SIZE(plc->rgLockCount))
            {
                if(!_locks.Remove(lid, NULL))
                    goto lDone;
            }
        }
        
        fRet = true;
        
    lDone:

        if(!fRet)
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
        return fRet;
    }
    
    HANDLE _hControlEvent;
    typedef TStackHashtable<THashtable<LOCK_ID, LOCK_COUNT, LOCK_ID>, 1000> CLockHashTable;
    CLockHashTable _locks; // TODO: constant
    UMS* _pUms;
    volatile LONG _fSleeping;
};


class UMSWorker : 
    public CSingleLink
{
USE_GLOBAL_ALLOC;
public:
    UMSWorker() : 
        _hThread(NULL),
        _dwThreadId(0),
        _eState(NOT_INITIALIZED),
        _pTask(NULL)
    {
    }
    
    virtual ~UMSWorker()
    {
        DBGASSERT(NULL == _hThread);
    }
    
    bool Init(UMS* pScheduler);
    
    void Term();
    
    UmsClient* GetUmsClient() { return &_UmsClient; }
    
#if LBSVR_ALL_PUBLIC
public:
#else
protected:
#endif
    
    enum SUPERVISOR_THREAD_STATE
    {
        NOT_INITIALIZED,
        INITIALIZED,
        SHUTTING_DOWN,
        TERMINATED
    };

    static DWORD WINAPI ThreadProc(LPVOID lpParam);
    
    void WorkerProc();
    
    UMSTask* GetTask() const { return _pTask; }
    
    void SetTask(UMSTask* pTask)
    {
        DBGASSERT(_pTask == NULL);
        
        _pTask  = pTask;
    }
    
    void ReleaseTask()
    {
        DBGASSERT(_pTask != NULL);
        
        UMSTask* pTask = _pTask;
        _pTask  = NULL;
        pTask->Free();
    }
    
    UMS* _pScheduler;
    UmsClient _UmsClient;
    HANDLE  _hThread;
    DWORD   _dwThreadId;
    SUPERVISOR_THREAD_STATE _eState;
    UMSTask* _pTask;

    friend UMS;

};  // UMSWorker


struct UMSSafeLockCookie : public UMSLockCookie
{
    IUmsClient* pUmsClient;
    
    UMSSafeLockCookie(IUmsClient* pUmsClient)
    {
        this->pUmsClient = pUmsClient;
    }
    
    ~UMSSafeLockCookie()
    {
        Release();
    }
    
    void Detach(UMSLockCookie* pCookie)
    {
        *pCookie = *((UMSLockCookie*)this);
        Reset();
    }
    
    void Reset()
    {
        this->lid.type = 0;
        this->lid.id   = 0;
        this->lm       = 0;
        this->pWorker  = NULL;
    }
    
    void Release()
    {
        if(this->lid.type != 0 || this->lid.id != 0)
        {
            pUmsClient->ReleaseLock((UMSLockCookie*)this);
            Reset();
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\svc\main.cpp ===
#include <lbs.h>
#include "mgmt.h"
#include <ntservice.h>

CConfig         g_config;
CServerTimer    g_timer;
UMS             g_ums;
CBufferManager  g_bm;
CLbList         g_lbList;
CRequestManager g_rm;
CNet            g_net;
CPersister      g_persister;
CDb             g_db;
CJobs           g_jobs;
CLbSvrMgmt      g_mgmt;

CPerfCounters   g_Counters;
CHealthChecks   g_Health;


class CLbSvrService : public CNTService
{
public:
    
    CLbSvrService() :
        CNTService(
            L"LbSvr",
            L"Xbox Online Leaderboard Server",
            L"Leaderboard and stats backend",
            L"lbsvrperf",
            Component_lbsvr )
    {
    }

    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv )
    {
        return S_OK;
    }

    virtual HRESULT RunService( BOOL *pfServiceRan )
    {
        bool fInit = false;
        bool fReg  = false;
        HRESULT hr;
        
        g_xomcentral    .Init("lbsvr", NULL);
        g_MemAlloc      .Init();
        CGlobalError   ::Init();
        CArenaMemAlloc ::GlobalInit(65536, 1, true);

        hr = g_Counters.Init();
        if (hr != S_OK)
            goto lDone;

        if(!g_config.LoadConfig())
            goto lDone;

        if(!g_timer.Init())
            goto lDone;
            
        if(!g_ums.Init(&g_Counters))
            goto lDone;
    
        if(!g_bm.Init(&g_config, &g_ums, &g_Counters))
            goto lDone;
    
        if(!g_db.Init(&g_config, &g_ums, &g_Counters))
            goto lDone;
        
        if(!g_persister.Init(&g_config, &g_ums, &g_db, &g_lbList, &g_bm, &g_Counters))
            goto lDone;
        
        if(!g_lbList.Init(&g_config,&g_bm,&g_ums,&g_persister,&g_db,&g_Counters))
            goto lDone;
        
        // Here we build the leaderboards from the data in the database
        if(!g_lbList.Load(false))
            goto lDone;
            
        if(!g_jobs.Init(&g_config, &g_ums, &g_lbList, &g_timer))
            goto lDone;
        
        if(!g_rm.Init(&g_config,&g_ums,&g_lbList, &g_Counters))
            goto lDone;
        if(!CLbRemoteProc::Register(&g_rm))
            goto lDone;

        g_mgmt.Init(&g_ums,&g_lbList,&g_bm);
    
        // Initialize the network component and start accepting requests
        if(!g_net.Init(&g_config,&g_timer,&g_rm, &g_Counters))
            goto lDone;

        // Initialize health checks last, so that they'll fail until the service is fully up.
        if (!g_Health.Init())
            goto lDone;
        
        fReg  = true;
        fInit = true;

        XomNtEvent(XEVENT_STATS_INFO_24, "Lbsvr initialized.");
        
        WaitForSingleObject(ShutdownEvent(), INFINITE);
        
    lDone:
        
        if(!fInit)
        {
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER
                "Initialization failed. Most likely a configuration error. ");
            XomNtEvent(XEVENT_STATS_CONFIG_26, "%s", CGlobalError::GetCurrentMessage());
        }
        
        XomNtEvent(XEVENT_STATS_INFO_25, "Lbsvr shutting down.");
        
        // Stop accepting new requests. Wait until pending requests are done.
        g_ums.Shutdown();
        
        // Terminate
        g_mgmt     .Term();
        g_net      .Term();
        g_jobs     .Term();
        g_persister.Term();
        g_lbList   .Term(true);
        g_db       .Term();
        g_rm       .Term();
        g_bm       .Term();
        g_ums      .Term();
        g_timer    .Term();
        g_Health   .Term();

        CArenaMemAlloc ::GlobalTerm();
        CGlobalError   ::Term();
        g_MemAlloc      .Term();
        g_xomcentral    .Term();

        return fInit ? S_OK : E_FAIL;
    }
} g_Service;

CNTService* g_pService = &g_Service;

int __cdecl wmain( int argc, WCHAR *argv[] )
{
    return( g_Service.ProcessMain( argc, argv ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\util.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * util.h
 * Header of leaderboard server utilities classes, functions and macros.
 * Source: util.cpp
 * 
 */

#pragma once
#include <stdio.h>
#include <stdarg.h>
#include <new>
#include <windows.h>

#include <PageHeap.hpp>
#include <DebugHeap.hpp>

#if _DEBUG
    #define DBGASSERT(x) \
        if(!(x)) \
        { \
            printf("\nTest error in %s line %d: %s\n", __FILE__, __LINE__, #x); \
            DebugBreak(); \
        } 
#else
    #define DBGASSERT(x)
#endif

#if _DEBUG
    #define INLINE __declspec(noinline)
#else
    #define INLINE __forceinline
#endif

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#ifdef _AMD64_
    #define DEADBEEF 0xdeadbeeffeebdaed
#else
    #define DEADBEEF 0xdeadbeef
#endif

class CInterlocked
{
public:

    static INLINE LONG Add(
        volatile LONG *Address,
        LONG Value
    )
    {
#ifdef _X86_
        __asm
            {
            mov     ecx,Address                 // Load the address.
            mov     eax,Value                   // Load the value.
            lock    xadd dword ptr[ecx],eax     // Increment the value.
            }
#else
    return InterlockedExchangeAdd(Address, Value);
#endif
    }


    static I