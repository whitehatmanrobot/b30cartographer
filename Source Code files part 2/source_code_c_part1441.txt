 CEcbBaseImpl<_T>::FGetServerVariable(). Error 0x%08lX from MultiByteToWideChar() "
						  "while trying to find sufficient length for conversion.\n", GetLastError() );

				*pcchValue = 0;
				goto ret;
			}
		}
		else
		{
			//	... failure was fatal
			//
			EcbTrace( "Dav: CEcbBaseImpl<_T>::FGetServerVariable(), Error 0x%08lX from MultiByteToWideChar() "
					  "while trying to convert.\n", GetLastError() );

			*pcchValue = 0;
			goto ret;
		}
	}

	*pcchValue = cch;
	fResult = TRUE;

ret:

	return fResult;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetVirtualRoot
//
//		Fetch and cache the vroot information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetVirtualRoot( LPCSTR * ppszVroot ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppszVroot );
	*ppszVroot = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	If the skinny version of vroot is not available generate
	//	an cache one
	//
	if (NULL == m_rgchVroot)
	{
		//	We got the maping info, so if the skinny version of the
		//	vroot was not available, then at least wide will be there.
		//	That would meen that we are on IIS 6.0 or later. Also we
		//	should have 0 bytes for skinny vroot at this point.
		//
		Assert(m_rgwchVroot);
		Assert(m_pecb->dwVersion >= IIS_VERSION_6_0);
		Assert(0 == m_cchVroot);

		UINT cb = m_cchVrootW * 3;
		m_rgchVroot = reinterpret_cast<LPSTR>(m_sb.Alloc(cb));
		m_cchVroot = WideCharToMultiByte ( CP_ACP,
										   0,
										   m_rgwchVroot,
										   m_cchVrootW,
										   m_rgchVroot,
										   cb,
										   0,
										   0 );
		if (0 == m_cchVroot)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetVirtualRoot failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppszVroot = m_rgchVroot;
	return m_cchVroot - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetVirtualRootW
//
//		Fetch and cache the vroot information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppwszVroot );
	*ppwszVroot = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	If the wide version of vroot is not available generate
	//	an cache one
	//
	if (NULL == m_rgwchVroot)
	{
		//	We got the maping info, so if the wide version of the
		//	vroot was not available, then at least wide will be there.
		//	That would meen that we are on pre IIS 6.0 version. Also we
		//	should have 0 bytes for wide vroot at this point.
		//
		Assert(m_rgchVroot);
		Assert(m_pecb->dwVersion < IIS_VERSION_6_0);
		Assert(0 == m_cchVrootW);

		UINT cb	 = m_cchVroot * sizeof(WCHAR);
		m_rgwchVroot = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchVrootW = MultiByteToWideChar ( CP_ACP,
											MB_ERR_INVALID_CHARS,
											m_rgchVroot,
											m_cchVroot,
											m_rgwchVroot,
											m_cchVroot);
		if (0 == m_cchVrootW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetVirtualRootW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppwszVroot = m_rgwchVroot;
	return m_cchVrootW - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetMatchingPathW
//
//		Fetch and cache the matching path information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetMatchingPathW( LPCWSTR * ppwszPath ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppwszPath );
	*ppwszPath = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	Give the data back to the caller from our cache.
	//
	if (NULL == m_rgwchVrootPath)
	{
		//	We got the maping info, so if the wide version of the
		//	matching path was not available, then at least skinny will
		//	be there. That would meen that we are on pre IIS 6.0 version.
		//	Also we should have 0 bytes for wide matching path at
		//	this point.
		//
		Assert(m_rgchVrootPath);
		Assert(m_pecb->dwVersion < IIS_VERSION_6_0);
		Assert(0 == m_cchVrootPathW);

		UINT cb	 = m_cchVrootPath * sizeof(WCHAR);
		m_rgwchVrootPath = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchVrootPathW = MultiByteToWideChar ( CP_ACP,
												MB_ERR_INVALID_CHARS,
												m_rgchVrootPath,
												m_cchVrootPath,
												m_rgwchVrootPath,
												m_cchVrootPath);
		if (0 == m_cchVrootPathW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetMatchingPathW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppwszPath = m_rgwchVrootPath;
	return m_cchVrootPathW - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetServerName
//
//		Fetch and cache the server name, including port number
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CchGetServerName( LPCSTR* ppszServer ) const
{
	if ( !m_lpszServerName )
	{
		DWORD	cbName;
		DWORD	cbPort;
		CStackBuffer<CHAR> lpszName;
		CStackBuffer<CHAR> lpszPort;

		cbName = lpszName.celems();
		for ( ;; )
		{
			lpszName.resize(cbName);
			if ( FGetServerVariable( gc_szServer_Name,
									 lpszName.get(),
									 &cbName ) )
			{
				break;
			}

			if ( cbName == 0 )
			{
				lpszName[0] = '\0';
				++cbName;
				break;
			}
		}

		cbPort = lpszPort.celems();
		for ( ;; )
		{
			lpszPort.resize(cbPort);
			if ( FGetServerVariable( gc_szServer_Port,
									 lpszPort.get(),
									 &cbPort ) )
			{
				break;
			}

			if ( cbPort == 0 )
			{
				lpszPort[0] = '\0';
				++cbPort;
				break;
			}
		}

		//	Limit the servname/port combination to 256 (including NULL)
		//
		if (256 < (cbName + cbPort))
		{
			throw CHresultException(E_INVALIDARG);
		}

		//	Allocate enough space for the server name and port plus
		//	a ':' separator.  Note that the ':' replaces the '\0' at
		//	the end of the name, so we don't need to add 1 for it here.
		//
		m_lpszServerName = reinterpret_cast<LPSTR>(m_sb.Alloc(cbName + cbPort));

		//	Format the whole thing as "<name>[:<port>]" where
		//	:<port> is only included if the port is not the default
		//	port for the connection (:443 for SSL or :80 for standard)
		//
		CopyMemory( m_lpszServerName,
					lpszName.get(),
					cbName );

		//	If we are secure and the port is "443", or if the port is
		//	the default one, then there is no need to append the port
		//	number to the server name.
		//
		if (( FSsl() && !strcmp( lpszPort.get(), gc_sz443 )) ||
			!strcmp( lpszPort.get(), gc_sz80 ))
		{
			//	It was easier to write the conditional this way and
			//	have the real work done in the "else" clause.
			//
		}
		else
		{
			//	Append the port to the server name
			//
			m_lpszServerName[cbName-1] = ':';
			CopyMemory( m_lpszServerName + cbName,
						lpszPort.get(),
						cbPort );
		}

		m_cchServerName = static_cast<UINT>(strlen(m_lpszServerName));
	}

	*ppszServer = m_lpszServerName;
	return m_cchServerName;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetServerNameW
//
//		Fetch and cache the server name, including port number
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CchGetServerNameW( LPCWSTR* ppwszServer ) const
{
	if ( !m_pwszServerName )
	{
		//	Fetch the server name and include 0 termination in its length
		//
		LPCSTR pszServerName = NULL;
		UINT  cbServerName = CchGetServerName(&pszServerName) + 1;

		//	We are looking for the wide server name for the first time.
		//	The character count should be zero at that point.
		//
		Assert(!m_cchServerNameW);

		UINT cb = cbServerName * sizeof(WCHAR);
		m_pwszServerName = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchServerNameW = MultiByteToWideChar ( CP_ACP,
												 MB_ERR_INVALID_CHARS,
												 pszServerName,
												 cbServerName,
												 m_pwszServerName,
												 cbServerName);
		if (0 == m_cchServerNameW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetServerNameW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}

		//	Subtract 0 termination so that we would behave the same way as
		//	the skinny version of the function
		//
		m_cchServerNameW--;
	}

	*ppwszServer = m_pwszServerName;
	return m_cchServerNameW;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszUrlPrefix
//
//		Fetch and cache the url prefix
//
extern const __declspec(selectany) CHAR gsc_szHTTPS[] = "HTTPS";
extern const __declspec(selectany) CHAR gsc_szFrontEndHTTPS[] = "HTTP_FRONT_END_HTTPS";
extern const __declspec(selectany) CHAR gsc_szOn[] = "on";

template<class _T>
BOOL
CEcbBaseImpl<_T>::FSsl() const
{
	if (m_secure == HTTPS_UNKNOWN)
	{
		//	Start out believing that we are not in a secure environment
		//
		m_secure = NORMAL;

		//	We want to ask the ECB for the server variables that indicate
		//	whether or not the constructed urls should be secured or not.
		//
		//	In the case of a FE/BE topology, the FE will include a header
		//	"Front-End-HTTPS" that indicates whether or not the FE/BE was
		//	secured via SSL.  In the absence of the header, we should try
		//	to fallback to the IIS "HTTPS" header.  For either header, we
		//	we check its value -- in both cases, it should either be "on"
		//	or "off"
		//
		//	IMPORTANT: you have to check for the FE entry first!  That is
		//	the overriding value for this configuration.
		//
		CHAR szHttps[8];
		ULONG cb = sizeof(szHttps);
		ULONG cbFE = sizeof(szHttps);

		m_fFESecured = FGetServerVariable (gsc_szFrontEndHTTPS, szHttps, &cbFE);
		if (m_fFESecured || FGetServerVariable (gsc_szHTTPS, szHttps, &cb))
		{
			if (!_stricmp(szHttps, gsc_szOn))
				m_secure = SECURE;
		}
	}
	return (SECURE == m_secure);
}

template<class _T>
LPCSTR
CEcbBaseImpl<_T>::LpszUrlPrefix() const
{
	return (FSsl() ? gc_szUrl_Prefix_Secure : gc_szUrl_Prefix);
}

template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszUrlPrefix() const
{
	return (FSsl() ? gc_wszUrl_Prefix_Secure : gc_wszUrl_Prefix);
}

template<class _T>
UINT
CEcbBaseImpl<_T>::CchUrlPrefix( LPCSTR * ppszPrefix ) const
{
	//	Make sure that we know which prefix we are working with...
	//
	LPCSTR psz = LpszUrlPrefix();

	//	If the caller wants the pointer, too, give it to 'em
	//
	if (ppszPrefix)
		*ppszPrefix = psz;

	//	Return the appropriate size
	//
	return ((m_secure == SECURE)
			? gc_cchszUrl_Prefix_Secure
			: gc_cchszUrl_Prefix);
}

template<class _T>
UINT
CEcbBaseImpl<_T>::CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const
{
	//	Make sure that we know which prefix we are working with...
	//
	LPCWSTR pwsz = LpwszUrlPrefix();

	//	If the caller wants the pointer, too, give it to 'em
	//
	if (ppwszPrefix)
		*ppwszPrefix = pwsz;

	//	Return the appropriate size
	//
	return ((m_secure == SECURE)
			? gc_cchszUrl_Prefix_Secure
			: gc_cchszUrl_Prefix);
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszRequestUrl()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszRequestUrl() const
{
	if (!m_pwszRequestUrl)
	{
			SCODE sc;

			CStackBuffer<CHAR> pszAcceptLanguage;
			CStackBuffer<CHAR> pszRawUrlCopy;
			LPCSTR	pszQueryStringStart	= NULL;
			LPCSTR	pszRawUrl			= NULL;
			UINT	cbRawUrl			= 0;
			UINT	cchRequestUrl		= 0;

			//	Grab the raw URL.
			//
			cbRawUrl = CbGetRawURL(&pszRawUrl);

			//	We also need to cut off the URL at the beginning of the query
			//	string, if there is one.
			//
			pszQueryStringStart = strchr(pszRawUrl, '?');
			if (pszQueryStringStart)
			{
				//	If there is a query string we need to make a copy of
				//	the raw URL to work with.
				//
				cbRawUrl = static_cast<UINT>(pszQueryStringStart - pszRawUrl);

				//	Allocate a buffer, and copy it in!
				//
				pszRawUrlCopy.resize(cbRawUrl + 1);
				memcpy(pszRawUrlCopy.get(), pszRawUrl, cbRawUrl);
				pszRawUrlCopy[cbRawUrl] = '\0';

				//	Now set up to normalize from this copy. Do not forget
				//	to increment cbRawUrl to include '\0' termination.
				//
				cbRawUrl++;
				pszRawUrl = pszRawUrlCopy.get();
			}

			//	Before normalizing the url, get the Accept-Language: header
			//	to pass it in. This will be used in figuring out the correct
			//	code page to use to decode non-UTF8 urls.
			//
			for ( DWORD cbValue = 256; cbValue > 0; )
			{
				pszAcceptLanguage.resize(cbValue);

				//	Zero the string.
				//
				pszAcceptLanguage[0] = '\0';

				//	Get the header value
				//
				if ( FGetServerVariable( "HTTP_ACCEPT_LANGUAGE",
										 pszAcceptLanguage.get(),
										 &cbValue ) )
				{
					break;
				}
			}

			//	Now, normalize the URL and we're done
			//
			cchRequestUrl = cbRawUrl;
			m_pwszRequestUrl = reinterpret_cast<LPWSTR>(m_sb.Alloc (cchRequestUrl * sizeof(WCHAR)));

			sc = ScNormalizeUrl(pszRawUrl,
								&cchRequestUrl,
								m_pwszRequestUrl,
								pszAcceptLanguage.get());
			if (S_OK != sc)
			{
				//	We should never get S_FALSE here, since we've passed enough buffer space.
				//	Most often callers of this function assume that it cannot return NULL,
				//	and on the other hand we cannot do anything without request URL. Thus
				//	throw the last error exception.
				//
				Assert(S_FALSE != sc);
				DebugTrace("CEcbBaseImpl::LpwszRequestUrl() - ScNormalizeUrl() failed with error 0x%08lX\n", sc);
				SetLastError(sc);
				throw CLastErrorException();
			}

			//	Store the pointer to stripped request URL
			//
			m_pwszRequestUrl = const_cast<LPWSTR>(PwszUrlStrippedOfPrefix(m_pwszRequestUrl));
	}

	return m_pwszRequestUrl;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszRequestUrl()
//
template<class _T>
LPCSTR
CEcbBaseImpl<_T>::LpszRequestUrl() const
{
	if (!m_pszRequestUrl)
	{
		LPCWSTR pwszRequestUrl;
		UINT cbRequestUrl;
		UINT cchRequestUrl;

		pwszRequestUrl = LpwszRequestUrl();
		cchRequestUrl = static_cast<UINT>(wcslen(pwszRequestUrl));
		cbRequestUrl = cchRequestUrl * 3;
		m_pszRequestUrl = reinterpret_cast<LPSTR>(m_sb.Alloc (cbRequestUrl + 1));

		//	The reason for choosing CP_ACP codepage here is that it matches
		//	the old behaviour.
		//
		cbRequestUrl = WideCharToMultiByte(CP_ACP,
										   0,
										   pwszRequestUrl,
										   cchRequestUrl + 1,
										   m_pszRequestUrl,
										   cbRequestUrl + 1,
										   NULL,
										   NULL);
		if (0 == cbRequestUrl)
		{
			DebugTrace( "CEcbBaseImpl::LpszRequestUrl() - WideCharToMultiByte() failed 0x%08lX\n",
						HRESULT_FROM_WIN32(GetLastError()) );

			throw CLastErrorException();
		}
	}

	return m_pszRequestUrl;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpwszRequestUrl()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszMethod() const
{
	if (!m_pwszMethod)
	{
		LPCSTR pszMethod;
		UINT cbMethod;
		UINT cchMethod;

		pszMethod = LpszMethod();
		cbMethod = static_cast<UINT>(strlen(pszMethod));

		m_pwszMethod = reinterpret_cast<LPWSTR>(
				m_sb.Alloc (CbSizeWsz(cbMethod)));

		cchMethod = MultiByteToWideChar(CP_ACP,
										MB_ERR_INVALID_CHARS,
										pszMethod,
										cbMethod + 1,
										m_pwszMethod,
										cbMethod + 1);
		if (0 == cchMethod)
		{
			DebugTrace( "CEcbBaseImpl::LpwszRequestUrl() - MultiByteToWideChar() failed 0x%08lX\n",
						HRESULT_FROM_WIN32(GetLastError()) );

			throw CLastErrorException();
		}
	}

	return m_pwszMethod;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpwszPathTranslated()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszPathTranslated() const
{
	//	Cache the path info in the first call
	//
	if (!m_pwszPathTranslated)
	{
		LPCWSTR	pwszRequestUrl;
		UINT	cchRequestUrl;
		LPCWSTR	pwszMatching;
		UINT	cchMatching;
		LPCWSTR	pwszVroot;
		UINT	cchVroot;
		UINT	cchPathTranslated;

		//	Grab the request URL.
		//
		pwszRequestUrl = LpwszRequestUrl();
		cchRequestUrl = static_cast<UINT>(wcslen(pwszRequestUrl));

		//	Grab the matching path information.
		//
		pwszMatching = NULL;
		cchMatching = CchGetMatchingPathW(&pwszMatching);

		//	Grab the virtual root information.
		//
		pwszVroot = NULL;
		cchVroot = CchGetVirtualRootW(&pwszVroot);

		//	Move the request URL pointer over to snip off the virtual root.
		//
		pwszRequestUrl += cchVroot;
		cchRequestUrl -= cchVroot;

		//	Allocate enough space for the matching path and the request URL, and
		//	copy the pieces in.
		//
		m_pwszPathTranslated = reinterpret_cast<LPWSTR>(
				m_sb.Alloc (CbSizeWsz(cchMatching + cchRequestUrl)));

		//	Copy the matching path.
		//
		memcpy (m_pwszPathTranslated, pwszMatching, cchMatching * sizeof(WCHAR));

		//	Copy the request URL after the vroot, including '\0' termination
		//
		memcpy (m_pwszPathTranslated + cchMatching, pwszRequestUrl, (cchRequestUrl + 1) * sizeof(WCHAR));

		//	Change all '/' that came from URL to '\\'
		//
		for (LPWSTR pwch = m_pwszPathTranslated + cchMatching; *pwch; pwch++)
		{
			if (L'/' == *pwch)
			{
				*pwch = L'\\';
			}
		}

		//	We must remove all trailing slashes, in case the path is not empty string
		//
		cchPathTranslated = cchMatching + cchRequestUrl;
		if (0 < cchPathTranslated)
		{
			LPWSTR pwszTrailing = m_pwszPathTranslated + cchPathTranslated - 1;

			//	Since URL is normalized there may be not more than one trailing slash.
			//	We check only for backslash, as we already changed all forward slashes
			//	to backslashes. Also do not remove trailing slash for the root of the
			//	drive.
			//
			if ((L'\\' == *pwszTrailing) &&
				(!FIsDriveTrailingChar(pwszTrailing, cchPathTranslated)))
			{
				cchPathTranslated--;
				*pwszTrailing = L'\0';
			}
		}		
	}

	return m_pwszPathTranslated;
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CbGetRawURL
//
//		Fetch and cache the raw URL
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CbGetRawURL (LPCSTR* ppszRawURL) const
{
	if (!m_pszRawURL)
	{
		DWORD	cbRawURL;
		CStackBuffer<CHAR,MAX_PATH> pszRawURL;

		cbRawURL = pszRawURL.size();
		for ( ;; )
		{
			pszRawURL.resize(cbRawURL);
			if (FGetServerVariable ("UNENCODED_URL",
									 pszRawURL.get(),
									 &cbRawURL))
			{
				break;
			}

			if (cbRawURL == 0)
			{
				pszRawURL[0] = '\0';
				cbRawURL++;
				break;
			}
		}

		Assert ('\0' == pszRawURL[cbRawURL - 1]);
		UrlTrace("CEcbBaseImpl::CbGetRawURL(): Raw URL = %s\n", pszRawURL.get());

		//	Copy the data to our object.
		//
		m_pszRawURL = reinterpret_cast<LPSTR>(m_sb.Alloc (cbRawURL));
		memcpy (m_pszRawURL, pszRawURL.get(), cbRawURL);
		m_cbRawURL = cbRawURL;
	}

	//	Return the cached values to the caller.
	//
	*ppszRawURL = m_pszRawURL;
	return m_cbRawURL;
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LcidAccepted()
//
//		Fetch, cache, and return the LCID of the accepted language
//		based on the value of the Accept-Language header (if any).
//
//		The default LCID is the special constant referring to the
//      default system locale.
//
//$REVIEW$
//	The const at the end of the function needs to be removed
//
template<class _T>
ULONG
CEcbBaseImpl<_T>::LcidAccepted() const
{
	if ( !m_lcid )
	{
		LPCSTR psz = m_pszAcceptLanguage.get();
		HDRITER hdri(psz);
		ULONG lcid;

		m_lcid = LOCALE_NEUTRAL; // must be the same as lcidDefault in mdbeif.hxx

		for (psz = hdri.PszNext(); psz; psz = hdri.PszNext())
			if (FLookupLCID(psz, &lcid))
			{
				m_lcid = LANGIDFROMLCID(lcid);
				break;
			}
	}

	return m_lcid;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::SetLcidAccepted
//
//	Sets the LCID for the request. We call this function when
//	we dont have an AcceptLang header and we want to override
//	the default LCID (with the LCID in the Cookie)
//
//$REVIEW$
//	After RTM, this function should be merged with the LcidAccepted() function.
//	The LcidAccepted() should check AcceptLang header and if it is not present,
//	should check the lcid in the cookie.
//
template<class _T>
VOID
CEcbBaseImpl<_T>::SetLcidAccepted(LCID lcid)
{
	m_lcid = lcid;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\eventlog.h ===
/*
 *	E V E N T L O G . H
 *
 *	Event log interface
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _EVNTLOG_H_
#define _EVNTLOG_H_

EXTERN_C const WCHAR gc_wszSignature[]; 

VOID LogEventW( DWORD     dwEventID,
				WORD      wEventType,
				WORD      wcDataStrings,
				LPCWSTR * plpwszDataStrings,
				DWORD     dwcbRawData,
			    LPVOID    lpvRawData,
				WORD	  wEventCategory=0);

VOID LogEvent( DWORD    dwEventID,
			   WORD     wEventType,
			   WORD     wcDataStrings,
			   LPCSTR * plpszDataStrings,
			   DWORD    dwcbRawData,
	           LPVOID   lpvRawData,
			   WORD		wEventCategory=0);

STDAPI EventLogDllRegisterServer( LPCWSTR lpwszDllPath, DWORD dwCategories = 0 );
STDAPI EventLogDllUnregisterServer();

#endif // _EVNTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\etag.h ===
/*
 *	E T A G . H
 *
 *	ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_ETAG_H_
#define _ETAG_H_

//	ETAG Format ---------------------------------------------------------------
//
enum { CCH_ETAG = 100, STRONG_ETAG_DELTA = 30000000 };

//	ETAG creation -------------------------------------------------------------
//
BOOL FGetLastModTime (IMethUtil *, LPCWSTR pwszPath, FILETIME * pft);
BOOL FETagFromFiletime (FILETIME * pft, LPWSTR rgwchETag);

//	If-xxx header processing --------------------------------------------------
//

//	Use the first function if you want to generate an ETag by calling FETagFromFiletime;
//	use the second function to override this generation by supplying your own ETag.
//
SCODE ScCheckIfHeaders (IMethUtil * pmu, FILETIME * pft, BOOL fGetMethod);
SCODE ScCheckIfHeadersFromEtag (IMethUtil *	pmu, FILETIME * pft,
								BOOL fGetMethod, LPCWSTR pwszEtag);

//	Use the first function if you want to generate an ETag by calling FETagFromFiletime;
//	use the second function to override this generation by supplying your own ETag.
//
SCODE ScCheckIfRangeHeader (IMethUtil * pmu, FILETIME * pft);
SCODE ScCheckIfRangeHeaderFromEtag (IMethUtil * pmu, FILETIME* pft,
									LPCWSTR pwszEtag);

SCODE ScCheckEtagAgainstHeader (LPCWSTR pwszEtag, LPCWSTR pwszHeader);

#endif	// _ETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ecb.h ===
#ifndef _ECB_H_
#define _ECB_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ECB.H
//
//		Header for IEcb interface class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <autoptr.h>	// For CMTRefCounted parent
#include <cvroot.h>
#include <davmb.h>		// For IMDData
#include <url.h>		// For HttpUriEscape

//	========================================================================
//
//	ENUM TRANSFER_CODINGS
//
//	Valid transfer codings.  See HTTP/1.1 draft section 3.5.
//
//	TC_UNKNOWN  - Unknown value.
//	TC_IDENTITY - Identity encoding (i.e. no encoding).
//	TC_CHUNKED  - Chunked encoding.
//
enum TRANSFER_CODINGS
{
	TC_UNKNOWN,
	TC_IDENTITY,
	TC_CHUNKED
};

typedef struct _HSE_EXEC_URL_INFO_WIDE {

    LPCWSTR pwszUrl;           // URL to execute
    DWORD dwExecUrlFlags;      // Flags

} HSE_EXEC_URL_INFO_WIDE, * LPHSE_EXEC_URL_INFO_WIDE;

//	========================================================================
//
//	CLASS IIISAsyncIOCompleteObserver
//
//	Passed to IEcb async I/O methods
//
class IIISAsyncIOCompleteObserver
{
	//	NOT IMPLEMENTED
	//
	IIISAsyncIOCompleteObserver& operator=( const IIISAsyncIOCompleteObserver& );

public:
	//	CREATORS
	//
	virtual ~IIISAsyncIOCompleteObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID IISIOComplete( DWORD dwcbIO, DWORD dwLastError ) = 0;
};

//	========================================================================
//
//	CLASS IEcb
//
//		Provides a clean interface to the EXTENSION_CONTROL_BLOCK passed
//		to us by IIS.
//
class CInstData;

class IEcbBase : public CMTRefCounted
{
private:

	//	NOT IMPLEMENTED
	//
	IEcbBase( const IEcbBase& );
	IEcbBase& operator=( const IEcbBase& );

	//	Private URL mapping helpers
	//
	SCODE ScReqMapUrlToPathEx60After( /* [in]  */ LPCWSTR pwszUrl,
									  /* [out] */ UINT * pcch,
									  /* [out] */ HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		SCODE sc = S_OK;
		UINT cbPath;

		Assert( m_pecb );
		Assert( pwszUrl );
		Assert( pmi );

		cbPath = MAX_PATH * sizeof(WCHAR);

		if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
											HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX,
											const_cast<LPWSTR>(pwszUrl),
											reinterpret_cast<DWORD*>(&cbPath),
											reinterpret_cast<DWORD*>(pmi) ))
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			Assert(FAILED(sc));
			DebugTrace("IEcbBase::ScReqMapUrlToPathEx60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", sc);
			goto ret;
		}

		DebugTrace ("IEcbBase::ScReqMapUrlToPathEx60After() - ServerSupportFunction"
				"(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) succeded!\n"
				"mapinfo:\n"
				"- url \"%ls\" maps to \"%ls\"\n"
				"- dwFlags = 0x%08x\n"
				"- cchMatchingPath = %d\n"
				"- cchMatchingURL  = %d\n",
				pwszUrl,
				pmi->lpszPath,
				pmi->dwFlags,
				pmi->cchMatchingPath,
				pmi->cchMatchingURL);

		//	The value for cbPath, at this point, should include the L'\0'
		//	termination, and for that reason cbPath will always be more
		//	than the length of the matching path.
		//
		Assert (0 == cbPath % sizeof(WCHAR));
		Assert (L'\0' == pmi->lpszPath[cbPath/sizeof(WCHAR) - 1]);
		Assert (pmi->cchMatchingPath < cbPath/sizeof(WCHAR));

		//	Pass back the length of the storage path including '\0' termination
		//	in the case we were asked for.
		//
		if (pcch)
		{
			*pcch = cbPath/sizeof(WCHAR);
		}

	ret:

		return sc;
	}

	SCODE ScReqMapUrlToPathEx60Before( /* [in]  */ LPCWSTR pwszUrl,
									   /* [out] */ UINT * pcch,
									   /* [out] */ HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		SCODE sc = S_OK;

		HSE_URL_MAPEX_INFO mi;

		CStackBuffer<CHAR, MAX_PATH> pszUrl;
		UINT cchUrl;
		UINT cbUrl;
		UINT cbPath;
		UINT cchPath;

		Assert( m_pecb );
		Assert( pwszUrl );
		Assert( pmi );

		//	Find out the length of the URL
		//
		cchUrl = static_cast<UINT>(wcslen(pwszUrl));
		cbUrl = cchUrl * 3;

		//	Resize the buffer to the sufficient size, leave place for '\0' termination
		//
		if (!pszUrl.resize(cbUrl + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("IEcbBase::ScReqMapUrlToPathEx60Before() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Convert to skinny including '\0' termination
		//
		cbUrl = WideCharToMultiByte(CP_ACP,
									0,
									pwszUrl,
									cchUrl + 1,
									pszUrl.get(),
									cbUrl + 1,
									0,
									0);
		if (0 == cbUrl)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - WideCharToMultiByte() failed 0x%08lX\n", sc);
			goto ret;
		}

		cbPath = MAX_PATH;

		//	Get the skinny mappings from IIS
		//
		if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
											HSE_REQ_MAP_URL_TO_PATH_EX,
											pszUrl.get(),
											reinterpret_cast<DWORD*>(&cbPath),
											reinterpret_cast<DWORD*>(&mi)))
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - ServerSupportFunction() failed 0x%08lX\n", sc);
			goto ret;
		}

		DebugTrace ("IEcbBase::ScSSFReqMapUrlToPathEx() - ServerSupportFunction"
				"(HSE_REQ_MAP_URL_TO_PATH_EX) succeded!\n"
				"mapinfo:\n"
				"- url \"%hs\" maps to \"%hs\"\n"
				"- dwFlags = 0x%08x\n"
				"- cchMatchingPath = %d\n"
				"- cchMatchingURL  = %d\n",
				pszUrl.get(),
				mi.lpszPath,
				mi.dwFlags,
				mi.cchMatchingPath,
				mi.cchMatchingURL);

		//	The value for cbPath, at this point, should include the null
		//	termination, and for that reason cbPath will always be more
		//	than the length of the matching path.
		//
		Assert ('\0' == mi.lpszPath[cbPath - 1]);
		Assert (mi.cchMatchingPath < cbPath);
		Assert (mi.cchMatchingURL < cbUrl);

		//	First translate the matching path so we would know its
		//	length and would be able to pass it back
		//
		if (mi.cchMatchingPath)
		{
			//	Converting will never yield the buffer bigger than one we already have
			//
			pmi->cchMatchingPath = MultiByteToWideChar(CP_ACP,
													   MB_ERR_INVALID_CHARS,
													   mi.lpszPath,
													   mi.cchMatchingPath,
													   pmi->lpszPath,
													   MAX_PATH);
			if (0 == pmi->cchMatchingPath)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
				goto ret;
			}
		}
		else
		{
			pmi->cchMatchingPath = 0;
		}

		//	Convert the remainder of the path including the '\0' termination 
		//
		cchPath = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  mi.lpszPath + mi.cchMatchingPath,
									  cbPath - mi.cchMatchingPath,
									  pmi->lpszPath + pmi->cchMatchingPath,
									  MAX_PATH - pmi->cchMatchingPath);
		if (0 == cchPath)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Find the matching URL length for wide version
		//
		if (mi.cchMatchingURL)
		{
			pmi->cchMatchingURL = MultiByteToWideChar(CP_ACP,
													  MB_ERR_INVALID_CHARS,
													  pszUrl.get(),
													  mi.cchMatchingURL,
													  0,
													  0);
			if (0 == pmi->cchMatchingURL)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("IEcbBase::ScReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
				goto ret;
			}
		}
		else
		{
			pmi->cchMatchingURL = 0;
		}

		//	Pass back the length of the storage path including '\0' termination
		//
		if (pcch)
		{
			*pcch = pmi->cchMatchingPath + cchPath;
		}

	ret:
		
		return sc;
	}

protected:

	//	Declare the version constant
	//	
	enum
	{
		IIS_VERSION_6_0	= 0x60000
	};

	//	A POINTER to the original EXTENSION_CONTROL_BLOCK.
	//	Using a reference would make it impossible for us
	//	to tell if IIS ever requires that we use the
	//	EXTENSION_CONTROL_BLOCK passed into async I/O
	//	completion routines for subsequent I/O.
	//
	EXTENSION_CONTROL_BLOCK * m_pecb;

	IEcbBase( EXTENSION_CONTROL_BLOCK& ecb) :
		m_pecb(&ecb)
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	}

public:
	virtual BOOL FSsl() const = 0;
	virtual BOOL FFrontEndSecured() const = 0;
	virtual BOOL FBrief() const = 0;
	virtual ULONG LcidAccepted() const = 0;
	virtual VOID  SetLcidAccepted(LCID lcid) = 0;
	virtual LPCSTR LpszRequestUrl() const = 0;
	virtual LPCWSTR LpwszRequestUrl() const = 0;
	virtual UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const = 0;
	virtual UINT CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const = 0;
	virtual UINT CchGetServerName( LPCSTR * ppszServer ) const = 0;
	virtual UINT CchGetServerNameW( LPCWSTR * ppwszServer ) const = 0;
	virtual UINT CchGetVirtualRoot( LPCSTR * ppszVroot ) const = 0;
	virtual UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const = 0;
	virtual UINT CchGetMatchingPathW( LPCWSTR * ppwszMatching ) const = 0;
	virtual LPCWSTR LpwszPathTranslated() const = 0;
	virtual CInstData& InstData() const = 0;

	virtual BOOL FGetServerVariable( LPCSTR	lpszName,
									 LPSTR lpszValue,
									 DWORD * pcbValue ) const = 0;
	virtual BOOL FGetServerVariable( LPCSTR lpszName,
									 LPWSTR lpwszValue,
									 DWORD * pcchValue ) const = 0;

    BOOL
	WriteClient( LPVOID  lpvBuf,
				 LPDWORD lpdwcbBuf,
				 DWORD   dwFlags ) const
	{
		Assert( m_pecb );

		return m_pecb->WriteClient( m_pecb->ConnID,
									lpvBuf,
									lpdwcbBuf,
									dwFlags );
	}

    BOOL
	ReadClient( LPVOID  lpvBuf,
				LPDWORD lpdwcbBuf ) const
	{
		Assert( m_pecb );

		return m_pecb->ReadClient( m_pecb->ConnID,
								   lpvBuf,
								   lpdwcbBuf );
	}

    BOOL
	ServerSupportFunction( DWORD      dwHSERequest,
						   LPVOID     lpvBuffer,
						   LPDWORD    lpdwSize,
						   LPDWORD    lpdwDataType ) const
	{
		Assert( m_pecb );

		return m_pecb->ServerSupportFunction( m_pecb->ConnID,
											  dwHSERequest,
											  lpvBuffer,
											  lpdwSize,
											  lpdwDataType );
	}

	SCODE
	ScReqMapUrlToPathEx( LPCWSTR pwszUrl,
						 UINT * pcch,
						 HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		if ( m_pecb->dwVersion >= IIS_VERSION_6_0 )
		{
			return ScReqMapUrlToPathEx60After( pwszUrl,
											   pcch,
											   pmi );
		}
		else
		{
			return ScReqMapUrlToPathEx60Before( pwszUrl,
												pcch,
												pmi );
		}
	}
};

class IEcb : public IEcbBase
{
	//	NOT IMPLEMENTED
	//
	IEcb( const IEcb& );
	IEcb& operator=( const IEcb& );

protected:

	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IEcb( EXTENSION_CONTROL_BLOCK& ecb ) :
		IEcbBase(ecb)
	{}

	~IEcb();

public:
	//	ACCESSORS
	//
	LPCSTR
	LpszMethod() const
	{
		Assert( m_pecb );

		return m_pecb->lpszMethod;
	}

	LPCSTR
	LpszQueryString() const
	{
		Assert( m_pecb );

		return m_pecb->lpszQueryString;
	}

	DWORD
	CbTotalBytes() const
	{
		Assert( m_pecb );

		return m_pecb->cbTotalBytes;
	}

	DWORD
	CbAvailable() const
	{
		Assert( m_pecb );

		return m_pecb->cbAvailable;
	}

	const BYTE *
	LpbData() const
	{
		Assert( m_pecb );

		return m_pecb->lpbData;
	}

	virtual LPCWSTR LpwszMethod() const = 0;
	virtual UINT CbGetRawURL( LPCSTR * ppszRawURL ) const = 0;
	virtual LPCSTR LpszUrlPrefix() const = 0;
	virtual LPCWSTR LpwszUrlPrefix() const = 0;
	virtual UINT CchUrlPortW( LPCWSTR * ppwszPort ) const = 0;

	virtual HANDLE HitUser() const = 0;
	virtual BOOL FKeepAlive() const = 0;
	virtual BOOL FCanChunkResponse() const = 0;
	virtual BOOL FAuthenticated() const = 0;
	virtual BOOL FProcessingCEUrl() const = 0;
	virtual BOOL FIIS60OrAfter() const = 0;

	virtual LPCSTR LpszVersion() const = 0;

	virtual BOOL FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei ) = 0;

	virtual SCODE ScAsyncRead( BYTE * pbBuf,
							   UINT * pcbBuf,
							   IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncWrite( BYTE * pbBuf,
								DWORD  dwcbBuf,
								IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
									   IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
											 LPSTR pszStatus ) = 0;

	virtual SCODE ScExecuteChild( LPCWSTR pwszURI, LPCSTR pszQueryString, BOOL fCustomErrorUrl ) = 0;

	virtual SCODE ScSendRedirect( LPCSTR lpszURI ) = 0;

	virtual IMDData& MetaData() const = 0;
	virtual LPCWSTR PwszMDPathVroot() const = 0;

#ifdef DBG
	virtual void LogString( LPCSTR szLocation ) const = 0;
#else
	void LogString( LPCSTR ) const {};
#endif

	//	MANIPULATORS
	//
	virtual VOID SendAsyncErrorResponse( DWORD dwStatusCode,
										 LPCSTR pszBody,
										 DWORD cchzBody,
										 LPCSTR pszStatusDescription,
										 DWORD cchzStatusDescription ) = 0;

	virtual DWORD HSEHandleException() = 0;

	//	To be used ONLY by request/response.
	//
	virtual void SetStatusCode( UINT iStatusCode ) = 0;
	virtual void SetConnectionHeader( LPCWSTR pwszValue ) = 0;
	virtual void SetAcceptLanguageHeader( LPCSTR pszValue ) = 0;
	virtual void CloseConnection() = 0;
};

IEcb * NewEcb( EXTENSION_CONTROL_BLOCK& ecb,
			   BOOL fUseRawUrlMappings,
			   DWORD * pdwHSEStatusRet );

#ifdef DBG
void InitECBLogging();
void DeinitECBLogging();
#endif

//
//	Routines to manipulate metadata (metabase) paths
//
ULONG CbMDPathW( const IEcb& ecb, LPCWSTR pwszURI );
VOID MDPathFromURIW( const IEcb& ecb, LPCWSTR pwszURI, LPWSTR pwszMDPath );

#endif // !defined(_ECB_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\exguid.h ===
//	========================================================================
//
//	X G U I D . H
//
//		Header file for common GUID related data shared by DAVEX, EXOLEDB
//		and EXDAV.
//
//	========================================================================

#ifndef _XGUID_H_
#define _XGUID_H_

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS
#define USES_PS_INTERNET_HEADERS
#include <mapiguid.h>

//	An enumeration of all the well-known GUIDs. Specifying a GUID by its
//	enumeration avoids marshalling and unmarshalling the entire GUID.
//$REVIEW: If the number of well-known GUIDs ever gets greater than TWELVE
//$REVIEW: we need to find another scheme to represent them. This is
//$REVIEW: because, during marshalling, we lay out the GUIDs after the
//$REVIEW: MAPINAMEID array in our buffer and convert their addresses
//$REVIEW: into offsets. The minimum offset is 12(size of MAPINAMEID
//$REVIEW: structure) when we have a single sized array. We don't want
//$REVIEW: to confuse an offset with a well-known GUID and vice-versa.
//$LATER: There is no point in having an enumeration of just one guid.
//	We should add some of the other well-known guids such as PS_MAPI,
//	PS_INTERNET_HEADERS and the outlook guids or remove this enumeration
//	altogether.
//
enum {
	FIRST_GUID,
	MAPI_PUBLIC = FIRST_GUID,
	LAST_GUID = MAPI_PUBLIC
};

//	A table of well-known guids for quick access.
//
const LPGUID rgGuidTable[LAST_GUID - FIRST_GUID + 1] = {
	(LPGUID)&PS_PUBLIC_STRINGS,
};

/*
 *	FWellKnownGUID
 *
 *	Purpose:
 *		Determines if a GUID is a well-known one. Well-known GUIDS are
 *		enumerated above. If a GUID is well-known, its pointer is a
 *		special value equal to its enumeration.
 *	Arguments:
 *		lpguid		Pointer to the GUID
 *	Returns:
 *		TRUE if the GUID is well known
 *		FALSE otherwise
 */
__inline BOOL
FWellKnownGUID(LPGUID lpguid)
{
	//	No need to compare lpguid with FIRST_GUID, as it's always greater
	//	than FIRST_GUID. Acutally, such comparison may cause C4296 in build
	//
	if (LAST_GUID >= (DWORD_PTR)lpguid)
		return TRUE;
	else return FALSE;
}

#endif //!_XGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\exo.h ===
/*
 *	e x o . h
 *
 *	Purpose:
 *		Base Exchange COM Object
 *
 *		Any Exchange object that implements one or more COM interfaces
 *		should derive from EXObject and create an interface table
 *		using the macros below.
 *
 *	Originator:
 *		JohnKal
 *	Owner:
 *		BeckyAn
 *
 *	Copyright (C) Microsoft Corp 1993-1997. All rights reserved.
 */


//
//	How to use the macros (overview).
//	You need to do three things:
//		Declare your class.
//		Route your IUnknown processing to EXO.
//		Fill in EXO's data structures.
//
//	When declaring your class, you must:
//		Inherit from EXO.
//
//	To route your IUnknown processing to EXO:
//		Put the EXO[A]_INCLASS_DECL macro in the PUBLIC part of your class.
//			NOTE: This also declares the EXO static data in your class.
//
//	When filling in EXO's data structures:
//		In some source-file, build an interface mapping table.
//			BEGIN_INTERFACE_TABLE
//			INTERFACE_MAP
//			END_INTERFACE_TABLE
//		In the same source-file, after the interface mapping table,
//		declare & fill in the EXO class info structure.
//			EXO[A]_GLOBAL_DATA_DECL
//
//	Quick example:
//
/*
In snacks.h

class CSnackBag: public EXO, public IFiddle, public IFaddle
{
public:
	EXO_INCLASS_DECL(CSnackBag);

	// IFiddle methods
	// IFaddle methods
protected:
	// protected methods & data
private:
	// private methods & data
};

In snacks.cpp

BEGIN_INTERFACE_TABLE(CSnackBag)
	INTERFACE_MAP(CSnackBag, IFiddle),
	INTERFACE_MAP(CSnackBag, IFaddle)
END_INTERFACE_TABLE(CSnackBag);

EXO_GLOBAL_DATA_DECL(CSnackBag, EXO);

*/
//
//

#ifndef __exo_h_
#define __exo_h_


// Macros EXO needs ////////////////////////////////////////
// NOTE: All are named to avoid local name collisions, for your shopping convenience!

// Compute the offset to 'this' (of a specific type) when it's cast from one
// interface to another.  (concept: punk = (intf2) (intf1) (class) pobj --
// casting pobj, an instance of class, "from" intf1 "to" intf2.)
// We use them to get the offset from EXO (who is doing all the real work)
// to another interface in a particular class.
// NOTE: This is done in two steps because the compiler (VC5.0) was unable
// to figure out the math at compile-time when we subtracted one from the other.
// These values are used to initialize our static tables, and we don't
// want to explicitly call CRT_INIT just to get a few offsets.  So use two steps.
// (To get back to one step, combine these two steps as in ApplyDbCast, Down - Up).
// To is the delta of intf2 ("to") in cls.  From is the delta of intf1 ("from").
//
// NOTE: The 0x1000 for the pointer seems weird, but that is randomly chosen
// value and the thing we are interested in is the difference between the values
// of return from EXODbCastTo (IIDINFO::cbDown) and EXODbCastFrom (IIDINFO::cbUp).
//
#define EXODbCastTo(_cls, _intf1, _intf2)		((ULONG_PTR)static_cast<_intf2 *>(static_cast<_cls *>((void *)0x1000)))
#define EXODbCastFrom(_cls, _intf1, _intf2)		((ULONG_PTR)static_cast<_intf1 *>(static_cast<_cls *>((void *)0x1000)))

// apply that offset since the base class can't do it automagically
#define EXOApplyDbCast(_intf, _pobj, _cbTo, _cbFrom)	((_intf *)((BYTE *)_pobj + _cbTo - _cbFrom))

// Gives the count of elements in an array
#define EXOCElems(_rg)							(sizeof(_rg)/sizeof(_rg[0]))

// EXO is an abstract base class.  Since you can't instantiate him directly,
// he doesn't need his vtable pointers set in the ctor/dtor.  (And he
// promises not to do ANYTHING in his ctor/dtor that could cause a virtual
// function to be called).  So if we have a supporting MS C-compiler,
// turn off his vtables.
#if _MSC_VER<1100
#define EXO_NO_VTABLE
#else	// _MSC_VER check
#ifdef _EXO_DISABLE_NO_VTABLE
#define EXO_NO_VTABLE
#else	// !_EXODISABLE_NO_VTABLE
#define EXO_NO_VTABLE __declspec(novtable)
#endif	// _EXO_DISABLE_NO_VTABLE
#endif	// _MSC_VER check


// Global flag to turn on/off the EXO debug tracing.
#ifdef DBG
extern BOOL g_fExoDebugTraceOn;
#endif // DBG


// Interface map ////////////////////////////////////////


/*
 *  IIDINFO -- Interface ID (IID) INFOrmation
 *
 *	Contains a list of interfaces and offsets to convert an EXO-derived
 *	object pointer to that interface.
 */

typedef struct							// Information about interfaces.
{
	LPIID		iid;					// Interface ID.
	ULONG_PTR	cbDown;					// offset of interface from beginning
	ULONG_PTR	cbUp;					// of object.
#ifdef DBG
	LPTSTR		szIntfName;				// Interface name
#endif	// DBG
} IIDINFO;

// Macros for the name of a class's interface mapping table.
#define INTERFACE_TABLE(_cls) _cls ## ::c_rgiidinfo
#define DECLARE_INTERFACE_TABLE_INCLASS(_cls) static const IIDINFO c_rgiidinfo[]


// Helper macros to fill in the interface mapping table.
#ifdef DBG

#define INTERFACE_MAP_EX(_cl, _iid, _intf)			\
	{ (LPIID) & _iid, EXODbCastTo(_cl, EXO, _intf), EXODbCastFrom(_cl, EXO, _intf), TEXT(# _intf) }

#else	// !DBG

#define INTERFACE_MAP_EX(_cl, _iid, _intf)			\
	{ (LPIID) & _iid, EXODbCastTo(_cl, EXO, _intf), EXODbCastFrom(_cl, EXO, _intf) }

#endif	// DBG else


// Macros to actually fill in the interface mapping table.
//
// Use the BEGIN_INTERFACE_TABLE macro to start a table definition.
// Use the INTERFACE_MAP macro to express support for standard interfaces.
// These should be interfaces which, when prepended by IID_, yield a valid
// IID name. If you are doing advanced hackery, use the INTERFACE_MAP_EX
// macro instead. It allows you more control over which IID_ gets mapped
// to which interface.
// Use the END_INTERFACE_TABLE macro to end your table definition.
//
// NOTE: It is assumed that the very first interface of any non-aggregated
// class derived from EXO does double work as its IUnknown interface. This
// explains the '0' offset next to IID_IUnknown in the BEGIN_INTERFACE_TABLE
// macro below.

#ifdef DBG

#define BEGIN_INTERFACE_TABLE(_cl)					\
const IIDINFO INTERFACE_TABLE(_cl)[] =				\
{													\
	{ (LPIID) & IID_IUnknown, 0, 0, TEXT("IUnknown") },

#else	// DBG

#define BEGIN_INTERFACE_TABLE(_cl)					\
const IIDINFO INTERFACE_TABLE(_cl)[] =				\
{													\
	{ (LPIID) & IID_IUnknown, 0, 0 },
#endif	// DBG, else


#define INTERFACE_MAP(_cl, _intf)					\
	INTERFACE_MAP_EX(_cl, IID_ ## _intf, _intf)


#define END_INTERFACE_TABLE(_cl)					\
}


#ifdef EXO_CLASSFACTORY_ENABLED
// EXchange Object TYPes
// To be used with a general-purpose class factory.  These types
// can be used to check if a class needs special support in the DLL's
// self-registration (DllRegisterServer) routine.
enum {
	exotypNull = 0,			// invalid value
	exotypAutomation,		// OLE automation object derived from CAutomationObject
	exotypControl,			// ActiveX control derived from CInternetControl or COleControl
	exotypPropPage,			// property page derived from CPropertyPage
	exotypNonserver,		// not registered as an OLE server
};

// EXO prototype for a named constructor.  For use with a general-purpose
// class factory.
typedef HRESULT (* PFNEXOCLSINFO)(const struct _exoclsinfo *pxci, LPUNKNOWN punkOuter,
								  REFIID riid, LPVOID *ppvOut);
#endif // EXO_CLASSFACTORY_ENABLED


/*
 *	EXOCLSINFO -- EXchange Object CLaSs INFOrmation.
 *
 *	This structure contains all the constant class information of a
 *	particular class.  This includes the interface mapping table
 *	(IIDINFO count and array) and a pointer to the parent class's
 *	EXOCLSINFO structure.  These items are used by EXO's base implementation
 *	of QueryInterface.  The parent class here must be a subclass of EXO,
 *	or EXO itself if this class derives directly from EXO.  Thus these
 *	structures make a traceable chain of inforamtion back up to EXO, the root.
 *	For debugging purposes, a stringized version of the class name is included.
 *	In support of a general-purpose class factory, additional information,
 *	such as the CLSID and a standard creation function can be included.
 */

typedef struct _exoclsinfo
{
	UINT			ciidinfo;				// Count of interfaces this class supports.
	const IIDINFO * rgiidinfo;				// Info for interfaces this class supports.
	const _exoclsinfo * pexoclsinfoParent;	// Parent's EXOCLSINFO structure.
#ifdef DBG
	LPTSTR			szClassName;			// Class name -- for debug purposes.
#endif // DBG
#ifdef EXO_CLASSFACTORY_ENABLED
	// Data to use with a general, multi-class class factory.
	int				exotyp;					// type of the object
	const CLSID *	pclsid;					// CLaSs ID (NULL if not co-creatable)
	PFNEXOCLSINFO	HrCreate;				// Function to create an object of this class.
#endif // EXO_CLASSFACTORY_ENABLED
} EXOCLSINFO;

// Macros for the name of a class's exoclsinfo.
#define EXOCLSINFO_NAME(_cls) _cls ## ::c_exoclsinfo
#define DECLARE_EXOCLSINFO(_cls) const EXOCLSINFO EXOCLSINFO_NAME(_cls)
#define DECLARE_EXOCLSINFO_INCLASS(_cls) static const EXOCLSINFO c_exoclsinfo

// Helper macros to fill in the exoclsinfo.
#ifdef EXO_CLASSFACTORY_ENABLED
#ifdef DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), TEXT( #_cls ),							\
	  (_exotyp), (LPCLSID) (_pclsid),	(_pfn) }				\

#else // !DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent),											\
	  (_exotyp), (LPCLSID) (_pclsid),	(_pfn) }				\

#endif // DBG, else
#else // !EXO_CLASSFACTORY_ENABLED
#ifdef DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), TEXT( #_cls ) }

#else // !DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), }

#endif // DBG, else
#endif // EXO_CLASSFACTORY_ENABLED

// Macro to actually fill in the exoclsinfo.
#define EXOCLSINFO_CONTENT(_cls, _clsparent)					\
	EXOCLSINFO_CONTENT_EX( _cls, &EXOCLSINFO_NAME(_clsparent),	\
        exotypNonserver, &CLSID_NULL, NULL )


// Macros to access members in the exoclsinfo structure.
#ifdef DBG
#define NAMEOFOBJECT(_pexoclsinfo)		 (((EXOCLSINFO *)(_pexoclsinfo))->szClassName)
#endif // DBG
#ifdef EXO_CLASSFACTORY_ENABLED
#define CLSIDOFOBJECT(_pexoclsinfo)		 (*(((EXOCLSINFO *)(_pexoclsinfo))->pclsid))
#define CREATEFNOFOBJECT(_pexoclsinfo)	 (((EXOCLSINFO *)(_pexoclsinfo))->HrCreate)
#endif // EXO_CLASSFACTORY_ENABLED


// EXO and EXOA declarations ////////////////////////////////////////

/*
 *	EXO is the base class of Exchange objects that present one or
 *	more COM interfaces. To derive from EXO, follow the example
 *	below:
 *
 *	class MyClass : public EXO, public ISomeInterface1, public ISomeInterface2
 *	{
 *	public:
 *		EXO_INCLASS_DECL(MyClass);
 *
 *		methods for ISomeInterface1
 *		methods for ISomeInterface2
 *
 *	protected:
 *		protected member functions & variables
 *
 *	private:
 *		private member functions & variables
 *	};
 *
 *
 *	DISCLAIMER: currently EXO inherits from IUnknown to prevent
 *	maintainability problems that would show up if
 *	(void *) pexo != (void *) (IUnknown *) pexo.  Yes, this means
 *	12 extra bytes in our vtable.  Those extra bytes are worth it
 *	(and we already had a vtable -- pure virt. dtor!).  Go deal.
 */
class EXO_NO_VTABLE EXO : public IUnknown
{
public:
	// Declare EXO's support structures.
	DECLARE_INTERFACE_TABLE_INCLASS(EXO);
	DECLARE_EXOCLSINFO_INCLASS(EXO);


protected:
	// Making the constructor protected prevents people from making these
	// objects on the stack. The pure virtual destructor forces derived
	// classes to implement their own dtors, and prevents instances of
	// EXObject from being created directly. Of course, a derived class
	// may want to allow the creation of instances on the stack. It is
	// up to such derived classes to make their own constructors public.

	EXO();
	virtual ~EXO() = 0;					// pure virtual destructor
										// forces derived classes to
										// implement their own dtors.

	// InternalQueryInterface() does the QI work for all for interfaces
	// supported by this class (directly and from a child aggregate).
	// Your class should route its QI work to this call using
	// EXO[A]_INCLASS_DECL 99.9% of the time.
	// Only override this if you have AGGREGATED another object and want to
	// get them in on the action.  And even then, make sure to call
	// this method, EXO::InternalQueryInterface, directly before searching
	// your aggregatee (kid) This is YOUR base QI!!
	// See the EXO implementation of this function for more important details.
	virtual HRESULT InternalQueryInterface(REFIID riid, LPVOID * ppvOut);

	// InternalAddRef() & InternalRelease() do the AddRef & Release work
	// for all descendents of EXO.  You should ALWAYS (100% of the time)
	// route AddRef/Release work to these functions.
	ULONG InternalAddRef();
	ULONG InternalRelease();

	// Virtual function to grab the correct lowest-level exoclsinfo struct.
	// All descendants who introduce a new interface (and thus have a new
	// interface mapping table) should implement this method (and pass back
	// an appropriately-chained exoclsinfo struct!) using one of these
	// macros: Iff you are an aggregator DECLARE_GETCLSINFO.  Otherwise,
	// EXO[A]_INCLASS_DECL will do the right stuff for you.
	virtual const EXOCLSINFO * GetEXOClassInfo() = 0;
		// Again, pure virtual to force derived classes to
		// implement their own before they can be instantiated.

	// Our reference counter.
	LONG m_cRef;
};


/*
 *	EXOA is the base class of Exchange objects that support being aggregated
 *	(in addition to having other OLE interfaces). To derive from EXOA, follow
 *	the example below:
 *
 *	class MyClass : public EXOA, public ISomeInterface1, public ISomeInterface2
 *	{
 *	public:
 *		EXOA_INCLASS_DECL(MyClass);
 *
 *		methods for ISomeInterface1
 *		methods for ISomeInterface2
 *
 *	protected:
 *		protected member functions & variables
 *
 *	private:
 *		private member functions & variables
 *	};
 */

class EXO_NO_VTABLE EXOA : public EXO
{
protected:
	// The following 3 methods are not virtual, so don't get into a tiff.
	HRESULT DeferQueryInterface(REFIID riid, LPVOID * ppvOut)
			{return m_punkOuter->QueryInterface(riid, ppvOut);}
	ULONG	DeferAddRef(void)
			{return m_punkOuter->AddRef();}
	ULONG	DeferRelease(void)
			{return m_punkOuter->Release();}

	// Making the constructor protected prevents people from making these
	// objects on the stack. The pure virtual destructor forces derived
	// classes to implement their own dtors, and prevents instances of
	// EXOA from being created directly. Of course, a derived class
	// may want to allow the creation of instances on the stack. It is
	// up to such derived classes to make their own constructors public.

	EXOA(IUnknown * punkOuter);
	virtual ~EXOA() = 0;				// pure virtual destructor
										// forces derived classes to
										// implement their own dtors.

	IUnknown * m_punkOuter;
	IUnknown * PunkPrivate(void) {return &m_exoa_unk;}

private:
	class EXOA_UNK : public IUnknown
	{
	public:
		STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut);
		STDMETHOD_(ULONG, AddRef)();
		STDMETHOD_(ULONG, Release)();
	public:
		EXOA *	m_pexoa;
	};
	friend class EXOA_UNK;

	EXOA_UNK	m_exoa_unk;
};



// Macros to properly route IUnknown calls //////////////////////////
// (Macros are your friends!) ///////////////////////////////////////

// This routes the IUnknown calls for an EXO-derived object properly.
#define DECLARE_EXO_IUNKNOWN(_cls)								\
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut)		\
		{return _cls::InternalQueryInterface(riid, ppvOut);}	\
	STDMETHOD_(ULONG, AddRef)(void)								\
		{return EXO::InternalAddRef();}							\
	STDMETHOD_(ULONG, Release)(void)							\
		{return EXO::InternalRelease();}						\

// If you are an aggregator (you have aggregatee kids),
// use this macro to override EXO's InternalQueryInterface
// and call your kids there.
#define OVERRIDE_EXO_INTERNALQUREYINTERFACE						\
	HRESULT InternalQueryInterface(REFIID, LPVOID * ppvOut)

// This routes the IUnknown calls for an EXOA-derived object properly.
#define DECLARE_EXOA_IUNKNOWN(_cls)								\
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut)		\
		{return EXOA::DeferQueryInterface(riid, ppvOut);}		\
	STDMETHOD_(ULONG, AddRef)(void)								\
		{return EXOA::DeferAddRef();}							\
	STDMETHOD_(ULONG, Release)(void)							\
		{return EXOA::DeferRelease();}							\


// Macro to implement GetEXOClassInfo & give back a pointer to the
// a correctly-chained classinfo struct.
#define DECLARE_GETCLSINFO(_cls)				\
		const EXOCLSINFO * GetEXOClassInfo() { return &c_exoclsinfo; }


// Here are the simple macros to use ///////////////////

// Use these in your class to declare the class's EXO data and
// to implement the properly-deferring IUnknown.

#define EXO_INCLASS_DECL(_cls)					\
		DECLARE_EXO_IUNKNOWN(_cls)				\
		DECLARE_GETCLSINFO(_cls);				\
		DECLARE_INTERFACE_TABLE_INCLASS(_cls);	\
		DECLARE_EXOCLSINFO_INCLASS(_cls)

#define EXOA_INCLASS_DECL(_cls)					\
		DECLARE_EXOA_IUNKNOWN(_cls)				\
		DECLARE_GETCLSINFO(_cls);				\
		DECLARE_INTERFACE_TABLE_INCLASS(_cls);	\
		DECLARE_EXOCLSINFO_INCLASS(_cls)

// Use these in your implementation file to define (declare space
// for the data AND fill it in) the class's EXO data.
// NOTE: These must come after your interface table declaration.
// NOTE: The parent listed here must be in the chain between you and EXO.

#define EXO_GLOBAL_DATA_DECL(_cls, _clsparent)	\
		DECLARE_EXOCLSINFO(_cls) =				\
		EXOCLSINFO_CONTENT(_cls, _clsparent)

#define EXOA_GLOBAL_DATA_DECL(_cls, _clsparent)	\
		EXO_GLOBAL_DATA_DECL(_cls, _clsparent)




#endif // !__exo_h_

// end of exo.h ////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\gencache.h ===
#ifndef _GENCACHE_H_
#define _GENCACHE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	GENCACHE.H
//
//		Header for generic cache classes.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#ifdef _EXDAV_
#error "buffer.h uses throwing allocators"
#endif

//	Include the non-exdav-safe/throwing allocators
#include <mem.h>
#include <autoptr.h>
#include <synchro.h>

//	Include exdav-safe CCache definition header
#include <ex\gencache.h>

//	========================================================================
//
//	TEMPLATE CLASS CMTCache
//
//	Multithread-safe generic cache.
//
template<class _K, class _Ty>
class CMTCache
{
	typedef CCache<_K, _Ty> CBaseCache;

	//
	//	The cache
	//
	CBaseCache				m_cache;

	//
	//	Multi-reader/single-writer lock to protect the cache
	//
	mutable CMRWLock		m_mrw;

	//	NOT IMPLEMENTED
	//
	CMTCache& operator=( const CMTCache& );
	CMTCache( const CMTCache& );

public:
	typedef CBaseCache::IOp IOp;

	//	CREATORS
	//
	CMTCache()
	{
		if ( !m_mrw.FInitialize() )
			throw CLastErrorException();
		//	If this fails, our allocators will throw for us.
		m_cache.FInit();
	}

	//	ACCESSORS
	//
	BOOL FFetch( const _K& key, _Ty * pValueRet ) const
	{
		CSynchronizedReadBlock blk(m_mrw);

		return m_cache.FFetch(key, pValueRet);
	}

	void ForEach( IOp& op ) const
	{
		CSynchronizedReadBlock blk(m_mrw);

		m_cache.ForEach(op);
	}

	//	MANIPULATORS
	//
	void Set( const _K& key, const _Ty& value )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		//	If this fails, our allocators will throw for us.
		(void)m_cache.FSet(key, value);
	}

	void Add( const _K& key, const _Ty& value )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		//	If this fails, our allocators will throw for us.
		(void)m_cache.FAdd(key, value);
	}

	void Remove( const _K& key )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		m_cache.Remove(key);
	}

	void Clear()
	{
		CSynchronizedWriteBlock blk(m_mrw);

		m_cache.Clear();
	}
};


//	========================================================================
//
//	CLASS CAccInv
//
//		Access/Invalidate synchronization logic.
//		This class encapsulates the logic needed to safely read
//		(access) from a datasource that may be invalidated (invalidate)
//		by an asynchronous, external event.  (IN-ternal events
//		should ALWAYS use the synch mechanisms we provide DIRECTLY.)
//
class IEcb;
class CAccInv
{
	//
	//	Multi-reader/single-writer lock to synchronize
	//	access and invalidation functions
	//
	CMRWLock m_mrw;

	//
	//	Flag to indicate whether the object is invalid.
	//	If 0, the object is invalid and and will
	//	be refreshed the next time it is accessed.
	//
	LONG m_lValid;

	//	NOT IMPLEMENTED
	//
	CAccInv& operator=( const CAccInv& );
	CAccInv( const CAccInv& );

public:

	//	Forward declaration
	//
	class IAccCtx;

protected:
	//
	//	Refresh operation to be provided by derived class
	//
	virtual void RefreshOp( const IEcb& ecb ) = 0;

	void Access( const IEcb& ecb, IAccCtx& context )
	{
		//
		//	Repeat the following validity check, refresh, and
		//	access, and recheck sequence until the access succeeds
		//	and the object is valid from start to finish.
		//
		for (;;)
		{
			//
			//	Check validity, and refresh if invalid.
			//
			while ( !m_lValid )
			{
				CTryWriteBlock blk(m_mrw);

				//
				//	Only one thread should refresh the object.
				//	Other threads detecting that the object is invalid
				//	periodically retry checking validity (spin waiting)
				//	until the object becomes valid.
				//
				if ( blk.FTryEnter() )
				{
					//
					//	By being the first to enter the write lock,
					//	this thread gets to refresh the object.
					//

					//
					//	Mark the object as valid BEFORE actually
					//	refreshing it so that it is possible to
					//	tell if the object gets marked invalid by
					//	another thread while it is being refreshed.
					//
					InterlockedExchange( &m_lValid, 1 );

					//
					//	Refresh the object
					//
					RefreshOp(ecb);
				}
				else
				{
					//
					//	Give up the rest of this thread's time slice so
					//	that the thread holding the write lock may finish
					//	as soon as possible.
					//
					Sleep(0);
				}
			}

			//
			//	The object is valid (or at least it was a tiny instant
			//	ago) so go ahead and access it.  Apply a read lock
			//	to prevent other threads from refreshing it during
			//	access (if the object is marked invalid during access).
			//
			{
				CSynchronizedReadBlock blk(m_mrw);

				context.AccessOp( *this );

				//
				//	Test whether the object is still valid after access.
				//	(Do this while holding the read lock to prevent other
				//	threads from marking the object as invalid and refreshing
				//	it since it was accessed on this thread.)  If the
				//	object is still valid now, then it was valid for
				//	the entire operation, so we're done.
				//
				if ( m_lValid )
					break;
			}
		}
	}

public:

	class IAccCtx
	{

	public:

		//
		//	Method on the cache context to perform the access operation.
		//	This allows for caches to support multiple access methods for
		//	both ::Lookup() and ::ForEach() mechanisms
		//
		virtual void AccessOp( CAccInv& cache ) = 0;
	};

	//	The object is initially considered invalid.  It will be refreshed
	//	the first time it is accessed.
	//
	CAccInv() :
		m_lValid(0)
	{
		if ( !m_mrw.FInitialize() )
			throw CLastErrorException();
	}

	void Invalidate()
	{
		InterlockedExchange( &m_lValid, 0 );
	}
};

#endif // !_GENCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\htmlmap.h ===
/*
 *	H T M L M A P . H
 *
 *	HTML .MAP file processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_HTMLMAP_H_
#define _HTMLMAP_H_

BOOL
FIsMapProcessed (
	LPCSTR lpszQueryString,
	LPCSTR lpszUrlPrefix,
	LPCSTR lpszServerName,
	LPCSTR pszMap,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf);

#endif	// _HTMLMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\implstub.h ===
#ifndef _IMPLSTUB_H_
#define _IMPLSTUB_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	IMPLSTUB.H
//
//	This file is similar to impldef.h. The difference is that impldefs.h are
//	meant to be implemented by ISAPI dlls. and this implstub.h are for
//	those functions that might be implemented by all CAL componets.
//

namespace IMPLSTUB
{
	VOID __fastcall SaveHandle(HANDLE hHandle);
}

#endif  // _IMPLSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\except.h ===
#ifndef _EXCEPT_H_
#define _EXCEPT_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EXCEPT.H
//
//		Exception classes used by this implementation
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <stdexcpt.h>
#include <eh.h>

#include <caldbg.h>		//	For gc_szDbgIni definition

//	------------------------------------------------------------------------
//
//	CLASS CWin32ExceptionHandler
//
//		Handles Win32 exceptions (access violations, alignment faults, etc.)
//		by constructing a C++ exception from information in the Win32 SEH
//		exception record and throwing it.
//
class CWin32ExceptionHandler
{
	_se_translator_function			m_pfnOldHandler;

	static void __cdecl HandleWin32Exception( unsigned int, struct _EXCEPTION_POINTERS * );

public:
	CWin32ExceptionHandler();
	~CWin32ExceptionHandler();
};

//	------------------------------------------------------------------------
//
//	CLASS CDAVException
//
class CDAVException : public exception
{
public:
	//	CREATORS
	//
	CDAVException( const char * s = "DAV fatal error exception" );

	//	ACCESSORS
	//
#ifdef DBG
	virtual void DbgTrace() const;
#else
	void DbgTrace() const {}
#endif

	//	ACCESSORS
	//
	virtual HRESULT Hresult() const;
	virtual DWORD   DwLastError() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CHresultException
//
class CHresultException : public CDAVException
{
	HRESULT	m_hr;

public:
	CHresultException( HRESULT hr, const char * s = "HRESULT exception" ) :
		CDAVException(s),
		m_hr(hr)
	{
	}

	virtual HRESULT Hresult() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CLastErrorException
//
class CLastErrorException : public CDAVException
{
	DWORD	m_dwLastError;

public:
	CLastErrorException( const char * s = "LastError exception" ) :
		CDAVException(s),
		m_dwLastError(GetLastError())
	{
	}

	virtual DWORD DwLastError() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CWin32Exception
//
//		This exception is thrown as a result of any Win32 exception
//		(access violation, alignment fault, etc.)  By catching it
//		you can better determine what happened.
//
class CWin32Exception : public CDAVException
{
	unsigned int						m_code;
	const struct _EXCEPTION_POINTERS&	m_ep;


	//	NOT IMPLEMENTED
	//
	CWin32Exception& operator=( const CWin32Exception& );

public:
	//	CREATORS
	//
	CWin32Exception( unsigned int code, const struct _EXCEPTION_POINTERS& ep ) :
		CDAVException(),
		m_code(code),
		m_ep(ep)
	{
	}

	//	ACCESSORS
	//
#ifdef DBG
	virtual void DbgTrace() const;
#endif
};

#endif // !defined(_EXCEPT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\impldef.h ===
#ifndef	_IMPLDEF_H_
#define _IMPLDEF_H_

//	Implementation defined items ----------------------------------------------
//
//	The following must be DEFINED by the IMPL for use by the PARSER.
//

//	Allow header items --------------------------------------------------------
//
//	The impl. needs to define the following set of strings that identify the
//	methods supported by the impl. for particular resources.
//
extern const CHAR gc_szHttpBase[];
extern const CHAR gc_szHttpDelete[];
extern const CHAR gc_szHttpPut[];
extern const CHAR gc_szHttpPost[];
extern const CHAR gc_szDavCopy[];
extern const CHAR gc_szDavMove[];
extern const CHAR gc_szDavMkCol[];
extern const CHAR gc_szDavPropfind[];
extern const CHAR gc_szDavProppatch[];
extern const CHAR gc_szDavLocks[];
extern const CHAR gc_szDavSearch[];
extern const CHAR gc_szDavNotif[];
extern const CHAR gc_szDavBatchDelete[];
extern const CHAR gc_szDavBatchCopy[];
extern const CHAR gc_szDavBatchMove[];
extern const CHAR gc_szDavBatchProppatch[];
extern const CHAR gc_szDavBatchPropfind[];
extern const CHAR gc_szDavPublic[];
extern const CHAR gc_szCompliance[];
extern const UINT gc_cbszDavPublic;

//	Storage paths and urls ----------------------------------------------------
//
//	The storage path for a resource is no-different that the path as translated
//	by IIS.  This has not always been true, and there is code in the DAV source
//	tree that expects the path to have some sort of a prefix.
//
//	At the beginning of NT beta3 work, we are removing the idea that a storage
//	path in DAV looks any different than a storage path in IIS.  This is a very
//	important idea.  Otherwise, there could be items accessible via DAV that
//	are not accessible via IIS -- and visa versa.
//
//	Keeping this in mind...  There are several places where we have url's that
//	are a part of a DAV request that are not pre-handled for us by IIS.  Some
//	examples are the url's in the destination header of MOVE/COPY, the url's in
//	the scope of a SEARCH request, and the url's embedded in "if" headers.
//
//	There are also several instances where we may have to generate a url from
//	a storage path  -- as in the case of location headers and XML response
//	references.
//
//	The translation of those items uses only common elements.  So there is no
//	implementation specifc work that needs to be done here.
//

class IMethUtilBase;
class CMethUtil;
typedef CMethUtil IMethUtil;

//	The call to be used for proper conversion to unicode
//
SCODE __fastcall
ScConvertToWide(/* [in]     */	LPCSTR	pszSource,
				/* [in/out] */  UINT *	pcchDest,
				/* [out]    */	LPWSTR	pwszDest,
				/* [in]		*/	LPCSTR	pszAcceptLang,
				/* [in]		*/	BOOL	fUrlConversion);

//	The call to be used for canonicalization of URL
//
SCODE __fastcall
ScCanonicalizeURL( /* [in]     */ LPCWSTR pwszSrc,
				   /* [in/out] */ LPWSTR pwszDest,
				   /* [out]	   */ UINT * pcch );

//	The call to be used for canonicalization of URL,
//	taking into account if it is fully qualified
//
SCODE __fastcall
ScCanonicalizePrefixedURL( /* [in]     */ LPCWSTR pwszSrc,
						   /* [in/out] */ LPWSTR pwszDest,
						   /* [out]	   */ UINT * pcch );


//	These are the calls to be used to normalize URL
//
//	Normalization consists of 3 steps:
//		a) escaping of skinny version
//		b) conversion to unicode
//		c) canonicalization
//
SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCWSTR			pwszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang);

SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCSTR			pszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang);

SCODE __fastcall ScStoragePathFromUrl (
		/* [in] */ const IEcb& ecb,
		/* [in] */ LPCWSTR pwszUrl,
		/* [out] */ LPWSTR wszStgID,
		/* [in/out] */ UINT* pcch,
		/* [out] */ CVRoot** ppcvr = NULL);

SCODE __fastcall ScUrlFromStoragePath (
		/* [in] */ const IEcbBase& ecb,
		/* [in] */ LPCWSTR pwszPath,
		/* [out] */ LPWSTR pwszUrl,
		/* [in/out] */ UINT * pcb,
		/* [in] */ LPCWSTR pwszServer = NULL);

SCODE __fastcall ScUrlFromSpannedStoragePath (
		/* [in] */ LPCWSTR pwszPath,
		/* [in] */ CVRoot& vr,
		/* [in] */ LPWSTR pwszUrl,
		/* [in/out] */ UINT* pcch);

//	Wire urls -----------------------------------------------------------------
//
//	A note about a wire url.  IIS translate all its urls into CP_ACP.  So, to
//	keep consistant behavior in HTTPEXT, we also keep all local urls in CP_ACP.
//	However, for DAVEX, we don't hold to this.  We deal exclusively in CP_UTF8
//	style URLs.
//
//	However, when we spit the url back out over the wire.  The url must be in
//	UTF8.  Anytime a url goes back over the wire from IIS to client, it must be
//	sanitized via these calls.
//
SCODE __fastcall ScWireUrlFromWideLocalUrl (
		/* [in] */ UINT cchLocal,
		/* [in] */ LPCWSTR pwszLocalUrl,
		/* [in/out] */ auto_heap_ptr<CHAR>& pszWireUrl);

SCODE __fastcall ScWireUrlFromStoragePath (
		/* [in] */ IMethUtilBase* pmu,
		/* [in] */ LPCWSTR pwszStoragePath,
		/* [in] */ BOOL fCollection,
		/* [in] */ CVRoot* pcvrTranslate,
		/* [in/out] */ auto_heap_ptr<CHAR>& pszWireUrl);

BOOL __fastcall FIsUTF8Url (/* [in] */ LPCSTR pszUrl);

//	Child ISAPI aux. access check ---------------------------------------------
//
//	On both HTTPEXT and DAVEX, we have an additional stipulation that needs
//	satisfaction before we can hand back the source of an scriptmapped item.
//	We want to see if it has NT write access.
//	Note that among the parameters, pwszPath is used by HTTPEXT only and
//	pbSD is used by DAVEX only
//

SCODE __fastcall ScChildISAPIAccessCheck (
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ DWORD dwAccess,
	/* [in] */ LPBYTE pbSD);

//	Supported lock types ------------------------------------------------------
//
//	Return the supported locktype flags for the resource type.  HTTPEXT only
//	supports documents and collections.  DavEX, on the other hand, understands
//	structured documents.
//

DWORD __fastcall DwGetSupportedLockType (RESOURCE_TYPE rtResource);

//	Access perm hack for DAVEX ------------------------------------------------
//
//$SECURITY
//	In DAVEX only, if either a VR_USERNAME or VR_PASSWORD is set then
//	to avoid a security problem, shut off all access.
//
VOID ImplHackAccessPerms( LPCWSTR pwszVRUserName,
						  LPCWSTR pwszVRPassword,
						  DWORD * pdwAccessPerms );

//	DLL instance refcounting --------------------------------------------------
//
VOID AddRefImplInst();
VOID ReleaseImplInst();

//	Exception safe DLL instance refcounting -----------------------------------
//
typedef enum {
	ADD_REF = 0,
	TAKE_OWNERSHIP
} REF_ACTION;

class safeImplInstRef
{
	BOOL m_fRelease;

	//	NOT IMPLEMENTED
	//
	safeImplInstRef( const safeImplInstRef& );
	safeImplInstRef& operator=( const safeImplInstRef& );

public:

	//	CREATORS
	//
	safeImplInstRef(REF_ACTION ra) : m_fRelease(TRUE)
	{
		if (ADD_REF == ra)
			AddRefImplInst();
	}

	//	DESTRUCTOR
	//
	~safeImplInstRef()
	{
		if (m_fRelease)
			ReleaseImplInst();
	}

	//	MANIPULATOR
	//
	VOID relinquish()
	{
		m_fRelease = FALSE;
	}
};

BOOL FSucceededColonColonCheck(
	/* [in] */  LPCWSTR pwszURI);

#endif	// _IMPLDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\langid.h ===
//	========================================================================
//	LANGID.H
//
//	Cache to map between language ids (LCIDs) and MIME language specifiers
//	("en-us" etc.)
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//
//	========================================================================

#ifndef _LANGID_H_
#define _LANGID_H_

#include <ex\gencache.h>
#include <singlton.h>

//	We need to lookup LCID-s from strings on (IIS-side).
//
class CLangIDCache : private Singleton<CLangIDCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CLangIDCache>;

	//	Cache of mime mappings
	//
	typedef CCache<CRCSzi, LONG> CSzLCache;
	CSzLCache					m_cache;

	//	String data storage area.
	//
	ChainedStringBuffer<CHAR>	m_sb;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CLangIDCache() {};

	//	Function to fill cache with data.
	//
	static BOOL FFillCacheData();

	//	NOT IMPLEMENTED
	//
	CLangIDCache& operator=(const CLangIDCache&);
	CLangIDCache(const CLangIDCache&);

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CLangIDCache>::CreateInstance;
	using Singleton<CLangIDCache>::DestroyInstance;

	static BOOL FInitialize()
	{
		BOOL fSuccess = FALSE;

		//	Init all our failing members.
		//
		if (!Instance().m_cache.FInit())
			goto ret;

		//	Call the function to fill the cache.
		//	If we do not succeed let us not block,
		//	We will proceed with whatever we have got.
		//
		(void)Instance().FFillCacheData();

		fSuccess = TRUE;

	ret:
		return fSuccess;
	}

	//	Find LangID from MIME language string
	//
	static LONG LcidFind (LPCSTR psz);
};

#endif // !_LANGID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\instobj.h ===
#ifndef _INSTOBJ_H_
#define _INSTOBJ_H_

// Gives the count of elements in an array
//
#ifndef CElems
#define CElems(_rg)							(sizeof(_rg)/sizeof(_rg[0]))
#endif // !CElems

//	========================================================================
//
//	CLASS CInstData
//
//		Instance data for a single DAV instance (vserver x vroot combination).
//
class CInstData : public CMTRefCounted
{
	//	Data items describing this instance.
	//
	auto_heap_ptr<CHAR>			m_szVRoot;
	auto_heap_ptr<WCHAR>		m_wszVRoot;
	LONG						m_lServerID;

	auto_ptr<CChildVRCache>		m_pChildVRootCache;
	mutable auto_ptr<IPerfCounterBlock>	m_pPerfCounterBlock;

	//	NOT IMPLEMENTED
	//
	CInstData& operator=( const CInstData& );
	CInstData( const CInstData& );

	LPWSTR LpwszWideVroot( LPCSTR pszVRoot );

public:

	CInstData( LPCSTR szName );

	//	ACCESSORS
	//
	//	NOTE: These accessors do NOT give the caller ownership of the
	//	data object.  DO NOT put the returned objects into auto_ptrs
	//	and DO NOT release/delete them yourself!
	//
	IPerfCounterBlock& PerfCounterBlock() const { return *m_pPerfCounterBlock; }

	LPCSTR GetName() { return m_szVRoot; }
	LPCWSTR GetNameW() { return m_wszVRoot; }

	LONG GetServerId() { return m_lServerID; }
};


#endif // _INSTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\mem.h ===
/*
 *	M E M . H
 *
 *	DAV basic memory allocators.  Implementation of this class is
 *	owned by the individual implementations
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _MEM_H_
#define _MEM_H_

#ifdef _EXDAV_
#error "mem.h defines throwing allocators"
#endif

//	Global heap "class" ---------------------------------------------------------
//
//	This really only acts as a namespace.  I.e. there are no non-static members.
//	For historical reasons (and, mainly, to avoid changing a LOT of code from
//	calling "g_heap.Fn()" to calling "g_heap::Fn()"), g_heap still appears
//	outwardly to be a real object.
//
//	!!! CHeap is used by multiple components.  Specifically, it may be
//		*IMPLEMENTED* by multiple components in various locations.
//		When changing the CHeap interface, make sure to recompile
//		EVERYTHING in the project.
//
struct CHeap
{
	static BOOL FInit();
	static void Deinit();
	static LPVOID Alloc( SIZE_T cb );
	static LPVOID Realloc( LPVOID lpv, SIZE_T cb );
	static VOID Free( LPVOID pv );
};

extern CHeap g_heap;

//	Safe allocators
//
#include <ex\exmem.h>

// Try using pragmas to turn off the undesired warnings from the STL.
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

#include <memory>

// And undo it all so that we still get good checking!
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss


//	========================================================================
//
//	TEMPLATE CLASS heap_allocator<>
//
//		Allocator class to work with the STL (Standard C++ Template Library).
//		Allocations actually handled by our global heap allocator.
//
template<class _Ty>
class heap_allocator : public std::allocator<_Ty>
{
public:
	pointer allocate(size_type _N, const void *)
		{return (pointer) _Charalloc(_N * sizeof(_Ty)); }
	char _FARQ *_Charalloc(size_type _N)
		{return (char _FARQ *) g_heap.Alloc(_N); }
	void deallocate(void _FARQ *_P, size_type)
		{g_heap.Free(_P); }
};

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\langtocpid.h ===
//	========================================================================
//
//	Module:		   langtocpid.h
//
//	Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//	Description:	This file is used provide the support for HTTP_DAV
//					to make a best guess code page based on the Accept-
//					Language header. The code page is used to decode
//					non-UTF8 chanracters in URLs coming from Office/Rosebud
//					This file contains the static mapping of header values
//					to code pages as well as a cache to provide fast
//					retrieval of code pages.
//
//	========================================================================
#ifndef _LANGTOCPID_H_
#define _LANGTOCPID_H_

#include <ex\gencache.h>
#include <singlton.h>

struct ACCEPTLANGTOCPID_ENTRY { LPCSTR pszLang; UINT cpid; };

//	A static mapping of Accept-Language header values to the
//	corresponding CPIDs. This mapping comes from the DAV
//	implementation doc
//	http://exchange/doc/specs/Platinum/Future%20Protocols/ms-implementation/dav-codepage-support.doc
//
DEC_CONST ACCEPTLANGTOCPID_ENTRY gc_rgAcceptLangToCPIDTable[] =
{
	{"ar",		1256},
	{"ar-sa",	1256},
	{"ar-iq",	1256},
	{"ar-eg",	1256},
	{"ar-ly",	1256},
	{"ar-dz",	1256},
	{"ar-ma",	1256},
	{"ar-tn",	1256},
	{"ar-om",	1256},
	{"ar-ye",	1256},
	{"ar-sy",	1256},
	{"ar-jo",	1256},
	{"ar-lb",	1256},
	{"ar-kw",	1256},
	{"ar-ae",	1256},
	{"ar-bh",	1256},
	{"ar-qa",	1256},
	{"zh",		950},
	{"zh-tw",	950},
	{"zh-cn",	936},
	{"zh-hk",	950},
	{"zh-sg",	936},
	{"ja",		932},
	{"en-us",	1252},
	{"en-gb",	1252},
	{"en-au",	1252},
	{"en-ca",	1252},
	{"en-nz",	1252},
	{"en-ie",	1252},
	{"en-za",	1252},
	{"en-jm",	1252},
	{"en-bz",	1252},
	{"en-tt",	1252},
	{"fr",		1252},
	{"fr-be",	1252},
	{"fr-ca",	1252},
	{"fr-ch",	1252},
	{"fr-lu",	1252},
	{"de",		1252},
	{"de-ch",	1252},
	{"de-at",	1252},
	{"de-lu",	1252},
	{"de-li",	1252},
	{"el",		1253},
	{"he",		1255},
	{"it",		1252},
	{"it-ch",	1252},
	{"lt",		1257},
	{"ko",		949},
	{"es",		1252},
	{"es-mx",	1252},
	{"es-gt",	1252},
	{"es-cr",	1252},
	{"es-pa",	1252},
	{"es-do",	1252},
	{"es-ve",	1252},
	{"es-co",	1252},
	{"es-pe",	1252},
	{"es-ar",	1252},
	{"es-ec",	1252},
	{"es-cl",	1252},
	{"es-uy",	1252},
	{"es-py",	1252},
	{"es-bo",	1252},
	{"es-sv",	1252},
	{"es-hn",	1252},
	{"es-ni",	1252},
	{"es-pr",	1252},
	{"ru",		1251},
	{"th",		874},
	{"tr",		1254},
	{"vi",		1258}
};

//	The size of the table
//
const DWORD gc_cAcceptLangToCPIDTable = CElems(gc_rgAcceptLangToCPIDTable);

//	========================================================================
//
//	Singleton class CLangToCpidCache
//
//	A cache to provide fast retrieval of code pages based on values in the
//	Accept-Language header.
//
//
class CLangToCpidCache : private Singleton<CLangToCpidCache>
{
private:
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CLangToCpidCache>;

	//	The cache mapping accept language strings to code pages.
	//
	CCache<CRCSzi, UINT> m_cacheAcceptLangToCPID;

	//	CONSTRUCTORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CLangToCpidCache() {};

	//	NOT IMPLEMENTED
	//
	CLangToCpidCache (const CLangToCpidCache&);
	CLangToCpidCache& operator= (const CLangToCpidCache&);

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CLangToCpidCache>::DestroyInstance;

	//	Initialization. Wraps CreateInstance().
	//	This function hashes all the supported language strings
	//	to give us quick lookup by language string.
	//
	static BOOL FCreateInstance();

	//	Find the CPID from language string
	//
	static BOOL FFindCpid(IN LPCSTR pszLang, OUT UINT * puiCpid);
};

#endif // _LANGTOCPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\memx.h ===
/*
 *	M E M X . H
 *
 *	Default implementation of DAV allocators.
 *
 *	It is possible that sometime in the future we may decide that different
 *	implementations of DAV may require different allocator implementations,
 *	so each DAV implementation has its own allocator implementation file
 *	(mem.cpp) in its own directory.  However, until we need to differentiate
 *	allocator implementations among DAV implementations (if we ever do),
 *	it is easier to have the common default implementation in one place -- here.
 *
 *	This header defines a full implementation for a fast heap allocator
 *	and implementations for other allocators that can be used for debugging.
 *	This file should be included exactly once by mem.cpp in each DAV implementation.
 *
 *	To use the virtual heap allocator set:
 *
 *	[General]
 *	UseVirtual=1
 *
 *	For purely historical reasons, to use the debug heap set:
 *
 *	[General]
 *	UseExchmem=1
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <singlton.h>
#include <except.h>

//	===================================================================================
//
//	IHeap
//
//	Heap interface base class.
//
class IHeap
{
public:
	//	CREATORS
	//
	virtual ~IHeap() = 0;

	//	ACCESSORS
	//
	virtual LPVOID Alloc( SIZE_T cb ) const = 0;
	virtual LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const = 0;
	virtual VOID Free( LPVOID pv ) const = 0;
};

//	------------------------------------------------------------------------
//
//	IHeap::~IHeap()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IHeap::~IHeap() {}


//	===================================================================================
//
//	CMultiHeap
//
//	Multi-heap implementation (provided by EXCHMEM.DLL).  It is significantly
//	faster than the process heap on multiprocessor machines because it uses
//	multiple internal heaps, lookaside lists and deferred freeing to reduce
//	contention on system heap critical sections.
//
class CMultiHeap :
	public IHeap,
	private Singleton<CMultiHeap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CMultiHeap>;

	typedef HANDLE (WINAPI *HEAPCREATE) (
		ULONG	cHeaps,
		DWORD	dwFlags,
		SIZE_T	dwInitialSize,
		SIZE_T	dwMaxSize );

	typedef BOOL (WINAPI *HEAPDESTROY) ();

	typedef LPVOID (WINAPI *HEAPALLOC) (
		SIZE_T	dwSize );

	typedef LPVOID (WINAPI *HEAPREALLOC) (
		LPVOID	pvOld,
		SIZE_T	dwSize );

	typedef BOOL (WINAPI *HEAPFREE) (
		LPVOID	pvFree );

	//
	//	Allocation functions
	//
	HEAPCREATE	m_HeapCreate;
	HEAPDESTROY	m_HeapDestroy;
	HEAPALLOC	m_HeapAlloc;
	HEAPREALLOC	m_HeapRealloc;
	HEAPFREE	m_HeapFree;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CMultiHeap() :
		m_HeapCreate(NULL),
		m_HeapDestroy(NULL),
		m_HeapAlloc(NULL),
		m_HeapRealloc(NULL),
		m_HeapFree(NULL)
	{
	}

	//	MANIPULATORS
	//
	BOOL FInit();

public:
	//	STATICS
	//
	static CMultiHeap * New();

	//	CREATORS
	//
	~CMultiHeap();

	//	ACCESSORS
	//
	LPVOID Alloc( SIZE_T cb ) const;
	LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const;
	VOID Free( LPVOID pv ) const;
};

CMultiHeap *
CMultiHeap::New()
{
	if ( CreateInstance().FInit() )
		return &Instance();

	DestroyInstance();
	return NULL;
}

BOOL
CMultiHeap::FInit()
{
	//
	//	Load up EXCHMEM.DLL - or whatever
	//
	HINSTANCE hinst = LoadLibraryExW( g_szMemDll, NULL, 0 );

	if ( !hinst )
		return FALSE;

	//
	//	Get the function pointers for the multi-heap implementation
	//
	m_HeapCreate = reinterpret_cast<HEAPCREATE>(
		GetProcAddress( hinst, "ExchMHeapCreate" ));

	m_HeapDestroy = reinterpret_cast<HEAPDESTROY>(
		GetProcAddress( hinst, "ExchMHeapDestroy" ));

	m_HeapAlloc = reinterpret_cast<HEAPALLOC>(
		GetProcAddress( hinst, "ExchMHeapAlloc" ));

	m_HeapRealloc = reinterpret_cast<HEAPREALLOC>(
		GetProcAddress( hinst, "ExchMHeapReAlloc" ));

	m_HeapFree = reinterpret_cast<HEAPFREE>(
		GetProcAddress( hinst, "ExchMHeapFree" ));

	//
	//	Make sure we found all of the entrypoints
	//
	if ( !(m_HeapCreate &&
		   m_HeapDestroy &&
		   m_HeapAlloc &&
		   m_HeapRealloc &&
		   m_HeapFree) )
	{
		return FALSE;
	}

	//
	//	Create the multi-heap.  We don't need the heap HANDLE
	//	that is returned since none of the allocation functions
	//	take it.  We just need to know whether it succeeded.
	//
	return !!m_HeapCreate( 0,	 //	number of heaps -- 0 means use a default
								 //	proportional to the number of CPUs.
						   0,	 //	no flags
						   8192, //	initially 8K (growable)
						   0 );  // size unlimited
}

CMultiHeap::~CMultiHeap()
{
	if ( m_HeapDestroy )
		m_HeapDestroy();
}

LPVOID
CMultiHeap::Alloc( SIZE_T cb ) const
{
	return m_HeapAlloc( cb );
}

LPVOID
CMultiHeap::Realloc( LPVOID lpv, SIZE_T cb ) const
{
	return m_HeapRealloc( lpv, cb );
}

void
CMultiHeap::Free( LPVOID lpv ) const
{
	m_HeapFree( lpv );
}



//
//	Debug-only allocators...
//
#if defined(DBG)

//	===================================================================================
//
//	CVirtualHeap (X86 only)
//
//		Places allocations at the end of virtual memory pages.
//		While being drastically slower than other allocators,
//		this one catches memory overwrites immediately by
//		throwing a memory access violation exception.
//
#if defined(_X86_)

class CVirtualHeap :
	public IHeap,
	private Singleton<CVirtualHeap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CVirtualHeap>;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CVirtualHeap() {}

public:
	//	STATICS
	//
	static CVirtualHeap * New()
	{
		return &CreateInstance();
	}

	//	ACCESSORS
	//
	LPVOID Alloc( SIZE_T cb ) const
	{
		return VMAlloc( cb );
	}

	LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const
	{
		return VMRealloc( lpv, cb );
	}

	VOID Free( LPVOID lpv ) const
	{
		VMFree( lpv );
	}
};

#endif // defined(_X86)


//	===================================================================================
//
//	CDebugHeap
//
//	Debug heap implementation (also provided by EXCHMEM.DLL).  This implementation
//	provides added infrastructure to do more advanced heap analysis at a
//	significant runtime cost.
//
class CDebugHeap :
	public IHeap,
	private Singleton<CDebugHeap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CDebugHeap>;

	typedef HANDLE (WINAPI *HEAPCREATE) (
		DWORD	dwFlags,
		SIZE_T	dwInitialSize,
		SIZE_T	dwMaxSize );

	typedef BOOL (WINAPI *HEAPDESTROY) (
		HANDLE	hHeap );

	typedef LPVOID (WINAPI *HEAPALLOC) (
		HANDLE	hHeap,
		DWORD	dwFlags,
		SIZE_T	dwSize );

	typedef LPVOID (WINAPI *HEAPREALLOC) (
		HANDLE	hHeap,
		DWORD	dwFlags,
		LPVOID	pvOld,
		SIZE_T	dwSize );

	typedef BOOL (WINAPI *HEAPFREE) (
		HANDLE	hHeap,
		DWORD	dwFlags,
		LPVOID	pvFree );

	//
	//	Handle to the heap
	//
	HANDLE			m_hHeap;

	//
	//	Allocation functions
	//
	HEAPCREATE	m_HeapCreate;
	HEAPDESTROY	m_HeapDestroy;
	HEAPALLOC	m_HeapAlloc;
	HEAPREALLOC	m_HeapRealloc;
	HEAPFREE	m_HeapFree;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CDebugHeap() :
		m_hHeap(NULL),
		m_HeapCreate(NULL),
		m_HeapDestroy(NULL),
		m_HeapAlloc(NULL),
		m_HeapRealloc(NULL),
		m_HeapFree(NULL)
	{
	}

	//	MANIPULATORS
	//
	BOOL FInit();

public:
	//	STATICS
	//
	static CDebugHeap * New();

	//	CREATORS
	//
	~CDebugHeap();

	//	ACCESSORS
	//
	LPVOID Alloc( SIZE_T cb ) const;
	LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const;
	VOID Free( LPVOID pv ) const;
};

CDebugHeap *
CDebugHeap::New()
{
	if ( CreateInstance().FInit() )
		return &Instance();

	DestroyInstance();
	return NULL;
}

BOOL
CDebugHeap::FInit()
{
	//
	//	Load up EXCHMEM.DLL
	//
	HINSTANCE hinst = LoadLibraryExW( g_szMemDll, NULL, 0 );

	if ( !hinst )
		return FALSE;

	//
	//	Use the slow EXCHMEM heap.
	//
	//
	m_HeapCreate = reinterpret_cast<HEAPCREATE>(
		GetProcAddress( hinst, "ExchHeapCreate" ));

	m_HeapDestroy = reinterpret_cast<HEAPDESTROY>(
		GetProcAddress( hinst, "ExchHeapDestroy" ));

	m_HeapAlloc = reinterpret_cast<HEAPALLOC>(
		GetProcAddress( hinst, "ExchHeapAlloc" ));

	m_HeapRealloc = reinterpret_cast<HEAPREALLOC>(
		GetProcAddress( hinst, "ExchHeapReAlloc" ));

	m_HeapFree = reinterpret_cast<HEAPFREE>(
		GetProcAddress( hinst, "ExchHeapFree" ));

	//
	//	Make sure we found all of the entrypoints
	//
	if ( !(m_HeapCreate &&
		   m_HeapDestroy &&
		   m_HeapAlloc &&
		   m_HeapRealloc &&
		   m_HeapFree) )
	{
		return FALSE;
	}

	//
	//	Create our heap
	//
	m_hHeap = m_HeapCreate( 0,		//	no flags
							8192,	//	initially 8K (growable)
							0 );	//	unlimited max size

	return !!m_hHeap;
}

CDebugHeap::~CDebugHeap()
{
	if ( m_hHeap && m_HeapDestroy )
		m_HeapDestroy( m_hHeap );
}

LPVOID
CDebugHeap::Alloc( SIZE_T cb ) const
{
	Assert( m_hHeap != NULL );

	return m_HeapAlloc( m_hHeap, 0, cb );
}

LPVOID
CDebugHeap::Realloc( LPVOID lpv, SIZE_T cb ) const
{
	Assert( m_hHeap != NULL );

	return m_HeapRealloc( m_hHeap, 0, lpv, cb );
}

void
CDebugHeap::Free( LPVOID lpv ) const
{
	Assert( m_hHeap != NULL );

	m_HeapFree( m_hHeap, 0, lpv );
}

#endif // DBG



//	===================================================================================
//
//	CHeapImpl
//
//	Top-level heap implementation
//
class CHeapImpl : private RefCountedGlobal<CHeapImpl>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CHeapImpl>;
	friend class RefCountedGlobal<CHeapImpl>;

	//
	//	Pointer to the object that provides our heap implementation
	//
	auto_ptr<IHeap> m_pHeapImpl;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CHeapImpl() {}

	//	NOT IMPLEMENTED
	//
	CHeapImpl( const CHeapImpl& );
	CHeapImpl& operator=( const CHeapImpl& );

	//
	//	Initialization routine called
	//	by the RefCountedGlobal template
	//
	BOOL FInit()
	{
		//
		//	And bind to a particular heap implementation
		//
		//	In DBG builds only, check whether we are being told
		//	to use the virtual allocator heap implementation
		//
#if defined(DBG)
#if defined(_X86_)
		if ( GetPrivateProfileIntA( gc_szDbgGeneral,
									gc_szDbgUseVirtual,
									FALSE,
									gc_szDbgIni ) )
		{
			m_pHeapImpl = CVirtualHeap::New();
		}
		else
#endif // defined(_X86_)
		if ( GetPrivateProfileIntA( gc_szDbgGeneral,
									gc_szDbgUseExchmem,
									FALSE,
									gc_szDbgIni ) )
		{
			m_pHeapImpl = CDebugHeap::New();
		}
		else
#endif // DBG
		m_pHeapImpl = CMultiHeap::New();

		return !!m_pHeapImpl;
	}

public:
	using RefCountedGlobal<CHeapImpl>::DwInitRef;
	using RefCountedGlobal<CHeapImpl>::DeinitRef;

	static IHeap& Heap()
	{
		Assert( Instance().m_pHeapImpl.get() != NULL );

		return *Instance().m_pHeapImpl;
	}
};


//	===================================================================================
//
//	CHeap
//
//	Top-level heap.
//
//	This "class" (it's actually a struct) really only acts as a namespace.
//	I.e. its only members are static functions.  It remains a class for
//	historical reasons (mainly to avoid changing a LOT of code from calling
//	"g_heap.Fn()" to simply calling "Fn()").
//

BOOL
CHeap::FInit()
{
	return !!CHeapImpl::DwInitRef();
}

void
CHeap::Deinit()
{
	CHeapImpl::DeinitRef();
}

LPVOID
CHeap::Alloc( SIZE_T cb )
{
	LPVOID	lpv;

	Assert( cb > 0 );

	lpv = CHeapImpl::Heap().Alloc(cb);

#ifndef	_NOTHROW_
	if ( !lpv )
	{
		DebugTrace ("CHeap::Alloc() - Error allocating (%d)\n", GetLastError());
		throw CLastErrorException();
	}
#endif	// _NOTHROW_

	return lpv;
}

LPVOID
CHeap::Realloc( LPVOID lpv, SIZE_T cb )
{
	LPVOID	lpvNew;

	Assert( cb > 0 );

	//	Just in case some heap implementation doesn't handle
	//	realloc with NULL lpv, map that case to Alloc here.
	//
	if (!lpv)
		lpvNew = CHeapImpl::Heap().Alloc(cb);
	else
		lpvNew = CHeapImpl::Heap().Realloc(lpv, cb);

#ifndef	_NOTHROW_
	if ( !lpvNew )
	{
		DebugTrace ("CHeap::Alloc() - Error reallocating (%d)\n", GetLastError());
		throw CLastErrorException();
	}
#endif	// _NOTHROW_

	return lpvNew;
}

VOID
CHeap::Free( LPVOID lpv )
{
	if ( lpv )
	{
		CHeapImpl::Heap().Free( lpv );
	}
}

//
//	The one global heap "object".  CHeap is really just a struct
//	containing only static member functions, so there should be
//	no space required for this declaration.  The actual heap
//	implementation (CHeapImpl) provides everything.  CHeap is
//	now just an interface.
//
CHeap g_heap;



//	------------------------------------------------------------------------
//
//	Global new operator
//	Global delete operator
//
//		Remap all calls to new to use our memory manager.
//		(Don't forget to throw explicitly on error!)
//
void * __cdecl operator new(size_t cb)
{
#ifdef	DBG
	AssertSz(cb, "Zero-size allocation detecetd!");
	//	Force small allocations up to min size of four
	//	so that I can reliably do the "vtable-nulling trick" in delete!
	//
	if (cb < 4) cb = 4;
#endif	// DBG

	PVOID pv = g_heap.Alloc(cb);

#ifndef	_NOTHROW_
	if (!pv)
		throw CDAVException();
#endif	// _NOTHROW_

	return pv;
}

void __cdecl operator delete(void * pv)
{
#ifdef	DBG
	//	Zero-out the first four bytes of this allocation.
	//	(If there was a vtable there previously, we'll now trap
	//	if we try to use it!)
	//
	if (pv)
		*((DWORD *)pv) = 0;
#endif	// DBG

	g_heap.Free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\pclib.h ===
#ifndef _PCLIB_H_
#define _PCLIB_H_

#include <winperf.h>

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PCLIB.H
//
//		Public interface to PCLIB to be used by perf counter data
//		generating and monitoring components.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

//
//	A signature that uniquely identifies the component whose perf counters are
//	being implemented.  This must be identical to the value of the drivername
//	key in the [info] section of the perf counter INI file.  It is used to
//	locate the counters' "first counter" information in the registry.
//	
EXTERN_C const WCHAR gc_wszPerfdataSource[];

//	The signature of the perf counter dll.
//	NOTE: This is usually NOT the same as the monitor component signature above!
//	This variable is defined to MATCH the definition in \cal\src\inc\eventlog.h.
//
EXTERN_C const WCHAR gc_wszSignature[]; 


//	************************************************************************
//
//	INTERFACE for counter data generating processes
//

//	========================================================================
//
//	CLASS IPerfCounterBlock
//
//	Created by IPerfObject::NewInstance().  A perf counter block
//	encapsulates the set of counters for a given instance.  The
//	methods of this interface define the mechanism for changing
//	the values of the counters in the counter block.
//
class IPerfCounterBlock
{
public:
	//	CREATORS
	//
	virtual ~IPerfCounterBlock() = 0;

	//	MANIPULATORS
	//
	virtual VOID IncrementCounter( UINT iCounter ) = 0;
	virtual VOID DecrementCounter( UINT iCounter ) = 0;
	virtual VOID SetCounter( UINT iCounter, LONG lValue ) = 0;
};

//	========================================================================
//
//	CLASS IPerfObject
//
//	Created by PCLIB::NewPerfObject().  A perf object defines a set of
//	counters.  In terms of the NT perf counter structures, a perf object
//	encapsulates a PERF_OBJECT_TYPE and its PERF_COUNTER_DEFINITIONs.
//
//	IPerfObject::NewInstance() creates a new instance of this perf object
//	from a PERF_INSTANCE_DEFINITION and a PERF_COUNTER_BLOCK.  All values
//	of both structures must be properly initialized prior to calling
//	IPerfObject::NewInstance() following standard conventions for these
//	structures.  I.e. the instance name must immediately follow the
//	PERF_INSTANCE_DEFINITION structure, and the PERF_COUNTER_BLOCK must
//	be DWORD-aligned following the name.  The PERF_COUNTER_BLOCK should
//	be followed by the counters themselves.  Read the documentation for
//	these structures if you're confused.
//
class IPerfObject
{
public:
	//	CREATORS
	//
	virtual ~IPerfObject() = 0;

	//	MANIPULATORS
	//
	virtual IPerfCounterBlock *
	NewInstance( const PERF_INSTANCE_DEFINITION& pid,
				 const PERF_COUNTER_BLOCK& pcb ) = 0;
};

//	========================================================================
//
//	NAMESPACE PCLIB
//
//	The top level of the PCLIB interface.  PCLIB::FInitialize() should be
//	called once per process to initialize the library.  Similarly,
//	PCLIB::Deinitialize() should be called once per process to deinitialize
//	it.  NOTE: To simplify your error code cleanup, it is safe to call
//	PCLIB::Deinitialize() even if you did not call PCLIB::FInitialize().
//
//	PCLIB::NewPerfObject() creates a new perf object from a
//	PERF_OBJECT_TYPE and subsequent PERF_COUNTER_DEFINITIONs.  All values
//	of both structures must be properly initialized prior to calling
//	PCLIB::NewPerfObject() following standard conventions for these
//	structures, with one exception: PERF_OBJECT_TYPE::NumInstances and
//	PERF_OBJECT_TYPE::TotalByteLength should both be initialized to 0.
//	These values are computed in the monitor process because the number
//	of instances is not generally fixed at the time the object is created.
//
namespace PCLIB
{
	//
	//	Initialization/Deinitialization
	//
	BOOL __fastcall FInitialize( LPCWSTR lpwszSignature );
	VOID __fastcall Deinitialize();

	//
	//	Instance registration
	//
	IPerfObject * __fastcall NewPerfObject( const PERF_OBJECT_TYPE& pot );
};

//	========================================================================
//
//	CLASS CPclibInit
//
//	PCLIB initializer class.  Simplifies PCLIB initialization and
//	deinitialization.
//
class CPclibInit
{
	//	NOT IMPLEMENTED
	//
	CPclibInit& operator=( const CPclibInit& );
	CPclibInit( const CPclibInit& );

public:
	CPclibInit()
	{
	}

	BOOL FInitialize( LPCWSTR lpwszSignature )
	{
		return PCLIB::FInitialize( lpwszSignature );
	}

	~CPclibInit()
	{
		PCLIB::Deinitialize();
	}
};


//	************************************************************************
//
//	INTERFACE for counter monitors
//

//	------------------------------------------------------------------------
//
//	The interface for monitors *IS* the perfmon interface!
//	Just define these as EXPORTS for your monitor DLL and you're done.
//
EXTERN_C DWORD APIENTRY
PclibOpenPerformanceData( LPCWSTR );

EXTERN_C DWORD APIENTRY
PclibCollectPerformanceData( LPCWSTR lpwszCounterIndices,
							 LPVOID * plpvPerfData,
							 LPDWORD lpdwcbPerfData,
							 LPDWORD lpcObjectTypes );

EXTERN_C DWORD APIENTRY
PclibClosePerformanceData();

EXTERN_C STDAPI
PclibDllRegisterServer(VOID);

EXTERN_C STDAPI
PclibDllUnregisterServer(VOID);

//	------------------------------------------------------------------------
//
//	Or, for the do-it-yourself'er....
//
//	Step 1) Initialize shared memory (see inc\smh.h)
//	Step 2) Call NewCounterPublisher() or NewCounterMonitor() (depending
//			on which you are!) passing in the string you used in Step 1.
//
class ICounterData
{
protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	ICounterData() {};

public:
	//	CREATORS
	//
	virtual ~ICounterData() = 0;

	//	MANIPULATORS
	//
	virtual IPerfObject *
		CreatePerfObject( const PERF_OBJECT_TYPE& pot ) = 0;

	virtual DWORD
		DwCollectData( LPCWSTR lpwszCounterIndices,
					   DWORD   dwFirstCounter,
					   LPVOID * plpvPerfData,
					   LPDWORD lpdwcbPerfData,
					   LPDWORD lpcObjectTypes ) = 0;
};

ICounterData * __fastcall
NewCounterPublisher( LPCWSTR lpwszSignature );

ICounterData * __fastcall
NewCounterMonitor( LPCWSTR lpwszSignature );

#endif // !defined(_PCLIB_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\nonimpl.h ===
/*
 *	N O N I M P L . H
 *
 *	Base classes for COM interfaces with no functionality except IUnknown.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_NONIMPL_H_
#define _NONIMPL_H_

#include <exo.h>
#include <ocidl.h>		//	For IPersistStreamInit
#include <caldbg.h>

//	Non-Implemented IStream ---------------------------------------------------
//
class CStreamNonImpl : public EXO, public IStream
{
public:

	EXO_INCLASS_DECL(CStreamNonImpl);

	CStreamNonImpl() {}
	~CStreamNonImpl() {}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Read() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
		/* [size_is][in] */ const void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Write() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek(
		/* [in] */ LARGE_INTEGER,
		/* [in] */ DWORD,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Seek() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE SetSize(
		/* [in] */ ULARGE_INTEGER)
	{
		TrapSz ("CStreanNonImpl::SetSize() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo(
		/* [unique][in] */ IStream __RPC_FAR *,
		/* [in] */ ULARGE_INTEGER,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::CopyTo() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Commit(
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImbdpl::Commit() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Revert( void)
	{
		TrapSz ("CStreanNonImpl::Revert() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE LockRegion(
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::LockRegion() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::UnlockRegion() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Stat(
		/* [out] */ STATSTG __RPC_FAR *,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::Stat() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Clone(
		/* [out] */ IStream __RPC_FAR *__RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Clone() called");
		return E_NOTIMPL;
	}
};

//	Non-Implemented IPersistStreamInit ----------------------------------------
//
class CPersistStreamInitNonImpl: public EXO, public IPersistStreamInit
{
public:
	EXO_INCLASS_DECL(CPersistStreamInitNonImpl);

	virtual HRESULT STDMETHODCALLTYPE GetClassID(
		/* [out] */ CLSID __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::GetClassID() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE IsDirty( void)
	{
		TrapSz ("CPersistStreamInitNonImpl::IsDirty() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Load(
		/* [unique][in] */ IStream __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::Load() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Save(
		/* [unique][in] */ IStream __RPC_FAR *,
		/* [in] */ BOOL )
	{
		TrapSz ("CPersistStreamInitNonImpl::Save() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE GetSizeMax(
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::GetSizeMax() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE InitNew()
	{
		TrapSz ("CPersistStreamInitNonImpl::InitNew() called");
		return E_NOTIMPL;
	}
};

#endif // _NONIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\msidxs.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Provider for Index Server
// (C) Copyright 1996 - 1997 By Microsoft Corporation.
//
// @doc
//
// @module MSIDXS.H | Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSIDXS_H_
#define  _MSIDXS_H_

// Provider Class Id
#ifdef DBINITCONSTANTS
extern const GUID CLSID_MSIDXS			= {0xF9AE8980, 0x7E52, 0x11d0, {0x89,0x64,0x00,0xC0,0x4F,0xD6,0x11,0xD7}};
extern const GUID CLSID_MSSEARCHSQL		= {0x0B63E349, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
// Site Server
extern const GUID DBPROPSET_NLCOMMAND	= {0x0B63E344, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
extern const GUID DBPROPSET_NLROWSET	= {0x0B63E36E, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
#else // !DBINITCONSTANTS
extern const GUID CLSID_MSIDXS;
extern const GUID CLSID_MSSEARCHSQL;
// Site Server
extern const GUID DBPROPSET_NLCOMMAND;
extern const GUID DBPROPSET_NLROWSET;
#endif // DBINITCONSTANTS


//----------------------------------------------------------------------------
// MSIDXS and MSIDNL specific properties
#ifdef DBINITCONSTANTS
extern const GUID DBPROPSET_MSIDXS_ROWSET_EXT	= {0xAA6EE6B0, 0xE828, 0x11D0, {0xB2,0x3E,0x00,0xAA,0x00,0x47,0xFC,0x01} };
extern const GUID DBPROPSET_QUERY_EXT			= {0xA7AC77ED, 0xF8D7, 0x11CE, {0xA7,0x98,0x00,0x20,0xF8,0x00,0x80,0x25} };
#else // !DBINITCONSTANTS
extern const GUID DBPROPSET_MSIDXS_ROWSET_EXT;
extern const GUID DBPROPSET_QUERY_EXT;
#endif // DBINITCONSTANTS


// PropIds under DBPROPSET_MSIDX_ROWSET_EXT
#define MSIDXSPROP_ROWSETQUERYSTATUS			2
#define MSIDXSPROP_COMMAND_LOCALE_STRING		3
#define MSIDXSPROP_QUERY_RESTRICTION			4

// Prop IDs for DBPROPET_NLCOMMAND 
#define DBPROP_NLCOMMAND_STARTROW				3
#define DBPROP_NLCOMMAND_GETROWCOUNT			4

// Prop IDs for DBPROPSET_NLROWSET
#define DBPROP_NLROWSET_ROWCOUNT				1000
#define DBPROP_NLROWSET_NEXTSTARTROW			1001
#define DBPROP_NLROWSET_MOREROWS				1002
#define DBPROP_NLROWSET_CATSEQNUMS				1003

#endif
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\profile.h ===
#ifndef _PROFILE_H_
#define _PROFILE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PROFILE.H
//
//		Profiling classes for use with IceCAP profiling
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CProfiledBlock
//
//	Profiles any block of code in which an instance of this class exists.
//
//	To use, just declare one of these in the block you want profiled:
//
//		...
//		{
//			CProfiledBlock	profiledBlock;
//
//			//
//			//	Do stuff to be profiled
//			//
//			...
//
//			//
//			//	Do more stuff to be profiled
//			//
//			...
//		}
//
//		//
//		//	Do stuff that isn't to be profiled
//		//
//		...
//
//	and the block is automatically profiled.  Why bother?  Because
//	you don't need to have any cleanup code; profiling is automatically
//	turned off when execution leaves the block, even if via
//	an exception thrown from any of the synchronized stuff.  Also,
//	profiling information for initialization of local objects
//	is automatically gathered as long as the profiled block is
//	the first thing declared.
//
class CProfiledBlock
{
public:
#ifdef PROFILING
	//	CREATORS
	//
	CProfiledBlock() { StartCAP(); }
	~CProfiledBlock() { StopCAP(); }

	//	MANIPULATORS
	//
	void Suspend() { SuspendCAP(); }
	void Resume() { ResumeCAP(); }

#else // !defined(PROFILING)
	//	CREATORS
	//
	CProfiledBlock() {}
	~CProfiledBlock() {}

	//	MANIPULATORS
	//
	void Suspend() {}
	void Resume() {}

#endif // PROFILING
};

#endif // !defined(_PROFILE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\perfctrs.h ===
#ifndef _PERFCTRS_H_
#define _PERFCTRS_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PERFCTRS.H
//
//		Interface to DAV performance counters for use by impls.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

//	--- !!! INSTRUCTIONS !!! ---
//
//		If you want to add, remove or change any perf counters,
//		you must do the following things:
//
//		1) Update the CTI #defines (See below).
//
//		2) Update the IPC enum (See below).
//
//		2) Go into _davprs\perfctrs.cpp and update the structures there.
//
//		3) VERY IMPORTANT -- Make sure you update the <xxx>ctr.h and
//		   <xxx>ctr.INI files in each impl's perf counter subdirectory
//		   to reflect your changes.  These files are the ones used by
//		   lodctr to add counters to the title database.  If you fail
//		   to update them, perfmon will not show your new counters.
//
//		4) VERY VERY IMPORTANT -- Consider carefully whether your changes
//		   will impact perf counters for HTTPEXT.  The best way to be
//		   sure they don't is to never change any existing CTI values --
//		   always add new CTI values to the END of the list.  If you do
//		   change any CTI values that correspond to values in
//		   \cal\src\httpxpc\httpxctr.h, in addition to updating the values
//		   there (see item 3), you will also need to redrop httpxctr.h
//		   to the IIS project (\nt\private\iis\svcs\w3\server\httpxctr.h)
//		   and rebuild W3SVC.DLL.
//
//		5) Finally, if you add counters that you want to expose under
//		   IIS' Web Service object and via SNMP, in addition to doing item 4,
//		   you will also need to modify a number of files in the IIS project.
//		   If that is your situation, your best bet is to find someone
//		   in IIS who can make those changes for you.
//
//		Except for items 4 and 5 above, you generally do not need to
//		recompile perf counter DLLs when making any changes to perf counters.
//
//	--- !!! INSTRUCTIONS !!! ---

#include <pclib.h>

//	------------------------------------------------------------------------
//
//	Counter Title Indices (CTI)
//
//	The following values define counter name/help title indices for
//	inclusion in each impl's public perf counter .H file (the one that
//	goes with the .INI file).  If you make any changes here, you must
//	also update the <xxx>ctr.H and <xxx>ctr.INI files in each impl's
//	perf counter subdirectory to reflect those changes.
//
//	These values are provided as #defines (rather than as an enum)
//	to make it easier to propagate changes here to impls' .H and .INI files.
//
//	Note that these values must always be even.
//
//	Note also that there is not necessarily a one-to-one correspondence
//	between CTIs and IPCs.  For example, a single IPC can be used to
//	generate both total and per-second counters.
//
#define CTI_OBJECT												0
#define CTI_COUNTER_SERVER_ID                                   2
#define CTI_COUNTER_REQUESTS_PER_SECOND							4
#define CTI_COUNTER_OPTIONS_REQUESTS_PER_SECOND					6
#define CTI_COUNTER_GET_REQUESTS_PER_SECOND						8
#define CTI_COUNTER_HEAD_REQUESTS_PER_SECOND					10
#define CTI_COUNTER_PUT_REQUESTS_PER_SECOND						12
#define CTI_COUNTER_POST_REQUESTS_PER_SECOND					14
#define CTI_COUNTER_DELETE_REQUESTS_PER_SECOND					16
#define CTI_COUNTER_COPY_REQUESTS_PER_SECOND					18
#define CTI_COUNTER_MOVE_REQUESTS_PER_SECOND					20
#define CTI_COUNTER_MKCOL_REQUESTS_PER_SECOND					22
#define CTI_COUNTER_PROPFIND_REQUESTS_PER_SECOND				24
#define CTI_COUNTER_PROPPATCH_REQUESTS_PER_SECOND				26
#define CTI_COUNTER_LOCK_REQUESTS_PER_SECOND					28
#define CTI_COUNTER_UNLOCK_REQUESTS_PER_SECOND					30
#define CTI_COUNTER_SEARCH_REQUESTS_PER_SECOND					32
#define CTI_COUNTER_OTHER_REQUESTS_PER_SECOND					34
#define CTI_COUNTER_200_RESPONSES_PER_SECOND					36
#define CTI_COUNTER_201_RESPONSES_PER_SECOND					38
#define CTI_COUNTER_400_RESPONSES_PER_SECOND					40
#define CTI_COUNTER_401_RESPONSES_PER_SECOND					42
#define CTI_COUNTER_404_RESPONSES_PER_SECOND					44
#define CTI_COUNTER_423_RESPONSES_PER_SECOND					46
#define CTI_COUNTER_500_RESPONSES_PER_SECOND					48
#define CTI_COUNTER_REDIRECT_RESPONSES_PER_SECOND				50
#define CTI_COUNTER_TOTAL_REQUESTS								52
#define CTI_COUNTER_TOTAL_OPTIONS_REQUESTS						54
#define CTI_COUNTER_TOTAL_GET_REQUESTS							56
#define CTI_COUNTER_TOTAL_HEAD_REQUESTS							58
#define CTI_COUNTER_TOTAL_PUT_REQUESTS							60
#define CTI_COUNTER_TOTAL_POST_REQUESTS							62
#define CTI_COUNTER_TOTAL_DELETE_REQUESTS						64
#define CTI_COUNTER_TOTAL_COPY_REQUESTS							66
#define CTI_COUNTER_TOTAL_MOVE_REQUESTS							68
#define CTI_COUNTER_TOTAL_MKCOL_REQUESTS						70
#define CTI_COUNTER_TOTAL_PROPFIND_REQUESTS						72
#define CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS					74
#define CTI_COUNTER_TOTAL_LOCK_REQUESTS							76
#define CTI_COUNTER_TOTAL_UNLOCK_REQUESTS						78
#define CTI_COUNTER_TOTAL_SEARCH_REQUESTS						80
#define CTI_COUNTER_TOTAL_OTHER_REQUESTS						82
#define CTI_COUNTER_TOTAL_200_RESPONSES							84
#define CTI_COUNTER_TOTAL_201_RESPONSES							86
#define CTI_COUNTER_TOTAL_400_RESPONSES							88
#define CTI_COUNTER_TOTAL_401_RESPONSES							90
#define CTI_COUNTER_TOTAL_404_RESPONSES							92
#define CTI_COUNTER_TOTAL_423_RESPONSES							94
#define CTI_COUNTER_TOTAL_500_RESPONSES							96
#define CTI_COUNTER_TOTAL_REDIRECT_RESPONSES					98
#define CTI_COUNTER_CURRENT_REQUESTS_EXECUTING					100
#define CTI_COUNTER_TOTAL_REQUESTS_FORWARDED					102
#define CTI_COUNTER_TOTAL_EXCEPTIONS							104

#define CTI_COUNTER_POLL_REQUESTS_PER_SECOND					106
#define CTI_COUNTER_SUBSCRIBE_REQUESTS_PER_SECOND				108
#define CTI_COUNTER_UNSUBSCRIBE_REQUESTS_PER_SECOND				110
#define CTI_COUNTER_BATCHDELETE_REQUESTS_PER_SECOND				112
#define CTI_COUNTER_BATCHCOPY_REQUESTS_PER_SECOND				114
#define CTI_COUNTER_BATCHMOVE_REQUESTS_PER_SECOND				116
#define CTI_COUNTER_BATCHPROPPATCH_REQUESTS_PER_SECOND			118
#define CTI_COUNTER_BATCHPROPFIND_REQUESTS_PER_SECOND			120
#define CTI_COUNTER_204_RESPONSES_PER_SECOND					122
#define CTI_COUNTER_207_RESPONSES_PER_SECOND					124
#define CTI_COUNTER_302_RESPONSES_PER_SECOND					126
#define CTI_COUNTER_403_RESPONSES_PER_SECOND					128
#define CTI_COUNTER_405_RESPONSES_PER_SECOND					130
#define CTI_COUNTER_406_RESPONSES_PER_SECOND					132
#define CTI_COUNTER_409_RESPONSES_PER_SECOND					134
#define CTI_COUNTER_412_RESPONSES_PER_SECOND					136
#define CTI_COUNTER_415_RESPONSES_PER_SECOND					138
#define CTI_COUNTER_422_RESPONSES_PER_SECOND					140
#define CTI_COUNTER_424_RESPONSES_PER_SECOND					142
#define CTI_COUNTER_501_RESPONSES_PER_SECOND					144
#define CTI_COUNTER_503_RESPONSES_PER_SECOND					146
#define CTI_COUNTER_TOTAL_POLL_REQUESTS							148
#define CTI_COUNTER_TOTAL_SUBSCRIBE_REQUESTS					150
#define CTI_COUNTER_TOTAL_UNSUBSCRIBE_REQUESTS					152
#define CTI_COUNTER_TOTAL_BATCHDELETE_REQUESTS					154
#define CTI_COUNTER_TOTAL_BATCHCOPY_REQUESTS					156
#define CTI_COUNTER_TOTAL_BATCHMOVE_REQUESTS					158
#define CTI_COUNTER_TOTAL_BATCHPROPPATCH_REQUESTS				160
#define CTI_COUNTER_TOTAL_BATCHPROPFIND_REQUESTS				162
#define CTI_COUNTER_TOTAL_204_RESPONSES							164
#define CTI_COUNTER_TOTAL_207_RESPONSES							166
#define CTI_COUNTER_TOTAL_302_RESPONSES							168
#define CTI_COUNTER_TOTAL_403_RESPONSES							170
#define CTI_COUNTER_TOTAL_405_RESPONSES							172
#define CTI_COUNTER_TOTAL_406_RESPONSES							174
#define CTI_COUNTER_TOTAL_409_RESPONSES							176
#define CTI_COUNTER_TOTAL_412_RESPONSES							178
#define CTI_COUNTER_TOTAL_415_RESPONSES							180
#define CTI_COUNTER_TOTAL_422_RESPONSES							182
#define CTI_COUNTER_TOTAL_424_RESPONSES							184
#define CTI_COUNTER_TOTAL_501_RESPONSES							186
#define CTI_COUNTER_TOTAL_503_RESPONSES							188

#define CTI_COUNTER_REDIRECTS_FROM_BACKEND_PER_SECOND			190
#define CTI_COUNTER_TOTAL_REDIRECTS_FROM_BACKEND				192
#define CTI_COUNTER_IFS_CACHE_HITS_PER_SECOND					194
#define CTI_COUNTER_TOTAL_IFS_CACHE_HITS						196
#define CTI_COUNTER_IFS_CACHE_MISSES_PER_SECOND					198
#define CTI_COUNTER_TOTAL_IFS_CACHE_MISSES						200
#define CTI_COUNTER_CURRENT_ITEM_COUNT_IN_IFS_CACHE				202

//	------------------------------------------------------------------------
//
//	Perf Counter Indices (IPC)
//
//	Impl-defined counters (if any) should start at IPC_IMPL_BASE.
//
//	These values are indices into the perf data structures in perfdata.cpp.
//	Use these values, not the CTI values above, in calls to the perf
//	counter functions.
//
//	When adding counters here, you almost certainly want to update the
//	counter title indices as well.  The exception to this rule is for
//	internal (non-reported) counters with PERF_DISPLAY_NOSHOW
//	counter types (see winperf.h).
//
enum
{
	//
	//	Per-vroot (per-instance) counters
	//	------------------------------------------------------
	//

	//
	//	Web Server ID.  Used in merging counter data with
	//	W3SVC counters (see \nt\private\iis\svcs\w3\server\httpxpc.cxx
	//	in the IIS project for its use).
	//
	IPC_SERVER_ID = 0,

	//
	//		Per second verb counters
	//
	//		"What is the current distribution of requests?"
	//
	IPC_REQUESTS_PER_SECOND,
	IPC_OPTIONS_REQUESTS_PER_SECOND,
	IPC_GET_REQUESTS_PER_SECOND,
	IPC_HEAD_REQUESTS_PER_SECOND,
	IPC_PUT_REQUESTS_PER_SECOND,
	IPC_POST_REQUESTS_PER_SECOND,
	IPC_DELETE_REQUESTS_PER_SECOND,
	IPC_COPY_REQUESTS_PER_SECOND,
	IPC_MOVE_REQUESTS_PER_SECOND,
	IPC_MKCOL_REQUESTS_PER_SECOND,
	IPC_PROPFIND_REQUESTS_PER_SECOND,
	IPC_PROPPATCH_REQUESTS_PER_SECOND,
	IPC_LOCK_REQUESTS_PER_SECOND,
	IPC_UNLOCK_REQUESTS_PER_SECOND,
	IPC_SEARCH_REQUESTS_PER_SECOND,
	IPC_OTHER_REQUESTS_PER_SECOND,

	//
	//		Per second error counters
	//
	IPC_200_RESPONSES_PER_SECOND,
	IPC_201_RESPONSES_PER_SECOND,
	IPC_400_RESPONSES_PER_SECOND,
	IPC_401_RESPONSES_PER_SECOND,
	IPC_404_RESPONSES_PER_SECOND,
	IPC_423_RESPONSES_PER_SECOND,
	IPC_500_RESPONSES_PER_SECOND,
	IPC_REDIRECT_RESPONSES_PER_SECOND,

	//
	//		Total verb counters
	//
	//		"What is the historical (cumulative) distribution of requests?"
	//
	IPC_TOTAL_REQUESTS,
	IPC_TOTAL_OPTIONS_REQUESTS,
	IPC_TOTAL_GET_REQUESTS,
	IPC_TOTAL_HEAD_REQUESTS,
	IPC_TOTAL_PUT_REQUESTS,
	IPC_TOTAL_POST_REQUESTS,
	IPC_TOTAL_DELETE_REQUESTS,
	IPC_TOTAL_COPY_REQUESTS,
	IPC_TOTAL_MOVE_REQUESTS,
	IPC_TOTAL_MKCOL_REQUESTS,
	IPC_TOTAL_PROPFIND_REQUESTS,
	IPC_TOTAL_PROPPATCH_REQUESTS,
	IPC_TOTAL_LOCK_REQUESTS,
	IPC_TOTAL_UNLOCK_REQUESTS,
	IPC_TOTAL_SEARCH_REQUESTS,
	IPC_TOTAL_OTHER_REQUESTS,

#ifdef TRANSACTION_SIZE_COUNTERS
	//
	//		Historical (cumulative) requests/responses percentages
	//		by body size/content.
	//
	//		Useful in analyzing usage characteristics for methods
	//		whose performance can vary widely depending on certain
	//		per-request factors.
	//
	IPC_TOTAL_GET_RESPONSES_0_5K_BYTES,
	IPC_TOTAL_GET_RESPONSES_5_15K_BYTES,
	IPC_TOTAL_GET_RESPONSES_GT_15K_BYTES,

	IPC_TOTAL_PUT_REQUESTS_0_5K_BYTES,
	IPC_TOTAL_PUT_REQUESTS_5_15K_BYTES,
	IPC_TOTAL_PUT_REQUESTS_GT_15K_BYTES,

	IPC_TOTAL_COPY_REQUESTS_DEPTH_0,
	IPC_TOTAL_COPY_REQUESTS_DEPTH_INFINITY,

	IPC_TOTAL_MKCOL_REQUESTS_0_10_ITEMS,
	IPC_TOTAL_MKCOL_REQUESTS_10_100_ITEMS,
	IPC_TOTAL_MKCOL_REQUESTS_100_1K_ITEMS,
	IPC_TOTAL_MKCOL_REQUESTS_GT_1K_ITEMS,

	IPC_TOTAL_PROPFIND_RESPONSES_0_10_PROPERTIES,
	IPC_TOTAL_PROPFIND_RESPONSES_10_100_PROPERTIES,
	IPC_TOTAL_PROPFIND_RESPONSES_100_1K_PROPERTIES,
	IPC_TOTAL_PROPFIND_RESPONSES_GT_1K_PROPERTIES,

	IPC_TOTAL_PROPPATCH_REQUESTS_0_10_PROPERTIES,
	IPC_TOTAL_PROPPATCH_REQUESTS_10_100_PROPERTIES,
	IPC_TOTAL_PROPPATCH_REQUESTS_100_1K_PROPERTIES,
	IPC_TOTAL_PROPPATCH_REQUESTS_GT_1K_PROPERTIES,

	IPC_TOTAL_SEARCH_RESPONSES_0_10_ROWS,
	IPC_TOTAL_SEARCH_RESPONSES_10_100_ROWS,
	IPC_TOTAL_SEARCH_RESPONSES_100_1K_ROWS,
	IPC_TOTAL_SEARCH_RESPONSES_GT_1K_ROWS,

#endif // TRANSACTION_SIZE_COUNTERS

	//
	//		Historical (cumulative) response percentages by status code
	//
	IPC_TOTAL_200_RESPONSES,
	IPC_TOTAL_201_RESPONSES,
	IPC_TOTAL_400_RESPONSES,
	IPC_TOTAL_401_RESPONSES,
	IPC_TOTAL_404_RESPONSES,
	IPC_TOTAL_423_RESPONSES,
	IPC_TOTAL_500_RESPONSES,
	IPC_TOTAL_REDIRECT_RESPONSES,

	//
	//		Concurrent data flow counters
	//
	//		"Where is the data flow path spending most of its time?"
	//
	IPC_CURRENT_REQUESTS_EXECUTING,

	//
	//		Historical data flow counters for presumably uncommon
	//		(and possibly expensive) code paths.
	//
	IPC_TOTAL_REQUESTS_FORWARDED,
	IPC_TOTAL_EXCEPTIONS,

	//		Davex specific counters
	//
	IPC_POLL_REQUESTS_PER_SECOND,
	IPC_SUBSCRIBE_REQUESTS_PER_SECOND,
	IPC_UNSUBSCRIBE_REQUESTS_PER_SECOND,
	IPC_BATCHDELETE_REQUESTS_PER_SECOND,
	IPC_BATCHCOPY_REQUESTS_PER_SECOND,
	IPC_BATCHMOVE_REQUESTS_PER_SECOND,
	IPC_BATCHPROPPATCH_REQUESTS_PER_SECOND,
	IPC_BATCHPROPFIND_REQUESTS_PER_SECOND,
	IPC_204_RESPONSES_PER_SECOND,
	IPC_207_RESPONSES_PER_SECOND,
	IPC_302_RESPONSES_PER_SECOND,
	IPC_403_RESPONSES_PER_SECOND,
	IPC_405_RESPONSES_PER_SECOND,
	IPC_406_RESPONSES_PER_SECOND,
	IPC_409_RESPONSES_PER_SECOND,
	IPC_412_RESPONSES_PER_SECOND,
	IPC_415_RESPONSES_PER_SECOND,
	IPC_422_RESPONSES_PER_SECOND,
	IPC_424_RESPONSES_PER_SECOND,
	IPC_501_RESPONSES_PER_SECOND,
	IPC_503_RESPONSES_PER_SECOND,

	IPC_TOTAL_POLL_REQUESTS,
	IPC_TOTAL_SUBSCRIBE_REQUESTS,
	IPC_TOTAL_UNSUBSCRIBE_REQUESTS,
	IPC_TOTAL_BATCHDELETE_REQUESTS,
	IPC_TOTAL_BATCHCOPY_REQUESTS,
	IPC_TOTAL_BATCHMOVE_REQUESTS,
	IPC_TOTAL_BATCHPROPPATCH_REQUESTS,
	IPC_TOTAL_BATCHPROPFIND_REQUESTS,
	IPC_TOTAL_204_RESPONSES,
	IPC_TOTAL_207_RESPONSES,
	IPC_TOTAL_302_RESPONSES,
	IPC_TOTAL_403_RESPONSES,
	IPC_TOTAL_405_RESPONSES,
	IPC_TOTAL_406_RESPONSES,
	IPC_TOTAL_409_RESPONSES,
	IPC_TOTAL_412_RESPONSES,
	IPC_TOTAL_415_RESPONSES,
	IPC_TOTAL_422_RESPONSES,
	IPC_TOTAL_424_RESPONSES,
	IPC_TOTAL_501_RESPONSES,
	IPC_TOTAL_503_RESPONSES,

	//		Frontend perf counters
	//
	IPC_REDIRECTS_FROM_BACKEND_PER_SECOND,
	IPC_TOTAL_REDIRECTS_FROM_BACKEND,

	//		IFS file handle cache perf counters
	//
	IPC_IFS_CACHE_HITS_PER_SECOND,
	IPC_TOTAL_IFS_CACHE_HITS,
	IPC_IFS_CACHE_MISSES_PER_SECOND,
	IPC_TOTAL_IFS_CACHE_MISSES,
	IPC_CURRENT_ITEM_COUNT_IN_IFS_CACHE,

	//
	//	Base index where implementation-specific counters start.
	//	DO NOT ADD ANY COMMON COUNTERS BEYOND THIS POINT!
	//
	CPC_COMMON,
	IPC_IMPL_BASE = CPC_COMMON
};

//	------------------------------------------------------------------------
//
//	DAV implementation DLL interface
//
//	The following routines are used by DAV DLL implementations to
//	provide perf counters to monitoring processes.
//
//$NYI	If impls need per-vroot counters, these should be exposed
//$NYI	(like everything else) through CMethUtil.  Once created,
//$NYI	per-vroot counters are only accessed directly via CInstData.
//

//
//	Initialization/Deinitialization
//
BOOL FInitPerfCounters( const VOID * lpvCounterDefs );
VOID DeinitPerfCounters();

//
//	Per-vroot counters instance
//
IPerfCounterBlock * NewVRCounters( LPCSTR lpszVRoot );

//
//	Global perf counter manipulation
//
VOID IncrementGlobalPerfCounter( UINT iCounter );
VOID DecrementGlobalPerfCounter( UINT iCounter );

//
//	Per-instance (vroot) perf counter manipulation
//
class CInstData;
VOID IncrementInstancePerfCounter( const CInstData& cid, UINT iCounter );
VOID DecrementInstancePerfCounter( const CInstData& cid, UINT iCounter );

#endif // !defined(_PERFCTRS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\pipeline.h ===
#ifndef _PIPELINE_H_
#define _PIPELINE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PIPELINE.H
//
//		Declarations for objects and functions that are used when attempting
//      to pass a call to DAVProc through the pipeline.
////
//  Functions included here:
//      SaveHandle
//      LockFile
//      RemoveHandle
//      DupHandle
//
//  Any binaries including this file and not linking to _pipeline.lib will need
//  to define dummy functions for these function declarations.  Note that _shmem.lib
//  does include this file, and in some uses the binaries created with it do not
//  link to _pipeline.lib.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include "smh.h"

#define DEC_CONST		extern const __declspec(selectany)
DEC_CONST CHAR	g_szEventDavCData[] = "Global\\DavCDataUp";

class CInShLockData;

// We send two DWORDS (the action and the ProcessID)
// and one handle (the handle that needs to be removed or saved).
const DWORD PIPE_MESSAGE_SIZE = 2 * sizeof(DWORD) + sizeof(HANDLE) + sizeof(SharedHandle<CInShLockData>);

// Actions you can as the pipeline to do.
enum {	
	DO_NEW_WP,
	DO_REMOVE,
	DO_SAVE,
	DO_LOCK
};

// Functions used to ask DAVProc to perform some action:
//
namespace PIPELINE
{
	VOID LockFile(HANDLE hFileHandle, SharedHandle<CInShLockData>& shLockData);
	VOID SaveHandle(HANDLE hWPHandle);
	VOID RemoveHandle(HANDLE hDAVHandle);
}

// Function used to get a valid handle for the process from
// a handle to the owning process and the handle in it's process.
//
HRESULT DupHandle(HANDLE i_hOwningProcess, HANDLE i_hOwningProcessHandle, HANDLE* o_phCreatedHandle);

#endif  // _PIPELINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\replpropshack.h ===
//	========================================================================
//
//	REPLPROPSHACK.H
//
//		Extra bits for replication in DAVEX.
//
//	========================================================================

#ifndef _REPLPROPSHACK_H_
#define _REPLPROPSHACK_H_

//	Values for new XML nodes
DEC_CONST WCHAR gc_wszReplNode[]				= L"http://schemas.microsoft.com/repl/repl";
DEC_CONST WCHAR gc_wszReplCollBlob[]			= L"http://schemas.microsoft.com/repl/collblob";
DEC_CONST WCHAR gc_wszReplResTagList[]			= L"http://schemas.microsoft.com/repl/resourcetaglist";
DEC_CONST WCHAR gc_wszReplResTagItem[]			= L"http://schemas.microsoft.com/repl/resourcetag";

//	Names for new properties
DEC_CONST WCHAR gc_wszReplChangeType[]		= L"http://schemas.microsoft.com/repl/changetype";
DEC_CONST WCHAR gc_wszReplUid[]				= L"http://schemas.microsoft.com/repl/repl-uid";
DEC_CONST WCHAR gc_wszReplContentTag[]		= L"http://schemas.microsoft.com/repl/contenttag";
DEC_CONST WCHAR gc_wszReplResourceTag[] 	= L"http://schemas.microsoft.com/repl/resourcetag";

//	New headers
DEC_CONST CHAR gc_szResourceTag[] = "ResourceTag";
DEC_CONST CHAR gc_szReplUID[] = "Repl-UID";

//	Namespace string used for namespace preloading by the XML emitter
//
DEC_CONST WCHAR gc_wszReplNameSpace[]				= L"http://schemas.microsoft.com/repl/";

#endif // !_REPLPROPSHACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\request.h ===
#ifndef _REQUEST_H_
#define _REQUEST_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REQUEST.H
//
//		Header for DAV request class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <autoptr.h>	// For CMTRefCounted parent

class IEcb;
class IBodyPartVisitor;
class IAcceptObserver;
class IAsyncStream;
class IAsyncIStreamObserver;
class IAsyncPersistObserver;

//	========================================================================
//
//	CLASS IRequest
//
//		Interface for HTTP 1.1/DAV 1.0 request using an ISAPI
//		EXTENSION_CONTROL_BLOCK
//
class IRequest : public CMTRefCounted
{
private:
	//	NOT IMPLEMENTED
	//
	IRequest& operator=( const IRequest& );
	IRequest( const IRequest& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IRequest() {};

public:
	//	CREATORS
	//
	virtual ~IRequest() = 0;

	//	ACCESSORS
	//
	virtual LPCSTR LpszGetHeader( LPCSTR pszName ) const = 0;
	virtual LPCWSTR LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const = 0;

	virtual BOOL FExistsBody() const = 0;
	virtual IStream * GetBodyIStream( IAsyncIStreamObserver& obs ) const = 0;
	virtual VOID AsyncImplPersistBody( IAsyncStream& stm,
									   IAsyncPersistObserver& obs ) const = 0;

	//	MANIPULATORS
	//
	virtual void ClearBody() = 0;
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyStream( IStream& stm ) = 0;
};

IRequest * NewRequest( IEcb& ecb );

#endif // !defined(_REQUEST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\scrptmps.h ===
/*
 *	S C R P T M P S . H
 *
 *	Scriptmaps cacheing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SCRPTMPS_H_
#define _SCRPTMPS_H_

//	CLASS IScriptMap ----------------------------------------------------------
//
//	NOTE: This interface must be "pure" -- can't use anything that is private
//	to DAVEX because ExINET re-implements this class on LocalStore installs.
//	For that reason, we pass in two pieces from CMethUtil, not the CMethUtil itself.
//
class IScriptMap : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IScriptMap(const IScriptMap&);
	IScriptMap& operator=(IScriptMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IScriptMap() 
	{
	};

public:

	//	ScMatched
	//	This is the workhorse of the scriptmap matching.
	//	There are three possible returns here:
	//		S_OK -- there was NO match in the scriptmaps
	//		W_DAV_SCRIPTMAP_MATCH_FOUND -- There was a match.
	//		W_DAV_SCRIPTMAP_MATCH_EXCLUDED -- There was a match,
	//			but the current method is excluded.
	//	This is important, because the ExINET metabase-replacement code
	//	re-implements this function, and so the semantics must match!
	//
	virtual SCODE ScMatched (LPCWSTR pwszMethod,
							 METHOD_ID midMethod,
							 LPCWSTR pwszMap,
							 DWORD dwAccess,
							 BOOL * pfCGI) const = 0;

	virtual BOOL FSameStarScriptmapping (const IScriptMap *) const = 0;
};

IScriptMap *
NewScriptMap( LPWSTR pwszScriptMaps );

#endif	// _SCRPTMPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\safeobj.h ===
/*
 *	S A F E O B J . H
 *
 *	Implementation of safe object classes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SAFEOBJ_H_
#define _SAFEOBJ_H_

//	safe_xxx classes ----------------------------------------------------------
//
class safe_bstr
{
	BSTR		bstr;

	//	NOT IMPLEMENTED
	//
	safe_bstr(const safe_bstr& b);
	safe_bstr& operator=(const safe_bstr& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_bstr(BSTR b=0) : bstr(b) {}
	~safe_bstr()
	{
		SysFreeString (bstr);
	}

	//	MANIPULATORS
	//
	safe_bstr& operator=(BSTR b)
	{
		Assert(!bstr);		//	Scream on overwrite of good data.
		bstr = b;
		return *this;
	}

	//	ACCESSORS
	//
	BSTR* operator&()	{ Assert(NULL==bstr); return &bstr; }
	BSTR get()			const { return bstr; }
	BSTR relinquish()	{ BSTR b = bstr; bstr = 0; return b; }
	BSTR* load()		{ Assert(NULL==bstr); return &bstr; }
};

class safe_propvariant
{
	PROPVARIANT		var;

	//	NOT IMPLEMENTED
	//
	safe_propvariant(const safe_propvariant& b);
	safe_propvariant& operator=(const safe_propvariant& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_propvariant()
	{
		//	Note! we cannot simply set vt to VT_EMPTY, as when this
		//	structure go across process, it will cause marshalling
		//	problem if not property initialized.
		//
		ZeroMemory (&var, sizeof(PROPVARIANT) );
	}

	~safe_propvariant()
	{
		PropVariantClear (&var);
	}

	//	MANIPULATORS
	//
	safe_propvariant& operator=(PROPVARIANT v)
	{
		Assert(var.vt == VT_EMPTY);		//	Scream on overwrite of good data.
		var = v;
		return *this;
	}

	//	ACCESSORS
	//
	PROPVARIANT* operator&()	{ Assert(var.vt == VT_EMPTY); return &var; }
	//	get() accessor
	//	NOTE that I am returning a const reference here.  The reference is to
	//	avoid creating a copy of our member var on return.  The const is
	//	because this method is a const accessor method.
	const PROPVARIANT& get()	const { return var; }
	//	relinquish() accessor
	//	NOTE that I am NOT returning a reference here.  The return for this
	//	method comes off the STACK (PROPVARIANT v), so a reference would point
	//	to that stack space, and our caller would be accessing OLD STACK frames.
	PROPVARIANT relinquish()	{ PROPVARIANT v = var; var.vt = VT_EMPTY; return v; }
	PROPVARIANT* addressof()	{ return &var; }
};

class safe_variant
{
	//	IMPORTANT:  Do not add any other members to this class
	//	other than the VARIANT that is to be protected.  You will
	//	break code all over the place if you do.  There are places
	//	where an array of these things are treated as an array of
	//	VARIANT structures.
	//
	VARIANT		var;

	//	NOT IMPLEMENTED
	//
	safe_variant(const safe_variant& b);
	safe_variant& operator=(const safe_variant& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_variant()
	{
		//	Note! we cannot simply set vt to VT_EMPTY, as when this
		//	structure go across process, it will cause marshalling
		//	problem if not property initialized.
		//
		ZeroMemory (&var, sizeof(VARIANT) );
	}
	~safe_variant()
	{
		VariantClear (&var);
	}

	//	MANIPULATORS
	//
	safe_variant& operator=(VARIANT v)
	{
		Assert(var.vt == VT_EMPTY);		//	Scream on overwrite of good data.
		var = v;
		return *this;
	}

	//	ACCESSORS
	//
	VARIANT* operator&()	{ Assert(var.vt == VT_EMPTY); return &var; }
	//	get() accessor
	//	NOTE that I am returning a const reference here.  The reference is to
	//	avoid creating a copy of our member var on return.  The const is
	//	because this method is a const accessor method.
	const VARIANT& get()	const { return var; }
	//	relinquish() accessor
	//	NOTE that I am NOT returning a reference here.  The return for this
	//	method comes off the STACK (PROPVARIANT v), so a reference would point
	//	to that stack space, and our caller would be accessing OLD STACK frames.
	VARIANT relinquish()	{ VARIANT v = var; var.vt = VT_EMPTY; return v; }
};

//	Safe impersonation --------------------------------------------------------
//
class safe_impersonation
{
	BOOL		m_fImpersonated;

	//	NOT IMPLEMENTED
	//
	safe_impersonation(const safe_impersonation& b);
	safe_impersonation& operator=(const safe_impersonation& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_impersonation(HANDLE h = 0) : m_fImpersonated(0)
	{
		if (h != 0)
			m_fImpersonated = ImpersonateLoggedOnUser (h);
	}

	~safe_impersonation()
	{
		if (m_fImpersonated)
			RevertToSelf();
	}
};

//	------------------------------------------------------------------------
//
//	class safe_revert
//
//		Turns impersonation OFF for the duration of the object's lifespan.
//		Unconditionally reimpersonates on exit, based on the provided handle.
//
//		NOTE: UNCONDITIONALLY reimpersonates on exit.
//			  (Just wanted to make that clear.)
//
//	WARNING: the safe_revert class should only be used in very selective
//	situations.  It is not a "quick way to get around" impersonation.  If
//	you do need to do something like this, please see Becky -- she will then
//	wack you up'side the head.
//
class safe_revert
{
	HANDLE		m_h;

	safe_revert( const safe_revert& );
	safe_revert& operator=( const safe_revert& );

public:

	explicit safe_revert( HANDLE h ) : m_h(h)
	{
		RevertToSelf();
	}	

	~safe_revert()
	{
		ImpersonateLoggedOnUser( m_h );
	}
};

//	-------------------------------------------------------------------------
//
//	class safe_revert_self
//
//		This is class is essentially the same as safe_revert except it uses
//	the thread handle instead of an external handle
//
class safe_revert_self
{
    // Handle to hold on to the thread token
    // that we will want to use when we go back 
    // to impersonating.
	//
    HANDLE m_hThreadHandle;

public:

    // constructor will revert to self if there is
    // a valid thread token it can get for the current thread
	//
    safe_revert_self() :
			m_hThreadHandle (INVALID_HANDLE_VALUE)
    {
        if (OpenThreadToken( GetCurrentThread(),
        					TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                            TRUE,	//	fOpenAsSelf
                            &m_hThreadHandle ))
		{
            if (!RevertToSelf())
                DebugTrace("Failed to revert to self \r\n");
        }
        else
        	DebugTrace ("Failed to open thread token, last error = %d\n", 
        				GetLastError());
    }

    // destructor will impersonate again if we did a RevertToSelf above.
	//
    ~safe_revert_self()
    {
        if (m_hThreadHandle != INVALID_HANDLE_VALUE)
        {
            if (!ImpersonateLoggedOnUser(m_hThreadHandle))
                DebugTrace("Failed to get back to correct user \r\n");
			
			CloseHandle (m_hThreadHandle);
        }
    }
};

#endif // _SAFEOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\security.h ===
/*
 *	S E C U R I T Y . H
 *
 *	Url security checks.  While these would seem to only apply to HttpEXT,
 *	all impls. that care about ASP execution should really think about this.
 *
 *	Bits stolen from the IIS5 project 'iis5\infocom\cache2\filemisc.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_SECURITY_H_
#define _SECURITY_H_

SCODE __fastcall
ScCheckIfShortFileName (
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ const HANDLE hitUser);

SCODE __fastcall
ScCheckForAltFileStream (
	/* [in] */ LPCWSTR pwszPath);

#endif	// _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\sgstruct.h ===
#ifndef _SGSTRUCT_H_
#define _SGSTRUCT_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SGSTRUCT.H
//
//		Data structures to specify Scatther Gather Files
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#pragma warning(disable:4200)	/* zero-sized array */


// Structure to specify the sizes and offsets of a Scatter-Gather File

typedef struct 	_SGITEM
{
	DWORD	dwibFile;		// offset into file of SG packet
	DWORD	dwcbSegment;    // size (in bytes) of SG packet
	UINT    ibBodyPart;		// offset into body part of SG packet
} SGITEM, *PSGITEM;

// structure to specify a scatther gather file
typedef struct _SCATTER_GATHER_FILE
{
	HANDLE 	hFile; 	// the file handle

	ULONG	cSGList;   //number of scatter-gather packets associated with file

	SGITEM rgSGList[];  // an array of size cSGList ie struct SGITEM rgSGList[cSGItem]

} SCATTER_GATHER_FILE;


#endif // !defined(_SGSTRUCT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\shlkcache.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	S H L K C A C H E . H 
//
//		Declarations for objects existing in shared memory and
//      supporting the shared lock cache implementation.
//
//  Classes defined here are:
//      CInShBytes          = allocates bytes in shared memory.
//      CInShString         = allocates strings in shared memory.
//      CInShLockData       = handles all the information about
//                            a particular lock for a resource.
//      CInShCacheStatic    = holds all static information needed
//                            to use the shared cache.
//      CInShLockCache      = holds the hash table for the shared
//                            memory cache.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#ifndef _SHLKCACHE_H_
#define _SHLKCACHE_H_


#include <smh.h>
#include <sz.h>
#include "pipeline.h"

//==================================
// Forward Declarations for classes
//==================================
class CInShLockCache;
class CInShCacheStatic;
class CInShLockData;

//==================================
// Global Function Declarations
//==================================

// InitalizeSharedCache is implemented in the initobj.cpp file
// as part of the _shlkcache library.
//
HRESULT InitalizeSharedCache(SharedPtr<CInShLockCache>& spSharedCache
                             , SharedPtr<CInShCacheStatic>& spSharedStatic
                             , BOOL fCreateFile);

// Callback for printing out lock information.
//
typedef VOID CALLBACK EmitLockInfoDecl(SharedPtr<CInShLockData>* plock, LPVOID pContext );

//==================================
// Class Declarations
//==================================

//
// Class CInShBytes
//
// Allows for dynamic creation of an array of bytes in shared
// memory.  However, the array is write once, read while holding
// a reference to the object.  Data is not copied when handed out.
//
class CInShBytes
{
private:

    // m_HandleToMemory is really an offset into the shared memory
	// heap supported by smh.h.
	//
    SHMEMHANDLE			m_HandleToMemory;

    //	NOT IMPLEMENTED
	//
	CInShBytes& operator=( const CInShBytes& );
	CInShBytes( const CInShBytes& );

public:
    CInShBytes();
    
    void CopyInBytes(LONG i_cbMemory, LPVOID i_pvMemory);

    LPCVOID GetPtrToBytes();
    LPVOID GetPtrToBytes(LONG i_cbMemory);
    
    ~CInShBytes();
};

//
// Class CInShString
// 
// Allows for dynamic creation of a LPWSTR in shared memory.  However, the
// string is write once, read while holding a reference to the object.  Data 
// is not copied when handed out.
//
class CInShString : CInShBytes
{
private:
	//	NOT IMPLEMENTED
	//
	CInShString& operator=( const CInShString& );
	CInShString( const CInShString& );

public:

    CInShString() {}
    ~CInShString() 
	{ 
	}

    LPCWSTR GetPtrToString()
    {
        return (LPCWSTR) GetPtrToBytes();
    }

    void CopyInString(LPCWSTR i_pStr)
    {
        if (i_pStr!=NULL)
            CopyInBytes(static_cast<LONG>(wcslen(i_pStr)+1) * sizeof(WCHAR), (LPVOID) i_pStr);
        else
            CopyInBytes(0, NULL);
    }


    // Static helper function to get a ptr to a shared memory string
    // when all we have is the shared handle to the CInShString object.
	//
	static LPCWSTR GetPtrToStringFromHandle(SharedHandle<CInShString>& shStringHandle)
	{
        LPCWSTR pRetVal = NULL;

        SharedPtr<CInShString> spString;

		if (spString.FBind(shStringHandle))
        {
            pRetVal = spString->GetPtrToString();
        }
        
        return pRetVal;
    };

};


//
// Class CInShString
// 
// Holds all information about a shared lock as it pertains to a resource.
//
class CInShLockData
{
public:
	
	enum { MAX_LOCKTOKEN_LENGTH = 256 };
    enum { DEFAULT_LOCK_TIMEOUT = 60 * 3 };

private:
	__int64 m_i64LockID;

    // Handles to dynamic sized memory for the class
	//
    SharedHandle<CInShString> m_hOffsetToResourceString;
    SharedHandle<CInShString> m_hOffsetToOwnerComment;
    SharedHandle<CInShBytes> m_hOffsetToSidOwner;

    // Lock description data
	//
    DWORD   m_dwAccess;
	DWORD   m_dwLockType;
	DWORD   m_dwLockScope;
	DWORD   m_dwSecondsTimeout;

    // File handle that DAVProc is holding 
    // to keep the file open.  It must be
    // duphandled before using.
	//
	HANDLE	m_hDAVProcFileHandle;
    
    // Lock Cache Keys
	//
    DWORD   m_dwNameHash;
    DWORD   m_dwIDHash;

    // Lock Cache Timeout data
	//
    FILETIME m_fRememberFtNow;
    FILETIME m_ftLastAccess;
	BOOL	 m_fHasTimedOut;

    // Links for hash table collision support
	//
    SharedHandle<CInShLockData> m_hNextName;
    SharedHandle<CInShLockData> m_hNextID;

    // Unique Lock Token Identifier
	//
    WCHAR    m_rgwchToken[MAX_LOCKTOKEN_LENGTH];

    // Used to save the owner sid with the lock
	//
    HRESULT SetLockOwnerSID(HANDLE hit);

public:

	//	CREATORS
	//
	CInShLockData();
    ~CInShLockData();

    // Initalization functions:
	//
    // Used to setup an inital shared lock
    // with the settings provided.
    HRESULT Init (  LPCWSTR wszStoragePath
                                    , DWORD dwAccess
                                    , _int64 i64LockID
                                    , LPCWSTR pwszGuid
                                    , DWORD dwLockType = 0
                                    , DWORD dwLockScope = 0
                                    , DWORD dwTimeout = 0
                                    , LPCWSTR wszOwnerComment = NULL
                                    , HANDLE hit = INVALID_HANDLE_VALUE
                                   );

    // Used by lock manager to set the key values
    // for the lock cache that this item will be stored at.
	//
    void SetHashes(DWORD dwIDValue, DWORD dwNameValue);

    // Used by DAVProc to set in the DAVProc representation of the file handle.
	//
    void SetDAVProcFileHandle(HANDLE h)
    {  
        Assert (m_hDAVProcFileHandle == INVALID_HANDLE_VALUE);
        m_hDAVProcFileHandle = h; 
    };

    // Hash functions:
	
    BOOL IsEqualByID(__int64 i64LockID)
    {  return (i64LockID == m_i64LockID);  }

    BOOL IsEqualByName(LPCWSTR wszResource, DWORD dwLockType);

    DWORD GetIDHashCode() const
	{ return m_dwIDHash; }

    DWORD GetNameHashCode() const
	{ return m_dwNameHash; }

    // Timer Functions:

	// Checks if a lock has expired.
	//
    BOOL IsExpired(FILETIME ftNow);

    void SetLastAccess(FILETIME ft)
    {  m_ftLastAccess = ft;  }

  	// Last writer wins for changing the timeout.
	//
	VOID SetTimeoutInSecs(DWORD dwSeconds)
	{ m_dwSecondsTimeout = dwSeconds; }


    // Usage Functions:

    HRESULT GetUsableHandle(HANDLE i_hDAVProcess, HANDLE* o_phFile);

   	const __int64 * GetLockID() const
	{ return &m_i64LockID; }

    DWORD GetTimeoutInSecs() const
	{ return m_dwSecondsTimeout; }

	DWORD GetLockType() const
	{ return m_dwLockType; }

	DWORD GetLockScope() const
	{ return m_dwLockScope; }

    DWORD GetAccess() const
    { return m_dwAccess; }

    // This is a create once, don't change property.If you use this to get the
	// resource name, do not release the handle on the object until you
    // are done with this pointer into the object below.
	//
    LPCVOID GetOwnerSID()
    { 
        SharedPtr<CInShBytes> pSID;

		pSID.FBind(m_hOffsetToSidOwner);

		if (!pSID.FIsNull())
			return (LPVOID) (pSID->GetPtrToBytes());
		return NULL;
    }

    // This is a create once, don't change property.If you use this to get the
	// resource name, do not release the handle on the object until you are
	// done with this pointer into the object below.
	//
    LPCWSTR PwszOwnerComment()
    { 
        return CInShString::GetPtrToStringFromHandle(m_hOffsetToOwnerComment);
    };

    // This is a create once, don't change property.If you use this to get the
	// resource name, do not release the handle on the object until you
    // are done with this pointer into the object below.
	//
    LPCWSTR GetResourceName()
    {
        return CInShString::GetPtrToStringFromHandle(m_hOffsetToResourceString);
    };

	//	Lock token string
	//
	LPCWSTR GetLockTokenString()
    {
		return m_rgwchToken;
	}

	VOID SetNextHandleByID(SharedHandle<CInShLockData>& shNext)
	{
		m_hNextID = shNext;
	}

	SharedHandle<CInShLockData>& GetNextHandleByID ()
	{
		return m_hNextID;
	}

	VOID SetNextHandleByName(SharedHandle<CInShLockData>& shNext)
	{
		m_hNextName = shNext;
	}

	SharedHandle<CInShLockData>& GetNextHandleByName ()
	{
		return m_hNextName;
	}
};

//
// Class CInShCacheStatic
// 
// Holds static information about the shared lock cache.  Only one of these
// should ever be created and it should be created by DAVProc.
//
class CInShCacheStatic
{
private:

    //	Guid string for our lock ids.
	//
	WCHAR m_rgwchGuid[gc_cchMaxGuid];

    //  ProcessId of the DAVProc used for duplicating file handles.
	//
    DWORD m_DAVProcessId;

public:

    // Counter keeping track of next id for a new lock token
	//
    LONG m_lTokenLow;
    LONG m_lTokenHigh;

    // Saves the current process's ID and a newly generated guid for use in
	// creating and working with lock tokens.
	//
    CInShCacheStatic()
        : m_lTokenLow(50)
        , m_lTokenHigh(50)
    {
        m_DAVProcessId = GetCurrentProcessId();

        UUID guid;
        UuidCreate(&guid);

        wsprintfW(m_rgwchGuid, gc_wszGuidFormat,
				  guid.Data1, guid.Data2, guid.Data3,
				  guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
				  guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

    };

    DWORD GetDAVProcessId() const
    { return m_DAVProcessId; }

    LPCWSTR GetGuidString() const
    { return m_rgwchGuid; }
};

//
// Class CInShLockCache
// 
// Holds the shared lock cache table that tracks all active locks
//
class CInShLockCache
{
    // NOTE:  The shared lock cache is double indexed by id and by name
    //        It needs to be indexed by name so we can quickly access 
    //        properties about the lock for propfind when dealing only
    //        with the resource name.
    //        While we shouldn't need to index by the lock id (because we
    //        always have the resource string we are dealing with), it 
    //        would mean more extensive changes to the lockmgr interface,
    //        the CLockCache class and code in all the DAV providers 
    //        to change this over to not use ID.  Since part of the goals
    //        of developing the shared lock cache is to touch as little 
    //        shared project code, I am not making this change.
public:
    enum { CACHE_SIZE = 37 };

private:

    // CODEWORK:  Evaluate performance and move to a better
    //            form of locking for the cache.
    // The Shared lock cache is currently guarded by a spin 
    // lock stored in shared memory, it has no promotion so
    // some mostly read activities like Expiring locks are
    // all blocked with a write lock.
	//
    CSharedMRWLock	m_lock;

    //	NOT IMPLEMENTED
	//
	CInShLockCache& operator=( const CInShLockCache& );
	CInShLockCache( const CInShLockCache& );

    // The lockmgr caches appeared to be variable size, but
    // they are all ways created to be 37 locks, so the shared
    // lock cache will not be variable size.
	//
    SharedHandle<CInShLockData> m_hIDEntries[CACHE_SIZE];
    SharedHandle<CInShLockData> m_hNameEntries[CACHE_SIZE];

    DWORD m_dwItemsInCache;

	// Finds and Deletes the token from the name cache (does not touch the ID cache)
	//	
	void DeleteByName ( LPCWSTR wszResource, __int64 i64LockID);

    // Deletes a found token from the name cache.
	//	
    VOID DeleteFromNameList(SharedPtr<CInShLockData>& spObjToDelete, SharedHandle<CInShLockData>& shObjBefore, DWORD dwIndexInCache);

    // Deletes a found token from the ID cache.
	//
    VOID DeleteFromIDList(SharedPtr<CInShLockData>& spObjToDelete, SharedHandle<CInShLockData>& shObjBefore, DWORD dwIndexInCache);

    // Find a lock when given it's resource name
	//
	BOOL FLookupByName( LPCWSTR wszResource
						, DWORD dwLockType
						, SharedPtr<CInShLockData>& plock );

public:

#ifdef DBG
	// DebugFunction for seeing what is in the cache.
	//
    void DumpCache();
#endif

    CInShLockCache();
    ~CInShLockCache();

    void Add(SharedPtr<CInShLockData>& spSharedEntry);

    BOOL FLookupByID( __int64 i64LockID, SharedPtr<CInShLockData>& plock );

    BOOL FLookUpAll(   LPCWSTR wszResource
                                  , DWORD   dwLockType
                                  , BOOL fEmitXML
                                  , LPVOID pContext
                                  , EmitLockInfoDecl* pEmitLockInfo );
    
	// Will also delete the token from the name cache.
	//
	void DeleteByID( __int64 i64LockID );

    // Figure out a hash code based on the lock id.
	//	
    DWORD GetHashCodeByID(__int64 i64LockID);

    // Figure out a hash code based on the resource string.
	//	
    DWORD GetHashCodeByName(LPCWSTR wszResource);

    VOID ExpireLocks();

    BOOL FEmpty() { return (0 == m_dwItemsInCache);}
};


#endif // _SHLKCACHE_H_ Define
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\response.h ===
#ifndef _RESPONSE_H_
#define _RESPONSE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RESPONSE.H
//
//		Header for DAV response class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <sgstruct.h>	// For PSGITEM in IResponse::AddBodyFile()
#include <autoptr.h>	// For CMTRefCounted parent
#include <body.h>		// For auto_ref_handle, etc.

//	------------------------------------------------------------------------
//
//	CLASS IResponse
//
//		Interface of the HTTP 1.1/DAV 1.0 response using an ISAPI
//		EXTENSION_CONTROL_BLOCK
//
class IEcb;
class IBodyPart;

class IResponseBase : public CMTRefCounted
{
private:
	//	NOT IMPLEMENTED
	//
	IResponseBase& operator=( const IResponseBase& );
	IResponseBase( const IResponseBase& );
protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	IResponseBase() {};
public:
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyText( UINT cchText, LPCWSTR pwszText ) = 0;
	virtual void AddBodyFile( const auto_ref_handle& hf,
							  UINT64 ibFile64 = 0,
							  UINT64 cbFile64 = 0xFFFFFFFFFFFFFFFF ) = 0;
};

class IResponse : public IResponseBase
{
private:
	//	NOT IMPLEMENTED
	//
	IResponse& operator=( const IResponse& );
	IResponse( const IResponse& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IResponse() {};

public:
	//	CREATORS
	//
	virtual ~IResponse() = 0;

	//	ACCESSORS
	//
	virtual IEcb * GetEcb() const = 0;
	virtual BOOL FIsEmpty() const = 0;

	virtual DWORD DwStatusCode() const = 0;
	virtual DWORD DwSubError() const = 0;
	virtual LPCSTR LpszStatusDescription() const = 0;

	virtual LPCSTR LpszGetHeader( LPCSTR pszName ) const = 0;

	//	MANIPULATORS
	//
	virtual void SetStatus( int    iStatusCode,
							LPCSTR lpszReserved,
							UINT   uiCustomSubError,
							LPCSTR lpszBodyDetail,
							UINT   uiBodyDetail = 0 ) = 0;

	virtual void ClearHeaders() = 0;
	virtual void SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple = FALSE ) = 0;
	virtual void SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple = FALSE ) = 0;

	virtual void ClearBody() = 0;
	virtual void SupressBody() = 0;
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyFile( const auto_ref_handle& hf,
							  UINT64 ibFile64 = 0,
							  UINT64 cbFile64 = 0xFFFFFFFFFFFFFFFF ) = 0;

	virtual void AddBodyStream( IStream& stm ) = 0;
	virtual void AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize ) = 0;
	virtual void AddBodyPart( IBodyPart * pBodyPart ) = 0;

	//
	//	Various sending mechanisms
	//
	virtual SCODE ScForward( LPCWSTR pwszURI,
							 BOOL	 fKeepQueryString=TRUE,
							 BOOL	 fCustomErrorUrl = FALSE) = 0;
	virtual SCODE ScRedirect( LPCSTR pszURI ) = 0;
	virtual void Defer() = 0;
	virtual void SendPartial() = 0;
	virtual void SendComplete() = 0;
	virtual void FinishMethod() = 0;
};

IResponse * NewResponse( IEcb& ecb );

#endif // !defined(_RESPONSE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\singlton.h ===
/*
 *	S I N G L T O N . H
 *
 *	Singleton (per-process global) classes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SINGLTON_H_
#define _SINGLTON_H_

#include <caldbg.h>

//	========================================================================
//
//	TEMPLATE CLASS Singleton
//
//	Use this template to implement classes that can only have one instance.
//	NOTE: For ref-counted or on-demand global objects, see below
//		(RefCountedGlobal and OnDemandGlobal).
//
//	The Singleton template provides the following:
//
//		o	a common memory layout for singleton classes which
//			allows template folding to reduce overall code size.
//
//		o	an instantiation mechanism that verifies (asserts)
//			that only instance of your class ever exists.
//
//		o	asserts to catch any code which attempts to use
//			your class when it's not initialized.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private Singleton<YourClass>
//		{
//			//
//			//	Declare Singleton as a friend of YourClass
//			//	if YourClass's constructor is private (which it
//			//	should be since YourClass is a singleton and
//			//	should not be allowed to arbitrarily create
//			//	instances of it).
//			//
//			friend class Singleton<YourClass>;
//
//			//
//			//	YourClass private members.  Since the 'staticness'
//			//	of YourClass is provided entirely by this template,
//			//	you do not need to declare your members as 'static'
//			//	and you should use standard Hungarian class member
//			//	naming conventions (e.g. m_dwShoeSize).
//			//
//			[...]
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass which
//			//	would call CreateInstance() and DestroyInstance()
//			//	respectively.  Or, you could just expose these functions
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using Singleton<YourClass>::CreateInstance;
//			//		using Singleton<YourClass>::DestroyInstance;
//			//
//			//	Similarly, YourClass will probably have additional
//			//	static methods which access or operate on the
//			//	singleton instance.  These will call Instance()
//			//	to get at the global instance.  Or, though it's
//			//	not recommended from an encapsulation standpoint,
//			//	you could expose the global instance directly to
//			//	clients with:
//			//
//			//		using Singleton<YourClass>::Instance;
//			//
//			[...]
//		};
//
template<class _X>
class Singleton
{
	//
	//	Space for the sole instance
	//
	static BYTE sm_rgbInstance[];

	//
	//	Pointer to the instance
	//
	static _X * sm_pInstance;

public:
	//	STATICS
	//

	//
	//	Create the single, global instance of class _X.
	//
	static _X& CreateInstance()
	{
		//
		//	This actually calls Singleton::new()
		//	(defined below), but calls to new()
		//	must always be unqualified.
		//
		return *(new _X());
	}

	//
	//	Destroy the single, global instance of class _X.
	//
	static VOID DestroyInstance()
	{
		//
		//	This actually calls Singleton::delete()
		//	(defined below), but calls to delete()
		//	must always be unqualified.
		//
		if (sm_pInstance)
			delete sm_pInstance;
	}

	//
	//	Provide access to the single, global instance of class _X.
	//
	static BOOL FIsInstantiated()
	{
		return !!sm_pInstance;
	}

	static _X& Instance()
	{
		Assert( sm_pInstance );

		return *sm_pInstance;
	}

	//
	//	Singleton operator new and operator delete "allocate"
	//	space for the object in static memory.  These must be
	//	defined public for syntactic reasons.  Do NOT call them
	//	directly!!  Use CreateInstance()/DestroyInstance().
	//
	static void * operator new(size_t)
	{
		Assert( !sm_pInstance );

		//
		//	Just return a pointer to the space
		//	in which to instantiate the object.
		//
		sm_pInstance = reinterpret_cast<_X *>(sm_rgbInstance);
		return sm_pInstance;
	}

	static void operator delete(void *, size_t)
	{
		Assert( sm_pInstance );

		//
		//	Since nothing was done to allocate space
		//	for the instance, we don't do anything
		//	here to free it.
		//
		sm_pInstance = NULL;
	}

};

//
//	Space for the sole instance of class _X
//
template<class _X>
BYTE Singleton<_X>::sm_rgbInstance[sizeof(_X)] = {0};

//
//	Pointer to the instance
//
template<class _X>
_X * Singleton<_X>::sm_pInstance = NULL;


//	========================================================================
//
//	CLASS _Empty
//
//	A completely empty, but instantiatable class.  Use the _Empty class
//	to get around the syntactic inability to instantiate anything of
//	type void (or VOID).
//
//	In retail builds, _Empty has the same memory footprint and code
//	impact as void -- none.
//
//	See the RefCountedGlobal template below for a usage example.
//
class _Empty
{
	//	NOT IMPLEMENTED
	//
	_Empty( const _Empty& );
	_Empty& operator=( const _Empty& );

public:
	_Empty() {}
	~_Empty() {}
};


//	========================================================================
//
//	TEMPLATE CLASS RefCountedGlobal
//
//	Use this template as boilerplate for any class that encapsulates
//	a global, refcounted initialization/deinitialization process.
//
//	This template maintains proper refcounting and synchronization when
//	there are multiple threads trying to initialize and deinitialize
//	references at the same time.  And it does so without a critical
//	section.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private RefCountedGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call DwInitRef() and DeinitRef() respectively.
//			//	Or, you could just expose DwInitRef() and DeinitRef()
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::DwInitRef;
//			//		using RefCountedGlobal<YourClass>::DeinitRef;
//			//
//			[...]
//		};
//
//	If YourClass::FInit() succeeds (returns TRUE), then DwInitRef()
//	returns the new refcount.  If YourClass::FInit() fails (returns
//	FALSE), then DwInitRef() returns 0.
//
//	See \cal\src\inc\memx.h for sample usage.
//
//	If YourClass::FInit() requires initialization parameters, you can
//	still use the RefCountedGlobal template.  You just need to provide
//	your parameter type in the template instantiation and declare your
//	FInit() to take a const reference to a parameter of that type:
//
//		class YourClass : private RefCountedGlobal<YourClass, YourParameterType>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that htey can call your private
//			//	initialization functions.
//			//
//			//	Note the added parameter type to the RefCountedGlobal
//			//	declaration.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass, YourParameterType>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	now takes a const ref to the initialization parameters.
//			//
//			BOOL FInit( const YourParameterType& initParam );
//
//		public:
//			//
//			//	Public declarations for YourClass
//			//
//			[...]
//		};
//
//	See \cal\src\httpext\entry.cpp for an example of this usage.
//
template<class _X, class _ParmType = _Empty>
class RefCountedGlobal : private Singleton<_X>
{
	//
	//	The object's reference count.
	//
	static LONG sm_lcRef;

	//
	//	Member template that generates an appropriately-typed,
	//	(inline) function that calls _X::FInit with initialization
	//	parameters.
	//
	template<class _P> static BOOL
	FInit( const _P& parms ) { return Instance().FInit( parms ); }

	//
	//	Specialization of the above member template for
	//	the _Empty parameter type, which calls _X::FInit
	//	without initialization parameters.
	//
	static BOOL FInit( const _Empty& ) { return Instance().FInit(); }

protected:

	//
	//	Set of states which describe the object's state
	//	of initialization.  The object's state is
	//	STATE_UNKNOWN while it is being initialized or
	//	deinitialized.
	//
	enum
	{
		STATE_UNINITIALIZED,
		STATE_INITIALIZED,
		STATE_UNKNOWN
	};

	static LONG sm_lState;

	//
	//	Expose access to the single instance of class _X
	//
	using Singleton<_X>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template so that they will be
	//	used rather than the default new and delete
	//	to "allocate" space for the instance of class _X.
	//
	using Singleton<_X>::operator new;
	using Singleton<_X>::operator delete;

	static BOOL FInitialized()
	{
		return sm_lState == STATE_INITIALIZED;
	}

	static LONG CRef()
	{
		return sm_lcRef;
	}

public:
	static DWORD DwInitRef( const _ParmType& parms )
	{
		LONG lcRef;

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );

		//
		//	Add the reference for the instance we're about
		//	to initialize.  Doing this now simplifies the
		//	code below at the expense of having to decrement
		//	if first time initialization (FInit()) fails.
		//	The only thing critical to the design is that
		//	at any point, when sm_lState is STATE_INITIALIZED,
		//	sm_lcRef is at least 1.
		//
		lcRef = InterlockedIncrement( &sm_lcRef );
		Assert( lcRef > 0 );

		//
		//	Don't proceed until the object is initialized.
		//
		while ( sm_lState != STATE_INITIALIZED )
		{
			//
			//	Simultaneously check whether initialization has
			//	started and, if it has not, start it.
			//
			LONG lStatePrev = InterlockedCompareExchange(
								&sm_lState,
								STATE_UNKNOWN,
								STATE_UNINITIALIZED );

			//
			//	If we're starting first time initialization,
			//	then create and initialize the sole instance.
			//
			if ( lStatePrev == STATE_UNINITIALIZED )
			{
				CreateInstance();

				//	This calls our private member template FInit()
				//	(declared above), which in turn calls _X::Finit()
				//	with the appropriate parameters.
				//
				if ( FInit( parms ) )
				{
					sm_lState = STATE_INITIALIZED;
					break;
				}

				//	We failed to init.
				//	Tear down now.
				//

				Assert( lcRef == 1 );
				Assert( sm_lState == STATE_UNKNOWN );

				//	Let go of our ref on the object.
				//	Destroy the object.
				//	And LAST, set the state to UNINITIALIZED.
				//	NOTE: This will let the next caller through the
				//	InterlockedCompare above.
				//
				InterlockedDecrement( &sm_lcRef );
				DestroyInstance();
				sm_lState = STATE_UNINITIALIZED;

				return 0;
			}

			//
			//	If first time initialization is in progress on
			//	another thread, then get out of the way so
			//	it can finish.
			//
			//$OPT	We should probably spin rather than Sleep()
			//$OPT	on multi-proc machines on the assumption that
			//$OPT	we only get here on a processor other than
			//$OPT	the one which is doing the initialization
			//$OPT	and we don't want to invite a task switch
			//$OPT	by calling Sleep() while we are waiting
			//$OPT	for initialization to complete.
			//
			if ( lStatePrev == STATE_UNKNOWN )
				Sleep(0);
		}

		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		return static_cast<DWORD>(lcRef);
	}

	static VOID DeinitRef()
	{
		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		//
		//	Remove that reference.  If it is the last
		//	then deinit the object.
		//
		if ( 0 == InterlockedDecrement( &sm_lcRef ) )
		{
			//
			//	After releasing the last reference, declare that
			//	the object is in an unknown state.  This prevents
			//	other threads trying to re-initialize the object
			//	from proceeding until we're done.
			//
			sm_lState = STATE_UNKNOWN;

			//
			//	There is a tiny window between decrementing the
			//	refcount and changing the state where another
			//	initialization could have come through.  Test this
			//	by rechecking the refcount.
			//
			if ( 0 == sm_lcRef )
			{
				//
				//	If the refcount is still zero, then no
				//	initializations happened before we changed
				//	states.  At this point, if an initialization
				//	starts, it will block until we change state,
				//	so it is safe to actually destroy the instance.
				//
				DestroyInstance();

				//
				//	Once the object has been deinitialized, update
				//	the state information.  This unblocks any
				//	initializations waiting to happen.
				//
				sm_lState = STATE_UNINITIALIZED;
			}
			else // refcount is now non-zero
			{
				//
				//	If the refcount is no longer zero, then an
				//	initialization happened between decrementing
				//	the refcount above and entering the unknown
				//	state.  When that happens, DO NOT deinit --
				//	there is now another valid reference somewhere.
				//	Instead, just restore the object's state to let
				//	other references proceed.
				//
				sm_lState = STATE_INITIALIZED;
			}
		}

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );
	}

	//	This provides a no-parameter version of DwInitRef
	//	for clients that do not need any parameters in FInit().
	//
	static DWORD DwInitRef()
	{
		_Empty e;

		return DwInitRef( e );
	}
};

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lcRef = 0;

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lState = STATE_UNINITIALIZED;


//	========================================================================
//
//	TEMPLATE CLASS OnDemandGlobal
//
//	Use this template to implement a global object which should be
//	initialized on its first use ("on demand") and then explicitly
//	deinitialized once if it was ever used.
//
//	The most common usage is with global objects that ideally are never
//	used or for which up-front initialization is prohibitively
//	expensive.  However, once the object has been initialied, it should
//	remain initialized (to avoid having to initialize it again) until
//	it is explicitly deinitialized.
//
//	!!!	OnDemandGlobal DOES NOT provide refcounting functionality to
//		consumers -- It uses refcounting internally, but is not intended
//		to expose it to callers.  If you want refcounting, use RefCountedGlobal.
//		If you call DeinitIfUsed(), the instance WILL be destroyed if it
//		exists. In particular, calling code MUST ensure that DeinitIfUsed()
//		is not called while any other thread is inside FInitOnFirstUse().
//		Failure to do so can cause FInitOnFirstUse() to return with the
//		object uninitialized.
//
//	Usage:
//
//		class YourClass : private OnDemandGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	creation/initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call FInitOnFirstUse() and DeinitIfUsed()
//			//	respectively.  Or, you could just expose FInitOnFirstUse()
//			//	and DeinitIfUsed() directly to clients of YourClass with
//			//	using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::FInitOnFirstUse;
//			//		using RefCountedGlobal<YourClass>::DeinitIfUsed;
//			//
//			[...]
//		};
//
//	FInitOnFirstUse() can be called any number of times from any
//	thread, including simultaneously from multiple threads, but
//	DeinitIfUsed() should only ever be called once, and then
//	only when no other threads are calling FInitOnFirstUse().
//
//	OnDemandGlobal takes care of tracking whether YourClass was
//	ever actually used so that DeinitIfUsed() is safe to call
//	even if YourClass was never used (hence the name).
//
//	See \cal\src\_davprs\eventlog.cpp for sample usage.
//
template<class _X, class _ParmType = _Empty>
class OnDemandGlobal : private RefCountedGlobal<_X, _ParmType>
{
protected:
	//
	//	Expose access to the single instance of class _X
	//
	using RefCountedGlobal<_X, _ParmType>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template (via RefCountedGlobal)
	//	so that they will be used rather than the
	//	default new and delete to "allocate" space
	//	for the instance of class _X.
	//
	using RefCountedGlobal<_X, _ParmType>::operator new;
	using RefCountedGlobal<_X, _ParmType>::operator delete;

public:
	static BOOL FInitOnFirstUse( const _ParmType& parms )
	{
		DWORD dwResult = 1;

		if ( STATE_INITIALIZED != sm_lState )
		{
			//	Add a reference to the object.  If this is the first
			//	reference, RefCountedGlobal will call _X::FInit()
			//	to initialize the object.
			//
			DWORD dwResult = DwInitRef( parms );

			//	If this was not the first reference, then release
			//	the reference we just added.  We only want one
			//	reference left around by the time DeinitIfUsed()
			//	so that the DeinitRef() called from there will
			//	actually destroy the object.
			//
			if ( dwResult > 1 )
				DeinitRef();
		}

		//	Return success/failure (dwResult == 0 --> failure)
		//
		return !!dwResult;
	}

	static BOOL FInitOnFirstUse()
	{
		_Empty e;

		return FInitOnFirstUse( e );
	}

	static VOID DeinitIfUsed()
	{
		//
		//	If the object was never initialized (i.e. there was
		//	never a reference to it), then do nothing.
		//	Otherwise, deinit the object.
		//
		if ( FInitialized() )
		{
			//
			//	Make sure there is EXACTLY one reference.
			//	Zero references indicates a bug in setting the
			//	initialization state.  More than one reference
			//	most likely indicates that OnDemandGlobal is
			//	being used where RefCountedGlobal is needed.
			//
			Assert( CRef() == 1 );

			DeinitRef();
		}
	}
};

#endif // _SINGLTON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\smh.h ===
#ifndef _SMH_H_
#define _SMH_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SMH.H
//
//		Public interface to shared memory heap implementation in
//		\cal\src\_shmem
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <synchro.h>

//	========================================================================
//	SHARED MEMORY HANDLES
//
//	They are always defined as 32 bit values
//
#ifdef _WIN64
	typedef VOID * __ptr32 SHMEMHANDLE;
#else
	typedef HANDLE SHMEMHANDLE;
#endif


//	========================================================================
//
//	NAMESPACE SMH
//
//	Differentiates the shared memory heap allocation functions
//	from all of the other various heap allocation functions
//	in existence.
//
//	Yes, this could have been done with a prefix just as easily....
//
namespace SMH
{
	BOOL __fastcall FInitialize( IN LPCWSTR pwszInstanceName );
	VOID __fastcall Deinitialize();
	PVOID __fastcall PvAlloc( IN DWORD cbData, OUT SHMEMHANDLE * phsmba );
	VOID __fastcall Free( IN SHMEMHANDLE hsmba );
	PVOID __fastcall PvFromSMBA( IN SHMEMHANDLE hsmba );
};


//	========================================================================
//
//	CLASS CSmhInit
//
//	Initializer for shared memory heap.  Any class containing member objects
//	that reside on the shared memory heap should also include an instance
//	of this class as a member BEFORE the others to ensure that they are
//	properly destroyed before the heap is deinitialized.
//
class CSmhInit
{
	//	NOT IMPLEMENTED
	//
	CSmhInit& operator=( const CSmhInit& );
	CSmhInit( const CSmhInit& );

public:
	CSmhInit()
	{
	}

	BOOL FInitialize( LPCWSTR lpwszSignature )
	{
		return SMH::FInitialize( lpwszSignature );
	}

	~CSmhInit()
	{
		SMH::Deinitialize();
	}
};

//	========================================================================
//
//	TEMPLATE CLASS SharedHandle
//
//	Encapsulates a reference to a SharedObj (a refcounted object in shared
//	memory).  The SharedHandle itself is designed to exist in shared memory.
//	Any process can access the SharedObj through a SharedHandle.
//	Because the SharedHandle represents a reference on the SharedObj,
//	access to the SharedObj through the handle is always "safe"
//	in that the SharedObj cannot "go away" as long as the SharedHandle
//	exists.  If safe access to the SharedHandle itself is a concern,
//	that protection must be provided externally.  This can be easily done
//	by making the SharedHandle a member of another SharedObj.  Entire
//	hierarchies of refcounted objects in shared memory can be created
//	this way.
//
template<class _X> class SharedObj;
template<class _X>
class SharedHandle
{
	//
	//	The RAW shared memory handle
	//
	SHMEMHANDLE m_hsmba;

	//
	//	A shared multi-reader/single writer lock to resolve
	//	simultaneous attempts to modify the handle via
	//	operator=() while accessing it via PObjBind().
	//	It should not be possible for consumers of
	//	SharedHandle to return from PObjBind() without a
	//	qualified reference to some object.
	//
	mutable CSharedMRWLock m_lock;

	//	CREATORS
	//
	void Init( SharedObj<_X> * pObj,
			   SHMEMHANDLE hsmba )
	{
		//
		//	Stuff the object and its raw handle.
		//	Note that NULL objects (with corresponding
		//	NULL handles) are allowed.  Get a proper
		//	ref on the object before returning.
		//
		if ( pObj )
		{
			Assert( hsmba );

			pObj->AddRef();
		}

		m_hsmba = hsmba;
	}

	void Deinit()
	{
		//
		//	If the handle is non-NULL, drop the ref
		//	to its SharedObject, destroying the object
		//	when the last ref is released.
		//
		if ( m_hsmba )
		{
			SharedObj<_X> * pObj = static_cast<SharedObj<_X> *>(SMH::PvFromSMBA( m_hsmba ));

			Assert( pObj );

			if ( 0 == pObj->Release() )
			{
				pObj->~SharedObj<_X>();
				SMH::Free( m_hsmba );
			}
			
			//	We should always reset m_hsmba because it's ref is gone already
			//
			m_hsmba = NULL;
		}
	}

public:
	//	CREATORS
	//
	SharedHandle() :
		m_hsmba(NULL)
	{
	}

	~SharedHandle()
	{
		Deinit();
	}

	SharedHandle( const SharedHandle<_X>& rhs )
	{
		(VOID) rhs.PObjBind(this);
	}

	SharedHandle<_X>& operator=( const SharedHandle<_X>& rhs )
	{
		//
		//	Shortcut for assignment to self.  Actually doing
		//	the assignment to self is a recipe for deadlock.
		//
		if ( this != &rhs )
		{
			SynchronizedWriteBlock<CSharedMRWLock> blk(m_lock);

			//
			//	Blow away the current value associated with this handle
			//
			Deinit();

			//
			//	Construct new data for the handle
			//
			(VOID) rhs.PObjBind(this);
		}

		return *this;
	}

	VOID Clear()
	{
		Deinit();
	}
	
	//	ACCESSORS
	//
	SharedObj<_X> * PObjBind( SharedHandle<_X> * pshObj ) const
	{
		SynchronizedReadBlock<CSharedMRWLock> blk(m_lock);

		SharedObj<_X> * pObj;

		pObj = m_hsmba ?
				   static_cast<SharedObj<_X> *>(SMH::PvFromSMBA( m_hsmba )) :
				   NULL;

		pshObj->Init(pObj, m_hsmba);

		return pObj;
	}

	//	STATICS
	//
	static SharedObj<_X> *
	Create( UINT cbExtra,
			SharedHandle<_X> * pshObj )
	{
		SHMEMHANDLE hsmba;

		SharedObj<_X> * pObj =
			new(SMH::PvAlloc( sizeof(SharedObj<_X>) + cbExtra, &hsmba ))
				SharedObj<_X>();

		pshObj->Init(pObj, hsmba);

		return pObj;
	}
};

//	========================================================================
//
//	TEMPLATE CLASS SharedObj
//
//	Implements a refcountable object in shared memory.  The object data
//	itself is provided by the template paramater (_X).  Access to the object
//	through this interface is direct.  It is up to the consumer of
//	SharedObj to provide thread-safe access and control the lifetime
//	of the object via its refcount.
//
template<class _X>
class SharedObj
{
	//
	//	Refcount
	//
	LONG m_lcRef;

	//
	//	The _X instance
	//
	_X m_x;

	//	NOT IMPLEMENTED
	//
	SharedObj& operator=( const SharedObj& );
	SharedObj( const SharedObj& );

public:

	//	STATICS
	//
	static void * operator new(size_t cb, void * pv)
	{
		//
		//	Just return the pointer given to us.  Presumably, it points
		//	to a valid block of shared memory large enough to contain
		//	the object.
		//
		return pv;
	}

	//	Fix C4291
	void operator delete (void * pv) {}
	void operator delete (void * pv, void * pM) {}

	//
	//	For symetry with operator new we also could create operator delete.
	//	As this object manages just a refcount, but not memory we will
	//	could just return. But that is not that important at the moment.
	//

	//	CREATORS
	//
	SharedObj() : m_lcRef(0) {}

	//	ACCESSORS
	//
	const _X& X() const { return m_x; }
	_X& X() { return m_x; }

	UINT AddRef()
	{
		DebugTrace ("SharedObj AddRef = %d, this = %x\n", m_lcRef+1, this);
		return InterlockedIncrement( &m_lcRef );
	}

	UINT Release()
	{
		DebugTrace ("SharedObj Release = %d, this = %x\n", m_lcRef-1, this);
		return InterlockedDecrement( &m_lcRef );
	}
};

//	========================================================================
//
//	TEMPLATE CLASS SharedPtr
//
//	Encapsulates a reference to a SharedObj (a refcounted object in shared
//	memory) as a pointer for use in local (process) memory.  A SharedPtr
//	is essentially just a SharedHandle (which holds a reference to the
//	SharedObj) and an addressable pointer bound to that handle.
//
template<class _X>
class SharedPtr
{
	//
	//	The SharedHandle to which this SharedPtr is bound
	//
	SharedHandle<_X> m_shObj;

	//
	//	Physical pointer to the shared object
	//
	SharedObj<_X> * m_pObj;

	//	NOT IMPLEMENTED
	//
	SharedPtr& operator=( const SharedPtr& );
	SharedPtr( const SharedPtr& );

public:
	//	CREATORS
	//
	SharedPtr() :
		m_pObj(NULL)
	{
	}

	~SharedPtr() {}

	//	ACCESSORS
	//
	SharedHandle<_X>& GetHandle()
	{
		return m_shObj;
	}

	BOOL FIsNull() const
	{
		return !m_pObj;
	}

	//	MANIPULATORS
	//

	//	Create a new object.  cbExtra leaves room at the end of
	//	the allocation for variable-sized objects.
	//
	BOOL FCreate( UINT cbExtra = 0 )
	{
		m_pObj = SharedHandle<_X>::Create( cbExtra, &m_shObj );

		return !!m_pObj;
	}

	//	Bind to an existing SharedObject by its handle.
	//
	BOOL FBind( SharedHandle<_X>& shObj )
	{
		Assert (NULL == m_pObj);
		
		m_pObj = shObj.PObjBind( &m_shObj );

		return !!m_pObj;
	}

	//
	//	Forward everything else to the controlled object
	//
	_X* operator->() const
	{
		Assert( m_pObj );
		return &m_pObj->X();
	}

	VOID Clear()
	{
		m_pObj = NULL;
		m_shObj.Clear();
	}
};

#endif // !defined(_SMH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\statcode.h ===
/*
 *	S T A T C O D E . H
 *
 *	DAV response status codes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_STATCODE_H_
#define _STATCODE_H_

//	HTTP/1.1 Response Status Codes --------------------------------------------
//
#define	HSC_CONTINUE						100
#define	HSC_SWITCH_PROTOCOL					101
#define HSC_PROCESSING						102

#define	HSC_OK								200
#define	HSC_CREATED							201
#define	HSC_ACCEPTED						202
#define	HSC_NON_AUTHORITATIVE_INFO			203
#define	HSC_NO_CONTENT						204
#define	HSC_RESET_CONTENT					205
#define	HSC_PARTIAL_CONTENT					206
#define	HSC_MULTI_STATUS					207

#define HSC_SUBSCRIBED						241
#define HSC_SUBSCRIPTION_FAILED				242
#define HSC_NOTIFICATION_FAILED				243
#define HSC_NOTIFICATION_ACKNOWLEDGED		244
#define HSC_EVENTS_FOLLOW					245
#define HSC_NO_EVENTS_PENDING				246

#define	HSC_MULTIPLE_CHOICE					300
#define	HSC_MOVED_PERMANENTLY				301
#define	HSC_MOVED_TEMPORARILY				302
#define	HSC_SEE_OTHER						303
#define	HSC_NOT_MODIFIED					304
#define	HSC_USE_PROXY						305

#define	HSC_BAD_REQUEST						400
#define	HSC_UNAUTHORIZED					401
#define	HSC_PAYMENT_REQUIRED				402
#define	HSC_FORBIDDEN						403
#define	HSC_NOT_FOUND						404
#define	HSC_METHOD_NOT_ALLOWED				405
#define	HSC_NOT_ACCEPTABLE					406
#define	HSC_PROXY_AUTH_REQUIRED				407
#define	HSC_REQUEST_TIMEOUT					408
#define	HSC_CONFLICT						409
#define	HSC_GONE							410
#define	HSC_LENGTH_REQUIRED					411
#define	HSC_PRECONDITION_FAILED				412
#define	HSC_REQUEST_ENTITY_TOO_LARGE		413
#define	HSC_REQUEST_URI_TOO_LARGE			414
#define	HSC_UNSUPPORTED_MEDIA_TYPE			415
#define HSC_RANGE_NOT_SATISFIABLE			416
#define HSC_EXPECTATION_FAILED				417

#define HSC_UNPROCESSABLE					422
#define	HSC_LOCKED							423
#define HSC_METHOD_FAILURE					424

#define HSC_INCOMPLETE_DATA					437

#define	HSC_INTERNAL_SERVER_ERROR			500
#define	HSC_NOT_IMPLEMENTED					501
#define	HSC_BAD_GATEWAY						502
#define	HSC_SERVICE_UNAVAILABLE				503
#define	HSC_GATEWAY_TIMEOUT					504
#define	HSC_VERSION_NOT_SUPPORTED			505
#define	HSC_NO_PARTIAL_UPDATE				506
#define HSC_INSUFFICIENT_SPACE				507

#define HSC_SERVER_TOO_BUSY					513

//	Util macros ---------------------------------------------------------------
//
#define FSuccessHSC(_h)					((_h) < 300)
#define FFailedHSC(_h)					((_h) >= 300)
#define FRedirectHSC(_h)				(((_h) == 301) ||		\
										 ((_h) == 302) ||		\
										 ((_h) == 303) ||		\
										 ((_h) == 305))

#endif	// _STATCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\stm.h ===
/*
 *	S T M . H
 *
 *	Basis stream implementation class
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_STM_H_
#define _STM_H_

#include <nonimpl.h>
#include <davimpl.h>
#include <statcode.h>

//	StmToBody -----------------------------------------------------------------
//
class StmToBody : public CStreamNonImpl
{
private:

	IMethUtil *		m_pmu;

public:

	StmToBody(IMethUtil * pmu) : m_pmu(pmu) {}
	~StmToBody() {}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
		/* [size_is][in] */ const void __RPC_FAR * pb,
		/* [in] */ ULONG cb,
		/* [out] */ ULONG __RPC_FAR * pcb);

	virtual HRESULT STDMETHODCALLTYPE Commit(
		/* [in] */ DWORD)
	{
		//	MSXML's implementation of IPersistStreamInit() calls
		//	Commit() when the writing is complete.  We really don't
		//	care here and should simply return S_OK;
		//
		DebugTrace ("Dav: CStreanNonImpl::Commit() return S_OK");
		return S_OK;
	}
};

#endif // _STM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\spinlock.h ===
/*==========================================================================*\

    Module:        spinlock.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Implements a spin lock that can be used on Shared Memory

\*==========================================================================*/

#ifndef __SPINLOCK_H__
#define __SPINLOCK_H__

//
// This correct value of the spin count will depend heavily on how much time
//  is spent holding the lock.
//
const DWORD DEFAULT_SPIN_COUNT = 500; // ??
const DWORD SPIN_UNLOCKED      = 0;


/*$--CSpinLock==============================================================*\

\*==========================================================================*/

class CSpinLock
{
public:
    
    void  Initialize(IN DWORD cMaxSpin = DEFAULT_SPIN_COUNT);
    void  Acquire();
    void  Relinquish();
    void  ResetIfOwnedByOtherProcess();
    
private:
    BOOL  m_fMultiProc;
    DWORD m_cMaxSpin;
    
    volatile DWORD m_dwLock;
};



/*$--CSpinLock::Initialize==================================================*\

\*==========================================================================*/

inline
void
CSpinLock::Initialize(IN DWORD cMaxSpin)
{
    SYSTEM_INFO si;
    
    GetSystemInfo(&si);
    m_fMultiProc = (si.dwNumberOfProcessors > 1);
    
    m_dwLock     = SPIN_UNLOCKED;
    m_cMaxSpin   = cMaxSpin;
}


/*$--CSpinLock::Acquire=====================================================*\



\*==========================================================================*/

inline
void
CSpinLock::Acquire()
{
    DWORD cSpin       = m_cMaxSpin;
    DWORD dwLockId    = GetCurrentProcessId();



    while(InterlockedCompareExchange((LONG *)&m_dwLock,
                                     dwLockId,
                                     SPIN_UNLOCKED))
    {
        // We should only spin if we're running on a multiprocessor
        if (m_fMultiProc)
        {
            if (cSpin--)
                continue;
            cSpin = m_cMaxSpin;
        }
        Sleep(0);  // Deschedule ourselves and let whomever has the lock get out
    }
}



/*$--CSpinLock::Relinquish==================================================*\

\*==========================================================================*/

inline
void
CSpinLock::Relinquish()
{
    Assert(m_dwLock);
    
    m_dwLock = SPIN_UNLOCKED;
}



/*$--CSpinLock::ResetIfOwnedByOtherProcess==================================*\

  This method is needed to reset the spin lock in the case where it was being
  held by a process that died and didn't have a chance to relinquish it.

\*==========================================================================*/

inline
void
CSpinLock::ResetIfOwnedByOtherProcess()
{
    // If it's not locked by us, then reset it.
    if ((DWORD)m_dwLock != GetCurrentProcessId())
        m_dwLock = SPIN_UNLOCKED;
}


#endif // __SPINLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\statetok.h ===
/*
 *	S T A T E T O K. H
 *
 *	Sources implementation of DAV-Lock common definitions.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

/*
 *	This file contains the definitions used for parsing state token
 *	relared headers.
 *
 */

#ifndef __STATETOK_H__
#define __STATETOK_H__

//	Current max seconds = 1 day.
//
DEC_CONST INT	gc_cSecondsMaxLock = 60 * 60 * 24;

//	Current default lock time out is 3 minutes
//
DEC_CONST INT	gc_cSecondsDefaultLock = 60 * 3;

//$REVIEW	These flags are duplicated in lockmgr.h and statetok.h. before
//$REVIEW	this is addressed, to be safe, we make sure they match
//$REVIEW	Also inherit the excellent comments from the lockmgr.h regarding
//$REVIEW	how the flags should be defined when we merge.
#define DAV_LOCKTYPE_ROLLBACK			0x08000000
#define DAV_LOCKTYPE_CHECKOUT			0x04000000
#define DAV_LOCKTYPE_TRANSACTION_GOP	0x00100000
#define DAV_LOCKTYPE_READWRITE	(GENERIC_READ | GENERIC_WRITE)
#define DAV_LOCKTYPE_FLAGS		(GENERIC_READ | GENERIC_WRITE | DAV_LOCKTYPE_ROLLBACK | DAV_LOCKTYPE_CHECKOUT | DAV_LOCKTYPE_TRANSACTION_GOP)
#define DAV_EXCLUSIVE_LOCK		0x01000000
#define DAV_SHARED_LOCK			0x02000000
#define DAV_LOCKSCOPE_LOCAL		0x04000000
#define DAV_LOCKSCOPE_FLAGS		(DAV_EXCLUSIVE_LOCK | DAV_SHARED_LOCK | DAV_LOCKSCOPE_LOCAL)
#define DAV_RECURSIVE_LOCK		0x00800000
#define DAV_LOCK_FLAGS			(DAV_LOCKTYPE_FLAGS | DAV_RECURSIVE_LOCK | DAV_LOCKSCOPE_FLAGS)

/*
 -	IFITER
 -
 *
 *	This is the parser copied from the original IF header processor
 *	used in lockutil.cpp. Eventually lockutil.cpp shall use this
 *	file since this file shall have only the common stuff sharable
 *	between davex and davfs lock code.
 *
 *	Comment format change to the style used in this file otherwise.
 *
 *
 */
//	========================================================================
//
//	class IFITER
//
//		Built to parse the new If header.
//
//	Format of the If header
//		If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
//		No-tag-list = List
//		Tagged-list = Resource 1*List
//		Resource = Coded-url
//		List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
//		State-token = Coded-url
//		Coded-url = "<" URI ">"
//
//
//		NOTE: We are going to be lax about tagged/untagged lists.
//		If the first list is not tagged, but we find tagged lists later,
//		that's cool by me.
//		(Realize that there no problem switching from tagged to untagged --
//		because that case cannot be detected & distinguished from another
//		list for the same URI!  The only problem is if the first list is
//		untagged, and later there are tagged lists.  That is a case that
//		*should*, by a perfectly tight reading of the spec, be a bad request.
//		I am treating it as perfectly valid until someone tells me that I have
//		to do the extra 1 bit of bookkeeping.)
//
//	State machine for this class
//		It's a really simple state machine.
//		(NOTE that I'm calling statetokens and etags "tokens", and the
//		contents of a single set of parentheses a "list", just like above.)
//
//		Three possible states: NONE, NAME, and LIST.
//		Starts in state NONE -- can accept a tag (URI) or a start of a list.
//		Moves to NAME if a tag (URI) is encountered.
//		Only a list can follow a tag (URI).
//		Moves to LIST when a list start (left paren) is encountered.
//		Moves back to NONE when a list end (right paren) is encountered.
//

//	------------------------------------------------------------------------
//	enum FETCH_TOKEN_TYPE
//		These are the flags used in IFITER::PszNextToken.
//		There are two basic types of fetching:
//		o	advance to next item of this type (xxx_NEW_xxx)
//		o	fetch the next item & fail if the type does not match.
//
enum FETCH_TOKEN_TYPE
{
	TOKEN_URI,			// Fetch a URI, don't skip anything.
	TOKEN_NEW_URI,		// Advance to the next URI, skipping stuff in between.
	TOKEN_START_LIST,	// Fetch the next list item.  Must be the starting list item.
	TOKEN_SAME_LIST,	// Fetch the next internal item in this list.
	TOKEN_NEW_LIST,		// Advance to the next start of a list, skipping past the
						//	end of the current list if necessary.  Don't skip uris.
	TOKEN_ANY_LIST,		// NTRaid#244243 -- special for looking up locktokens
						//	Fetch the next item for this same uri -- can cross lists,
						//	but not uris.
	TOKEN_NONE,			// Empty marker.
};

class IFITER
{
private:

	enum STATE_TYPE
	{
		STATE_NONE,
		STATE_NAME,
		STATE_LIST,
	};

	const LPCWSTR		m_pwszHdr;
	LPCWSTR				m_pwch;
	StringBuffer<WCHAR>	m_buf;
	//	State bits
	STATE_TYPE			m_state;
	BOOL				m_fCurrentNot;

	//  NOT IMPLEMENTED
	//
	IFITER& operator=( const IFITER& );
	IFITER( const IFITER& );

public:

	IFITER (LPCWSTR pwsz=0) :
			m_pwszHdr(pwsz),
			m_pwch(pwsz),
			m_state(STATE_NONE),
			m_fCurrentNot(FALSE)
	{
	}
	~IFITER() {}


	LPCWSTR PszNextToken (FETCH_TOKEN_TYPE type);
	BOOL FCurrentNot() const
	{
		return m_fCurrentNot;
	}
	void Restart()
	{
		m_pwch = m_pwszHdr; m_state = STATE_NONE;
	}
};

/*
 -	PwszSkipCodes
 -
 *	Remove <> or [] tags around stuff. Useful for if: header
 *	tags. also eliminates the LWS near to the delimiters.
 *
 *	*pdwLen may be zero or the length of the string. If zero
 *	the routine calculate the length using strlen. Wasteful,
 *	if you already know the length.
 *
 *	Returns the pointer to the first non-lws, non-delimiter.
 *	dwLen shall be set to the actual number of chars, from the
 *	first to the last char which is non-lws, non-delimiter when
 *	we start looking from the end. Does not stick the null char
 *	at the end. Do it yourself, if you need to, using dwLen.
 *
 */

LPCWSTR  PwszSkipCodes(IN LPCWSTR pwszTagged, IN OUT DWORD *pdwLen);


/*
 -	CStateToken
 -
 *	The state token is the lean string that we use to communicate
 *	with the client. It is the external representation of a DAV lock
 *	or any other kind of state information.
 *
 *	State token is a quoted uri which is <uri> for the external world.
 *	So we provide facilities to deal with this in this class. The < and
 *	> are not useful for internal processing - so we hide this to our
 *	customers - this will avoid copying to prepend the <.
 *
 *	E-TAGs are special beasts and are just plain quoted strings surrounded
 *	by [ and ].
 *
 */

class CStateToken
{
	
public:
	
	//	Common defintions which are public, also used privately!
	//
	typedef enum StateTokenType
	{
		TOKEN_NONE = 0,
		TOKEN_LOCK,
		TOKEN_TRANS,
		TOKEN_ETAG,
		TOKEN_RESTAG,
					  
	} STATE_TOKEN_TYPE;

	//	normally state tokens are about of this size
	//	ie lock tokens.
	//
	enum { NORMAL_STATE_TOKEN_SIZE = 128 };

private:
	
	//	Token buffer
	//
	LPWSTR m_pwszToken;

	//	Allocated size of the current buffer.
	//
	DWORD m_cchBuf;

	//	type of the token
	//
	STATE_TOKEN_TYPE m_tType;
	
	//	Never implemented
	//
	CStateToken( const CStateToken& );
	CStateToken& operator=( const CStateToken& );
	
public:

	CStateToken() : m_pwszToken(NULL), m_cchBuf(0), m_tType(TOKEN_NONE)
    {
    };

	~CStateToken()
    {
        if (NULL != m_pwszToken)
            ExFree(m_pwszToken);
    }

	//	Plain token accepted here.
	//	If the dwLen is zero, NULL terminated pszToken
	//	is the token. If non zero, it gives actual
	//	number of chars in the token.
	//	Useful when we parse the if: header.
	//
	BOOL FSetToken(LPCWSTR pwszToken, BOOL fEtag, DWORD dwLen = 0);
			
	//	Accessors to the token info
	//
	inline STATE_TOKEN_TYPE	GetTokenType() const { return m_tType; }

	//	TRUE if the lock tokens are equal.
	//
	BOOL FIsEqual(CStateToken *pstokRhs);

	//	get a pointer to the token string
	//
	inline LPCWSTR WszGetToken() const { return m_pwszToken; }

	//	Parses the state token as a lock token and
	//	get the lock token information.. Note that our lock
	//	tokens consist of a GUIID and a long long(int64).
	//	The guid string must be long enough to hold a GUID
	//	string (37 chars).
	//
	BOOL FGetLockTokenInfo(unsigned __int64 *pi64SeqNum, LPWSTR	pwszGuid);
};


/*
 -	CStateMatchOp
 -
 *	This class is used as the base class for doing
 *	state  match operations including e-tag
 *	checks. Each implementation shall derive its own
 *	ways to check the state of the resource. This way
 *	the core parse code is shared between subsystems.
 *
 *	Not multi-thread safe - create,use and delete in a
 *	single thread.
 *
 */

class CStateMatchOp
{
private:

	//	NOT IMPLEMENTED
	//
	CStateMatchOp( const CStateMatchOp& );
	CStateMatchOp& operator=( const CStateMatchOp& );

protected:

	//	Current token under investigation.
	//	All derived classes can access it.
	//	We do not pass this as the parameter.
	//
	CStateToken	m_tokCurrent;

	friend class CIfHeadParser;
	
	//	---------------------------------------------------------
	//	support API for the ifheader parser
	//	set the current token
	//
	inline BOOL FSetToken(LPCWSTR pwszToken, BOOL fEtag)
	{
		return m_tokCurrent.FSetToken(pwszToken, fEtag);
	}
	//	get the current token type
	//
	inline CStateToken::STATE_TOKEN_TYPE GetTokenType() const
	{
		return m_tokCurrent.GetTokenType();
	}
	//	return the storage path of the uri. Note that davex and davfs
	//	has different implementations of this.
	//
	virtual SCODE ScGetResourcePath(LPCWSTR pwszUri, LPCWSTR * ppwszStoragePath) = 0;

	//	check if the resource is locked by the lock specified
	//	by the current lock token above. fRecusrive says if the
	//	condition is to be applied to all the resources under the
	//	given path. Believe me, lpwszPath can be NULL. And it is
	//	NULL when the match condition is to be applied on the
	//	first path given to HrApplyIf!. Why we do this: normally
	//	we do lotsa processing on the method's resource before
	//	we call the if-header parser. This processing generates
	//	info like e-tags which can be used to do the state match
	//	check here. So the parser needs to tell the match checker
	//	that this is for the original uri and NULL is the indication
	//	of that.
	//
	virtual SCODE ScMatchLockToken(LPCWSTR pwszPath, BOOL fRecursive) = 0;
	virtual SCODE ScMatchResTag(LPCWSTR pwszPath) = 0;
	virtual SCODE ScMatchTransactionToken(LPCWSTR pwszPath) = 0;

	//	Checks if the resource is in the state specified by the
	//	(e-tag) state token above. Parameters have same meaning as above.
	//
	virtual SCODE ScMatchETag(LPCWSTR pwszPath, BOOL fRecursive) = 0;
	//	-----------------------------------------------------------

public:

	//	Usual suspects of CTOR and DTOR
	//
	CStateMatchOp() { };

	~CStateMatchOp() { };

	//	Using this object as the match operator parse an if header.
	//	This is used by all method impls.
	//
	SCODE ScParseIf(LPCWSTR pwszIfHeader, LPCWSTR rgpwszPaths[], DWORD cPaths, BOOL fRecur, SCODE * pSC);
};

/*
 -	FCompareSids
 -
 *	compare two sids
 *
 */
inline BOOL FCompareSids(PSID pSidLeft, PSID pSidRight)
{
	if ((NULL == pSidLeft) || (NULL == pSidRight))
		return FALSE;

	//	Assert the SID validity.
	//
	Assert(IsValidSid(pSidLeft));
	Assert(IsValidSid(pSidRight));

	return EqualSid(pSidLeft, pSidRight);
}

/*
 -	FSeparator
 -
 *  returns true if input is a path separator - used below
 *
 */

inline BOOL FSeparator(WCHAR wch)
{
   return ((wch == L'\\') || (wch == L'/'));
}

/*
 -	FIsChildPath
 -
 *	compare two paths to check if the child is within the scope
 *	of the parent.
 *
 *	For non recursive match, the two paths must match exactly for
 *	TRUE return. This is useful when tagged URIs within the IF header
 *	is processed and we have a deep operation going on. The other place
 *	this function is used is when we have a recursive lock and need to
 *	find out if a path is locked by this lock.
 *
 */
inline BOOL FIsChildPath(LPCWSTR pwszPathParent, LPCWSTR pwszPathChild, BOOL fRecursive)
{
	UINT	cchParentLen;

	if ((NULL == pwszPathParent) || (NULL == pwszPathChild))
		return FALSE;

	cchParentLen = static_cast<UINT>(wcslen(pwszPathParent));

	//	If the parent path is not an initial substring
	//	of child return fail immediately.
	//
	if ( 0 != _wcsnicmp(pwszPathChild, pwszPathParent, cchParentLen) )
	{
		return FALSE;
	}

	//	Parent indeed is the initial substring.
	//	Check the next char of child (for NULL) to see
	//	if they	match exactly. This is an instand good condition.
	//
	if (L'\0' == pwszPathChild[cchParentLen])
	{
		return TRUE;
	}
	//	We still have hope for a match ONLY for recursive checks.
	//
	if (! fRecursive)
	{
		return FALSE;
	}
	else
	{
		//	either parent or child need to have a separator
		//
		if ( FSeparator(pwszPathParent[cchParentLen-1]) ||
			 FSeparator(pwszPathChild[cchParentLen]) )
			 return TRUE;
		else
			 return FALSE;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\synchro.h ===
#ifndef _SYNCHRO_H_
#define _SYNCHRO_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.H
//
//		Header for DAV synchronization classes.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifdef _EXDAV_
#error "synchro.h: CInitGate can throw() -- not safe for EXDAV"
#endif

//	Include common EXDAV-safe synchronization items
#include <ex\stackbuf.h>
#include <ex\synchro.h>

#include <stdio.h>		// for swprintf()
#include <except.h>		// Exception throwing/handling


//	========================================================================
//
//	CLASS CInitGate
//
//	(The name of this class is purely historical)
//
//	Encapsulates ONE-SHOT initialization of a globally NAMED object.
//
//	Use to handle simultaneous on-demand initialization of named
//	per-process global objects.  For on-demand initialization of
//	unnamed per-process global objects, use the templates in singlton.h.
//
class CInitGate
{
	CEvent m_evt;
	BOOL m_fInit;

	//  NOT IMPLEMENTED
	//
	CInitGate& operator=( const CInitGate& );
	CInitGate( const CInitGate& );

public:

	CInitGate( LPCWSTR lpwszBaseName,
			   LPCSTR  lpszName ) :

		m_fInit(FALSE)
	{
		//
		//	First, set up an empty security descriptor and attributes
		//	so that the event can be created with no security
		//	(i.e. accessible from any security context).
		//
		SECURITY_DESCRIPTOR sdAllAccess;

		(void) InitializeSecurityDescriptor( &sdAllAccess, SECURITY_DESCRIPTOR_REVISION );
		SetSecurityDescriptorDacl( &sdAllAccess, TRUE, NULL, FALSE );

		SECURITY_ATTRIBUTES saAllAccess;

		saAllAccess.nLength              = sizeof(saAllAccess);
		saAllAccess.lpSecurityDescriptor = &sdAllAccess;
		saAllAccess.bInheritHandle       = FALSE;

		CStackBuffer<WCHAR,256> lpwszEventName;
		if (NULL == lpwszEventName.resize(sizeof(WCHAR) *
										  (wcslen(lpwszBaseName) +
										   strlen(lpszName) +
										   sizeof('\0'))))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			throw CLastErrorException();
		}

		swprintf(lpwszEventName.get(), L"%ls%hs", lpwszBaseName, lpszName);
		if ( !m_evt.FCreate( lpszName,
							 &saAllAccess,  // no security
							 TRUE,  // manual reset
							 FALSE, // initially non-signalled
							 lpwszEventName.get()))
		{
			throw CLastErrorException();
		}

		if ( ERROR_ALREADY_EXISTS == GetLastError() )
			m_evt.Wait();
		else
			m_fInit = TRUE;
	}

	~CInitGate()
	{
		if ( m_fInit )
			m_evt.Set();
	}

	BOOL FInit() const { return m_fInit; }
};

#endif // !defined(_SYNCHRO_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\sz.h ===
/*
 *	S Z . H
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SZ_H_
#define _SZ_H_

#include <szsrc.h>
#include <statcode.h>

//	Impl Signature string ------------------------------------------------------
//	Provided by impl.  Used in various parser (_davprs) functions.
//	NOTE: This declaration is designed to match the signature in calrc.h.
//
extern const CHAR gc_szSignature[];		//	provided by impl.

//	Path Prefix ----------------------------------------------------------------
//	Provided by impl.  Used in default URI-to-Path translation code.
//
extern const WCHAR gc_wszPathPrefix[];
extern const int gc_cchPathPrefix;

//	String constants ----------------------------------------------------------
//	String constants live in \inc\ex\sz.h, so that they may be shared
//	with our Exchange components.
//
#include <ex\sz.h>

#endif	// _SZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\util.h ===
/*
 *	U T I L . H
 *
 *	Common DAV utilities
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _UTIL_H_
#define _UTIL_H_

#include <autoptr.h>
#include <buffer.h>
#include <davimpl.h>
#include <ex\hdriter.h>

enum { MAX_LOCKTOKEN_LENGTH = 256 };

//	Function to generate a separator boundary for multipart responses.
//
VOID
GenerateBoundary(LPWSTR rgwchBoundary, UINT cch);

//	Alphabet allowed for multipart boundaries
const ULONG	gc_ulDefaultBoundarySz = 70;
const ULONG gc_ulAlphabetSz = 74;
const WCHAR gc_wszBoundaryAlphabet[] =
	L"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'()+_,-./:=?";
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\szsrc.h ===
/*
 *	S Z S R C . H
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_SZSRC_H_
#define _SZSRC_H_

//	Include CAL common defines ('cause they used to live in this file!)
#include <ex\calcom.h>

//	Localized string lookup ---------------------------------------------------
//
class safe_lcid
{
	LONG		m_lcid;

	//	NOT IMPLEMENTED
	//
	safe_lcid(const safe_lcid& b);
	safe_lcid& operator=(const safe_lcid& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_lcid (LONG lcid = LOCALE_SYSTEM_DEFAULT)
		: m_lcid(GetThreadLocale())
	{
		SetThreadLocale (lcid);
	}
	~safe_lcid ()
	{
		SetThreadLocale (m_lcid);
	}
};


//	Localized string fetching -------------------------------------------------
//
BOOL FLookupLCID (LPCSTR psz, ULONG * plcid);
ULONG LcidAccepted (LPCSTR psz);
LPSTR LpszAutoDupSz (LPCSTR psz);
LPWSTR WszDupWsz (LPCWSTR psz);
BOOL FInitResourceStringCache();
VOID DeinitResourceStringCache();
LPSTR LpszLoadString (
		UINT		uiResourceID,
		ULONG		lcid,
		LPSTR		lpszBuf,
		INT			cchBuf );
LPWSTR LpwszLoadString (
		UINT		uiResourceID,
		ULONG		lcid,
		LPWSTR		lpwszBuf,
		INT			cchBuf);

//	Service instance (otherwise referred as server ID)
//	parsing out of virtual root
//
LONG LInstFromVroot( LPCSTR lpszServerId );

#endif // _SZSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\thrdpool.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.h
//
//  Contents:    definitions needed for clients of the thrdpool lib
//
//	Description: The thrdpool library defines the CWorkerThread base class
//				 Users of this lib should define their own derived class
//				 that inherits from CWorkerThread. Each CWorkerThread object
//				 has a thread that is used to do some work. It is also
//				 associated with a common completion port that is used to
//				 queue work items. All worker threads will normally block on
//				 GetQueuedCompletionStatus(). Clients of the CWorkerThread
//				 objects will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will
//				 reduce context switches.
//
//  Functions:
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//				 11/11/97	  Adapted for DAV usage
//
//-----------------------------------------------------------------------------

#ifndef _THRDPOOL_H_
#define _THRDPOOL_H_

#include <autoptr.h>
#include <singlton.h>

//	CPoolManager --------------------------------------------------------------
//
class CDavWorkContext;
class CDavWorkerThread;
class CPoolManager : private Singleton<CPoolManager>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CPoolManager>;

private:

	//	Completion port for WorkerThreads
	//
	auto_handle<HANDLE> m_hCompletionPort;

	//	Array of worker threads
	//
	enum { CTHRD_WORKER = 5 };
	CDavWorkerThread *		m_rgpdwthrd[CTHRD_WORKER];

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CPoolManager() {}
	~CPoolManager();

	BOOL FInitPool(DWORD dwConcurrency = CTHRD_WORKER);
	VOID TerminateWorkers();

	//	NOT IMPLEMENTED
	//
	CPoolManager(const CPoolManager& x);
	CPoolManager& operator=(const CPoolManager& x);

public:

	//	STATICS
	//
	static BOOL FInit()
	{
		if ( CreateInstance().FInitPool() )
			return TRUE;

		DestroyInstance();
		return FALSE;
	}

	static VOID Deinit()
	{
		DestroyInstance();
	}

	static BOOL PostWork (CDavWorkContext * pwc);

	static BOOL PostDelayedWork (CDavWorkContext * pwc,
								 DWORD dwMsecDelay);

	static HANDLE GetIOCPHandle()
	{
		return Instance().m_hCompletionPort.get();
	}
};

//	CDavWorkContext --------------------------------------------------------------
//
//	Work context base class for work items posted to the thread pool.
//
//	Note: this class is NOT refcounted.  Lifetime of work items is determined
//	external to the thread pool mechanism.  In particular, if a particular
//	derived work item class needs to have an indefinite lifetime, it is up
//	to the derived class to provide that functionality.  E.g. a derived work
//	item can have a refcount.  Code that posts the work item would then
//	add a reference before posting and release the reference (possibly destroying
//	the object if is the last ref) in its DwDoWork() call.
//
//	The reason for this is that not ALL work items may be refcounted.
//	In fact, some may be static....
//
class CDavWorkContext
{
private:

	//	NOT IMPLEMENTED
	//
	CDavWorkContext(const CDavWorkContext& x);
	CDavWorkContext& operator=(const CDavWorkContext& x);

	DWORD        m_cbTransferred;
	DWORD		 m_dwLastError;
	LPOVERLAPPED m_po;
public:

	CDavWorkContext() :
		m_cbTransferred(0),
		m_dwLastError(ERROR_SUCCESS),
		m_po(NULL)
	{
	}
	virtual ~CDavWorkContext() = 0;
	virtual DWORD DwDoWork () = 0;

	void SetCompletionStatusData(DWORD        cbTransferred,
								 DWORD		  dwLastError,
								 LPOVERLAPPED po)
	{
		m_cbTransferred = cbTransferred;
		m_dwLastError = dwLastError;
		m_po = po;
	}
	DWORD CbTransferred() const { return m_cbTransferred; }
	DWORD DwLastError() const { return m_dwLastError; }
	LPOVERLAPPED GetOverlapped() const { return m_po; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\url.h ===
/*
 *	U R L . H
 *
 *	Url normalization/canonicalization
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_URL_H_
#define _URL_H_

//	ACP Language vs. DBCS -----------------------------------------------------
//
//	ACP Language vs. DBCS -----------------------------------------------------
//
//	FIsSystemDBCS()
//
typedef enum {

	DBCS_UNKNOWN = 0,
	DBCS_NO,
	DBCS_YES

} LANG_DBCS;
DEC_GLOBAL LANG_DBCS gs_dbcs = DBCS_UNKNOWN;

inline BOOL
FIsSystemDBCS()
{
	if (DBCS_UNKNOWN == gs_dbcs)
	{
		UINT uPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());
		if ((uPrimaryLangID == LANG_JAPANESE) ||
			(uPrimaryLangID == LANG_CHINESE)  ||
			(uPrimaryLangID == LANG_KOREAN))
		{
			gs_dbcs = DBCS_YES;
		}
		else
			gs_dbcs = DBCS_NO;
	}

	return (DBCS_YES == gs_dbcs);
}

inline BOOL
FIsDBCSTrailingByte (const CHAR * pch, LONG cch)
{
	//	Checks to see if the previous byte of the pointed to character is
	//	a lead byte if and only if there is characters preceeding and the
	//	system is DBCS.
	//
	Assert (pch);
	return ((0 < cch) && FIsSystemDBCS() && IsDBCSLeadByte(*(pch - 1)));
}

inline BOOL
FIsDriveTrailingChar(const CHAR * pch, LONG cch)
{
	//	Checks if the character we are pointing at stands after the drive letter
	//
	Assert(pch);
	return ((2 < cch) && (':' == *(pch - 1)) &&
			((('a' <= *(pch - 2)) && ('z' >= *(pch - 2))) ||
			 (('A' <= *(pch - 2)) && ('Z' >= *(pch - 2)))));
}

inline BOOL
FIsDriveTrailingChar(const WCHAR * pwch, LONG cch)
{
	//	Checks if the character we are pointing at stands after the drive letter
	//
	Assert(pwch);
	return ((2 < cch) && (L':' == *(pwch - 1)) &&
			(((L'a' <= *(pwch - 2)) && (L'z' >= *(pwch - 2))) ||
			 ((L'A' <= *(pwch - 2)) && (L'Z' >= *(pwch - 2)))));
}

//	Processing ----------------------------------------------------------------
//
SCODE __fastcall
ScStripAndCheckHttpPrefix (
	/* [in] */ const IEcb& ecb,
	/* [in/out] */ LPCWSTR * ppwszRequest);

LPCWSTR __fastcall
PwszUrlStrippedOfPrefix (
	/* [in] */ LPCWSTR pwszUrl);

VOID __fastcall HttpUriEscape (
	/* [in] */ LPCSTR pszSrc,
	/* [out] */ auto_heap_ptr<CHAR>& pszDst);

VOID __fastcall HttpUriUnescape (
	/* [in] */ const LPCSTR pszUrl,
	/* [out] */ LPSTR pszUnescaped);

//	Path conflicts ------------------------------------------------------------
//
BOOL __fastcall FPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszDst);

BOOL __fastcall FSizedPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ UINT cchSrc,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ UINT cchDst);

BOOL __fastcall FIsImmediateParentUrl (
	/* [in] */ LPCWSTR pwszParent,
	/* [in] */ LPCWSTR pwszChild);

SCODE __fastcall
ScConstructRedirectUrl (
	/* [in] */ const IEcb& ecb,
	/* [in] */ BOOL fNeedSlash,
	/* [out] */ LPSTR * ppszUrl,
	/* [in] */ LPCWSTR pwszServer = NULL);


#endif // _URL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xatom.h ===
/*
 *	X A T O M . H
 *
 *	XML atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XATOM_H_
#define _XATOM_H_

#include <ex\atomcache.h>

#endif	// _XATOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\vrenum.h ===
/*
 *	V R E N U M . H
 *
 *	Vritual root enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_VRENUM_H_
#define _VRENUM_H_

#include <winsock2.h>

#include <crc.h>
#include <autoptr.h>
#include <buffer.h>
#include <davmb.h>
#include <gencache.h>
#include <cvroot.h>
#include <davimpl.h>
#include <singlton.h>

//	CChildVRCache ---------------------------------------------------------------
//
typedef CCache<CRCWsz, auto_ref_ptr<CVRoot> > CVRCache;

class CChildVRCache : public CAccInv,
					  private Singleton<CChildVRCache>
{
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CChildVRCache>;

	//	Cache
	//
	CVRCache m_cache;
	ChainedStringBuffer<WCHAR> m_sb;

	//	Server default values
	//
	enum { MAX_SERVER_NAME_LENGTH = 64 };
	WCHAR m_wszServerDefault[MAX_SERVER_NAME_LENGTH];
	UINT m_cchServerDefault;

	//	CAccInv access/modification methods
	//
	void RefreshOp(const IEcb& ecb);

	//	CFindChildren ---------------------------------------------------------
	//
	//	Functional classes to find all applicible child vroots
	//
	class CFindChildren : public CVRCache::IOp, public CAccInv::IAccCtx
	{
		CVRCache& m_cache;						//	Cache

		ChainedStringBuffer<WCHAR>& m_sb;		//	Return set of child
		CVRList& m_vrl;							//	virtual roots

		LPCWSTR m_pwsz;							//	Metadata path to find
		UINT m_cch;								//	children for

		//	NOT IMPLEMENTED
		//
		CFindChildren& operator=(const CFindChildren&);
		CFindChildren(const CFindChildren&);

	public:

		CFindChildren(CVRCache& cache,
					  LPCWSTR pwszMetaPath,
					  ChainedStringBuffer<WCHAR>& sb,
					  CVRList& vrl)
			: m_cache(cache),
			  m_sb(sb),
			  m_vrl(vrl),
			  m_pwsz(pwszMetaPath),
			  m_cch(static_cast<UINT>(wcslen(pwszMetaPath)))
		{
		}

		virtual BOOL operator()(const CRCWsz&, const auto_ref_ptr<CVRoot>&);
		virtual void AccessOp (CAccInv& cache)
		{
			m_cache.ForEach(*this);
		}

		BOOL FFound() const { return !m_vrl.empty(); }
	};

	//	CLookupChild ----------------------------------------------------------
	//
	//	Functional classes to find a given child vroot
	//
	class CLookupChild : public CAccInv::IAccCtx
	{
		CVRCache& m_cache;						//	Cache

		LPCWSTR m_pwsz;							//	Metadata path to lookup

		auto_ref_ptr<CVRoot>& m_cvr;			//	CVRoot for path

		//	NOT IMPLEMENTED
		//
		CLookupChild& operator=(const CLookupChild&);
		CLookupChild(const CLookupChild&);

	public:

		CLookupChild(CVRCache& cache,
					 LPCWSTR pwszMetaPath,
					 auto_ref_ptr<CVRoot>& cvr)
			: m_cache(cache),
			  m_pwsz(pwszMetaPath),
			  m_cvr(cvr)
		{
		}

		virtual void AccessOp (CAccInv& cache)
		{
			m_cache.FFetch(CRCWsz(m_pwsz), &m_cvr);
		}

		BOOL FFound() const { return m_cvr.get() != NULL; }
	};

	//	NOT IMPLEMENTED
	//
	CChildVRCache& operator=(const CChildVRCache&);
	CChildVRCache(const CChildVRCache&);

	//	Cache construction
	//
	SCODE ScCacheVroots (const IEcb& ecb);

	//	CONSTRUCTOR
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton template
	//	(declared as a friend above) controls the sole instance
	//	of this class.
	//
	CChildVRCache()
	{
		CHAR rgchServerDefault[MAX_SERVER_NAME_LENGTH];
		UINT cbServerDefault;

		//	Call the WinSock api to learn our default host name
		//
		gethostname (rgchServerDefault, sizeof(rgchServerDefault));
		cbServerDefault = static_cast<UINT>(strlen(rgchServerDefault));

		//	It actually does not mater what codepage we will
		//	select for conversion. Server names are not allowed
		//	to contain funky characters.
		//
		m_cchServerDefault = MultiByteToWideChar(CP_ACP,
												 0,
												 rgchServerDefault,
												 cbServerDefault + 1,
												 m_wszServerDefault,
												 MAX_SERVER_NAME_LENGTH);

		//	There is no reason to fail and we would be converting at least
		//	termination character
		//
		Assert(1 <= m_cchServerDefault);
		m_cchServerDefault--;

		DebugTrace ("Dav: CVRoot: gethostname(): '%S'\n", m_wszServerDefault);

		//	If this fails, our allocators will throw for us.
		//
		(void) m_cache.FInit();
	}

public:

	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CChildVRCache>::CreateInstance;
	using Singleton<CChildVRCache>::DestroyInstance;
	using Singleton<CChildVRCache>::Instance;

	//	Metabase notification methods
	//
	void OnNotify( DWORD dwElements,
				   MD_CHANGE_OBJECT_W pcoList[] );

	//	Access ----------------------------------------------------------------
	//
	static BOOL FFindVroot( const IEcb& ecb, LPCWSTR pwszMetaPath, auto_ref_ptr<CVRoot>& cvr )
	{
		CLookupChild clc(Instance().m_cache, pwszMetaPath, cvr);
		Instance().Access(ecb, clc);
		return clc.FFound();
	}

	static SCODE ScFindChildren( const IEcb& ecb,
								 LPCWSTR pwszMetaPath,
								 ChainedStringBuffer<WCHAR>& sb,
								 CVRList& vrl )
	{
		CFindChildren cfc(Instance().m_cache, pwszMetaPath, sb, vrl);
		Instance().Access(ecb, cfc);
		return cfc.FFound() ? S_FALSE : S_OK;
	}
};

#endif	// _VRENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xemit.h ===
/*
 *	X E M I T . H
 *
 *	XML emitting
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XEMIT_H_
#define _XEMIT_H_

#include <ex\xemit.h>

#include <cvroot.h>
#include <davimpl.h>

//	CXMLEmitter helper functions ----------------------------------------------
//
SCODE ScGetPropNode (
	/* [in] */ CEmitterNode& enItem,
	/* [in] */ ULONG hsc,
	/* [out] */ CEmitterNode& enPropStat,
	/* [out] */ CEmitterNode& enProp);

//	CXNode helper functions ---------------------------------------------------
//
SCODE ScSetEscapedValue (CXNode* pxn, LPCWSTR pwszValue, UINT cch, BOOL fHandleStoraePathEscaping);

SCODE ScEmitRawStoragePathValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch);

//	This wrapper is used to output the HREF props in XML. It assumes that the HREF properties are in
//	the impl's storage path escaped form and calls into the impl defined storage path unescaping
//	routine before doing the http-uri-escape call.
//
//	$WARNING: pwszValue is assumed to the in the storage path escaped form (as in Exchange store escaped
//	$WARNING: form). If not use the above helper to emit the property. Note that this makes a difference
//	$WARNING: only for DAVEx. HTTPEXT and EXPROX have do-nothing storage path escape/unescape callouts.
//
inline SCODE ScSetEscapedValue (CXNode* pxn, LPCWSTR pwszValue)
{
	return ScSetEscapedValue (pxn, pwszValue, static_cast<UINT>(wcslen(pwszValue)), TRUE);
}

//	CEmitterNode helper functions ---------------------------------------------
//
SCODE __fastcall ScAddStatus (CEmitterNode* pen, ULONG hsc);
SCODE __fastcall ScAddError (CEmitterNode* pen, LPCWSTR pwszErrMsg);

//	class CStatusCache ------------------------------------------------------
//
class CStatusCache
{
	class CHsc
	{
	public:

		ULONG m_hsc;
		CHsc(ULONG hsc) : m_hsc(hsc)
		{
		}

		//	operators for use with the hash cache
		//
		int hash( const int rhs ) const
		{
			return (m_hsc % rhs);
		}
		bool isequal( const CHsc& rhs ) const
		{
			return (m_hsc == rhs.m_hsc);
		}
	};

	class CPropNameArray
	{
	private:

		StringBuffer<CHAR>	m_sb;

		//	Ref' counting.
		//
		//	!!! Please note that this is NON-THREADSAFE !!!
		//
		LONG						m_cRef;

		//	non-implemented
		//
		CPropNameArray(const CPropNameArray& p);
		CPropNameArray& operator=(const CPropNameArray& p);

	public:

		CPropNameArray() :
				m_cRef(1)
		{
		}

		VOID AddRef()				{ m_cRef++; }
		VOID Release()				{ if (0 == --m_cRef) delete this; }

		//	Accessors
		//
		UINT CProps ()				{ return m_sb.CbSize() / sizeof (LPCWSTR); }
		LPCWSTR PwszProp (UINT iProp)
		{
			//	Use C-style cast, reinterpret_cast cannot convert LPCSTR to LPCWSTR *
			//
			return *((LPCWSTR *)(m_sb.PContents() + iProp * sizeof(LPCWSTR)));
		}

		SCODE ScAddPropName (LPCWSTR pwszProp)
		{
			UINT cb = sizeof (LPCWSTR);

			//	Store the pointer in the string buffer
			//
			UINT cbAppend = m_sb.Append (cb, reinterpret_cast<LPSTR>(&pwszProp));
			return (cb == cbAppend) ? S_OK : E_OUTOFMEMORY;
		}
	};

	typedef CCache<CHsc, auto_ref_ptr<CPropNameArray> > CPropNameCache;
	CPropNameCache				m_cache;
	ChainedStringBuffer<WCHAR>	m_csbPropNames;

	class EmitStatusNodeOp : public CPropNameCache::IOp
	{
		CEmitterNode&	m_enParent;

		//	NOT IMPLEMENTED
		//
		EmitStatusNodeOp( const EmitStatusNodeOp& );
		EmitStatusNodeOp& operator=( const EmitStatusNodeOp& );

	public:
		EmitStatusNodeOp (CEmitterNode& enParent) :
				m_enParent(enParent)
		{
		}

		BOOL operator()( const CHsc& key,
						 const auto_ref_ptr<CPropNameArray>& pna );
	};

	//	non-implemented
	//
	CStatusCache(const CStatusCache& p);
	CStatusCache& operator=(const CStatusCache& p);

public:

	CStatusCache()
	{
	}

	SCODE	ScInit ()	{ return m_cache.FInit() ? S_OK : E_OUTOFMEMORY ; }
	BOOL	FEmpty ()	{ return m_cache.CItems() == 0; }

	SCODE	ScAddErrorStatus (ULONG hsc, LPCWSTR pwszProp);
	SCODE	ScEmitErrorStatus (CEmitterNode& enParent);
};

//	CEmitterNode construction helpers -----------------------------------------
//
SCODE ScEmitFromVariant (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ CEmitterNode& enParent,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ PROPVARIANT& var);

#endif	// _XEMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xlock.h ===
/*
 *	X L O C K . H
 *
 *	XML push-model parsing for the LOCK method
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XLOCK_H_
#define _XLOCK_H_

#include <buffer.h>
#include <xprs.h>

extern const WCHAR gc_wszLockActive[];
extern const WCHAR gc_wszLockDepth[];
extern const WCHAR gc_wszLockDiscovery[];
extern const WCHAR gc_wszLockEntry[];
extern const WCHAR gc_wszLockInfo[];
extern const WCHAR gc_wszLockOwner[];
extern const WCHAR gc_wszLockScope[];
extern const WCHAR gc_wszLockScopeExclusive[];
extern const WCHAR gc_wszLockScopeShared[];
extern const WCHAR gc_wszLockSupportedlock[];
extern const WCHAR gc_wszLockTimeout[];
extern const WCHAR gc_wszLockToken[];
extern const WCHAR gc_wszLockType[];
extern const WCHAR gc_wszLockTypeWrite[];
extern const WCHAR gc_wszLockTypeCheckout[];
extern const WCHAR gc_wszLockTypeTransaction[];
extern const WCHAR gc_wszLockTypeTransactionGOP[];
extern const WCHAR gc_wszLockScopeLocal[];

extern const WCHAR gc_wszLockRollback[];

//	class CNFLock -------------------------------------------------------------
//
class CNFLock : public CNodeFactory
{
	//	Parsed bits
	//
	DWORD				m_dwLockType;
	DWORD				m_dwScope;
	DWORD				m_dwRollback;

	//	Lock owner
	//
	UINT				m_lOwnerDepth;
	BOOL				m_fAddNamespaceDecl;
	StringBuffer<WCHAR> m_sbOwner;
	CXMLOut				m_xo;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_LOCKINFO,
		ST_OWNER,
		ST_TYPE,
		ST_SCOPE,
		ST_ROLLBACK,
		ST_INTYPE,
		ST_INSCOPE,
		ST_INTYPE_TRANS,
	} LOCK_PARSE_STATE;
	LOCK_PARSE_STATE m_state;

	//	non-implemented
	//
	CNFLock(const CNFLock& p);
	CNFLock& operator=(const CNFLock& p);

public:

	virtual ~CNFLock() {};
	CNFLock() :
			m_dwLockType(0),
			m_dwScope(0),
			m_dwRollback(0),
			m_lOwnerDepth(0),
			m_fAddNamespaceDecl(FALSE),
			m_xo(m_sbOwner),
			m_state(ST_NODOC)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD dwType);

	//	LockMgr Accessors
	//
	DWORD DwGetLockType() const		{ return m_dwLockType; }
	DWORD DwGetLockScope() const	{ return m_dwScope; }
	DWORD DwGetLockRollback() const { return m_dwRollback; }
	DWORD DwGetLockFlags() const
	{
		return m_dwLockType |
				m_dwRollback |
				m_dwScope;
	}

	//	Owner data access
	//
	LPCWSTR PwszLockOwner() const
	{
		return m_sbOwner.CbSize()
				? m_sbOwner.PContents()
				: NULL;
	}
};

//	class CNFUnlock -------------------------------------------------------------
//
class CNFUnlock : public CNodeFactory
{
	auto_heap_ptr<WCHAR> m_wszComment;
	BOOL				m_fCancelCheckout;
	BOOL				m_fAbortTransaction;
	BOOL				m_fCommitTransaction;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_UNLOCKINFO,
		ST_COMMENT,
		ST_CANCELCHECKOUT,
		ST_TRANSACTIONINFO,
		ST_TRANSACTIONSTATUS,
		ST_TRANSACTIONSTATUS_COMMIT,
		ST_TRANSACTIONSTATUS_ABORT
	} LOCK_PARSE_STATE;
	
	LOCK_PARSE_STATE m_state;

	//	non-implemented
	//
	CNFUnlock(const CNFUnlock& p);
	CNFUnlock& operator=(const CNFUnlock& p);

public:

	virtual ~CNFUnlock() {};
	CNFUnlock() :
			m_fCancelCheckout(FALSE),
			m_state(ST_NODOC),
			m_fAbortTransaction(FALSE),
			m_fCommitTransaction(FALSE)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	// Accessors
	//
	BOOL 	FCancelCheckout() const { return m_fCancelCheckout; }
	LPCWSTR PwszUnlockComment() const { return m_wszComment.get(); }
	BOOL	FAbortTransaction() const { return m_fAbortTransaction; }
	BOOL	FCommitTransaction() const { return m_fCommitTransaction; }
};

#endif	// _XLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xsearch.h ===
/*
 *	X S E A R C H . H
 *
 *	XML push-model parsing for METADATA
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XSEARCH_H_
#define _XSEARCH_H_

#include <xprs.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Search);
#define SearchTrace		DO_TRACE(Search)

//	Ranges --------------------------------------------------------------------
//
#include <ex\rgiter.h>

//	CSearchContext ------------------------------------------------------------
//
class CSearchContext
{
	//	non-implemented operators
	//
	CSearchContext( const CSearchContext& );
	CSearchContext& operator=( const CSearchContext& );

public:

	virtual ~CSearchContext() {}
	CSearchContext ()
	{
		INIT_TRACE(Search);
	}

	//	When the parser finds an item that applies to the search, a call is
	//	made such that the context is informed of the desired search.
	//
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL) = 0;

	//	REPL Search interface -------------------------------------------------
	//
	//	Default implementation fails on these items.  All impls that support
	//	this type of search must implement....
	//
	virtual SCODE ScSetCollBlob (LPCWSTR pwszBlob)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
	virtual SCODE ScSetResTagAdds (LPCWSTR pwszResTagAdd)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
	virtual SCODE ScSetReplRequest (BOOL fReplRequest)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}

	//	Range Search interface ------------------------------------------------
	//
	//	Default impl. fails for these items.  All impls that support this type
	//	of search must implement....
	//
	virtual SCODE ScAddRange (UINT uRT, LPCWSTR pwszRange, LONG lCount)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}

	//	'GROUP BY' Expansion --------------------------------------------------
	//
	//	Default impl. fails for these items.  All impls that support this type
	//	of search must implement....
	//
	virtual SCODE ScSetExpansion (DWORD dwExpansion)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
};

//	class CNFSearch -------------------------------------------------------------
//
class CNFSearch : public CNodeFactory
{
	//	The search context
	//
	CSearchContext&				m_csc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_SEARCH,
		ST_QUERY,
		ST_QUERYENTITY,

		//	REPL (DAV Replication) XML nodes
		//
		ST_REPL,
		ST_REPLCOLLBLOB,
		ST_REPLRESTAGLIST,
		ST_REPLRESTAGADD,

		//	Range XML nodes
		//
		ST_RANGE,
		ST_RANGE_TYPE,
		ST_RANGE_ROWS,

		//	Group Expansion
		//
		ST_GROUP_EXPANSION,

	} SEARCH_PARSE_STATE;
	SEARCH_PARSE_STATE			m_state;

	//	Value buffer
	//
	StringBuffer<WCHAR>			m_sb;

	//	Range items
	//
	UINT						m_uRT;
	LONG						m_lcRows;

	//	non-implemented
	//
	CNFSearch(const CNFSearch& p);
	CNFSearch& operator=(const CNFSearch& p);

public:

	virtual ~CNFSearch() {};
	CNFSearch(CSearchContext& csc)
			: m_csc(csc),
			  m_state(ST_NODOC),
			  m_uRT(RANGE_UNKNOWN),
			  m_lcRows(0)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);
};

#include <replpropshack.h>

#endif	// _XSEARCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xprs.h ===
/*
 *	X P R S . H
 *
 *	XML push-model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XPRS_H_
#define _XPRS_H_

#include <ex\xprs.h>

//	class CXMLOut -------------------------------------------------------------
//
//	Contstruction of XML text from parsed input
//
class CXMLOut
{
	StringBuffer<WCHAR>&	m_sb;
	BOOL					m_fElementNeedsClosing;

	UINT					m_lDepth;
	BOOL					m_fAddNamespaceDecl;
	
	VOID CloseElementDecl (
		/* [in] */ BOOL fEmptyNode);

	//	non-implemented
	//
	CXMLOut(const CXMLOut& p);
	CXMLOut& operator=(const CXMLOut& p);

public:

	CXMLOut(StringBuffer<WCHAR>& sb)
			: m_sb(sb),
			  m_fElementNeedsClosing(FALSE),
			  m_fAddNamespaceDecl(FALSE),
			  m_lDepth(0)
	{
	}

	VOID EndAttributesOut (
		/* [in] */ DWORD dwType);

	VOID EndChildrenOut (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	VOID CreateNodeAttrOut (
		/* [in] */ const WCHAR __RPC_FAR *pwszAttr,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	VOID CreateNodeOut(
		/* [in] */ DWORD dwType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	BOOL FAddNamespaceDecl() const { return m_fAddNamespaceDecl; }
	UINT LDepth() const { return m_lDepth; }

	//	When CompleteAttribute here, we have started processing
	//	the out node attributes and all cached namespaces have
	//	been added.
	//
	VOID CompleteAttribute() {m_fAddNamespaceDecl = TRUE; }

	VOID CompleteCreateNode (/* [in] */ DWORD dwType)
	{
		EndAttributesOut (dwType);
	}

	SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);		
};

//	Namespace emitting ----------------------------------------------------
//
class CEmitNmspc : public CNmspcCache::NmspcCache::IOp
{
	CXMLOut&		m_xo;

	//	non-implemented
	//
	CEmitNmspc(const CEmitNmspc& c);
	CEmitNmspc& operator=(const CEmitNmspc&);

public:

	CEmitNmspc(CXMLOut& xo) :
			m_xo(xo)
	{
	}

	virtual BOOL operator()(const CRCWszN&, const auto_ref_ptr<CNmspc>& pns);
};

#endif	// _XPRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\xmeta.h ===
/*
 *	X M E T A . H
 *
 *	XML push-model parsing for METADATA
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XMETA_H_
#define _XMETA_H_

#include <xprs.h>

//	Parsers -------------------------------------------------------------------
//
//	METADATA ------------------------------------------------------------------
//
//	The metadata processing for DAV is all done via the PROPFIND and PROPPATCH
//	(and to some extent, SEARCH) methods.  In all of these cases, there is an
//	xml request that must be parsed to determine the state of type of request
//	being made.  Once known, the request is applied to the resource and/or its
//	children.  The response is generated and emitted back to the client.
//
//	In some cases, the client may ask for the operation to be carried out for
//	a resource and for each of its children.  In this scenario, we do not want
//	to reprocess the request for each resource, etc.
//
//	In an effort to make this code simple, and extendable to each individual
//	DAV implementation, the processing uses four classes:
//
//		a parsing class
//		a class describing the parsed context
//		a class that provides access to the properties
//		and a class that is used to generate the response
//
//	Both the parser and emitter classes are common across all DAV impls. While
//	the context and the property access are provided by the impl.
//

//	CFindContext/CPatchContext ------------------------------------------------
//
//	The context for a PROPFIND and a PROPGET are not expected to be the same,
//	and as such can be implemented as different objects.
//
class CFindContext
{
	//	non-implemented operators
	//
	CFindContext( const CFindContext& );
	CFindContext& operator=( const CFindContext& );

protected:

	typedef enum {

		FIND_NONE,
		FIND_SPECIFIC,
		FIND_ALL,
		FIND_NAMES,
		FIND_ALL_FULL,
		FIND_NAMES_FULL

	} FINDTYPE;
	FINDTYPE				m_ft;

public:

	CFindContext()
			: m_ft(FIND_NONE)
	{
	}
	virtual ~CFindContext() {}

	//	When the parser finds an item that the client wants returned,
	//	the item is added to the context via the following set context
	//	methods.  Each add is qualified by the resource on which the
	//	request is made. Some propfind requests support editing of the
	//	proplists: for example DAVEX implementation supports full-fidelity
	//	retrieval with certain properties added or deleted from the response
	//	that would have normally returned by the request. The BOOL flag is
	//	used to indicate whether the prop needs to be excluded.
	//
	virtual SCODE ScAddProp(LPCWSTR pwszPath, LPCWSTR pwszProp, BOOL fExcludeProp) = 0;

	//	defines for readability for the BOOL fExcludeProp param above.
	//
	enum {
		FIND_PROPLIST_INCLUDE = FALSE,
		FIND_PROPLIST_EXCLUDE = TRUE
	};

	virtual SCODE ScGetAllProps(LPCWSTR)
	{
		//	If we have already specified a find method, and the
		//	xml indicated another type was expected, then BTS
		//	(by the spec) this should consititute an error.
		//
		if (m_ft != FIND_NONE)
		{
			DebugTrace ("Dav: multiple PROPFIND types indicated\n");
			return E_DAV_PROPFIND_TYPE_UNEXPECTED;
		}
		m_ft = FIND_ALL;
		return S_OK;
	}
	virtual SCODE ScGetAllNames (LPCWSTR)
	{
		//	If we have already specified a find method, and the
		//	xml indicated another type was expected, then BTS
		//	(by the spec) this should consititute an error.
		//
		if (m_ft != FIND_NONE)
		{
			DebugTrace ("Dav: multiple PROPFIND types indicated\n");
			return E_DAV_PROPFIND_TYPE_UNEXPECTED;
		}
		m_ft = FIND_NAMES;
		return S_OK;
	}
	virtual SCODE ScGetFullFidelityProps ()
	{
		//	If we have full fidelity node (it is a child node of
		//	allprop or propname node) then we should allready
		//	be in the state of FIND_ALL or FIND_NAMES. Do not
		//	shift to full fidelity lookup, let the deriving classes
		//	decide if they need that.
		//
		Assert((FIND_ALL == m_ft) || (FIND_NAMES == m_ft));
		return S_OK;
	}

	//$REVIEW: Make the default behavior of the following methods
	//$REVIEW: to ignore the report tags. it's up to the impl which understands
	//$REVIEW: reports to overwrite these methods
	//
	virtual SCODE	ScEnumReport () { return S_OK; }
	virtual SCODE	ScSetReportName (ULONG ulLen, LPCWSTR pwszName)	{ return S_OK;	}
	virtual SCODE	ScSetReportLimit (ULONG ulLen, LPCWSTR pwszLimit) {	return S_OK; }
};

class CPatchContext
{
	//	non-implemented operators
	//
	CPatchContext( const CPatchContext& );
	CPatchContext& operator=( const CPatchContext& );

public:

	CPatchContext() {}
	virtual ~CPatchContext() {}

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScDeleteProp(LPCWSTR pwszPath, LPCWSTR pwszProp) = 0;
	virtual SCODE ScSetProp(LPCWSTR pwszPath,
							LPCWSTR pwszProp,
							auto_ref_ptr<CPropContext>& pPropCtx) = 0;

	//  If parser finds a resourcetype prop set request, we use this function
	//  to set correct behavior
	//
	virtual void SetCreateStructureddocument(void) {};
};

//	class CNFFind -------------------------------------------------------------
//
class CNFFind : public CNodeFactory
{

protected:

	//	The find context
	//
	CFindContext&				m_cfc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_PROPFIND,
		ST_ALLPROP,
		ST_ALLNAMES,
		ST_PROPS,
		ST_INPROP,
		ST_ENUMREPORT,
		ST_INENUMREPORT,
		ST_ENUMLIMIT,
		ST_ALLPROPFULL,
		ST_ALLNAMESFULL,
		ST_ALLPROP_INCLUDE,
		ST_ALLPROP_INCLUDE_INPROP,
		ST_ALLPROP_EXCLUDE,
		ST_ALLPROP_EXCLUDE_INPROP

	} FIND_PARSE_STATE;
	FIND_PARSE_STATE			m_state;

private:

	//	non-implemented
	//
	CNFFind(const CNFFind& p);
	CNFFind& operator=(const CNFFind& p);

public:

	virtual ~CNFFind() {};
	CNFFind(CFindContext& cfc)
			: m_cfc(cfc),
			  m_state(ST_NODOC)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);
};

//	class CNFFind -------------------------------------------------------------
//
class CNFPatch : public CNodeFactory
{

protected:

	//	The patch context
	//
	CPatchContext&				m_cpc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_UPDATE,
		ST_SET,
		ST_DELETE,
		ST_PROPS,
		ST_INPROP,
		ST_INMVPROP,
		ST_SEARCHREQUEST,
		ST_RESOURCETYPE,
		ST_STRUCTUREDDOCUMENT,
		ST_LEXTYPE,
		ST_FLAGS

	} PATCH_PARSE_STATE;
	PATCH_PARSE_STATE			m_state;

	//	XML value echoing to m_xo object
	//
	typedef enum {

		VE_NOECHO,
		VE_NEEDNS,
		VE_INPROGRESS

	} PATCH_VALUE_ECHO;
	PATCH_VALUE_ECHO			m_vestate;

	//	Check if an element we are setting
	//	if an XML valued property
	//
	BOOL	FValueIsXML( const WCHAR *pwcTag );

private:

	//	Current property context
	//
	//	Property context is only used in property set and it is NULL
	//	when the prop to set is a reserved property
	//
	PATCH_PARSE_STATE			m_sType;
	auto_ref_ptr<CPropContext>	m_ppctx;

	//	Values for properties (and attributes) can be
	//	composed of mulitple items in the XML document
	//	and thus need to be stored until they are complete
	//	and can be handed off to the context
	//
	StringBuffer<WCHAR>			m_sbValue;
	UINT						m_cmvValues;

	CXMLOut						m_xo;

	SCODE ScHandleElementNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	//	non-implemented
	//
	CNFPatch(const CNFPatch& p);
	CNFPatch& operator=(const CNFPatch& p);

public:

	virtual ~CNFPatch() {};
	CNFPatch(CPatchContext& cpc)
			: m_cpc(cpc),
			  m_state(ST_NODOC),
			  m_vestate(VE_NOECHO),
			  m_cmvValues(0),
			  m_xo(m_sbValue)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD dwType);
};

#endif	// _XMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\atomcache.h ===
/*
 *	A T O M C A C H E . H
 *
 *	atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_ATOMCACHE_H_
#define _EX_ATOMCACHE_H_

#include <crc.h>
#include <crcsz.h>
#include <singlton.h>
#include <ex\buffer.h>
#include <ex\synchro.h>

class CXAtomCache : public OnDemandGlobal<CXAtomCache>
{
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CXAtomCache>;
	friend class RefCountedGlobal<CXAtomCache>;

	enum { CACHESIZE_START = 53 };

	//	Cache of atoms
	//
	typedef CCache<CRCWszN, LPCWSTR> CSzCache;
	CSzCache m_cache;
	CMRWLock m_lock;

	//	String data storage area.
	//
	ChainedStringBuffer<WCHAR> m_csb;

	//	GetCachedAtom()
	//
	SCODE ScGetCachedAtom (CRCWszN& key, LPCWSTR* pwszAtom);

	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CXAtomCache() : m_cache(CACHESIZE_START)
	{
	}

	//	Initialize lock and cache
	//
	BOOL FInit()
	{
		//	Initialize the MRWLock and the cache
		//
		return m_lock.FInitialize() && m_cache.FInit();
	}

	//	non-implmented
	//
	CXAtomCache& operator=(const CXAtomCache&);
	CXAtomCache(const CXAtomCache&);

public:

	using OnDemandGlobal<CXAtomCache>::FInitOnFirstUse;
	using OnDemandGlobal<CXAtomCache>::DeinitIfUsed;

	//	CacheAtom()
	//
	static SCODE ScCacheAtom (LPCWSTR* pwszAtom, UINT cch)
	{
		Assert (pwszAtom);
		Assert (*pwszAtom);

		if (!FInitOnFirstUse())
			return E_OUTOFMEMORY;

		//	Retrieve the string from the cache
		//
		CRCWszN key(*pwszAtom, cch);
		return Instance().ScGetCachedAtom (key, pwszAtom);
	}
};

#endif	// _EX_ATOMCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\astream.h ===
#ifndef _ASTREAM_H_
#define _ASTREAM_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ASTREAM.H
//
//		Async streams header.
//
#include <ex\refcnt.h>
#include <ex\refhandle.h>


//	========================================================================
//
//	CLASS IAsyncReadObserver
//
//	Passed to IAsyncStream::AsyncRead() and called when the asynchronous
//	operation completes.
//
class IAsyncReadObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncReadObserver& operator=( const IAsyncReadObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncReadObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID ReadComplete( UINT cbRead, HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncWriteObserver
//
//	Passed to IAsyncStream::AsyncWrite() and called when the asynchronous
//	operation completes.
//
class IAsyncWriteObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncWriteObserver& operator=( const IAsyncWriteObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncWriteObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID WriteComplete( UINT cbWritten, HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncFlushObserver
//
//	Passed to IAsyncStream::AsyncFlush() and called when the asynchronous
//	operation completes.
//
class IAsyncFlushObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncFlushObserver& operator=( const IAsyncFlushObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncFlushObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID FlushComplete( HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncCopyToObserver
//
//	Passed to IAsyncStream::AsyncCopyTo() and called when the asynchronous
//	operation completes.
//
class IAsyncCopyToObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncCopyToObserver& operator=( const IAsyncCopyToObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncCopyToObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID CopyToComplete( UINT cbCopied, HRESULT hr ) = 0;
};

//	========================================================================
//
//	CLASS IDavStream
//
//		Interface for sync streams.
//
class IDavStream
{
	//	NOT IMPLEMENTED
	//
	IDavStream& operator=( const IDavStream& );

protected:
	//	CREATORS
	//
	//		Only create this object through it's descendents!
	//
	IDavStream() {};

public:
	//	DESTRUCTORS
	//
	//		Out of line virtual destructor necessary for proper
	//		deletion of objects of derived classes via this class
	//
	virtual ~IDavStream() = 0
	{
	}

	//	ACCESSORS
	//

	//	DwLeft() is the function that must be implemented by the descendants of this 
	//	interface if they are to be passed to
	//
	//		IHybridStream::ScCopyFrom(const IDavStream * stmSrc,
	//								  IAsyncWriteObserver * pobsAsyncWrite)
	//	
	//	In that case it must return the number of bytes left in the stream to drain.
	//	That size can be an estimated one, not necessarily exact. That has to be
	//	implemented, that way, as the stream size that we are getting from the store
	//	when we open the stream on the property may be not correct (from the
	//	experience in that I can tell that still in most cases that data is
	//	correct, except for PR_BODY). Also for example in conversion streams we will
	//	not know the stream size in advance (we have not read all data yet and do not
	//	know in what converted size it will result in). Descendants that are not intended to
	//	be passed to the call above may choose to implement DwLeft() to trap or return 0.
	//	Of course in that case they should not rely on information comming back from
	//	that call. Also as soon as it is finally determined that we have reached the
	//	end of the stream (i.e. we read a piece of data, and we read less than we asked for),
	//	the function should always return 0.
	//	
	virtual DWORD DwLeft() const = 0;

	//	FEnd() is the function that must return TRUE in the case the whole stream has been
	//	already drained/consumed. FALSE must be returned in all other cases. Child classes
	//	may implement it to return FALSE always if they are always sure that ScCopyFrom
	//	operations from this stream will always be given amount of bytes to copy that is
	//	equal or less than actual amount of bytes still remaining in the stream. Of course
	//	if they choose always to return FLASE they should not use the function to determine
	//	if they reached the end of the stream.
	//
	virtual BOOL FEnd() const
	{
		TrapSz("IDavStream::FEnd() not implemented");
		return FALSE;
	}
	
	//	ScRead() reading from the stream
	//
	virtual SCODE ScRead( BYTE * pbBuf,
						  UINT   cbToRead,
						  UINT * pcbRead ) const
	{
		TrapSz("IDavStream::ScRead() not implemented");
		return E_NOTIMPL;
	}

	//	MANIPULATORS
	//
	virtual SCODE ScWrite( const BYTE * pbBuf,
						   UINT         cbToWrite,
						   UINT *       pcbWritten )
	{
		TrapSz("IDavStream::ScWrite() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyTo( IDavStream& stmDst,
							UINT        cbToCopy,
							UINT *      pcbCopied )
	{
		TrapSz("IDavStream::ScCopyTo() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScFlush()
	{
		return S_OK;
	}
};

//	========================================================================
//
//	CLASS IAsyncStream
//
//		Interface for async streams.
//
//		AsyncRead() -
//			Asynchronously reads bytes from a stream and notifies an
//			observer when the I/O completes.  IAsyncStream provides
//			a default implementation that notifies the observer with
//			0 bytes read and an HRESULT of E_NOTIMPL.
//
//		AsyncWrite()
//			Asynchronously writes bytes to a stream and notifies an
//			observer when the I/O completes.  IAsyncStream provides
//			a default implementation that notifies the observer with
//			0 bytes written and an HRESULT of E_NOTIMPL.
//
//		AsyncCopyTo()
//			Asynchronously copies bytes from this stream to another
//			IAsyncStream and notifies an observer when the I/O completes.
//			IAsyncStream provides a default implementation that notifies
//			the observer with 0 bytes copied and an HRESULT of E_NOTIMPL.
//
//		AsyncFlush()
//			To be used with buffered writable streams.  Asynchronously
//			flushes accumulated data written in previous calls to
//			AsyncWrite() and notifies an observer when the I/O completes.
//			IAsyncStream provides a default implementation that notifies
//			the observer with an HRESULT of E_NOTIMPL.
//
//	!!!IMPORTANT!!!
//	Despite the refcounted base class of IAsyncWriteObserver and IAsyncFlushObserver,
//	it is the CALLER's sole responsbility to guarantee the lifetime of the stream
//	and observers through completion of any async I/O call.
//
class IAsyncStream
{
	//	NOT IMPLEMENTED
	//
	IAsyncStream& operator=( const IAsyncStream& );

public:
	//	DESTRUCTORS
	//
	virtual ~IAsyncStream() = 0
	{
	}

	//	ACCESSORS
	//
	virtual UINT CbReady() const
	{
		return 0;
	}

	//	MANIPULATORS
	//
	virtual VOID AsyncRead( BYTE * pbBuf,
							UINT   cbToRead,
							IAsyncReadObserver& obsAsyncRead )
	{
		obsAsyncRead.ReadComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncWrite( const BYTE * pbBuf,
							 UINT         cbToWrite,
							 IAsyncWriteObserver& obsAsyncWrite )
	{
		obsAsyncWrite.WriteComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncCopyTo( IAsyncStream& stmDst,
							  UINT          cbToCopy,
							  IAsyncCopyToObserver& obsAsyncCopyTo )
	{
		obsAsyncCopyTo.CopyToComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncFlush( IAsyncFlushObserver& obsAsyncFlush )
	{
		obsAsyncFlush.FlushComplete( E_NOTIMPL );
	}
};

//	========================================================================
//
//	CLASS IHybridStream
//
//		Interface for a hybrid sync/async stream.  The main difference
//		between this interface and IAsyncStream is that the calls here
//		do not always complete via async observer notification.  If a
//		call executes synchronously, it fills in all return values and
//		returns status via an SCODE.  If a call executes asynchronously,
//		it immediately returns E_PENDING and calls the completion observer
//		with return values and status when the asynchronous I/O completes.
//
//		Callers cannot control whether a call executes synchronously or
//		asynchronously.
//
//	!!!IMPORTANT!!!
//	Despite the refcounted base class of IAsyncWriteObserver and IAsyncFlushObserver,
//	it is the CALLER's sole responsbility to guarantee the lifetime of the stream
//	and observers through completion of any async I/O call.
//
class IHybridStream
{
	//	NOT IMPLEMENTED
	//
	IHybridStream& operator=( const IHybridStream& );

public:
	//	CREATORS
	//
	virtual ~IHybridStream() = 0
	{
	}

	//	ACCESSORS
	//
	virtual UINT CbSize() const
	{
		TrapSz("IHybridStream::CbSize() not implemented");
		return 0;
	}

	//	MANIPULATORS
	//
	virtual SCODE ScRead( BYTE * pbToRead,
						  DWORD cbToRead,
						  DWORD * pcbRead,
						  IAsyncReadObserver * pobsAsyncRead )
	{
		TrapSz("IHybridStream::ScRead() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScWrite( const BYTE * pbToWrite,
						   DWORD cbToWrite,
						   DWORD * pcbWritten,
						   IAsyncWriteObserver * pobsAsyncWrite )
	{
		TrapSz("IHybridStream::ScWrite() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyFrom( const IDavStream * pdsToCopy,
							  const DWORD cbToCopy,
							  DWORD * pcbCopied,
							  IAsyncWriteObserver * pobsAsyncWrite )
	{
		TrapSz("IHybridStream::ScCopyFrom() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyFrom( const IDavStream * pdsToCopy,
							  IAsyncWriteObserver * pobsAsyncWrite )
	{
		DWORD cbCopied;
		return ScCopyFrom( pdsToCopy,
						   pdsToCopy->DwLeft(),
						   &cbCopied,
						   pobsAsyncWrite);
	}

	virtual SCODE ScCopyTo( IHybridStream& stmDst,
							DWORD cbToCopy,
							DWORD * pcbCopied,
							IAsyncCopyToObserver * pobsAsyncCopyTo )
	{
		TrapSz("IHybridStream::ScCopyTo() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScFlush( IAsyncFlushObserver * pobsAsyncFlush )
	{
		TrapSz("IHybridStream::ScFlush() not implemented");
		return E_NOTIMPL;
	}
};

//	========================================================================
//
//	TEMPLATE CLASS CBufferedStream
//
//	Inline buffering stream implementation.  See !!! IMPORTANT !!! section
//	below for limitations and other considerations.
//
//	Template parameters:
//
//		_RawStream
//			Raw stream type.  _RawStream must implement ScReadRaw() for
//			CBufferedStream::ScRead(), if it is to be used, and ScWriteRaw()
//			for CBufferedStream::ScWrite() and CBufferedStream::ScFlush()
//			if they are to be used.  The prototypes are:
//
//			SCODE ScReadRaw( BYTE * pbToRead,
//							 DWORD   cbToRead,
//							 DWORD * pcbRead,
//							 IAsyncReadObserver * pobsAsyncRead );
//
//			SCODE ScWriteRaw( const BYTE * pbToWrite,
//							  DWORD cbToWrite,
//							  DWORD * pcbWritten,
//							  IAsyncWriteObserver * pobsAsyncWrite );
//
//			These functions read and write from the raw stream.  The I/O
//			they implement can be synchronous or asynchronous or both.
//
//		CB_BUF
//			Size (in bytes) of the buffer to use.  The buffer is a direct
//			member of CBufferedStream; no allocation is done.
//
//
//	!!! IMPORTANT !!!
//
//	Reading and writing:
//		There is no restriction on the amount of data that can be read
//		or written at once, but data is buffered CB_BUF bytes at a time.
//		This means that a request to write, for example, 128K of data
//		will incur two buffer flushes when CB_BUF is 64K.  The same
//		is true of reads and buffer fills.  Buffer flushes/fills are
//		typically the expensive I/O operations, so choose a CB_BUF
//		that works well with the particular I/O (e.g. 64K for file I/O).
//
//	Flushing:
//		There is an assumption in ScFlush() that the stream being flushed
//		to is not a buffered stream; ScFlush() does not flush the raw stream.
//
//	Class size:
//		Since the buffer is inline (i.e. not allocated), instances of this class
//		can potentially be large.  Whenever such an instance is used as a
//		direct member of another class, it should be the last such member so as
//		to maximize data locality when accessing other members of the class.
//		
template<class _RawStream, UINT CB_BUF>
class CBufferedStream :
	private IAsyncReadObserver,
	private IAsyncWriteObserver
{
	//	Amount of the buffer used.
	//
	UINT m_cbBufUsed;

	//	Index of next byte to read from buffer.
	//
	UINT m_ibBufCur;

	//	Per read/write request state.  These members are used
	//	to keep track of state across various async I/O calls.
	//
	const IDavStream * m_pdsRequest;
	LPBYTE m_pbRequest;
	DWORD m_cbRequest;
	DWORD m_cbRequestDone;

	//	Caller-supplied observers.  Used to notify the caller
	//	when I/O completes.
	//
	IAsyncReadObserver * m_pobsRead;
	IAsyncWriteObserver * m_pobsWrite;
	IAsyncFlushObserver * m_pobsFlush;

	//	Pointer to the raw stream.  Used in buffer filling/flushing.
	//
	_RawStream * m_pstmRaw;

	//	The buffer.  The CB_BUF size is a template parameter.
	//
	BYTE m_rgbBuf[CB_BUF];

	//	Internal I/O routines
	//
	inline SCODE ScReadInt();
	inline SCODE ScWriteInt();
	inline SCODE ScCopyFromInt();

	//	Raw stream I/O completion routines
	//
	inline VOID RawReadComplete(UINT cbReadRaw);
	inline VOID RawWriteComplete(UINT cbWrittenRaw);

	//	Buffer filling and flushing utilities
	//
	inline SCODE ScFillBuffer();
	inline SCODE ScFlushBuffer();

	//	NOT IMPLEMENTED
	//
	CBufferedStream( const CBufferedStream& );
	CBufferedStream& operator=( const CBufferedStream& );

public:
	//	CREATORS
	//
	CBufferedStream() :
		m_cbBufUsed(0),
		m_ibBufCur(0),
		m_pobsRead(NULL),
		m_pobsWrite(NULL),
		m_pobsFlush(NULL)
	{
	}

	//	ACCESSORS
	//
	ULONG CbBufUsed() const
	{
		return m_cbBufUsed;
	}

	//	MANIPULATORS
	//
	inline
	SCODE ScRead( _RawStream& stmRaw,
				  BYTE * pbToRead,
				  DWORD cbToRead,
				  DWORD * pcbRead,
				  IAsyncReadObserver * pobsReadExt );

	inline
	SCODE ScWrite( _RawStream& stmRaw,
				   const BYTE * pbToWrite,
				   DWORD cbToWrite,
				   DWORD * pcbWritten,
				   IAsyncWriteObserver * pobsWriteExt );

	inline
	SCODE ScCopyFrom( _RawStream& stmRaw,
					  const IDavStream * pdsToCopy,
					  const DWORD cbToCopy,
					  DWORD * pcbCopied,
					  IAsyncWriteObserver * pobsWriteExt );

	inline
	SCODE ScFlush( _RawStream& stmRaw,
				   IAsyncFlushObserver * pobsFlushExt );

	//	IAsyncReadObserver/IAsyncWriteObserver
	//
	//	Note: these functions are not really inlined -- they are declared
	//	virtual in the observer interface classes.  However we must declare
	//	them inline so that the compiler will generate one instance of each
	//	function rather than one instance per function per module.  This is
	//	the member function equivalent of DEC_CONST.
	//
	inline
	VOID ReadComplete( UINT cbReadRaw,
					   HRESULT hr );

	inline
	VOID WriteComplete( UINT cbWrittenRaw,
						HRESULT hr );

	//$REVIEW
	//
	//	IAsyncWriteObserver and IAsyncReadObserver are both refcounted
	//	interfaces and don't need to be.  Caller assumes all responsibility
	//	for keeping stream and observer objects alive through any stream
	//	call.
	//
	void AddRef()
	{
		TrapSz("CBufferedStream::AddRef() is not implemented!");
	}

	void Release()
	{
		TrapSz("CBufferedStream::Release() is not implemented!");
	}
};

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScRead(
	_RawStream& stmRaw,
	BYTE * pbToRead,
	DWORD cbToRead,
	DWORD * pcbRead,
	IAsyncReadObserver * pobsReadExt )
{
	//	Check parameters
	//
	Assert(cbToRead > 0);
	Assert(!IsBadWritePtr(pbToRead, cbToRead));
	Assert(!IsBadWritePtr(pcbRead, sizeof(UINT)));
	Assert(!pobsReadExt || !IsBadReadPtr(pobsReadExt, sizeof(IAsyncReadObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	Set up state for a new read
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = NULL;
	m_pbRequest = pbToRead;
	m_cbRequest = cbToRead;
	m_pobsRead = pobsReadExt;
	m_cbRequestDone = 0;

	//	Issue the read
	//
	SCODE sc = ScReadInt();

	//	If the read didn't pend then clear out the observer
	//	and return the amount of data read.
	//
	if (E_PENDING != sc)
	{
		m_pobsRead = NULL;
		*pcbRead = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScReadInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and reading from the
	//	buffer until we finish the request or until a fill pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If we have read everything from the buffer then try
		//	to refill the buffer from the raw stream.
		//
		if (m_ibBufCur == m_cbBufUsed)
		{
			sc = ScFillBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScReadInt() - ScFillBuffer() failed 0x%08lX\n", sc);

				break;
			}

			//	If the buffer is still empty then we have
			//	exhausted the stream, so we are done.
			//
			if (0 == m_cbBufUsed)
				break;
		}

		//	The buffer should have data available to be read
		//	so read it.
		//
		Assert(m_ibBufCur < m_cbBufUsed);
		DWORD cbToRead = min(m_cbBufUsed - m_ibBufCur,
							 m_cbRequest - m_cbRequestDone);

		memcpy(m_pbRequest + m_cbRequestDone,
			   &m_rgbBuf[m_ibBufCur],
			   cbToRead);

		m_ibBufCur += cbToRead;
		m_cbRequestDone += cbToRead;
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFillBuffer()
{
	//	We better have a stream to fill from
	//
	Assert(m_pstmRaw);

	//	Assert that we are not in any write/copy/flush I/O
	//
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	We should only try to refill the buffer after all
	//	of the data in it has been consumed.
	//
	Assert(m_ibBufCur == m_cbBufUsed);

	//	Reset the buffer back to the beginning.
	//
	m_cbBufUsed = 0;
	m_ibBufCur = 0;

	//	Read data in from the raw stream.  If reading pends on I/O
	//	then we will resume processing in CBufferedStream::ReadComplete()
	//	when the I/O completes.
	//
	DWORD cbRead = 0;
	SCODE sc = m_pstmRaw->ScReadRaw(m_rgbBuf,
									CB_BUF,
									&cbRead,
									this);
	if (SUCCEEDED(sc))
	{
		//	ScReadRaw() did not pend, so update our internal state and continue.
		//
		RawReadComplete(cbRead);
	}
	else if (E_PENDING != sc)
	{
		DebugTrace("CBufferedStream::ScFillBuffer() - m_pstmRaw->ScReadRaw() failed 0x%08lX\n", sc);
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::ReadComplete( UINT cbReadRaw,
												   HRESULT hr )
{
	//	Update our internal state
	//
	RawReadComplete(cbReadRaw);

	//	If I/O succeeded then continue reading where we left off.
	//	We are done reading only when ScReadInt() returns S_OK
	//	or any error other than E_PENDING.
	//
	if (SUCCEEDED(hr))
	{
		hr = ScReadInt();
		if (E_PENDING == hr)
			return;

		if (FAILED(hr))
			DebugTrace("CBufferedStream::ReadComplete() - ScReadInt() failed 0x%08lX\n", hr);
	}

	//	Pull the external read observer from where we saved it
	//
	Assert(m_pobsRead);
	IAsyncReadObserver * pobsReadExt = m_pobsRead;
	m_pobsRead = NULL;

	//	Complete the read by calling the client back with
	//	total amount read for the request.
	//
	//	Note that m_cbRequestDone != m_cbRequest only when there
	//	is an error.
	//
	Assert(FAILED(hr) || m_cbRequestDone == m_cbRequest);
	pobsReadExt->ReadComplete(m_cbRequestDone, hr);
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::RawReadComplete(UINT cbReadRaw)
{
	Assert(0 == m_cbBufUsed);
	Assert(0 == m_ibBufCur);

	//	Update the number of bytes read
	//
	m_cbBufUsed = cbReadRaw;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScWrite(
	_RawStream& stmRaw,
	const BYTE * pbToWrite,
	DWORD cbToWrite,
	DWORD * pcbWritten,
	IAsyncWriteObserver * pobsWriteExt )
{
	//	Check parameters
	//
	Assert(cbToWrite > 0);
	Assert(!IsBadReadPtr(pbToWrite, cbToWrite));
	Assert(!IsBadWritePtr(pcbWritten, sizeof(UINT)));
	Assert(!pobsWriteExt || !IsBadReadPtr(pobsWriteExt, sizeof(IAsyncWriteObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);
	
	//	Set up state for a new write.  Casting away const-ness is OK;
	//	we don't write to m_pbRequest on writes.
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = NULL;
	m_pbRequest = const_cast<BYTE *>(pbToWrite);
	m_cbRequest = cbToWrite;
	m_pobsWrite = pobsWriteExt;
	m_cbRequestDone = 0;

	//	Issue the write
	//
	SCODE sc = ScWriteInt();

	//	If the write didn't pend then clear out the observer
	//	and return the amount of data written.
	//
	if (E_PENDING != sc)
	{
		m_pobsWrite = NULL;
		*pcbWritten = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScCopyFrom(
	_RawStream& stmRaw,
	const IDavStream * pdsToCopy,
	const DWORD cbToCopy,
	DWORD * pcbCopied,
	IAsyncWriteObserver * pobsWriteExt )
{
	//	Check parameters
	//
	Assert(cbToCopy >= 0);
	Assert(!IsBadReadPtr(pdsToCopy, sizeof(IDavStream)));
	Assert(!IsBadWritePtr(pcbCopied, sizeof(UINT)));
	Assert(!pobsWriteExt || !IsBadReadPtr(pobsWriteExt, sizeof(IAsyncWriteObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	Set up state for a new write.  Casting away const-ness is OK;
	//	we don't write to m_pbRequest on writes.
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = pdsToCopy;
	m_pbRequest = NULL;
	m_cbRequest = cbToCopy;
	m_pobsWrite = pobsWriteExt;
	m_cbRequestDone = 0;

	//	Issue the write
	//
	SCODE sc = ScCopyFromInt();

	//	If the write didn't pend then clear out the observer
	//	and return the amount of data written.
	//
	if (E_PENDING != sc)
	{
		m_pobsWrite = NULL;
		*pcbCopied = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScWriteInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and flushing the buffer until
	//	we finish the request or until a buffer flush pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If there is no room left to write to the buffer then flush
		//	the buffer to the raw stream.
		//
		if (CB_BUF == m_cbBufUsed)
		{
			sc = ScFlushBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScWriteInt() - ScFlushBuffer() failed 0x%08lX\n", sc);

				break;
			}
		}

		//	There is room left in the buffer so copy over
		//	as much data from the request as will fit.
		//
		Assert(m_cbBufUsed < CB_BUF);
		DWORD cbToWrite = min(CB_BUF - m_cbBufUsed,
							  m_cbRequest - m_cbRequestDone);

		Assert(m_pbRequest);
		memcpy(&m_rgbBuf[m_cbBufUsed],
			   m_pbRequest + m_cbRequestDone,
			   cbToWrite);

		m_cbBufUsed += cbToWrite;
		m_cbRequestDone += cbToWrite;
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScCopyFromInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and flushing the buffer until
	//	we finish the request or until a buffer flush pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If there is no room left to write to the buffer then flush
		//	the buffer to the raw stream.
		//
		if (CB_BUF == m_cbBufUsed)
		{
			sc = ScFlushBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScCopyFromInt() - ScFlushBuffer() failed 0x%08lX\n", sc);

				break;
			}
		}

		//	There is room left in the buffer so copy over
		//	as much data from the request as will fit.
		//
		Assert(m_cbBufUsed < CB_BUF);
		UINT  cbCopied = 0;
		DWORD cbToCopy = min(CB_BUF - m_cbBufUsed,
							  m_cbRequest - m_cbRequestDone);

		Assert(m_pdsRequest);
		sc = m_pdsRequest->ScRead(&m_rgbBuf[m_cbBufUsed],
								  cbToCopy,
								  &cbCopied);
		if (FAILED(sc))
		{
			Assert(E_PENDING != sc);
			DebugTrace("CBufferedStream::ScCopyFromInt() - ScRead() from source buffer failed 0x%08lX\n", sc);
			break;
		}

		m_cbBufUsed += cbCopied;
		m_cbRequestDone += cbCopied;

		//	Even if the clients requested to read certain amount of bytes to be read,
		//	they may be wrong in their estimates, so let us be really smart about the
		//	case and check if the end of the stream has been reached
		//
		if (m_pdsRequest->FEnd())
		{
			//	Make sure that we certainly go out of the loop in the case we finished
			//
			m_cbRequest = m_cbRequestDone;
			break;
		}
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::WriteComplete( UINT cbWritten,
													HRESULT hr )
{
	//	Update our internal state with the amount of buffered data that we
	//	flushed.  We only want to do this IF the call was successful....
	//	RawWriteComplete() asserts that cbWritten == m_cbBufUsed, which will
	//	not be true if the write failed.
	//
    if (SUCCEEDED(hr))
        RawWriteComplete(cbWritten);

	//	I/O is complete.  Either the write that just completed
	//	failed or the subsequent write completed synchronously.
	//	Notify the appropriate observer that we are done.
	//
	if (m_pobsWrite)
	{
		// I/O was a write, not a flush
		//
		Assert(!m_pobsFlush);

		//	If I/O succeeded then continue writing where we left off.
		//	We are done writing only when ScWriteInt() returns S_OK
		//	or any error other than E_PENDING.
		//
		if (SUCCEEDED(hr))
		{
			hr = ScWriteInt();
			if (E_PENDING == hr)
				return;

			if (FAILED(hr))
				DebugTrace("CBufferedStream::WriteComplete() - ScWriteInt() failed 0x%08lX\n", hr);
		}

		//	Pull the external write observer from where we saved it
		//
		IAsyncWriteObserver * pobsWriteExt = m_pobsWrite;
		m_pobsWrite = NULL;

		//	Complete the write by calling the client back with
		//	total amount written for the request.
		//
		//	Note that m_cbRequestDone != m_cbRequest only when there
		//	is an error.
		//
		Assert(FAILED(hr) || m_cbRequestDone == m_cbRequest);
		pobsWriteExt->WriteComplete(m_cbRequestDone, hr);
	}
	else
	{
		// I/O was a flush, not a write
		//
		Assert(m_pobsFlush);

		//	The buffer should be empty after flushing
		//
		Assert(0 == m_cbBufUsed);

		//	Pull the external flush observer from where we saved it
		//
		IAsyncFlushObserver * pobsFlushExt = m_pobsFlush;
		m_pobsFlush = NULL;

		//	Tell it that we are done.
		//
		pobsFlushExt->FlushComplete(hr);
	}
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFlushBuffer()
{
	//	We better have a stream to flush to.
	//
	Assert(m_pstmRaw);

	//	We better have something to flush.
	//
	Assert(m_cbBufUsed > 0);

	//	Write out all buffered data to the raw stream.  If writing
	//	pends on I/O then we will resume processing in
	//	CBufferedStream::WriteComplete() when the I/O completes.
	//
	DWORD cbWritten = 0;
	SCODE sc = m_pstmRaw->ScWriteRaw(m_rgbBuf,
									 m_cbBufUsed,
									 &cbWritten,
									 this);
	if (SUCCEEDED(sc))
	{
		//	ScWriteRaw() did not pend, so update our internal state and continue.
		//
		RawWriteComplete(cbWritten);
	}
	else if (E_PENDING != sc)
	{
		DebugTrace("CBufferedStream::ScFlushBuffer() - m_pstmRaw->ScWriteRaw() failed 0x%08lX\n", sc);
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::RawWriteComplete(UINT cbWrittenRaw)
{
	//	Verify that we wrote the entire buffer
	//
	Assert(cbWrittenRaw == m_cbBufUsed);

	//	Start the buffer again from the beginning
	//
	m_cbBufUsed = 0;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFlush( _RawStream& stmRaw,
											  IAsyncFlushObserver * pobsFlushExt )
{
	SCODE sc = S_OK;

	//	Check parameters
	//
	Assert(!pobsFlushExt || !IsBadReadPtr(pobsFlushExt, sizeof(IAsyncFlushObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsFlush);
	Assert(!m_pobsWrite);

	//	If there's nothing to flush then we're done.
	//
	if (m_cbBufUsed)
	{
		//	Set up state for a flush
		//
		m_pstmRaw = &stmRaw;
		m_pobsFlush = pobsFlushExt;

		//	Flush buffered data to the raw stream.
		//
		sc = ScFlushBuffer();

		//	If the flush didn't pend then clear out the observer.
		//
		if (E_PENDING != sc)
			m_pobsFlush = NULL;
	}

	return sc;
}


//	========================================================================
//
//	CLASS CFileStreamImp
//
//		Base implementation class for a file stream.
//
template<class _RawStream, class _OVL>
class CFileStreamImp
{
	//
	//	File handle
	//
	auto_ref_handle m_hf;

	//
	//	File pointer
	//
	_OVL m_ovl;

	//
	//	Implementation stream is a buffered stream with a buffer size
	//	of 64K to optimize for file I/O.
	//
	//	Note: this data member is declared LAST because it contains
	//	an internal 64K buffer that we don't want sitting between
	//	other member variables.
	//
	CBufferedStream<_RawStream, 64 * 1024> m_BufferedStream;

	//	NOT IMPLEMENTED
	//
	CFileStreamImp( const CFileStreamImp& );
	CFileStreamImp& operator=( const CFileStreamImp& );

public:
	//	CREATORS
	//
	CFileStreamImp(const auto_ref_handle& hf) :
		m_hf(hf)
	{
		memset(&m_ovl, 0, sizeof(m_ovl));
	}

	//	ACCESSORS
	//
	HANDLE HFile() const
	{
		return m_hf.get();
	}

	_OVL * POverlapped()
	{
		return &m_ovl;
	}

	//	MANIPULATORS
	//
	SCODE ScRead( _RawStream& stmRaw,
				  BYTE * pbToRead,
				  DWORD cbToRead,
				  DWORD * pcbRead,
				  IAsyncReadObserver * pobsAsyncRead )
	{
		return m_BufferedStream.ScRead( stmRaw,
										pbToRead,
										cbToRead,
										pcbRead,
										pobsAsyncRead );
	}

	SCODE ScWrite( _RawStream& stmRaw,
				   const BYTE * pbToWrite,
				   DWORD cbToWrite,
				   DWORD * pcbWritten,
				   IAsyncWriteObserver * pobsAsyncWrite )
	{
		return m_BufferedStream.ScWrite( stmRaw,
										 pbToWrite,
										 cbToWrite,
										 pcbWritten,
										 pobsAsyncWrite );
	}

	SCODE ScCopyFrom( _RawStream& stmRaw,
					  const IDavStream * pdsToCopy,
					  const DWORD cbToCopy,
					  DWORD * pcbCopied,
					  IAsyncWriteObserver * pobsAsyncWrite )
	{
		return m_BufferedStream.ScCopyFrom( stmRaw,
											pdsToCopy,
											cbToCopy,
											pcbCopied,
											pobsAsyncWrite );
	}


	SCODE ScFlush( _RawStream& stmRaw,
				   IAsyncFlushObserver * pobsFlush )
	{
		return m_BufferedStream.ScFlush( stmRaw, pobsFlush );
	}

	//
	//	Update the current file position
	//
	VOID UpdateFilePos(UINT cbIO)
	{
		//
		//	Check for overflow of the low 32 bits of the offset.  If we are
		//	going to overflow then increment the high part of the offset.
		//
		if (m_ovl.Offset + cbIO < m_ovl.Offset)
		{
			++m_ovl.OffsetHigh;

			//
			//	OffsetHigh should NEVER overflow
			//
			Assert(m_ovl.OffsetHigh);
		}

		//
		//	Update the low 32 bits of the offset
		//
		m_ovl.Offset += cbIO;
	}
};

#endif // !defined(_ASTREAM_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\autoptr.h ===
/*
 *	E X \ A U T O P T R . H
 *
 *	Implementation of automatic-cleanup pointer template classes.
 *	This implementation is safe for use in NON-throwing environments
 *	(save for EXDAV & other store-loaded components).
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved.
 */

//----------------------------------------------------------------------//
//
//	Automatic pointers defined here:
//
//		auto_ptr<>
//		auto_heap_ptr<>
//		auto_handle<>
//		auto_heap_array<>
//		auto_ref_ptr<CRefCountedObject>
//

#ifndef _EX_AUTOPTR_H_
#define _EX_AUTOPTR_H_

#include <caldbg.h>
#include <calrc.h>
#include <ex\exmem.h>

#pragma warning(disable: 4284)   // operator-> to a non UDT

//	========================================================================
//
//	TEMPLATE CLASS auto_ptr
//
//		Stripped down auto_ptr class based on the C++ STL standard one
//
//		Calls delete on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-ptr1 = auto-ptr2.relinquish();
//
template<class X>
class auto_ptr
{
protected:
	X *			px;

	//	NOT IMPLEMENTED
	//
	auto_ptr(const auto_ptr<X>& p);
	auto_ptr& operator=(const auto_ptr<X>& p);

public:

	//	CONSTRUCTORS
	//
	explicit auto_ptr(X* p=0) : px(p) {}
	~auto_ptr()
	{
		delete px;
	}

	//	ACCESSORS
	//
	bool operator!()const { return (px == NULL); }
	operator X*() const { return px; }
	// X& operator*()  const { Assert (px); return *px; }
	X* operator->() const { Assert (px); return px; }
	X* get()		const { return px; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = px; px = 0; return p; }
	X** operator&()	{ Assert (!px); return &px; }
	void clear()
	{
		delete px;
		px = NULL;
	}
	auto_ptr& operator=(X* p)
	{
		Assert(!px);		//	Scream on overwrite of good data.
		px = p;
		return *this;
	}
};



//	========================================================================
//
//	TEMPLATE CLASS auto_handle
//
//		auto_ptr for NT system handles.
//
//		Closes the handle on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-handle-1 = auto-handle-2.relinquish();
//
template<class X>
class auto_handle
{
private:
	X 	handle;

	//	NOT IMPLEMENTED
	//
	auto_handle(const auto_handle<X>& h);
	auto_handle& operator=(auto_handle<X>& h);

public:

	//	CONSTRUCTORS
	//
	auto_handle(X h=0) : handle(h) {}
	~auto_handle()
	{
		if (handle && INVALID_HANDLE_VALUE != handle)
		{
			CloseHandle(handle);
		}
	}

	//	ACCESSORS
	//
	operator X()	const { return handle; }
	X get()			const { return handle; }

	//	MANIPULATORS
	//
	X relinquish()	{ X h = handle; handle = 0; return h; }
	X* load()		{ Assert(NULL==handle); return &handle; }
	X* operator&()	{ Assert(NULL==handle); return &handle; }
	void clear()
	{
		if (handle && INVALID_HANDLE_VALUE != handle)
		{
			CloseHandle(handle);
		}

		handle = 0;
	}

	auto_handle& operator=(X h)
	{
		Assert (handle == 0);	//	Scream on overwrite of good data
		handle = h;
		return *this;
	}
};



//	========================================================================
//
//	TEMPLATE CLASS auto_ref_ptr
//
//		Holds a ref on an object.  Works with CRefCountedObject.
//		Grabs a ref when a pointer is assigned into this object.
//		Releases the ref when this object is destroyed.
//
template<class X>
class auto_ref_ptr
{
private:

	X *	m_px;

	void init()
	{
		if ( m_px )
		{
			m_px->AddRef();
		}
	}

	void deinit()
	{
		if ( m_px )
		{
			m_px->Release();
		}
	}

	//	NOT IMPLEMENTED
	//	We turn off operator new to try to prevent auto_ref_ptrs being
	//	created via new().  However, storext.h uses a macro to redefine new,
	//	so this line is only used on non-DBG.
#ifndef	DBG
	void * operator new(size_t cb);
#endif	// !DBG

public:

	//	CONSTRUCTORS
	//
	explicit auto_ref_ptr(X* px=0) :
			m_px(px)
	{
		init();
	}

	auto_ref_ptr(const auto_ref_ptr<X>& rhs) :
			m_px(rhs.m_px)
	{
		init();
	}

	~auto_ref_ptr()
	{
		deinit();
	}

	//	ACCESSORS
	//
	X& operator*()		const { return *m_px; }
	X* operator->()		const { return m_px; }
	X* get()			const { return m_px; }

	//	MANIPULATORS
	//
	X* relinquish()			{ X* p = m_px; m_px = 0; return p; }
	X** load()				{ Assert(NULL==m_px); return &m_px; }
	X* take_ownership(X* p) { Assert(NULL==m_px); return m_px = p; }
	void clear()
	{
		deinit();
		m_px = NULL;
	}
	auto_ref_ptr& operator=(const auto_ref_ptr<X>& rhs)
	{
		if ( m_px != rhs.m_px )
		{
			deinit();
			m_px = rhs.m_px;
			init();
		}

		return *this;
	}

	auto_ref_ptr& operator=(X* px)
	{
		if ( m_px != px )
		{
			deinit();
			m_px = px;
			init();
		}

		return *this;
	}
};




//	========================================================================
//
//	TEMPLATE CLASS auto_heap_ptr
//
//		An auto_ptr class based on the heap instead of new.
//
//		Calls ExFree() on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-heap-ptr1 = auto-heap-ptr2.relinquish();
//
template<class X>
class auto_heap_ptr
{
private:
	X *			m_px;

	//	NOT IMPLEMENTED
	//
	auto_heap_ptr (const auto_heap_ptr<X>& p);
	auto_heap_ptr& operator= (const auto_heap_ptr<X>& p);
	//void * operator new(size_t cb);

public:

	//	CONSTRUCTORS
	//
	explicit auto_heap_ptr (X* p=0) : m_px(p) {}
	~auto_heap_ptr()
	{
		clear();
	}

	//	ACCESSORS
	//
	//	NOTE: this simple cast operator (operator X*()) allows
	//	the [] operator to function.
	//$REVIEW: Should we add an explicit [] operator?
	operator X*()	const { return m_px; }
	X* operator->() const { Assert (m_px); return m_px; }
	X* get()		const { return m_px; }

	//X& operator[] (UINT index) const { return *(m_px + index); }
	//X& operator[] (UINT index) const { return m_px[index]; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = m_px; m_px = 0; return p; }
	X** load()		{ Assert(!m_px); return &m_px; }
	//$REVIEW: Can we migrate all users of operator&() to use load() instead???
	//$REVIEW: Benefit: it's more explicit.  Detriment: need to change existing code.
	X** operator&()	{ Assert (!m_px); return &m_px; }
	void clear()
	{
		if (m_px)			// Release any object we're holding now
		{
			ExFree (m_px);
		}
		m_px = NULL;
	}

	//	Realloc
	//$REVIEW:
	//	This operator is technically NOT safe for store-side code!
	//	It makes it easy to ignore memory failures.
	//	(However, it is currently so ingrained in our vocabulary that
	//	removing it will touch a very large number of files:   )
	//	For now, to be safe, callers MUST check the value of their
	//	object (using .get()) after calling this function.
	//
	void realloc(UINT cb)
	{
		VOID * pvTemp;

		if (m_px)
			pvTemp = ExRealloc (m_px, cb);
		else
			pvTemp = ExAlloc (cb);
		Assert (pvTemp);

		m_px = reinterpret_cast<X*>(pvTemp);
	}
	//$REVIEW: end

	//	Failing Realloc
	//
	BOOL frealloc(UINT cb)
	{
		VOID * pvTemp;

		if (m_px)
			pvTemp = ExRealloc (m_px, cb);
		else
			pvTemp = ExAlloc (cb);
		if (!pvTemp)
			return FALSE;

		m_px = static_cast<X*>(pvTemp);
		return TRUE;
	}

	//	NOTE: This method asserts if the auto-pointer already holds a value.
	//	Use clear() or relinquish() to clear the old value before
	//	taking ownership of another value.
	//
	void take_ownership (X * p)
	{
		Assert (!m_px);		//	Scream on overwrite of good data.
		m_px = p;
	}
	//	NOTE: This operator= is meant to do exactly the same as take_ownership().
	//
	auto_heap_ptr& operator= (X * p)
	{
		Assert (!m_px);		//	Scream on overwrite of good data.
		m_px = p;
		return *this;
	}

};

#endif //!_EX_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\buffer.h ===
/*
 *	B U F F E R . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_BUFFER_H_
#define _EX_BUFFER_H_

//	Alignment macros ----------------------------------------------------------
//
#include <align.h>

//	Safe allocators -----------------------------------------------------------
//
#include <ex\exmem.h>

//	Stack buffers -------------------------------------------------------------
//
#include <ex\stackbuf.h>

//	StringSize usage ----------------------------------------------------------
//
//	CbStringSize is the size of the string without the NULL termination
//	CbStringSizeNull is the size of the string with the NULL termination
//	CchStringLength is the length of the string without the NULL termination
//	CchzStringLength is the length of the string with the NULL termination
//
template<class X>
inline int WINAPI CbStringSize(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch * sizeof(X);
}

template<class X>
inline int WINAPI CbStringSizeNull(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return (cch + 1) * sizeof(X);
}

template<class X>
inline int WINAPI CchStringLength(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch;
}
template<class X>
inline int WINAPI CchzStringLength(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch + 1;
}

//	StringBuffer vs ChainedStringBuffer usage ---------------------------------
//
//	When should you use which one?
//	StringBuffer characteristics:
//	o	Data stored in one contiguous memory block.
//	o	Memory may be realloc'd.
//	o	Only offsets (ib) to strings are returned.
//	ChainedStringBuffer characteristics:
//	o	Memory not contiguous.  Multiple chained buffers.
//	o	Memory is never realloc'd.
//	o	String pointers directly into chained buffers are returned.
//	Both have logarithmic allocation behavior (order log(n) alloc operations
//	will be done, where n is the max size of the data).  This behavior is
//	governed by the m_cbChunkSize starting size and increments.
//

//	StringBuffer template class -----------------------------------------------
//
//	A simple variable-size, demand paged buffer abstraction.
//
template<class T>
class StringBuffer
{
	T *			m_pData;
	UINT		m_cbAllocated;
	UINT		m_cbUsed;
	UINT		m_cbChunkSize;		// Count of bytes to alloc (dynamic).

	enum { CHUNKSIZE_START = 64 };	// Default starting chunk size (in bytes).

	//	Memory allocation mechanism -------------------------------------------
	//
	UINT Alloc( UINT ibLoc, UINT cbAppend )
	{
		//	Grow the data buffer if necessary
		//
		if ( ibLoc + cbAppend > m_cbAllocated )
		{
			T* pData;

			//	Alloc the buffer.
			//
			UINT cbSize = max( m_cbChunkSize, cbAppend );

			if (m_pData)
			{
				pData = static_cast<T*>
						(ExRealloc( m_pData, m_cbAllocated + cbSize ));
			}
			else
			{
				pData = static_cast<T*>
						(ExAlloc( m_cbAllocated + cbSize ));
			}

			//	When we are in the context of the server, our allocators
			//	can fail without throwing.  Bubble the error out.
			//
			if (NULL == pData)
				return static_cast<UINT>(-1);

			m_cbAllocated += cbSize;
			m_pData = pData;

			//	Increase the chunk size, to get "logarithmic allocation behavior"
			//
			m_cbChunkSize *= 2;
		}

		return cbAppend;
	}

	//	non-implemented operators
	//
	StringBuffer(const StringBuffer& );
	StringBuffer& operator=(const StringBuffer& );

public:

	StringBuffer( ULONG cbChunkSize = CHUNKSIZE_START ) :
		m_pData(NULL),
		m_cbAllocated(0),
		m_cbUsed(0),
		m_cbChunkSize(cbChunkSize)
	{
	}

	~StringBuffer()
	{
		ExFree( m_pData );
	}

	//	There is no reason to make it constant on relinquish
	//	we do not own the memory any more
	//
	T * relinquish()
	{
		T * tRet = m_pData;

		m_pData = NULL;
		m_cbUsed = 0;
		m_cbAllocated = 0;

		return tRet;
	}

	const T * PContents() const { return m_pData; }
	UINT CbSize() const			{ return m_cbUsed; }
	UINT CchSize() const		{ return m_cbUsed/sizeof(T); }
	VOID Reset()				{ m_cbUsed = 0; }

	//	Counted type appends --------------------------------------------------
	//
	UINT AppendAt( UINT ibLoc, UINT cbAppend, const T * pAppend)
	{
		UINT cb;
		//	Ensure there is enough memory to hold what is needed
		//
		cb = Alloc( ibLoc, cbAppend );

		//	When we are in the context of the server, our allocators
		//	can fail without throwing.  Bubble the error out.
		//
		if (cb != cbAppend)
			return cb;

		//	Append the data to the buffer
		//
		CopyMemory( reinterpret_cast<LPBYTE>(m_pData) + ibLoc,
					pAppend,
					cbAppend );

		m_cbUsed = ibLoc + cbAppend;
		return cbAppend;
	}

	UINT Append( UINT cbAppend, const T * pAppend )
	{
		return AppendAt( CbSize(), cbAppend, pAppend );
	}

	//	Uncounted appends -----------------------------------------------------
	//
	UINT AppendAt( UINT ibLoc, const T * const pszText )
	{
		return AppendAt( ibLoc, CbStringSize<T>(pszText), pszText );
	}

	UINT Append( const T * const pszText )
	{
		return AppendAt( CbSize(), CbStringSize<T>(pszText), pszText );
	}

	BOOL FAppend( const T * const pszText )
	{
		if (AppendAt( CbSize(), CbStringSize<T>(pszText), pszText ) ==
			static_cast<UINT>(-1))
		{
			return FALSE;
		}
		return TRUE;
	}

	BOOL FTerminate()
	{
		T ch = 0;
		if (AppendAt(CbSize(), sizeof(T), &ch) == static_cast<UINT>(-1))
			return FALSE;
		return TRUE;
	}
};


//	ChainedBuffer template class -----------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing buffer pool abstraction.
//	When would you use this guy? When you need to allocate heap memory for
//	many small data items and would rather do it in sizeable chunks rather
//	than allocate each small data item individually. You need the data to
//	to stay because you are going to point to it (no reallocs are allowed
//	under your feet).
//
//	NOTE: Caller is required to allocate items to be properly aligned if
//	it the item being allocated is an element that requires a specific
//	alignment (ie. struct's).
//
template<class T>
class ChainedBuffer
{
	// CHAINBUF -- Hungarian hb
	//
	struct CHAINBUF
	{
		CHAINBUF * phbNext;
		UINT cbAllocated;
		UINT cbUsed;
		BYTE * pData;
	};

	CHAINBUF *	m_phbData;			// The data.
	CHAINBUF *	m_phbCurrent;		// The current buffer for appends.
	UINT		m_cbChunkSizeInit;	// Initial value of m_cbChunkSize
	UINT		m_cbChunkSize;		// Count of bytes to alloc (dynamic).

	//	Alignments
	//
	UINT		m_uAlign;

	//	Destruction function
	//
	void FreeChainBuf( CHAINBUF * phbBuf )
	{
		while (phbBuf)
		{
			CHAINBUF * phbNext = phbBuf->phbNext;
			ExFree(phbBuf);
			phbBuf = phbNext;
		}
	}

protected:

	enum { CHUNKSIZE_START = 64 };	// Default starting chunk size (in bytes).

public:

	ChainedBuffer( ULONG cbChunkSize = CHUNKSIZE_START,
				   UINT uAlign = ALIGN_NATURAL) :
		m_phbData(NULL),
		m_phbCurrent(NULL),
		m_cbChunkSizeInit(cbChunkSize),
		m_cbChunkSize(cbChunkSize),
		m_uAlign(uAlign)
	{
	}

	~ChainedBuffer() { FreeChainBuf( m_phbData ); }

	//	Alloc a fixed size buffer ---------------------------------------
	//
	T * Alloc( UINT cbAlloc )
	{
		BYTE * pbAdd;

		//	So that we don't do anything stupid....  Make sure we allocate
		//	stuff aligned for the template-parameterized type 'T'.
		//
		cbAlloc = AlignN(cbAlloc, m_uAlign);

		//	Add another data buffer if necessary.
		//
		//	It's necessary if we don't have a buffer, or
		//	if the current buffer doesn't have enough free space.
		//
		if ( ( !m_phbCurrent ) ||
			 ( m_phbCurrent->cbUsed + cbAlloc > m_phbCurrent->cbAllocated ) )
		{
			//	Alloc the new buffer.
			//
			UINT cbSize = max(m_cbChunkSize, cbAlloc);
			CHAINBUF * phbNew = static_cast<CHAINBUF *>
								(ExAlloc( cbSize + sizeof(CHAINBUF) ));

			//	When we are in the context of the server, our allocators
			//	can fail without throwing.  Bubble the error out.
			//
			if (NULL == phbNew)
				return NULL;

			//	Fill in the header fields.
			//
			phbNew->phbNext = NULL;
			phbNew->cbAllocated = cbSize;
			phbNew->cbUsed = 0;
			phbNew->pData = reinterpret_cast<BYTE *>(phbNew) + sizeof(CHAINBUF);

			//	Add the new buffer into the chain.
			//
			if ( !m_phbData )
			{
				Assert(!m_phbCurrent);
				m_phbData = phbNew;
			}
			else
			{
				Assert(m_phbCurrent);
				phbNew->phbNext = m_phbCurrent->phbNext;
				m_phbCurrent->phbNext = phbNew;
			}

			//	Use the new buffer (it is now the current buffer).
			//
			m_phbCurrent = phbNew;

			//	Increase the chunk size, to get "logarithmic allocation behavior".
			//
			m_cbChunkSize *= 2;
		}

		Assert(m_phbCurrent);
		Assert(m_phbCurrent->pData);

		//	Find the correct starting spot in the current buffer.
		//
		pbAdd = m_phbCurrent->pData + m_phbCurrent->cbUsed;

		//	Update our count of bytes actually used.
		//
		m_phbCurrent->cbUsed += cbAlloc;

		//	Return the alloced data's starting point to the caller.
		//
		return reinterpret_cast<T *>(pbAdd);
	}

	//	Clear all buffers -----------------------------------------------------
	//
	void Clear()
	{
		//
		//	Clear out data from, but do not free, the buffers
		//	in the chain.  This allows a ChainedStringBuffer to be
		//	reused without necessarily having to reallocate its
		//	consituent buffers.
		//
		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
			phb->cbUsed = 0;

		//	Free any nodes after the first, they do not get reused
		//	as you might expect.
		//
		if ( m_phbCurrent )
		{
			FreeChainBuf( m_phbCurrent->phbNext );
			m_phbCurrent->phbNext = NULL;
		}

		//
		//	Reset the current buffer to the first one
		//
		m_phbCurrent = m_phbData;

		//
		//	Reset the chunk size to the initial chunk size
		//
		m_cbChunkSize = m_cbChunkSizeInit;
	}

	//	Get the total size of the buffer ---------------------------------------
	//
	DWORD	CbBufferSize() const
	{
		DWORD	cbTotal = 0;

		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
			cbTotal += phb->cbUsed;

		return cbTotal;
	}
	//	Dump the whole buffer contents into a contiguous buffer------------------
	//
	DWORD Dump(T *tBuffer, DWORD cbSize) const
	{
		BYTE	*pbBuffer		= NULL;

		Assert(tBuffer);
        Assert(cbSize >= CbBufferSize());

		pbBuffer = reinterpret_cast<PBYTE>(tBuffer);

		//	walk thru the list and dump all the contents
		//
		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
		{
			memcpy(pbBuffer, phb->pData, phb->cbUsed);
			pbBuffer += phb->cbUsed;
		}
		//	return the actual size
		//
		return ( (pbBuffer) - (reinterpret_cast<PBYTE>(tBuffer)) );
	}
};

//	ChainedStringBuffer template class -----------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing string buffer pool abstraction.
//	Why would you use this guy instead of StringBuffer (above)?
//	If you want the strings to STAY, and you don't care about them being
//	in a contiguous block of memory.
//	NOTE: We still keep the data in order, it's just not all in one block.
//
//	This template is only to be used for CHAR and WCHAR strings.
//	Use the ChainedBuffer template for other types.
//
template<class T>
class ChainedStringBuffer : public ChainedBuffer<T>
{
	//	non-implemented operators
	//
	ChainedStringBuffer(const ChainedStringBuffer& );
	ChainedStringBuffer& operator=(const ChainedStringBuffer& );

public:

	//	Declare constructor inline (for efficiency) but do not provide
	//	a definition here.  Definitions for the two template paramater
	//	types that we support (CHAR and WCHAR) are provided explicitly
	//	below.
	//
	inline ChainedStringBuffer( ULONG cbChunkSize = CHUNKSIZE_START );

	//	Counted append --------------------------------------------------
	//
	T * Append( UINT cbAppend, const T * pAppend )
	{
		T* pAdd;

		//	Reserve the space
		//
		pAdd = Alloc( cbAppend );

		//	When we are in the context of the server, our allocators
		//	can fail without throwing.  Bubble the error out.
		//
		if (NULL == pAdd)
			return NULL;

		//	Append the data to the current buffer.
		//
		CopyMemory( pAdd, pAppend, cbAppend );

		//	Return the data's starting point to the caller.
		//
		return pAdd;
	}

	//	Uncounted append ------------------------------------------------------
	//	NOTE: The append does NOT count the trailing NULL of the string!
	//
	T * Append( const T * const pszText )
	{
		return Append( CbStringSize<T>(pszText), pszText );
	}

	//	Uncounted append with trailing NULL -----------------------------------
	//
	T * AppendWithNull( const T * const pszText )
	{
		return Append( CbStringSizeNull<T>(pszText), pszText );
	}
};

//	Specialized ChainedStringBuffer constructor for CHAR ----------------------
//
//	Pass ALIGN_NONE to the ChainedBuffer constructor because CHAR strings
//	do not require alignment.
//
//	!!! DO NOT use ChainedStringBuffer<CHAR> for anything that must be aligned!
//
inline
ChainedStringBuffer<CHAR>::ChainedStringBuffer( ULONG cbChunkSize )
	: ChainedBuffer<CHAR>(cbChunkSize, ALIGN_NONE )
{
}

//	Specialized ChainedStringBuffer constructor for WCHAR ---------------------
//
//	Pass ALIGN_WORD to the ChainedBuffer constructor because WCHAR strings
//	require WORD alignment.
//
inline
ChainedStringBuffer<WCHAR>::ChainedStringBuffer( ULONG cbChunkSize )
	: ChainedBuffer<WCHAR>(cbChunkSize, ALIGN_WORD )
{
}

//	LinkedBuffer template class -----------------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing buffer pool abstraction.
//	When would you use this guy? When you need to allocate heap memory for
//	many small data items and would rather do it in sizeable chunks rather
//	than allocate each small data item individually and the resulting pointer
//	you need to pass into the store needs to be "linked".
//
//	IMPORTANT:
//
//	Linked allocation mechanism is stolen from \store\src\_util\mdbmig.cxx
//	and needs to always match that mechanism.
//
PVOID ExAllocLinked(LPVOID pvLinked, UINT cb);
VOID ExFreeLinked(LPVOID* ppv);

template<class T>
class LinkedBuffer
{
	PVOID m_pvHead;
	PVOID PvAllocLinked(UINT cb)
	{
		PVOID pv = ExAllocLinked(m_pvHead, cb);

		if (NULL == m_pvHead)
			m_pvHead = pv;

		return pv;
	}

public:

	LinkedBuffer() : m_pvHead(NULL)
	{
	}

	~LinkedBuffer()
	{
		if (m_pvHead)
			ExFreeLinked(&m_pvHead);
	}

	//	Alloc a fixed size buffer ---------------------------------------
	//
	T * Alloc( UINT cbAlloc )
	{
		return reinterpret_cast<T*>(PvAllocLinked (cbAlloc));
	}

	PVOID PvTop() { Assert (m_pvHead); return m_pvHead; }
	PVOID relinquish()
	{
		PVOID pv = m_pvHead;
		m_pvHead = NULL;
		return pv;
	}
	void clear()
	{
		if (m_pvHead)
		{
			ExFreeLinked(&m_pvHead);
			m_pvHead = NULL;
		}
	}
	void takeover ( LinkedBuffer<T> & lnkbufOldOwner )
	{
		m_pvHead = lnkbufOldOwner.m_pvHead;
		lnkbufOldOwner.m_pvHead = NULL;
	}
};

#endif // _EX_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\gencache.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	GENCACHE.H
//
//		Header for generic cache classes.
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//

//	Documenting my dependencies
//	These must be included BEFORE this file is included.
//#include "caldbg.h"
//#include "autoptr.h"

#ifndef _EX_GENCACHE_H_
#define _EX_GENCACHE_H_

#pragma warning(disable:4200)	// zero-sized array

//	Exdav-safe allocators --------------------------------------------------
//
//	The classed declared here use the EXDAV-safe allocators (ExAlloc, ExFree)
//	for all allocations.
//	NOTE: These allocators can FAIL.  You must check for failure on
//	ExAlloc and ExRealloc!
//
#include <ex\exmem.h>
#include <align.h>

//	========================================================================
//
//	TEMPLATE CLASS CPoolAllocator
//
//	A generic type-specific pool allocator template.  Items in the pool
//	are allocated in chunks and handed out upon request.
//	Items are recycled on a free chain.
//	All items are the same size, so reuse is relatively easy.
//
//	NOTE: I have NOT optimized the heck out of this thing.  To really
//	optimize locality of mem usage, we'd want to always grow & shrink
//	"at the tail".  To that end, I always check the freechain first --
//	reuse an item before using a new one from the current buffer.
//	More optimization would require sorting the freechain & stuff.
//
template<class T>
class CPoolAllocator
{
	//	CHAINBUFHDR ----------------------------------------
	//	Header struct for chaining together pool buffers.
	//
	struct CHAINBUFHDR
	{
		CHAINBUFHDR * phbNext;
		int cItems;
		int cItemsUsed;
		// Remainder of buffer is set of items of type T.
		T rgtPool[0];
		// Just to quiet our noisy compiler.
		CHAINBUFHDR() {};
		~CHAINBUFHDR() {};
	};

	//	CHAINITEM ------------------------------------------
	//	Struct "applied over" free items to chain them together.
	//	The actual items MUST be large enough to accomodate this.
	//
	struct CHAINITEM
	{
		CHAINITEM * piNext;
	};

	//	Chain of buffers.
	CHAINBUFHDR * m_phbCurrent;
	//	Chain of free'd items to reuse.
	CHAINITEM * m_piFreeChain;
	//	Size of chunk to alloc.
	int m_ciChunkSize;

	//	Constant (enum) for our default starting chunk size (in items).
	//
	enum { CHUNKSIZE_START = 20 };

public:

	//	Constructor takes count of items for initial chunk size.
	//
	CPoolAllocator (int ciChunkSize = CHUNKSIZE_START) :
		m_phbCurrent(NULL),
		m_piFreeChain(NULL),
		m_ciChunkSize(ciChunkSize)
	{
		//	A CHAINITEM struct will be "applied over" free items to chain
		//	them together.
		//	The actual items MUST be large enough to accomodate this.
		//
		Assert (sizeof(T) >= sizeof(CHAINITEM));
	};
	~CPoolAllocator()
	{
		//	Walk the list of blocks we allocated and free them.
		//
		while (m_phbCurrent)
		{
			CHAINBUFHDR * phbTemp = m_phbCurrent->phbNext;
			ExFree (m_phbCurrent);
			m_phbCurrent = phbTemp;
		}
	}

	//	------------------------------------------------------------------------
	//	GetItem
	//	Return an item from the pool to our caller.
	//	We get the item from the free chain, or from the next block of items.
	//
	T * GetItem()
	{
		T * ptToReturn;

		if (m_piFreeChain)
		{
			//	The free chain is non-empty.  Return the first item here.
			//
			ptToReturn = reinterpret_cast<T *>(m_piFreeChain);
			m_piFreeChain = m_piFreeChain->piNext;
		}
		else
		{
			//	The free chain is empty.  We must grab a never-used item from
			//	the current block.
			//
			if (!m_phbCurrent ||
				(m_phbCurrent->cItemsUsed == m_phbCurrent->cItems))
			{
				//	There are no more items in the current block.
				//	Allocate a whole new block of items.
				//
				CHAINBUFHDR * phbNew = static_cast<CHAINBUFHDR *>(
					ExAlloc (sizeof(CHAINBUFHDR) +
							 (m_ciChunkSize * sizeof(T))));
				//	The allocators CAN FAIL.  Handle this case!
				if (!phbNew)
					return NULL;
				phbNew->cItems = m_ciChunkSize;
				phbNew->cItemsUsed = 0;
				phbNew->phbNext = m_phbCurrent;
				m_phbCurrent = phbNew;
			}

			//	Now we should have a block with an unused item for us to return.
			//
			Assert (m_phbCurrent &&
					(m_phbCurrent->cItemsUsed < m_phbCurrent->cItems));
			ptToReturn = & m_phbCurrent->rgtPool[ m_phbCurrent->cItemsUsed++ ];
		}
		Assert (ptToReturn);
		return ptToReturn;
	}

	//	------------------------------------------------------------------------
	//	FreeItem
	//	The caller is done with this item.  Add it to our free chain.
	//
	void FreeItem (T * pi)
	{
		//	Add the item to the free chain.
		//	To do this without allocating more memory, we use the item's
		//	storage to hold our next-pointer.
		//	The actual items MUST be large enough to accomodate this.
		//
		reinterpret_cast<CHAINITEM *>(pi)->piNext = m_piFreeChain;
		m_piFreeChain = reinterpret_cast<CHAINITEM *>(pi);
	}

};



//	========================================================================
//
//	TEMPLATE CLASS CCache
//
//	A generic hash cache template.  Items in the cache uniquely map keys of
//	type _K to values of type _Ty.  Keys and values are copied when
//	they are added to the cache; there is no "ownership".
//
//	The key (type _K) must provide methods hash and isequal.  These methods
//	will be used to hash and compare the keys.
//
//
//	Add()
//		Adds an item (key/value pair) to the cache.  Returns a reference
//		to the added item's value.
//
//	Set()
//		Sets an item's value, adding the item if it doesn't already exist.
//		Returns a reference to the added item's value.
//
//	Lookup()
//		Looks for an item with the specified key.  If the item exists,
//		returns a pointer to its value, otherwise returns NULL.
//
//	FFetch()
//		Boolean version of Lookup().
//
//	Remove()
//		Removes the item associated with a particular key.
//		Does nothing if there is no item with that key.
//
//	Clear()
//		Removes all items from the cache.
//
//	ForEach()
//		Applies an operation, specified by an operator object passed in
//		as a parameter, to all of the items in the cache.
//
//	ForEachMatch()
//		Applies an operation, specified by an operator object passed in
//		as a parameter, to each item in the cache that matches the provided key.
//
//	Additional functions proposed
//	Rehash - currently ITP only
//		Resize the table & re-add all items.
//	DumpCacheUsage() - NYI
//		Dump the bookkeeping data about the cache.
//
template<class _K, class _Ty>
class CCache
{
	//	---------------------------------------------------------------------
	//	Cache Entry structures
	//
	struct Entry
	{
		struct Entry * peNext;
		_K key;
		_Ty data;
#ifdef	DBG
		BOOL fValid;		// Is this entry valid?
#endif	// DBG

		//	CONSTRUCTORS
		Entry (const _K& k, const _Ty& d) :
				key(k),
				data(d)
		{
		};
		//
		// The following is to get around the fact that the store has
		//   defined a "new" macro which makes using the new operator to
		//   do in place initialization very difficult
		//
		void EntryInit (const _K& k, const _Ty& d) {
			key = k;
			data = d;
		};
	};

	struct TableEntry	//HashLine
	{
		BOOL fLineValid;			// Is this cache line valid?
		Entry * peChain;
#ifdef DBG
		int cEntries;				// Number of entries in this line in the cache.
		mutable BYTE cAccesses;		// Bookkeeping
#endif // DBG
	};

	//	---------------------------------------------------------------------
	//	The hash table data
	//
	int m_cSize;			// Size of the hash table.
	auto_heap_ptr<TableEntry> m_argTable;	// The hash table.
	int m_cItems;			// Current number of items in the cache.

	//	---------------------------------------------------------------------
	//	Pool allocator to alloc nodes
	//
	CPoolAllocator<Entry> m_poolalloc;

	//	---------------------------------------------------------------------
	//	Constant (enum) for our default initial count of lines in the cache.
	//	NOTE: Callers should really pick their own best size.
	//	This size is prime to try to force fewer collisions.
	//
	enum { CACHESIZE_START = 37 };

#ifdef	DBG
	//	---------------------------------------------------------------------
	//	Bookkeeping bits
	//
	int m_cCollisions;		//	Adds that hit the same chain
	mutable int m_cHits;	//	Lookup/Set hits
	mutable int m_cMisses;	//	Lookup/Set misses
#endif	// DBG


	//	---------------------------------------------------------------------
	//	Helper function to build the table
	//
	BOOL FBuildTable()
	{
		Assert (!m_argTable.get());

		//	Allocate space for the number of cache lines we need (m_cSize).
		//
		m_argTable = reinterpret_cast<TableEntry *>(ExAlloc (
			m_cSize * sizeof(TableEntry)));
		//	The allocators CAN FAIL.  Handle this case!
		if (!m_argTable.get())
			return FALSE;
		ZeroMemory (m_argTable.get(), m_cSize * sizeof(TableEntry));
		return TRUE;
	}

	//	---------------------------------------------------------------------
	//	CreateEntry
	//	Create a new entry to add to the cache.
	//
	Entry * CreateEntry(const _K& k, const _Ty& d)
	{
		Entry * peNew = m_poolalloc.GetItem();
		//	The allocators CAN FAIL.  Handle this case!
		if (!peNew)
			return NULL;
		ZeroMemory (peNew, sizeof(Entry));
//		peNew = new (peNew) Entry(k,d);
		peNew->EntryInit (k,d);
#ifdef	DBG
		peNew->fValid = TRUE;
#endif	// DBG
		return peNew;
	}

	void DeleteEntry(Entry * pe)
	{
		pe->~Entry();
#ifdef	DBG
		pe->fValid = FALSE;
#endif	// DBG
		m_poolalloc.FreeItem (pe);
	}

	//	NOT IMPLEMENTED
	//
	CCache (const CCache&);
	CCache& operator= (const CCache&);

public:
	//	=====================================================================
	//
	//	TEMPLATE CLASS IOp
	//
	//		Operator base class interface used in ForEach() operations
	//		on the cache.
	//		The operator can return FALSE to cancel iteration, or TRUE to
	//		continue walking the cache.
	//
	class IOp
	{
		//	NOT IMPLEMENTED
		//
		IOp& operator= (const IOp&);

	public:
		virtual BOOL operator() (const _K& key,
								 const _Ty& value) = 0;
	};

	//	=====================================================================
	//
	//	CREATORS
	//
	CCache (int cSize = CACHESIZE_START) :
			m_cSize(cSize),
			m_cItems(0)
	{
		Assert (m_cSize);	// table size of zero is invalid!
							// (and would cause div-by-zero errors later!)
#ifdef DBG
		m_cCollisions = 0;
		m_cHits = 0;
		m_cMisses = 0;
#endif // DBG
	};
	~CCache()
	{
		//	If we have a table (FInit was successfully called), clear it.
		//
		if (m_argTable.get())
			Clear();
		//	Auto-pointer will clean up the table.
	};

	BOOL FInit()
	{
		//	Set up the cache with the provided initial size.
		//	When running under the store (exdav.dll) THIS CAN FAIL!
		//
		return FBuildTable();
	}

	//	=====================================================================
	//
	//	ACCESSORS
	//

	//	--------------------------------------------------------------------
	//	CItems
	//	Returns the number of items in the cache.
	//
	int CItems() const
	{
		return m_cItems;
	}

	//	--------------------------------------------------------------------
	//	Lookup
	//	Find the first item in the cache that matches this key.
	//	key.hash is used to find the correct line of the cache.
	//	key.isequal is called on each item in the collision chain until a
	//	match is found.
	//
	_Ty * Lookup (const _K& key) const
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash(m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Do we have any entries in this cache line?
		//	If this cache line is not valid, we have no entries -- NOT found.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
#ifdef	DBG
					m_cHits++;
#endif	// DBG
					return &pe->data;
				}
				pe = pe->peNext;
			}
		}

#ifdef	DBG
		m_cMisses++;
#endif	// DBG

		return NULL;
	}

	//	--------------------------------------------------------------------
	//	FFetch
	//	Boolean-returning wrapper for Lookup.
	//
	BOOL FFetch (const _K& key, _Ty * pValueRet) const
	{
		_Ty * pValueFound = Lookup (key);
		if (pValueFound)
		{
			*pValueRet = *pValueFound;
			return TRUE;
		}

		return FALSE;
	}

	//	--------------------------------------------------------------------
	//	ForEach
	//	Seek through the cache, calling the provided operator on each item.
	//	The operator can return FALSE to cancel iteration, or TRUE to continue
	//	walking the cache.
	//
	//	NOTE: This function is built to allow deletion of the item being
	//	visited (see the comment inside the while loop -- fetch a pointer
	//	to the next item BEFORE calling the visitor op), BUT other
	//	deletes and adds are not "supported" and will have undefined results.
	//	Two specific disaster scenarios:  delete of some other item could
	//	actually delete the item we pre-fetched, and we will crash on the
	//	next time around the loop.  add of any item during the op callback
	//	could end up adding the item either before or after our current loop
	//	position, and thus might get visited, or might not.
	//
	void ForEach (IOp& op) const
	{
		//	If we don't have any items, quit now!
		//
		if (!m_cItems)
			return;

		Assert (m_argTable.get());

		//	Loop through all items in the cache, calling the
		//	provided operator on each item.
		//
		for (int iHash = 0; iHash < m_cSize; iHash++)
		{
			//	Look for valid cache entries.
			//
			if (m_argTable[iHash].fLineValid)
			{
				Entry * pe = m_argTable[iHash].peChain;
				while (pe)
				{
					//	To support deleting inside the op,
					//	fetch the next item BEFORE calling the op.
					//
					Entry * peNext = pe->peNext;

					Assert (pe->fValid);

					//	Found a valid entry.  Call the operator.
					//	If the operator returns TRUE, keep looping.
					//	If he returns FALSE, quit the loop.
					//
					if (!op (pe->key, pe->data))
						return;

					pe = peNext;
				}
			}
		}
	}

	//	--------------------------------------------------------------------
	//	ForEachMatch
	//	Seek through the cache, calling the provided operator on each item
	//	that has a matching key.  This is meant to be used with a cache
	//	that may have duplicate items.
	//	The operator can return FALSE to cancel iteration, or TRUE to continue
	//	walking the cache.
	//
	void ForEachMatch (const _K& key, IOp& op) const
	{
		//	If we don't have any items, quit now!
		//
		if (!m_cItems)
			return;

		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash(m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Only process if this row of the cache is valid.
		//
		if (m_argTable[iHash].fLineValid)
		{
			//	Loop through all items in this row of the cache, calling the
			//	provided operator on each item.
			//
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				//	To support deleting inside the op,
				//	fetch the next item BEFORE calling the op.
				//
				Entry * peNext = pe->peNext;

				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
					//	Found a matching entry.  Call the operator.
					//	If the operator returns TRUE, keep looping.
					//	If he returns FALSE, quit the loop.
					//
					if (!op (pe->key, pe->data))
						return;
				}

				pe = peNext;
			}
		}
	}

	//	=====================================================================
	//
	//	MANIPULATORS
	//

	//	--------------------------------------------------------------------
	//	FSet
	//	Reset the value of an item in the cache, adding it if the item
	//	does not yet exist.
	//
	BOOL FSet (const _K& key, const _Ty& value)
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Look for valid cache entries.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
#ifdef	DBG
					m_cHits++;
#endif	// DBG
					pe->data = value;
					return TRUE;
				}
				pe = pe->peNext;
			}
		}

#ifdef	DBG
		m_cMisses++;
#endif	// DBG

		//	The items does NOT exist in the cache.  Add it now.
		//
		return FAdd (key, value);
	}

	//	--------------------------------------------------------------------
	//	FAdd
	//	Add an item to the cache.
	//	WARNING: Duplicate keys will be blindly added here!  Use FSet()
	//	if you want to change the value for an existing item.  Use Lookup()
	//	to check if a matching item already exists.
	//$LATER: On DBG, scan the list for duplicate keys.
	//
	BOOL FAdd (const _K& key, const _Ty& value)
	{
		//	Create a new element to add to the chain.
		//	NOTE: This calls the copy constructors for the key & value!
		//
		Entry * peNew = CreateEntry (key, value);
		//	The allocators CAN FAIL.  Handle this case!
		if (!peNew)
			return FALSE;

		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cEntries++;
		if (m_argTable[iHash].peChain)
			m_cCollisions++;
		else
			pte->cAccesses = 0;
#endif	// DBG

		//	Link this new element into the chain.
		//
		peNew->peNext = m_argTable[iHash].peChain;
		m_argTable[iHash].peChain = peNew;

		m_argTable[iHash].fLineValid = TRUE;
		m_cItems++;

		return TRUE;
	}

	//	--------------------------------------------------------------------
	//	Remove
	//	Remove an item from the cache.
	//$REVIEW: Does this need to return a "found" boolean??
	//
	void Remove (const _K& key)
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	If this cache line is not valid, we have no entries --
		//	nothing to remove.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			Entry * peNext = pe->peNext;
			Assert (pe->fValid);

			//	Delete first item in chain.
			//
			if (key.isequal (pe->key))
			{
				//	Snip the item to delete (pe) out of the chain.
				m_argTable[iHash].peChain = peNext;
				if (!peNext)
				{
					//	We deleted the last item.  This line is empty.
					//
					m_argTable[iHash].fLineValid = FALSE;
				}

				//	Delete entry to destroy the copied data (value) object.
				DeleteEntry (pe);
				m_cItems--;
#ifdef	DBG
				pte->cEntries--;
#endif	// DBG
			}
			else
			{
				//	Lookahead compare & delete.
				//
				while (peNext)
				{
					Assert (peNext->fValid);

					if (key.isequal (peNext->key))
					{
						//	Snip peNext out of the chain.
						pe->peNext = peNext->peNext;

						//	Delete entry to destroy the copied data (value) object.
						DeleteEntry (peNext);
						m_cItems--;
#ifdef	DBG
						pte->cEntries--;
#endif	// DBG
						break;
					}
					//	Advance
					pe = peNext;
					peNext = pe->peNext;
				}
			}
		}
	}

	//	--------------------------------------------------------------------
	//	Clear
	//	Clear all items from the cache.
	//	NOTE: This does not destroy the table -- the cache is still usable
	//	after this call.
	//
	void Clear()
	{
		if (m_argTable.get())
		{
			//	Walk the cache, checking for valid lines.
			//
			for (int iHash = 0; iHash < m_cSize; iHash++)
			{
				//	If the line if valid, look for items to clear out.
				//
				if (m_argTable[iHash].fLineValid)
				{
					Entry * pe = m_argTable[iHash].peChain;
					//	The cache line was marked as valid.  There should be
					//	at least one item here.
					Assert (pe);

					//	Walk the chain of items in this cache line.
					//
					while (pe)
					{
						Entry * peTemp = pe->peNext;
						Assert (pe->fValid);
						//	Delete entry to destroy the copied data (value) object.
						DeleteEntry (pe);
						pe = peTemp;
					}
				}

				//	Clear out our cache line.
				//
				m_argTable[iHash].peChain = NULL;
				m_argTable[iHash].fLineValid = FALSE;

#ifdef	DBG
				//	Clear out the bookkeeping bits in the cache line.
				//
				m_argTable[iHash].cEntries = 0;
				m_argTable[iHash].cAccesses = 0;
#endif	// DBG
			}

			//	We have no more items.
			//
			m_cItems = 0;
		}
	}

#ifdef	ITP_USE_ONLY
	//	---------------------------------------------------------------------
	//	Rehash
	//	Re-allocates the cache's hash table and re-hashes all items.
	//	NOTE: If this call fails (due to memory failure), the old hash table
	//	is restored so that we don't lose any the items.
	//	**RA** This call has NOT been tested in production (shipping) code!
	//	**RA** It is provided here for ITP use only!!!
	//
	BOOL FRehash (int cNewSize)
	{
		Assert (m_argTable.get());

		//	Swap out the old table and build a new one.
		//
		auto_heap_ptr<TableEntry> pOldTable ( m_argTable.relinquish() );
		int cOldSize = m_cSize;

		Assert (pOldTable.get());
		m_cSize = cNewSize;

		if (!FBuildTable())
		{
			Assert (pOldTable.get());
			Assert (!m_argTable.get());

			//	Restore the old table.
			//
			m_cSize = cOldSize;
			m_argTable = pOldTable.relinquish();
			return FALSE;
		}

		//	If no items in the cache, we're done!
		//
		if (!m_cItems)
		{
			return TRUE;
		}

		//	Loop through all items in the cache (old table), placing them
		//	into the new table.
		//
		for ( int iHash = 0; iHash < cOldSize; iHash++ )
		{
			//	Look for valid cache entries.
			//
			if (pOldTable[iHash].fLineValid)
			{
				Entry * pe = pOldTable[iHash].peChain;
				while (pe)
				{
					//	Keep track of next item.
					Entry * peNext = pe->peNext;

					Assert (pe->fValid);

					//	Found a valid entry.  Place it in the new hash table.
					//
					int iHashNew = pe->key.hash (m_cSize);
					pe->peNext = m_argTable[iHashNew].peChain;
					m_argTable[iHashNew].peChain = pe;
					m_argTable[iHashNew].fLineValid = TRUE;
#ifdef	DBG
					m_argTable[iHashNew].cEntries++;
#endif	// DBG
					pe = peNext;
				}
			}
		}

		//	We're done re-filling the cache.
		//
		return TRUE;
	}
#endif	// ITP_USE_ONLY

};


//	========================================================================
//	COMMON KEY CLASSES
//	========================================================================

//	========================================================================
//	class DwordKey
//		Key class for any dword data that can be compared with ==.
//
class DwordKey
{
private:
	DWORD m_dw;

public:
	DwordKey (DWORD dw) : m_dw(dw) {}

	DWORD Dw() const
	{
		return m_dw;
	}

	int DwordKey::hash (const int rhs) const
	{
		return (m_dw % rhs);
	}

	bool DwordKey::isequal (const DwordKey& rhs) const
	{
		return (rhs.m_dw == m_dw);
	}
};

//	========================================================================
//	class PvoidKey
//		Key class for any pointer data that can be compared with ==.
//
class PvoidKey
{
private:
	PVOID m_pv;

public:
	PvoidKey (PVOID pv) : m_pv(pv) {}

	//	operators for use with the hash cache
	//
	int PvoidKey::hash (const int rhs) const
	{
		//	Since we are talking about ptrs, we want
		//	to shift the pointer such that the hash
		//	values don't tend to overlap due to alignment
		//	NOTE: This shouldn't matter if you choose your hash table size
		//	(rhs) well.... but it also doesn't hurt.
		//
		return (int)((reinterpret_cast<UINT_PTR>(m_pv) >> ALIGN_NATURAL) % rhs);
	}

	bool PvoidKey::isequal (const PvoidKey& rhs) const
	{
		//	Just check if the values are equal.
		//
		return (rhs.m_pv == m_pv);
	}
};


//	========================================================================
//
//	CLASS Int64Key
//
//		__int64-based key class for use with the CCache (hashcache).
//
class Int64Key
{
private:
	__int64 m_i64;

	//	NOT IMPLEMENTED
	//
	bool operator< (const Int64Key& rhs) const;

public:
	Int64Key (__int64 i64) :
			m_i64(i64)
	{
	};

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		//	Don't even bother with the high part of the int64.
		//	The mod operation would lose that part anyway....
		//
		return ( static_cast<UINT>(m_i64) % rhs );
	}

	BOOL isequal (const Int64Key& rhs) const
	{
		//	Just check if the ids are equal.
		//
		return ( m_i64 == rhs.m_i64 );
	}
};

//	========================================================================
//	CLASS GuidKey
//	Key class for per-MDB cache of prop-mapping tables.
//
class GuidKey
{
private:
	const GUID * m_pguid;

public:
	GuidKey (const GUID * pguid) :
			m_pguid(pguid)
	{
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_pguid->Data1 % rhs);
	}

	bool isequal (const GuidKey& rhs) const
	{
		return (!!IsEqualGUID (*m_pguid, *rhs.m_pguid));
	}
};


//	========================================================================
//	CLASS StoredGuidKey
//	Key class for per-MDB cache of prop-mapping tables.
//
class StoredGuidKey
{
private:
	GUID m_guid;

public:
	StoredGuidKey (const GUID guid)
	{
		CopyMemory(&m_guid, &guid, sizeof(GUID));
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_guid.Data1 % rhs);
	}

	bool isequal (const StoredGuidKey& rhs) const
	{
		return (!!IsEqualGUID (m_guid, rhs.m_guid));
	}
};




#endif // !_EX_GENCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\hdriter.h ===
/*
 *	H D R I T E R . H
 *
 *	Comma-separated header iterator
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _HDRITER_H_
#define _HDRITER_H_

//	Check if the given character is whitespace
//
template<class X>
inline BOOL WINAPI FIsWhiteSpace( const X ch )
{
	BOOL f;

	if (sizeof(X) == sizeof(WCHAR))
	{
		f = !!wcschr(gc_wszLWS, static_cast<const WCHAR>(ch));
	}
	else
	{
		f = !!strchr(gc_szLWS, static_cast<const CHAR>(ch));;
	}

	return f;
}

//	Comma-separated header iterator -------------------------------------------
//
template<class T>
class HDRITER_TEMPLATE
{
private:

	const T *			m_pszHdr;
	const T *			m_pch;
	StringBuffer<T>		m_buf;

	//  NOT IMPLEMENTED
	//
	HDRITER_TEMPLATE& operator=( const HDRITER_TEMPLATE& );
	HDRITER_TEMPLATE( const HDRITER_TEMPLATE& );

public:

	HDRITER_TEMPLATE (const T * psz=0) : m_pszHdr(psz), m_pch(psz) {}
	~HDRITER_TEMPLATE() {}

	//	Accessors -------------------------------------------------------------
	//
	void Restart()					{ m_pch = m_pszHdr; }
	void NewHeader(const T * psz)	{ m_pch = m_pszHdr = psz; }
	const T * PszRaw(VOID)	const	{ return m_pch; }

	const T * PszNext(VOID)
	{
		const T * psz;
		const T * pszEnd;

		//	If no header existed, then there is nothing to do
		//
		if (m_pch == NULL)
			return NULL;

		//	Eat all the white space
		//
		while (*m_pch && FIsWhiteSpace<T>(*m_pch))
			m_pch++;

		//	There is nothing left to process
		//
		if (*m_pch == 0)
			return NULL;

		//	Record the start of the current segment and zip
		//	along until you find the end of the new segment
		//
		psz = m_pch;
		while (*m_pch && (*m_pch != ','))
			m_pch++;

		//	Need to eat all the trailing white spaces
		//
		pszEnd = m_pch - 1;
		while ((pszEnd >= psz) && FIsWhiteSpace<T>(*pszEnd))
			pszEnd--;

		//	The difference between, the two pointers gives us
		//	the size of the current entry.
		//
		m_buf.AppendAt (0, static_cast<UINT>(pszEnd - psz + 1) * sizeof(T), psz);
		m_buf.FTerminate ();

		//	Skip the trailing comma, if any.
		//
		if (*m_pch == ',')
			m_pch++;

		//	Return the string
		//
		return m_buf.PContents();
	}
};

typedef HDRITER_TEMPLATE<CHAR>	HDRITER;
typedef HDRITER_TEMPLATE<CHAR>	HDRITER_A;
typedef HDRITER_TEMPLATE<WCHAR>	HDRITER_W;

#endif // _HDRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\exmem.h ===
/*
 *	E X M E M . H
 *
 *	Defines a set of external functions that provide memory allocation
 *	for common code between impls and store-side processes.  The memory
 *	allocators defined here can fail and callers are responsible for
 *	checking the return values.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_EXMEM_H_
#define	_EX_EXMEM_H_

extern LPVOID __fastcall ExAlloc( UINT cb );
extern LPVOID __fastcall ExRealloc( LPVOID lpv, UINT cb );
extern VOID __fastcall ExFree( LPVOID pv );

//	For use in RTFHTML only!!!!
//
STDMETHODIMP_(SCODE) ExMapiAlloc(ULONG ulSize, LPVOID * lppv);
STDAPI_(ULONG) ExMapiFree(LPVOID lpv);

#endif	// _EX_EXMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\idlethrd.h ===
/*=========================================================================*\

	Module:      idlethrd.h

	Copyright Microsoft Corporation 1997, All Rights Reserved.

	Author:      zyang

	Description: Idle thread implementation

\*=========================================================================*/

#ifndef _EX_IDLETHRD_H_
#define _EX_IDLETHRD_H_

#include <ex\refcnt.h>

//	Interface IIdleThreadCallBack
//
//		This is a pure virtual class. which is to be implemented by any caller
//	who wants to register a callback on the idle thread. It has two methods.
//
//		DwWait(): return the next time out value. this allows the client to
//	change the timeout value dynamically. This method is also called when the 
//	callback is register obtain the initial timeout value, in this case, zero 
//	means execute immediately.
//
//		FExecute(): called when the time out happens, client should return 
//					TRUE if client want to keep this registration
//					FALSE if the client wants to unregister
//
//	IMPORTANT:
//		As there could be huge numder of registration on the idle thread, client 
//	should not block the Execute(), otherwise, other registrations would be 
//	blocked.
//
class IIdleThreadCallBack : private CRefCountedObject,
							public IRefCounted
{
	ULONG	m_ulIndex;	//	This is to facilitate unregister	
						// 	should not be touched by the client							
						
	//	non-implemented
	//
	IIdleThreadCallBack( const IIdleThreadCallBack& );
	IIdleThreadCallBack& operator=( const IIdleThreadCallBack& );

protected:

	IIdleThreadCallBack() {};

public:
	//	Client should not touch these two methods
	//
	VOID 	SetIndex (ULONG ulIndex) {	m_ulIndex = ulIndex; }
	const ULONG	UlIndex  ()	{ return m_ulIndex; }

	//	Client should implement the following methods
	
	//	Return the next timeout, in milliseconds.
	//
	virtual DWORD	DwWait() = 0;

	//	Called when timed out
	//
	virtual BOOL	FExecute() = 0;

	// 	Tell the clients that the idle thread is being shutdown
	//
	virtual VOID	Shutdown() = 0;

	//	RefCounting -- forward all reconting requests to our refcounting
	//	implementation base class: CRefCountedObject
	//
	void AddRef() { CRefCountedObject::AddRef(); }
	void Release() { CRefCountedObject::Release(); }
};

//	Helper functions

//	FInitIdleThread
//
//	Initialize the idle thread object. It can be out only once,
//	Note this call only initialize the CIdleThread object, the 
//	idle thread is not started until the first registration
//
BOOL	FInitIdleThread();

//	FDeleteIdleThread
//	
//	Delete the idle thread object. again, it can be called only once.
//
//	Note this must be called before any other uninitialization work,
//	Because we don't own a ref to the callback object, all what we 
//	have is a pointer to the object. in the shutdown time, we must
//	clear all the callback registration before the callback object 
//	go away.
//
VOID	DeleteIdleThread();

//	FRegister
//
//	Register a callback
//
BOOL	FRegister (IIdleThreadCallBack * pCallBack);

//	Unregister
//
//	Unregister a callback
//
VOID	Unregister (IIdleThreadCallBack * pCallBack);

#endif // !_EX_IDLETHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\calcom.h ===
/*
 *	C A L C O M . H
 *
 *	Simple things, safe for use in ALL of CAL.
 *	Items in this file should NOT require other CAL libs to be linked in!
 *	Items is this file should NOT throw exceptions (not safe in exdav/exoledb).
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_CALCOM_H_
#define _EX_CALCOM_H_

#include <caldbg.h>

//	Useful defines ------------------------------------------------------------
//
//	These are used to declare global and const vars in header files!
//	This means you can do this in a header file:
//
//		DEC_CONST CHAR gc_szFoo[]  = "Foo";
//		DEC_CONST UINT gc_cchszFoo = CchConstString(gc_szFoo);
//
#define DEC_GLOBAL		__declspec(selectany)
#define DEC_CONST		extern const __declspec(selectany)

//	Helper Macros -------------------------------------------------------------
//	CElems -- Count of elements in an array
//	CbSizeWsz -- byte-size of a wide string, including space for final NULL
//
#define CElems(_rg)			(sizeof(_rg)/sizeof(_rg[0]))
#define CbSizeWsz(_cch)		(((_cch) + 1) * sizeof(WCHAR))

//  Const string length -------------------------------------------------------
//
#define CchConstString(_s)  ((sizeof(_s)/sizeof(_s[0])) - 1)

//	The whitespace checker
//
inline
BOOL FIsWhiteSpace ( IN LPCSTR pch )
{
	return 
		*pch == ' ' ||
		*pch == '\t' ||
		*pch == '\r' ||
		*pch == '\n';
}

//	String support functions --------------------------------------------------
//

inline
void
WideFromAsciiSkinny (IN CHAR * szIn,
					 OUT WCHAR * wszOut,
					 IN UINT cch)
{
	Assert (szIn);
	Assert (wszOut);
	Assert (cch);
	Assert (!IsBadReadPtr(szIn, cch * sizeof(CHAR)));
	Assert (!IsBadWritePtr(wszOut, cch * sizeof(WCHAR)));

	for (; cch; cch--)
	{
		wszOut[cch - 1] = szIn[cch - 1];
	}
}

inline
void
SkinnyFromAsciiWide (IN const WCHAR * wszIn,
					 OUT CHAR * szOut,
					 IN UINT cch)
{
	Assert (wszIn);
	Assert (szOut);
	Assert (cch);
	Assert (!IsBadReadPtr(wszIn, cch * sizeof(WCHAR)));
	Assert (!IsBadWritePtr(szOut, cch * sizeof(CHAR)));

	for (; cch; cch--)
	{
		//	Do NOT use this function on non-ASCII data!!!
		Assert (0 == (0xff00 & wszIn[cch - 1]));
		szOut[cch - 1] = static_cast<CHAR>(wszIn[cch - 1]);
	}
}

//	Global enum for DEPTH specification
//	NOTE: Not all values are valid on all calls.
//	I have tried to list the most common values first.
//
enum
{
	DEPTH_UNKNOWN = -1,
	DEPTH_ZERO,
	DEPTH_ONE,
	DEPTH_INFINITY,
	DEPTH_ONE_NOROOT,
	DEPTH_INFINITY_NOROOT,
};

//	Mapping enums to keep us building until everyone switches to use the above enum.
//$LATER: Pull this out!
//
enum STOREXT_DEPTH
{
	STOREXT_DEPTH_ZERO = DEPTH_ZERO,
	STOREXT_DEPTH_ONE = DEPTH_ONE,
	STOREXT_DEPTH_INFINITY = DEPTH_INFINITY,
};

//	Global enum for OVERWRITE/ALLOW-RENAME headers
//	Overwrite_rename is when overwrite header is absent or "f" and allow-reanme header is "t".
//	when overwrite header is explicitly "t", allow-rename is ignored. Combining these two,
//	very much dependent, headers saves us a tag in the DAVEX DIM.
//
enum
{
	OVERWRITE_UNKNOWN = 0,
	OVERWRITE_YES = 0x8,
	OVERWRITE_RENAME = 0x4
};


//	Inline functions to type cast FileTime structures to __int64 and back.
//
//	For safety, these cast using the UNALIGNED keyword to avoid any problems
//	on the Alpha if someone were to do this:
//		struct {
//			DWORD dwFoo;
//			FILETIME ft;
//		}
//	In this case, the FILETIME would be aligned on a 32-bit rather than a
//	64-bit boundary, which would be bad without UNALIGNED!
//
inline
__int64 & FileTimeCastToI64(FILETIME & ft)
{
	return *(reinterpret_cast<__int64 UNALIGNED *>(&ft));
}

inline
FILETIME & I64CastToFileTime(__int64 & i64)
{
	return *(reinterpret_cast<FILETIME UNALIGNED *>(&i64));
}

//	Special function to change from filetime-units-in-an-int64 to seconds.
//
inline
__int64
I64SecondsFromFiletimeDelta (__int64 i64FiletimeData)
{
	return 	( i64FiletimeData / 10000000i64 );
}

/*
 -	UlConModFromUserDN
 -
 *	Purpose:
 *		This is a hash on a user's legacy DN. We stole this function from
 *		MAPI (\store\src\emsmdb\logonobj.cxx who in turn stole it straight
 *		from the hash function "X65599" from the Dragon Book pp435-437.
 *		We needed to use the same algorithm as MAPI uses to select public
 *		folder replicas.
 *
 *
 *	Parameters:
 *		szDN		stringized legacy exchange DN of user
 *
 *	Returns:
 *		ulong value used in two places - in ScHandleEcNoReplicaHere() in
 *		_storext and HrSelectServerForUser in exprox
 */
inline
ULONG
UlConModFromUserDN(LPSTR szDN)
{
	ULONG	ul = 0;
	PCH		pch;

	Assert (szDN);

	for (pch = szDN; *pch; ++pch)
	{
		CHAR	ch = *pch;

		// Uppercase to eliminate case sensitivity.
		// Only teletext should be used in DN.
		if (ch >= 'a' && ch <= 'z')
			ch -= 'a' - 'A';

		// From the Dragon Book:
		// "For 32-bit integers, if we take alpha = 65599, a prime near 2^16,
		//  then overflow soon occurs during the computation... Since alpha
		//  is a prime, ignoring overflows and keeping only the lower-order
		//  32 bits seems to do well."
		ul = ul * 65599 + ch;
	}

	return ul;
}

#endif // _EX_CALCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\oldhack.h ===
//  will be public in IIS 5.0
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_GET_EXECUTE_FLAGS                (HSE_REQ_END_RESERVED+19)

# define HSE_EXEC_NO_ISA_WILDCARDS        0x00000010   // Ignore wildcards in
                                                       // ISAPI mapping when
                                                       // executing child
# define HSE_EXEC_CUSTOM_ERROR            0x00000020   // URL being sent is a
                                                       // custom error
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\nmspc.h ===
/*
 *	N M S P C . H
 *
 *	XML namespace processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_NMSPC_H_
#define _EX_NMSPC_H_

#include <ex\calcom.h>
#include <ex\autoptr.h>
#include <ex\gencache.h>
#include <ex\buffer.h>
#include <ex\sz.h>
#include <crc.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Nmspc);
#define NmspcTrace		DO_TRACE(Nmspc)

//	Namespaces ----------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszXmlns[] = L"xmlns";

//	Namespace support functions -----------------------------------------------
//
inline ULONG CchGenerateAlias (LONG lAlias, LPWSTR pwszAlias)
{
	UINT i = 0;
	Assert (pwszAlias);
	do
	{
		//	We don't have to use 'A'-'Z', use the first 16 capital
		//	letters to facilitate our computing.
		//
		pwszAlias[i++] = static_cast<WCHAR>(L'a' + (lAlias & 0xF));
		lAlias >>= 4;
	}
	while (lAlias);

	//	Ensure termination
	//
	pwszAlias[i] = 0;

	//	Return the length
	//
	NmspcTrace ("Nmspc: generating '%ws' as alias\n", pwszAlias);
	return i;
}

DEC_CONST WCHAR wchHiddenNmspcSep = L'#';
inline BOOL FIsNmspcSeparator (WCHAR wch)
{
	return ((wch == L':') ||
			(wch == L'/') ||
			(wch == L'?') ||
			(wch == L';') ||
			(wch == wchHiddenNmspcSep));
}

inline UINT CchAliasFromSizedTag (LPCWSTR pwszTag, UINT cch)
{
	LPCWSTR pwsz;

	for (pwsz = pwszTag; (pwsz - pwszTag) < static_cast<LONG>(cch); pwsz++)
		if (*pwsz == L':')
			return static_cast<UINT>(pwsz - pwszTag);

	return 0;
}

inline UINT CchNmspcFromTag (UINT cchTag, LPCWSTR pwszTag, LPCWSTR* ppwszOut)
{
	LPCWSTR pwsz;

	Assert (ppwszOut);
	*ppwszOut = pwszTag;
	for (pwsz = pwszTag + cchTag - 1; pwsz >= pwszTag; pwsz--)
	{
		if (FIsNmspcSeparator (*pwsz))
		{
			//	Since the separator is a part of the namespace,
			//	adjust accourdingly..
			//
			//$	REVIEW: We are being forced down the path of allowing namespaces
			//	that are not properly terminated.  The way we do this, is if the
			//	namespace is not properly terminated, or ends in an '#', we will
			//	append an '#' character.
			//
			//	What this means is the namespace "urn:xml-data", when assembled
			//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
			//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
			//
			//	What we are catching here is the breaking down of a fully qualified
			//	tag into it's namespace and tag components.
			//
			//	The length of the namespace will not include the trailing '#'
			//	character -- ever!
			//
			*ppwszOut = pwsz + 1;
			if (wchHiddenNmspcSep == *pwsz)
				--pwsz;
			//
			//$ REVIEW: end.

			break;
		}
	}
	return static_cast<UINT>(1 + pwsz - pwszTag);
}

//	class CNmspc --------------------------------------------------------------
//
class CNmspc
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:

	auto_heap_ptr<WCHAR>	m_pszHref;
	UINT					m_cchAlias;
	UINT					m_cchHref;

	auto_heap_ptr<WCHAR>	m_pszLongAlias;
	WCHAR					m_szAlias[20];
	LPWSTR					m_pszAlias;

	//	Used for the scoping of namespaces
	//
	auto_ref_ptr<CNmspc>	m_pnsScoped;
	auto_ref_ptr<CNmspc>	m_pnsSiblings;

	//	non-implemented
	//
	CNmspc(const CNmspc& p);
	CNmspc& operator=(const CNmspc& p);

public:

	CNmspc () :
			m_cRef(1), // com-style refcounting
			m_cchHref(0),
			m_cchAlias(0)
	{
		m_szAlias[0] = 0;
		m_pszAlias = m_szAlias;
	}

	SCODE ScSetHref (LPCWSTR pszHref, UINT cch)
	{
		Assert (m_pszHref.get() == NULL);

		//	Copy the namespace locally
		//
		UINT cb = CbSizeWsz(cch);

		//$	REVIEW: We are being forced down the path of allowing namespaces
		//	that are not properly terminated.  The way we do this, is if the
		//	namespace is not properly terminated, or ends in an '#', we will
		//	append an '#' character.
		//
		//	What this means is the namespace "urn:xml-data", when assembled
		//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
		//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
		//
		//	What we catch here, is the handling for an unterminated namespace.
		//	If the namespace ends in a non-terminator or a '#' character, then
		//	we will want to append one.
		//
		//	It is important to note that the appended char is NOT included in
		//	the total character count of the href.
		//
		//  If we are dealing with the empty namespace, we will not append a #.
		//
		BOOL fUnterminated = FALSE;

		if (0 != cch)
		{
			Assert (pszHref);
			WCHAR wch = pszHref[cch - 1];
			if ((wchHiddenNmspcSep == wch) || !FIsNmspcSeparator(wch))
			{
				NmspcTrace ("Nmspc: WARNING: namespace does not have a separator\n"
							"  as the last character of the namespace.  DAV will\n"
							"  add a '#' to the namespace for internal processing.\n");

				fUnterminated = TRUE;

				//	Make sure there is space for the appended character
				//
				cb += sizeof(WCHAR);
			}
		}
		//
		//$	REVIEW: end;

		//	Allocate space and copy everything over
		//
		m_pszHref = static_cast<LPWSTR>(ExAlloc(cb));
		if (NULL == m_pszHref.get())
			return E_OUTOFMEMORY;

		//  Note:  CopyMemory does not dereference pszHref if cch equals 0.
		//
		CopyMemory (m_pszHref, pszHref, cch * sizeof(WCHAR));
		m_cchHref = cch;

		//	If it is unterminated, handle that here
		//
		if (fUnterminated)
		{
			NmspcTrace ("Nmspc: WARNING: '#' appended to mis-terminated namespace\n");
			m_pszHref[cch++] = wchHiddenNmspcSep;

			Assert (CchHref() == m_cchHref);
			Assert (PszHref() == m_pszHref.get());
			Assert (wchHiddenNmspcSep == m_pszHref[m_cchHref]);
		}

		//	Ensure termination
		//
		m_pszHref[cch] = 0;
		NmspcTrace ("Nmspc: href defined\n"
					"-- m_pszHref: %ws\n"
					"-- m_szAlias: %ws\n",
					m_pszHref,
					m_szAlias);

		return S_OK;
	}

	SCODE ScSetAlias (LPCWSTR pszAlias, UINT cchAlias)
	{
		//	Copy the alias locally
		//
		Assert (pszAlias);
		UINT cb = CbSizeWsz(cchAlias);
		if (cb <= sizeof(m_szAlias))
		{
			CopyMemory (m_szAlias, pszAlias, cchAlias * sizeof(WCHAR));
			m_pszAlias = m_szAlias;
		}
		else
		{
			m_pszLongAlias.realloc (cb);
			if (NULL == m_pszLongAlias.get())
				return E_OUTOFMEMORY;

			CopyMemory (m_pszLongAlias, pszAlias, cchAlias * sizeof(WCHAR));
			m_pszAlias = m_pszLongAlias.get();
		}
		m_pszAlias[cchAlias] = L'\0';
		m_cchAlias = cchAlias;
		NmspcTrace ("Nmspc: alias defined\n"
					"-- m_pszHref: %ws\n"
					"-- m_szAlias: %ws\n",
					m_pszHref,
					m_pszAlias);

		return S_OK;
	}

	UINT CchHref()		const { return m_cchHref; }
	UINT CchAlias()		const { return m_cchAlias; }
	LPCWSTR PszHref()	const { return m_pszHref; }
	LPCWSTR PszAlias()	const { return m_pszAlias; }

	//	Namespace Scoping -----------------------------------------------------
	//
	CNmspc* PnsScopedNamespace() const { return m_pnsScoped.get(); }
	void SetScopedNamespace (CNmspc* pns)
	{
		m_pnsScoped = pns;
	}

	CNmspc* PnsSibling() const { return m_pnsSiblings.get(); }
	void SetSibling (CNmspc* pns)
	{
		m_pnsSiblings = pns;
	}

};

//	class CNmspcCache ---------------------------------------------------------
//
class CNmspcCache
{
public:

	typedef CCache<CRCWszN, auto_ref_ptr<CNmspc> > NmspcCache;
	NmspcCache					m_cache;

protected:

	ChainedStringBuffer<WCHAR>	m_sb;

	//	Key generation
	//
	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns) = 0;

	//	non-implemented
	//
	CNmspcCache(const CNmspcCache& p);
	CNmspcCache& operator=(const CNmspcCache& p);

public:

	CNmspcCache()
	{
		INIT_TRACE(Nmspc);
	}

	SCODE ScInit() { return m_cache.FInit() ? S_OK : E_OUTOFMEMORY; }

	void CachePersisted (auto_ref_ptr<CNmspc>& pns)
	{
		auto_ref_ptr<CNmspc>* parp = NULL;
		CRCWszN key = IndexKey(pns);

		//	Take a quick peek to see if the index already
		//	exists in the cache.  If it does, then setup
		//	the scoping such that when the namespace falls
		//	out of scope, the original namespace will be
		//	restored.
		//
		if (NULL != (parp = m_cache.Lookup (key)))
		{
			NmspcTrace ("Nmspc: scoped redefinition of namespace:\n"
						"-- old: '%ws' as '%ws'\n"
						"-- new: '%ws' as '%ws'\n",
						(*parp)->PszHref(),
						(*parp)->PszAlias(),
						pns->PszHref(),
						pns->PszAlias());

			pns->SetScopedNamespace(parp->get());
		}

		//	Setup the index
		//
		NmspcTrace ("Nmspc: indexing namespace\n"
					"-- ns: '%ws' as '%ws'\n",
					pns->PszHref(),
					pns->PszAlias());

		(void) m_cache.FAdd (key, pns);
	}

	void RemovePersisted (auto_ref_ptr<CNmspc>& pns)
	{
		auto_ref_ptr<CNmspc> pnsScoped;

		//	Disconnect the index to this namespace
		//
		NmspcTrace ("Nmspc: namespace falling out of scope\n"
					"-- ns: '%ws' as '%ws'\n",
					pns->PszHref(),
					pns->PszAlias());

		m_cache.Remove (IndexKey(pns));

		//	If there was an index in existance before this
		//	namespace came into scope, reinstate it here.
		//
		pnsScoped = pns->PnsScopedNamespace();
		if (pnsScoped.get())
		{
			NmspcTrace ("Nmspc: restoring redefined namespace:\n"
						"-- restored: '%ws' as '%ws'\n"
						"-- from: '%ws' as '%ws'\n",
						pnsScoped->PszHref(),
						pnsScoped->PszAlias(),
						pns->PszHref(),
						pns->PszAlias());

			(void) m_cache.FAdd (IndexKey(pnsScoped), pnsScoped);
		}
	}
};

//	class CParseNmspcCache ----------------------------------------------------
//
class CParseNmspcCache : public CNmspcCache
{
	//	non-implemented
	//
	CParseNmspcCache(const CNmspcCache& p);
	CParseNmspcCache& operator=(const CNmspcCache& p);

	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns)
	{
		return CRCWszN (pns->PszAlias(), pns->CchAlias());
	}

	//	Namespace lookup ------------------------------------------------------
	//
	BOOL FNmspcFromAlias (LPCWSTR pszAlias, UINT cch, auto_ref_ptr<CNmspc>& pns)
	{
		//	In this scenario, the namespace should already exist.
		//	if it doesn't things will not go well.
		//
		auto_ref_ptr<CNmspc> * parp = NULL;
		parp = m_cache.Lookup (CRCWszN(pszAlias, cch));
		if (parp)
		{
			pns = *parp;
			return TRUE;
		}
		return FALSE;
	}

public:

	CParseNmspcCache()
	{
	}

	//	Token translations ----------------------------------------------------
	//
	SCODE TranslateToken (LPCWSTR* ppwszTok,
						  ULONG* pcchTok,
						  LPCWSTR* ppwszNmspc,
						  ULONG* pcchNmspc)
	{
		auto_ref_ptr<CNmspc> pns;
		SCODE sc = S_FALSE;

		Assert (pcchTok && (*pcchTok != 0));
		Assert (ppwszTok && *ppwszTok);

		Assert (pcchNmspc);
		Assert (ppwszNmspc);

		//	See if there is an namespace that matches the persisted
		//	alias.
		//
		if (FNmspcFromAlias (*ppwszTok, *pcchNmspc, pns))
		{
			//	Passback the namespace
			//
			*pcchNmspc = pns->CchHref();
			*ppwszNmspc = pns->PszHref();

			//$	REVIEW: We are being forced down the path of allowing namespaces
			//	that are not properly terminated.  The way we do this, is if the
			//	namespace is not properly terminated, or ends in an '#', we will
			//	append an '#' character.
			//
			//	What this means is the namespace "urn:xml-data", when assembled
			//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
			//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
			//
			//	What we catch here, is the first part of reconstruction of a fully
			//	qualified namespace.  If the href we want to pass back is non-
			//	terminated or ends in a '#' character, then we want to append one.
			//	When we cached the namespace object, we did the appending there.
			//	So, the character already exists, the character count just doesn't
			//	include it (see CNmspc::SetHref() above).
			//
			//  If we are dealing with the empty namespace, we will not append a #.
			//
			if (0 != pns->CchHref())
			{
				WCHAR wch = pns->PszHref()[pns->CchHref() - 1];
				if ((wchHiddenNmspcSep == wch) || !FIsNmspcSeparator(wch))
				{
					NmspcTrace ("Nmspc: WARNING: namespace is not properly terminated\n"
								"  and DAV will add in a '#' for internal processing.\n");

					Assert (wchHiddenNmspcSep == pns->PszHref()[pns->CchHref()]);
					*pcchNmspc = *pcchNmspc + 1;
				}
			}
			//
			//$	REVIEW: end.

			//	Adjust the token to refer to the tagname -- ie. the
			//	text after the namespace alias and colon.  If the alias
			//	is zero-length, then this maps to the "default" namespace
			//	and no colon skipping is done.
			//
			if (0 != pns->CchAlias())
			{
				*pcchTok = *pcchTok - (pns->CchAlias() + 1);
				*ppwszTok = *ppwszTok + (pns->CchAlias() + 1);
			}

			//	Tell the caller there is a translation
			//
			sc = S_OK;
		}
		else
		{
			//	If the caller expected a namespace, but one did not
			//	exist, it is an error.  If they didn't expect one to
			//	to exist -- ie. *pcchNmspc was 0 -- then it is not an
			//	error.  Make sure the caller knows what the real
			//	situation is.
			//
			if (0 == *pcchNmspc)
				sc = S_OK;

			//	It looks like no alias was specified, so we can just
			//	return the name as persisted.
			//
			*ppwszNmspc = NULL;
			*pcchNmspc = 0;
		}
		return sc;
	}
};

//	class CEmitterNmspcCache --------------------------------------------------
//
class CEmitterNmspcCache : public CNmspcCache
{
	LONG m_lAlias;

	//	non-implemented
	//
	CEmitterNmspcCache(const CEmitterNmspcCache& p);
	CEmitterNmspcCache& operator=(const CEmitterNmspcCache& p);

protected:

	void AdjustAliasNumber(LONG lOffset) { m_lAlias += lOffset; }

	//	Key generation
	//
	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns)
	{
		return CRCWszN (pns->PszHref(), pns->CchHref());
	}

	SCODE ScNmspcFromHref (LPCWSTR pszHref, UINT cch, auto_ref_ptr<CNmspc>& pns)
	{
		//	Lookup to see if the namespace already exists
		//
		auto_ref_ptr<CNmspc>* parp = m_cache.Lookup (CRCWszN(pszHref, cch));

		//	If it doesn't exist, then create a new one and cache it
		//
		if (parp == NULL)
		{
			WCHAR wszAlias[10];
			ULONG cchAlias;
			SCODE sc;

			//	Generate an alias to apply to this namespace and then
			//	check to see if this alias has been already used.  If
			//	not, then go ahead an use it.
			//
			cchAlias = CchGenerateAlias (m_lAlias++, wszAlias);

			//	Create a new cache item
			//
			pns.take_ownership(new CNmspc());
			if (NULL == pns.get())
				return E_OUTOFMEMORY;

			//	Set the HREF
			//
			sc = pns->ScSetHref (pszHref, cch);
			if (FAILED (sc))
				return sc;

			//	Set the alias
			//
			sc = pns->ScSetAlias (wszAlias, cchAlias);
			if (FAILED (sc))
				return sc;

			//	It is important, that the key and the return value are taken
			//	from items in the cache, otherwise the lifetime of the data
			//	may not scope the usage.
			//
			CachePersisted (pns);
			return S_FALSE;
		}
		pns = *parp;
		return S_OK;
	}

public:

	CEmitterNmspcCache() :
			m_lAlias(0)
	{
	}
};

#endif	// _EX_NMSPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\cnvt.h ===
/*
 *	C N V T . H
 *
 *	Data conversion routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CNVT_H_
#define _CNVT_H_

#include <ex\sz.h>
#include <crc.h>
#include <limits.h>
#define INT64_MIN 0x8000000000000000

//	Error return value for CchFindChar()
//
#define INVALID_INDEX ((UINT)(-1))

//	Conversion functions ------------------------------------------------------
//
UINT __fastcall CchFindChar(WCHAR, LPCWSTR, UINT);
UINT __fastcall CchSkipWhitespace(LPCWSTR, UINT);
LONG __fastcall LNumberFromParam(LPCWSTR, UINT);

HRESULT __fastcall HrHTTPDateToFileTime(LPCWSTR, FILETIME *);
HRESULT	__fastcall GetFileTimeFromParam(LPCWSTR, UINT, SYSTEMTIME *);
HRESULT __fastcall GetFileDateFromParam(LPCWSTR, UINT, SYSTEMTIME *);

BOOL __fastcall FGetSystimeFromDateIso8601(LPCWSTR, SYSTEMTIME *);
BOOL __fastcall FGetDateIso8601FromSystime(SYSTEMTIME *, LPWSTR, UINT);
BOOL __fastcall FGetDateRfc1123FromSystime(SYSTEMTIME *, LPWSTR, UINT);

VOID EncodeBase64 (LPBYTE pbIn, UINT cbIn, WCHAR* pwszOut, UINT cchOut);
VOID EncodeBase64A (LPBYTE pbIn, UINT cbIn, LPBYTE pbOut, UINT cbOut, BOOL fTerminate = TRUE);
SCODE ScDecodeBase64 (WCHAR* pwszIn, UINT cchIn, LPBYTE pbOut, UINT* pcbOut);

//	------------------------------------------------------------------------
//	CchNeededEncodeBase64
//
//	Figure the size of the string buffer needed to encode binary data of the
//	given size into a Base64 string.
//	Base64 uses 4 chars out for each 3 bytes in, AND if there is ANY
//	"remainder", it needs another 4 chars to encode the remainder.
//	("+2" BEFORE "/3" ensures that we count any remainder as a whole
//	set of 3 bytes that need 4 chars to hold the encoding.)
//
//	NOTE: This function does NOT count space for the terminating NULL.
//	The caller must add one for the terminating NULL, if desired.
//
inline
UINT
CchNeededEncodeBase64 (UINT cb)
{
	return (((cb + 2) / 3) * 4);
}


//	------------------------------------------------------------------------
//	CbNeededDecodeBase64
//
//	Figure the number of bytes of space needed to decode a Base64 string
//	of length cch (NOT counting terminal NULL -- pure strlen cch here).
//	This is the easy direction -- the padding is already in the cch!
//
inline
UINT
CbNeededDecodeBase64 (UINT cch)
{
	return ((cch / 4) * 3);
}

//	------------------------------------------------------------------------
//	CopyToWideBase64
//
//	Copy skinny base64 encoded string into the wide base64 encoded string
//	of length equal to cb. Function assumes that there is a '\0' termination
//	straight at the end that is to be copied too
//
inline
VOID CopyToWideBase64(LPCSTR psz, LPWSTR pwsz, UINT cb)
{
	//	Include '\0' termination
	//
	cb++;

	//	Copy all the stuff to the wide string
	//
	while (cb--)
	{
		pwsz[cb] = psz[cb];
	}
}

//$REVIEW: The following three do not really does not belong to any common libraries 
//$REVIEW: that are shared by davex, exdav, exoledb and exprox. 
//$REVIEW: On the other hand, we definitely don't want add a new lib for this. so just
//$REVIEW: add it here. Feel free to move them to a better location if you find one
//
//	Routines to fetch and manipulate security IDs (SIDs)
//
SCODE
ScDupPsid (PSID psidSrc,
		   DWORD dwcbSID,
		   PSID * ppsidDst);

SCODE
ScGetTokenInfo (HANDLE hTokenUser,
				DWORD * pdwcbSIDUser,
				PSID * ppsidUser);

//	CRCSid:	A SID based key.
//
class CRCSid
{
public:

	DWORD	m_dwCRC;
	DWORD	m_dwLength;
	PSID	m_psid;

	CRCSid (PSID psid)
			: m_psid(psid)
	{
		UCHAR* puch;
		Assert (psid);

		//	"Right way" -- since MSDN says not to touch the SID directly.
		puch = GetSidSubAuthorityCount (psid);
		m_dwLength = GetSidLengthRequired (*puch);	// "cannot fail" -- MSDN
		Assert (m_dwLength);	// MSDN said this call "cannot fail".

		m_dwCRC = DwComputeCRC (0,
								psid,
								m_dwLength);
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_dwCRC % rhs);
	}

	bool isequal (const CRCSid& rhs) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				(m_dwLength == rhs.m_dwLength) &&
				!memcmp (m_psid, rhs.m_psid, m_dwLength));
	}
};

//$REVIEW: These functions are needed by _storext, exdav and davex. They have
//	moved quite a bit, going from calcprops.cpp to exprops.cpp and now to 
//	cnvt.cpp. cnvt.cpp seems to be a better destination for them than 
//	exprops.cpp. I bet these functions look awfully similar to some of 
//	the ones already in this file:-)
//
SCODE ScUnstringizeData (
	IN LPCSTR pchData,
	IN UINT cchData,
	IN OUT BYTE * pb,
	IN OUT UINT * pcb);

SCODE
ScStringizeData (IN const BYTE * pb,
				 IN const UINT cb,
				 OUT LPSTR psz,
				 IN OUT UINT * pcch);

SCODE
ScStringizeDataW (	IN const BYTE * pb,
					IN const UINT cb,
					OUT LPWSTR pwsz,
					IN OUT UINT * pcch);

inline
BOOL
FCharInHexRange (char ch)
{
	return ((ch >= '0' && ch <= '9') ||
			(ch >= 'A' && ch <= 'F') ||
			(ch >= 'a' && ch <= 'f'));
}

//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	It returns similarly to the system call WideCharToMultiByte:
//
//	If the function succeeds, and cbMulti is nonzero, the return value is
//	the number of bytes written to the buffer pointed to by psz. 
//
//	If the function succeeds, and cbMulti is zero, the return value is
//	the required size, in bytes, for a buffer that can receive the translated
//	string. 
//
//	If the function fails, the return value is zero. To get extended error
//	information, call GetLastError. GetLastError may return one of the
//	following error codes:
//
//	ERROR_INSUFFICIENT_BUFFER
//	ERROR_INVALID_FLAGS
//	ERROR_INVALID_PARAMETER
//
//	See the WideCharToMultiByte MSDN pages to find out more about
//	this function and its use. The only difference is that INVALID_INDEX
//	should be used instead of -1.
//
UINT WideCharToUTF8(/* [in]  */ LPCWSTR	pwsz,
				    /* [in]  */ UINT	cchWide,
				    /* [out] */ LPSTR	psz,
				    /* [in]  */ UINT	cbMulti);

//$	REVIEW: negative values of _int64 seem to have problems in
//	the __i64toa() API.  Handle those cases ourselves by using the wrapper
//  function Int64ToPsz.
//
inline
VOID
Int64ToPsz (UNALIGNED __int64 * pI64, LPSTR pszBuf)
{
	Assert(pI64);
	Assert(pszBuf);
	BOOL fNegative = (*pI64 < 0);

	//  Note:  this workaround works for all cases except the
	//  most negative _int64 value (because it can't be inverted).
	//  Luckily __i64toa works for this case...
	//
	if (INT64_MIN == *pI64) 
		fNegative = FALSE;

	if (fNegative)
	{
		//	Stuff a negative sign into the buffer and
		//	then fix the value.
		//
		pszBuf[0] = '-';
		*pI64 = 0 - *pI64;
	}
	
	Assert ((0 == fNegative) || (1 == fNegative));
	_i64toa (*pI64, pszBuf + fNegative, 10);
}

//$	REVIEW: negative values of _int64 seem to have problems in
//	the __i64tow() API.  Handle those cases ourselves by using the wrapper
//  function Int64ToPwsz.
//
inline
VOID
Int64ToPwsz (UNALIGNED __int64 * pI64, LPWSTR pwszBuf)
{
	Assert(pI64);
	Assert(pwszBuf);
	BOOL fNegative = (*pI64 < 0);	

	//  Note:  this workaround works for all cases except the
	//  most negative _int64 value (because it can't be inverted).
	//  Luckily __i64tow works for this case...
	//
	if (INT64_MIN == *pI64) 
		fNegative = FALSE;

	if (fNegative)
	{
		//	Stuff a negative sign into the buffer and
		//	then fix the value.
		//
		pwszBuf[0] = L'-';
		*pI64 = 0 - *pI64;
	}
	
	Assert ((0 == fNegative) || (1 == fNegative));
	_i64tow (*pI64, pwszBuf + fNegative, 10);
}


#endif // _CNVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\refcnt.h ===
/*=========================================================================*\

	Module:      _refcnt.h

	Copyright Microsoft Corporation 1997, All Rights Reserved.


		Stolen from Storext.h
		
	Description: Ref counted object defintion
	
\*=========================================================================*/

#ifndef _EX_REFCNT_H_
#define _EX_REFCNT_H_

/*==========================================================================*\

	IRefCounted

    Description:  Your basic reference counting interface.

	Note:
		In most cases you shouldn't need to include this class as a base
		class in your refcounted object.  Instead you should just derive
		derive your class directly from CRefCountedObject.  You would only
		use IRefCounted with objects that can be used used where the
		code cannot or does not make assumptions on how the object
		implements its refcounting.  E.g. classes that forward refcounting
		to parent classes or derive from two concrete refcounted base
		classes.

\*==========================================================================*/

class IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IRefCounted& operator=(const IRefCounted&);

public:
	//	CREATORS
	//
	virtual ~IRefCounted() = 0 {}

	//	MANIPULATORS
	//
	virtual void AddRef() = 0;
	virtual void Release() = 0;
};


/*==========================================================================*\

	CRefCountedObject

    Description:  Provide simple reference counting for internal objects.
	NOTE: The ref-counting used here is NOT consistent with OLE/COM refcounting.
	This class was meant to be used with auto_ref_ptr.

\*==========================================================================*/

class CRefCountedObject
{

private:

	//	NOT IMPLEMENTED
	//
	//	Force an error in instances where a copy constructor
	//  was needed, but none was provided.
	//
	CRefCountedObject& operator=(const CRefCountedObject&);
    CRefCountedObject(const CRefCountedObject&);

protected:

	LONG	m_cRef;

public:

	CRefCountedObject() : m_cRef(0) {}
	virtual ~CRefCountedObject() = 0 {}

	void AddRef()
	{
		InterlockedIncrement(&m_cRef);
	}

	void Release()
	{
		if (0 == InterlockedDecrement(&m_cRef))
			delete this;
	}

};

#endif // !_EX_REFCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\refhandle.h ===
#ifndef _REFHANDLE_H_
#define _REFHANDLE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REFHANDLE.H
//
//	Copyright 1999 Microsoft Corporation, All Rights Reserved
//

#include <ex\refcnt.h>
#include <ex\autoptr.h>


//	========================================================================
//
//	CLASS IRefHandle
//
//	Implements a refcounted handle.  AddRef() and Release() replace the
//	much slower in-process DuplicateHandle() calls.
//
//	The reason for the interface is that handles may come from many sources
//	and it is not always clear what we should do once we are done with one
//	when the last ref goes away.  In the most common case (where we own the
//	raw handle) we just want to call CloseHandle().  But we don't always own
//	the raw handle.  When someone else owns the raw handle, we must use
//	their mechanisms to indicate when we are done using it.  CIFSHandle in
//	davex\exifs.cpp is one such instance.
//
class IRefHandle : public CRefCountedObject
{
	//	NOT IMPLEMENTED
	//
	IRefHandle( const IRefHandle& );
	IRefHandle& operator=( const IRefHandle& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IRefHandle()
	{
		//
		//	Start the ref count at 1.  The expectation is that we will
		//	typically use constructs like this
		//
		//		auto_ref_handle hf;
		//		hf.take_ownership(new CFooRefHandle());
		//
		//	or this
		//
		//		auto_ref_ptr<IRefHandle> pRefHandle;
		//		pRefHandle.take_ownership(new CFooRefHandle());
		//
		//	when creating these objects.
		//
		m_cRef = 1;
	}

public:
	//	CREATORS
	//
	virtual ~IRefHandle() = 0 {}

	//	ACCESSORS
	//
	virtual HANDLE Handle() const = 0;
};

//	========================================================================
//
//	CLASS CRefHandle
//
//	By far the most common form of a refcounted handle -- the one where we
//	own the raw HANDLE and must call CloseHandle() on it when we are done.
//
//	This is implemented as a simple refcounted auto_handle.
//
class CRefHandle : public IRefHandle
{
	//
	//	The handle
	//
	auto_handle<HANDLE> m_h;

	//	NOT IMPLEMENTED
	//
	CRefHandle( const CRefHandle& );
	CRefHandle& operator=( const CRefHandle& );

public:
	//	CREATORS
	//
	CRefHandle(auto_handle<HANDLE>& h)
	{
		//	Take ownership of the passed-in auto_handle
		//
		*m_h.load() = h.relinquish();
	}

	//	ACCESSORS
	//
	HANDLE Handle() const
	{
		return m_h;
	}
};

//	========================================================================
//
//	CLASS auto_ref_handle
//
//	Implements automatic refcounting on IRefHandle objects.  The idea is
//	that an auto_ref_handle can be used in most cases to replace a raw
//	HANDLE.  The main difference is that copying a raw HANDLE introduces
//	an issue of ownership, but copying an auto_ref_handle does not.
//	Typically, a raw handle is copied with an expensive DuplicateHandle()
//	call.  Copying an auto_ref_handle just does a cheap AddRef().
//
class auto_ref_handle
{
	auto_ref_ptr<IRefHandle> m_pRefHandle;

public:
	//	CREATORS
	//
	auto_ref_handle() {}

	auto_ref_handle(const auto_ref_handle& rhs)
	{
		m_pRefHandle = rhs.m_pRefHandle;
	}

	//	ACCESSORS
	//
	HANDLE get() const
	{
		return m_pRefHandle.get() ? m_pRefHandle->Handle() : NULL;
	}

	//	MANIPULATORS
	//
	auto_ref_handle& operator=(const auto_ref_handle& rhs)
	{
		if ( m_pRefHandle.get() != rhs.m_pRefHandle.get() )
			m_pRefHandle = rhs.m_pRefHandle;

		return *this;
	}

	VOID take_ownership(IRefHandle * pRefHandle)
	{
		Assert( !m_pRefHandle.get() );

		m_pRefHandle.take_ownership(pRefHandle);
	}

	//	------------------------------------------------------------------------
	//
	//	auto_ref_handle::FCreate()
	//
	//	This function serves to simplify the very specific -- but very common --
	//	case of having an auto_ref_handle take ownership of a raw HANDLE.
	//	Without this function, callers would essentially need to go through all
	//	of the same steps that we do here.  The number of different objects
	//	required to get to the final auto_ref_handle (a temporary auto_handle,
	//	a CRefHandle, and an auto_ref_ptr to hold it) and how to assemble them
	//	correctly would be confusing enough to be bug prone.  It is far better
	//	to keep things simple from the caller's perspective.
	//
	//	Returns:
	//		TRUE	if the auto_ref_handle successfully takes ownership of the
	//				specified valid handle.
	//		FALSE	if the specified handle is NULL or invalid or if there is
	//				some other failure in the function.  In the latter case
	//				the function also CLOSES THE RAW HANDLE.
	//
	//	!!! IMPORTANT !!!
	//	This function is designed to be called with the direct return value
	//	from any API that creates a raw HANDLE.  If this call fails
	//	(i.e. returns FALSE) then it will close the raw HANDLE passed in!
	//	The whole point of the auto_ref_handle class is to replace usage of
	//	the raw HANDLE.
	//
	BOOL FCreate(HANDLE h)
	{
		Assert( !m_pRefHandle.get() );

		//	Don't even bother with NULL or invalid handles.
		//
		if (NULL == h || INVALID_HANDLE_VALUE == h)
			return FALSE;

		//	Put the raw handle into an auto_handle so that we clean up properly
		//	(i.e. close the handle) if instantiating the CRefHandle below fails
		//	by throwing an exception (as it would with a throwing allocator).
		//
		auto_handle<HANDLE> hTemp(h);

		//	Preserve the last error from our caller.  Our caller could have passed
		//	in a raw HANDLE from a CreateFile() call and may need to check the last
		//	error even in the success case -- to determine whether the file already
		//	existed, for example.
		//
		DWORD dw = GetLastError();

		//	Create a new refcounted handle object to control the lifetime
		//	of the handle that we are taking ownership of.
		//
		//	Note: the reason we preserved the last error above is that the
		//	allocator clears the last error when we create the CRefHandle
		//	here if the allocation succeeds.
		//
		m_pRefHandle.take_ownership(new CRefHandle(hTemp));
		if (!m_pRefHandle.get())
		{
			//	Return a failure.  Note that we don't restore the last
			//	error here -- callers should expect the last error to
			//	be set to a value appropriate for the last call that
			//	failed which is us.
			//
			return FALSE;
		}

		//	Restore our caller's last error before returning.
		//
		SetLastError(dw);

		//	We now own the handle.
		//
		return TRUE;
	}

	VOID clear()
	{
		m_pRefHandle = NULL;
	}
};

#endif // !defined(_REFHANDLE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\synchro.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.H
//
//		Header for DAV synchronization classes.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef _EX_SYNCHRO_H_
#define _EX_SYNCHRO_H_

#include <caldbg.h>		// for Assert/DebugTrace/etc
#include <malloc.h>		// for _alloca()

//	========================================================================
//
//	CLASS CCriticalSection
//
//	Implements a critical section around a Win32 CRITICAL_SECTION.
//
//	Adds safety by explicitly disallowing copying (copying a raw
//	CRITICAL_SECTION can cause very unpredictable and hard to debug
//	behavior -- trust me).
//
//	Automatically cleans up the CRITICAL_SECTION resource when done.
//
class CCriticalSection
{
	//	The critical section
	//
	CRITICAL_SECTION	m_cs;

	//  NOT IMPLEMENTED
	//
	CCriticalSection& operator=( const CCriticalSection& );
	CCriticalSection( const CCriticalSection& );

public:
	//	CREATORS
	//
	CCriticalSection()
	{
		InitializeCriticalSection(&m_cs);
#ifdef DBG
		m_cLockRefs				= 0;
		m_dwLockOwnerThreadId	= 0;
#endif
	}

	~CCriticalSection()
	{
		DeleteCriticalSection(&m_cs);
	}

	BOOL FTryEnter()
	{
		if ( TryEnterCriticalSection (&m_cs) ) {
#ifdef DBG
			Assert (
				m_dwLockOwnerThreadId == GetCurrentThreadId() ||
				( m_cLockRefs == 0 && m_dwLockOwnerThreadId == 0 )
				);

			m_dwLockOwnerThreadId = GetCurrentThreadId ();
		m_cLockRefs++;
#endif
			return TRUE;
		}
		else
			return FALSE;
	}

	void Enter()
	{
		EnterCriticalSection(&m_cs);
#ifdef DBG
		Assert (
			m_dwLockOwnerThreadId == GetCurrentThreadId() ||
			( m_cLockRefs == 0 && m_dwLockOwnerThreadId == 0 )
			);

		m_dwLockOwnerThreadId = GetCurrentThreadId ();
		m_cLockRefs++;
#endif
	}

	void Leave()
	{
#ifdef DBG
		Assert ( m_cLockRefs > 0 );
		Assert ( m_dwLockOwnerThreadId != 0 );

		m_cLockRefs--;

		if ( m_cLockRefs == 0 ) {
			m_dwLockOwnerThreadId = 0;
		}
#endif
		LeaveCriticalSection(&m_cs);
	}

	void AssertLocked ( ) const
	{
#ifdef DBG
		//	This routine allows us to verify our correctness even when
		//	running in the single-threaded case.
		//

		// If this assert fires, it means that nobody has the lock:
		AssertSz ( m_cLockRefs > 0, "Calling method without the lock." );

		// If this assert fires, it means that somebody else has the lock:
		AssertSz ( m_dwLockOwnerThreadId == GetCurrentThreadId(),
			"Calling method, but another thread owns the lock!" );

#endif
	}

private:
#ifdef DBG

	// # of Lock() calls - # of Unlock() calls. Used by AssertInLock()
	DWORD				m_cLockRefs;

	// Thread ID of the current lock owner (or 0 if unowned).
	DWORD				m_dwLockOwnerThreadId;

#endif
};


//	========================================================================
//
//	CLASS CSynchronizedBlock
//
//	Synchronizes (serializes) any block of code in which an instance of
//	this class is declared on the critical section with which it
//	is initialized.
//
//	To use, just declare one of these in the block you want synchronized:
//
//		...
//		{
//			CSynchronizedBlock	sb(critsec);
//
//			//
//			//	Do some stuff that must be synchronized
//			//
//			...
//
//			//
//			//	Do more synchronized stuff
//			//
//			...
//		}
//
//		//
//		//	Do stuff that doesn't have to be synchronized
//		//
//		...
//
//	and the block is automatically synchronized.  Why bother?  Because
//	you don't need to have any cleanup code; the critical section is
//	automatically released when execution leaves the block, even if via
//	an exception thrown from any of the synchronized stuff.
//
class CSynchronizedBlock
{
	//	The critical section
	//
	CCriticalSection&	m_cs;

	//  NOT IMPLEMENTED
	//
	CSynchronizedBlock& operator=( const CSynchronizedBlock& );
	CSynchronizedBlock( const CSynchronizedBlock& );

public:
	//	CREATORS
	//
	CSynchronizedBlock( CCriticalSection& cs ) :
		m_cs(cs)
	{
		m_cs.Enter();
	}

	~CSynchronizedBlock()
	{
		m_cs.Leave();
	}
};

#include <except.h>

//	========================================================================
//
//	CLASS CEvent
//
//	Implements an event around a Win32 event handle resource.
//
class CEvent
{
	//	NOT IMPLEMENTED
	//
	CEvent& operator=(const CEvent&);
	CEvent(const CEvent&);

protected:

	HANDLE m_hevt;

public:

	CEvent() : m_hevt(NULL) {}

	BOOL FInitialized() const
	{
		return m_hevt && m_hevt != INVALID_HANDLE_VALUE;
	}

	~CEvent()
	{
		if ( FInitialized() )
		{
			CloseHandle( m_hevt );
		}
	}

	//$LATER: Pull out this now-unused parameter, and clean up all our callers!
	BOOL FCreate( LPCSTR ,		// OLD: was our resource-recording parameter
				  LPSECURITY_ATTRIBUTES	lpsa,
				  BOOL					fManualReset,
				  BOOL					fSignalled,
				  LPCWSTR				lpwszEventName,
				  BOOL					fDontMungeTheEventName = FALSE)
	{
		Assert( !FInitialized() );

		//	create event does not take backslashes. so replace
		//	them with ? which won't be part of URI at this point.
		//
		//$HACK
		//	ARGH!  Who put this slash-munging hack in here?  Modifying a
		//	const parameter and munging the name.  Most events are smart
		//	enough not to use backward slashes in their names since they
		//	aren't allowed by the underlying Win32 API, CreateEvent()....
		//
		//	At any rate, this is not good in the Terminal Server case which
		//	must prefix event names with either "Global\" or "Local\" (note
		//	the backslash!)
		//
		//	So the hack upon a hack here (fDontMungeTheEventName) is for
		//	callers who really can be trusted to know what they are doing.
		//	Unfortunately, short of grepping a lot of sources, there is
		//	no way of knowing who can and can't be trusted, so we have to
		//	assume the worst.
		//
		if (!fDontMungeTheEventName)
		{
			LPWSTR lpwszTemp = const_cast<LPWSTR>(lpwszEventName);

			if (lpwszTemp)
			{
				while( NULL != (lpwszTemp = wcschr (lpwszTemp, L'\\')) )
				{
					lpwszTemp[0] = L'?';
				}
			}
		}

		m_hevt = CreateEventW( lpsa,
							   fManualReset,
							   fSignalled,
							   lpwszEventName );

		//	According to MSDN, if the creation fails, CreateEvent returns NULL, not
		//	INVALID_HANDLE_VALUE.  We'll just do a quick DBG check to make sure we never
		//	see INVALID_HANDLE_VALUE here.
		//
		Assert(INVALID_HANDLE_VALUE != m_hevt);

		if ( !m_hevt )
			return FALSE;

		return TRUE;
	}

	void Set()
	{
		Assert( FInitialized() );

		SideAssert( SetEvent(m_hevt) );
	}

	void Reset()
	{
		Assert( FInitialized() );

		SideAssert( ResetEvent(m_hevt) );
	}

	void Wait()
	{
		Assert( FInitialized() );

		SideAssert( WaitForSingleObject( m_hevt, INFINITE ) == WAIT_OBJECT_0 );
	}

	void AlertableWait()
	{
		Assert( FInitialized() );

		DWORD dwResult;

		do
		{
			dwResult = WaitForSingleObjectEx( m_hevt, INFINITE, TRUE );
			Assert( dwResult != 0xFFFFFFFF );
		}
		while ( dwResult == WAIT_IO_COMPLETION );

		Assert( dwResult == WAIT_OBJECT_0 );
	}
};

//	========================================================================
//
//	CLASS CAlertableEvent
//
//	Extends CEvent with ability to wait on the additional handle comming
//	from external world.
//
class CAlertableEvent : public CEvent
{
	//	NOT IMPLEMENTED
	//
	CAlertableEvent& operator=(const CAlertableEvent&);
	CAlertableEvent(const CAlertableEvent&);

public:

	CAlertableEvent() : CEvent() {}

	DWORD DwWait(HANDLE hExt)
	{
		Assert( FInitialized() );

		if (( NULL != hExt ) && ( INVALID_HANDLE_VALUE != hExt ))
		{
			HANDLE	rgh[2] = { m_hevt, hExt };
			return WaitForMultipleObjects( 2, rgh, FALSE, INFINITE );
		}
		else
		{
			SideAssert( WaitForSingleObject( m_hevt, INFINITE ) == WAIT_OBJECT_0 );
			return WAIT_OBJECT_0;
		}
	}
};

//	========================================================================
//
//	CLASS CMRWLock
//
//	Implements a multi-reader, single writer-with-promote lock for
//	efficient, thread-safe access of a per-process resource.
//
class CMRWLock
{
	//
	//	The implementation uses a really clever trick where
	//	the high bit of the reader count is reserved for use
	//	as a one-bit flag that it set whenever there is a
	//	writer in the lock or waiting to enter it.
	//
	//	Combining the reader count and a writer flag into
	//	a single DWORD allows InterlockedXXX() calls to
	//	be used to manipulate the two pieces of information
	//	atomically as part of a spinlock which eliminates
	//	the need for an entering reader to pass through
	//	a critical section.
	//
	//	Entering a critical section, even for the short amount
	//	of time necessary to get a reader into the lock,
	//	drastically impacts the performance of heavily used
	//	process-wide locks.
	//

	//
	//	The write lock bit
	//
	enum { WRITE_LOCKED = 0x80000000 };

	//
	//	Critical section to allow only one writer at a time.
	//
	CCriticalSection m_csWriter;

	//
	//	ThreadID of the thread that owns the write lock.
	//	This value is 0 when no one owns the write lock.
	//
	DWORD m_dwWriteLockOwner;

	//
	//	Promoter recursion count used to allow a single thread
	//	which holds the promote/write lock to reenter the lock.
	//
	DWORD m_dwPromoterRecursion;

	//
	//	Event signalled when a writer leaves the lock to
	//	allow blocked readers to enter.
	//
	CEvent m_evtEnableReaders;

	//
	//	Event signalled when the last reader leaves the lock
	//	to allow a blocked writer to enter.
	//
	CEvent m_evtEnableWriter;

	//
	//	Count of readers plus a flag bit (WRITE_LOCKED)
	//	indicating whether a writer owns the lock or is
	//	waiting to enter it.
	//
	LONG m_lcReaders;

	BOOL FAcquireReadLock(BOOL fAllowCallToBlock);

	//	NOT IMPLEMENTED
	//
	CMRWLock& operator=(const CMRWLock&);
	CMRWLock(const CMRWLock&);

public:

	//	CREATORS
	//
	CMRWLock();
	BOOL FInitialize();
	~CMRWLock() {};

	//	MANIPULATORS
	//
	void EnterRead();
	BOOL FTryEnterRead();
	void LeaveRead();

	void EnterWrite();
	BOOL FTryEnterWrite();
	void LeaveWrite();

	void EnterPromote();
	BOOL FTryEnterPromote();
	void LeavePromote();
	void Promote();
};


//	========================================================================
//
//	CLASS CSharedMRWLock
//
//	Implements a simple multi-reader, single writer lock designed to
//	guard access to objects in shared memory.
//
//	CSharedMRWLock differs from CRMWLock:
//
//	o	This class is intended to be instantiated in shared memory.
//		It has no data members that cannot be simultaneously accessed
//		by multiple processes.
//
//	o	When asked to lock for read or write, the lock spins if it
//		cannot complete the request immediately.  Since this can consume
//		an enourmous amount of CPU resources, CSharedMRWLock should
//		only guard resources that can be acquired very quickly.
//
//	o	It does not support reader promotion.
//
//	o	It does not support conditional entry (TryEnterXXX()).
//
//	o	It does not support reentrancy in any form.
//
class CSharedMRWLock
{
	//
	//	The write lock bit (see CMRWLock for rationale)
	//
	enum { WRITE_LOCKED = 0x80000000 };

	//
	//	Count of readers plus a flag bit (WRITE_LOCKED)
	//	indicating whether a writer owns the lock or is
	//	waiting to enter it.
	//
	volatile LONG m_lcReaders;

	//	NOT IMPLEMENTED
	//
	CSharedMRWLock& operator=(const CSharedMRWLock&);
	CSharedMRWLock(const CSharedMRWLock&);

public:

	//	CREATORS
	//
	CSharedMRWLock() : m_lcReaders(0) {}
	~CSharedMRWLock() {};

	//	MANIPULATORS
	//
	void EnterRead();
	void LeaveRead();

	void EnterWrite();
	void LeaveWrite();
};


//	========================================================================
//
//	CLASS CCrossThreadLock
//
//	Implements a simple mutual exclusion lock to guard access to objects.
//	This object can be locked and unlocked from different threads (difference
//	from critsec-style locks).
//
//	ONLY USE THIS LOCK IF YOU _REALLY_ _REALLY_ NEED CROSS-THREAD
//	LOCK/UNLOCK CAPABILITY.
//
//	Possible future plans for improvement:
//	o	This object currently sets NULL for lpSemaphoreAttributes.  This will
//		not allow the lock to be used cross-process or from a different
//		user security context.
//	o	This object always specifies an INFINITE timeout.  In the future, there
//		could be an optional parameter to FEnter that allows you to set
//		something other than INFINITE.
//
class
CCrossThreadLock
{
	HANDLE	m_hSemaphore;

	//	NOT IMPLEMENTED
	//
	CCrossThreadLock& operator=(const CCrossThreadLock&);
	CCrossThreadLock(const CCrossThreadLock&);

public:
	CCrossThreadLock() :
		m_hSemaphore(NULL)
	{ }

	~CCrossThreadLock()
	{
		if (NULL != m_hSemaphore)
			CloseHandle(m_hSemaphore);
	}

	BOOL FInitialize()
	{
		BOOL	fSuccess = FALSE;
		m_hSemaphore = CreateSemaphore(NULL,				//	lpSemaphoreAttributes
									   1,					//	lInitialCount
									   1,					//	lMaximumCount
									   NULL);				//	lpName

		//	According to MSDN, if the creation fails, CreateSemaphore returns NULL, not
		//	INVALID_HANDLE_VALUE.  We'll just do a quick DBG check to make sure we never
		//	see INVALID_HANDLE_VALUE here.
		//
		Assert(INVALID_HANDLE_VALUE != m_hSemaphore);

		if (NULL == m_hSemaphore)
			goto Exit;

		fSuccess = TRUE;

	Exit:
		return fSuccess;
	}

	BOOL FEnter(DWORD dwTimeOut = INFINITE)
	{
		Assert(NULL != m_hSemaphore);

		if (WAIT_OBJECT_0 == WaitForSingleObject(m_hSemaphore,
												 dwTimeOut))
			return TRUE;

		return FALSE;
	}

	VOID Leave()
	{
		Assert(NULL != m_hSemaphore);

		if (!ReleaseSemaphore(m_hSemaphore,
							  1,
							  NULL))
		{
			DebugTrace("CCrossThreadLock::Leave(): Failed to release semaphore, last error 0x%08lX.\n",
					   GetLastError());
			TrapSz("CCrossThreadLock::Leave(): Failed to release semaphore!\n");
		}
	}
};

//	========================================================================
//
//	CLASS CGate
//
//	Implements gating mechanism, that alows to close the EXECUTION PATH and
//	push out all the threads using it. Very usefull on shutdown scenarios.
//
//	Here is a sketch of the gate usage:
//
//	...
//
//	{
//		CGatedBlock	gb(gate);
//
//		if (gb.FIsGateOpen())
//		{
//			...
//				EXECUTION PATH that is to be gated
//			...
//		}
//		else
//		{
//			...
//				Do whatever has to be done if EXECUTION PATH
//				is not to be executed any more
//			...
//		}
//	}
//	...
//
class CGate
{
	//	Number of users in the zone framed by this gate
	//
	LONG	m_lcUsers;

	//	Flag indicating if the gate is open
	//
	BOOL	m_fClosed;

	//	NOT IMPLEMENTED
	//
	CGate& operator=(const CGate&);
	CGate(const CGate&);

public:

	//	The fact that all member variables of the class are
	//	0 on creation, allows to use it as a static variable
	//	without additional burden of explicit initialization
	//
	CGate() : m_lcUsers(0),
			  m_fClosed(FALSE) {};

	//	INITIALIZER
	//
	inline
	VOID Init()
	{
		m_lcUsers = 0;
		m_fClosed = FALSE;
	}

	//	MANIPULATORS
	//
	inline
	VOID Enter()
	{
		InterlockedIncrement(&m_lcUsers);
	}

	inline
	VOID Leave()
	{
		InterlockedDecrement(&m_lcUsers);
	}

	inline
	VOID Close()
	{
		//	Mark the gate as closed
		//
		m_fClosed = TRUE;

		//	Wait until all the threads that use execution
		//	path framed by this gate will leave the zone
		//	it is framing. As FIsOpen() call is allowed only
		//	inside the gated zone, we will know that after
		//	this call returns there is no thread thinking
		//	that the gate is still open
		//
		while (0 != m_lcUsers)
		{
			Sleep(200);
		}
	}

	//	ACCESSORS
	//
	inline
	BOOL FIsOpen()
	{
		//	We must be in the gated zone in order
		//	to be able to determine if the gate is
		//	open.
		//
		Assert(m_lcUsers > 0);
		return !m_fClosed;
	}
};


//	========================================================================
//
//	TEMPLATE CLASS SynchronizedReadBlock
//
template<class _Lock>
class SynchronizedReadBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedReadBlock& operator=( const SynchronizedReadBlock& );
	SynchronizedReadBlock( const SynchronizedReadBlock& );

public:

	SynchronizedReadBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterRead();
	}

	~SynchronizedReadBlock()
	{
		m_lock.LeaveRead();
	}
};

typedef SynchronizedReadBlock<CMRWLock> CSynchronizedReadBlock;


//	========================================================================
//
//	TEMPLATE CLASS CSynchronizedWriteBlock
//
template<class _Lock>
class SynchronizedWriteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedWriteBlock& operator=( const SynchronizedWriteBlock& );
	SynchronizedWriteBlock( const SynchronizedWriteBlock& );

public:

	SynchronizedWriteBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterWrite();
	}

	~SynchronizedWriteBlock()
	{
		m_lock.LeaveWrite();
	}
};

typedef SynchronizedWriteBlock<CMRWLock> CSynchronizedWriteBlock;


//	========================================================================
//
//	TEMPLATE CLASS TryWriteBlock
//
//	Like SynchronizedWriteBlock except that the block must be
//	entered via the FTryEnter() method.  A return value of TRUE
//	from FTryEnter() indicates the lock is entered.
//
template<class _Lock>
class TryWriteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//	TRUE if write lock entered
	//
	BOOL m_fLocked;

	//  NOT IMPLEMENTED
	//
	TryWriteBlock& operator=( const TryWriteBlock& );
	TryWriteBlock( const TryWriteBlock& );

public:

	TryWriteBlock (_Lock& mrw) :
		m_lock(mrw),
		m_fLocked(FALSE)
	{
	}

	BOOL FTryEnter()
	{
		return m_fLocked = m_lock.FTryEnterWrite();
	}

	~TryWriteBlock()
	{
		if ( m_fLocked )
			m_lock.LeaveWrite();
	}
};

typedef TryWriteBlock<CMRWLock> CTryWriteBlock;


//	========================================================================
//
//	TEMPLATE CLASS SynchronizedPromoteBlock
//
template<class _Lock>
class SynchronizedPromoteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedPromoteBlock& operator=( const SynchronizedPromoteBlock& );
	SynchronizedPromoteBlock( const SynchronizedPromoteBlock& );

public:

	SynchronizedPromoteBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterPromote();
	}

	~SynchronizedPromoteBlock()
	{
		m_lock.LeavePromote();
	}

	void Promote()
	{
		m_lock.Promote();
	}
};

typedef SynchronizedPromoteBlock<CMRWLock> CSynchronizedPromoteBlock;

//	========================================================================
//
//	TEMPLATE CLASS GatedBlock
//
template<class _Gate>
class GatedBlock
{
	//	The gate
	//
	_Gate& m_gate;

	//  NOT IMPLEMENTED
	//
	GatedBlock& operator=( const GatedBlock& );
	GatedBlock( const GatedBlock& );

public:

	GatedBlock (_Gate& gate)
		: m_gate(gate)
	{
		m_gate.Enter();
	}

	BOOL FGateIsOpen()
	{
		return m_gate.FIsOpen();
	}

	~GatedBlock()
	{
		m_gate.Leave();
	}
};

typedef GatedBlock<CGate> CGatedBlock;

//	========================================================================
//
//	InterlockedExchangeOr -  A multithread safe way to OR bits into a LONG
//
LONG InterlockedExchangeOr( LONG * plVariable, LONG lOrBits );

#endif // !_EX_SYNCHRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\reg.h ===
#ifndef _REG_H_
#define _REG_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REG.H
//
//	Registry manipulation
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include <caldbg.h>

//	========================================================================
//
//	CLASS CRegKey
//
class CRegKey
{
	//
	//	The raw HKEY
	//
	HKEY m_hkey;

	//	NOT IMPLEMENTED
	//
	CRegKey& operator=( const CRegKey& );
	CRegKey( const CRegKey& );

public:
	//	CREATORS
	//
	CRegKey() : m_hkey(NULL) {}

	~CRegKey()
	{
		if ( m_hkey )
			(VOID) RegCloseKey( m_hkey );
	}

	//	MANIPULATORS
	//
	DWORD DwCreate( HKEY    hkeyBase,
					LPCWSTR lpwszSubkeyPath )
	{
		Assert( !m_hkey );

		return RegCreateKeyW( hkeyBase,
							  lpwszSubkeyPath,
							  &m_hkey );
	}

	DWORD DwOpen( HKEY    hkeyBase,
				  LPCWSTR lpwszSubkeyPath,
				  REGSAM  regsam = KEY_READ )
	{
		Assert( !m_hkey );

		return RegOpenKeyExW( hkeyBase,
							  lpwszSubkeyPath,
							  0,
							  regsam,
							  &m_hkey );
	}

	DWORD DwOpen( const CRegKey& regkey,
				  LPCWSTR lpwszSubkeyPath,
				  REGSAM  regsam = KEY_READ )
	{
		return DwOpen( regkey.m_hkey, lpwszSubkeyPath, regsam );
	}

	DWORD DwOpenA( HKEY   hkeyBase,
				   LPCSTR pszSubkeyPath,
				   REGSAM regsam = KEY_READ )
	{
		Assert( !m_hkey );

		return RegOpenKeyExA( hkeyBase,
							  pszSubkeyPath,
							  0,
							  regsam,
							  &m_hkey );
	}

	DWORD DwOpenA( const CRegKey& regkey,
				   LPCSTR pszSubkeyPath,
				   REGSAM regsam = KEY_READ )
	{
		return DwOpenA( regkey.m_hkey, pszSubkeyPath, regsam );
	}

	//	ACCESSORS
	//
	DWORD DwSetValue( LPCWSTR      lpwszValueName,
					  DWORD        dwValueType,
					  const VOID * lpvData,
					  DWORD        cbData ) const
	{
		Assert( m_hkey );

		return RegSetValueExW( m_hkey,
							   lpwszValueName,
							   0,
							   dwValueType,
							   reinterpret_cast<const BYTE *>(lpvData),
							   cbData );
	}

	DWORD DwQueryValue( LPCWSTR lpwszValueName,
						VOID *  lpvData,
						DWORD * pcbData,
						DWORD * pdwType = NULL ) const
	{
		Assert( m_hkey );

		return RegQueryValueExW( m_hkey,
								 lpwszValueName,
								 NULL, // lpReserved (must be NULL)
								 pdwType,
								 reinterpret_cast<LPBYTE>(lpvData),
								 pcbData );
	}

	DWORD DwQueryValueA( LPCSTR  lpszValueName,
						 VOID *  lpvData,
						 DWORD * pcbData,
						 DWORD * pdwType = NULL ) const
	{
		Assert( m_hkey );

		return RegQueryValueEx( m_hkey,
								lpszValueName,
								NULL, // lpReserved (must be NULL)
								pdwType,
								reinterpret_cast<LPBYTE>(lpvData),
								pcbData );
	}

	DWORD DwEnumSubKeyA( DWORD   iSubKey,
						 LPCSTR  pszSubKey,
						 DWORD * pcchSubKey ) const
	{
		FILETIME ftUnused;

		Assert( m_hkey );

		return RegEnumKeyExA( m_hkey,
							  iSubKey,
							  const_cast<LPSTR>(pszSubKey),
							  pcchSubKey,
							  NULL, // Reserved
							  NULL,	// Class not required
							  NULL, // Class not required
							  &ftUnused );
	}

	DWORD DwEnumSubKey( DWORD   iSubKey,
						LPCWSTR pwszSubKey,
						DWORD * pcchSubKey ) const
	{
		FILETIME ftUnused;

		Assert( m_hkey );

		return RegEnumKeyExW( m_hkey,
							  iSubKey,
							  const_cast<LPWSTR>(pwszSubKey),
							  pcchSubKey,
							  NULL, // Reserved
							  NULL,	// Class not required
							  NULL, // Class not required
							  &ftUnused );
	}
};

#endif // !defined(_REG_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\rgiter.h ===
/*
 *	R G I T E R . H
 *
 *	Range iterator
 */

#ifndef	_EX_RGITER_H_
#define _EX_RGITER_H_

//	Ranges --------------------------------------------------------------------
//
enum {

	RANGE_TOTAL_UNKNOWN	= 0xFFFFFFFF,
	RANGE_NOT_PRESENT = 0xFFFFFFFF,
	RANGE_UNKNOWN = 0,
	RANGE_ROW,
	RANGE_URL,
	RANGE_FIND
};

//	Range Items ---------------------------------------------------------------
//
//	There are two different range item formats.
//
//		row/byte ranges = DWRGITEM;
//		url/find ranges = SZRGITEM;
//
typedef struct _dwrgitem
{
	DWORD dwFirst;	// first row/byte of a range
	DWORD dwLast;	// last row/byte of a range

} DWRGITEM;

typedef struct _szrgitem
{
	LONG	lcRows;	// count of rows to return
	DWORD	cb;		// length, in bytes of item including NULL and padding
	WCHAR	wsz[];	// item padded out to align as needed

} SZRGITEM;

typedef struct _rgitem
{
	DWORD uRT;		// range type
	SCODE sc;

	union {

		DWRGITEM dwrgi;	// item for byte and row ranges
		SZRGITEM szrgi;	// item for url and find ranges
	};

} RGITEM, *PRGITEM;

inline
DWORD CbRangeItem (const RGITEM * prgi)
{
	Assert (prgi);
	DWORD cb = sizeof(RGITEM);
	if ((RANGE_URL == prgi->uRT) || (RANGE_FIND == prgi->uRT))
		cb += prgi->szrgi.cb;

	return cb;
}

//	Range Classes -------------------------------------------------------------
//
//	There are two classes for dealing with ranges.  A class that constructs the
//	range item array (a range parser), and a class that iterates over a range
//	array.
//
//	It is important to note that the CRangeParser only is used to parse the HTTP
//	"Range" header.  This header does not support the syntax of url and/or find
//	ranges, so the parser only builds items of type "bytes" and/or "rows".
//
//	Since both of these share the same format (DWRGITEM), and it is a fixed size,
//	there are some simplifying assumptions that can be made without adding too
//	much complexity to the parser.
//
//	Both parser and iterator share a common base...
//
class CRangeBase
{
protected:

	//	Count of ranges parsed out.
	//
	DWORD m_cRGList;

	//	Index of the range that is currently being parsed and/or processed
	//
	DWORD m_iCur;
	RGITEM * m_prgi;

	//	An array of ranges of size m_cRCList.  As noted above, this array is
	//	built up from items that were parsed from the HTTP header, and can
	//	then be assumed to be a fixed size based on the count of ranges.  This
	//	is an important aspect of the CRangeParser.
	//
	auto_heap_ptr<BYTE> m_pbData;
	DWORD m_cbSize;

	//	Collapsing unknown ranges
	//
	void CollapseUnknown();

	//  NOT IMPLEMENTED
	//
	CRangeBase& operator=( const CRangeBase& );
	CRangeBase( const CRangeBase& );

public:

	~CRangeBase();
	CRangeBase()
		: m_cRGList(0),
		  m_cbSize(0),
		  m_iCur(0),
		  m_prgi(0)

	{
	}

	//	Range fixup.  There are some cases where ranges need to be fixed up
	//	to match the actual amount of bytes/rows available.  Note that this
	//	only impacts byte and/or row ranges.
	//
	SCODE ScFixupRanges (DWORD dwCount);

	//	Advances through the rangGet the next range.
	//
	const RGITEM * PrgiNextRange();

	//	Rewind to the first range.
	//
	void Rewind()
	{
		m_iCur = 0;
		m_prgi = NULL;
	}

	//	Check for more ranges
	//
	BOOL FMoreRanges () const { return m_iCur < m_cRGList; }

	//	Check if a range present or not
	//
	BOOL FRangePresent (DWORD dw) const { return RANGE_NOT_PRESENT != dw; }

	//	Gets the total number of ranges.
	//
	ULONG UlTotalRanges() const { return m_cRGList; }

	//	Return the range array, with count and size.
	//
	RGITEM * PrgRangeArray(
		/* [out] */ ULONG * pulCount,
		/* [out] */ ULONG * pulSize,
		/* [in]  */ BOOL fTakeOwnership)
	{
		Assert (pulCount);
		Assert (pulSize);

		RGITEM * prgi = reinterpret_cast<RGITEM*>
			(fTakeOwnership ? m_pbData.relinquish() : m_pbData.get());

		*pulCount = m_cRGList;
		*pulSize = m_cbSize;
		return prgi;
	}
};

class CRangeParser : public CRangeBase
{
private:

	//  NOT IMPLEMENTED
	//
	CRangeParser& operator=( const CRangeParser& );
	CRangeParser( const CRangeParser& );

public:

	CRangeParser() {}
	~CRangeParser();

	//	Takes a range header and builds an array of ranges. Calls
	//	ScParseRangeHdr() to perform syntax checking, then validates
	//	the ranges against the entity size.
	//
	SCODE ScParseByteRangeHdr (LPCWSTR pwszRgHeader, DWORD dwSize);

	//	Take a range header and builds an array of ranges. Performs
	//	syntax checking.
	//
	SCODE ScParseRangeHdr (LPCWSTR pwszRgHeader, LPCWSTR pwszRangeUnit);
};

class CRangeIter : public CRangeBase
{
private:

	//  NOT IMPLEMENTED
	//
	CRangeIter& operator=( const CRangeIter& );
	CRangeIter( const CRangeIter& );

public:

	CRangeIter() {}
	~CRangeIter();

	//	Initialize a range iteration object based off of an existing
	//	range data blob.  In this case, the blob is copied and not consumed
	//	by the call.
	//
	SCODE ScInit (ULONG	cRGList, const RGITEM * prgRGList, ULONG cbSize);

	//	Initialize a range	iteration object based off of an existing
	//	range data blob.  In this case, the blob is consumed by the new
	//	object.
	//
	SCODE ScInit (CRangeParser& crp)
	{
		RGITEM * prgi = crp.PrgRangeArray (&m_cRGList,
										   &m_cbSize,
										   TRUE /* fTakeOwnership */);

		m_pbData = reinterpret_cast<BYTE*>(prgi);

		//	Rewind all the state.
		//
		Rewind();

		return S_OK;
	}
};

//	Range Parsing -------------------------------------------------------------
//
SCODE
ScParseOneWideRange (
	/* [in]  */ LPCWSTR pwsz,
	/* [out] */ DWORD * pdwStart,
	/* [out] */ DWORD * pdwEnd);

//	Range support -------------------------------------------------------------
//
//	Helper function to tell whether a range is a special range (0,0xffffffff)
//	which is used to represent the rows(bytes)=-n range on a zero sized response
//	body.
//
inline
BOOL FSpecialRangeForZeroSizedBody (RGITEM * prgItem)
{
	Assert (prgItem);

	return ((RANGE_ROW == prgItem->uRT)
			&& (0 == prgItem->dwrgi.dwFirst)
			&& (RANGE_NOT_PRESENT == prgItem->dwrgi.dwLast));
}

//	Range emitting ------------------------------------------------------------
//
SCODE ScGenerateContentRange (
	/* [in]  */ LPCSTR pszRangeUnit,
	/* [in]  */ const RGITEM * prgRGList,
	/* [in]  */ ULONG cRanges,
	/* [in]  */ ULONG cbRanges,
	/* [in]  */ ULONG ulTotal,
	/* [out] */ LPSTR *ppszContentRange);

#endif // _EX_RGITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\stackbuf.h ===
/*
 *	S T A C K B U F . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_STACKBUF_H_
#define _EX_STACKBUF_H_
#include <caldbg.h>

//	Alignment macros ----------------------------------------------------------
//
#include <align.h>

//	Safe allocators -----------------------------------------------------------
//
#include <ex\exmem.h>

//	Class STACKBUF ------------------------------------------------------------
//
enum { STACKBUFFER_THRESHOLD = 64};
template <class T, UINT N = STACKBUFFER_THRESHOLD>
class CStackBuffer
{
private:

	BYTE	m_rgb[N];
	ULONG	m_fDynamic:1;
	ULONG	m_fValid:1;
	ULONG	m_cb:30;
	T*		m_pt;

	//	non-implemented operators
	//
	CStackBuffer(const CStackBuffer& );
	CStackBuffer& operator=(const CStackBuffer& );

	void release()
	{
		if (m_fDynamic && m_pt)
		{
			ExFree(m_pt);
			m_pt = NULL;
		}
	}

	T& idx(size_t iT) const
	{
		Assert(m_fValid && m_pt && ((UINT)iT < celems()));
		return m_pt[iT];
	}

	//	non-implemented operators
	//
	operator T*() const;
	T& operator*() const;
	T** operator&()	const;

	//	block random assignments
	//
	CStackBuffer& operator=(T* pt);
	CStackBuffer& operator=(void * p);

public:

	//	Manuplation -----------------------------------------------------------
	//
	//	Allocation mechanism, replaces _alloca()
	//
	T * resize (UINT cb)
	{
		//	Max size for a stack item
		//
		Assert (cb <= 0x3FFFFFFF);

		//	Lets go ahead an ask for a sizable chunk, regardless.
		//
		cb = max(cb, N);

		//	If the size of the item is greater than the current size,
		//	then we need to aquire space for the data,
		//
		if (m_cb < cb)
		{
			T* pt = NULL;

			//	If the item is already dynamically allocated, or if the
			//	size exceeds the threshold of the stackbuffer, allocate
			//	the memory.
			//
			if (m_fDynamic || (N < cb))
			{
				//	Allocate space using ExAlloc() and return that value,
				//	fDynamic means that the existing value is dynamically
				//	allocated.  Free the old before creating the new.
				//
				DebugTrace ("DAV: stackbuf going dynamic...\n");
				//
				//	The free/alloc should have better perf characteristics
				//	in the multi-heap land.
				//
				release();
				pt = static_cast<T*>(ExAlloc(cb));
				m_fDynamic = TRUE;
			}
			else
			{
				pt = reinterpret_cast<T*>(m_rgb);
			}

			m_pt = pt;
			m_cb = cb;
		}
		m_fValid = TRUE;
		return m_pt;
	}


	//	Constructor/Destructor ------------------------------------------------
	//
	~CStackBuffer() { release(); }
	explicit CStackBuffer(UINT uInitial = N)
		: m_fDynamic(FALSE),
		  m_fValid(FALSE),
		  m_pt(NULL),
		  m_cb(0)
	{
		resize(uInitial);
	}

	//	Invalidation ----------------------------------------------------------
	//
	void clear() { m_fValid = FALSE; }

	//	Size ------------------------------------------------------------------
	//
	size_t celems() const { return (m_cb / sizeof(T)); }
	size_t size() const { return m_cb; }

	//	Accessors -------------------------------------------------------------
	//
	T* get()		const { Assert(m_fValid && m_pt); return m_pt; }
	void* pvoid()	const { Assert(m_fValid && m_pt); return m_pt; }
	T* operator->() const { Assert(m_fValid && m_pt); return m_pt; }
	T& operator[] (INT iT) const { return idx((size_t)iT); }
	T& operator[] (UINT iT) const { return idx((size_t)iT); }
	T& operator[] (DWORD iT) const { return idx((size_t)iT); }
	T& operator[] (__int64 iT) const { return idx((size_t)iT); }
	T& operator[] (unsigned __int64 iT) const { return idx((size_t)iT); }
};

#endif // _EX_STACKBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xmldata.h ===
/*
 *	X M L D A T A . H
 *
 *	Sources Exchange messaging implementation of DAV-Base --
 *	XML-Data types.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XMLDATA_H_
#define _EX_XMLDATA_H_

#include <mapidefs.h>

//#define INT64_MIN 0x8000000000000000

//	Data types ----------------------------------------------------------------
//
DEC_CONST WCHAR wszWebClientTime[]	= L"dateTime.wc.";

USHORT __fastcall
UsPtypeFromName (
	/* [in] */ LPCWSTR pwszAs,
	/* [in] */ UINT cchAs,
	/* [out] */ USHORT* pusCnvt);

enum {

	CNVT_DEFAULT = 0,
	CNVT_ISO8601,
	CNVT_RFC1123,
	CNVT_UUID,
	CNVT_BASE64,
	CNVT_BINHEX,
	CNVT_01,
	CNVT_CUSTOMDATE,
	CNVT_LIMITED,
};

//	Data conversions ----------------------------------------------------------
//
SCODE ScInBase64Literal (LPCWSTR, UINT, BOOL, SBinary*);
SCODE ScInBinhexLiteral (LPCWSTR, UINT, BOOL, SBinary*);
SCODE ScInIso8601Literal (LPCWSTR, UINT, BOOL, FILETIME*);
SCODE ScInRfc1123Literal (LPCWSTR, UINT, BOOL, FILETIME*);
SCODE ScInUuidLiteral (LPCWSTR, UINT, BOOL, GUID*);

#endif	// _EX_XMLDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xml.h ===
/*
 *	X M L . H
 *
 *	XML Document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XML_H_
#define _XML_H_

#include <caldbg.h>
#include <ex\refcnt.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Xml);
#define XmlTrace		DO_TRACE(Xml)

//	Property name escaping/unescaping -----------------------------------------
//
VOID UnescapePropertyName (LPCWSTR wszEscaped, LPWSTR wszProp);
SCODE ScEscapePropertyName (LPCWSTR wszProp, UINT cch, LPWSTR pwszEscaped, UINT* pcch, BOOL fRestrictFirstCharacter);

//	Property construction helpers ---------------------------------------------
//
SCODE ScVariantTypeFromString (LPCWSTR pwszType, USHORT& vt);
SCODE ScVariantValueFromString (PROPVARIANT& var, LPCWSTR pwszValue);

enum
{
	//$REVIEW: Define an proper body part size. It's used in CXMLBodyPartMgr
	//$REVIEW: to control when a body part is to be added to the body part list.
	//$REVIEW: Acutally, because it is not predictable how big the next piece is.
	//$REVIEW: the max size of xml body part can be (CB_XMLBODYPART_SIZE * 2 - 1)
	//$REVIEW: It is also used in ScSetValue to break over-size value into
	//$REVIEW: smaller pieces.
	//
	//$REVIEW: Don't confuse this to the largest chunk size CB_WSABUFS_MAX (8174).
	//$REVIEW: CB_XMLBODYPART_SIZE is not meant to control chunks
	//
	CB_XMLBODYPART_SIZE	=	4 * 1024	//	4K
};

//	class IXMLBody ------------------------------------------------------------
//
//	This is the XML body building interface, it is to be inherited in either
//	IIS and/or store size, to allow XML emitting
//
class IXMLBody : private CRefCountedObject,
				 public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IXMLBody(const IXMLBody& p);
	IXMLBody& operator=( const IXMLBody& );

protected:

	IXMLBody()
	{
		AddRef(); // use com-style refcounting
	}

public:

	virtual SCODE ScAddTextBytes ( UINT cbText, LPCSTR lpszText ) = 0;
	virtual VOID Done() = 0;

	//	RefCounting -- forward all reconting requests to our refcounting
	//	implementation base class: CRefCountedObject
	//
	void AddRef() { CRefCountedObject::AddRef(); }
	void Release() { CRefCountedObject::Release(); }
};

#endif	// _XML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_crc\calcrc.c ===
/*
 *	C A L C R C . C
 *
 *	CRC (Cyclic Redundancy Check) Calculation Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

//	We get this warning, C4115, in rpcasync.h
#pragma warning(disable:4115)	/* named type definition in parentheses */

#include <windows.h>
#include <crc.h>

//	DwComputeCRC --------------------------------------------------------------
//
//	The table which follows was computed using the following function:
//
//	#define CRC_POLYNOMIAL 0xEDB88320
//
//	DWORD ComputeCRCByte(BYTE b)
//	{
//		DWORD	dwCRC = b;
//		int	   i;
//
//		for (i = 8; --i >= 0; )
//			dwCRC = ((dwCRC & 1) ? ((dwCRC >> 1) ^ CRC_POLYNOMIAL)
//						: (dwCRC >> 1));
//
//		return dwCRC;
//	}
//
const DWORD g_rgdwCRC[] =
{
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
	0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
	0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
	0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
	0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
	0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
	0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
	0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
	0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
	0xA4D1C46D, 0xD3D6F4FB,	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,	0x5005713C, 0x270241AA,
	0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
	0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
	0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
	0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
	0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
	0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
	0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
	0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
	0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
	0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
	0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
	0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

DWORD
DwComputeCRC(DWORD dwCRC, PVOID pv, UINT cb)
{
	BYTE * pb = (BYTE *)pv;
	DWORD dw;

	while (cb && ((DWORD_PTR)pb & 3))
	{
		dwCRC = CRC_COMPUTE(dwCRC, *pb++);
		cb--;
	}
	if (cb)
	{
		while (cb >= sizeof(DWORD))
		{
			dw = *((DWORD *)pb);
			pb += sizeof(DWORD); 
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			cb -= sizeof(DWORD);
		}

		while (cb--)
			dwCRC = CRC_COMPUTE(dwCRC, *pb++);
	}
	return dwCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xprs.h ===
/*
 *	X P R S . H
 *
 *	XML push-model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XPRS_H_
#define _EX_XPRS_H_

#include <xmlparser.h>
#include <ex\autoptr.h>
#include <ex\nmspc.h>
#include <davsc.h>
#include <exo.h>

//	XML Namespace scopes ------------------------------------------------------
//
class CXmlnsScope
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:

	auto_ref_ptr<CNmspc>	m_pns;

	//	non-implemented
	//
	CXmlnsScope(const CXmlnsScope& p);
	CXmlnsScope& operator=(const CXmlnsScope& p);

public:

	~CXmlnsScope() {}
	CXmlnsScope()
			: m_cRef(1)
	{
	}

	VOID ScopeNamespace(CNmspc* pns)
	{
		//	Set the current top of the sibling chain as a sibling
		//	to this namespace.
		//
		pns->SetSibling (m_pns.get());

		//	Set this new namespace as the top of the sibling chain.
		//
		m_pns = pns;
	}

	VOID LeaveScope(CNmspcCache* pnsc)
	{
		auto_ref_ptr<CNmspc> pns;

		while (m_pns.get())
		{
			//	Unhook the namespace
			//
			pns = m_pns;
			m_pns = m_pns->PnsSibling();

			//	Remove it from the indexes
			//
			pnsc->RemovePersisted (pns);
		}
	}
};

//	class CXMLNodeFactory -----------------------------------------------------
//
class CNodeFactory :
	public EXO,
	public IXMLNodeFactory,
	public CParseNmspcCache
{
	StringBuffer<WCHAR> m_sbValue;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_PROLOGUE,
		ST_INDOC,
		ST_INATTR,
		ST_INATTRDATA,
		ST_XMLERROR

	} PARSE_STATE;
	PARSE_STATE m_state;
	HRESULT m_hrParserError;

	//	Unhandled nodes -------------------------------------------------------
	//
	UINT m_cUnhandled;

	VOID PushUnhandled()
	{
		++m_cUnhandled;
		XmlTrace ("Xml: incrementing unhandled node depth\n"
				  "  m_cUnhandled: %ld\n",
				  m_cUnhandled);
	}

	VOID PopUnhandled()
	{
		--m_cUnhandled;
		XmlTrace ("Xml: decrementing unhandled node depth\n"
				  "  m_cUnhandled: %ld\n",
				  m_cUnhandled);
	}

	//	non-implemented
	//
	CNodeFactory(const CNodeFactory& p);
	CNodeFactory& operator=(const CNodeFactory& p);

protected:

	//	FIsTag() --------------------------------------------------------------
	//
	//	FIsTag() can be used in XML parsing code as a shortcut to see if
	//	the str from a xml element matches a fully qualified tagname. An
	//	important distinction here, is that FIsTag() will allow for non-
	//	qualified short-names.  So, FIsTag() should never be used in any
	//	place where the tag is not scoped by the standard dav namespace.
	//
	//		ie. "DAV:foo" and "foo" will match.
	//
	inline BOOL FIsTag (LPCWSTR pwszTag, LPCWSTR pwszExpected)
	{
		Assert (wcslen(pwszExpected) > CchConstString(gc_wszDav));
		return (!_wcsicmp (pwszTag, pwszExpected) ||
				!_wcsicmp (pwszTag, pwszExpected + CchConstString(gc_wszDav)));
	}

public:

	virtual ~CNodeFactory() {}
	CNodeFactory()
			: m_state(ST_NODOC),
			  m_hrParserError(S_OK),
			  m_cUnhandled(0)
	{
		INIT_TRACE(Xml);
	}

	//	EXO support
	//
	EXO_INCLASS_DECL(CNodeFactory);

	//	INodeFactory ----------------------------------------------------------
	//
	virtual HRESULT STDMETHODCALLTYPE NotifyEvent(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODEFACTORY_EVENT iEvt);

	virtual HRESULT STDMETHODCALLTYPE BeginChildren(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE EndChildren(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ BOOL fEmpty,
		/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE Error(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ HRESULT hrErrorCode,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE CreateNode(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ PVOID pNodeParent,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *pNodeInfo);

	//	CNodeFactory specific methods -----------------------------------------
	//
	virtual SCODE ScCompleteAttribute (void) = 0;

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen) = 0;

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen) = 0;

	//	Most implementation do not need this method, lock requires it for
	//	proper processing of the owner node.
	//
	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD)
	{
		return S_OK;
	}

	//	Parser errors ---------------------------------------------------------
	//
	BOOL FParserError(SCODE sc) const
	{
		return (FAILED (m_hrParserError) ||
				((sc & 0xFFFFFF00) == XML_E_PARSEERRORBASE));
	}
};

//	ScInstatiateParser() ------------------------------------------------------
//
//	Raid X5:136451
//	The XML parser in the version of MSXML.DLL released with Windows 2000
//	doesn't fail properly when given a XML document shorter than a certain
//	length.  CB_XML_PARSER_MIN is the minimum length of an XML document, in
//	bytes, required to avoid this bug.  One must explicitly check that a
//	document is at least this long before feeding it to the XML parser.
//
enum { CB_XML_PARSER_MIN = 2 };
SCODE ScNewXMLParser (CNodeFactory* pnf, IStream * pstm, IXMLParser ** ppxprs);
SCODE ScParseXML (IXMLParser * pxprs, CNodeFactory * pnf);
SCODE ScParseXMLBuffer (CNodeFactory* pnf, LPCWSTR pwszXML);

//	Parsers -------------------------------------------------------------------
//
//	CPropContext --------------------------------------------------------------
//
//	The property context is used specifically in <DAV:prop> node processing.
//	The components of the property are constructed across multiple calls and
//	are implementation dependant.
//
class CPropContext
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:
	//	non-implemented operators
	//
	CPropContext( const CPropContext& );
	CPropContext& operator=( const CPropContext& );

public:

	virtual ~CPropContext() {}
	CPropContext()
			: m_cRef(1) // com-style refcounting
	{
	}

	virtual SCODE ScSetType(
		/* [in] */ LPCWSTR pwszType) = 0;

	virtual SCODE ScSetValue(
		/* [in] */ LPCWSTR pwszValue,
		/* [in] */ UINT cmvValues) = 0;

	virtual SCODE ScComplete(
		/* [in] */ BOOL fEmpty) = 0;

	virtual BOOL FMultiValued( void ) = 0;

	virtual SCODE ScSetFlags(DWORD dw)	{ return S_OK; }
};

//	CValueContext -------------------------------------------------------------
//
//	When a parser encounters a property, a context is needed such that
//	construction of the property value is possible.
//
class CValueContext
{
	//	non-implemented operators
	//
	CValueContext( const CValueContext& );
	CValueContext& operator=( const CValueContext& );

public:

	CValueContext() {}
	virtual ~CValueContext() {}

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScSetProp(
		/* [in] */ LPCWSTR pwszPath,
		/* [in] */ LPCWSTR pwszProp,
		/* [in] */ auto_ref_ptr<CPropContext>& pPropCtx) = 0;
};

#endif	// _EX_XPRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\sz.h ===
//	========================================================================
//
//	sz.h
//
//	Constant string support
//
//	NOTE: Strings that need multi-language support should NOT go here!
//	They belong in the \cal\lang tree.
//
//	Copyright 1986-1999 Microsoft Corporation, All Rights Reserved
//

#ifndef _EX_SZ_H_
#define _EX_SZ_H_


//	Const string length -------------------------------------------------------
//
#define CchConstString(_s)	((sizeof(_s)/sizeof(_s[0])) - 1)
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)


//	String constants ----------------------------------------------------------
//

//	Product tokens ------------------------------------------------------------
//
DEC_CONST CHAR gc_szOffice9UserAgent[]		= "Microsoft Data Access Internet Publishing Provider DAV";
DEC_CONST UINT gc_cchOffice9UserAgent		= CchConstString(gc_szOffice9UserAgent);
DEC_CONST CHAR gc_szRosebudNT5UserAgent[]	= "Microsoft Data Access Internet Publishing Provider DAV 1.1";
DEC_CONST UINT gc_cchRosebudNT5UserAgent	= CchConstString(gc_szRosebudNT5UserAgent);

//	Whitespace ----------------------------------------------------------------
//
DEC_CONST CHAR gc_szLWS[]					= " \r\n\t";
DEC_CONST WCHAR gc_wszLWS[]					= L" \r\n\t";
DEC_CONST CHAR gc_szWS[]					= " \t";
DEC_CONST WCHAR gc_wszWS[]					= L" \t";

//	Generic constants ---------------------------------------------------------
//
DEC_CONST WCHAR gc_wszDigits[] = L"0123456789";
DEC_CONST WCHAR gc_wchEquals   = L'=';
DEC_CONST WCHAR gc_wchComma	   = L',';
DEC_CONST WCHAR gc_wszByteRangeAlphabet[] = L"0123456789-, \t";
DEC_CONST WCHAR gc_wszSeparator[] = L" \t,";
DEC_CONST WCHAR gc_wchDash	= L'-';

//	HTTP-DAV headers ----------------------------------------------------------
//
DEC_CONST CHAR gc_szAccept_Charset[]		= "Accept-Charset";
DEC_CONST CHAR gc_szAccept_Encoding[]		= "Accept-Encoding";
DEC_CONST CHAR gc_szAccept_Language[]		= "Accept-Language";
DEC_CONST CHAR gc_szAccept_Ranges[]			= "Accept-Ranges";
DEC_CONST CHAR gc_szAccept[]				= "Accept";
DEC_CONST CHAR gc_szAge[]					= "Age";
DEC_CONST CHAR gc_szAllow[]					= "Allow";
DEC_CONST CHAR gc_szAtomic[]				= "Atomic";
DEC_CONST CHAR gc_szAuthorization[]			= "Authorization";
DEC_CONST CHAR gc_szChunked[]				= "chunked";
DEC_CONST WCHAR gc_wszChunked[]				= L"chunked";
DEC_CONST CHAR gc_szCollection_Member[]		= "Collection-Member";
DEC_CONST CHAR gc_szCompatibility[]			= "Compatibility";
DEC_CONST CHAR gc_szConnection[]			= "Connection";
DEC_CONST CHAR gc_szContent_Base[]			= "Content-Base";
DEC_CONST CHAR gc_szContent_Encoding[]		= "Content-Encoding";
DEC_CONST CHAR gc_szContent_Language[]		= "Content-Language";
DEC_CONST CHAR gc_szContent_Length[]		= "Content-Length";
DEC_CONST CHAR gc_szContent_Location[]		= "Content-Location";
DEC_CONST CHAR gc_szContent_MD5[]			= "Content-MD5";
DEC_CONST CHAR gc_szContent_Range[]			= "Content-Range";
DEC_CONST WCHAR gc_wszContent_Range[]		= L"Content-Range";
DEC_CONST INT gc_cchContent_Range			= CchConstString(gc_szContent_Range);
DEC_CONST CHAR gc_szContent_Type[]			= "Content-Type";
DEC_CONST WCHAR gc_wszContent_Type[]		= L"Content-Type";
DEC_CONST INT gc_cchContent_Type			= CchConstString(gc_szContent_Type);
DEC_CONST CHAR gc_szContent_Disposition[]	= "Content-Disposition";
DEC_CONST CHAR gc_szCookie[]				= "Cookie";
DEC_CONST CHAR gc_szDate[]					= "Date";
DEC_CONST CHAR gc_szDepth[]					= "Depth";
DEC_CONST CHAR gc_szDestination[]			= "Destination";
DEC_CONST CHAR gc_szDestroy[]				= "Destroy";
DEC_CONST CHAR gc_szExpires[]				= "Expires";
DEC_CONST CHAR gc_szETag[]					= "ETag";
DEC_CONST CHAR gc_szFrom[]					= "From";
DEC_CONST CHAR gc_szHost[]					= "Host";
DEC_CONST CHAR gc_szIf_Match[]				= "If-Match";
DEC_CONST CHAR gc_szIf_Modified_Since[]		= "If-Modified-Since";
DEC_CONST CHAR gc_szIf_None_Match[]			= "If-None-Match";
DEC_CONST CHAR gc_szIf_None_State_Match[]	= "If-None-State-Match";
DEC_CONST CHAR gc_szIf_Range[]				= "If-Range";
DEC_CONST CHAR gc_szIf_State_Match[]		= "If-State-Match";
DEC_CONST CHAR gc_szIf_Unmodified_Since[]	= "If-Unmodified-Since";
DEC_CONST CHAR gc_szLast_Modified[]			= "Last-Modified";
DEC_CONST CHAR gc_szLocation[]				= "Location";
DEC_CONST CHAR gc_szLockInfo[]				= "Lock-Info";
DEC_CONST CHAR gc_szLockToken[]				= "If";
DEC_CONST CHAR gc_szMS_Author_Via[]			= "MS-Author-Via";
DEC_CONST CHAR gc_szMS_Exchange_FlatURL[]	= "MS-Exchange-Permanent-URL";
DEC_CONST CHAR gc_szOverwrite[]				= "Overwrite";
DEC_CONST CHAR gc_szAllowRename[]			= "Allow-Rename";
DEC_CONST CHAR gc_szPublic[]				= "Public";
DEC_CONST CHAR gc_szRange[]					= "Range";
DEC_CONST CHAR gc_szReferer[]				= "Referer";
DEC_CONST CHAR gc_szRetry_After[]			= "Retry-After";
DEC_CONST CHAR gc_szServer[]				= "Server";
DEC_CONST CHAR gc_szSet_Cookie[]			= "Set-Cookie";
DEC_CONST CHAR gc_szTimeout[]				= "Timeout";
DEC_CONST CHAR gc_szTime_Out[]				= "Time-Out";
DEC_CONST CHAR gc_szTransfer_Encoding[]		= "Transfer-Encoding";
DEC_CONST CHAR gc_szTranslate[]				= "Translate";
DEC_CONST CHAR gc_szUpdate[]				= "Update";
DEC_CONST CHAR gc_szUser_Agent[]			= "User-Agent";
DEC_CONST CHAR gc_szVary[]					= "Vary";
DEC_CONST CHAR gc_szWarning[]				= "Warning";
DEC_CONST CHAR gc_szWWW_Authenticate[]		= "WWW-Authenticate";
DEC_CONST CHAR gc_szVersioning_Support[]	= "Versioning-Support";
DEC_CONST CHAR gc_szBrief[]					= "Brief";

//	ECB server variables ------------------------------------------------------
//
DEC_CONST CHAR gc_szHTTP_[]                 = "HTTP_";
DEC_CONST UINT gc_cchHTTP_					= CchConstString(gc_szHTTP_);
DEC_CONST CHAR gc_szServer_Protocol[]		= "SERVER_PROTOCOL";
DEC_CONST CHAR gc_szServer_Name[]			= "SERVER_NAME";
DEC_CONST CHAR gc_szServer_Port[]			= "SERVER_PORT";
DEC_CONST CHAR gc_szAuth_Type[]				= "AUTH_TYPE";
DEC_CONST CHAR gc_szHTTP_Version[]			= "HTTP_VERSION";
DEC_CONST CHAR gc_szAll_Raw[]				= "ALL_RAW";

//	ECB server variable values ------------------------------------------------
//
DEC_CONST CHAR gc_sz80[]					= "80";
DEC_CONST CHAR gc_sz443[]					= "443";
DEC_CONST CHAR gc_szBasic[]					= "Basic";

//	Verbs
//
DEC_CONST CHAR gc_szHEAD[]	= "HEAD";
DEC_CONST CHAR gc_szGET[]	= "GET";

//	Custom headers ------------------------------------------------------------
//
DEC_CONST CHAR gc_szX_MS_DEBUG_DAV[]		= "X-MS-Debug-DAV";
DEC_CONST CHAR gc_szX_MS_DEBUG_DAV_Signature[]	= "X-MS-Debug-DAV-Signature";

//	Depth values --------------------------------------------------------------
//
DEC_CONST CHAR gc_sz0[]					= "0";
DEC_CONST WCHAR gc_wsz0[]				= L"0";
DEC_CONST CHAR gc_sz1[]					= "1";
DEC_CONST WCHAR gc_wsz1[]				= L"1";
DEC_CONST CHAR gc_szInfinity[]			= "infinity";
DEC_CONST WCHAR gc_wszInfinity[]		= L"infinity";
DEC_CONST CHAR gc_sz1NoRoot[]			= "1,noroot";
DEC_CONST CHAR gc_szInfinityNoRoot[]	= "infinity,noroot";

//	Common header values ------------------------------------------------------
//
DEC_CONST CHAR gc_szClose[]					= "close";
DEC_CONST WCHAR gc_wszClose[]				= L"close";
DEC_CONST WCHAR gc_wszKeep_Alive[]			= L"Keep-Alive";
DEC_CONST CHAR gc_szNone[]					= "none";

DEC_CONST CHAR gc_szBytes[]					= "bytes";
DEC_CONST WCHAR gc_wszBytes[]				= L"bytes";
DEC_CONST INT gc_cchBytes					= CchConstString(gc_szBytes);
DEC_CONST WCHAR gc_wszRows[]				= L"rows";
DEC_CONST CHAR gc_szAnd[]					= "and";
DEC_CONST CHAR gc_szOr[]					= "or";
DEC_CONST WCHAR gc_wszNot[]					= L"not";
DEC_CONST WCHAR gc_wszInfinite[]			= L"Infinite";
DEC_CONST INT gc_cchInfinite				= CchConstString(gc_wszInfinite);
DEC_CONST WCHAR gc_wszSecondDash[]			= L"Second-";
DEC_CONST INT gc_cchSecondDash				= CchConstString(gc_wszSecondDash);

DEC_CONST CHAR gc_szMS_Author_Via_Dav[]		= "DAV";
DEC_CONST CHAR gc_szMS_Author_Via_Dav_Fp[]	= "MS-FP/4.0,DAV";

//	Lock Header values --------------------------------------------------------
//
DEC_CONST CHAR gc_szLockTimeoutFormat[]		= "Second-%d";
DEC_CONST INT gc_cchMaxLockTimeoutString	= CchConstString(gc_szLockTimeoutFormat) + 10;

//	Content-Type values -------------------------------------------------------
//
DEC_CONST CHAR gc_szText_XML[]				= "text/xml";
DEC_CONST WCHAR gc_wszText_XML[]			= L"text/xml";
DEC_CONST INT  gc_cchText_XML				= CchConstString(gc_szText_XML);
DEC_CONST CHAR gc_szApplication_XML[]	    = "application/xml";
DEC_CONST WCHAR gc_wszApplication_XML[]	    = L"application/xml";
DEC_CONST CHAR gc_szText_HTML[]				= "text/html";
DEC_CONST INT  gc_cchText_HTML				= CchConstString(gc_szText_HTML);
DEC_CONST CHAR gc_szAppl_Octet_Stream[]		= "application/octet-stream";
DEC_CONST WCHAR gc_wszAppl_Octet_Stream[]	= L"application/octet-stream";
DEC_CONST INT  gc_cchAppl_Octet_Stream		= CchConstString(gc_szAppl_Octet_Stream);
DEC_CONST CHAR gc_szAppl_X_WWW_Form[]		= "application/x-www-form-urlencoded";
DEC_CONST INT gc_cchAppl_X_WWW_Form			= CchConstString(gc_szAppl_X_WWW_Form);
DEC_CONST WCHAR gc_wszMultipart_Byterange[]	= L"multipart/byteranges";
DEC_CONST INT  gc_cchMultipart_Byterange	= CchConstString(gc_wszMultipart_Byterange);
DEC_CONST CHAR gc_szMultipart_FormData[]	= "multipart/form-data";
DEC_CONST INT  gc_cchMultipart_FormData		= CchConstString(gc_szMultipart_FormData);
DEC_CONST WCHAR gc_wszBoundary[]			= L"boundary";
DEC_CONST INT  gc_cchBoundary				= CchConstString(gc_wszBoundary);
DEC_CONST CHAR gc_szAppl_MIME[]				= "application/mime";
DEC_CONST INT  gc_cchAppl_MIME				= CchConstString(gc_szAppl_MIME);

//	Cache control -------------------------------------------------------------
//
DEC_CONST CHAR gc_szCache_Control[]			= "Cache-Control";
DEC_CONST CHAR gc_szCache_Control_Private[]	= "private";
DEC_CONST CHAR gc_szCache_Control_NoCache[] = "no-cache";
DEC_CONST CHAR gc_szCache_Control_MaxAge[]  = "max-age";
DEC_CONST ULONG gc_cchCache_Control_MaxAge	= CchConstString(gc_szCache_Control_MaxAge);
DEC_CONST CHAR gc_szCache_Control_MaxAgeZero[]  = "max-age=0";

//	Header emitters -----------------------------------------------------------
//
DEC_CONST CHAR gc_szCRLF[]					= "\r\n";
DEC_CONST WCHAR gc_wszCRLF[]				= L"\r\n";
DEC_CONST INT gc_cchCRLF					= CchConstString(gc_szCRLF);
DEC_CONST CHAR gc_szColonSp[]				= ": ";
DEC_CONST CHAR gc_szEmpty[]					= "";
DEC_CONST WCHAR gc_wszEmpty[]				= L"";

//	HTTP versions -------------------------------------------------------------
//
DEC_CONST CHAR gc_szHTTP[]					= "HTTP/";
DEC_CONST INT gc_cchHTTP					= CchConstString(gc_szHTTP);
DEC_CONST CHAR gc_szHTTP_0_9[]				= "HTTP/0.9";
DEC_CONST CHAR gc_szHTTP_1_0[]				= "HTTP/1.0";
DEC_CONST CHAR gc_szHTTP_1_1[]				= "HTTP/1.1";
DEC_CONST INT gc_cchHTTP_X_X				= CchConstString(gc_szHTTP_1_1);

DEC_CONST CHAR gc_szDavCompliance[]			= "DAV";

//	Default error -------------------------------------------------------------
//
DEC_CONST CHAR gc_szDefErr400StatusLine[]	= "400 Bad Request";
DEC_CONST CHAR gc_szDefErrStatusLine[]		= "500 Internal Server Failure";
DEC_CONST UINT gc_cchszDefErrStatusLine		= CchConstString(gc_szDefErrStatusLine);
DEC_CONST CHAR gc_szDefErrBody[] =
	"Content-Type: text/html\r\n"
	"Content-Length: 67\r\n"
	"\r\n"
	"<body><h1>"
	"HTTP/1.1 500 Internal Server Error(exception)"
	"</h1></body>";
DEC_CONST UINT gc_cchszDefErrBody			= CchConstString(gc_szDefErrBody);

//	Token error ---------------------------------------------------------------
//
DEC_CONST CHAR gc_szUsgErrBody[] =
	"Content-Type: text/html\r\n"
	"Content-Length: 69\r\n"
	"\r\n"
	"<body><h1>"
	"HTTP/1.1 500 Internal Server Error(USG support)"
	"</h1></body>";
DEC_CONST UINT gc_cchszUsgErrBody			= CchConstString(gc_szUsgErrBody);

//	INDEX response items ------------------------------------------------------
//
DEC_CONST WCHAR gc_wszAs[]					= L"as";
DEC_CONST WCHAR gc_wszCollectionResource[]	= L"DAV:collectionresource";
DEC_CONST WCHAR gc_wszContent_Encoding[]	= L"Content-Encoding";
DEC_CONST WCHAR gc_wszContent_Language[]	= L"Content-Language";
DEC_CONST WCHAR gc_wszContent_Length[]		= L"Content-Length";
DEC_CONST WCHAR gc_wszCreation_Date[]		= L"Creation-Date";
DEC_CONST WCHAR gc_wszDisplayName[]			= L"DisplayName";
DEC_CONST WCHAR gc_wszETag[]				= L"ETag";
DEC_CONST WCHAR gc_wszExternal[]			= L"External";
DEC_CONST WCHAR gc_wszHref[]				= L"href";
DEC_CONST WCHAR gc_wszIsCollection[]		= L"IsCollection";
DEC_CONST WCHAR gc_wszLast_Modified[]		= L"Last-Modified";
DEC_CONST WCHAR gc_wszMemberResource[]		= L"MemberResource";
DEC_CONST WCHAR gc_wszDav[]					= L"DAV:";
DEC_CONST WCHAR gc_wszProp[]				= L"DAV:prop";
DEC_CONST WCHAR gc_wszXML__Href[]			= L"DAV:href";
DEC_CONST WCHAR gc_wszXML__Namespace[]		= L"xml::namespace";

//	Partial response items ----------------------------------------------------
//
DEC_CONST WCHAR gc_wszErrorMessage[]		= L"DAV:responsedescription";
DEC_CONST WCHAR gc_wszStatus[]				= L"DAV:status";
DEC_CONST WCHAR gc_wszMultiResponse[]		= L"DAV:multistatus";
DEC_CONST WCHAR gc_wszResponse[]			= L"DAV:response";
DEC_CONST WCHAR gc_wszSearchResult[]		= L"DAV:searchresult";
DEC_CONST WCHAR gc_wszPropstat[] 			= L"DAV:propstat";
DEC_CONST WCHAR	gc_wszXML[]					= L"xml";
DEC_CONST WCHAR gc_wszContentRange[]		= L"DAV:contentrange";

//	Metadata items ------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszCreate[]				= L"DAV:create";
DEC_CONST WCHAR gc_wszSet[]					= L"DAV:set";
DEC_CONST WCHAR gc_wszGetProps[]			= L"DAV:getprops";
DEC_CONST WCHAR gc_wszPropfind[]			= L"DAV:propfind";
DEC_CONST WCHAR gc_wszPropertyUpdate[]		= L"DAV:propertyupdate";
DEC_CONST WCHAR gc_wszRemove[]				= L"DAV:remove";
DEC_CONST WCHAR gc_wszAllprop[]				= L"DAV:allprop";
DEC_CONST WCHAR gc_wszFullFidelity[]		= L"http://schemas.microsoft.com/exchange/allprop";
DEC_CONST WCHAR gc_wszFullFidelityExclude[]	= L"http://schemas.microsoft.com/exchange/exclude";
DEC_CONST WCHAR gc_wszFullFidelityInclude[]	= L"http://schemas.microsoft.com/exchange/include";
DEC_CONST WCHAR gc_wszPropname[]			= L"DAV:propname";
DEC_CONST WCHAR gc_wszCollection[]			= L"DAV:collection";

//	Version history report items ----------------------------------------------
//
DEC_CONST WCHAR	gc_wszEnumReport[]			= L"DAV:enumreport";
DEC_CONST WCHAR gc_wszLimit[]				= L"DAV:limit";
DEC_CONST WCHAR	gc_wszReport[]				= L"DAV:report";
DEC_CONST WCHAR	gc_wszDavDefaultHistory[]	= L"DAV:defaulthistory";
DEC_CONST UINT	gc_cchDavDefaultHistory		= CchConstString (gc_wszDavDefaultHistory);
DEC_CONST WCHAR	gc_wszRevision[]			= L"DAV:revision";

//	Search items --------------------------------------------------------------
//
DEC_CONST CHAR gc_szDasl[]					= "DASL";
DEC_CONST CHAR gc_szSqlQuery[]				= "<DAV:sql>";

DEC_CONST WCHAR gc_wszSearchRequest[]		= L"DAV:searchrequest";
DEC_CONST WCHAR gc_wszResoucetype[]			= L"DAV:resourcetype";
DEC_CONST WCHAR gc_wszStructureddocument[]	= L"DAV:structureddocument";
DEC_CONST WCHAR gc_wszSimpleSearch[]		= L"DAV:simple-search";
DEC_CONST WCHAR gc_wszType[]				= L"DAV:type";
DEC_CONST WCHAR gc_wszQuery[]				= L"DAV:query";
DEC_CONST WCHAR gc_wszSql[]					= L"DAV:sql";
DEC_CONST WCHAR gc_wszSelect[]				= L"Select";
DEC_CONST WCHAR gc_wszFrom[]				= L"From";
DEC_CONST WCHAR	gc_wszWhere[] 				= L"Where";
DEC_CONST WCHAR gc_wszOrder[]				= L"Order";
DEC_CONST WCHAR gc_wszBy[]					= L"By";
DEC_CONST WCHAR gc_wszServerHints[]			= L"DAV:serverhints";
DEC_CONST WCHAR	gc_wszMaxResults[]			= L"DAV:maxresults";
DEC_CONST WCHAR	gc_wszScope[] 				= L"Scope";
DEC_CONST WCHAR gc_wszRange[]				= L"DAV:range";
DEC_CONST WCHAR gc_wszRangeType[]			= L"DAV:type";
DEC_CONST WCHAR gc_wszRangeRows[]			= L"DAV:rows";
DEC_CONST WCHAR gc_wszExpansion[]			= L"DAV:expansion";

DEC_CONST WCHAR gc_wszStatic[]				= L"static";
DEC_CONST WCHAR gc_wszDynamic[]				= L"dynamic";

//	Batch method items --------------------------------------------------------
//
DEC_CONST WCHAR gc_wszTarget[]				= L"DAV:target";
DEC_CONST WCHAR gc_wszDelete[]				= L"DAV:delete";
DEC_CONST WCHAR gc_wszCopy[]				= L"DAV:copy";
DEC_CONST WCHAR gc_wszMove[]				= L"DAV:move";
DEC_CONST WCHAR gc_wszDest[]				= L"DAV:dest";
DEC_CONST WCHAR gc_wszLocation[]			= L"DAV:location";

//	Property types ------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszLexType[]				= L"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/dt";
DEC_CONST INT   gc_cchLexType				= CchConstString (gc_wszLexType);
DEC_CONST WCHAR gc_wszLexTypeOfficial[]		= L"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882#dt";
DEC_CONST WCHAR gc_wszDataTypes[]			= L"urn:schemas-microsoft-com:datatypes#dt";
DEC_CONST WCHAR gc_wszFlags[]				= L"urn:schemas:httpmail:flags";

DEC_CONST WCHAR gc_wszHrefAttribute[]		= L"urn:schemas:href";
DEC_CONST INT   gc_cchHrefAttribute			= CchConstString (gc_wszHrefAttribute);

DEC_CONST WCHAR gc_wszDavType_String[]		= L"string";
DEC_CONST WCHAR gc_wszDavType_Date_ISO8601[]= L"dateTime.tz";
DEC_CONST WCHAR gc_wszDavType_Date_Rfc1123[]= L"dateTime.rfc1123";
DEC_CONST WCHAR gc_wszDavType_Float[]		= L"float";
DEC_CONST WCHAR gc_wszDavType_Boolean[]		= L"boolean";
DEC_CONST WCHAR gc_wszDavType_Int[]			= L"int";
DEC_CONST WCHAR gc_wszDavType_Mvstring[]	= L"mv.string";
DEC_CONST WCHAR gc_wszDavType_Bin_Base64[]	= L"bin.base64";
DEC_CONST WCHAR gc_wszDavType_Bin_Hex[]		= L"bin.hex";
DEC_CONST WCHAR gc_wszDavType_I2[]			= L"i2";
DEC_CONST WCHAR gc_wszDavType_I8[]			= L"i8";
DEC_CONST WCHAR gc_wszDavType_R4[]			= L"r4";
DEC_CONST WCHAR gc_wszDavType_Fixed_14_4[]  = L"fixed.14.4";
DEC_CONST WCHAR gc_wszDavType_Uuid[]		= L"uuid";
DEC_CONST WCHAR gc_wszDavType_MV[]			= L"mv.";
DEC_CONST WCHAR gc_wszUri[]					= L"uri";

//	multivalue property	-------------------------------------------------------
//
DEC_CONST WCHAR gc_wszXml_V[]				= L"xml:v";

//	URI Construction ----------------------------------------------------------
//
DEC_CONST CHAR gc_szUrl_Prefix[]			= "http://";
DEC_CONST WCHAR gc_wszUrl_Prefix[]			= L"http://";
DEC_CONST INT gc_cchszUrl_Prefix			= CchConstString(gc_szUrl_Prefix);
DEC_CONST CHAR gc_szUrl_Prefix_Secure[]		= "https://";
DEC_CONST WCHAR gc_wszUrl_Prefix_Secure[]	= L"https://";
DEC_CONST INT gc_cchszUrl_Prefix_Secure		= CchConstString(gc_szUrl_Prefix_Secure);
DEC_CONST WCHAR	gc_wszFileScheme[]			= L"file://";
DEC_CONST INT gc_strlenFileScheme			= CchConstString(gc_wszFileScheme);

DEC_CONST CHAR gc_szUrl_Fmt_Http[]			= "%hs%hs%hs";
DEC_CONST WCHAR gc_wszUrl_Fmt_Http[]		= L"%hs%hs%hs";
DEC_CONST INT gc_cbszUrl_Fmt_Http			= sizeof(gc_szUrl_Fmt_Http);
DEC_CONST WCHAR gc_wszUrl_Port_80[]			= L":80";
DEC_CONST INT gc_cchUrl_Port_80				= CchConstString(gc_wszUrl_Port_80);
DEC_CONST WCHAR gc_wszUrl_Port_443[]		= L":443";
DEC_CONST INT gc_cchUrl_Port_443			= CchConstString(gc_wszUrl_Port_443);

//	Special metaprops ---------------------------------------------------------
//
DEC_CONST WCHAR	gc_wszProp_ContentType[]	= L"ContentType";

//	Performance counters ------------------------------------------------------
//
DEC_CONST WCHAR	gc_wsz_Total[]				= L"_Total";

//	Metabase strings ----------------------------------------------------------
//
DEC_CONST WCHAR gc_wsz_Lm_MimeMap[]			= L"/lm/MimeMap";
DEC_CONST INT gc_cch_Lm_MimeMap				= CchConstString(gc_wsz_Lm_MimeMap);

DEC_CONST CHAR gc_sz_Lm_W3Svc[]				= "/lm/w3svc";
DEC_CONST WCHAR gc_wsz_Lm_W3Svc[]			= L"/lm/w3svc";
DEC_CONST INT gc_cch_Lm_W3Svc				= CchConstString(gc_sz_Lm_W3Svc);

DEC_CONST WCHAR gc_wsz_Root[]				= L"/root";
DEC_CONST INT gc_cch_Root					= CchConstString(gc_wsz_Root);
DEC_CONST WCHAR gc_wsz_Lm_Pop3Svc[]			= L"/lm/pop3svc";
DEC_CONST CHAR gc_sz_Star[]					= "*";
DEC_CONST WCHAR gc_wsz_Star[]				= L"*";

//	Lock strings --------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszOpaquelocktokenPrefix[] = L"opaquelocktoken:";
DEC_CONST INT   gc_cchOpaquelocktokenPrefix  = CchConstString(gc_wszOpaquelocktokenPrefix);
DEC_CONST WCHAR gc_wszLockTypeRead[]         = L"DAV:read";
DEC_CONST CHAR  gc_szLockTokenHeader[]       = "Lock-Token";
DEC_CONST WCHAR gc_wszGuidFormat[]          = L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X";

//  Size in characters required for an ascii string which contains
//  a GUID in the swprintf'ed gc_wszGuidFormat
//
DEC_CONST INT   gc_cchMaxGuid                = 37;  // Not the size of format string: size of formatted guid

//	CRC'd strings -------------------------------------------------------------
//
//	IMPORTANT: if you feel the need to change any of these strings, then you
//	really need to re-crc it and update the value.  Failure to do so will cause
//	unpredicitible results and possible termination (of the app, not you).
//
//	The CRC's are maintained in the impls' meta sources

#define IanaItem(_sz)							\
	DEC_CONST WCHAR gc_wszProp_iana_##_sz[] =	\
		L"DAV:" L#_sz;							\

IanaItem(getcontentencoding);
IanaItem(getcontentlanguage);
IanaItem(getcontentlength);
IanaItem(getcontenttype);
IanaItem(creationdate);
IanaItem(displayname);
IanaItem(getetag);
IanaItem(filename);
IanaItem(getlastmodified);
IanaItem(externalmembers);
IanaItem(resourcetype);
IanaItem(ishidden);
IanaItem(iscollection);

#define MAX_GUID_STRING_SIZE	40

#define BizItem(_sz)							\
	DEC_CONST WCHAR gc_wszProp_iana_##_sz[] =	\
		L"http://www.bizprop.com/" L#_sz;		\

#endif	// !_EX_SZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_cnvt\base64.cpp ===
/*
 *	B A S E 6 4 . C P P
 *
 *	Sources Base64 encoding
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

#include <malloc.h>				// For _alloca declaration ONLY!
#include <string.h>
#include <stdio.h>

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>

#include <caldbg.h>
#include <ex\calcom.h>
#include <ex\cnvt.h>
#include <davsc.h>

/* From RFC 1521:

5.2.  Base64 Content-Transfer-Encoding

   The Base64 Content-Transfer-Encoding is designed to represent
   arbitrary sequences of octets in a form that need not be humanly
   readable.  The encoding and decoding algorithms are simple, but the
   encoded data are consistently only about 33 percent larger than the
   unencoded data.	This encoding is virtually identical to the one used
   in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
   The base64 encoding is adapted from RFC 1421, with one change: base64
   eliminates the "*" mechanism for embedded clear text.

	  A 65-character subset of US-ASCII is used, enabling 6 bits to be
   represented per printable character. (The extra 65th character, "=",
   is used to signify a special processing function.)

	  NOTE: This subset has the important property that it is
	  represented identically in all versions of ISO 646, including US
	  ASCII, and all characters in the subset are also represented
	  identically in all versions of EBCDIC.  Other popular encodings,
	  such as the encoding used by the uuencode utility and the base85
	  encoding specified as part of Level 2 PostScript, do not share
	  these properties, and thus do not fulfill the portability
	  requirements a binary transport encoding for mail must meet.

   The encoding process represents 24-bit groups of input bits as output
   strings of 4 encoded characters. Proceeding from left to right, a
   24-bit input group is formed by concatenating 3 8-bit input groups.
   These 24 bits are then treated as 4 concatenated 6-bit groups, each
   of which is translated into a single digit in the base64 alphabet.
   When encoding a bit stream via the base64 encoding, the bit stream
   must be presumed to be ordered with the most-significant-bit first.
   That is, the first bit in the stream will be the high-order bit in
   the first byte, and the eighth bit will be the low-order bit in the
   first byte, and so on.

   Each 6-bit group is used as an index into an array of 64 printable
   characters. The character referenced by the index is placed in the
   output string. These characters, identified in Table 1, below, are
   selected so as to be universally representable, and the set excludes
   characters with particular significance to SMTP (e.g., ".", CR, LF)
   and to the encapsulation boundaries defined in this document (e.g.,
   "-").

			   Table 1: The Base64 Alphabet

	  Value Encoding  Value Encoding  Value Encoding  Value Encoding
		   0 A			  17 R			  34 i			  51 z
		   1 B			  18 S			  35 j			  52 0
		   2 C			  19 T			  36 k			  53 1
		   3 D			  20 U			  37 l			  54 2
		   4 E			  21 V			  38 m			  55 3
		   5 F			  22 W			  39 n			  56 4
		   6 G			  23 X			  40 o			  57 5
		   7 H			  24 Y			  41 p			  58 6
		   8 I			  25 Z			  42 q			  59 7
		   9 J			  26 a			  43 r			  60 8
		  10 K			  27 b			  44 s			  61 9
		  11 L			  28 c			  45 t			  62 +
		  12 M			  29 d			  46 u			  63 /
		  13 N			  30 e			  47 v
		  14 O			  31 f			  48 w		   (pad) =
		  15 P			  32 g			  49 x
		  16 Q			  33 h			  50 y

   The output stream (encoded bytes) must be represented in lines of no
   more than 76 characters each.  All line breaks or other characters
   not found in Table 1 must be ignored by decoding software.  In base64
   data, characters other than those in Table 1, line breaks, and other
   white space probably indicate a transmission error, about which a
   warning message or even a message rejection might be appropriate
   under some circumstances.

   Special processing is performed if fewer than 24 bits are available
   at the end of the data being encoded.  A full encoding quantum is
   always completed at the end of a body.  When fewer than 24 input bits
   are available in an input group, zero bits are added (on the right)
   to form an integral number of 6-bit groups.	Padding at the end of
   the data is performed using the '=' character.  Since all base64
   input is an integral number of octets, only the following cases can
   arise: (1) the final quantum of encoding input is an integral
   multiple of 24 bits; here, the final unit of encoded output will be
   an integral multiple of 4 characters with no "=" padding, (2) the
   final quantum of encoding input is exactly 8 bits; here, the final
   unit of encoded output will be two characters followed by two "="
   padding characters, or (3) the final quantum of encoding input is
   exactly 16 bits; here, the final unit of encoded output will be three
   characters followed by one "=" padding character.

   Because it is used only for padding at the end of the data, the
   occurrence of any '=' characters may be taken as evidence that the
   end of the data has been reached (without truncation in transit).  No
   such assurance is possible, however, when the number of octets
   transmitted was a multiple of three.

   Any characters outside of the base64 alphabet are to be ignored in
   base64-encoded data.	 The same applies to any illegal sequence of
   characters in the base64 encoding, such as "====="

   Care must be taken to use the proper octets for line breaks if base64
   encoding is applied directly to text material that has not been
   converted to canonical form.	 In particular, text line breaks must be
   converted into CRLF sequences prior to base64 encoding. The important
   thing to note is that this may be done directly by the encoder rather
   than in a prior canonicalization step in some implementations.

	  NOTE: There is no need to worry about quoting apparent
	  encapsulation boundaries within base64-encoded parts of multipart
	  entities because no hyphen characters are used in the base64
	  encoding.

*/

VOID inline
EncodeAtom (LPBYTE pbIn, WCHAR* pwszOut, UINT cbIn)
{
	static const WCHAR wszBase64[] = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
									 L"abcdefghijklmnopqrstuvwxyz"
									 L"0123456789+/";
	Assert (pbIn);
	Assert (pwszOut);
	Assert (cbIn);

	//	Set cbIn to 3 if it's greater than three: convenient for 'switch'
	//
	if (cbIn > 3)
		cbIn = 3;

	pwszOut[0] = wszBase64[pbIn[0] >> 2];
	switch(cbIn)
	{
		case 3:

			//	End of stream has not been reached yet
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[((pbIn[1] & 0x0F) << 2) + (pbIn[2] >> 6)];
			pwszOut[3] = wszBase64[pbIn[2] & 0x3F];
			return;

		case 2:

			//	At the end of stream: pad with 1 byte
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[ (pbIn[1] & 0x0F) << 2];
			pwszOut[3] = L'=';
			return;

		case 1:

			//	At the end of stream: pad with 2 bytes
			//
			pwszOut[1] = wszBase64[ (pbIn[0] & 0x03) << 4];
			pwszOut[2] = L'=';
			pwszOut[3] = L'=';
			return;

		default:

			//	Should never happen
			//
			Assert (FALSE);
	}
}

VOID inline
EncodeAtomA (LPBYTE pbIn, LPBYTE pbOut, UINT cbIn)
{
	static const CHAR szBase64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
								   "abcdefghijklmnopqrstuvwxyz"
								   "0123456789+/";
	Assert (pbIn);
	Assert (pbOut);
	Assert (cbIn);

	//	Set cbIn to 3 if it's greater than three: convenient for 'switch'
	//
	if (cbIn > 3)
		cbIn = 3;

	pbOut[0] = szBase64[pbIn[0] >> 2];
	switch(cbIn)
	{
		case 3:

			//	End of stream has not been reached yet
			//
			pbOut[1] = szBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pbOut[2] = szBase64[((pbIn[1] & 0x0F) << 2) + (pbIn[2] >> 6)];
			pbOut[3] = szBase64[pbIn[2] & 0x3F];
			return;

		case 2:

			//	At the end of stream: pad with 1 byte
			//
			pbOut[1] = szBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pbOut[2] = szBase64[ (pbIn[1] & 0x0F) << 2];
			pbOut[3] = '=';
			return;

		case 1:

			//	At the end of stream: pad with 2 bytes
			//
			pbOut[1] = szBase64[ (pbIn[0] & 0x03) << 4];
			pbOut[2] = '=';
			pbOut[3] = '=';
			return;

		default:

			//	Should never happen
			//
			Assert (FALSE);
	}
}

//	------------------------------------------------------------------------
//	EncodeBase64
//
//	Encode cbIn bytes of data from pbIn into the provided buffer
//	at pwszOut, up to cchOut chars.
//$REVIEW: Shouldn't this function return some kind of error if
//$REVIEW: cchOut didn't have enough space for the entire output string?!!!
//
void
EncodeBase64 (LPBYTE pbIn, UINT cbIn, WCHAR* pwszOut, UINT cchOut)
{
	//	They must have passed us at least one char of space -- for the terminal NULL.
	Assert (cchOut);

	//	Loop through, encoding atoms as we go...
	//
	while (cbIn)
	{
		//	NOTE: Yes, test for STRICTLY more than 4 WCHARs of space.
		//	We will use 4 WCHARs on this pass of the loop, and we always
		//	need one for the terminal NULL!
		Assert (cchOut > 4);

		//	Encode the next three bytes of data into four chars of output string.
		//	(NOTE: This does handle the case where we have <3 bytes of data
		//	left to encode -- thus we pass in cbIn!)
		//
		EncodeAtom (pbIn, pwszOut, cbIn);

		//	Update our pointers and counters.
		pbIn += min(cbIn, 3);
		pwszOut += 4;
		cchOut -= 4;
		cbIn -= min(cbIn, 3);
	}

	//	Ensure Termination
	//	(But first, check that we still have one WCHAR of space left
	//	for the terminal NULL!)
	//
	Assert (cchOut >= 1);
	*pwszOut = 0;
}

void
EncodeBase64A (LPBYTE pbIn, UINT cbIn, LPBYTE pbOut, UINT cbOut, BOOL fTerminate)
{
	//	They must have passed us at least one char of space -- for the terminal NULL,
	//	but only in the case where we are asked to terminate the string
	//
	Assert (cbOut || !fTerminate);

	//	Loop through, encoding atoms as we go...
	//
	while (cbIn)
	{
		//	NOTE: Yes, test for having exactly 4 bytes or more.
		//	We cannot use STRICT > 4 as we may be required not
		//	to do the '\0' termination
		//
		Assert (cbOut >= 4);

		//	Encode the next three bytes of data into four chars of output string.
		//	(NOTE: This does handle the case where we have <3 bytes of data
		//	left to encode -- thus we pass in cbIn!)
		//
		EncodeAtomA	(pbIn, pbOut, cbIn);

		//	Update our pointers and counters.
		pbIn += min(cbIn, 3);
		pbOut += 4;
		cbOut -= 4;
		cbIn -= min(cbIn, 3);
	}

	if (fTerminate)
	{
		//	Ensure Termination
		//	(But first, check that we still have one CHAR of space left
		//	for the terminal NULL!)
		//
		Assert (cbOut >= 1);
		*pbOut = 0;
	}
}

SCODE
ScDecodeBase64 (WCHAR* pwszIn, UINT cchIn, LPBYTE pbOut, UINT* pcbOut)
{
	//	Base64 Reverse alphabet.  Indexed by base 64 alphabet character
	//
	static const BYTE bEq = 254;
	static const BYTE rgbDict[128] = {

		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 0-F
		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 10-1F
		255,255,255,255,255,255,255,255,255,255,255, 62,255,255,255, 63,	// 20-2F
		 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,255,255,255,bEq,255,255,	// 30-3f
		255,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,	// 40-4f
		 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,255,255,255,255,255,	// 50-5f
		255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,	// 60-6f
		 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,255,255,255,255,255		// 70-7f
	};

	SCODE sc = S_OK;

	UINT cchConsumed = 0;
	UINT cbProduced = 0;
	UINT cbFudge = 0;

	Assert (pbOut);
	Assert (pcbOut);

	//	Check that they didn't lie about the size of their buffer!
	//
	Assert (!IsBadWritePtr(pbOut, *pcbOut));

	//	Check that the size of the output buffer is adequate for
	//	decoded data.
	//
	Assert (*pcbOut >= CbNeededDecodeBase64(cchIn));
	Assert (pwszIn);

	//	Output is generated in 3-byte increments for 4 bytes of input
	//
	Assert ((cchIn*3)/4 <= *pcbOut);
	
	//	Go until there is nothing left to decode...
	//
	while (cchConsumed < cchIn)
	{
		Assert (cbProduced <= *pcbOut);

		BYTE rgb[4];
		UINT ib = 0;
		
		//	However, if there is not enough space to
		//	decode the next atom into, then this has
		//	got to be an error...
		//
		if (*pcbOut - cbProduced < 3)
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Not enough space to decode next base64 atom.");
			break;
		}

		//	The characters that do not fall into base 64 alphabet must be
		//	ignored, so let us assemble the 4 byte chunk of data that we
		//	will actually go with for the conversion
		//
		while ((cchConsumed < cchIn) &&
			   (ib < 4))
		{
			//	If the symbol is in the alphabet ...
			//
			if ((pwszIn[cchConsumed] < sizeof(rgbDict)) &&
				(rgbDict[pwszIn[cchConsumed]] != 0xFF))
			{
				//	...	save the character off into the
				//	array
				//
				rgb[ib++] = rgbDict[pwszIn[cchConsumed]];
			}

			//	... go for the next character in the line
			//
			cchConsumed++;
		}

		//	If there is no more data at all, then go
		//	away with no error, as up to that point
		//	we converted everything just fine, and
		//	the characters in the end were ignorable
		//
		if (0 == ib)
		{
			Assert(cchConsumed == cchIn);
			break;
		}
		else if ((4 != ib) || (0 != cbFudge))
		{
			//	There was some data to convert, but not enough to fill in
			//	the 4 byte buffer then data is incomplete and cannot be converted;
			//	If the end bEq markers were present some time before, data
			//	is also invalid, there should not be any data after the end
			//
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, data not complete, or extra data after padding: %ws\n", pwszIn);
			break;
		}

		//	Check that the characters 1 and 2 are not bEq
		//
		if ((rgb[0] == bEq) ||
			(rgb[1] == bEq))
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected: %ws\n", pwszIn);
			break;
		}

		//	Check if the third character is bEq
		//
		if (rgb[2] == bEq)
		{
			rgb[2] = 0;
			cbFudge += 1;

			//	... the fourth should be also bEq if the third was that way
			//
			if (rgb[3] != bEq)
			{
				sc = E_DAV_BASE64_ENCODING_ERROR;
				DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected:  %ws\n", pwszIn);
				break;
			}
		}

		//	Check if the fourth character is bEq
		//
		if (rgb[3] == bEq)
		{
			rgb[3] = 0;
			cbFudge += 1;
		}

		//	Make sure that these are well formed 6bit characters.
		//
		Assert((rgb[0] & 0x3f) == rgb[0]);
		Assert((rgb[1] & 0x3f) == rgb[1]);
		Assert((rgb[2] & 0x3f) == rgb[2]);
		Assert((rgb[3] & 0x3f) == rgb[3]);

		//	Ok, we now have 4 6bit characters making up the 3 bytes of output.
		//
		//	Assemble them together to make a 3 byte word.
		//
		DWORD dwValue = (rgb[0] << 18) +
						(rgb[1] << 12) +
						(rgb[2] << 6) +
						(rgb[3]);

		//	This addition had better not have wrapped.
		//
		Assert ((dwValue & 0xff000000) == 0);

		//	Copy over the 3 bytes into the output stream.
		//
		pbOut[0] = (BYTE)((dwValue & 0x00ff0000) >> 16);
		Assert(pbOut[0] == (rgb[0] << 2) + (rgb[1] >> 4));
		pbOut[1] = (BYTE)((dwValue & 0x0000ff00) >>	 8);
		Assert(pbOut[1] == ((rgb[1] & 0xf) << 4) + (rgb[2] >> 2));
		pbOut[2] = (BYTE)((dwValue & 0x000000ff) >>	 0);
		Assert(pbOut[2] == ((rgb[2] & 0x3) << 6) + rgb[3]);
		cbProduced += 3;
		pbOut += 3;

		//	If cbFudge is non 0, it means we had "=" signs at the end
		//	of the buffer.	In this case, we overcounted the actual
		//	number of characters in the buffer.
		//
		//	Although cbFuge is counted in 6 bit chunks, but it assumes
		//	values just 0, 1 or 2. And that allows us to say that the
		//	number of bytes actually produced were by cbFuge less.
		//	Eg. if cbFuge = 1, then uuuuuu is padded, which could
		//		happen only when zzzzzzzz chunk was empty
		//		if cbFuge = 2, then zzzzzz uuuuuu is padded, which could
		//		happen only when yyyyyyyy and zzzzzzzz were empty
		//
		//	xxxxxx yyyyyy zzzzzz uuuuuu <- 6 bit chunks
		//	xxxxxx xxyyyy yyyyzz zzzzzz	<- 8 bit chunks
		//
		if (cbFudge)
		{
			Assert ((cbFudge < 3) && (cbFudge < cbProduced));
			cbProduced -= cbFudge;
			pbOut -= cbFudge;
		}		
	}

	//	Tell the caller the actuall size...
	//
	*pcbOut = cbProduced;
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_cnvt\cnvt.cpp ===
/*
 *	C N V T . C P P
 *
 *	Data conversion routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

#include <malloc.h>				// For _alloca declaration ONLY!
#include <string.h>
#include <stdio.h>

//	Windows headers
//
#include <windows.h>

//	CAL common headers
//
#include <caldbg.h>
#include <ex\calcom.h>
#include <ex\cnvt.h>
#include <ex\exmem.h>
#include <davsc.h>
#include <ex\stackbuf.h>
#include <ex\autoptr.h>

//	Month names ---------------------------------------------------------------
//
DEC_CONST LPCWSTR c_rgwszMonthNames[] =
{
	L"Jan",
	L"Feb",
	L"Mar",
	L"Apr",
	L"May",
	L"Jun",
	L"Jul",
	L"Aug",
	L"Sep",
	L"Oct",
	L"Nov",
	L"Dec",
};
DEC_CONST ULONG c_cMonthNames = CElems(c_rgwszMonthNames);
DEC_CONST ULONG c_cchMonthName = 3;

DEC_CONST LPCWSTR c_rgwszDayNames[] =
{
	L"Sun",
	L"Mon",
	L"Tue",
	L"Wed",
	L"Thu",
	L"Fri",
	L"Sat",
};
DEC_CONST UINT c_cDayNames = CElems(c_rgwszDayNames);
DEC_CONST UINT c_cchDayName = 3;

//	Date formats --------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszIso8601_min[]			= L"yyyy-mm-ddThh:mm:ssZ";
DEC_CONST UINT	gc_cchIso8601_min			= CchConstString(gc_wszIso8601_min);
DEC_CONST WCHAR gc_wszIso8601_scanfmt[]		= L"%04hu-%02hu-%02huT%02hu:%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_tz_scanfmt[]	= L"%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_fmt[]			= L"%04d-%02d-%02dT%02d:%02d:%02d.%03dZ";
DEC_CONST WCHAR gc_wszRfc1123_min[]			= L"www, dd mmm yyyy hh:mm:ss GMT";
DEC_CONST UINT	gc_cchRfc1123_min			= CchConstString (gc_wszRfc1123_min);
DEC_CONST WCHAR gc_wszRfc1123_fmt[] 		= L"%ls, %02d %ls %04d %02d:%02d:%02d GMT";

enum {
	tf_year,
	tf_month,
	tf_day,
	tf_hour,
	tf_minute,
	tf_second,
	cTimeFields,

	tz_hour = 0,
	tz_minute,
	cTzDeltaFields,

	RADIX_BASE = 10,
};

//	Conversion functions ------------------------------------------------------
//
/*
 *	CchFindChar
 *
 *	Look for the given char, obeying the cbMax limit.
 *	If the char is not found, return INVALID_INDEX.
 */
UINT __fastcall
CchFindChar(WCHAR wch, LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   wch != *pwszData)
	{
		cchParsed++;
		pwszData++;
	}

	if (cchParsed == cchMax)
		cchParsed = INVALID_INDEX;
	return cchParsed;
}

/*
 *	CchSkipWhitespace
 *
 *	Skips whitespace, obeying the cbMax limit.
 *	Returns the number of bytes parsed.
 */
UINT __fastcall
CchSkipWhitespace(LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   (L' ' == *pwszData ||
			L'\t' == *pwszData ||
			L'\n' == *pwszData ||
			L'\r' == *pwszData))
	{
		cchParsed++;
		pwszData++;
	}
	return cchParsed;
}

LONG __fastcall
LNumberFromParam(LPCWSTR pwszData, UINT cchMax)
{
	LONG lReturn = 0;
	UINT cchCurrent = 0;
	BOOL fNegative = FALSE;

	// Get any sign char.
	//
	if (L'-' == *pwszData)
	{
		// Set the negative flag to true.
		//
		fNegative = TRUE;

		// Skip this valid character.
		//
		cchCurrent++;

		// Skip any whitespace.
		//
		cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
	}
	else if (L'+' == *pwszData)
	{
		// Skip any whitespace.
		//
		cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
	}

	// From here, any non-number chars are invalid & mean we
	// should stop parsing.

	// Get the magnitude of the number.
	//
	while (cchCurrent < cchMax)
	{
		if (L'0' <= static_cast<USHORT>(pwszData[cchCurrent]) &&
		    L'9' >= static_cast<USHORT>(pwszData[cchCurrent]))
		{
			lReturn *= 10;
			lReturn += (pwszData[cchCurrent] - L'0');
		}
		else
		{
			// Not a number char.  Time to quit parsing.
			//
			break;
		}

		// Move to the next char.
		//
		cchCurrent++;
	}

	// Apply the negative sign, if any.
	//
	if (fNegative)
		lReturn = (0 - lReturn);

	return lReturn;
}

HRESULT __fastcall
HrHTTPDateToFileTime(LPCWSTR pwszDate,
					 FILETIME * pft)
{
	HRESULT		hr;
	SYSTEMTIME	systime;
	UINT		cchDate;

	//	Make sure we were passed something as a date string.
	//
	Assert(pwszDate);
	Assert(pft);

	//	Zero out the structure.
	//
	memset(&systime, 0, sizeof(SYSTEMTIME));

	//	Get the length of the date string.
	//
	cchDate = static_cast<UINT>(wcslen(pwszDate));

	//	Get the date and time pieces.  If either fails, return its
	//	error code.  Otherwise, convert to a file time at the end,
	//	return E_FAIL if the conversion fails, S_OK otherwise.
	//
	hr = GetFileDateFromParam(pwszDate,
							  cchDate,
							  &systime);
	if (FAILED(hr))
		return hr;

	hr = GetFileTimeFromParam(pwszDate,
							  cchDate,
							  &systime);

	if (FAILED(hr))
		return hr;

	if (!SystemTimeToFileTime(&systime, pft))
		return E_FAIL;

	return S_OK;
}

HRESULT __fastcall
GetFileDateFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;

	// If the first char's of the date are ddd, then the day of the
	// week is a part of the date, and we really do not care.
	//
	if ( L'9' < static_cast<USHORT>(*pwszCurrent))
	{
		// Find the day
		//
		UINT uiDay;
		for (uiDay = 0; uiDay < c_cDayNames; uiDay++)
		{
			// Compare the month names.
			//
			if (*pwszCurrent == *(c_rgwszDayNames[uiDay]) &&
				!_wcsnicmp(pwszCurrent, c_rgwszDayNames[uiDay], c_cchDayName))
			{
				// Found the right month.  This index tells us the month number.
				//
				psystime->wDayOfWeek = static_cast<WORD>(uiDay);  // Sunday is 0
				break;
			}
		}
		if (uiDay == c_cDayNames)
			return E_FAIL;

		// Look for our space delimiter.
		//
		cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
		if (INVALID_INDEX == cchTemp)
		{
			// Invalid format to this data. Fail here.
			//
			return E_FAIL;
		}
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;

		// Again, skip whitespace.
		//
		cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;
	}

	// The date format is dd month yyyy.  Anything else is invalid.

	// Get the day-of-the-month number.
	//
	psystime->wDay = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Find the month number.
	//
	for (UINT uiMonth = 0; uiMonth < c_cMonthNames; uiMonth++)
	{
		// Compare the month names.
		//
		if (*pwszCurrent == *(c_rgwszMonthNames[uiMonth]) &&
			!_wcsnicmp(pwszCurrent, c_rgwszMonthNames[uiMonth], c_cchMonthName))
		{
			// Found the right month.  This index tells us the month number.
			//
			psystime->wMonth = static_cast<WORD>(uiMonth + 1);  // January is 1.
			break;
		}
	}

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Now get the year.
	//
	psystime->wYear = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	return S_OK;
}

HRESULT __fastcall
GetFileTimeFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;

	// Skip any date information.  This could get called for date-time params!

	// Look for the first colon delimiter. Yes, we assume no colons in date info!
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No time info available. Fail here.
		//
		return E_FAIL;
	}
	cchTemp--;		// Back up to get the hours digits.
	cchTemp--;
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Skip whitespace (in case the parm is h:mm:ss).
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Time format is hh:mm:ss UT, GMT, +- hh:mm, anything else is invalid.
	// (Actually, we allow [h]h:mm[:ss], and whitespace around the colons.)

	// Get the hours.
	//
	psystime->wHour = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No minutes specified.  This is not allowed.  Fail here.
		//
		return E_FAIL;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Get the minutes.
	//
	psystime->wMinute = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// NOTE: The seconds are optional.  Don't fail here!

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No seconds specified.  This is allowed.  Return success.
		//
		return S_OK;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Get the seconds, if any.
	//
	psystime->wSecond = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// LATER: Get the timezone spec from the line and shift this data into our timezone...

	return S_OK;
}

BOOL __fastcall
FGetSystimeFromDateIso8601(LPCWSTR pwszDate, SYSTEMTIME * psystime)
{
	UINT i;

	// 	Iso8601 is a fixed digit format: "yyyy-mm-ddThh:mm:ssZ"
	//	we require the date strings has at least the required
	//	chars (we allow for the ommission of the fractional
	//	seconds, and the time delta), otherwise it is an error.
	//
	if (gc_cchIso8601_min > static_cast<UINT>(wcslen(pwszDate)))
	{
		DebugTrace ("Dav: date length < than minimal\n");
		return FALSE;
	}

	//	Scan the first bit of date information up to the
	//	optional bits
	//
	psystime->wMilliseconds = 0;
	if (cTimeFields != swscanf (pwszDate,
								gc_wszIso8601_scanfmt,
								&psystime->wYear,
								&psystime->wMonth,
								&psystime->wDay,
								&psystime->wHour,
								&psystime->wMinute,
								&psystime->wSecond))
	{
		DebugTrace ("Dav: minimal scan failed\n");
		return FALSE;
	}

	//	Take a look at what is next and process accordingly.
	//
	//	('Z'), ('.'), ('+') and ('-').
	//
	//	The ('Z') element signifies ZULU time and completes
	//	the time string.  The ('.') element signifies that a
	//	fractional second value follows.  And either a ('+')
	//	or ('-') element indicates that a timezone delta will
	//	follow.
	//
	i = gc_cchIso8601_min - 1;
	if (pwszDate[i] == L'Z')
		goto ret;
	else if (pwszDate[i] == L'.')
		goto frac_sec;
	else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'+'))
		goto tz_delta;

	DebugTrace ("Dav: minimal date not terminated properly\n");
	return FALSE;

frac_sec:

	Assert (pwszDate[i] == L'.');
	{
		UINT iFrac;

		for (iFrac = ++i; pwszDate[i]; i++)
		{
			//	Any non-digit terminates the fractional seconds time
			//
			if ((pwszDate[i] > L'9') || (pwszDate[i] < L'0'))
			{
				//	At this point, we are expecting ('Z') or a timezone
				//	delta ('+') or ('-')
				//
				if (pwszDate[i] == L'Z')
					goto ret;
				else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'))
					goto tz_delta;

				break;
			}

			//	It turns out, our granularity is only milliseconds, so
			//	we cannot keep any better precision than that.  However,
			//	we can round the last digit, so at best we will process
			//	the next four digits
			//
			if (i - iFrac < 3)
			{
				//	As many digits remain, comprise the fractional
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds * RADIX_BASE + (pwszDate[i]-L'0'));
			}
			else if (i - iFrac < 4)
			{
				//	Our granularity is only milliseconds, so we cannot keep
				//	any better precision than that.  However, we can round this
				//	digit.
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds + (((pwszDate[i]-L'0')>4)?1:0));
			}
		}

		//	We ran out of string before the time was terminated
		//
		return FALSE;
	}

tz_delta:

	Assert ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'));
	{
		WORD wHr;
		WORD wMin;
		__int64 tm;
		__int64 tzDelta;
		static const __int64 sc_i64Min = 600000000;
		static const __int64 sc_i64Hr = 36000000000;
		FILETIME ft;

		//	Find the time delta in terms of FILETIME units
		//
		if (cTzDeltaFields != swscanf (pwszDate + i + 1,
									   gc_wszIso8601_tz_scanfmt,
									   &wHr,
									   &wMin))
		{
			DebugTrace ("Dav: tz delta scan failed\n");
			return FALSE;
		}
		tzDelta = (sc_i64Hr * wHr) + (sc_i64Min * wMin);

		//	Convert the time into a FILETIME, and stuff it into
		//	a 64bit integer
		//
		if (!SystemTimeToFileTime (psystime, &ft))
		{
			DebugTrace ("Dav: invalid time specified\n");
			return FALSE;
		}
		tm = FileTimeCastToI64(ft);

		//	Apply the delta
		//
		if (pwszDate[i] == L'+')
			tm = tm + tzDelta;
		else
		{
			Assert (pwszDate[i] == L'-');
			tm = tm - tzDelta;
		}

		//	Return the value converted back into a SYSTEMTIME
		//
		ft = I64CastToFileTime(tm);
		if (!FileTimeToSystemTime (&ft, psystime))
		{
			DebugTrace ("Dav: delta invalidated time\n");
			return FALSE;
		}
	}

ret:

	return TRUE;
}

BOOL __fastcall
FGetDateIso8601FromSystime(SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchIso8601_min >= cchSize)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszIso8601_fmt,
						 psystime->wYear,
						 psystime->wMonth,
						 psystime->wDay,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond,
						 psystime->wMilliseconds));
}

BOOL __fastcall
FGetDateRfc1123FromSystime (SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchRfc1123_min >= cchSize)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszRfc1123_fmt,
						 c_rgwszDayNames[psystime->wDayOfWeek],
						 psystime->wDay,
						 c_rgwszMonthNames[psystime->wMonth - 1],
						 psystime->wYear,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond));
}

//	BCharToHalfByte -----------------------------------------------------------
//
//	Switches a wide char to a half-byte hex value.  The incoming char
//	MUST be in the "ASCII-encoded hex digit" range: 0-9, A-F, a-f.
//
DEC_CONST BYTE gc_mpbchCharToHalfByte[] = {

	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,	0x8,0x9,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Caps here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Lowercase here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

inline BYTE BCharToHalfByte(WCHAR ch)
{
	//	gc_mpbchCharToHalfByte - map a ASCII-encoded char representing a single hex
	//	digit to a half-byte value.  Used to convert hex represented strings into a
	//	binary representation.
	//
	//	Reference values:
	//
	//		'0' = 49, 0x31;
	//		'A' = 65, 0x41;
	//		'a' = 97, 0x61;
	//
    AssertSz (!(ch & 0xFF00), "BCharToHalfByte: char upper bits non-zero");
    AssertSz (iswxdigit(ch), "Char out of hex digit range.");

    return gc_mpbchCharToHalfByte[ch];
}

//	------------------------------------------------------------------------
//	c_mpwchbStringize - map a half-byte (low nibble) value to
//		the correspoding ASCII-encoded wide char.
//	Used to convert binary data into Unicode URL strings.
//
DEC_CONST WCHAR c_mpwchhbStringize[] =
{
	L'0', L'1', L'2', L'3',
	L'4', L'5', L'6', L'7',
	L'8', L'9', L'a', L'b',
	L'c', L'd', L'e', L'f',
};

//	------------------------------------------------------------------------
//	WchHalfByteToWideChar
//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline WCHAR WchHalfByteToWideChar(BYTE b)
{
	AssertSz(!(b & 0xF0), "Garbage in upper nibble.");
	return c_mpwchhbStringize[b];
};

//	==========================================================================
//
//	UTILITY FUNCTIONS
//		Used in building some props -- like getetag, resourcetag and flat url.
//		This code has been moved from calcprops.cpp to exprops.cpp and now to
//		cnvt.cpp. The Flat URL code lives in this file because it is needed
//		by _storext, exdav and davex. _props is the other component which is
//		shared by all of them. But _cnvt seemed like a better place to put
//		it. The other utility functions are needed by the flat url generation
//		code and by davex in processing parameterized URLs.
//
//	==========================================================================

//	------------------------------------------------------------------------
//	Un-stringiz-ing support functions
//	(Stringize = dump a binary blob to a string.
//	Unstringize = make it a binary blob again.)
//
inline
void
AssertCharInHexRange (char ch)
{
	Assert ((ch >= '0' && ch <= '9') ||
			(ch >= 'A' && ch <= 'F') ||
			(ch >= 'a' && ch <= 'f'));
}

inline
BYTE
NibbleFromChar (char ch)
{
	//	Assumes data is already in range....
	//
	return static_cast<BYTE>((ch <= '9')
							 ? ch - '0'
							 : ((ch >= 'a')
								? ch - 'W'		// 'W' = 'a' - 0xa
								: ch - '7'));	// '7' = 'A' - 0xa
}

inline
BYTE
ByteFromTwoChars (char chLow, char chHigh)
{
	BYTE nibbleLow;
	BYTE nibbleHigh;

	nibbleLow = NibbleFromChar(chLow);
	nibbleHigh = NibbleFromChar(chHigh);

	return static_cast<BYTE>(nibbleLow | (nibbleHigh << 4));
}

//$REVIEW: The following two functions really does not belong to any common libraries
//$REVIEW: that are shared by davex, exdav and exoledb. (other options are _prop, _sql)
//$REVIEW: On the other hand, we definitely don't want add a new lib for this. so just
//$REVIEW: add it here. Feel free to move them to a better location if you find one
//
//	------------------------------------------------------------------------
//
//	ScDupPsid()
//
//	Copies a SID properly (using CopySid()) into a heap-allocated buffer
//	that is returned to the caller.  The caller must free the buffer when
//	it is done using it.
//
SCODE
ScDupPsid (PSID psidSrc,
		   DWORD dwcbSID,
		   PSID * ppsidDst)
{
	PSID psidDst;

	Assert (psidSrc);
	Assert (IsValidSid(psidSrc));
	Assert (GetLengthSid(psidSrc) == dwcbSID);

	psidDst = static_cast<PSID>(ExAlloc(dwcbSID));
	if (!psidDst)
	{
		DebugTrace ("ScDupPsid() - OOM allocating memory for dup'd SID\n");
		return E_OUTOFMEMORY;
	}

	//	"Right way" -- since MSDN says not to touch the SID directly.
	if (!CopySid (dwcbSID, psidDst, psidSrc))
	{
		DWORD dwLastError = GetLastError();

		DebugTrace ("ScDupPsid() - CopySid() failed %d\n", dwLastError);
		ExFree (psidDst);
		return HRESULT_FROM_WIN32(dwLastError);
	}

	*ppsidDst = psidDst;

	return S_OK;
}

//	------------------------------------------------------------------------
//
//	ScGetTokenInfo()
//
//	Extracts a user's security ID (SID) from a security token.  Returns the SID
//	in a heap-allocated buffer which the caller must free.
//
SCODE
ScGetTokenInfo (HANDLE hTokenUser,
				DWORD * pdwcbSIDUser,
				PSID * ppsidUser)
{
	CStackBuffer<TOKEN_USER> pTokenUser;
	DWORD dwcbTokenUser = pTokenUser.size(); //$OPT What is a good initial guess?

	Assert (pdwcbSIDUser);
	Assert (ppsidUser);

	//	Fetch the token info into local memory.  GetTokenInformation()
	//	returns the size of the buffer needed if the one passed in is
	//	not large enough so this loop should execute no more than twice.
	//
#ifdef DBG
	for ( UINT iPass = 0;
		  (Assert (iPass < 2), TRUE);
		  ++iPass )
#else
	for ( ;; )
#endif
	{
		if (NULL == pTokenUser.resize (dwcbTokenUser))
			return E_OUTOFMEMORY;

		if (GetTokenInformation (hTokenUser,
								 TokenUser,
								 pTokenUser.get(),
								 dwcbTokenUser,
								 &dwcbTokenUser))
		{
			break;
		}
		else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	//	Dup and return the SID from the token info.
	//
	*pdwcbSIDUser = GetLengthSid(pTokenUser->User.Sid);
	return ScDupPsid (pTokenUser->User.Sid,
					  *pdwcbSIDUser,
					  ppsidUser);
}

//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	It returns similarly to the system call WideCharToMultiByte:
//
//	If the function succeeds, and cbDest is nonzero, the return value is
//	the number of bytes written to the buffer pointed to by psz.
//
//	If the function succeeds, and cbDest is zero, the return value is
//	the required size, in bytes, for a buffer that can receive the translated
//	string.
//
//	If the function fails, the return value is zero. To get extended error
//	information, call GetLastError. GetLastError may return one of the
//	following error codes:
//
//	ERROR_INSUFFICIENT_BUFFER
//	ERROR_INVALID_FLAGS
//	ERROR_INVALID_PARAMETER
//
//	See the WideCharToMultiByte MSDN pages to find out more about
//	this function and its use.
//
UINT WideCharToUTF8(/* [in]  */ LPCWSTR	pwszSrc,
				    /* [in]  */ UINT	cchSrc,
				    /* [out] */ LPSTR	pszDest,
				    /* [in]  */ UINT	cbDest)
{
	//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
	//	more info.
	//
	//		Unicode value    1st byte    2nd byte    3rd byte
	//		000000000xxxxxxx 0xxxxxxx
	//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
	//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
	//

	//	If cbDest == 0 is passed in then we should only calculate the length
	//	needed, not use the "pszDest" parameter.
	//
	BOOL	fCalculateOnly = FALSE;

	//	(comment from nt\private\windows\winnls\mbcs.c, corrected for accuracy):
	//  Invalid Parameter Check:
	//     - length of WC string is 0
	//     - multibyte buffer size is negative
	//     - WC string is NULL
	//     - length of MB string is NOT zero AND
	//         (MB string is NULL OR src and dest pointers equal)
	//
	if ( (cchSrc == 0) ||
		 (pwszSrc == NULL) ||
		 ((cbDest != 0) &&
		  ((pszDest == NULL) ||
		   (reinterpret_cast<VOID *>(pszDest) ==
			reinterpret_cast<VOID *>(const_cast<LPWSTR>(pwszSrc))))) )
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return 0;
	}

#ifdef DBG
	//	Check our parameters.  We must be given a non-NULL pwszSrc.
	//
	Assert(pwszSrc);

	//	Make sure we have a valid string.
	//
	Assert(!IsBadStringPtrW(pwszSrc, (INVALID_INDEX == cchSrc) ? INFINITE : cchSrc));

	//	If the user says that the length of the multi-byte string is non-Zero,
	//	we must be given a non-NULL pszDest.  We'll also check it with IsBadWritePtr().
	//
	if (cbDest)
	{
		Assert(pszDest);
		Assert(!IsBadWritePtr(pszDest, cbDest));
	}
#endif

	//	If -1 is passed in as the length of the string, then we calculate the
	//	length of the string on the fly, and include the NULL terminator.
	//
	if (INVALID_INDEX == cchSrc)
		cchSrc = static_cast<UINT>(wcslen(pwszSrc) + 1);

	//	If 0 is passed in as cbDest, then we calculate the length of the
	//	buffer that would be needed to convert the string.  We ignore the
	//	pszDest parameter in this case.
	//
	if (0 == cbDest)
		fCalculateOnly = TRUE;

	UINT ich = 0;
	UINT iwch = 0;
	for (; iwch < cchSrc; iwch++)
	{
		WCHAR wch = pwszSrc[iwch];
		//
		//	Single-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		000000000xxxxxxx 0xxxxxxx
		//
		if (wch < 0x80)
		{
			if (!fCalculateOnly)
			{
				if (ich >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich] = static_cast<BYTE>(wch);
			}
			ich++;
		}
		//
		//	Double-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
		//
		else if (wch < 0x800)
		{
			if (!fCalculateOnly)
			{
				if ((ich + 1) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 6) | 0xC0);
				pszDest[ich + 1]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 2;
		}
		//
		//	Triple-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
		//
		else
		{
			if (!fCalculateOnly)
			{
				if ((ich + 2) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 12) | 0xE0);
				pszDest[ich + 1]	= static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
				pszDest[ich + 2]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 3;
		}
	}

	return ich;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\content.h ===
#ifndef	_CONTENT_H_
#define _CONTENT_H_

/*
 *	C O N T E N T . H
 *
 *	DAV Content-Type mappings
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

class IContentTypeMap : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	IContentTypeMap(const IContentTypeMap&);
	IContentTypeMap& operator=(IContentTypeMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IContentTypeMap()
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	};

public:
	//	ACCESSORS
	//
	virtual LPCWSTR PwszContentType( LPCWSTR pwszURI ) const = 0;
	virtual BOOL FIsInherited() const = 0;
};

BOOL FInitRegMimeMap();
VOID DeinitRegMimeMap();

IContentTypeMap *
NewContentTypeMap( LPWSTR pwszContentTypeMappings,
				   BOOL fMappingsInherited );

#endif	// _CONTENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\appmain.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	APPMAIN.CPP
//
//		DAV ISAPI DLL entrypoints, main routine, global instance management
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <xatom.h>		// XML atom cache

#include "instdata.h"
#include <langid.h>
#include "custerr.h"
#include "content.h"


//	THE one, global instance
//
CInst g_inst;



//	------------------------------------------------------------------------
//
//	CInst::PerProcessInit()
//
//		Zero it out.
//

void
CInst::PerProcessInit( HINSTANCE hinst )
{
	m_hinst = hinst;

#ifdef MINIMAL_ISAPI
	m_hfDummy = CreateFileW( L"c:\\temp\\test2.txt",		// filename
							 GENERIC_READ,					// dwAccess
							 FILE_SHARE_READ | FILE_SHARE_WRITE,
							 NULL,							// lpSecurityAttributes
							 OPEN_EXISTING,					// creation flags
							 FILE_ATTRIBUTE_NORMAL |
							 FILE_FLAG_SEQUENTIAL_SCAN |
							 FILE_FLAG_OVERLAPPED,			// attributes
							 NULL );						// tenplate
#endif // MINIMAL_ISAPI
}


//	------------------------------------------------------------------------
//
//	CInst::GetInstData()
//
//		Get the instance data for this ECB.
//		Handoff this call to our InstDataCache.
//

CInstData&
CInst::GetInstData( const IEcb& ecb )
{
	return CInstDataCache::GetInstData( ecb );
}



//	------------------------------------------------------------------------
//
//	CDAVExt::FInitializeDll()
//
//		Your standard DLL entrypoint.
//

BOOL
CDAVExt::FInitializeDll( HINSTANCE	hinst,
						 DWORD		dwReason )
{
	BOOL			fInitialized = TRUE;

	switch ( dwReason )
	{
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:

			Assert(FALSE);
			break;

		case DLL_PROCESS_ATTACH:
		{

			//
			//	Do per process initialization (and implicit initialization of
			//	the first thread).  The try/catch block just allows us to
			//	clean up neatly if anything at all goes wrong.
			//
			try
			{
				g_inst.PerProcessInit( hinst );
			}
			catch ( CDAVException& )
			{
				DebugTrace( "CDAVExt::FInitializeDll() - Caught exception in per-process initialization\n" );
				fInitialized = FALSE;
			}

			break;
		}

		case DLL_PROCESS_DETACH:
		{

			break;
		}

		default:
		{
			TrapSz( "FInitializeDll called for unknown reason\n" );
			fInitialized = FALSE;
			break;
		}
	}

	return fInitialized;
}

//	------------------------------------------------------------------------
//
//	CDAVExt::FVersion()
//
BOOL
CDAVExt::FVersion ( HSE_VERSION_INFO * pver )
{
	BOOL fSuccess = FALSE;

	//
	//	Init .INI file tagged debug traces
	//
	InitDavprsTraces();

	//	Init ECB logging -- DBG only
	//
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		InitECBLogging();
#endif

	//	Instatiate the virtual root cache
	//	We must do that before we initialise the metabase as this cache will listen
	//	to the metabase notifications that are registered when metabase is created.
	//	So if CChildVRCache is not there we may notify the object that does not
	//	exist and crash while doing that.
	//
	CChildVRCache::CreateInstance();

	//	Init the metabase
	//
	if ( !FMDInitialize() )
		goto ret;

	//	Instatiate the instance cache
	//
	CInstDataCache::CreateInstance();

	//	Create the language ID cache
	//
	CLangIDCache::CreateInstance();

	if ( !CLangIDCache::FInitialize() )
		goto ret;

	//	Instantiate the global registry-based mime map
	//
	if ( !FInitRegMimeMap() )
		goto ret;

	fSuccess = TRUE;

ret:
	return fSuccess;
}

#ifndef MINIMAL_ISAPI
#else  // defined(MINIMAL_ISAPI)
static VOID WINAPI
IOCompleteNoOp( EXTENSION_CONTROL_BLOCK *		pecb,
				PVOID                           pvContext,
				DWORD							cbIO,
				DWORD							dwLastError )
{
	//
	//	Done with the session.  This must be done from inside
	//	of the async callback because INETINFO crashes in
	//	INFOCOMM.DLL if you try to put it immediately after
	//	the SSF::HSE_REQ_TRANSMIT_FILE and the client sends
	//	a huge pile of requests before waiting for a response.
	//
	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_DONE_WITH_SESSION |
								 (pvContext ? HSE_STATUS_SUCCESS_AND_KEEP_CONN : 0),
								 NULL,
								 NULL,
								 NULL);
}

void
CheckKeepAlive( LPEXTENSION_CONTROL_BLOCK pecb, DWORD * pdwKeepAlive )
{
	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_IS_KEEP_CONN,
								 pdwKeepAlive,
								 NULL,
								 NULL);
}

void
SendHeaders( LPEXTENSION_CONTROL_BLOCK pecb )
{
	HSE_SEND_HEADER_EX_INFO	hseSendHeaderExInfo;

	static CHAR rgchStatus[] = "200 OK";

	hseSendHeaderExInfo.pszStatus = rgchStatus;
	hseSendHeaderExInfo.cchStatus = sizeof(rgchStatus) - 1;

	hseSendHeaderExInfo.pszHeader = NULL;
	hseSendHeaderExInfo.cchHeader = 0;

	hseSendHeaderExInfo.fKeepConn = TRUE;

	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_SEND_RESPONSE_HEADER_EX,
								 &hseSendHeaderExInfo,
								 NULL,
								 NULL);
}

void
SendResponse( LPEXTENSION_CONTROL_BLOCK pecb, DWORD dwKeepAlive )
{
	HSE_TF_INFO	hseTFInfo;

	ZeroMemory(&hseTFInfo, sizeof(HSE_TF_INFO));

	//
	//	If we're going to close the connection anyway, might
	//	as well send the headers along with everything else now.
	//
	if ( !dwKeepAlive )
	{
		static CHAR rgchHeaders[] =
			"HTTP/1.1 200 OK\r\n"
			"Content-Type: text/plain\r\n"
			"Connection: close\r\n"
			"\r\n";

		hseTFInfo.pHead        = rgchHeaders;
		hseTFInfo.HeadLength   = sizeof(rgchHeaders) - 1;
	}

	hseTFInfo.pfnHseIO     = IOCompleteNoOp;
	hseTFInfo.pContext     = (PVOID)(dwKeepAlive);
	hseTFInfo.dwFlags      = HSE_IO_ASYNC |
							 (dwKeepAlive ? 0 : HSE_IO_DISCONNECT_AFTER_SEND);
	hseTFInfo.BytesToWrite = 0;
	hseTFInfo.hFile        = g_inst.m_hfDummy;

	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_TRANSMIT_FILE,
								 &hseTFInfo,
								 NULL,
								 NULL);
}

DWORD
CDAVExt::DwMain( LPEXTENSION_CONTROL_BLOCK pecb,
				 BOOL fUseRawUrlMappings /* = FALSE */ )
{
	DWORD dwKeepAlive;

	//
	//	Determine whether to keep the connection open
	//
	CheckKeepAlive( pecb, &dwKeepAlive );

	//
	//	If keep alive is set, we *MUST* send the headers using
	//	HSE_REQ_SEND_RESPONSE_HEADERS_EX (which is always synchronous)
	//	because it's the only way that allows us to tell IIS to
	//	keep the connection open.
	//
	if ( dwKeepAlive )
		SendHeaders( pecb );

	//
	//	Transmit the dummy file
	//
	SendResponse( pecb, dwKeepAlive );

	return HSE_STATUS_PENDING;
}
#endif // defined(MINIMAL_ISAPI)


//	------------------------------------------------------------------------
//
//	CDAVExt::FTerminate()
//
//		Terminates (deinitializes) the common portions of this DAV ISAPI
//
//	Returns:
//		TRUE	if the DAV ISAPI application can be unloaded now
//		FALSE	otherwise
//
BOOL
CDAVExt::FTerminate()
{
	//	Tear down the global registry-based mimemap
	//
	DeinitRegMimeMap();

	//	Tear down the XML Atom cache
	//
	CXAtomCache::DeinitIfUsed();

	//	Delete the language ID cache
	//
	CLangIDCache::DestroyInstance();

	//	Tear down the instance data cache
	//
	CInstDataCache::DestroyInstance();

	//
	//	Deinit the metabase
	//
	MDDeinitialize();

	//	Tear down the child vroot cache
	//	We must do that after metabase is uninitialized and metabase notifications
	//	are shut down, as this cache listens to the metabase notifications.
	//	So if CChildVRCache is not there we may notify the object that does not
	//	exist and crash while doing that.
	//
	CChildVRCache::DestroyInstance();

	//	Deinit ECB logging
	//
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		DeinitECBLogging();
#endif

	//	Due to the fact that COM threads may still be siting in the pur code
	//	even they are done modifying our data, and there is no way we can
	//	push them out (synchronization would need to happen outside of our
	//	dll-s) - we will sleep for 5 seconds, hoping tha they will leave us alone.
	//
	Sleep(5000);

	//
	//	We can always shut down (for now...)
	//
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\body.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	BODY.CPP
//
//		Common implementation classes from which request body and
//		response body are derived.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>
#include <body.h>



//	========================================================================
//
//	CLASS IAcceptObserver
//

//	------------------------------------------------------------------------
//
//	IAcceptObserver::~IAcceptObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAcceptObserver::~IAcceptObserver() {}



//	========================================================================
//
//	CLASS IAsyncPersistObserver
//

//	------------------------------------------------------------------------
//
//	IAsyncPersistObserver::~IAsyncPersistObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAsyncPersistObserver::~IAsyncPersistObserver() {}



//	========================================================================
//
//	CLASS IAsyncIStreamObserver
//

//	------------------------------------------------------------------------
//
//	IAsyncIStreamObserver::~IAsyncIStreamObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAsyncIStreamObserver::~IAsyncIStreamObserver() {}


//	========================================================================
//
//	CLASS CIStreamAsyncStream
//
class CIStreamAsyncStream : public IAsyncStream
{
	//
	//	The OLE IStream
	//
	IStream& m_stm;

	//	NOT IMPLEMENTED
	//
	CIStreamAsyncStream( const CIStreamAsyncStream& );
	CIStreamAsyncStream& operator=( const CIStreamAsyncStream& );

public:
	//	CREATORS
	//
	CIStreamAsyncStream( IStream& stm ) : m_stm(stm) {}

	//	ACCESSORS
	//
	void AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );
};

//	------------------------------------------------------------------------
//
//	CIStreamAsyncStream::AsyncWrite()
//
void
CIStreamAsyncStream::AsyncWrite(
	const BYTE * pbBuf,
	UINT         cbToWrite,
	IAsyncWriteObserver& obsAsyncWrite )
{
	ULONG cbWritten;
	HRESULT hr;

	hr = m_stm.Write( pbBuf,
					  cbToWrite,
					  &cbWritten );

	obsAsyncWrite.WriteComplete( cbWritten, hr );
}


//	========================================================================
//
//	CLASS IBodyPartVisitor
//

//	------------------------------------------------------------------------
//
//	IBodyPartVisitor::~IBodyPartVisitor()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBodyPartVisitor::~IBodyPartVisitor() {}



//	========================================================================
//
//	CLASS IBodyPart
//

//	------------------------------------------------------------------------
//
//	IBodyPart::~IBodyPart()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBodyPart::~IBodyPart() {}


//	------------------------------------------------------------------------
//
//	CTextBodyPart::CTextBodyPart()
//
CTextBodyPart::CTextBodyPart( UINT cbText, LPCSTR lpszText )
{
	AddTextBytes( cbText, lpszText );
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::CTextBodyPart()
//
VOID
CTextBodyPart::AddTextBytes( UINT cbText, LPCSTR lpszText )
{
	m_bufText.Append( cbText, lpszText );
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::Rewind()
//
VOID
CTextBodyPart::Rewind()
{
	//
	//	Since a text body part is implemented as a randomly-
	//	accessible array there is nothing to "rewind".
	//
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::Accept()
//
VOID
CTextBodyPart::Accept( IBodyPartVisitor& v,
					   UINT64 ibPos64,
					   IAcceptObserver& obsAccept )
{
	Assert( ibPos64 < m_bufText.CbSize() );

	//
	//	Just visit all of the remaining text in the buffer.  The visitor
	//	may not process it all, but that will be reflected in the next
	//	call to this function.
	//		NOTE: To be compatable with IBodyPart the position is passed
	//	in as 64 bit value (this is necessary to support file body parts
	//	that are bigger than 4GB). However we do not want anyone to create
	//	text body parts that are bigger than 4GB. So assert that it is not
	//	the case here and truncate the passed in 64 bit value to 32 bits.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibPos64));

	v.VisitBytes(
		reinterpret_cast<const BYTE *>(m_bufText.PContents()) + static_cast<UINT>(ibPos64),
		m_bufText.CbSize() - static_cast<UINT>(ibPos64),
		obsAccept );
}


//	========================================================================
//
//	CLASS CFileBodyPart
//

//	------------------------------------------------------------------------
//
//	CFileBodyPart::CFileBodyPart()
//
CFileBodyPart::CFileBodyPart( const auto_ref_handle& hf,
							  UINT64 ibFile64,
							  UINT64 cbFile64 ) :
   m_hf(hf),
   m_ibFile64(ibFile64),
   m_cbFile64(cbFile64)
{

	//	We do not support byteranges on the files larger than 4GB. But due to the fact that byterange
	//	processing is all DWORD based in adition to the check for default file length value we do the
	//	check for default byterange value. If _HSE_TF_INFO will ever be fixed to take file size values
	//	larger than DWORD then we would be able to move our byterange processing to UINT64 base and
	//	the second check below would go away.
	//
	if ((0xFFFFFFFFFFFFFFFF == cbFile64) ||	//	If we got the default file length value indicating that we want data up to the end of the file
		(0x00000000FFFFFFFF == cbFile64))	//	If we got the default byterange value indicating that we want the data up to the end of the file
	{
		LARGE_INTEGER cbFileSize;

		if (!GetFileSizeEx(hf.get(), &cbFileSize))
		{
			DebugTrace( "CFileBodyPart::CFileBodyPart() - GetFileSizeEx() failed with last error (0x%08lX)\n", GetLastError() );
			throw CLastErrorException();
		}

		m_cbFile64 = cbFileSize.QuadPart;
	}
}

//	------------------------------------------------------------------------
//
//	CFileBodyPart::Rewind()
//
VOID
CFileBodyPart::Rewind()
{
	//
	//	Since the files in file body parts are opened overlapped,
	//	they do not have internal file pointers, hence they never
	//	need to be rewound.
	//
}

//	------------------------------------------------------------------------
//
//	CFileBodyPart::Accept()
//
VOID
CFileBodyPart::Accept( IBodyPartVisitor& v,
					   UINT64 ibPos64,
					   IAcceptObserver& obsAccept )
{
	if (ibPos64 < m_cbFile64)
	{
		//
		//	Just visit the remainder of the file.  The visitor
		//	may not process it all, but that will be reflected in the next
		//	call to this function.
		//
		v.VisitFile( m_hf,
					 m_ibFile64 + ibPos64,
					 m_cbFile64 - ibPos64,
					 obsAccept );
	}
	else
	{
		//
		//	We should always have something to accept unless we have a
		//	0-length file body part.  In that case, just tell the observer
		//	how much was visited: nothing.
		//
		obsAccept.AcceptComplete(0);
	}
}


//	========================================================================
//
//	CLASS CAsyncReadVisitor
//
//	A body part visitor that asynchronously reads body parts into
//	a fixed size, caller-supplied, buffer.
//
class CAsyncReadVisitor :
	public IBodyPartVisitor,
	private IAsyncReadObserver
{
	//
	//	Error information
	//
	HRESULT	m_hr;

	//
	//	User's buffer and its size
	//
	LPBYTE	m_pbBufUser;
	UINT	m_cbBufUser;

	//
	//	Accept observer passed to VisitStream().  This observer must
	//	be stashed in a member variable because reading from the stream
	//	is asynchronous and we need to be able to notify the observer
	//	when the read completes.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT         cbToRead,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64   ibOffset64,
					UINT64   cbToRead64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToRead,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	//
	//	IAsyncReadObserver for async streams visited via VisitStream()
	//
	VOID ReadComplete( UINT cbRead, HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CAsyncReadVisitor( const CAsyncReadVisitor& );
	CAsyncReadVisitor& operator=( const CAsyncReadVisitor& );

public:
	//	CREATORS
	//
	CAsyncReadVisitor() :
			//	Always start with clean member variables
			m_hr(S_OK),
			m_pbBufUser(NULL),
			m_cbBufUser(0),
			m_pobsAccept(NULL)
	{
	}

	//	ACCESSORS
	//
	HRESULT Hresult() const { return m_hr; }

	//	MANIPULATORS
	//
	VOID
	Configure( LPBYTE pbBufUser,
			   UINT   cbBufUser )
	{
		m_pbBufUser = pbBufUser;
		m_cbBufUser = cbBufUser;
		//	Also reset our HRESULT
		m_hr = S_OK;
	}
};

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitBytes()
//
VOID
CAsyncReadVisitor::VisitBytes( const BYTE * pbData,
							   UINT         cbToRead,
							   IAcceptObserver& obsAccept )
{
	cbToRead = min(cbToRead, m_cbBufUser);

	memcpy(m_pbBufUser, pbData, cbToRead);

	obsAccept.AcceptComplete(cbToRead);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitFile()
//
//	Not implemented because 1) request bodies cannot have file
//	body parts and 2) CAsyncReadVisitor is currently only used
//	with request bodies.  Should we ever need this for response
//	bodies we'll need to write the code at that point.
//
//	The old implementation used ReadFileEx() to read from the file
//	asynchronously.  In a nutshell, we couldn't use ReadFileEx()
//	because it relied on APC for calling back its completion routine.
//	APC in turn required the calling thread to enter an alertable
//	wait state.  Typically, we would only call VisitFile() from an
//	I/O completion port thread pool, and those threads are never
//	in an alertable wait state, thus the completion routine for
//	ReadFileEx() would never be called.
//
VOID
CAsyncReadVisitor::VisitFile( const auto_ref_handle&,
							  UINT64,
							  UINT64,
							  IAcceptObserver& obsAccept )
{
	TrapSz( "CAsyncReadVisitor::VisitFile() is not implemented!!" );

	//
	//	If, for whatever random reason, someone actually does call
	//	this function, at least do something predictable: fail gracefully.
	//
	m_hr = E_FAIL;
	obsAccept.AcceptComplete( 0 );
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitStream()
//
VOID
CAsyncReadVisitor::VisitStream( IAsyncStream& stmSrc,
								UINT cbToRead,
								IAcceptObserver& obsAccept )
{
	//
	//	Read into our user's buffer only as much of the stream as is
	//	immediately available -- i.e. the amount of data that can be
	//	read without pending the read operation.  Note that on input
	//	cbToRead is the amount of data remaining to be read from the
	//	stream -- it is not all necessarily immediately available.
	//
	//	X5 162502: This used to say min(stmSrc.CbReady(),...) here
	//	instead of min(cbToRead,...).  This was not a problem on IIS5
	//	because there was always at least some data immediately available
	//	when our ISAPI was called.  However, on the Local Store, it may
	//	be such that when we call the ISAPI, there is no data immediately
	//	available.  This turned out to be a problem because we would get
	//	here and cbToRead would be assigned to 0, which would end up
	//	making it look like we'd finished (end of stream), which would
	//	cause XML parse errors (0-byte XML bodies don't parse well!).
	//
	cbToRead = min(cbToRead, m_cbBufUser);

	//
	//	Save off the observer and start reading.  Even though this is
	//	an AsyncRead() call, we have limited the request to what can
	//	be read immediately, so our ReadComplete() should be called
	//	before the AsyncRead() call returns.  This is important because
	//	we are reading directly into the user's buffer.  The buffer
	//	is valid for the duration of this visit.
	//
	m_pobsAccept = &obsAccept;
	stmSrc.AsyncRead(m_pbBufUser, cbToRead, *this);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::ReadComplete()
//
//	Called when the AsyncRead() of the stream by VisitStream() completes.
//
VOID
CAsyncReadVisitor::ReadComplete( UINT cbRead, HRESULT hr )
{
	//
	//	Latch in any error returned.
	//
	m_hr = hr;

	//
	//	Notify our observer of the number of bytes read.
	//
	Assert(m_pobsAccept);
	m_pobsAccept->AcceptComplete(cbRead);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitComplete()
//
VOID
CAsyncReadVisitor::VisitComplete()
{
	m_hr = S_FALSE;
}

//	========================================================================
//
//	CLASS CAsyncCopyToVisitor
//
//	A body part visitor that asynchronously copies body parts into
//	a destination async stream.
//
class CAsyncCopyToVisitor :
	public IBodyPartVisitor,
	private IAsyncWriteObserver,
	private IAsyncCopyToObserver
{
	//
	//	CAsyncCopyToVisitor forwards its refcounting calls to this
	//	parent object (settable via SetRCParent()).  We are a non-refcounted
	//	member of another object (e.g. CAsyncPersistor below) -- so our
	//	lifetime must be determined by the lifetime of our parent object.
	//
	IRefCounted * m_prcParent;

	//
	//	Error information
	//
	HRESULT m_hr;

	//
	//	The destination stream
	//
	IAsyncStream * m_pstmDst;

	//
	//	The count of bytes to copy and the count copied
	//
	ULONG m_cbToCopy;
	ULONG m_cbCopied;

	//
	//	The Accept() observer to notify when we're done
	//	visiting upon completion of an AsyncWrite()
	//	or AsyncCopyTo() on the destination stream.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT cbToCopy,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64 ibOffset64,
					UINT64 cbToCopy64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToCopy,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	//
	//	IAsyncWriteObserver
	//
	VOID WriteComplete( UINT cbWritten, HRESULT hr );

	//
	//	IAsyncCopyToObserver
	//
	VOID CopyToComplete( UINT cbCopied, HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CAsyncCopyToVisitor( const CAsyncCopyToVisitor& );
	CAsyncCopyToVisitor& operator=( const CAsyncCopyToVisitor& );

public:
	//	CREATORS
	//
	CAsyncCopyToVisitor() :
			m_prcParent(NULL),
			m_hr(S_OK),
			m_pstmDst(NULL),
			m_cbToCopy(0),
			m_cbCopied(0)
	{
	}

	//	ACCESSORS
	//
	HRESULT Hresult() const { return m_hr; }
	UINT CbCopied() const { return m_cbCopied; }

	//	MANIPULATORS
	//
	VOID
	Configure( IAsyncStream& stmDst,
			   ULONG cbToCopy )
	{
		m_pstmDst  = &stmDst;
		m_cbToCopy = cbToCopy;
		m_cbCopied = 0;
		m_hr       = S_OK;
	}

	VOID
	SetRCParent(IRefCounted * prcParent)
	{
		Assert(prcParent);

		m_prcParent = prcParent;
	}

	//	Refcounting for IAsyncWriteObserver.  Since this is not a refcounted
	//	object we forward the refcouting to the object with which we
	//	were configured.
	//
	void AddRef()
	{
		Assert( m_prcParent );

		m_prcParent->AddRef();
	}

	void Release()
	{
		Assert( m_prcParent );

		m_prcParent->Release();
	}
};

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::WriteComplete()
//
void
CAsyncCopyToVisitor::WriteComplete( UINT cbWritten, HRESULT hr )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::WriteComplete() called.  hr = 0x%08lX, cbWritten = %u\n", GetCurrentThreadId(), this, hr, cbWritten );

	m_cbCopied += cbWritten;
	m_hr = hr;

	m_pobsAccept->AcceptComplete( cbWritten );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitBytes()
//
void
CAsyncCopyToVisitor::VisitBytes( const BYTE * pbData,
								 UINT cbToCopy,
								 IAcceptObserver& obsAccept )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::VisitBytes() called.  cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Remember the accept observer so that we can notify it when
	//	the AsyncWrite() below completes.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Start writing
	//
	cbToCopy = min( cbToCopy, m_cbToCopy - m_cbCopied );
	m_pstmDst->AsyncWrite( pbData, cbToCopy, *this );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitFile()
//
//	Not implemented because 1) request bodies cannot have file
//	body parts and 2) CAsyncCopyToVisitor is currently only used
//	with request bodies.  Should we ever need this for response
//	bodies we'll need to write the code at that point.
//
//	The old implementation used ReadFileEx() to read from the file
//	asynchronously.  In a nutshell, we couldn't use ReadFileEx()
//	because it relied on APC for calling back its completion routine.
//	APC in turn required the calling thread to enter an alertable
//	wait state.  Typically, we would only call VisitFile() from an
//	I/O completion port thread pool, and those threads are never
//	in an alertable wait state, thus the completion routine for
//	ReadFileEx() would never be called.
//
void
CAsyncCopyToVisitor::VisitFile( const auto_ref_handle&,
								UINT64,
								UINT64,
								IAcceptObserver& obsAccept )
{
	TrapSz( "CAsyncCopyToVisitor::VisitFile() is not implemented!!" );

	//
	//	If, for whatever random reason, someone actually does call
	//	this function, at least do something predictable: fail gracefully.
	//
	m_hr = E_FAIL;
	obsAccept.AcceptComplete( 0 );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitStream()
//
void
CAsyncCopyToVisitor::VisitStream( IAsyncStream& stmSrc,
								  UINT cbToCopy,
								  IAcceptObserver& obsAccept )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::VisitStream() called.  cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Remember the accept observer so that we can notify it when
	//	the AsyncCopyTo() below completes.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Start copying
	//
	cbToCopy = min( cbToCopy, m_cbToCopy - m_cbCopied );
	stmSrc.AsyncCopyTo( *m_pstmDst, cbToCopy, *this );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::CopyToComplete()
//
void
CAsyncCopyToVisitor::CopyToComplete( UINT cbCopied, HRESULT hr )
{
	m_cbCopied += cbCopied;
	m_hr = hr;

	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::CopyToComplete() hr = 0x%08lX, cbCopied = %u, m_cbCopied = %u\n", GetCurrentThreadId(), this, hr, cbCopied, m_cbCopied );

	m_pobsAccept->AcceptComplete( cbCopied );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitComplete()
//
VOID
CAsyncCopyToVisitor::VisitComplete()
{
	m_hr = S_FALSE;
}


//	========================================================================
//
//	CLASS CBodyAsIStream
//
//	Provides once-only access to the entire body as an OLE COM IStream using
//	either IStream::Read() and IStream::CopyTo().
//
class CBodyAsIStream :
	public CStreamNonImpl,
	private IAcceptObserver
{
	//
	//	Iterator used to traverse the body
	//
	IBody::iterator * m_pitBody;

	//
	//	The three states of the read operation started by the most recent
	//	call to CBodyAsIStream::Read():
	//
	//		READ_ACTIVE
	//			The read is active.  It may or may not complete
	//			synchronously.  This is the initial state.
	//
	//		READ_PENDING
	//			The read is pending.  The read did not complete before
	//			we had to return to the caller.  CBodyAsIStream::Read()
	//			returns E_PENDING and the stream observer (below) is notified
	//			when the read completes.
	//
	//		READ_COMPLETE
	//			The read completed before we had to return to the
	//			caller.  CBodyAsIStream::Read() does not return E_PENDING
	//			and the stream observer (below) is not notified.
	//
	//	Note: m_lStatus is meaningless (and hence uninitialized/invalid) until
	//	CBodyAsIStream::Read() is called.
	//
	enum
	{
		READ_ACTIVE,
		READ_PENDING,
		READ_COMPLETE,

		READ_INVALID_STATUS = -1
	};

	LONG m_lStatus;

	//
	//	Status of last completed operation.
	//
	HRESULT m_hr;

	//
	//	Async visitor used for Read().
	//
	CAsyncReadVisitor m_arv;

	//
	//	Count of bytes read in the visit started by the most recent
	//	call to CBodyAsIStream::Read().
	//
	//	Note: m_cbRead is meaningless (and hence uninitialized) until
	//	CBodyAsIStream::Read() is called.
	//
	UINT m_cbRead;

	//
	//	Reference to the async I/O completion observer.  We notify this
	//	observer from CBodyAsIStream::AcceptComplete() when the async
	//	Accept() call we make in CBodyAsIStream::Read() completes for
	//	a read that we have pended.
	//
	IAsyncIStreamObserver& m_obsStream;

	//	IAcceptObserver callback used when accepting async read visitor
	//	to asynchronoulsy refill the buffer.
	//
	VOID AcceptComplete( UINT64 cbRead64 );

	//	NOT IMPLEMENTED
	//
	CBodyAsIStream( const CBodyAsIStream& );
	CBodyAsIStream& operator=( const CBodyAsIStream& );

public:
	CBodyAsIStream( IBody& body,
					IAsyncIStreamObserver& obs ) :
		m_pitBody(body.GetIter()),
		m_lStatus(READ_INVALID_STATUS),
		m_hr(S_OK),
		m_cbRead(0),
		m_obsStream(obs)
	{
	}

	//	COM IStream ACCESSORS/MANIPULATORS
	//
	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *);

	//$WORKAROUND: MSXML is calling our Stat() method. (X5#89140)
	//	Our parent (CStreamNonImpl) has a TrapSz() there, so
	//	avoid it by implementing our own Stat() call here,
	//	that just returns E_NOTIMPL.
	//	MSXML doesn't care if this is not implemented, just so long
	//	as it doesn't crash/assert/dbgbreak.  If they get results
	//	back here, they do other security checking that we don't
	//	need or want!
	//
	virtual HRESULT STDMETHODCALLTYPE Stat(
		/* [out] */ STATSTG __RPC_FAR *,
		/* [in] */ DWORD)
	{
		return E_NOTIMPL;
	}
	//$WORKAROUND: end
};

//	------------------------------------------------------------------------
//
//	CBodyAsIStream::Read()
//
HRESULT STDMETHODCALLTYPE
CBodyAsIStream::Read( LPVOID  pv,
					  ULONG   cbToRead,
					  ULONG * pcbRead )
{
	HRESULT hr = S_OK;

	Assert( cbToRead > 0 );
	Assert( !IsBadWritePtr(pv, cbToRead) );
	Assert( !pcbRead || !IsBadWritePtr(pcbRead, sizeof(ULONG)) );

	BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::Read() called to read %lu bytes from stream\n", GetCurrentThreadId(), this, cbToRead );

	//
	//	As this is an STDMETHODCALLTYPE function, we need to wrap the whole thing
	//	in a try/catch block to keep exceptions due to memory allocation failures
	//	from propagating out.
	//
	//	Note: We don't expect anything in this try/catch block to throw a "hard"
	//	Win32 exception so we don't need a CWin32ExceptionHandler in the block.
	//
	try
	{
		//
		//	Check for errors from the previous (pended) read.
		//
		hr = m_arv.Hresult();
		if ( FAILED(hr) )
		{
			DebugTrace( "CBodyAsIStream::Read() - Error from previous async read 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	Set up our visitor to read directly into the caller's buffer.
		//
		m_arv.Configure(static_cast<LPBYTE>(pv), cbToRead);

		//
		//	Clear out the count of bytes read from the previous run
		//
		m_cbRead = 0;

		//
		//	Set our status to actively reading.  When we call Accept(), this status will
		//	change in one of two possible ways:  If we finish accepting before our
		//	Accept() call returns then the status will be set to READ_COMPLETE and
		//	we will complete this Read() call synchronously.  If not then it will still
		//	be set to READ_ACTIVE at the point where we test and set it below to
		//	READ_PENDING.
		//
		m_lStatus = READ_ACTIVE;

		//
		//	Visit the body.
		//
		m_pitBody->Accept( m_arv, *this );

		//
		//	Check the visit status.  If the visit has not completed at this
		//	point then attempt to pend the read operation and return E_PENDING
		//	to our caller.  If we successfully pend the operation then our
		//	AcceptComplete() routine will notify our stream observer when the
		//	read completes.
		//
		if ( READ_ACTIVE == m_lStatus &&
			 READ_ACTIVE == InterlockedExchange( &m_lStatus, READ_PENDING ) )
		{
			BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::Read() Returning E_PENDING\n", GetCurrentThreadId(), this );
			hr = E_PENDING;
			goto ret;
		}

		//
		//	Check for errors from the current read.
		//
		hr = m_arv.Hresult();
		if ( FAILED(hr) )
		{
			DebugTrace( "CBodyAsIStream::Read() - Error from current read 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	If we're at End Of Stream then return what we got.
		//
		if ( S_FALSE == hr )
		{
			//
			//	Don't return S_FALSE when we're also returning
			//	data.  The IStream spec is unclear on whether
			//	that is allowed.
			//
			if ( m_cbRead > 0 )
				hr = S_OK;
		}

		//
		//	Return the number of bytes read if the caller asked for
		//	that information.
		//
		if ( pcbRead )
			*pcbRead = m_cbRead;
	}
	catch ( CDAVException& e )
	{
		hr = e.Hresult();
		Assert( FAILED(hr) );
	}

ret:
	return hr;
}

//	------------------------------------------------------------------------
//
//	CBodyAsIStream::AcceptComplete()
//
//	Called when the Accept() call started in Read() to asynchronously
//	refill the buffer completes.
//
VOID
CBodyAsIStream::AcceptComplete( UINT64 cbRead64 )
{
	BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::AcceptComplete() cbRead64 = %lu\n", GetCurrentThreadId(), this, cbRead64 );

	//
	//	Update the count of bytes that our Accept() call successfully
	//	read into the user's buffer. We are accepting in piecies so the
	//	accepted amount should be really much less than 4GB.
	//
	Assert(0 == (0xFFFFFFFF00000000 & cbRead64));
	m_cbRead = static_cast<UINT>(cbRead64);

	//
	//	Set status to READ_COMPLETE.  If the read operation pended --
	//	i.e. the previous state was READ_PENDING, not READ_ACTIVE --
	//	then we must wake up the stream observer and tell it that
	//	we are done.
	//
	if ( READ_PENDING == InterlockedExchange( &m_lStatus, READ_COMPLETE ) )
		m_obsStream.AsyncIOComplete();
}


//	========================================================================
//
//	CLASS CAsyncPersistor
//
//	Implements an async driven object to persist a body to an IAsyncStream.
//
class CAsyncPersistor :
	public CMTRefCounted,
	public IRefCounted,
	private IAcceptObserver
{
	//
	//	Body iterator
	//
	IBody::iterator * m_pitBody;

	//
	//	Async driving mechanism
	//
	CAsyncDriver<CAsyncPersistor> m_driver;
	friend class CAsyncDriver<CAsyncPersistor>;

	//
	//	Caller-supplied observer to notify when we're done persisting.
	//
	auto_ref_ptr<IAsyncPersistObserver> m_pobsPersist;

	//
	//	CopyTo visitor used to persist the body
	//
	CAsyncCopyToVisitor m_actv;

	//
	//	CAsyncDriver callback
	//
	VOID Run();

	//
	//	IAcceptObserver callback used when accepting async copyto visitor
	//	to asynchronously persist the body to the destination stream.
	//
	VOID AcceptComplete( UINT64 cbCopied64 );

	//	NOT IMPLEMENTED
	//
	CAsyncPersistor( const CAsyncPersistor& );
	CAsyncPersistor& operator=( const CAsyncPersistor& );

public:
	//	CREATORS
	//
	CAsyncPersistor( IBody& body,
					 IAsyncStream& stm,
					 IAsyncPersistObserver& obs ) :
		m_pitBody(body.GetIter()),
		m_pobsPersist(&obs)
	{
		//
		//	Set the CopyTo() parameters here, once.  If we ever need
		//	to copy request bodies larger than ULONG_MAX bytes, we'll
		//	need to move this call down into Run().
		//
		m_actv.Configure(stm, ULONG_MAX);
	}

	//	MANIUPLATORS
	//
	VOID Start()
	{
		m_driver.Start(*this);
	}

	//	Refcounting -- forward all refcounting requests to our refcounting
	//	implementation base class: CMTRefCounted.
	//
	void AddRef() { CMTRefCounted::AddRef(); }
	void Release() { CMTRefCounted::Release(); }
};

//	------------------------------------------------------------------------
//
//	CAsyncPersistor::Run()
//
VOID
CAsyncPersistor::Run()
{
	PersistTrace( "DAV: TID %3d: 0x%08lX: CAsyncPersistor::Run() called\n", GetCurrentThreadId(), this );

	//
	//	AddRef() for Accept().  Use auto_ref_ptr for exception-safety.
	//
	auto_ref_ptr<CAsyncPersistor> pRef(this);

	m_actv.SetRCParent(this);
	m_pitBody->Accept(m_actv, *this);

	pRef.relinquish();
}

//	------------------------------------------------------------------------
//
//	CAsyncPersistor::AcceptComplete()
//
VOID
CAsyncPersistor::AcceptComplete( UINT64 cbCopied64 )
{
	//
	//	Take ownership of the reference added in Run().
	//
	auto_ref_ptr<CAsyncPersistor> pRef;
	pRef.take_ownership(this);

	//
	//	We're done when the status of the CopyTo visitor is
	//	S_FALSE (success) or an error.
	//
	HRESULT hr = m_actv.Hresult();

	PersistTrace( "DAV: TID %3d: 0x%08lX: CAsyncPersistor::AcceptComplete() hr = 0x%08lX\n, cbCopied64 = %ud\n", GetCurrentThreadId(), this, hr, cbCopied64 );

	if ( FAILED(hr) || S_FALSE == hr )
	{
		Assert( m_pobsPersist.get() );
		m_pobsPersist->PersistComplete(hr);
	}
	else
	{
		Start();
	}
}


//	========================================================================
//
//	CLASS IBody
//

//	------------------------------------------------------------------------
//
//	IBody::~IBody()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBody::~IBody() {}

//	========================================================================
//
//	CLASS IBody::iterator
//

//	------------------------------------------------------------------------
//
//	IBody::iterator::~iterator()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBody::iterator::~iterator() {}


//	========================================================================
//
//	CLASS CList
//
//	The body part list implementation uses the STL list template.
//	Body parts are stored in auto_ptrs so that they are automatically
//	destroyed as they are removed from the list or when the list itself is
//	destroyed.
//
//	This class does not by itself need to provide any sort of thread-safety.
//
typedef std::list<
			auto_ptr_obsolete<IBodyPart>,
			heap_allocator< auto_ptr_obsolete<IBodyPart> >
		> CList;

//	========================================================================
//
//	CLASS CBodyPartList
//
//	Encapsulates access to the list of body parts.  The reason for this
//	seemingly extra level of encapsulation is that it enables us to
//	change the list implementation easily without touching code which
//	uses the list.
//
//	!!! IMPORTANT !!!
//	When accessing/modifying the raw STL list through CBodyPartList,
//	we must acquire our critical section.  Threads may be iterating
//	over the list via our iterator, CBodyPartListIter, while we are modifying
//	the list and the STL list and its iterator are not thread-safe.
//	In other words, CBodyPartListIter and CBodyPartList share the same critsec.
//
class CBodyPartList
{
	//	The list
	//
	CList m_list;

	//	Critical section to serialize access to the above list
	//
	CCriticalSection m_csList;

	//	NOT IMPLEMENTED
	//
	CBodyPartList( const CBodyPartList& );
	CBodyPartList& operator=( const CBodyPartList& );

	friend class CBodyPartListIter;

public:
	//	CREATORS
	//
	CBodyPartList() {}

	//	ACCESSORS
	//
	const BOOL FIsEmpty() const
	{
		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		//
		//	Return whether there are any body parts in the list
		//
		return m_list.empty();
	}

	//	MANIPULATORS
	//
	VOID Clear()
	{
		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		//
		//	Remove all body parts from the list (at which point they
		//	should be automatically destroyed).
		//
		m_list.clear();
	}

	VOID PushPart( IBodyPart * pBodyPart )
	{
		CSynchronizedBlock sb(m_csList);

		//
		//	Our iterator (CBodyPartList iter, below) uses the STL
		//	list reverse_iterator to traverse the list from back to
		//	front, so we append body parts to the *front* of the list.
		//
		m_list.push_front( auto_ptr_obsolete<IBodyPart>(pBodyPart) );
	}
};

//	========================================================================
//
//	CLASS CBodyPartListIter
//
//	Implements an iterator for CBodyPartList
//
//	This implementation uses the reverse STL list iterator corresponding
//	to the usage of the STL list type in CBodyPartList.  STL iterators
//	have some syntactic sugar that we need to note here:
//
//		* (deref) of an iterator gives the thing pointed to
//		++ (increment) of an iterator goes to the "next" item
//		-- (decrement) of an iterator goes to the "previous" item
//
//	We use the reverse iterator because of the behavior we need at
//	the end of the list w.r.t. adding new items.  When an iterator
//	reaches the end of the list and items are later added there,
//	we want the iterator to refer to the first of the new items rather
//	than the new end-of-list.  The forward STL iterator has the
//	latter behavior.
//
//	!!! IMPORTANT !!!
//	When accessing/modifying the raw STL list through our iterator
//	we must acquire CBodyPartList's critical section.  Threads may
//	be modifying the list while we are iterating through it and
//	the STL list and its iterator are not thread-safe.  In other words,
//	CBodyPartListIter and CBodyPartList share the same critsec.
//
class CBodyPartListIter
{
	//	Pointer to the list to iterate on
	//
	CBodyPartList * m_pBodyPartList;

	//	The raw STL list iterator
	//
	CList::reverse_iterator m_itRaw;

	//	CBodyPartList ACCESSORS
	//
	CCriticalSection& CritsecList() const
	{
		Assert( m_pBodyPartList );
		return m_pBodyPartList->m_csList;
	}

	CList& RawList() const
	{
		Assert( m_pBodyPartList );
		return m_pBodyPartList->m_list;
	}

	//	NOT IMPLEMENTED
	//
	CBodyPartListIter( const CBodyPartListIter& );
	CBodyPartListIter& operator=( const CBodyPartListIter& );

public:
	//	CREATORS
	//
	CBodyPartListIter() :
		m_pBodyPartList(NULL)
	{
	}

	VOID Start( CBodyPartList& m_bodyPartList )
	{
		m_pBodyPartList = &m_bodyPartList;

		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		m_itRaw = RawList().rbegin();
	}

	//	ACCESSORS
	//
	BOOL FDone()
	{
		CSynchronizedBlock sb(CritsecList());

		return m_itRaw == RawList().rend();
	}

	IBodyPart * PItem()
	{
		CSynchronizedBlock sb(CritsecList());

		return *m_itRaw;
	}

	//	MANIPULATORS
	//

	//	------------------------------------------------------------------------
	//
	//	CBody::Prune()
	//
	//	Bumps the iterator to the next item in the list
	//
	VOID Next()
	{
		CSynchronizedBlock sb(CritsecList());

		//
		//	We had better not already be at the end...
		//
		Assert( m_itRaw != RawList().rend() );

		++m_itRaw;
	}

	//	------------------------------------------------------------------------
	//
	//	CBody::Prune()
	//
	//	Prunes the list at this iterator's current position.  Removes items
	//	from the current position to the end of the list.  Does not remove
	//	the current item.
	//
	VOID Prune()
	{
		CSynchronizedBlock sb(CritsecList());

		//
		//	Unfortunately the STL only allows us to erase between two
		//	forward iterators.  And there is no way to get a forward
		//	iterator directly from a reverse iterator.  So we must
		//	start a forward iterator at the end of the list and walk
		//	it backward the same distance that our reverse iterator
		//	is from its "beginning" of the list and then erase the
		//	items between the forward iterator and the end of the list.
		//
		CList::iterator itErase = RawList().end();

		for ( CList::reverse_iterator it = RawList().rbegin();
			  it != m_itRaw;
			  ++it )
		{
			--itErase;
		}

		if ( itErase != RawList().end() )
			RawList().erase( ++itErase, RawList().end() );
	}
};


//	========================================================================
//
//	CLASS CBody
//
class CBody : public IBody
{
	//	========================================================================
	//
	//	CLASS iterator
	//
	class iterator :
		public IBody::iterator,
		private IAcceptObserver
	{
		//
		//	Iterator to walk the body part list.
		//
		CBodyPartListIter m_itPart;

		//
		//	Pointer to the current body part referred to by the
		//	above iterator.
		//
		IBodyPart * m_pBodyPart;

		//
		//	Current position in the above part.
		//
		UINT64 m_ibPart64;

		//
		//	Observer to call when Accept() completes -- set on each
		//	Accept() call.
		//
		IAcceptObserver *  m_pobsAccept;

		//
		//	IAcceptObserver
		//
		VOID AcceptComplete( UINT64 cbAccepted64 );

		//	NOT IMPLEMENTED
		//
		iterator( const iterator& );
		iterator& operator=( const iterator& );

	public:
		iterator() {}

		VOID Start( CBodyPartList& bodyPartList )
		{
			m_itPart.Start(bodyPartList);
			m_pBodyPart = NULL;
		}

		VOID Accept( IBodyPartVisitor& v,
					 IAcceptObserver& obsAccept );

		VOID Prune();
	};

	//	Body part list and current position in that list
	//
	CBodyPartList m_bodyPartList;

	//	Our iterator
	//
	iterator m_it;

	//
	//	Inline helper to add a body part
	//
	void _AddBodyPart( IBodyPart * pBodyPart )
	{
		m_bodyPartList.PushPart(pBodyPart);
	}

	//	NOT IMPLEMENTED
	//
	CBody( const CBody& );
	CBody& operator=( const CBody& );

public:
	CBody() {}

	//	ACCESSORS
	//
	BOOL FIsEmpty() const;
	BOOL FIsAtEnd() const;
	UINT64 CbSize64() const;

	//	MANIPULATORS
	//
	void AddText( LPCSTR lpszText,
				  UINT   cbText );

	void AddFile( const auto_ref_handle& hf,
				  UINT64 ibFile,
				  UINT64 cbFile );

	void AddStream( IStream& stm );

	void AddStream( IStream& stm,
					UINT     ibOffset,
				    UINT     cbSize );

	void AddBodyPart( IBodyPart * pBodyPart );

	void AsyncPersist( IAsyncStream& stm,
					   IAsyncPersistObserver& obs );

	IStream * GetIStream( IAsyncIStreamObserver& obs )
	{
		return new CBodyAsIStream(*this, obs);
	}

	IBody::iterator * GetIter();

	VOID Clear();
};

//	------------------------------------------------------------------------
//
//	CBody::GetIter()
//
IBody::iterator *
CBody::GetIter()
{
	m_it.Start(m_bodyPartList);
	return &m_it;
}

//	------------------------------------------------------------------------
//
//	CBody::FIsEmpty()
//
BOOL
CBody::FIsEmpty() const
{
	return m_bodyPartList.FIsEmpty();
}

//	------------------------------------------------------------------------
//
//	CBody::CbSize64()
//
UINT64
CBody::CbSize64() const
{
	UINT64 cbSize64 = 0;

	//
	//	Sum the sizes of all the body parts
	//
	CBodyPartListIter it;

	for ( it.Start(const_cast<CBodyPartList&>(m_bodyPartList));
		  !it.FDone();
		  it.Next() )
	{
		cbSize64 += it.PItem()->CbSize64();
	}

	return cbSize64;
}

//	------------------------------------------------------------------------
//
//	CBody::AddText()
//
//		Adds static text to the body by creating a text body part with
//		its own copy of the text and adding that body part to the
//		body part list.
//
//		!!!
//		For best performance, implement your own text body part on top
//		of your text data source rather than copying it via this function
//		as doing so avoids making an extra copy of the data from the
//		data source in memory.
//
void
CBody::AddText( LPCSTR lpszText, UINT cbText )
{
	_AddBodyPart( new CTextBodyPart(cbText, lpszText) );
}

//	------------------------------------------------------------------------
//
//	CBody::AddFile()
//
void
CBody::AddFile( const auto_ref_handle& hf,
				UINT64 ibFile64,
				UINT64 cbFile64 )
{
	_AddBodyPart( new CFileBodyPart(hf, ibFile64, cbFile64) );
}

//	------------------------------------------------------------------------
//
//	CBody::AddStream()
//
void
CBody::AddStream( IStream& stm )
{
	TrapSz("Stream body parts no longer implemented");
}

//	------------------------------------------------------------------------
//
//	CBody::AddStream()
//
void
CBody::AddStream( IStream& stm,
					 UINT     ibOffset,
					 UINT     cbSize )
{
	TrapSz("Stream body parts no longer implemented");
}

//	------------------------------------------------------------------------
//
//	CBody::AddBodyPart()
//
void
CBody::AddBodyPart( IBodyPart * pBodyPart )
{
	_AddBodyPart( pBodyPart );
}

//	------------------------------------------------------------------------
//
//	CBody::Clear()
//
VOID
CBody::Clear()
{
	m_bodyPartList.Clear();
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::Accept()
//
//	Accepts an asynchronous body part visitor (v) at the iterator's
//	current position.  The Accept() observer (obsAccept) is notified
//	when the visitor finishes.
//
//	Lifetimes of both the visitor and the observer are controled
//	outside the scope of this function; i.e. it is assumed that
//	the observer will still be valid when the visitor finishes.
//
VOID
CBody::iterator::Accept( IBodyPartVisitor& v,
						 IAcceptObserver& obsAccept )
{
	//
	//	If we've reached the end of the body, then we're done.
	//
	if ( m_itPart.FDone() )
	{
		v.VisitComplete();
		obsAccept.AcceptComplete(0);
		return;
	}

	//
	//	We're not at the end of the body.  If we are starting
	//	a new part then rewind the part and our current position.
	//
	if ( NULL == m_pBodyPart )
	{
		m_pBodyPart = m_itPart.PItem();
		m_pBodyPart->Rewind();
		m_ibPart64 = 0;
	}

	//
	//	Save off the observer so that we can call it back when
	//	the body part is done accepting the visitor.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Accept the specified visitor starting from the current
	//	position in the current body part.
	//
	m_pBodyPart->Accept( v, m_ibPart64, *this );
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::AcceptComplete()
//
//	IBodyPart::AcceptObserver method called by the body part when it is
//	done with the visitor we told it to accept in Accept() above.
//
VOID
CBody::iterator::AcceptComplete( UINT64 cbAccepted64 )
{
	Assert( m_pBodyPart );


	m_ibPart64 += cbAccepted64;

	//
	//	If we reach the end of the current body part then tell
	//	our iterator to go to the next part.  If we hit the end
	//	of the body, we will catch that condition in Accept() the
	//	next time we get called there.
	//
	if ( m_ibPart64 == m_pBodyPart->CbSize64() )
	{
		m_itPart.Next();

		//
		//	Null out the current body part so we will know to
		//	fetch the next one on the next call to Accept().
		//
		m_pBodyPart = NULL;
	}

	//
	//	Callback our observer
	//
	m_pobsAccept->AcceptComplete(cbAccepted64);
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::Prune()
//
//	Deletes items from the body part list up to, but not including,
//	the part at the current list position.  This minimizes the
//	memory footprint for large one-pass async partwise operations
//	such as request persisting or response transmission.
//
VOID
CBody::iterator::Prune()
{
	m_itPart.Prune();
}

//	------------------------------------------------------------------------
//
//	CBody::AsyncPersist()
//
void
CBody::AsyncPersist( IAsyncStream& stm,
					 IAsyncPersistObserver& obs )
{
	PersistTrace( "DAV: TID %3d: 0x%08lX: CBody::AsyncPersist() called\n", GetCurrentThreadId(), this );

	auto_ref_ptr<CAsyncPersistor>
		pPersistor(new CAsyncPersistor(*this, stm, obs));

	pPersistor->Start();
}

//	------------------------------------------------------------------------
//
//	NewBody()
//
IBody * NewBody()
{
	return new CBody();
}

//	------------------------------------------------------------------------
//
//	CXMLBody::ScAddTextBytes
//
SCODE
CXMLBody::ScAddTextBytes ( UINT cbText, LPCSTR lpszText )
{
	Assert (cbText <= CB_XMLBODYPART_SIZE);
	Assert (lpszText);

	//	Create the text body part if necessary
	//
	if (!m_ptbp.get())
		m_ptbp = new CTextBodyPart(0, NULL);

	//	Add the piece to the body part
	//
	m_ptbp->AddTextBytes (cbText, lpszText);

	//	Add to body part list if this body part has reach a proper size
	//
	if (m_fChunked && (m_ptbp->CbSize64() > CB_XMLBODYPART_SIZE))
		SendCurrentChunk();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\custerr.h ===
#ifndef _CUSTERR_H_
#define _CUSTERR_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CUSTERR.H
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

class ICustomErrorMap : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	ICustomErrorMap(const ICustomErrorMap&);
	ICustomErrorMap& operator=(ICustomErrorMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	ICustomErrorMap()
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	};

public:
	virtual BOOL FDoResponse( IResponse& response, const IEcb&  ) const = 0;
};

ICustomErrorMap *
NewCustomErrorMap( LPWSTR pwszCustomErrorMappings );

class IEcb;
class IResponse;

BOOL
FSetCustomErrorResponse( const IEcb& ecb, IResponse& response );

#endif // _CUSTERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xemit.h ===
/*
 *	X E M I T . H
 *
 *	XML emitting
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XEMIT_H_
#define _EX_XEMIT_H_

#include <ex\sz.h>
#include <ex\autoptr.h>
#include <ex\cnvt.h>
#include <ex\nmspc.h>
#include <ex\xmldata.h>
#include <ex\atomcache.h>

typedef UINT XNT;

//	Interface IPreloadNamespaces
//
//	This is a virtual class which is to be implemented by everyone
//	that emits XML.
//
class CXMLEmitter;
class IPreloadNamespaces
{
	//	NOT IMPLEMENTED
	//
	IPreloadNamespaces& operator=( const IPreloadNamespaces& );

public:
	//	CREATORS
	//
	virtual ~IPreloadNamespaces() = 0 {};

	//	MANIPULATORS
	//
	virtual SCODE ScLoadNamespaces(CXMLEmitter* pxe) = 0;
};

//	class CXMLEmitter ---------------------------------------------------------
//
class CXNode;
class CEmitterNode;
class CXMLEmitter : public CEmitterNmspcCache
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG						m_cRef;

public:

	void AddRef()	{ m_cRef++; }
	void Release()	{ if (0 == --m_cRef) delete this; }

private:
	//	Other important bits
	//

	//	Because CXNode::ScDone (which references IXMLBody * m_pxb) is called in CXNode
	//	dtor, so we must have m_pxb defined befor m_pxnRoot, so that it will be destroyed
	//	after CXNode is destroyed
	//
	auto_ref_ptr<IXMLBody>		m_pxb;
	
	auto_ref_ptr<CXNode>		m_pxnRoot;
	IPreloadNamespaces*			m_pNmspcLoader;
	NmspcCache					m_cacheLocal;

	class NmspcEmittingOp : public CNmspcCache::NmspcCache::IOp
	{
	private:

		auto_ref_ptr<CXMLEmitter> m_emitter;
		auto_ref_ptr<CXNode>	  m_pxnParent;

		//	NOT IMPLEMENTED
		//
		NmspcEmittingOp( const NmspcEmittingOp& );
		NmspcEmittingOp& operator=( const NmspcEmittingOp& );

	public:

		NmspcEmittingOp (CXMLEmitter * pemitter,
						 CXNode * pxnParent)
				:m_emitter (pemitter),
				 m_pxnParent (pxnParent)
		{
		}

		BOOL operator()( const CRCWszN&,
						 const auto_ref_ptr<CNmspc>& nmspc );
	};

	//	non-implemented
	//
	CXMLEmitter(const CXMLEmitter& p);
	CXMLEmitter& operator=(const CXMLEmitter& p);

public:

	~CXMLEmitter() 
	{
		// According to standard C++, There's no garantee on the order of member
		// being deleted. so delete explicitly.
		// 
		m_pxnRoot.clear();
		m_pxb.clear();
	}
	CXMLEmitter(IXMLBody * pxb, IPreloadNamespaces * pNmspcLoader = NULL)
			: m_cRef(1),
			  m_pxb(pxb),
			  m_pNmspcLoader(pNmspcLoader)
	{
		INIT_TRACE(Xml);
	}

	CXNode* PxnRoot() { return m_pxnRoot.get(); }

	//	Find the appropriate namespace for the given name
	//
	SCODE ScFindNmspc (LPCWSTR, UINT, auto_ref_ptr<CNmspc>&);

	//	Attach the namespace to a given node
	//
	inline SCODE ScAddNmspc(const auto_ref_ptr<CNmspc>&, CXNode *);

	SCODE ScAddAttribute (
		/* [in] */ CXNode * pxn,
		/* [in] */ LPCWSTR pwszTag,
		/* [in] */ UINT cchTag,
		/* [in] */ LPCWSTR pwszValue,
		/* [in] */ UINT cchValue);

	SCODE ScNewNode (
		/* [in] */ XNT xnt,
		/* [in] */ LPCWSTR pwszTag,
		/* [in] */ CXNode* pxnParent,
		/* [out] */ auto_ref_ptr<CXNode>& pxnOut);

	//	Create a root node for this document
	//	including prologue.
	//
	SCODE ScSetRoot (LPCWSTR);

	//	Create a root node with NO prologue, this node can be
	//	used to build XML piece.
	//
	//	This function should not be used directly in IIS side. it may
	//	be used directly in store side to build XML chunks
	//
	SCODE ScNewRootNode (LPCWSTR);
	SCODE ScPreloadNamespace (LPCWSTR pwszTag);
	SCODE ScPreloadLocalNamespace (CXNode * pxn, LPCWSTR pwszTag);
	VOID DoneWithLocalNamespace ()
	{
		//	Reuse the namespace alises
		//
		//$	NOTE: we can do this by simply deducting the the number of aliases
		//$	NOTE: in the local cache. because all local aliases are added
		//$	NOTE: after root level aliases is added. so this way do cleanup
		//$	NOTE: only those aliases taken the by the local cache.
		//$	NOTE: Note that this is based on the fact that at any time, we
		//$	NOTE: we have only one <response> node under contruction
		//
		AdjustAliasNumber (0 - m_cacheLocal.CItems());

		//	Cleanup all the entries in the local cache
		//
		m_cacheLocal.Clear();
	}

	VOID Done()
	{
		//	Close the root node
		//
		m_pxnRoot.clear();

		//	Emit the body part;
		//
		m_pxb->Done();
	}
};

//	class CXNode --------------------------------------------------------------
//
class CXNode
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG						m_cRef;

public:

	void AddRef()				{ m_cRef++; }
	void Release()				{ if (0 == --m_cRef) delete this; }

private:

	//	Node type
	//
	const XNT					m_xnt;

	//	The body part manager
	//
	IXMLBody *		            m_pxb;


	//	The namespace that applies to this node
	//
	auto_ref_ptr<CNmspc>		m_pns;

	//  The escaped property tag of the node.
	//
	auto_heap_ptr<WCHAR>		m_pwszTagEscaped;
	UINT						m_cchTagEscaped;
	
	//  Whether or not the propertyname has an empty namespace (no namespace).
	//
	BOOL						m_fHasEmptyNamespace;
	
	//	If an open node. i.e. <tag>, not <tag/>, Used for element node only
	//
	UINT						m_fNodeOpen;

	//	Whether this node is done emitting
	//
	BOOL						m_fDone;

	//	The CXMLEmitter from which we persist the pilot namespace
	//
	CXMLEmitter *				m_pmsr;

	//	Emitting --------------------------------------------------------------
	//
	SCODE ScAddUnicodeResponseBytes (UINT cch, LPCWSTR pwsz);
	SCODE ScAddEscapedValueBytes (UINT cch, LPCSTR psz);
	SCODE ScAddEscapedAttributeBytes (UINT cch, LPCSTR psz);
	SCODE ScWriteTagName ();

	//	non-implemented
	//
	CXNode(const CXNode& p);
	CXNode& operator=(const CXNode& p);

public:

	CXNode(XNT xnt, IXMLBody* pxb) :
			m_cRef(1),
			m_fDone(FALSE),
			m_pmsr(NULL),
			m_xnt(xnt),
			m_fNodeOpen(FALSE),
			m_cchTagEscaped(0),
			m_pxb(pxb),
			m_fHasEmptyNamespace(FALSE)
	{
	}

	~CXNode()
	{
		if (!m_fDone)
		{
			//	Close the node
			//
			//$REVIEW: ScDone() could only fail for E_OUTMEMORY. Yes, we cannot
			//$REVIEW: return the failure from dtor. but how much better can be done
			//$REVIEW: when run out of memory?
			//$REVIEW: This does help to relievate the dependence on client to
			//$REVIEW: call ScDone correctly. (Of course, they still need to declare
			//$REVIEW: the nodes in correct order
			//
			(void)ScDone();
		}
	}

	//	CXNode types ----------------------------------------------------------
	//
	typedef enum {

		XN_ELEMENT = 0,
		XN_ATTRIBUTE,
		XN_NAMESPACE
	};

	//	Construction ----------------------------------------------------------
	//
	//	Set the name of the node
	//
	SCODE ScSetTag (CXMLEmitter* pmsr, UINT cch, LPCWSTR pwszTag);

	//	Sets the value of a node.
	//
	//	IMPORTANT: setting the value of a node appends the value of the node
	//	to the child.
	//
	SCODE ScSetValue (LPCSTR pszValue, UINT cch);
	SCODE ScSetValue (LPCWSTR pwszValue, UINT cch);
	SCODE ScSetValue (LPCWSTR pwszValue)
	{
		return ScSetValue (pwszValue, static_cast<UINT>(wcslen(pwszValue)));
	}
	SCODE ScSetUTF8Value (LPCSTR pszValue, UINT cch);
	SCODE ScSetFormatedXML (LPCSTR pszValue, UINT cchValue);
	SCODE ScSetFormatedXML (LPCWSTR pwszValue, UINT cchValue);

	//	Adds an child to the this node
	//
	SCODE ScGetChildNode (XNT xntType, CXNode ** ppxnChild);
	SCODE ScDone();
};

//	class CEmitterNode --------------------------------------------------------
//
class CEmitterNode
{
	auto_ref_ptr<CXMLEmitter>		m_emitter;
	auto_ref_ptr<CXNode>			m_pxn;

	//	non-implemented
	//
	CEmitterNode(const CEmitterNode& p);
	CEmitterNode& operator=(const CEmitterNode& p);

public:

	CEmitterNode ()
	{
	}

	//	Pass back a reference to the Emitter
	//
	CXMLEmitter* PEmitter() const { return m_emitter.get(); }
	VOID SetEmitter (CXMLEmitter* pmsr) { m_emitter = pmsr; }

	//	Pass back a reference to the CXNode
	//
	CXNode*	Pxn() const { return m_pxn.get(); }
	VOID SetPxn (CXNode* pxn) { m_pxn = pxn; }

	//	New node construction -------------------------------------------------
	//
	SCODE ScConstructNode (CXMLEmitter& emitter,
						   CXNode * pxnParent,
						   LPCWSTR pwszTag,
						   LPCWSTR pwszValue = NULL,
						   LPCWSTR pwszType = NULL);

	//	Add a child node to this node.  This API is the heart of the emitter
	//	processing and all other AddXXX() methods are written in terms of
	//	this method.
	//
	SCODE ScAddNode (LPCWSTR pwszTag,
					 CEmitterNode& en,
					 LPCWSTR pwszValue = NULL,
					 LPCWSTR pwszType = NULL);

	//	Non-wide char nodes
	//
	SCODE ScAddMultiByteNode (LPCWSTR pwszTag,
							  CEmitterNode& en,
							  LPCSTR pszValue,
							  LPCWSTR pwszType = NULL);
	SCODE ScAddUTF8Node (LPCWSTR pwszTag,
						 CEmitterNode& en,
						 LPCSTR pszValue,
						 LPCWSTR pwszType = NULL);


	//	"date.iso8601"
	//
	SCODE ScAddDateNode (LPCWSTR pwszTag,
						 FILETIME * pft,
						 CEmitterNode& en);
	//	"int"
	//
	SCODE ScAddInt64Node (LPCWSTR pwszTag,
						  LARGE_INTEGER * pli,
						  CEmitterNode& en);
	//	"boolean"
	//
	SCODE ScAddBoolNode (LPCWSTR pwszTag,
						 BOOL f,
						 CEmitterNode& en);
	//	"bin.base64"
	//
	SCODE ScAddBase64Node (LPCWSTR pwszTag,
						   ULONG cb,
						   LPVOID pv,
						   CEmitterNode& en,
						   BOOL fSupressTypeAttr = FALSE,
						   //	For WebFolders, we need to emit zero length
						   //	binary properties as bin.hex instead of bin.base64.
						   //
						   BOOL fUseBinHexIfNoValue = FALSE);

	//	Multi-Status ----------------------------------------------------------
	//
	SCODE ScDone ()
	{
		SCODE sc = S_OK;
		if (m_pxn.get())
		{
			sc = m_pxn->ScDone();
			m_pxn.clear();
		}
		m_emitter.clear();
		return sc;
	}
};

//	String constants ----------------------------------------------------------
//
DEC_CONST CHAR gc_chAmp				= '&';
DEC_CONST CHAR gc_chBang			= '!';
DEC_CONST CHAR gc_chColon			= ':';
DEC_CONST CHAR gc_chDash			= '-';
DEC_CONST CHAR gc_chEquals			= '=';
DEC_CONST CHAR gc_chForwardSlash	= '/';
DEC_CONST CHAR gc_chBackSlash		= '\\';
DEC_CONST CHAR gc_chGreaterThan		= '>';
DEC_CONST CHAR gc_chLessThan		= '<';
DEC_CONST CHAR gc_chApos			= '\'';
DEC_CONST CHAR gc_chQuestionMark	= '?';
DEC_CONST CHAR gc_chQuote			= '"';
DEC_CONST CHAR gc_chSpace			= ' ';
DEC_CONST CHAR gc_szAmp[]			= "&amp;";
DEC_CONST CHAR gc_szGreaterThan[]	= "&gt;";
DEC_CONST CHAR gc_szLessThan[]		= "&lt;";
DEC_CONST CHAR gc_szApos[]			= "&apos;";
DEC_CONST CHAR gc_szQuote[]			= "&quot;";

DEC_CONST WCHAR gc_wszAmp[]			= L"&amp;";
DEC_CONST WCHAR gc_wszGreaterThan[]	= L"&gt;";
DEC_CONST WCHAR gc_wszLessThan[]	= L"&lt;";
DEC_CONST WCHAR gc_wszApos[]		= L"&apos;";
DEC_CONST WCHAR gc_wszQuote[]		= L"&quot;";

//	XML property emitting helpers ---------------------------------------------
//
SCODE __fastcall
ScEmitPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitStringPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cpid,
	/* [in] */ const UINT cch,
	/* [in] */ const VOID* pv);

SCODE __fastcall
ScEmitBinaryPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const UINT cb,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitMultiValuedAtomicToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const UINT cbItem,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cValues,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitMutliValuedStringToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cpid,
	/* [in] */ const UINT cchMax,
	/* [in] */ const LPVOID* pv);

SCODE __fastcall
ScEmitMutliValuedBinaryToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const BYTE** ppb,
	/* [in] */ const DWORD* pcb,
	/* [in] */ const DWORD cbMax);

#endif	// _EX_XEMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\content.cpp ===
/*
 *	C O N T E N T . C P P
 *
 *	DAV content types
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "content.h"
#include <ex\reg.h>


//	------------------------------------------------------------------------
//
//	CchExtMapping()
//
//	Returns the size in characters required for a single mapping for
//	writing to the metabase.
//
//	The format of a mapping is null-terminated, comma-delimited string
//	(e.g. ".ext,application/ext").
//
inline UINT
CchExtMapping( UINT cchExt,
			   UINT cchContentType )
{
	Assert(cchExt > 0);
	Assert(cchContentType > 0);

	return (cchExt +
			1 + // ','
			cchContentType +
			1); // '\0'
}

//	------------------------------------------------------------------------
//
//	PwchFormatExtMapping()
//
//	Formats a single mapping for writing to the metabase.
//
//	The format of a mapping is null-terminated, comma-delimited string
//	(e.g. ".ext,application/ext").
//
//	This function returns a pointer to the character beyond the null terminator
//	in the formatted mapping.
//
inline WCHAR *
PwchFormatExtMapping( WCHAR * pwchBuf,
					  LPCWSTR pwszExt,
					  UINT cchExt,
					  LPCWSTR pwszContentType,
					  UINT cchContentType )
{
	Assert(cchExt > 0);
	Assert(cchContentType > 0);
	Assert(!IsBadReadPtr(pwszExt, sizeof(WCHAR) * (cchExt+1)));
	Assert(!IsBadReadPtr(pwszContentType, sizeof(WCHAR) * (cchContentType+1)));
	Assert(!IsBadWritePtr(pwchBuf, sizeof(WCHAR) * CchExtMapping(cchExt, cchContentType)));

	//	Dump in the extension first ...
	//
	memcpy(pwchBuf,
		   pwszExt,
		   sizeof(WCHAR) * cchExt);

	pwchBuf += cchExt;

	//	... followed by a comma
	//
	*pwchBuf++ = L',';

	//	... followed by the content type
	//
	memcpy(pwchBuf,
		   pwszContentType,
		   sizeof(WCHAR) * cchContentType);

	pwchBuf += cchContentType;

	//	... and null-terminated.
	//
	*pwchBuf++ = '\0';

	return pwchBuf;
}

//	========================================================================
//
//	CLASS CContentTypeMap
//
class CContentTypeMap : public IContentTypeMap
{
	//	Cache of mappings from filename extensions to content types
	//	(e.g. ".txt" --> "text/plain")
	//
	typedef CCache<CRCWszi, LPCWSTR> CMappingsCache;

	CMappingsCache m_cache;

	//	Flag set if the mappings came from an inherited mime map.
	//
	BOOL m_fIsInherited;

	//	CREATORS
	//
	CContentTypeMap(BOOL fMappingsInherited) :
		m_fIsInherited(fMappingsInherited)
	{
	}

	BOOL CContentTypeMap::FInit( LPWSTR pwszContentTypeMappings );

	//	NOT IMPLEMENTED
	//
	CContentTypeMap(const CContentTypeMap&);
	CContentTypeMap& operator=(CContentTypeMap&);

public:
	//	CREATORS
	//
	static CContentTypeMap * New( LPWSTR pwszContentTypeMappings,
								  BOOL fMappingsInherited );

	//	ACCESSORS
	//
	LPCWSTR PwszContentType( LPCWSTR pwszExt ) const
	{
		LPCWSTR * ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );

		//
		//	Return the content type (if there was one).
		//	Note that the returned pointer is good only
		//	for the lifetime of the IMDData object that
		//	scopes us since that is where the raw data lives.
		//
		return ppwszContentType ? *ppwszContentType : NULL;
	}

	BOOL FIsInherited() const { return m_fIsInherited; }
};

//	------------------------------------------------------------------------
//
//	CContentTypeMap::FInit()
//
BOOL
CContentTypeMap::FInit( LPWSTR pwszContentTypeMappings )
{
	Assert( pwszContentTypeMappings );

	//
	//	Initialize the cache of mappings
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//
	//	The format of the data in the mappings is a sequence of
	//	null-terminated strings followed by an additional null.
	//	Each string is of the format ".ext,type/subtype".
	//

	//
	//	Parse out the extension and type/subtype for each
	//	item and add a corresponding mapping to the cache.
	//
	for ( LPWSTR pwszMapping = pwszContentTypeMappings; *pwszMapping; )
	{
		enum {
			ISZ_CT_EXT = 0,
			ISZ_CT_TYPE,
			CSZ_CT_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CT_FIELDS];
		UINT cchMapping;

		//
		//	Digest the metadata
		//
		if ( !FParseMDData( pwszMapping,
							rgpwsz,
							CSZ_CT_FIELDS,
							&cchMapping ) )
		{
			DebugTrace( "CContentTypeMap::FInit() - Malformed metadata\n" );
			return FALSE;
		}

		//
		//	Verify that the first field is an extension or '*'
		//
		if ( L'.' != *rgpwsz[ISZ_CT_EXT] && wcscmp(rgpwsz[ISZ_CT_EXT], gc_wsz_Star) )
		{
			DebugTrace( "CContentTypeMap::FInit() - Bad extension\n" );
			return FALSE;
		}

		//
		//	Whatever there is in the second field is expected to be the
		//	content type.  Note that we don't do any syntactic checking
		//	there.
		//

		//
		//	Add a mapping from the extension to the content type
		//
		if ( !m_cache.FSet(CRCWszi(rgpwsz[ISZ_CT_EXT]), rgpwsz[ISZ_CT_TYPE]) )
			return FALSE;

		//
		//	Get the next mapping
		//
		pwszMapping += cchMapping;
	}

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CContentTypeMap::New()
//
CContentTypeMap *
CContentTypeMap::New( LPWSTR pwszContentTypeMappings,
					  BOOL fMappingsInherited )
{
	auto_ref_ptr<CContentTypeMap> pContentTypeMap;

	pContentTypeMap.take_ownership(new CContentTypeMap(fMappingsInherited));

	if ( pContentTypeMap->FInit(pwszContentTypeMappings) )
		return pContentTypeMap.relinquish();

	return NULL;
}

//	------------------------------------------------------------------------
//
//	NewContentTypeMap()
//
//	Creates a new content type map from a string of content type mappings.
//
IContentTypeMap *
NewContentTypeMap( LPWSTR pwszContentTypeMappings,
				   BOOL fMappingsInherited )
{
	return CContentTypeMap::New( pwszContentTypeMappings,
								 fMappingsInherited );
}

//	========================================================================
//
//	CLASS CRegMimeMap
//
//	Global registry-based mime map from file extension to content type.
//
class CRegMimeMap : public Singleton<CRegMimeMap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CRegMimeMap>;

	//
	//	String buffer for cached strings
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	Cache of mappings from filename extensions to content types
	//	(e.g. ".txt" --> "text/plain")
	//
	CCache<CRCWszi, LPCWSTR> m_cache;

	//	A R/W lock that we will use when when reading from
	//	the cache or when adding cache misses This lock
	//	is used by PszContentType().
	//
	//	FInitialize() does not use this lock (only initializes it)
	//	because it is called during dll load and we don't need to
	//	protect ourselves during dll load
	//
	CMRWLock   m_rwl;

	//	CREATORS
	//
	CRegMimeMap() {}

	//	NOT IMPLEMENTED
	//
	CRegMimeMap(const CRegMimeMap&);
	CRegMimeMap& operator=(CRegMimeMap&);

public:
	//	CREATORS
	//
	using Singleton<CRegMimeMap>::CreateInstance;
	using Singleton<CRegMimeMap>::DestroyInstance;
	BOOL FInitialize();

	//	ACCESSORS
	//
	using Singleton<CRegMimeMap>::Instance;

	//	Given an extension, return the Content-Type
	//	from the registry.
	//$NOTE: This was a const function before but it
	//	cannot be a const function anymore because we
	//	can add to our caches on cache misses.
	//
	LPCWSTR PwszContentType( LPCWSTR pwszExt );
};

//	------------------------------------------------------------------------
//
//	CRegMimeMap::FInitialize()
//
//	Load up the registry mappings.  Any kind of failure (short of an
//	exception) is not considered fatal.  It just means that we will
//	rely on the superceding metabase mappings.
//
BOOL
CRegMimeMap::FInitialize()
{
	BOOL fRet = FALSE;
	CRegKey regkeyClassesRoot;
	DWORD dwResult;
	
	//
	//	Initialize the cache of mappings
	//
	if ( !m_cache.FInit() )
		goto ret;

	//	Init the R/W lock.
	//
	if (!m_rwl.FInitialize())
		goto ret;

	//
	//	Read in the mapping information from the registry
	//

	//  Get the base of the classes hierarchy in the registry
	//
	dwResult = regkeyClassesRoot.DwOpen( HKEY_CLASSES_ROOT, L"" );
	if ( dwResult != NO_ERROR )
		goto ret;

	// Iterate over all the entries looking for content-type associations
	//
	for ( DWORD iMapping = 0;; iMapping++ )
	{
		WCHAR wszSubKey[MAX_PATH];
		DWORD cchSubKey;
		DWORD dwDataType;
		CRegKey regkeySub;
		WCHAR wszContentType[MAX_PATH] = {0};
		DWORD cbContentType = MAX_PATH;

		//
		//	Locate the next subkey.  If there isn't one then we're done.
		//
		cchSubKey = CElems(wszSubKey);
		dwResult = regkeyClassesRoot.DwEnumSubKey( iMapping, wszSubKey, &cchSubKey );
		if ( dwResult != NO_ERROR )
		{
			fRet = (ERROR_NO_MORE_ITEMS == dwResult);
			goto ret;
		}

		//
		//	Open that subkey.
		//
		dwResult = regkeySub.DwOpen( regkeyClassesRoot, wszSubKey );
		if ( dwResult != NO_ERROR )
			continue;

		//
		//  Get the associated Media-Type (Content-Type)
		//
		dwResult = regkeySub.DwQueryValue( L"Content Type",
										   wszContentType,
										   &cbContentType,
										   &dwDataType );
		if ( dwResult != NO_ERROR || dwDataType != REG_SZ )
			continue;

		//
		//	Add a mapping for this extension/content type pair.
		//
		//	Note: FAdd() cannot fail here -- FAdd() only fails on
		//	allocator failures.  Our allocators throw.
		//
		(VOID) m_cache.FAdd (CRCWszi(m_sb.AppendWithNull(wszSubKey)),
							 m_sb.AppendWithNull(wszContentType));
	}
	
ret:
	return fRet;
}


LPCWSTR
CRegMimeMap::PwszContentType( LPCWSTR pwszExt )
{
	LPCWSTR pwszContentType = NULL;
	LPCWSTR * ppwszContentType = NULL;
	CRegKey regkeyClassesRoot;
	CRegKey regkeySub;
	DWORD dwResult;
	DWORD dwDataType;
	WCHAR prgwchContentType[MAX_PATH] = {0};
	DWORD cbContentType;

	//	Grab a reader lock and check the cache.
	//
	{
		CSynchronizedReadBlock srb(m_rwl);

		ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );
	}

	//
	//	Return the content type (if there was one).
	//	Note that the returned pointer is good only
	//	for the lifetime of the cache (since we never
	//	modify the cache after class initialization)
	//	which, in turn, is only good for the lifetime
	//	of this object.  The external interface functions
	//	FGetContentTypeFromPath() and FGetContentTypeFromURI()
	//	both copy the returned content type into caller-supplied
	//	buffers.
	//
	if (ppwszContentType)
	{
		pwszContentType = *ppwszContentType;
		goto ret;
	}

	//	Otherwise, read in the mapping information from the registry
	//

	//  Get the base of the classes hierarchy in the registry
	//
	dwResult = regkeyClassesRoot.DwOpen( HKEY_CLASSES_ROOT, L"" );
	if ( dwResult != NO_ERROR )
		goto ret;


	//	Open that subkey of the extension we are looking for.
	//
	dwResult = regkeySub.DwOpen( regkeyClassesRoot, pwszExt );
	if ( dwResult != NO_ERROR )
		goto ret;

	//  Get the associated Media-Type (Content-Type)
	//
	cbContentType = sizeof(prgwchContentType);
	dwResult = regkeySub.DwQueryValue( L"Content Type",
									   prgwchContentType,
									   &cbContentType,
									   &dwDataType );
	if ( dwResult != NO_ERROR || dwDataType != REG_SZ )
		goto ret;

	//	Before adding the mapping for this extension/content type
	//	pair to the cache, take a writer lock and check the cache
	//	to see if someone has beaten us to it.
	//
	//	Grab a reader lock and check the cache.
	//
	{
		CSynchronizedWriteBlock swb(m_rwl);

		ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );

		if (ppwszContentType)
		{
			pwszContentType = *ppwszContentType;
			goto ret;
		}

		pwszContentType = m_sb.AppendWithNull(prgwchContentType);

		Assert (pwszContentType);

		//	Note: FAdd() cannot fail here -- FAdd() only fails on
		//	allocator failures.  Our allocators throw.
		//
		(VOID) m_cache.FAdd (CRCWszi(m_sb.AppendWithNull(pwszExt)),
							 pwszContentType);
	}
ret:
	return pwszContentType;
}

//	------------------------------------------------------------------------
//
//	FInitRegMimeMap()
//
BOOL
FInitRegMimeMap()
{
	return CRegMimeMap::CreateInstance().FInitialize();
}

//	------------------------------------------------------------------------
//
//	DeinitRegMimeMap()
//
VOID
DeinitRegMimeMap()
{
	CRegMimeMap::DestroyInstance();
}


//	------------------------------------------------------------------------
//
//	HrGetContentTypeByExt()
//
//	Fetch the content type of a resource based on its path/URI extension.
//	This function searches the following three places, in order, for a mapping:
//
//	1) a caller-supplied content type map
//	2) the global (metabase) content type map
//	3) the global (registry) content type map
//
//	Parameters:
//
//		pContentTypeMapLocal	[IN]	If non-NULL, points to the content type
//										map to search first.
//
//		pwszExt					[IN]	Extension to search on
//		pwszBuf					[OUT]	Buffer in which to copy the mapped
//										content type
//		pcchBuf					[IN]	Size of buffer in characters including 0 termination
//								[OUT]	Size of mapped content type
//
//		pfIsGlobalMapping		[OUT]	(Optional) Pointer to flag which is set
//										if the mapping is from a global map.
//
//	Returns:
//
//	S_OK
//		if a mapping was found and copied into the caller-supplied buffer
//		The size of the mapped content type is returned in *pcchzBuf.
//
//	HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)
//		if no mapping was found in any of the maps
//
//	HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY)
//		if a mapping was found, but the caller supplied buffer was too small.
//		The required size of the buffer is returned in *pcchzBuf.
//
HRESULT
HrGetContentTypeByExt( const IEcb& ecb,
					   const IContentTypeMap * pContentTypeMapLocal,
					   LPCWSTR pwszExt,
					   LPWSTR pwszBuf,
					   UINT * pcchBuf,
					   BOOL * pfIsGlobalMapping )
{
	Assert(!pfIsGlobalMapping || !IsBadWritePtr(pfIsGlobalMapping, sizeof(BOOL)));

	LPCWSTR pwszContentType = NULL;
	auto_ref_ptr<IMDData> pMDData;
	const IContentTypeMap * pContentTypeMapGlobal;

	//
	//	If a local map was specified then check it first for
	//	the extension based mapping.
	//
	if ( pContentTypeMapLocal )
		pwszContentType = pContentTypeMapLocal->PwszContentType(pwszExt);

	//
	//	If this doesn't yield a mapping then try the global mime map.
	//	Note: if we fail to get any metadata for the global mime map
	//	then use gc_szAppl_Octet_Stream rather than trying the registry.
	//	We'd rather use a "safe" default than a possibly intentionally
	//	overridden value from the registry.
	//
	if ( !pwszContentType )
	{
		if ( SUCCEEDED(HrMDGetData(ecb, gc_wsz_Lm_MimeMap, gc_wsz_Lm_MimeMap, pMDData.load())) )
		{
			pContentTypeMapGlobal = pMDData->GetContentTypeMap();

			if ( pContentTypeMapGlobal )
			{
				pwszContentType = pContentTypeMapGlobal->PwszContentType(pwszExt);
				if (pwszContentType && pfIsGlobalMapping)
					*pfIsGlobalMapping = TRUE;
			}
		}
		else
		{
			pwszContentType = gc_wszAppl_Octet_Stream;
		}
	}

	//
	//	Nothing in the global mime map either?
	//	Then try the registry as a last resort.
	//
	if ( !pwszContentType )
	{
		pwszContentType = CRegMimeMap::Instance().PwszContentType(pwszExt);
		if (pwszContentType && pfIsGlobalMapping)
			*pfIsGlobalMapping = TRUE;
	}

	//
	//	If there wasn't anything in the registry either then there is
	//	no mapping for this extension.
	//
	if ( !pwszContentType )
		return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

	//
	//	If we did find a mapping via one of the above methods
	//	then attempt to copy it into the caller-supplied buffer.
	//	If the buffer is not big enough, return an appropriate error.
	//	Note: FCopyStringToBuf() will fill in the required size
	//	if the buffer was not big enough.
	//
	return FCopyStringToBuf( pwszContentType,
							 pwszBuf,
							 pcchBuf ) ?

				S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
}

//	------------------------------------------------------------------------
//
//	PszExt()
//
//	Returns any extension (i.e. characters including
//	and following a '.') appearing in the string pointed
//	to by pchPathBegin that appear at or before pchPathEnd.
//
//	Returns NULL if there is no extension.
//
inline LPCWSTR
PwszExt( LPCWSTR pwchPathBegin,
		 LPCWSTR pwchPathEnd )
{
	Assert(pwchPathEnd);

	//
	//	Scan backward from the designated end of the path looking
	//	for a '.' that begins an extension.  If we don't find one
	//	or we find a path separator ('/') then there is no extension.
	//
	while ( pwchPathEnd-- > pwchPathBegin )
	{
		if ( L'.' == *pwchPathEnd )
			return pwchPathEnd;

		if ( L'/'  == *pwchPathEnd )
			return NULL;
	}

	return NULL;
}

//	------------------------------------------------------------------------
//
//	FGetContentType()
//
//	Fetches the content type of the resource at the specified path/URI
//	and copies it into a caller-supplied buffer.
//
//	The copied content type comes from one of the following mappings:
//
//	1) Via an explicit mapping from the specified path/URI extension.
//	2) Via a ".*" (default) mapping
//	3) application/octet-stream
//
//	Parameters:
//
//		pContentTypeMapLocal	[IN]	If non-NULL, points to a content type
//										map for HrGetContentTypeByExt() to
//										search first for each of the first
//										two methods above.
//
//		pwszPath				[IN]	Path whose content type is desired.
//		pwszBuf					[OUT]	Buffer in which to copy the mapped
//										content type
//		pcchBuf					[IN]	Size of buffer in characters including 0 termination
//								[OUT]	Size of mapped content type
//
//		pfIsGlobalMapping		[OUT]	(Optional) Pointer to flag which is set
//										if the mapping is from a global map.
//
//	Returns:
//
//	TRUE
//		if the mapping was successfully copied into the caller-supplied buffer.
//		The size of the mapped content type is returned in *pcchzBuf.
//
//	FALSE
//		if the caller-supplied buffer was too small.
//		The required size of the buffer is returned in *pcchzBuf.
//
BOOL
FGetContentType( const IEcb& ecb,
				 const IContentTypeMap * pContentTypeMapLocal,
				 LPCWSTR pwszPath,
				 LPWSTR pwszBuf,
				 UINT * pcchBuf,
				 BOOL * pfIsGlobalMapping )
{
	HRESULT hr;

	CStackBuffer<WCHAR>	pwszCopy;
	BOOL fCopy = FALSE;
	UINT cchPath = static_cast<UINT>(wcslen(pwszPath));

	//	Scan backward to skip all '/' characters at the end.
	//
	while ( cchPath  && (L'/' == pwszPath[cchPath-1]) )
	{
		cchPath--;
		fCopy = TRUE;	// Fine to keep the assignment here, as clients usually
						// do not put multiple wacks at the end of the path.
	}

	if (fCopy)
	{
		//	Make the copy of the path without ending wacks.
		//
		if (!pwszCopy.resize(CbSizeWsz(cchPath)))
			return FALSE;

		memcpy( pwszCopy.get(), pwszPath, cchPath * sizeof(WCHAR) );
		pwszCopy[cchPath] = L'\0';

		//	Swap the pointers
		//
		pwszPath = pwszCopy.get();
	}

	//
	//	First check for an extension mapping in both the specified
	//	content type map and the global mime map.
	//
	//	The loop checks progressively longer extensions.  E.g. a path
	//	of "/foo/bar/baz.a.b.c" will be checked for ".c" then ".b.c"
	//	then ".a.b.c".  This is consistent with IIS' behavior.
	//
	for ( LPCWSTR pwszExt = PwszExt(pwszPath, pwszPath + cchPath);
		  pwszExt;
		  pwszExt = PwszExt(pwszPath, pwszExt) )
	{
		hr = HrGetContentTypeByExt( ecb,
									pContentTypeMapLocal,
									pwszExt,
									pwszBuf,
									pcchBuf,
									pfIsGlobalMapping );

		if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
		{
			Assert( S_OK == hr || HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) == hr );
			return SUCCEEDED(hr);
		}
	}

	//
	//	There is no extension mapping so check both maps
	//	for a ".*" (default) mapping.  Note: don't set *pfIsGlobalMapping if
	//	the ".*" mapping is the only one that applies.  The ".*" mapping is
	//	a catch-all; it is ok for local mime maps to override it.
	//
	hr = HrGetContentTypeByExt( ecb,
								pContentTypeMapLocal,
								L".*",
								pwszBuf,
								pcchBuf,
								NULL );

	if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
	{
		Assert( S_OK == hr || HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) == hr );
		return SUCCEEDED(hr);
	}

	//
	//	No ".*" mapping either so use the default default --
	//	application/octet-stream.
	//
	return FCopyStringToBuf( gc_wszAppl_Octet_Stream,
							 pwszBuf,
							 pcchBuf );
}

//	------------------------------------------------------------------------
//
//	FGetContentTypeFromPath()
//
//	Fetch the content type associated with the extension of the
//	specified file path.
//
BOOL FGetContentTypeFromPath( const IEcb& ecb,
							  LPCWSTR pwszPath,
							  LPWSTR pwszBuf,
							  UINT * pcchBuf )
{
	return FGetContentType( ecb,
							NULL, // No local map to check
							pwszPath,
							pwszBuf,
							pcchBuf,
							NULL ); // Don't care where the mapping comes from
}

//	------------------------------------------------------------------------
//
//	FGetContentTypeFromURI()
//
//	Retrieves the content type for the specified URI.
//
BOOL
FGetContentTypeFromURI( const IEcb& ecb,
						LPCWSTR pwszURI,
						LPWSTR  pwszBuf,
						UINT * pcchBuf,
						BOOL * pfIsGlobalMapping )
{
	auto_ref_ptr<IMDData> pMDData;

	//
	//	Fetch the metadata for this URI.  If it has a content type map
	//	then use it to look for a mapping.  If it does not have a content
	//	type map then check the global mime map.
	//
	//	Note: if we fail to get the metadata at all then default the
	//	content type to application/octet-stream.  Do not use the global
	//	mime map just because we cannot get the metadata.
	//
	if ( FAILED(HrMDGetData(ecb, pwszURI, pMDData.load())) )
	{
		DebugTrace( "FGetContentTypeFromURI() - HrMDGetData() failed to get metadata for %S.  Using application/octet-stream...\n", pwszURI );
		return FCopyStringToBuf( gc_wszAppl_Octet_Stream,
								 pwszBuf,
								 pcchBuf );
	}

	const IContentTypeMap * pContentTypeMap = pMDData->GetContentTypeMap();

	//
	//	If there is a content type map specific to this URI then
	//	try it first looking for a "*" (unconditional) mapping.
	//
	if ( pContentTypeMap )
	{
		LPCWSTR pwszContentType = pContentTypeMap->PwszContentType(gc_wsz_Star);
		if ( pwszContentType )
			return FCopyStringToBuf( pwszContentType,
									 pwszBuf,
									 pcchBuf );
	}

	//
	//	There was either no "*" mapping or no URI-specific map
	//	so check the global maps
	//
	return FGetContentType( ecb,
							pContentTypeMap,
							pwszURI,
							pwszBuf,
							pcchBuf,
							pfIsGlobalMapping );
}

//	------------------------------------------------------------------------
//
//	ScApplyStarExt()
//
//		Determines whether the mapping "*" --> pwszContentType should be used
//		instead of the mapping *ppwszExt --> pwszContentType based on the
//		following criteria:
//
//		Use the mapping "*" --> pwszContentType if:
//
//			o	*ppwszExt is already "*", OR
//			o	a mapping exists in pwszMappings for *ppwszExt whose content type
//				is not the same as pwszContentType, OR
//			o	a "*" mapping exists in pwszMappings.
//
//		Use *ppwszExt --> pwszContentType otherwise.
//
//	Returns:
//
//		The value returned in *ppwszExt indicates the mapping to be used.
//
SCODE
ScApplyStarExt( LPWSTR pwszMappings,
				LPCWSTR pwszContentType,
				LPCWSTR * ppwszExt )

{
	SCODE sc = S_OK;

	Assert(pwszMappings);
	Assert(!IsBadWritePtr(ppwszExt, sizeof(LPCWSTR)));
	Assert(*ppwszExt);
	Assert(pwszContentType);

	//
	//	Parse out the extension and type/subtype for each
	//	item and check for conflicts or "*" mappings.
	//
	for ( LPWSTR pwszMapping = pwszMappings;
		  L'*' != *(*ppwszExt) && *pwszMapping; )
	{
		enum {
			ISZ_CT_EXT = 0,
			ISZ_CT_TYPE,
			CSZ_CT_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CT_FIELDS];

		//
		//	Digest the metadata for this mapping
		//
		{
			UINT cchMapping;

			if ( !FParseMDData( pwszMapping,
								rgpwsz,
								CSZ_CT_FIELDS,
								&cchMapping ) )
			{
				sc = E_FAIL;
				DebugTrace("ScApplyStarExt() - Malformed metadata 0x%08lX\n", sc);
				goto ret;
			}

			pwszMapping += cchMapping;
		}

		Assert(rgpwsz[ISZ_CT_EXT]);
		Assert(rgpwsz[ISZ_CT_TYPE]);

		//
		//	If this is a "*" mapping OR
		//	If the extension matches *ppszExt AND
		//		the content types conflict
		//
		//	then use a "*" mapping.
		//
		if ((L'*' == *rgpwsz[ISZ_CT_EXT]) ||
			(!_wcsicmp((*ppwszExt), rgpwsz[ISZ_CT_EXT]) &&
			 _wcsicmp(pwszContentType, rgpwsz[ISZ_CT_TYPE])))
		{
			*ppwszExt = gc_wsz_Star;
		}

		//
		//	!!!IMPORTANT!!!  FParseMDData() munges the mapping string.
		//	Specifically, it replaces the comma separator with a null.
		//	We always need to restore the comma so that the mappings
		//	string is not modified by this function!
		//
		*(rgpwsz[ISZ_CT_EXT] + wcslen(rgpwsz[ISZ_CT_EXT])) = L',';
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	ScAddMimeMap()
//
//		Adds the mapping pwszExt --> pwszContentType to the mime map at
//		the metabase path pwszMDPath relative to the currently open
//		metabase handle mdoh, creating a new mime map as required.
//
//		A new mime map is required when there is no existing mime map
//		(pwszMappings is NULL) or if a "*" mapping is being set.  In the
//		latter case, the "*" map overwrites whatever mapping is there.
//
SCODE
ScAddMimeMap( const CMDObjectHandle& mdoh,
			  LPCWSTR pwszMDPath,
			  LPWSTR  pwszMappings,
			  UINT	  cchMappings,
			  LPCWSTR pwszExt,
			  LPCWSTR pwszContentType )
{
	CStackBuffer<WCHAR> wszBuf;
	UINT cchContentType = static_cast<UINT>(wcslen(pwszContentType));
	UINT cchExt = static_cast<UINT>(wcslen(pwszExt));
	WCHAR * pwch;

	//	If the content type is an empty string then we will not set it
	//	into the metabase as IIS will simple not be able to understand it.
	//	Thus semantically the empty content type header will be treated
	//	the same way as if the content type was not specified.
	//
	if (L'\0' == *pwszContentType)
	{
		return S_OK;
	}

	if (pwszMappings && L'*' != *pwszExt)
	{
		//	IIS has an interesting concept of an empty mapping.  Instead
		//	of just a single null (indicating an empty list of mapping
		//	strings) it uses a double null which to us would actually mean
		//	a list of strings consisting solely of the empty string!
		//	Anyway, if we add a mapping after this "empty mapping" neither
		//	IIS nor HTTPEXT will ever see it because the mime map checking
		//	implementations in both code bases treat the extraneous null
		//	as the list terminator.
		//
		//		If we have an "empty" set of mappings then REPLACE
		//		it with a set consisting of just the new mapping.
		//
		if (2 == cchMappings && !*pwszMappings)
			--cchMappings;

		//	Start at the end of the current mappings.  Skip the extra
		//	null at the end.  We will add it back later.
		//
		Assert(cchMappings >= 1);
		Assert(L'\0' == pwszMappings[cchMappings-1]);
		pwch = pwszMappings + cchMappings - 1;
	}
	else
	{
		//	Allocate enough space including list terminating 0
		//
		if (!wszBuf.resize(CbSizeWsz(CchExtMapping(cchExt, cchContentType))))
			return E_OUTOFMEMORY;

		//	Since this is the only mapping, start from the beginning
		//
		pwszMappings = wszBuf.get();
		pwch = pwszMappings;
	}

	//	Append the new mapping to the end of the existing mappings (if any).
	//
	pwch = PwchFormatExtMapping(pwch,
								pwszExt,
								cchExt,
								pwszContentType,
								cchContentType);

	//	Terminate the new set of mappings
	//
	*pwch++ = L'\0';

	//	Write the mappings out to the metabase
	//
	METADATA_RECORD mdrec;

	mdrec.dwMDIdentifier = MD_MIME_MAP;
	mdrec.dwMDAttributes = METADATA_INHERIT;
	mdrec.dwMDUserType   = IIS_MD_UT_FILE;
	mdrec.dwMDDataType   = MULTISZ_METADATA;
	mdrec.dwMDDataLen    = static_cast<DWORD>(pwch - pwszMappings) * sizeof(WCHAR);
	mdrec.pbMDData       = reinterpret_cast<LPBYTE>(pwszMappings);

	return mdoh.HrSetMetaData(pwszMDPath, &mdrec);
}

//	------------------------------------------------------------------------
//
//	ScSetStarMimeMap()
//
SCODE
ScSetStarMimeMap( const IEcb& ecb,
				  LPCWSTR pwszURI,
				  LPCWSTR pwszContentType )
{
	SCODE sc = E_OUTOFMEMORY;

	//	Get the metabase path corresponding to pwszURI.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathURI;
	if (NULL == pwszMDPathURI.resize(CbMDPathW(ecb,pwszURI)))
		return sc;

	{
		MDPathFromURIW(ecb, pwszURI, pwszMDPathURI.get());
		CMDObjectHandle	mdoh(ecb);
		LPCWSTR pwszMDPathMimeMap;

		//	Open a metabase object at or above the path where we want to set
		//	the star mime map.
		//
		sc = HrMDOpenMetaObject( pwszMDPathURI.get(),
								 METADATA_PERMISSION_WRITE,
								 1000, // timeout in msec (1.0 sec)
								 &mdoh );
		if (SUCCEEDED(sc))
		{
			pwszMDPathMimeMap = NULL;
		}
		else
		{
			if (sc != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
			{
				DebugTrace ("ScSetStarMimeMap() - HrMDOpenMetaObject(pszMDPathURI) "
							"failed 0x%08lX\n", sc);
				goto ret;
			}

			sc = HrMDOpenMetaObject( ecb.PwszMDPathVroot(),
									 METADATA_PERMISSION_WRITE,
									 1000,
									 &mdoh );
			if (FAILED(sc))
			{
				DebugTrace("ScSetStarMimeMap() - HrMDOpenMetaObject(ecb.PwszMDPathVroot()) "
						   "failed 0x%08lX\n", sc);
				goto ret;
			}

			Assert(!_wcsnicmp(pwszMDPathURI.get(),
							  ecb.PwszMDPathVroot(),
							  wcslen(ecb.PwszMDPathVroot())));

			pwszMDPathMimeMap = pwszMDPathURI.get() + wcslen(ecb.PwszMDPathVroot());
		}

		//	Add the "*" mime map
		//
		sc = ScAddMimeMap(mdoh,
						  pwszMDPathMimeMap,
						  NULL,			//	Overwrite existing mimemap (if any)
						  0,			//
						  gc_wsz_Star,	//	with "*" --> pszContentType
						  pwszContentType);
		if (FAILED(sc))
		{
			DebugTrace("ScSetStarMimeMap() - ScAddMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	ScAddExtMimeMap() (aka the guts behind NT5:292139)
//
//		Use the following algorithm to set the content type (pwszContentType)
//		of the resource at pwszURI:
//
//			If a mime map exists somewhere at or above the metabase path for
//			pwszURI that has no mapping for the extension of pwszURI AND that
//			mapping does NOT have a "*" mapping, then add a mapping from
//			the extension of pwszURI to pwszContentType to that map.
//
//			If no such map exists then create one at the site root and
//			add the mapping there.
//
//			In all other cases, add the mapping "*" --> pwszContentType
//			at the level of pwszURI.
//
//		The idea behind this complicated little routine is to reduce the number
//		of "*" mappings that we create in the metabase to represent content types
//		of resources with extensions that are not found in any administrator-defined
//		mime map or global mime map.  This helps most in scenarios where a new
//		application is deployed which uses a heretofore unknown extension and
//		the install utility (or admin) neglects to register a content type mapping
//		for that application in any mime map.
//
//		Without this functionality, we could end up creating "*" mappings for
//		every resource created with an unknown extension.  With time that would
//		drag down the performance of the metabase significantly.
//
SCODE
ScAddExtMimeMap( const IEcb& ecb,
				 LPCWSTR pwszURI,
				 LPCWSTR pwszContentType )
{
	//	Metabase path corresponding to pwszURI.  We form a relative path,
	//	off of this path, where we set a "*" mapping if we need to do so.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathURI(CbMDPathW(ecb, pwszURI));
	if (!pwszMDPathURI.get())
		return E_OUTOFMEMORY;

	MDPathFromURIW(ecb, pwszURI, pwszMDPathURI.get());
	UINT cchPathURI = static_cast<UINT>(wcslen(pwszMDPathURI.get()));

	//	Metabase path to the non-inherited mime map closest to pwszURI.  When there
	//	is no such mime map, this is just the metabase path to the site root.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathMimeMap(CbSizeWsz(cchPathURI));
	if (!pwszMDPathMimeMap.get())
		return E_OUTOFMEMORY;

	memcpy(pwszMDPathMimeMap.get(),
		   pwszMDPathURI.get(),
		   CbSizeWsz(cchPathURI));
	UINT cchPathMimeMap = cchPathURI;
	LPWSTR pwszMDPathMM = pwszMDPathMimeMap.get();

	//	Buffer for the metabase path to the site root (e.g. "/LM/W3SVC/1/root").
	//
	WCHAR rgwchMDPathSiteRoot[MAX_PATH];
	SCODE sc = S_OK;

	//	Locate the non-inherited mime map "closest" to pszURI by probing successively
	//	shorter path prefixes until a non-inherited mime map is found or until we reach
	//	the site root, whichever happens first.
	//
	for ( ;; )
	{
		//	Fetch the (hopefully cached) metadata for the current metabase path.
		//
		//$OPT
		//	Note the use of /LM/W3SVC as the "open" path.  We use that path because
		//	it is guaranteed to exist (a requirement for this form of HrMDGetData())
		//	and because it is above the site root.  It is also easily computable
		//	(it's a constant!).  It does however lock a pretty huge portion of the
		//	metabase fetching the metadata.  If this turns out to not perform well
		//	(i.e. the call fails due to timeout under normal usage) then we should
		//	evaluate whether a "lower" path -- like the site root -- would be a
		//	more appropriate choice.
		//
		auto_ref_ptr<IMDData> pMDDataMimeMap;
		sc = HrMDGetData(ecb,
						 pwszMDPathMM,
						 gc_wsz_Lm_W3Svc,
						 pMDDataMimeMap.load());
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - HrMDGetData(pwszMDPathMimeMap) failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Look for a mime map (inherited or not) in the metadata.  If we don't find
		//	one then we'll want to create one at the site root.
		//
		IContentTypeMap * pContentTypeMap;
		pContentTypeMap = pMDDataMimeMap->GetContentTypeMap();
		if (!pContentTypeMap)
		{
			ULONG cchPathSiteRoot = CElems(rgwchMDPathSiteRoot) - gc_cch_Root;

			//	We did not find any mime map (inherited or otherwise) so
			//	set up to create a mime map at the site root.
			//
			//	Get the instance root (e.g. "/LM/W3SVC/1")
			//
			if (!ecb.FGetServerVariable("INSTANCE_META_PATH",
										rgwchMDPathSiteRoot,
										&cchPathSiteRoot))
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("ScAddExtMimeMap() - ecb.FGetServerVariable(INSTANCE_META_PATH) failed 0x%08lX\n", sc);
				goto ret;
			}

			//	Convert the size (in bytes) of the site root path to a length (in characters).
			//	Remember: cbPathSiteRoot includes the null terminator.
			//
			cchPathMimeMap = cchPathSiteRoot - 1;

			//	Tack on the "/root" part to get something like "/LM/W3SVC/1/root".
			//
			memcpy( rgwchMDPathSiteRoot + cchPathMimeMap,
					gc_wsz_Root,
					CbSizeWsz(gc_cch_Root)); // copy the null terminator too

			cchPathMimeMap += gc_cch_Root;
			pwszMDPathMM = rgwchMDPathSiteRoot;
			break;
		}
		else if (!pContentTypeMap->FIsInherited())
		{
			//	We found a non-inherited mime map at pwszMDPathMimeMap
			//	so we are done looking.
			//
			break;
		}

		//	We found a mime map, but it was an inherited mime map,
		//	so back up one path component and check there.  Eventually
		//	we will find the path where it was inherited from.
		//
		while ( L'/' != pwszMDPathMM[--cchPathMimeMap])
			Assert(cchPathMimeMap > 0);

		pwszMDPathMM[cchPathMimeMap] = L'\0';
	}

	//	At this point, pwszMDPathMimeMap is the location of an existing non-inherited
	//	mime map or the site root.  Now we want to lock down the metabase at this
	//	path (and everything below it) so that we can consistently check the actual
	//	current mime map contents (remember, we were looking at a cached view above!)
	//	and update them with the new mapping.
	//
	{
		CMDObjectHandle	mdoh(ecb);
		METADATA_RECORD mdrec;

		//	Figure out the file extension on the URI.  If it doesn't have one
		//	then we know right away that we are going to use a "*" mapping.
		//
		LPCWSTR pwszExt = PwszExt(pwszURI, pwszURI + wcslen(pwszURI));
		if (!pwszExt)
			pwszExt = gc_wsz_Star;

		//	Buffer size for the mime map metadata.  8K should be big enough
		//	for most mime maps -- the global mime map at lm/MimeMap is only ~4K.
		//
		enum { CCH_MAPPINGS_MAX = 2 * 1024 };

		//	Compute the size of the new mapping and do a quick check
		//	to handle any bozo who tries to pull a fast one by creating
		//	a mapping that is ridiculously large.
		//
		UINT cchNewMapping = CchExtMapping(static_cast<UINT>(wcslen(pwszExt)),
										   static_cast<UINT>(wcslen(pwszContentType)));

		if (cchNewMapping >= CCH_MAPPINGS_MAX )
		{
			sc = E_DAV_INVALID_HEADER;  //HSC_BAD_REQUEST
			goto ret;
		}

		//	Buffer for the mime map metadata.  8K should be big enough for most
		//	mime maps -- the global mime map at lm/MimeMap is only ~4K.
		//	And don't forget to leave room at the end for the new mapping!
		//
		CStackBuffer<BYTE,4096> rgbData;
		Assert (rgbData.size() == (CCH_MAPPINGS_MAX * sizeof(WCHAR)));
		DWORD cbData = (CCH_MAPPINGS_MAX - cchNewMapping) * sizeof(WCHAR);

		//	Open the metadata object at the path we found.  We know that the path
		//	that we want to open already exists -- if it is a path to some node
		//	with a non-inherited mime map then it is the path to the site root.
		//
		sc = HrMDOpenMetaObject( pwszMDPathMM,
								 METADATA_PERMISSION_WRITE |
								 METADATA_PERMISSION_READ,
								 1000, // timeout in msec (1.0 sec)
								 &mdoh );
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - HrMDOpenMetaObject() failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Fetch the mime map.
		//
		mdrec.dwMDIdentifier = MD_MIME_MAP;
		mdrec.dwMDAttributes = METADATA_INHERIT;
		mdrec.dwMDUserType   = IIS_MD_UT_FILE;
		mdrec.dwMDDataType   = MULTISZ_METADATA;
		mdrec.dwMDDataLen    = cbData;
		mdrec.pbMDData       = rgbData.get();

		sc = mdoh.HrGetMetaData( NULL, // No relative path to the mime map.
									   // We opened a path directly there above.
								 &mdrec,
								 &cbData );

		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc)
		{
			//	In the unlikely event that the static-size buffer above wasn't
			//	big enough, then try reading again into a one that is.
			//
			//	Again, leave enough room for the new mapping
			//
			mdrec.dwMDDataLen = cbData;
			mdrec.pbMDData = rgbData.resize(cbData + cchNewMapping * sizeof(WCHAR));
			sc = mdoh.HrGetMetaData( NULL, &mdrec, &cbData );
		}
		if (FAILED(sc))
		{
			if (MD_ERROR_DATA_NOT_FOUND != sc)
			{
				DebugTrace("ScAddExtMimeMap() - HrMDOpenMetaObject() failed 0x%08lX\n", sc);
				goto ret;
			}

			//	If we don't find a mapping, that's fine.  Most likely we are just
			//	at the site root.  There is also a slim chance that the admin could
			//	have deleted the mapping between the time we found it in the cache
			//	and the time that we locked the path in the metabase.
			//
			mdrec.pbMDData = NULL;
			sc = S_OK;
		}

		//	If we don't have a mime map then use a "*" mapping unless we are
		//	at the site root in which case we should CREATE a mime map with
		//	a single mapping for the URI extension.
		//
		if (!mdrec.pbMDData)
		{
			if (rgwchMDPathSiteRoot != pwszMDPathMM)
				pwszExt = gc_wsz_Star;
		}

		//	If we found a mime map and it is still not inherited then we have
		//	some more checking to do.  Yes, the mime map actually can be
		//	inherited at this point.  See below for why.
		//
		else if (!(mdrec.dwMDAttributes & METADATA_ISINHERITED))
		{
			//	Check whether we should apply a "*" mapping rather than
			//	the extension mapping that we ideally want.  The rules
			//	governing this decision are outlined in ScApplyStarExt().
			//
			sc = ScApplyStarExt(reinterpret_cast<LPWSTR>(mdrec.pbMDData),
								pwszContentType,
								&pwszExt);
			if (FAILED(sc))
			{
				DebugTrace("ScAddExtMimeMap() - ScApplyStarExt() failed 0x%08lX\n", sc);
				goto ret;
			}
		}

		//	We found a mime map, but for some oddball reason it now appears to be
		//	inherited!  This can happen if the admin manages to change things
		//	between the time we check the cache and when we open pszMDPathMimeMap
		//	for writing.  This should be a sufficiently rare case that falling back
		//	to a "*" mapping here isn't so bad.
		//
		else
		{
			Assert(mdrec.pbMDData);
			Assert(mdrec.dwMDAttributes & METADATA_ISINHERITED);
			pwszExt = gc_wsz_Star;
		}

		//	Ok, we're all set.  We have the extension ("*" or .somethingorother).
		//	We have the content type.  We have the existing mappings (if any).
		//	Add in the new mapping.
		//
		//	Note: if we are adding a "*" mapping, we always want to add it
		//	at the level of the URI.  But since the metabase handle we have
		//	open is at some level above the URI, the path we pass to ScAddMimeMap()
		//	below must be relative to the path used to open the handle.
		//	Easy enough.  That path is just what's left of the URI path
		//	beyond where we found (or would have created) the non-inherited
		//	mime map.
		//
		sc = ScAddMimeMap(mdoh,
						  (L'*' == *pwszExt) ?
							  pwszMDPathURI.get() + cchPathMimeMap :
							  NULL,
						  reinterpret_cast<LPWSTR>(mdrec.pbMDData),
						  mdrec.dwMDDataLen / sizeof(WCHAR),
						  pwszExt,
						  pwszContentType);
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - ScAddMimeMap(pszExt) failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	ScSetContentType()
//
SCODE
ScSetContentType( const IEcb& ecb,
				  LPCWSTR pwszURI,
				  LPCWSTR pwszContentTypeWanted )
{
	BOOL fIsGlobalMapping = FALSE;
	CStackBuffer<WCHAR> pwszContentTypeCur;
	SCODE sc = S_OK;
	UINT cchContentTypeCur;

	//	Check what the content type would be if we didn't do anything.
	//	If it's what we want, then we're done.  No need to open the metabase
	//	for anything!
	//
	cchContentTypeCur = pwszContentTypeCur.celems();
	if ( !FGetContentTypeFromURI( ecb,
								  pwszURI,
								  pwszContentTypeCur.get(),
								  &cchContentTypeCur,
								  &fIsGlobalMapping ) )
	{
		if (!pwszContentTypeCur.resize(cchContentTypeCur * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		if ( !FGetContentTypeFromURI( ecb,
									  pwszURI,
									  pwszContentTypeCur.get(),
									  &cchContentTypeCur,
									  &fIsGlobalMapping))
		{
			//
			//	If the size of the content type keeps changing on us
			//	then the server is too busy.  Give up.
			//
			sc = ERROR_PATH_BUSY;
			DebugTrace("ScSetContentType() - FGetContentTypeFromURI() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

	//
	//	If the content type is already what we want then don't change a thing.
	//
	if ( !_wcsicmp( pwszContentTypeWanted, pwszContentTypeCur.get()))
	{
		sc = S_OK;
		goto ret;
	}

	//
	//	The current content type isn't what we want so we will have to set
	//	something in the metabase.  If the mapping for this extension came
	//	from one of the global maps, then always override the mapping by
	//	setting a "*" mapping at the URI level.  If the mapping was not
	//	a global one then what we do gets very complicated due to Raid NT5:292139....
	//
	if (fIsGlobalMapping)
	{
		sc = ScSetStarMimeMap(ecb,
							  pwszURI,
							  pwszContentTypeWanted);
		if (FAILED(sc))
		{
			DebugTrace("ScSetContentType() - ScAddExtMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}
	else
	{
		sc = ScAddExtMimeMap(ecb,
							 pwszURI,
							 pwszContentTypeWanted);
		if (FAILED(sc))
		{
			DebugTrace("ScSetContentType() - ScAddExtMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

/*
 *	ScCanAcceptContent()
 *
 *	Purpose:
 *
 *		Check if the given content type is acceptable
 *
 *	Parameters:
 *
 *		pwszAccepts	[in]	the Accept header;
 *		pwszApp		[in]	the application part of the content type
 *		pwszType	[in]	the sub type of the content type
 *
 *	Returns:
 *
 *		S_OK	- if the request accepts the content type, no wildcard matching
 *		S_FALSE - if the request accepts the content type, wildcard matching
 *		E_DAV_RESPONSE_TYPE_UNACCEPTED - if the response type was unaccepted
 */
SCODE __fastcall
ScCanAcceptContent (LPCWSTR pwszAccepts, LPWSTR pwszApp, LPWSTR pwszType)
{
	SCODE sc = E_DAV_RESPONSE_TYPE_UNACCEPTED;
	HDRITER_W hit(pwszAccepts);
	LPWSTR pwsz;
	LPCWSTR pwszAppType;
	LPCWSTR pwszSubType;

	//	Rip through the entries in the header...
	//
	while (NULL != (pwszAppType = hit.PszNext()))
	{
		pwsz = const_cast<LPWSTR>(pwszAppType);

		//	Search for the end of the application type
		//	'/' is the sub type separator, and ';' starts the parameters
		//
		while (	*pwsz &&
				(L'/' != *pwsz) &&
				(L';' != *pwsz) )
			pwsz++;

		if (L'/' == *pwsz)
		{
			//	Make pwszAppType point to the application type ...
			//
			*pwsz++ = L'\0';

			//	... and pszSubType point to the subtype
			//
			pwszSubType = pwsz;
			while (*pwsz && (L';' != *pwsz))
				pwsz++;

			*pwsz = L'\0';
		}
		else
		{
			//	There's not sub type.
			//
			*pwsz = L'\0';

			// 	point pszSubType to a empty string, instead of setting it to NULL
			//
			pwszSubType = pwsz;
		}

		//	Here're the rules:
		//
		//	A application type * match any type (including */xxx)
		//	type/* match all subtypes of that app type
		//	type/subtype looks for exact match
		//
		if (!wcscmp (pwszAppType, gc_wsz_Star))
		{
			//	This is a wild-card match.  So, S_FALSE is used
			//	to distinguish this from an exact match.
			//
			sc = S_FALSE;
		}
		else if (!wcscmp (pwszAppType, pwszApp))
		{
			if (!wcscmp (pwszSubType, gc_wsz_Star))
			{
				//	Again, a wild-card matching will result in
				//	an S_FALSE return.
				//
				sc = S_FALSE;
			}
			else if (!wcscmp (pwszSubType, pwszType))
			{
				//	Exact matches return S_OK
				//
				sc = S_OK;
			}
		}

		//	If we had any sort of a match by this point, we are
		//	pretty much done.
		//
		if (!FAILED (sc))
			break;
	}

	return sc;
}

/*
 *	ScIsAcceptable()
 *
 *	Purpose:
 *
 *		Checks if a given content type is acceptable for a given request.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the IMethUtil object
 *		pwszContent	[in]  content type to ask about
 *
 *	Returns:
 *
 *		S_OK	- if the request accepts the content type and the header existed
 *		S_FALSE - if the request accepts the content type and the header did not
 *				  exist or was blank, or any wildcard matching occured
 *		E_DAV_RESPONSE_TYPE_UNACCEPTED - if the response type was unaccepted
 *		E_OUTOFMEMORY - if memory allocation failure occurs
 *		
 */
SCODE
ScIsAcceptable (IMethUtil * pmu, LPCWSTR pwszContent)
{
	SCODE sc = S_OK;
	LPCWSTR pwszAccept = NULL;
	CStackBuffer<WCHAR> pwsz;
	UINT cch;
	LPWSTR pwch;

	Assert( pmu );
	Assert( pwszContent );

	//	If the accept header is NULL or empty, then we will gladly
	//	accept any type of file. Do not apply URL conversion rules
	//	for this header.
	//
	pwszAccept = pmu->LpwszGetRequestHeader (gc_szAccept, FALSE);
	if (!pwszAccept || (0 == wcslen(pwszAccept)))
	{
		sc = S_FALSE;
		goto ret;
	}

	//	Make a local copy of the content-type seeing
	//	that we are going to munge while processing
	//
	cch = static_cast<UINT>(wcslen(pwszContent) + 1);
	if (!pwsz.resize(cch * sizeof(WCHAR)))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("ScIsAcceptable() - Failed to allocate memory 0x%08lX\n", sc);
		goto ret;
	}
	memcpy(pwsz.get(), pwszContent, cch * sizeof(WCHAR));

	//	Split the content type into its two components
	//
	for (pwch = pwsz.get(); *pwch && (L'/' != *pwch); pwch++)
		;

	//	If there was app/type pair, we want to skip
	//	the '/' character.  Otherwise, lets just see
	//	What we get.
	//
	if (*pwch != 0)
		*pwch++ = 0;

	//	At this point, rgch refers to the application
	//	portion of the the content type.  pch refers
	//	to the subtype.  Do the search!
	//
	sc = ScCanAcceptContent (pwszAccept, pwsz.get(), pwch);

ret:

	return sc;
}

/*
 *	ScIsContentType()
 *
 *	Purpose:
 *
 *		Check if the specified content type is provide by the client
 *		SCODE is returned as we need to differentiate unexpected
 *		content type and no content type case.
 *
 *	Parameters:
 *
 *		pmu				[in]	pointer to the IMethUtil object
 *		pszType			[in]	the content type expected
 *		pszTypeAnother	[in]	optional, another valid content type
 *
 *	Returns:
 *
 *		S_OK	- if the content type existed, and was one tat we expected
 *		E_DAV_MISSING_CONTENT_TYPE - if the request did not have the content
 *									 type header
 *		E_DAV_UNKNOWN_CONTENT - content type existed but did not match expectation
 *		E_OUTOFMEMORY - if memory allocation failure occurs
 */
SCODE
ScIsContentType (IMethUtil * pmu, LPCWSTR pwszType, LPCWSTR pwszTypeAnother)
{
	SCODE sc = S_OK;
	const WCHAR wchDelimitSet[] = { L';', L'\t', L' ', L'\0' };
	LPCWSTR pwszCntType = NULL;
	CStackBuffer<WCHAR> pwszTemp;
	UINT cchTemp;

	//	Make sure none is passing in null
	//
	Assert(pmu);
	Assert(pwszType);

	//	Get content type. Do not apply URL conversion rules to this header.
	//
	pwszCntType = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);

	//	Error out if the content type does not exist
	//
	if (!pwszCntType)
	{
		sc = E_DAV_MISSING_CONTENT_TYPE;
		DebugTrace("ScIsContentType() - Content type header is missing 0x%08lX\n", sc);
		goto ret;
	}

	//	Find out the single content type in the header
	//
	cchTemp = static_cast<UINT>(wcscspn(pwszCntType, wchDelimitSet));

	//	At least we will find zero terminator. And if that is zero terminator then
	//	the entire string is the content type. Otherwise we copy it and zero terminate.
	//
	if (L'\0' != pwszCntType[cchTemp])
	{
		if (!pwszTemp.resize(CbSizeWsz(cchTemp)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScIsContentType() - Failed to allocate memory 0x%08lX\n", sc);
			goto ret;
		}

		memcpy(pwszTemp.get(), pwszCntType, cchTemp * sizeof(WCHAR));
		pwszTemp[cchTemp] = L'\0';
		pwszCntType = pwszTemp.get();
	}

	//	Now pwszCntType points to the string consisting just of null terminated content type.
	//	Check if it is requested content type.
	//
	if (!_wcsicmp(pwszCntType, pwszType))
		goto ret;

	if (pwszTypeAnother)
	{
		if (!_wcsicmp(pwszCntType, pwszTypeAnother))
			goto ret;
	}
	sc = E_DAV_UNKNOWN_CONTENT;

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\davcom.cpp ===
/*
 *	D A V C O M . C P P
 *
 *	Common routines used by both DAVFS and DAVOWS.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <iiscnfg.h>
#include "instdata.h"
#include <mapicode.h>
#include <mimeole.h>
#include <dav.rh>
#include <ex\rgiter.h>

//	Map last error to HTTP response code --------------------------------------
//
/*
 *	HscFromLastError()
 *
 *	Purpose:
 *
 *		Maps the value returned from GetLastError() to
 *		an HTTP 1.1 response status code.
 *
 *	Parameters:
 *
 *		err			[in]  system error code
 *
 *	Returns:
 *
 *		Mapped system error code
 */
UINT
HscFromLastError (DWORD dwErr)
{
	UINT hsc = HSC_INTERNAL_SERVER_ERROR;

	switch (dwErr)
	{
		//	Successes ---------------------------------------------------------
		//
		case NO_ERROR:

			return HSC_OK;

		//	Parial Success
		//
		case ERROR_PARTIAL_COPY:

			hsc = HSC_MULTI_STATUS;
			break;

		//	Errors ------------------------------------------------------------
		//
		//	Not Implemented
		//
		case ERROR_NOT_SUPPORTED:
		case ERROR_INVALID_FUNCTION:

			hsc = HSC_NOT_IMPLEMENTED;
			break;

		//	Not Found
		//
		case ERROR_FILE_NOT_FOUND:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_INVALID_NAME:

			hsc = HSC_NOT_FOUND;
			break;

		//	Unathorized Access
		//
		case ERROR_ACCESS_DENIED:

			hsc = HSC_UNAUTHORIZED;
			break;

		//	Forbidden access
		//
		case ERROR_DRIVE_LOCKED:
		case ERROR_INVALID_ACCESS:
		case ERROR_INVALID_PASSWORD:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:

			hsc = HSC_FORBIDDEN;
			break;

		//	LOCKING -- this is the error when a resource is
		//	already locked.
		//
		case ERROR_SHARING_VIOLATION:

			hsc = HSC_LOCKED;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_423s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("GetLastError() maps to 423");
			}
#endif	// DBG
			break;

		//	Bad Requests
		//
		case ERROR_BAD_COMMAND:
		case ERROR_BAD_FORMAT:
		case ERROR_INVALID_DRIVE:
		case ERROR_INVALID_PARAMETER:
		case ERROR_NO_UNICODE_TRANSLATION:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Errors generated when the client drops the connection
		//	on us or when we timeout waiting for the client to send
		//	us additional data.  These errors should map to a response
		//	status code of 400 Bad Request even though we can't actually
		//	send back the response.  IIS logs the response status code
		//	and we want to indicate that the error is the client's,
		//	not ours.  K2 logs a 400, so this is for compatibility.
		//
		case WSAECONNRESET:
		case ERROR_NETNAME_DELETED:
		case ERROR_SEM_TIMEOUT:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Method Failure
		//
		case ERROR_DIR_NOT_EMPTY:

			hsc = HSC_METHOD_FAILURE;
			break;

		//	Conflict
		//
		case ERROR_FILE_EXISTS:
		case ERROR_ALREADY_EXISTS:

			hsc = HSC_CONFLICT;
			break;

		//	Unavailable Services (SMB access)
		//
		case ERROR_NETWORK_UNREACHABLE:
		case ERROR_UNEXP_NET_ERR:

			hsc = HSC_SERVICE_UNAVAILABLE;
			break;

		//	Returned by metabase when the server is too busy.
		//	Do NOT map this to HSC_SERVICE_UNAVAILABLE.  The
		//	"too busy" scenario has an IIS custom suberror
		//	which assumes a 500 (not 503) status code.
		//
		case ERROR_PATH_BUSY:

			hsc = HSC_INTERNAL_SERVER_ERROR;
			break;

		//	This error code (ERROR_OUTOFMEMORY) has been added for DAVEX.
		//	The exchange store returns this error when we try to retrieve
		//	the message body property. When we fetch properties on a
		//	message, the store does not return the message body property
		//	if the message body is greater than a certain length. The
		//	general idea is that we don't wan't huge message bodies
		//	returned along with the other properties. We'd much rather fetch
		//	the message body separately.
		//
		case ERROR_OUTOFMEMORY:

			hsc = HSC_INSUFFICIENT_SPACE;
			break;

		default:

			hsc = HSC_INTERNAL_SERVER_ERROR;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_500s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("GetLastError() maps to 500");
			}
#endif	// DBG
			break;
	}

	DebugTrace ("DAV: sys error (%ld) mapped to hsc (%ld)\n", dwErr, hsc);
	return hsc;
}

/*
 *	CSEFromHresult()
 *
 *	Purpose:
 *
 *		Maps an hresult to an IIS custom error suberror
 *
 *	Parameters:
 *
 *		hr			[in]  HRESULT error code
 *
 *	Returns:
 *
 *		Mapped suberror
 */
UINT
CSEFromHresult (HRESULT hr)
{
	UINT cse = CSE_NONE;

	switch (hr)
	{
		//	Read Access Forbidden
		//
		case E_DAV_NO_IIS_READ_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_READ;
			break;

		//	Write Access Forbidden
		//
		case E_DAV_NO_IIS_WRITE_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_WRITE;
			break;

		//	Execute Access Forbidden
		//
		case E_DAV_NO_IIS_EXECUTE_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_EXECUTE;
			break;

		//	Access denied due to ACL
		//
		case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):

			Assert( HscFromHresult(hr) == HSC_UNAUTHORIZED );
			cse = CSE_401_ACL;
			break;

		//	Server too busy
		//
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):

			Assert( HscFromHresult(hr) == HSC_INTERNAL_SERVER_ERROR );
			cse = CSE_500_TOO_BUSY;
			break;
	}

	return cse;
}

/*
 *	HscFromHresult()
 *
 *	Purpose:
 *
 *		Maps an hresult to an HTTP 1.1 response status code.
 *
 *	Parameters:
 *
 *		hr			[in]  HRESULT error code
 *
 *	Returns:
 *
 *		Mapped error code
 */
UINT
HscFromHresult (HRESULT hr)
{
	UINT hsc = HSC_INTERNAL_SERVER_ERROR;

	//	If the facility of the hr is WIN32,
	//	parse out the error bits and send it to HscFromLastError.
	//
	if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
		return HscFromLastError (HRESULT_CODE(hr));

	switch (hr)
	{
		//	Successes ---------------------------------------------------------
		//
		case S_OK:
		case S_FALSE:
		case W_DAV_SCRIPTMAP_MATCH_FOUND:

			return HSC_OK;

		//	No Content
		//
		case W_DAV_NO_CONTENT:

			hsc = HSC_NO_CONTENT;
			break;

		//	Created
		//
		case W_DAV_CREATED:

			hsc = HSC_CREATED;
			break;

		//	Partial content
		//
		case W_DAV_PARTIAL_CONTENT:

			hsc = HSC_PARTIAL_CONTENT;
			break;

		//	Multi-status
		//
		case W_DAV_PARTIAL_SUCCESS:

			hsc = HSC_MULTI_STATUS;
			break;

		//	Moved temporarily
		//
		case W_DAV_MOVED_TEMPORARILY:

			hsc = HSC_MOVED_TEMPORARILY;
			break;

		//	Errors ------------------------------------------------------------
		//
		//	Not modified
		//
		case E_DAV_ENTITY_NOT_MODIFIED:

			hsc = HSC_NOT_MODIFIED;
			break;

		//	Pre-condition failed
		//
		case E_DAV_IF_HEADER_FAILURE:
		case E_DAV_NOTALLOWED_WITHIN_TRANSACTION:
		case E_DAV_OVERWRITE_REQUIRED:
		case E_DAV_CANT_SATISFY_LOCK_REQUEST:
		case E_DAV_NOTIF_SUBID_ERROR:

			hsc = HSC_PRECONDITION_FAILED;
			break;

		//	Not Implemented
		//
		case E_NOTIMPL:
		case E_DAV_NO_PARTIAL_UPDATE:
		case STG_E_UNIMPLEMENTEDFUNCTION:
		case STG_E_INVALIDFUNCTION:
		case E_DAV_STORE_CHECK_FOLDER_NAME:
		case E_DAV_MKCOL_NOT_ALLOWED_ON_NULL_RESOURCE:
		case E_DAV_STORE_SEARCH_UNSUPPORTED:

			hsc = HSC_NOT_IMPLEMENTED;
			break;

		//	Not Found
		//
		case E_DAV_ALT_FILESTREAM:
		case E_DAV_SHORT_FILENAME:
		case MK_E_NOOBJECT:
		case STG_E_FILENOTFOUND:
		case STG_E_INVALIDNAME:
		case STG_E_PATHNOTFOUND:
		case E_DAV_HIDDEN_OBJECT:
		case E_DAV_STORE_BAD_PATH:
		case E_DAV_STORE_NOT_FOUND:

			hsc = HSC_NOT_FOUND;
			break;

		//	Unathorized Access
		//
		case E_DAV_ENTITY_TYPE_CONFLICT:
		case E_ACCESSDENIED:
		case STG_E_ACCESSDENIED:

			hsc = HSC_UNAUTHORIZED;
			break;

		case E_DAV_SMB_PROPERTY_ERROR:
		case E_DAV_NO_IIS_ACCESS_RIGHTS:
		case E_DAV_NO_IIS_READ_ACCESS:
		case E_DAV_NO_IIS_WRITE_ACCESS:
		case E_DAV_NO_IIS_EXECUTE_ACCESS:
		case E_DAV_NO_ACL_ACCESS:
		case E_DAV_PROTECTED_ENTITY:
		case E_DAV_CONFLICTING_PATHS:
		case E_DAV_FORBIDDEN:
		case STG_E_DISKISWRITEPROTECTED:
		case STG_E_LOCKVIOLATION:
		case E_DAV_STORE_MAIL_SUBMISSION:
		case E_DAV_STORE_REVISION_ID_FAILURE:
		case E_DAV_MAIL_SUBMISSION_FORBIDDEN:
		case E_DAV_MKCOL_REVISION_ID_FORBIDDEN:
		case E_ABORT:

			hsc = HSC_FORBIDDEN;
			break;

		case E_DAV_SEARCH_COULD_NOT_RESTRICT:
		case E_DAV_UNSUPPORTED_SQL:
		case MIME_E_NO_DATA:			//	empty 822 message, returned from IMail. It is nothing wrong with
										//	request that attempts to create empty message. Semantics are wrong.

			hsc = HSC_UNPROCESSABLE;
			break;

		//	LOCKING errors when a resource is already locked.
		//
		case E_DAV_LOCKED:
		case STG_E_SHAREVIOLATION:

			hsc = HSC_LOCKED;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_423s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("HRESULT maps to 423");
			}
#endif	// DBG
			break;

		//	Bad Requests
		//
		case E_DAV_EMPTY_FIND_REQUEST:
		case E_DAV_EMPTY_PATCH_REQUEST:
		case E_DAV_INCOMPLETE_SQL_STATEMENT:
		case E_DAV_INVALID_HEADER:
		case E_DAV_LOCK_NOT_FOUND:
		case E_DAV_MALFORMED_PATH:
		case E_DAV_METHOD_FAILURE_STAR_URL:
		case E_DAV_MISSING_CONTENT_TYPE:
		case E_DAV_NAMED_PROPERTY_ERROR:
		case E_DAV_NO_DESTINATION:
		case E_DAV_NO_QUERY:
		case E_DAV_PATCH_TYPE_MISMATCH:
		case E_DAV_READ_REQUEST_TIMEOUT:
		case E_DAV_SEARCH_SCOPE_ERROR:
		case E_DAV_UNEXPECTED_TYPE:
		case E_DAV_XML_PARSE_ERROR:
		case E_DAV_XML_BAD_DATA:
		case E_INVALIDARG:
		case MK_E_NOSTORAGE:
		case MK_E_SYNTAX:
		case STG_E_INVALIDPARAMETER:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Length required
		//
		case E_DAV_MISSING_LENGTH:

			hsc = HSC_LENGTH_REQUIRED;
			break;

		//	Unknown content-types
		//
		case E_DAV_UNKNOWN_CONTENT:

			hsc = HSC_UNSUPPORTED_MEDIA_TYPE;
			break;

		//	Content errors
		//
		case E_DAV_BASE64_ENCODING_ERROR:
		case E_DAV_RESPONSE_TYPE_UNACCEPTED:

			hsc = HSC_NOT_ACCEPTABLE;
			break;

		//	Bad Gateway
		//
		case E_DAV_BAD_DESTINATION:
		case W_DAV_SPANS_VIRTUAL_ROOTS:
		case E_DAV_STAR_SCRIPTMAPING_MISMATCH:

			hsc = HSC_BAD_GATEWAY;
			break;

		//	Methods not allowed
		//
		case E_DAV_COLLECTION_EXISTS:
		case E_DAV_VOLUME_NOT_NTFS:
		case E_NOINTERFACE:
		case E_DAV_STORE_ALREADY_EXISTS:
		case E_DAV_MKCOL_OBJECT_ALREADY_EXISTS:

			hsc = HSC_METHOD_NOT_ALLOWED;
			break;

		//	Conflict
		//
		case E_DAV_NONEXISTING_PARENT:
		case STG_E_FILEALREADYEXISTS:
		case E_DAV_CONFLICT:
		case E_DAV_NATIVE_CONTENT_NOT_MAPI:

			hsc = HSC_CONFLICT;
			break;

		//	Unsatisfiable byte range requests
		//
		case E_DAV_RANGE_NOT_SATISFIABLE:

			hsc = HSC_RANGE_NOT_SATISFIABLE;
			break;

		//	424 Method Failure
		//
		case E_DAV_STORE_COMMIT_GOP:

			hsc = HSC_METHOD_FAILURE;
			break;

		case E_DAV_IPC_CONNECT_FAILED:
		case E_DAV_EXPROX_CONNECT_FAILED:
		case E_DAV_MDB_DOWN:
		case E_DAV_STORE_MDB_UNAVAILABLE:

			hsc = HSC_SERVICE_UNAVAILABLE;
			break;

		case E_DAV_RSRC_INSUFFICIENT_BUFFER:

			hsc = HSC_INSUFFICIENT_SPACE;
			break;

		default:
		case E_DAV_METHOD_FORWARDED:
		case E_DAV_GET_DB_HELPER_FAILURE:
		case E_DAV_NOTIF_POLL_FAILURE:

			hsc = HSC_INTERNAL_SERVER_ERROR;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_500s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("HRESULT maps to 500");
			}
#endif	// DBG
			break;
	}

	DebugTrace ("DAV: HRESULT error (0x%08x) mapped to hsc (%ld)\n", hr, hsc);
	return hsc;
}

BOOL
FWchFromHex (LPCWSTR pwsz, WCHAR * pwch)
{
	INT iwch;
	WCHAR wch;
	WCHAR wchX = 0;

	Assert (pwch);
	for (iwch = 0; iwch < 2; iwch++)
	{
		//	Shift whats there up a diget
		//
		wchX = (WCHAR)(wchX << 4);

		//	Parse the next char
		//
		wch = pwsz[iwch];

		//	Make sure we don't exceed the sequence.
		//
		if (!wch)
			return FALSE;

#pragma warning(disable:4244)
		if ((wch >= L'0') && (wch <= L'9'))
			wchX += (WCHAR)(wch - L'0');
		else if ((wch >= L'A') && (wch <= L'F'))
			wchX += (WCHAR)(wch - L'A' + 10);
		else if ((wch >= L'a') && (wch <= L'f'))
			wchX += (WCHAR)(wch - L'a' + 10);
		else
			return FALSE;	// bad sequence
#pragma warning(default:4244)
	}

	*pwch = wchX;
	return TRUE;
}

//	Byte Range Checking and Header Emission -----------------------------------------------------------
//
/*
 *	ScProcessByteRanges()
 *
 *	Purpose:
 *
 *		Helper function used to process byte ranges and emit the header
 *		information for GET responses.
 *
 *	Parameters:
 *
 *		pmu				[in]		pointer to the method util obj
 *		pwszPath		[in]		path of request entity
 *		dwSizeLow		[in]		size of get request entity (low byte)
 *		dwSizeHigh		[in]		size of get request entity (high byte)
 *		pByteRange		[out]		given a pointer to a RangeIter obj, the
 *									function fills in byte range information
 *									if the request contains a Range header
 *		pszEtagOverride	[in, opt.]	pointer to an Etag, overrides the Etag
 *										generated from the last modification
 *										time
 *		pftOverride		[in, opt.]	pointer to a FILETIME structure, overrides
 *										call to FGetLastModTime
 *
 *	Returns: SCODE
 *
 *		S_OK indicates success(ordinary response).
 *		W_DAV_PARTIAL_CONTENT (206) indicates success(byte range response).
 *		E_DAV_RANGE_NOT_SATISFIABLE (416) indicates all of requested
 *				byte ranges were beyond the size of the entity.
 */
SCODE
ScProcessByteRanges (IMethUtil * pmu,
					 LPCWSTR pwszPath,
					 DWORD dwSizeLow,
					 DWORD dwSizeHigh,
					 CRangeParser * pByteRange)
{
	FILETIME ft;
	WCHAR pwszEtag[CCH_ETAG];

	//	Check the validity of the inputs
	//
	Assert (pmu);
	Assert (pwszPath);
	Assert (pByteRange);

	SideAssert(FGetLastModTime (pmu, pwszPath, &ft));
	SideAssert(FETagFromFiletime (&ft, pwszEtag));

	return ScProcessByteRangesFromEtagAndTime (pmu,
											   dwSizeLow,
											   dwSizeHigh,
											   pByteRange,
											   pwszEtag,
											   &ft);
}

SCODE
ScProcessByteRangesFromEtagAndTime (IMethUtil * pmu,
									DWORD dwSizeLow,
									DWORD dwSizeHigh,
									CRangeParser *pByteRange,
									LPCWSTR pwszEtag,
									FILETIME * pft)
{
	SCODE	sc = S_OK;
	LPCWSTR	pwszRangeHeader;
	WCHAR	rgwchBuf[128] = L"";

	//	Check the validity of the inputs
	//
	Assert (pmu);
	Assert (pByteRange);
	Assert (pwszEtag);
	Assert (pft);

	//	Check to see if we have a Range header and the If-Range condition( if
	//	there is one) is satisfied. Do not apply URL conversion rules while
	//	fetching the header.
	//
	pwszRangeHeader = pmu->LpwszGetRequestHeader (gc_szRange, FALSE);
	if ( pwszRangeHeader && !FAILED (ScCheckIfRangeHeaderFromEtag (pmu,
																   pft,
																   pwszEtag)) )
	{
		//	We have no means of handling byte ranges for files larger than 4GB,
		//	due to limitations of _HSE_TF_INFO that takes DWORD values for sizes
		//	and offsets. So if we are geting byterange request on that large file
		//	just fail out - with some error that maps to 405 Method Not Allowed
		//
		if (dwSizeHigh)
		{
			sc = E_NOINTERFACE;
			goto ret;
		}

		//	OK, we have a byte range. Parse the byte ranges from the header.
		//	The function takes the size of the request entity to make
		//	sure the byte ranges are consistent with the entity size (no byte
		//	ranges beyond the size).
		//
		sc = pByteRange->ScParseByteRangeHdr(pwszRangeHeader, dwSizeLow);

		switch (sc)
		{
			case W_DAV_PARTIAL_CONTENT:

				//	We have a byte range (206 partial content). Send back
				//	this return code.
				//
				break;

			case E_DAV_RANGE_NOT_SATISFIABLE:

				//	We don't have any satisfiable ranges (all our ranges had a
				//	start byte greater than the size of the file or they
				//	requested a zero-sized range). Our behaviour here depends on
				//	the presence of the If-Range header.
				//	If we have an If-Range header, return the default response
				//	S_OK (the entire file). If we don't have one,
				//	we need to return a 416 (Requested Range Not Satisfiable).
				//		Would look like it is more performant to ask for the skinny
				//	version here, but at this moment wide header value is already
				//	cached so it makes no difference. And do not apply URL conversion
				//	rules to the header.
				//
				if (!pmu->LpwszGetRequestHeader(gc_szIf_Range, FALSE))
				{
					//	NO If-Range header found.
					//	Set the Content-Range header to say "bytes *"
					//	(meaning the whole file was sent).
					//
					wsprintfW(rgwchBuf, L"%ls */%d", gc_wszBytes, dwSizeLow);
					pmu->SetResponseHeader(gc_szContent_Range, rgwchBuf);

					//	Send back this return code (E_DAV_RANGE_NOT_SATISFIABLE).
					//
				}
				else
				{
					//	We DO have an If-Range header.
					//	Return 200 OK, and send the whole file.
					//
					sc = S_OK;
				}
				break;

			case E_INVALIDARG:

				//	If the parsing function returned S_FALSE we have a syntax
				//	error, so we ignore the Range header and send the entire
				//	file/stream.
				//	Reset our return code to S_OK.
				//
				sc = S_OK;
				break;

			default:

				//	Unrecognizable error. We should never see anything but
				//	the three values in the case statement. Assert (TrapSz),
				//	and return this sc.
				//
				break;
		}
	}

	//	Either we didn't have a Range header or the If-Range condition
	//	was false. Its an ordinary GET and we need to send the entire
	//	file. Our response (S_OK) is already set by default.
	//

ret:

	return sc;
}


//	Generating a boundary for multipartpart mime like responses------------------
//
/*
 *	GenerateBoundary()
 *
 *	Purpose:
 *
 *		Helper function used to generate a separator boundary for multipart
 *		mime like responses
 *
 *	Parameters:
 *
 *		rgwchBoundary	[out]		boundary for multipart responses
 *		cch				[in]		size of the rgwchBoundary parameter
 */
void
GenerateBoundary(LPWSTR rgwchBoundary, UINT cch)
{
	UINT cchMin;
	UINT iIter;

	//	Assert that we've been given a buffer of at least size 2 (a minimum
	//	null terminated boundary of one byte).
	//
	Assert (cch > 1);
	Assert (rgwchBoundary);

	//	The boundary size is the smaller of the size passed in to us or the default
	//
	cchMin = min(gc_ulDefaultBoundarySz, cch - 1);

	//	We are going to randomly use characters from the boundary alphabet.
	//	The rand() function is seeded by the current time
	//
	srand(GetTickCount());

	//	Now to generate the actual boundary
	//
	for (iIter = 0; iIter < cchMin; iIter++)
	{
		rgwchBoundary[iIter] = gc_wszBoundaryAlphabet[ rand() % gc_ulAlphabetSz ];
	}
	rgwchBoundary[cchMin] = L'\0';
}


//	Non-Async IO on Top of Overlapped Files -----------------------------------
//
BOOL
ReadFromOverlapped (HANDLE hf,
	LPVOID pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl)
{
	Assert (povl);

	//	Start reading
	//
	if ( !ReadFile( hf, pvBuf, cbToRead, pcbRead, povl ) )
	{
		if ( GetLastError() == ERROR_IO_PENDING )
		{
			if ( !GetOverlappedResult( hf, povl, pcbRead, TRUE ) )
			{
				if ( GetLastError() != ERROR_HANDLE_EOF )
				{
					DebugTrace( "ReadFromOverlapped(): "
								"GetOverlappedResult() failed (%d)\n",
								GetLastError() );

					return FALSE;
				}
			}
		}
		else if ( GetLastError() != ERROR_HANDLE_EOF )
		{
			DebugTrace( "ReadFromOverlapped(): "
						"ReadFile() failed (%d)\n",
						GetLastError() );

			return FALSE;
		}
	}
	return TRUE;
}

BOOL
WriteToOverlapped (HANDLE hf,
	const void * pvBuf,
	ULONG cbToWrite,
	ULONG * pcbWritten,
	OVERLAPPED * povl)
{
	Assert (povl);

	//	Start writting
	//
	if ( !WriteFile( hf, pvBuf, cbToWrite, pcbWritten, povl ) )
	{
		if ( GetLastError() == ERROR_IO_PENDING )
		{
			if ( !GetOverlappedResult( hf, povl, pcbWritten, TRUE ) )
			{
				if ( GetLastError() != ERROR_HANDLE_EOF )
				{
					DebugTrace( "WriteToOverlapped(): "
								"GetOverlappedResult() failed (%d)\n",
								GetLastError() );

					return FALSE;
				}
			}
		}
		else if ( GetLastError() != ERROR_HANDLE_EOF )
		{
			DebugTrace( "WriteToOverlapped(): "
						"WriteFile() failed (%d)\n",
						GetLastError() );

			return FALSE;
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\custerr.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CUSTERR.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "custerr.h"
#include "content.h"


//	========================================================================
//
//	CLASS IError
//
//	Interface class for error response handler classes.  An error response
//	handler class implements one virtual method, DoResponse(), which
//	handles the error response.
//
class IError : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	IError& operator=(const IError&);
	IError( const IError& );

protected:
	IError() {}

public:
	//	CREATORS
	//
	virtual ~IError() = 0;

	//	ACCESSORS
	//
	virtual void DoResponse( IResponse& response , const IEcb& ecb ) const = 0;

};

//	------------------------------------------------------------------------
//
//	IError::~IError()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IError::~IError() {}

//	------------------------------------------------------------------------
//
//	BOOL AddResponseBodyFromFile( IResponse& response, LPCSTR lpszFilePath )
//
//	Utility function to add the file's contents to the response's body
//
static BOOL AddResponseBodyFromFile( IResponse& response, LPCWSTR pwszFilePath )
{
	BOOL fReturn = FALSE;
	auto_ref_handle	hf;

	//
	//	Add the file to the response body
	//
	if ( hf.FCreate(
			CreateFileW( pwszFilePath,
						 GENERIC_READ,
						 FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL,
						 OPEN_EXISTING,
						 FILE_ATTRIBUTE_NORMAL |
						 FILE_FLAG_SEQUENTIAL_SCAN |
						 FILE_FLAG_OVERLAPPED,
						 NULL )) )
	{
		response.AddBodyFile(hf);

		//	Set the response content type to an appropriate value based
		//	on the file's extension.
		//
		UINT cchContentType = 60;
		CStackBuffer<WCHAR> pwszContentType(cchContentType * sizeof(WCHAR));
		if (!pwszContentType.get())
			return FALSE;

		if ( !FGetContentTypeFromPath( *response.GetEcb(),
									   pwszFilePath,
									   pwszContentType.get(),
									   &cchContentType))
		{
			if (!pwszContentType.resize(cchContentType * sizeof(WCHAR)))
				return FALSE;

			if ( !FGetContentTypeFromPath( *response.GetEcb(),
										   pwszFilePath,
										   pwszContentType.get(),
										   &cchContentType))
			{
				//
				//	If we can't get a reasonable value from the mime map
				//	then use a reasonable default: application/octet-stream
				//
				Assert (pwszContentType.celems() >
						CchConstString(gc_wszAppl_Octet_Stream));

				wcscpy (pwszContentType.get(), gc_wszAppl_Octet_Stream);
			}
		}
		response.SetHeader( gc_szContent_Type, pwszContentType.get() );
		fReturn = TRUE;
	}

	return fReturn;
}

//	========================================================================
//
//	CLASS CURLError
//
//	URL error response handler class.  Handles an error response by
//	forwarding to another URL.
//
class CURLError : public IError
{
	//
	//	The URL
	//
	LPCWSTR m_pwszURL;

	//	NOT IMPLEMENTED
	//
	CURLError& operator=(const CURLError&);
	CURLError(const CURLError&);

public:
	//	CREATORS
	//
	CURLError( LPCWSTR pwszURL ) : m_pwszURL(pwszURL) {}

	//	ACCESSORS
	//
	void DoResponse( IResponse& response, const IEcb& ecb ) const;
};

//	------------------------------------------------------------------------
//
//	CURLError::DoResponse()
//
//	Handle the error response by forwarding to the configured URL.
//
void
CURLError::DoResponse( IResponse& response, const IEcb& ecb ) const
{
	SCODE sc = S_OK;

	//	The first boolean flag is for keeping the query string
	//	and the second flag indicates that we are doing CustomError
	//	processing.
	//
	sc = response.ScForward( m_pwszURL, TRUE , TRUE );
	if (FAILED(sc))
	{
		//	The child execute failed - one reason is that the URL is a simple
		//	file URL. Try mapping the URL to file..
		//
		if ( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == sc )
		{
			HSE_UNICODE_URL_MAPEX_INFO mi;

			//	Obtain the file path and send the file in the body
			//
			sc = ecb.ScReqMapUrlToPathEx(m_pwszURL,
										 NULL,
										 &mi);
			if (FAILED(sc))
			{
				//	We ran into a case where the CE URL resource itself is not
				//	found. When we are ready to send response, this will mean
				//	an empty body. Appropriate body will be default generated there.
				//
				DebugTrace("CURLError::DoResponse() - IEcb::ScSSFReqMapUrlToPathEx() failed 0x%08lX\n", sc);
			}
			else
			{
				AddResponseBodyFromFile( response, mi.lpszPath );
			}
		}
	}

	return;
}

//	========================================================================
//
//	CLASS CFileError
//
//	File error response handler class.  Handles an error response by
//	adding a file containing response body content to the response body.
//
class CFileError : public IError
{
	//
	//	The filename
	//
	LPCWSTR m_pwszFileName;

	//	NOT IMPLEMENTED
	//
	CFileError& operator=(const CFileError&);
	CFileError(const CFileError&);

public:
	//	CREATORS
	//
	CFileError( LPCWSTR pwszFileName ) : m_pwszFileName(pwszFileName) {}


	//	ACCESSORS
	//
	void DoResponse( IResponse& response, const IEcb& ) const;
};

//	------------------------------------------------------------------------
//
//	CFileError::DoResponse()
//
//	Handle the error response by setting the response body content
//	to the contents of the configured file.
//
void
CFileError::DoResponse( IResponse& response, const IEcb& ) const
{
	AddResponseBodyFromFile( response, m_pwszFileName );
}


//	========================================================================
//	class CEKey
//		Key class for custom error keys that can be compared with ==.
//
#pragma warning(disable:4201) // Nameless struct/union
class CEKey
{
private:
	union
	{
		DWORD m_dw;
		struct
		{
			USHORT m_iStatusCode;
			USHORT m_iSubError;
		};
	};

public:
	CEKey (USHORT iStatusCode,
		   USHORT iSubError) :
		m_iStatusCode(iStatusCode),
		m_iSubError(iSubError)
	{
	}

	DWORD Dw() const
	{
		return m_dw;
	}

	int CEKey::hash (const int rhs) const
	{
		return (m_dw % rhs);
	}

	bool CEKey::isequal (const CEKey& rhs) const
	{
		return (rhs.m_dw == m_dw);
	}
};
#pragma warning(default:4201) // Nameless struct/union

//	========================================================================
//
//	CLASS CCustomErrorMap
//
//	Custom error list class.  Each instance of this class encapsulates a
//	set of custom error mappings.  Each mapping maps from a status code
//	and "suberror" (as defined by IIS) to an error response handling object.
//
//	The list is configured, via FInit(), from a set of null-terminated
//	string of the following form:
//
//		"<error>,<suberror|*>,<"FILE"|"URL">,<filename|URL>"
//
//	For example, the string "404,*,FILE,C:\WINNT\help\common\404b.htm" would
//	translate to a mapping from "404,*" to a CFileError(C:\WINNT\htlp\common\404b.htm)
//	object.
//
class CCustomErrorMap : public ICustomErrorMap
{
	//
	//	A cache of status-code-plus-sub-error strings to
	//	error object mappings
	//
	CCache<CEKey, auto_ref_ptr<IError> > m_cache;

	//	NOT IMPLEMENTED
	//
	CCustomErrorMap& operator=(const CCustomErrorMap&);
	CCustomErrorMap(const CCustomErrorMap&);

public:
	//	CREATORS
	//
	CCustomErrorMap()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();

		//
		//$COM refcounting
		//
		m_cRef = 1;
	}

	//	MANIPULATORS
	//
	BOOL FInit( LPWSTR pwszCustomErrorMappings );

	//	ACCESSORS
	//
	BOOL FDoResponse( IResponse& response, const IEcb& ecb ) const;
};

//	------------------------------------------------------------------------
//
//	CCustomErrorMap::FInit()
//
//	Initialize a custom error map from a sequence of comma-delimited mapping
//	strings.
//
//	Disable warnings about conversion from INT to USHORT losing data for
//	this function only.  The conversion is for the status code and suberror
//	which we Assert() are in the range of a USHORT.
//
BOOL
CCustomErrorMap::FInit( LPWSTR pwszCustomErrorMappings )
{
	Assert( pwszCustomErrorMappings != NULL );


	//
	//	Parse through the error list and build up the cache.
	//	(Code mostly copied from IIS' W3_METADATA::BuildCustomErrorTable())
	//
	//	Each mapping is a string of the form:
	//
	//		"<error>,<suberror|*>,<"FILE"|"URL">,<filename|URL>"
	//
	//	Note that if any of the mappings is invalid we fail the whole call.
	//	This is consistent with IIS' behavior.
	//
	for ( LPWSTR pwszMapping = pwszCustomErrorMappings; *pwszMapping; )
	{
		enum {
			ISZ_CE_STATCODE = 0,
			ISZ_CE_SUBERROR,
			ISZ_CE_TYPE,
			ISZ_CE_PATH,
			ISZ_CE_URL = ISZ_CE_PATH, // alias
			CSZ_CE_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CE_FIELDS];
		INT iStatusCode;
		INT iSubError = 0;

		auto_ref_ptr<IError> pError;
		UINT cchMapping;

		Assert( !IsBadWritePtr(pwszMapping, wcslen(pwszMapping) * sizeof(WCHAR)) );

		//
		//	Digest the metadata
		//
		if ( !FParseMDData( pwszMapping,
							rgpwsz,
							CSZ_CE_FIELDS,
							&cchMapping ) )
			return FALSE;

		//
		//	Verify that the first field is a valid status code
		//
		iStatusCode = _wtoi(rgpwsz[ISZ_CE_STATCODE]);
		if ( iStatusCode < 400 || iStatusCode > 599 )
			return FALSE;

		//
		//	Verify that the second field is a valid suberror.  A valid
		//	suberror is either a "*" or an integer.  Note: IIS'
		//	BuildCustomErrorTable() only checks whether the first
		//	character is a '*' so we do the same here.
		//
		if ( *rgpwsz[ISZ_CE_SUBERROR] != L'*' )
		{
			iSubError = _wtoi(rgpwsz[ISZ_CE_SUBERROR]);
			if ( iSubError < 0 || iSubError > _UI16_MAX )
				return FALSE;
		}

		//
		//	Verify that the third field is a valid type and
		//	create the appropriate (file or URL) error object.
		//
		if ( !_wcsicmp(rgpwsz[ISZ_CE_TYPE], L"FILE") )
		{
			pError = new CFileError(rgpwsz[ISZ_CE_PATH]);
		}
		else if ( !_wcsicmp(rgpwsz[ISZ_CE_TYPE], L"URL") )
		{
			pError = new CURLError(rgpwsz[ISZ_CE_URL]);
		}
		else
		{
			return FALSE;
		}

		//
		//	Add the error object to the cache, keyed by the error/suberror.
		//
		(void)m_cache.FSet( CEKey(static_cast<USHORT>(iStatusCode),
								  static_cast<USHORT>(iSubError)),
							pError );

		//
		//	Get the next mapping
		//
		pwszMapping += cchMapping;
	}

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CCustomErrorMap::FDoResponse()
//
//	Look for a custom error response mapping for the particular response
//	error status and, if one exists, apply it to the response.
//
//	Returns TRUE if an error mapping exists, FALSE if not.
//
BOOL
CCustomErrorMap::FDoResponse( IResponse& response, const IEcb& ecb ) const
{
	auto_ref_ptr<IError> pError;

	Assert( response.DwStatusCode() <= _UI16_MAX );
	Assert( response.DwSubError() <= _UI16_MAX );

	//
	//	Lookup the error/suberror pair in the cache
	//
	if ( m_cache.FFetch( CEKey(static_cast<USHORT>(response.DwStatusCode()),
							   static_cast<USHORT>(response.DwSubError())),
						 &pError ) )
	{
		pError->DoResponse( response, ecb );
		return TRUE;
	}

	return FALSE;
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	FSetCustomErrorResponse()
//
BOOL
FSetCustomErrorResponse( const IEcb& ecb,
						 IResponse& response )
{
	const ICustomErrorMap * pCustomErrorMap;

	pCustomErrorMap = ecb.MetaData().GetCustomErrorMap();
	return pCustomErrorMap && pCustomErrorMap->FDoResponse(response, ecb);
}

//	------------------------------------------------------------------------
//
//	NewCustomErrorMap()
//
ICustomErrorMap *
NewCustomErrorMap( LPWSTR pwszCustomErrorMappings )
{
	auto_ref_ptr<CCustomErrorMap> pCustomErrorMap;

	pCustomErrorMap.take_ownership(new CCustomErrorMap());

	if ( pCustomErrorMap->FInit(pwszCustomErrorMappings) )
		return pCustomErrorMap.relinquish();

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\emitting.cpp ===
/*
 *	E M I T T I N G . C P P
 *
 *	Common response bit emitters
 *
 *	Stolen from the IIS5 project 'iis5\svcs\iisrlt\string.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <dav.rh>

/*
 *	EmitLocation()
 *
 *	Purpose:
 *
 *		Helper function used to emit the location information
 *
 *	Parameters:
 *
 *		pszHeader	[in]  name of header to set
 *		pszURI		[in]  destination URI
 *		fCollection [in]  is resource a collection...
 *
 *	Note:
 *		This prefix the relative URI with the local server to get the
 *		absolute URI. this is OK as now all operations are within one
 *		vroot.
 *		Later, if we are able to COPY/MOVE across servers, then this
 *		function is not enough.
 */
void __fastcall
CMethUtil::EmitLocation (
	/* [in] */ LPCSTR pszHeader,
	/* [in] */ LPCWSTR pwszURI,
	/* [in] */ BOOL fCollection)
{
	auto_heap_ptr<CHAR> pszEscapedURI;
	BOOL fTrailing;
	CStackBuffer<WCHAR,MAX_PATH> pwsz;
	LPCWSTR pwszPrefix;
	LPCWSTR pwszServer;
	SCODE sc = S_OK;
	UINT cch;
	UINT cchURI;
	UINT cchServer;
	UINT cchPrefix;

	Assert (pszHeader);
	Assert (pwszURI);
	Assert (pwszURI == PwszUrlStrippedOfPrefix(pwszURI));

	//	Calc the length of the URI once and only once
	//
	cchURI = static_cast<UINT>(wcslen(pwszURI));

	//	See if it has a trailing slash
	//
	fTrailing = !!(L'/' == pwszURI[cchURI - 1]);

	//	See if it is fully qualified
	//
	cchPrefix = m_pecb->CchUrlPrefixW (&pwszPrefix);

	//	Get the server to use: passed in or from ECB
	//
	cchServer = m_pecb->CchGetServerNameW(&pwszServer);

	//	We know the size of the prefix, the size of the server
	//	and the size of the url.  All we need to make sure of is
	//	that there is space for a trailing slash and a terminator
	//
	cch = cchPrefix + cchServer + cchURI + 1 + 1;
	if (!pwsz.resize(cch * sizeof(WCHAR)))
		return;

	memcpy (pwsz.get(), pwszPrefix, cchPrefix * sizeof(WCHAR));
	memcpy (pwsz.get() + cchPrefix, pwszServer, cchServer * sizeof(WCHAR));
	memcpy (pwsz.get() + cchPrefix + cchServer, pwszURI, (cchURI + 1) * sizeof(WCHAR));
	cchURI += cchPrefix + cchServer;

	//	Ensure proper termination
	//
	if (fTrailing != !!fCollection)
	{
		if (fCollection)
		{
			pwsz[cchURI] = L'/';
			cchURI++;
			pwsz[cchURI] = L'\0';
		}
		else
		{
			cchURI--;
			pwsz[cchURI] = L'\0';
		}
	}
	pwszURI = pwsz.get();

	//	Make a wire url out of it.
	//
	sc = ScWireUrlFromWideLocalUrl (cchURI, pwszURI, pszEscapedURI);
	if (FAILED(sc))
	{
		//	If we can't make a wire URL for whatever reason
		//	we just won't emit a Location: header.  Oh well.
		//	It's the best we can do at this point.
		//
		return;
	}

	//	Add the appropriate header
	//
	m_presponse->SetHeader(pszHeader, pszEscapedURI.get(), FALSE);
}

/*
 *	EmitLastModified()
 *
 *	Purpose:
 *
 *		Helper function used to emit the last modified information
 *
 *	Parameters:
 *
 *		pft			[in]  last mod time
 */
void __fastcall
CMethUtil::EmitLastModified (
	/* [in] */ FILETIME * pft)
{
	SYSTEMTIME st;
	WCHAR rgwch[80];

	FileTimeToSystemTime (pft, &st);
	(VOID) FGetDateRfc1123FromSystime(&st, rgwch, CElems(rgwch));
	SetResponseHeader (gc_szLast_Modified, rgwch);
}


/*
 *	EmitCacheControlAndExpires()
 *
 *	Purpose:
 *
 *		Helper function used to emit the Cache-Control and Expires information
 *
 *	Parameters:
 *
 *		pszURI		[in]  string representing the URI for the entity to have
 *						  information generated for
 *
 *	Comments:  From the HTTP 1.1 specification, draft revision 5.
 *		13.4 Response Cachability
 *		... If there is neither a cache validator nor an explicit expiration time
 *		associated with a response, we do not expect it to be cached, but
 *		certain caches MAY violate this expectation (for example, when little
 *		or no network connectivity is available). A client can usually detect
 *		that such a response was taken from a cache by comparing the Date
 *		header to the current time.
 *			Note that some HTTP/1.0 caches are known to violate this
 *			expectation without providing any Warning.
 */
VOID __fastcall
CMethUtil::EmitCacheControlAndExpires(
	/* [in] */ LPCWSTR pwszURI)
{
	//$$BUGBUG: $$CAVEAT:  There is an inherent problem here.  We get the current
	//	system time, do some processing, and then eventually the response gets sent
	//	from IIS, at which time the Date header gets added.  However, in the case
	//	where the expiration time is 0, the Expires header should MATCH the Date
	//	header EXACTLY.  We cannot guarantee this.
	//

	static const __int64 sc_i64HundredNanoSecUnitsPerSec =
		1    *	//	second
		1000 *	//	milliseconds per second
		1000 *	//	microseconds per millisecond
		10;		//	100 nanosecond units per microsecond.

	SCODE sc;
	FILETIME ft;
	FILETIME ftExpire;
	SYSTEMTIME stExpire;
	__int64 i64ExpirationSeconds = 0;
	WCHAR rgwchExpireTime[80] = L"\0";
	WCHAR rgwchMetabaseExpireTime[80] = L"\0";
	UINT cchMetabaseExpireTime = CElems(rgwchMetabaseExpireTime);

	sc = ScGetExpirationTime(pwszURI,
							 rgwchMetabaseExpireTime,
							 &cchMetabaseExpireTime);

	if (FAILED(sc))
	{
		//	At this point, we cannot emit proper Cache-Control and Expires headers,
		//	so we do not emit them at all.  Please see the comment in this function's
		//	description above regarding non-emission of these headers.
		//
		DebugTrace("CMethUtil::EmitCacheControlAndExpires() - ScGetExpirationTime() error getting expiration time %08x\n", sc);

		//	With a buffer of 80 chars. long we should never have this problem.
		//	An HTTP date + 3 chars is as long as we should ever have to be.
		//
		Assert(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != sc);
		return;
	}

	//	The metabase expiration string looks like:
	//	"S, HTTP DATE" --- Expires at a specific date/time.
	//	"D, 0xHEXNUM" --- Expires after a certain number of seconds.
	//	"" --- No expiration.
	//
	switch (rgwchMetabaseExpireTime[0])
	{
		default:
			Assert(L'\0' == rgwchMetabaseExpireTime[0]);
			return;

		case L'S':
		case L's':
			if (SUCCEEDED(HrHTTPDateToFileTime(&(rgwchMetabaseExpireTime[3]),
											   &ftExpire)))
			{
				//	Set our Expires header.
				//
				SetResponseHeader(gc_szExpires, &(rgwchMetabaseExpireTime[3]));

				GetSystemTimeAsFileTime(&ft);
				if (CompareFileTime(&ft, &ftExpire) >= 0)
				{
					//	If we already expired, we want cache-control to be no-cache.  This
					//	will do that.
					//
					i64ExpirationSeconds = 0;
				}
				else
				{
					i64ExpirationSeconds = ((FileTimeCastToI64(ftExpire) -
											 FileTimeCastToI64(ft)) /
											sc_i64HundredNanoSecUnitsPerSec);
				}
			}
			else
			{
				//	At this point, we cannot emit proper Cache-Control and Expires headers,
				//	so we do not emit them at all.  Please see the comment in this function's
				//	description above regarding non-emission of these headers.
				//
				DebugTrace("EmitCacheControlAndExpires: Failed to convert HTTP date to FILETIME.\n");
				return;
			}
			break;

		case L'D':
		case L'd':

			BOOL fRetTemp;

			//	Set our Expires header.
			//
			SetResponseHeader (gc_szExpires, rgwchExpireTime);

			i64ExpirationSeconds = wcstoul(&(rgwchMetabaseExpireTime[3]), NULL, 16);

			GetSystemTimeAsFileTime(&ft);
			FileTimeCastToI64(ft) = (FileTimeCastToI64(ft) +
									 (i64ExpirationSeconds * sc_i64HundredNanoSecUnitsPerSec));

			if (!FileTimeToSystemTime (&ft, &stExpire))
			{
				//	At this point, we cannot emit proper Cache-Control and Expires headers,
				//	so we do not emit them at all.  Please see the comment in this function's
				//	description above regarding non-emission of these headers.
				//
				DebugTrace("EmitCacheControlAndExpires: FAILED to convert file time "
						   "to system time for expiration time.\n");
				return;
			}

			fRetTemp = FGetDateRfc1123FromSystime (&stExpire,
				rgwchExpireTime,
				CElems(rgwchExpireTime));
			Assert(fRetTemp);

			break;
	}

	if (0 == i64ExpirationSeconds)
		SetResponseHeader(gc_szCache_Control, gc_szCache_Control_NoCache);
	else
		SetResponseHeader(gc_szCache_Control, gc_szCache_Control_Private);
}


/*
 *	ScEmitHeader()
 *
 *	Purpose:
 *
 *		Helper function used to emit the header information for
 *		GET/HEAD responses.
 *
 *	Parameters:
 *
 *		pszContent	[in]  string containing content type of resource
 *		pszURI		[optional, in] string containing the URI of the resource
 *		pftLastModification [optional, in] pointer to a FILETIME structure
 *										   representing the last modification
 *										   time for the resource
 *
 *	Returns:
 *
 *		SCODE.  S_OK (0) indicates success.
 */
SCODE __fastcall
CMethUtil::ScEmitHeader (
	/* [in] */ LPCWSTR pwszContent,
	/* [in] */ LPCWSTR pwszURI,
	/* [in] */ FILETIME * pftLastModification)
{
	SCODE sc = S_OK;

	//	In the case where we have a last modification time, we also need a URI.
	//	If we don't have a last modification time, it doesn't matter.  We don't
	//	use the URI anyway in this case.
	//
	Assert(!pftLastModification || pwszURI);

	//	See if the content is acceptable to the client, remembering
	//	that the content type is html for directories.  If we are
	//	in a strict environment and the content is not acceptable,
	//	then return that as an error code.
	//
	Assert (pwszContent);
	if (FAILED (ScIsAcceptable (this, pwszContent)))
	{
		DebugTrace ("Dav: client does not want this content type\n");
		sc = E_DAV_RESPONSE_TYPE_UNACCEPTED;
		goto ret;
	}

	//	Write the common header information, all the calls to
	//	SetResponseHeader() really cannot fail unless there is
	//	a memory error (which will throw!)
	//
	if (*pwszContent)
		SetResponseHeader (gc_szContent_Type, pwszContent);

	//	We support byte ranges for documents but not collections.  We also
	//	only emit Expires and Cache-Control headers for documents but not
	//	collections.
	//
	if (pftLastModification != NULL)
	{
		SetResponseHeader (gc_szAccept_Ranges, gc_szBytes);

		//	While we are processing documents, get the Etag too
		//
		EmitETag (pftLastModification);
		EmitLastModified (pftLastModification);
		EmitCacheControlAndExpires(pwszURI);
	}
	else
		SetResponseHeader (gc_szAccept_Ranges, gc_szNone);

ret:
	return sc;
}


//	Allow header processing ---------------------------------------------------
//
void
CMethUtil::SetAllowHeader (
	/* [in] */ RESOURCE_TYPE rt)
{
	//	We need to check if we have write permission on the directory.  If not, we should
	//	not allow PUT, DELETE, MKCOL, MOVE, or PROPPATCH.
	//
	BOOL fHaveWriteAccess = !(E_DAV_NO_IIS_WRITE_ACCESS ==
							  ScIISCheck(LpwszRequestUrl(),
										 MD_ACCESS_WRITE));

	//	The gc_szDavPublic header MUST list all the possible verbs,
	//	so that's the longest Allow: header we'll ever have.
	//	NOTE: sizeof includes the trailing NULL!
	//
	CStackBuffer<CHAR,MAX_PATH> psz(gc_cbszDavPublic);

	//	Setup the minimal set of methods
	//
	strcpy (psz.get(), gc_szHttpBase);

	//	If we have write access, then we can delete.
	//
	if (fHaveWriteAccess)
		strcat (psz.get(), gc_szHttpDelete);

	//	If the resource is not a directory, PUT will be available...
	//
	if ((rt != RT_COLLECTION) && fHaveWriteAccess)
		strcat (psz.get(), gc_szHttpPut);

	//	If a scriptmap could apply to this resource, then
	//	add in the post method
	//
	if (FInScriptMap (LpwszRequestUrl(), MD_ACCESS_EXECUTE))
		strcat (psz.get(), gc_szHttpPost);

	//	Add in the DAV basic methods
	//
	if (rt != RT_NULL)
	{
		strcat (psz.get(), gc_szDavCopy);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavMove);
		strcat (psz.get(), gc_szDavPropfind);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavProppatch);
		strcat (psz.get(), gc_szDavSearch);
		strcat (psz.get(), gc_szDavNotif);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavBatchDelete);
		strcat (psz.get(), gc_szDavBatchCopy);
		if (fHaveWriteAccess)
		{
			strcat (psz.get(), gc_szDavBatchMove);
			strcat (psz.get(), gc_szDavBatchProppatch);
		}
		strcat (psz.get(), gc_szDavBatchPropfind);
	}

	//	If the resource is a directory, MKCOL will be available...
	//
	if ((rt != RT_DOCUMENT) && fHaveWriteAccess)
		strcat (psz.get(), gc_szDavMkCol);

	//	Locks should be available, it doesn't mean it will succeed...
	//
	strcat (psz.get(), gc_szDavLocks);

	//	Set the header
	//
	SetResponseHeader (gc_szAllow, psz.get());
}

//	Etags ---------------------------------------------------------------------
//
void __fastcall
CMethUtil::EmitETag (FILETIME * pft)
{
	WCHAR pwszEtag[100];

	if (FETagFromFiletime (pft, pwszEtag))
		SetResponseHeader (gc_szETag, pwszEtag);
}

void __fastcall
CMethUtil::EmitETag (LPCWSTR pwszPath)
{
	FILETIME ft;

	//	Get and Emit the ETAG
	//
	if (FGetLastModTime (this, pwszPath, &ft))
		EmitETag (&ft);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\davmb.cpp ===
/*
 *	D A V M B . C P P
 *
 *	DAV metabase
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
 */

#include <_davprs.h>
#include <content.h>	// IContentTypeMap
#include <custerr.h>	// ICustomErrorMap
#include <scrptmps.h>	// IScriptMap

//	========================================================================
//
//	CLASS CNotifSink
//
//	Metabase change notification advise sink.  Provides IMSAdminBaseSink
//	interface to the real metabase so that we can be informed of
//	all changes to it.
//
class CNotifSink : public EXO, public IMSAdminBaseSink
{
	//
	//	Shutdown notification event that we signal when we are
	//	done -- i.e. when we get destroyed.
	//
	CEvent& m_evtShutdown;

	HRESULT STDMETHODCALLTYPE SinkNotify(
		/* [in] */ DWORD dwMDNumElements,
		/* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);

	HRESULT STDMETHODCALLTYPE ShutdownNotify()
	{
		MBTrace ("MB: CNotifSink: shutdown\n");
		return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
	}

	//	NOT IMPLEMENTED
	//
	CNotifSink& operator=(const CNotifSink&);
	CNotifSink(const CNotifSink&);

public:
	EXO_INCLASS_DECL(CNotifSink);

	//	CREATORS
	//
	CNotifSink(CEvent& evtShutdown) :
		m_evtShutdown(evtShutdown)
	{
	}

	~CNotifSink()
	{
		//
		//	We cannot process any more notifications at this point.
		//	Signal our shutdown event.
		//
		m_evtShutdown.Set();
	}

	//	Wrapper for all the work that needs to be done on the notification
	//
	static VOID OnNotify( DWORD cCO,
						  MD_CHANGE_OBJECT_W rgCO[] );
};

BEGIN_INTERFACE_TABLE(CNotifSink)
	INTERFACE_MAP(CNotifSink, IMSAdminBaseSink)
END_INTERFACE_TABLE(CNotifSink);
EXO_GLOBAL_DATA_DECL(CNotifSink, EXO);

//	------------------------------------------------------------------------
//
//	HrAdviseSink()
//
HRESULT
HrAdviseSink( IMSAdminBase& msAdminBase,
			  IMSAdminBaseSink * pMSAdminBaseSink,
			  DWORD * pdwCookie )
{
	auto_ref_ptr<IConnectionPoint> pcp;
	auto_ref_ptr<IConnectionPointContainer> pcpc;
	SCODE sc = S_OK;

	Assert( !IsBadReadPtr(&msAdminBase, sizeof(IMSAdminBase)) );
	Assert( !IsBadWritePtr(pMSAdminBaseSink, sizeof(IMSAdminBaseSink)) );

	//	First see if a connection point container is supported
	//
	sc = msAdminBase.QueryInterface (IID_IConnectionPointContainer,
									 reinterpret_cast<LPVOID *>(pcpc.load()));
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - QI to IConnectionPointContainer() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find the required connection point
	//
	sc = pcpc->FindConnectionPoint (IID_IMSAdminBaseSink, pcp.load());
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - FindConnectionPoint() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Advise on the sink
	//
	sc = pcp->Advise (pMSAdminBaseSink, pdwCookie);
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - Advise() failed 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	UnadviseSink()
//
VOID
UnadviseSink( IMSAdminBase& msAdminBase,
			  DWORD dwCookie )
{
	auto_ref_ptr<IConnectionPoint> pcp;
	auto_ref_ptr<IConnectionPointContainer> pcpc;
	SCODE sc = S_OK;

	Assert( !IsBadReadPtr(&msAdminBase, sizeof(IMSAdminBase)) );
	Assert( dwCookie );

	//	First see if a connection point container is supported
	//
	sc = msAdminBase.QueryInterface (IID_IConnectionPointContainer,
									 reinterpret_cast<LPVOID *>(pcpc.load()));
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - QI to IConnectionPointContainer() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find the required connection point
	//
	sc = pcpc->FindConnectionPoint (IID_IMSAdminBaseSink, pcp.load());
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - FindConnectionPoint() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Unadvise
	//
	sc = pcp->Unadvise (dwCookie);
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - Unadvise() failed 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return;
}

//	========================================================================
//
//	CLASS CMDData
//
//	Encapsulates access to a resource's metadata.
//
class CMDData :
	public IMDData,
	public CMTRefCounted
{
	//
	//	Object metadata
	//
	auto_ref_ptr<IContentTypeMap> m_pContentTypeMap;
	auto_ref_ptr<ICustomErrorMap> m_pCustomErrorMap;
	auto_ref_ptr<IScriptMap> m_pScriptMap;

	//
	//	Buffer for the raw metadata and count of
	//	metadata records in that buffer.
	//
	auto_heap_ptr<BYTE> m_pbData;
	DWORD m_dwcMDRecords;

	//
	//	String metadata
	//
	LPCWSTR m_pwszDefaultDocList;
	LPCWSTR m_pwszVRUserName;
	LPCWSTR m_pwszVRPassword;
	LPCWSTR m_pwszExpires;
	LPCWSTR m_pwszBindings;
	LPCWSTR m_pwszVRPath;

	DWORD m_dwAccessPerms;
	DWORD m_dwDirBrowsing;
	BOOL  m_fFrontPage;
	DWORD m_cbIPRestriction;
	BYTE* m_pbIPRestriction;
	BOOL  m_fHasApp;
	DWORD m_dwAuthorization;
	DWORD m_dwIsIndexed;

	//
	//	Metabase path from which the data for this data set was loaded.
	//	Used in metabase notifications.  See CMetabase::OnNotify() below.
	//	The string pointed to is at the end of m_pbData.
	//
	LPCWSTR m_pwszMDPathDataSet;
	DWORD m_dwDataSet;

	//	NOT IMPLEMENTED
	//
	CMDData& operator=(const CMDData&);
	CMDData(const CMDData&);

public:
	//	CREATORS
	//
	CMDData(LPCWSTR pwszMDPathDataSet, DWORD dwDataSet);
	~CMDData();
	BOOL FInitialize( auto_heap_ptr<BYTE>& pbData, DWORD dwcRecords );

	//	Implementation of IRefCounted members
	//	Simply route them to our own CMTRefCounted members.
	//
	void AddRef()
	{ CMTRefCounted::AddRef(); }
	void Release()
	{ CMTRefCounted::Release(); }

	//	ACCESSORS
	//
	LPCWSTR PwszMDPathDataSet() const { return m_pwszMDPathDataSet; }
	DWORD DwDataSet() const { return m_dwDataSet; }
	IContentTypeMap * GetContentTypeMap() const { return m_pContentTypeMap.get(); }
	const ICustomErrorMap * GetCustomErrorMap() const { return m_pCustomErrorMap.get(); }
	const IScriptMap * GetScriptMap() const { return m_pScriptMap.get(); }

	LPCWSTR PwszDefaultDocList() const { return m_pwszDefaultDocList; }
	LPCWSTR PwszVRUserName() const { return m_pwszVRUserName; }
	LPCWSTR PwszVRPassword() const { return m_pwszVRPassword; }
	LPCWSTR PwszExpires() const { return m_pwszExpires; }
	LPCWSTR PwszBindings() const { return m_pwszBindings; }
	LPCWSTR PwszVRPath() const { return m_pwszVRPath; }

	DWORD DwDirBrowsing() const { return m_dwDirBrowsing; }
	DWORD DwAccessPerms() const { return m_dwAccessPerms; }
	BOOL FAuthorViaFrontPage() const { return m_fFrontPage; }
	BOOL FHasIPRestriction() const { return !!m_cbIPRestriction; }
	BOOL FSameIPRestriction( const IMDData* pIMDD ) const
	{
		const CMDData* prhs = static_cast<const CMDData*>( pIMDD );

		//$	REVIEW: theoretically, there is no need for
		//	a memcmp.  However, in the rare case where
		//	the sizes are the same and the pointers are
		//	different, we might still try this.
		//
		//	This way, if/when we go to not using the
		//	METADATA_REFERNCE flag when getting the
		//	data, there should be no difference.
		//
		if ( m_pbIPRestriction == prhs->m_pbIPRestriction )
		{
			Assert( m_cbIPRestriction == prhs->m_cbIPRestriction );
			return TRUE;
		}
		else if ( m_cbIPRestriction == prhs->m_cbIPRestriction )
		{
			if ( !memcmp (m_pbIPRestriction,
						  prhs->m_pbIPRestriction,
						  prhs->m_cbIPRestriction))
			{
				return TRUE;
			}
		}
		//
		//$	REVIEW: end.
		return FALSE;
	}
	BOOL FHasApp() const { return m_fHasApp; }
	DWORD DwAuthorization() const { return m_dwAuthorization; }
	BOOL FIsIndexed() const { return (0 != m_dwIsIndexed); }
	BOOL FSameStarScriptmapping( const IMDData* pIMDD ) const
	{
		return m_pScriptMap->FSameStarScriptmapping( pIMDD->GetScriptMap() );
	}
};


//	========================================================================
//
//	STRUCT SCullInfo
//
//	Structure used in culling cached metabase data once the cache reaches
//	a certain threshold size.
//
struct SCullInfo
{
	//
	//	Data set number of the entry to be considered for culling.
	//
	DWORD dwDataSet;

	//
	//	Number of hits to that entry.
	//
	DWORD dwcHits;

	//
	//	Comparison function used by qsort() to sort the array of
	//	SCullInfo structures in determining which ones to cull.
	//
	static int __cdecl Compare( const SCullInfo * pCullInfo1,
								const SCullInfo * pCullInfo2 );
};


//	========================================================================
//
//	CLASS CMetabase
//
//	Encapsulates access to the metabase through a cache.  The cache
//	provides O(hash) lookup and addition and keeps the cache from
//	growing without bound using a LFU (Least Frequently Used) culling
//	mechanism whenever the size of the cache exceeds a preset threshold.
//
class CMetabase : public Singleton<CMetabase>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CMetabase>;

	//
	//	The IMSAdminBase interface to the real metabase
	//
	auto_ref_ptr<IMSAdminBase> m_pMSAdminBase;

	//
	//	Cache of metadata objects keyed by data set number
	//	and a reader/writer lock to protect it.
	//
	typedef CCache<DwordKey, auto_ref_ptr<CMDData> > CDataSetCache;
	CDataSetCache m_cache;
	CMRWLock m_mrwCache;

	//
	//	Cookie for metabase advise sink registration and an event that is
	//	signalled when the sink associated with that registration has been
	//	shut down and is no longer processing any notifications.
	//
	DWORD m_dwSinkRegCookie;
	CEvent m_evtSinkShutdown;

	//	========================================================================
	//
	//	CLASS COpGatherCullInfo
	//
	//	Cache ForEach() operator class for gathering info needed in determining
	//	which entries to cull from the cache when the cache size reaches the
	//	culling threshold.
	//
	class COpGatherCullInfo : public CDataSetCache::IOp
	{
		//
		//	Array of cull info
		//
		SCullInfo * m_rgci;

		//
		//	Current item in the array above
		//
		int m_ici;

		//	NOT IMPLEMENTED
		//
		COpGatherCullInfo( const COpGatherCullInfo& );
		COpGatherCullInfo& operator=( const COpGatherCullInfo& );

	public:
		COpGatherCullInfo( SCullInfo * rgci ) :
			m_rgci(rgci),
			m_ici(0)
		{
			Assert( m_rgci );
		}

		BOOL operator()( const DwordKey& key,
						 const auto_ref_ptr<CMDData>& pMDData );
	};

	//
	//	Interlockable flag to prevent simultaneous culling by multiple threads.
	//
	LONG m_lfCulling;

	//	========================================================================
	//
	//	CLASS COpNotify
	//
	//	Cache ForEach() operator class for gathering info needed in determining
	//	which entries to blow from the cache when a notification comes in
	//	from the metabase that the metadata for a path changed.
	//
	class COpNotify : public CDataSetCache::IOp
	{
		//
		//	Array of data set IDs.  For entries with a value other than 0,
		//	the data set with that ID is flagged to be blown from the cache.
		//	The array is guaranteed to be as big as there are entries in
		//	the cache.
		//
		DWORD m_cCacheEntry;
		DWORD * m_rgdwDataSets;

		//
		//	Flag set to TRUE if there are any data sets flagged in m_rgdwDataSets.
		//
		BOOL m_fDataSetsFlagged;

		//
		//	Current item in the array above
		//
		UINT m_iCacheEntry;

		//
		//	Path being notified and its length in characters
		//	(set via the Configure() method below).
		//
		LPCWSTR m_pwszMDPathNotify;
		UINT    m_cchMDPathNotify;

		//	NOT IMPLEMENTED
		//
		COpNotify( const COpNotify& );
		COpNotify& operator=( const COpNotify& );

	public:
		//	CREATORS
		//
		COpNotify( DWORD cce, DWORD * rgdwDataSets ) :
			m_rgdwDataSets(rgdwDataSets),
			m_cCacheEntry(cce),
			m_iCacheEntry(0),
			m_fDataSetsFlagged(FALSE)
		{
		}

		//	ACCESSORS
		//
		BOOL FDataSetsFlagged() const { return m_fDataSetsFlagged; }

		//	MANIPULATORS
		//
		BOOL operator()( const DwordKey& key,
						 const auto_ref_ptr<CMDData>& pMDData );

		VOID Configure( LPCWSTR pwszMDPathNotify )
		{
			//	Reset our current entry index.
			//
			m_iCacheEntry = 0;

			m_pwszMDPathNotify = pwszMDPathNotify;
			m_cchMDPathNotify = static_cast<UINT>(wcslen(pwszMDPathNotify));
		}
	};

	//	========================================================================
	//
	//	CLASS COpMatchExactPath
	//
	//	ForEachMatch() operator that fetches the cache entry whose path matches
	//	a desired path.  Used when inheritance bits are important.
	//
	class COpMatchExactPath : public CDataSetCache::IOp
	{
		//	The path to match
		//
		LPCWSTR m_pwszMDPathToMatch;

		//	The data for the matched path
		//
		auto_ref_ptr<CMDData> m_pMDDataMatched;

		//	NOT IMPLEMENTED
		//
		COpMatchExactPath( const COpMatchExactPath& );
		COpMatchExactPath& operator=( const COpMatchExactPath& );

	public:
		//	CREATORS
		//
		COpMatchExactPath( LPCWSTR pwszMDPath ) :
			m_pwszMDPathToMatch(pwszMDPath)
		{
		}

		//	MANIPULATORS
		//
		VOID Invoke( CDataSetCache& cache,
					 DWORD dwDataSet,
					 auto_ref_ptr<CMDData> * ppMDData )
		{
			//	Do the ForEachMatch()
			//
			(VOID) cache.ForEachMatch( dwDataSet, *this );

			//	Returned the matched data (if any)
			//
			(*ppMDData).take_ownership(m_pMDDataMatched.relinquish());
		}

		BOOL operator()( const DwordKey&,
						 const auto_ref_ptr<CMDData>& pMDData )
		{
			//	If the data's data set number path matches the
			//	path we are looking for, then return this data set.
			//	If not then do nothing and keep looking.
			//
			//$OPT	Can we guarantee that all MD paths are one case?
			//
			if (_wcsicmp(pMDData->PwszMDPathDataSet(), m_pwszMDPathToMatch))
			{
				return TRUE;
			}
			else
			{
				m_pMDDataMatched = pMDData;
				return FALSE;
			}
		}
	};

	//	CREATORS
	//
	CMetabase() :
		m_lfCulling(FALSE),
		m_dwSinkRegCookie(0)
	{
	}
	~CMetabase();

	//	MANIPULATORS
	//
	VOID CullCacheEntries();

	HRESULT HrCacheData( const IEcb& ecb,
						 LPCWSTR pwszMDPathAccess,
						 LPCWSTR pwszMDPathOpen,
						 CMDData ** ppMDData );

	//	NOT IMPLEMENTED
	//
	CMetabase& operator=( const CMetabase& );
	CMetabase( const CMetabase& );

public:
	enum
	{
		//
		//	Number of entries allowed in cache before culling.
		//
		//$REVIEW	Not based on emperical data
		//
		C_MAX_CACHE_ENTRIES = 100,

		//
		//	Number of entries to cull from cache when culling.
		//
		//$REVIEW	Not based on emperical data
		//$REVIEW	Consider expressing culling as a factor (percentage)
		//$REVIEW	rather than an absolute number.
		//
		C_CULL_CACHE_ENTRIES = 20,

		//
		//	Size of the metadata for the average cache entry.
		//	This one is based on experential data.  9K is just
		//	enough to hold all of an object's inherited metadata.
		//
		CCH_AVG_CACHE_ENTRY = 9 * 1024
	};

	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CMetabase>::CreateInstance;
	using Singleton<CMetabase>::DestroyInstance;
	using Singleton<CMetabase>::Instance;
	BOOL FInitialize();

	VOID OnNotify( DWORD dwcChangeObjects,
				   MD_CHANGE_OBJECT_W rgCO[] );

	HRESULT HrGetData( const IEcb& ecb,
					   LPCWSTR pwszMDPathAccess,
					   LPCWSTR pwszMDPathOpen,
					   IMDData ** ppMDData );

	DWORD DwChangeNumber();

	HRESULT HrOpenObject( LPCWSTR pwszMDPath,
						  DWORD dwAccess,
						  DWORD dwMsecTimeout,
						  CMDObjectHandle * pmdoh );

	HRESULT HrOpenLowestNodeObject( LPWSTR pwszMDPath,
									DWORD dwAccess,
									LPWSTR * ppwszMDPath,
									CMDObjectHandle * pmdoh );

	HRESULT HrIsAuthorViaFrontPageNeeded( const IEcb& ecb,
										  LPCWSTR pwszURI,
										  BOOL * pfFrontPageWeb );

};


//	========================================================================
//
//	CLASS CMDObjectHandle
//
//	Encapsulates access to a metabase object through an open handle,
//	ensuring that the handle is always propery closed.
//
//	------------------------------------------------------------------------
//
//	HrOpen()
//
HRESULT
CMDObjectHandle::HrOpen( IMSAdminBase * pMSAdminBase,
						 LPCWSTR pwszPath,
						 DWORD dwAccess,
						 DWORD dwMsecTimeout )
{
	HRESULT hr = S_OK;

	Assert(pMSAdminBase);
	Assert (NULL == m_pMSAdminBase || pMSAdminBase == m_pMSAdminBase);

	//	METADATA_MASTER_ROOT_HANDLE must be set
	//
	Assert (METADATA_MASTER_ROOT_HANDLE == m_hMDObject);

	//	Save the pointer to the interface, so we could use
	//	it any time later in spite of the fact if opening
	//	of the key succeeded or not
	//
	m_pMSAdminBase = pMSAdminBase;

	hr = pMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							   pwszPath,
							   dwAccess,
							   dwMsecTimeout,
							   &m_hMDObject);

	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrOpen() - IMSAdminBase::OpenKey() failed 0x%08lX\n", hr );
	}
	else
	{
		m_pwszPath = pwszPath;
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrOpenLowestNode()
//
//	Purpose:
//
//		Opens the LOWEST possible metabase node along the given path.
//
//	Parameters:
//
//		pMSAdminBase [in]	IMSAdminBase interface pointer.
//
//		pwszPath	 [in]	A full metabase path.  This function opens
//							the lowest possible node along this path,
//							by working backward from the full path
//							up to the root of the metabase until a
//							path specifying an existing node is opened.
//
//		dwAccess	 [in]	Permissions with which we want to open the
//							node.
//
//		ppwszPath	 [out]	Points to the remainder of the initial path
//							relative to the opened node.  This value is
//							NULL if the initial path was openable.
//
HRESULT
CMDObjectHandle::HrOpenLowestNode( IMSAdminBase * pMSAdminBase,
								   LPWSTR pwszPath,
								   DWORD dwAccess,
								   LPWSTR * ppwszPath)
{
	HRESULT hr = E_FAIL;
	WCHAR * pwch;

	Assert (pMSAdminBase);
	Assert (pwszPath);
	Assert (L'/' == pwszPath[0]);
	Assert (ppwszPath);
	Assert (!IsBadWritePtr(ppwszPath, sizeof(LPWSTR)) );

	*ppwszPath = NULL;

	pwch = pwszPath + wcslen(pwszPath);
	while ( pwch > pwszPath )
	{
		//
		//	Split off the path from the root at the current position
		//
		*pwch = L'\0';

		//
		//	Attempt to open a node at the resulting root
		//
		hr = HrOpen(pMSAdminBase,
					pwszPath,
					dwAccess,
					METADATA_TIMEOUT);

		//
		//	If we successfully open the node or failed for any reason
		//	other than that the node wasn't there, we're done.
		//
		if ( SUCCEEDED(hr) ||
			 HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
		{
			goto ret;
		}

		//
		//	If there was no node, then restore the slash separator
		//	that we previously nulled out and scan backward to the
		//	next possible split location.
		//
		if ( *ppwszPath )
		{
			*pwch = L'/';
		}

		pwch--;
		while (*pwch != L'/')
		{
			pwch--;
		}

		*ppwszPath = pwch + 1;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrEnumKeys()
//
HRESULT
CMDObjectHandle::HrEnumKeys( LPCWSTR pwszPath,
							 LPWSTR pwszChild,
							 DWORD dwIndex ) const
{
	HRESULT hr = S_OK;

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->EnumKeys(m_hMDObject,
								  pwszPath,
								  pwszChild,
								  dwIndex);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrEnumKeys() - IMSAdminBase::EnumKeys() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetDataPaths()
//
HRESULT
CMDObjectHandle::HrGetDataPaths( LPCWSTR pwszPath,
								 DWORD   dwPropID,
								 DWORD   dwDataType,
								 LPWSTR	 pwszDataPaths,
								 DWORD * pcchDataPaths ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (pwszPath);
	Assert (!IsBadReadPtr(pcchDataPaths, sizeof(DWORD)));
	Assert (!IsBadWritePtr(pcchDataPaths, sizeof(DWORD)));
	Assert (!IsBadWritePtr(pwszDataPaths, *pcchDataPaths * sizeof(WCHAR)));

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetDataPaths(m_hMDObject,
									  pwszPath,
									  dwPropID,
									  dwDataType,
									  *pcchDataPaths,
									  pwszDataPaths,
									  pcchDataPaths);

	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetDataPaths() - IMSAdminBase::GetDataPaths() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetMetaData()
//
HRESULT
CMDObjectHandle::HrGetMetaData( LPCWSTR pwszPath,
							    METADATA_RECORD * pmdrec,
							    DWORD * pcbBufRequired ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetData(m_hMDObject,
								 const_cast<LPWSTR>(pwszPath),
								 pmdrec,
								 pcbBufRequired);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetMetaData() - IMSAdminBase::GetData() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetAllMetaData()
//
HRESULT
CMDObjectHandle::HrGetAllMetaData( LPCWSTR pwszPath,
								   DWORD dwAttributes,
								   DWORD dwUserType,
								   DWORD dwDataType,
								   DWORD * pdwcRecords,
								   DWORD * pdwDataSet,
								   DWORD cbBuf,
								   LPBYTE pbBuf,
								   DWORD * pcbBufRequired ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetAllData(m_hMDObject,
									pwszPath,
									dwAttributes,
									dwUserType,
									dwDataType,
									pdwcRecords,
									pdwDataSet,
									cbBuf,
									pbBuf,
									pcbBufRequired);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetAllMetaData() - IMSAdminBase::GetAllData() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrSetMetaData()
//
HRESULT
CMDObjectHandle::HrSetMetaData( LPCWSTR pwszPath,
							    const METADATA_RECORD * pmdrec ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	Assert (pmdrec);

	//	METADATA_MASTER_ROOT_HANDLE not valid for this operation
	//
	Assert (METADATA_MASTER_ROOT_HANDLE != m_hMDObject);
	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->SetData(m_hMDObject,
								 pwszPath,
								 const_cast<METADATA_RECORD *>(pmdrec));
	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrSetMetaData() - IMSAdminBase::SetData() failed 0x%08lX\n", hr );
	}
	else
	{
		//	Notify the sinks registered on this IMSAdminBase
		//	will not get notified, so we need to do all the
		//	invalidation ourselves. The only sink currently
		//	being registered is CChildVRCache.
		//
		SCODE scT;
		MD_CHANGE_OBJECT_W mdChObjW;
		UINT cchBase = 0;
		UINT cchPath = 0;

		CStackBuffer<WCHAR,MAX_PATH> pwsz;
		UINT cch;

		if (m_pwszPath)
		{
			cchBase = static_cast<UINT>(wcslen(m_pwszPath));
		}
		if (pwszPath)
		{
			cchPath = static_cast<UINT>(wcslen(pwszPath));
		}

		//	Allocate enough space for constructed path:
		//		base, '/' separator,
		//		path, '/' termination, '\0' termination...
		//
		cch = cchBase + 1 + cchPath + 2;
		if (!pwsz.resize(cch * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		scT = ScBuildChangeObject(m_pwszPath,
								  cchBase,
								  pwszPath,
								  cchPath,
								  MD_CHANGE_TYPE_SET_DATA,
								  &pmdrec->dwMDIdentifier,
								  pwsz.get(),
								  &cch,
								  &mdChObjW);

		//	Function above returns S_FALSE when it is short in buffer,
		//	otherwise it always returns S_OK. The buffer we gave is
		//	sufficient, so assert that we succeeded
		//
		Assert( S_OK == scT );
		CNotifSink::OnNotify( 1, &mdChObjW );
		goto ret;
	}

ret:
	return hr;
}

//	------------------------------------------------------------------------
//
//	HrDeleteMetaData()
//
HRESULT
CMDObjectHandle::HrDeleteMetaData( LPCWSTR pwszPath,
								   DWORD dwPropID,
								   DWORD dwDataType ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//	METADATA_MASTER_ROOT_HANDLE not valid for this operation
	//
	Assert (METADATA_MASTER_ROOT_HANDLE != m_hMDObject);
	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->DeleteData(m_hMDObject,
									pwszPath,
									dwPropID,
									dwDataType);
	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrDeleteMetaData() - IMSAdminBase::DeleteData() failed 0x%08lX\n", hr );
	}
	else
	{
		//	Notify the sinks registered on this IMSAdminBase
		//	will not get notified, so we need to do all the
		//	invalidation ourselves. The only sink currently
		//	being registered is CChildVRCache.
		//
		SCODE scT;
		MD_CHANGE_OBJECT_W mdChObjW;
		UINT cchBase = 0;
		UINT cchPath = 0;

		CStackBuffer<WCHAR,MAX_PATH> pwsz;
		UINT cch;

		if (m_pwszPath)
		{
			cchBase = static_cast<UINT>(wcslen(m_pwszPath));
		}
		if (pwszPath)
		{
			cchPath = static_cast<UINT>(wcslen(pwszPath));
		}

		//	Allocate enough space for constructed path:
		//		base, '/' separator,
		//		path, '/' termination, '\0' termination...
		//
		cch = cchBase + 1 + cchPath + 2;
		if (!pwsz.resize(cch * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		scT = ScBuildChangeObject(m_pwszPath,
								  cchBase,
								  pwszPath,
								  cchPath,
								  MD_CHANGE_TYPE_DELETE_DATA,
								  &dwPropID,
								  pwsz.get(),
								  &cch,
								  &mdChObjW);

		//	Function above returns S_FALSE when it is short in buffer,
		//	otherwise it always returns S_OK. The buffer we gave is
		//	sufficient, so assert that we succeeded
		//
		Assert( S_OK == scT );
		CNotifSink::OnNotify( 1, &mdChObjW );
		goto ret;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	Close()
//
VOID
CMDObjectHandle::Close()
{
	if ( METADATA_MASTER_ROOT_HANDLE != m_hMDObject )
	{
		Assert (m_pMSAdminBase);

		m_pMSAdminBase->CloseKey( m_hMDObject );
		m_hMDObject = METADATA_MASTER_ROOT_HANDLE;
		m_pwszPath = NULL;
	}
}

//	------------------------------------------------------------------------
//
//	~CMDObjectHandle()
//
CMDObjectHandle::~CMDObjectHandle()
{
	Close();
}

//	------------------------------------------------------------------------
//
//	HrReadMetaData()
//
//	Reads in the raw metadata from the metabase.
//
HrReadMetaData( const IEcb& ecb,
				IMSAdminBase * pMSAdminBase,
				LPCWSTR pwszMDPathAccess,
				LPCWSTR pwszMDPathOpen,
				LPBYTE * ppbData,
				DWORD * pdwDataSet,
				DWORD * pdwcRecords,
				LPCWSTR * ppwszMDPathDataSet )
{
	CMDObjectHandle mdoh(ecb);
	HRESULT hr;

	Assert( ppwszMDPathDataSet );

	//
	//	We should never open the root node of the metabase.
	//	It's prohibitively expensive.
	//
	Assert( pwszMDPathOpen );

	//
	//	If the open path is not the path we are trying to access
	//	then the former must be a proper prefix of the latter.
	//
	Assert( pwszMDPathAccess == pwszMDPathOpen ||
			!_wcsnicmp(pwszMDPathOpen, pwszMDPathAccess, wcslen(pwszMDPathOpen)) );

	//
	//	Open the specified "open" path.  Note that we do not simply open
	//	the full path because it may not exist and we don't necessarily
	//	want to try opening successive "parent" paths as each attempt
	//	costs us a trip through a global critical section in the metabase.
	//
	hr = mdoh.HrOpen( pMSAdminBase,
					  pwszMDPathOpen,
					  METADATA_PERMISSION_READ,
					  200 ); // timeout in msec (0.2 sec)

	if ( FAILED(hr) )
	{
		DebugTrace( "HrReadMetaData() - Error opening vroot for read 0x%08lX\n", hr );
		return hr;
	}

	//
	//	Get all of the metadata.  We should go through this loop at most twice --
	//	if our inital guess is too small to hold all the data the first time
	//	through, we'll go through it again with a buffer of the adequate size.
	//
	//	Note that we reserve space at the end of the buffer for a copy of the
	//	access path including a slash at the end (to make subpath detection
	//	easier).
	//
	DWORD cbBuf = CMetabase::CCH_AVG_CACHE_ENTRY * sizeof(WCHAR);
	DWORD cchMDPathAccess = static_cast<DWORD>(wcslen(pwszMDPathAccess) + 1);
	auto_heap_ptr<BYTE> pbBuf(static_cast<LPBYTE>(ExAlloc(cbBuf + CbSizeWsz(cchMDPathAccess))));

	//
	//	Get all the metadata.  Include inherited data (METADATA_INHERIT).
	//	Return whether the data for a given path was inherited (METADATA_ISINHERITED).
	//	If the path does not exist, return the inherited data
	//	anyway (METADATA_PARTIAL_PATH).
	//
	hr = mdoh.HrGetAllMetaData( (pwszMDPathOpen == pwszMDPathAccess) ?
									NULL :
									pwszMDPathAccess + wcslen(pwszMDPathOpen),
								METADATA_INHERIT |
								METADATA_ISINHERITED |
								METADATA_PARTIAL_PATH,
								ALL_METADATA,
								ALL_METADATA,
								pdwcRecords,
								pdwDataSet,
								cbBuf,
								pbBuf.get(),
								&cbBuf );

	if ( FAILED(hr) )
	{
		if ( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr )
		{
			DebugTrace( "HrReadMetaData() - Error getting all metadata 0x%08lX\n", hr );
			return hr;
		}

		//
		//	We couldn't read all the metadata because our initial
		//	guess was too small so allocate a buffer that is as
		//	big as the metabase told us we needed and use that
		//	buffer the next time around.
		//
		pbBuf.realloc(cbBuf + CbSizeWsz(cchMDPathAccess));
		hr = mdoh.HrGetAllMetaData( (pwszMDPathOpen == pwszMDPathAccess) ?
										NULL :
										pwszMDPathAccess + wcslen(pwszMDPathOpen),
									METADATA_INHERIT |
									METADATA_PARTIAL_PATH,
									ALL_METADATA,
									ALL_METADATA,
									pdwcRecords,
									pdwDataSet,
									cbBuf,
									pbBuf.get(),
									&cbBuf );

		if ( FAILED(hr) )
		{
			DebugTrace( "HrReadMetaData() - Error getting all metadata 0x%08lX\n", hr );
			return hr;
		}
	}

	//
	//	Copy the access path (including the null terminator) to the end
	//	of the buffer.
	//
	Assert( L'\0' == pwszMDPathAccess[cchMDPathAccess - 1] );
	memcpy( pbBuf + cbBuf, pwszMDPathAccess, cchMDPathAccess * sizeof(WCHAR) );

	//
	//	Tack on a final slash and null terminate.
	//	Note: pwszMDPathAccess may or may not already have a terminating slash
	//	** depending on how this function was called **
	//	(specifically, deep MOVE/COPY/DELETEs will have slashes on
	//	sub-directory URLs)
	//
	LPWSTR pwszT = reinterpret_cast<LPWSTR>(pbBuf + cbBuf + (cchMDPathAccess - 2) * sizeof(WCHAR));
	if ( L'/' != pwszT[0] )
	{
		pwszT[1] = L'/';
		pwszT[2] = L'\0';
	}

	//
	//	Return the path
	//
	*ppwszMDPathDataSet = reinterpret_cast<LPWSTR>(pbBuf.get() + cbBuf);

	//
	//	And the data
	//
	*ppbData = pbBuf.relinquish();
	return S_OK;
}

//	========================================================================
//
//	CLASS CMDData
//

//	------------------------------------------------------------------------
//
//	CMDData::CMDData()
//
CMDData::CMDData( LPCWSTR pwszMDPathDataSet,
				  DWORD dwDataSet ) :
    m_pwszMDPathDataSet(pwszMDPathDataSet),
	m_dwDataSet(dwDataSet),
								// Defaults not handled by auto_xxx classes:
	m_pwszDefaultDocList(NULL), //   No default doc list
	m_pwszVRUserName(NULL),     //   No VRoot user name
	m_pwszVRPassword(NULL),     //   No VRoot password
	m_pwszExpires(NULL),        //   No expiration
	m_pwszBindings(NULL),		//   No custom bindings
	m_pwszVRPath(NULL),			//   No VRoot physical path
    m_dwAccessPerms(0),         //   Deny all access
	m_dwDirBrowsing(0),         //   No default dir browsing
	m_fFrontPage(FALSE),        //   No FrontPage authoring
	m_cbIPRestriction(0),		//    --
	m_pbIPRestriction(NULL),	//    --
    m_fHasApp(FALSE),           //   No registered app
    m_dwAuthorization(0),		//	 No specific authorization method
	m_dwIsIndexed(1)			//   Indexing is on by default
{
	Assert(pwszMDPathDataSet);
	Assert(dwDataSet != 0);
	m_cRef = 1;
}

//	------------------------------------------------------------------------
//
//	CMDData::~CMDData()
//
CMDData::~CMDData()
{
}

//	------------------------------------------------------------------------
//
//	CMDData::FInitialize()
//
//	Populates a metadata object from metadata obtained through an accessor.
//
BOOL
CMDData::FInitialize( auto_heap_ptr<BYTE>& pbData,
					  DWORD dwcMDRecords )
{
	Assert(!IsBadReadPtr(pbData.get(), dwcMDRecords * sizeof(METADATA_RECORD)));

	for ( DWORD iRec = 0; iRec < dwcMDRecords; iRec++ )
	{
		//
		//	Locate the metadata record and its data.  Note that the
		//	pbMDData field of METADATA_RECORD is actually an offset
		//	to the data -- not a pointer to it -- from the start of
		//	the buffer.
		//
		const METADATA_GETALL_RECORD& mdrec =
			reinterpret_cast<const METADATA_GETALL_RECORD *>(pbData.get())[iRec];

		LPVOID pvRecordData =
			pbData.get() + mdrec.dwMDDataOffset;

		//
		//	!!!IMPORTANT!!! The list of identifiers below must be kept up to date
		//	with the list in FHasCachedIDs().
		//
		switch ( mdrec.dwMDIdentifier )
		{
			case MD_IP_SEC:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != BINARY_METADATA )
					return FALSE;

				m_cbIPRestriction = mdrec.dwMDDataLen;
				m_pbIPRestriction = static_cast<LPBYTE>(pvRecordData);
				break;
			}

			case MD_ACCESS_PERM:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwAccessPerms = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_IS_CONTENT_INDEXED:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwIsIndexed = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_FRONTPAGE_WEB:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				//
				//	Set the frontpage flag if MD_FRONTPAGE_WEB is
				//	explicitly set on this metabase node and not
				//	inherited.
				//
				m_fFrontPage = *static_cast<LPDWORD>(pvRecordData) &&
							   !(mdrec.dwMDAttributes & METADATA_ISINHERITED);
				break;
			}

			case MD_DIRECTORY_BROWSING:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwDirBrowsing = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_AUTHORIZATION:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwAuthorization = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_DEFAULT_LOAD_FILE:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszDefaultDocList = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_CUSTOM_ERROR:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pCustomErrorMap.take_ownership(
					NewCustomErrorMap(static_cast<LPWSTR>(pvRecordData)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pCustomErrorMap.get() )
					return FALSE;

				break;
			}

			case MD_MIME_MAP:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pContentTypeMap.take_ownership(
					NewContentTypeMap(static_cast<LPWSTR>(pvRecordData),
									  !!(mdrec.dwMDAttributes & METADATA_ISINHERITED)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pContentTypeMap.get() )
					return FALSE;

				break;
			}

			case MD_SCRIPT_MAPS:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pScriptMap.take_ownership(
					NewScriptMap(static_cast<LPWSTR>(pvRecordData)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pScriptMap.get() )
					return FALSE;

				break;
			}

			case MD_APP_ISOLATED:
			{
				//
				//	If this property exists on this node at all
				//	(i.e. it is not inherited) then we want to
				//	know, regardless of its value.
				//
				if ( mdrec.dwMDAttributes & METADATA_ISINHERITED )
					m_fHasApp = TRUE;

				break;
			}

			case MD_VR_USERNAME:
			{
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRUserName = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_VR_PASSWORD:
			{
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRPassword = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_HTTP_EXPIRES:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszExpires = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_SERVER_BINDINGS:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pwszBindings = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_VR_PATH:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRPath = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			//
			//$REVIEW	Do we need to worry about any of these?
			//
			case MD_VR_PASSTHROUGH:
			case MD_SSL_ACCESS_PERM:
			default:
			{
				break;
			}
		}
	}

	//
	//$SECURITY
	//$	REVIEW/HACK: DAVEX needs to disable access to any url that has a
	//	VrUserName, VrPassword enabled on it.  The following call is
	//	implemented differently in HTTPEXT and DAVEX
	//
	ImplHackAccessPerms( m_pwszVRUserName,
						 m_pwszVRPassword,
						 &m_dwAccessPerms );

	//
	//	If all goes well we take ownership of the data buffer passed in.
	//
	m_pbData = pbData.relinquish();
	m_dwcMDRecords = dwcMDRecords;
	return TRUE;
}

//	========================================================================
//
//	CLASS CMetabase
//

//	------------------------------------------------------------------------
//
//	CMetabase::~CMetabase()
//
CMetabase::~CMetabase()
{
	//
	//	If we ever advised a notification sink then unadvise it now.
	//
	if ( m_dwSinkRegCookie )
	{
		//
		//	Unadvise the sink
		//
		UnadviseSink(*m_pMSAdminBase.get(), m_dwSinkRegCookie);

		//
		//	Wait for the sink to shutdown
		//
		m_evtSinkShutdown.Wait();
	}
}

//	------------------------------------------------------------------------
//
//	CMetabase::FInitialize()
//
BOOL
CMetabase::FInitialize()
{
	HRESULT hr = S_OK;

	//	Init the cache
	//
	if ( !m_cache.FInit() )
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	//	Init its reader/writer lock
	//
	if ( !m_mrwCache.FInitialize() )
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	//	Create an instance of the com-base metabase interface.
	//	Again, we expect that somebody above us has already done
	//	this, so it should be fairly cheap as well.
	//
	//	Note that we do not init COM at any point.  IIS should
	//	have already done that for us.
	//
	hr = CoCreateInstance (CLSID_MSAdminBase,
						   NULL,
						   CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						   IID_IMSAdminBase,
						   (LPVOID *)m_pMSAdminBase.load());
	if ( FAILED(hr) )
	{
		DebugTrace( "CMetabase::FInitialize() - CoCreateInstance(CLSID_MDCOM) failed 0x%08lX\n", hr );
		goto ret;
	}

	//	Register for metabase change notifications
	//
	{
		auto_ref_ptr<CNotifSink> pSinkNew;

		//
		//	First, set up an empty security descriptor and attributes
		//	so that the event can be created with no security
		//	(i.e. accessible from any security context).
		//
		SECURITY_DESCRIPTOR sdAllAccess;

		(void) InitializeSecurityDescriptor( &sdAllAccess, SECURITY_DESCRIPTOR_REVISION );
		SetSecurityDescriptorDacl( &sdAllAccess, TRUE, NULL, FALSE );

		SECURITY_ATTRIBUTES saAllAccess;

		saAllAccess.nLength              = sizeof(saAllAccess);
		saAllAccess.lpSecurityDescriptor = &sdAllAccess;
		saAllAccess.bInheritHandle       = FALSE;

		//
		//	Create the sink shutdown event
		//
		if ( !m_evtSinkShutdown.FCreate( NULL,
										 &saAllAccess, // no security
										 TRUE, // manual access
										 FALSE, // initially non-signalled
										 NULL ))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace( "CMetabase::FInitialize() - m_evtSinkShutdown.FCreate() failed 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	Create the sink
		//
		pSinkNew.take_ownership(new CNotifSink(m_evtSinkShutdown));

		//
		//	Advise the sink
		//
		hr = HrAdviseSink(*m_pMSAdminBase.get(),
						  pSinkNew.get(),
						  &m_dwSinkRegCookie);
		if ( FAILED(hr) )
		{
			DebugTrace( "CMetabase::FInitialize() - HrAdviseSink() failed 0x%08lX\n", hr );
			goto ret;
		}
	}

ret:
	return SUCCEEDED(hr);
}

//	------------------------------------------------------------------------
//
//	CMetabase::DwChangeNumber()
//

DWORD
CMetabase::DwChangeNumber()
{
	DWORD dw = 0;

	Assert(m_pMSAdminBase.get());

	(void) m_pMSAdminBase->GetSystemChangeNumber(&dw);
	return dw;
}


//	------------------------------------------------------------------------
//
//	CMetabase::COpGatherCullInfo::operator()
//
BOOL
CMetabase::COpGatherCullInfo::operator()( const DwordKey& key,
										  const auto_ref_ptr<CMDData>& pMDData )
{
	//
	//	Gather and reset the access count of the current metadata object
	//
	m_rgci[m_ici].dwDataSet = key.Dw();
	m_rgci[m_ici].dwcHits   = pMDData->LFUData().DwGatherAndResetHitCount();
	++m_ici;

	//
	//	ForEach() operators can cancel the iteration by returning FALSE.
	//	We always want to iterate over everything so return TRUE
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	SCullInfo::Compare()
//
//	Cull info comparison function used by qsort() to sort an array
//	of SCullInfo structures.
//
int __cdecl
SCullInfo::Compare( const SCullInfo * pCullInfo1,
					const SCullInfo * pCullInfo2 )
{
	return static_cast<int>(pCullInfo1->dwcHits - pCullInfo2->dwcHits);
}

//	------------------------------------------------------------------------
//
//	CMetabase::CullCacheEntries()
//
//	Called by HrCacheData() when the number of entries in the metabase
//	cache reaches a preset threshold.  This function removes those entries
//	that have been used least frequently since the last time the cache
//	was culled.
//
VOID
CMetabase::CullCacheEntries()
{
	CStackBuffer<SCullInfo,128> rgci;
	int cCacheEntries;

	//
	//	Gather cull info for all of the cache entries.  We need to do
	//	this in a read block so that the cache stays stable (i.e. does
	//	not have entries added or removed) while we are in the ForEach()
	//	operation.
	//
	{
		//
		//	Lock out writers -- anyone trying to add or remove cache entries
		//
		CSynchronizedReadBlock sb(m_mrwCache);

		//
		//	Now that the count of cache entries is stable (because
		//	we are in the read block) check once again that we
		//	are over the culling threshold.  If we are not (because
		//	enough entries were removed before we got the lock) then
		//	don't cull.
		//
		cCacheEntries = m_cache.CItems();
		if ( cCacheEntries < C_CULL_CACHE_ENTRIES )
			return;

		//
		//	We need to cull.  Run through the cache gathering the access
		//	frequency information for each entry.
		//
		if (!rgci.resize(cCacheEntries * sizeof(SCullInfo)))
			return;

		COpGatherCullInfo opGatherCullInfo(rgci.get());
		m_cache.ForEach( opGatherCullInfo );
	}

	//
	//	Now that we are out of the reader block, cache entries can be
	//	freely added and removed, so there's no guarantee that any of
	//	the cull info we just gathered is still accurate at this point.
	//	It's important to remember that culling is a hint-driven process.
	//	More strict methods would require holding locks longer, increasing
	//	the probability of contention.
	//
	//
	//	Sort the cull info by increasing number of cache entry hits.
	//
	qsort( rgci.get(),
		   cCacheEntries,
		   sizeof(SCullInfo),
		   reinterpret_cast<int (__cdecl *)(const void *, const void *)>(SCullInfo::Compare) );

	//	Run through the sorted cull info and cull entries from the cache
	//
	Assert( cCacheEntries >= C_CULL_CACHE_ENTRIES );
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		for ( int iCacheEntry = 0;
			  iCacheEntry < C_CULL_CACHE_ENTRIES;
			  iCacheEntry++ )
		{
			m_cache.Remove( DwordKey(rgci[iCacheEntry].dwDataSet) );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrCacheData()
//
//	Add a new cache entry for the metadata for the object at the given
//	access path.
//
HRESULT
CMetabase::HrCacheData( const IEcb& ecb,
					    LPCWSTR pwszMDPathAccess,
						LPCWSTR pwszMDPathOpen,
						CMDData ** ppMDData )
{
	auto_ref_ptr<CMDData> pMDDataRet;
	auto_heap_ptr<BYTE> pbData;
	LPCWSTR pwszMDPathDataSet;
	DWORD dwDataSet;
	DWORD dwcMDRecords;
	HRESULT hr = S_OK;

	//
	//	Read in the raw metadata from the metabase
	//
	hr = HrReadMetaData( ecb,
						 m_pMSAdminBase.get(),
						 pwszMDPathAccess,
						 pwszMDPathOpen,
						 &pbData,
						 &dwDataSet,
						 &dwcMDRecords,
						 &pwszMDPathDataSet );
	if ( FAILED(hr) )
	{
		DebugTrace( "CMetabase::HrCacheData() - HrReadMetaData() failed 0x%08lX\n", hr );
		goto ret;
	}

	//
	//	Digest it into a new metadata object
	//
	pMDDataRet.take_ownership(new CMDData(pwszMDPathDataSet, dwDataSet));
	if ( !pMDDataRet->FInitialize(pbData, dwcMDRecords) )
	{
		//
		//$REVIEW	We should probably log this in the event log since
		//$REVIEW	there is no other indication to the server admin
		//$REVIEW	what is wrong and this is something that an admin
		//$REVIEW	could fix.
		//
		hr = E_INVALIDARG;
		DebugTrace( "CMetabase::HrCacheData() - Metadata is malformed\n" );
		goto ret;
	}

	//
	//	Add the new data object to the cache.  Note: we don't care
	//	if we can't add to the cache.  We already have a metadata
	//	object that we can return to the caller.
	//
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		if ( !m_cache.Lookup( DwordKey(dwDataSet) ) )
			(void) m_cache.FAdd( DwordKey(dwDataSet), pMDDataRet );
	}

	//
	//	If the cache size has exceeded the expiration threshold then
	//	start culling entries until it goes below the minimum
	//	threshold.  The ICE ensures that only the first thread to
	//	see the threshold exceeded will do the culling.
	//
	if ( (m_cache.CItems() > C_MAX_CACHE_ENTRIES) &&
		 TRUE == InterlockedCompareExchange(&m_lfCulling, TRUE, FALSE) )
	{
		//
		//$REVIEW	Consider culling asynchronously.  I believe the current
		//$REVIEW	mechanism still allows us to hang onto a very large
		//$REVIEW	cache which is never reduced if we get hit with a
		//$REVIEW	burst of new entries simultaneously.
		//
		CullCacheEntries();

		m_lfCulling = FALSE;
	}

	Assert( pMDDataRet.get() );
	*ppMDData = pMDDataRet.relinquish();

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrGetData()
//
//	Fetch data from the metabase cache.  See comment in \cal\src\inc\davmb.h
//	for the distinction between pszMDPathAccess and pszMDPathOpen.
//
HRESULT
CMetabase::HrGetData( const IEcb& ecb,
					  LPCWSTR pwszMDPathAccess,
					  LPCWSTR pwszMDPathOpen,
					  IMDData ** ppMDData )
{
	auto_ref_ptr<CMDData> pMDDataRet;
	DWORD dwDataSet;
	HRESULT hr;

	//	Fetch the data set number for this path directly from the metabase.
	//	Items in the metabase with the same data set number have the same data.
	//
	{
		safe_revert sr(ecb.HitUser());

		hr = m_pMSAdminBase->GetDataSetNumber(METADATA_MASTER_ROOT_HANDLE,
											  pwszMDPathAccess,
											  &dwDataSet);
		if ( FAILED(hr) )
		{
			MBTrace( "CMetabase::HrGetData() - GetDataSetNumber() failed 0x%08lX\n", hr );
			return hr;
		}

		MBTrace("MB: CMetabase::HrGetData() - TID %3d: Retrieved data set number 0x%08lX for path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );
	}

	//
	//	If we don't care about the exact path then look for any entry
	//	in the cache with this data set number.  If we do care then
	//	look for an entry in the cache with this data set number AND
	//	a matching path.
	//
	//	Note: a pointer comparison here is sufficient.  Callers are expected
	//	to use the single path version of HrMDGetData() if they want
	//	an metadata for an exact path.  That version passes the same
	//	string for both pszMDPathAccess and pszMDPathOpen.
	//
	//	Why does anyone care about an exact path match?  Inheritance.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);

		if (pwszMDPathAccess == pwszMDPathOpen)
		{
			MBTrace("MB: CMetabase::HrGetData() - TID %3d: Exact path match! Trying to get CMDData, dataset 0x%08lX\n", GetCurrentThreadId(), dwDataSet);

			COpMatchExactPath(pwszMDPathAccess).Invoke(m_cache, dwDataSet, &pMDDataRet);
		}
		else
		{
			MBTrace("MB: CMetabase::HrGetData() - TID %3d: Not exact path match! Trying to get CMDData, dataset 0x%08lX\n", GetCurrentThreadId(), dwDataSet);

			(void) m_cache.FFetch( dwDataSet, &pMDDataRet );
		}
	}

	if ( pMDDataRet.get() )
	{
		MBTrace("MB: CMetabase::HrGetData() - TID %3d: Retrieved cached CMDData, data set number 0x%08lX, path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );

		pMDDataRet->LFUData().Touch();
	}
	else
	{

		MBTrace("MB: CMetabase::HrGetData() - TID %3d: No cached data CMDData, data set number 0x%08lX, path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );

		//
		//	We didn't find an entry in the cache, so create one.
		//
		//	Note: nothing here prevents multiple threads from getting here
		//	simultaneously and attempting to cache duplicate entries.  That
		//	is done within HrCacheData().
		//
		hr = HrCacheData( ecb,
						  pwszMDPathAccess,
						  pwszMDPathOpen,
						  pMDDataRet.load() );
		if ( FAILED(hr) )
		{
			MBTrace( "MB: CMetabase::HrGetData() - HrCacheData() failed 0x%08lX\n", hr );
			return hr;
		}
	}

	//
	//	Return the data object
	//
	Assert( pMDDataRet.get() );
	*ppMDData = pMDDataRet.relinquish();
	return S_OK;
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrOpenObject()
//
HRESULT
CMetabase::HrOpenObject( LPCWSTR pwszMDPath,
						 DWORD dwAccess,
						 DWORD dwMsecTimeout,
						 CMDObjectHandle * pmdoh )
{
	Assert(pwszMDPath);
	Assert(pmdoh);

	return pmdoh->HrOpen( m_pMSAdminBase.get(),
						  pwszMDPath,
						  dwAccess,
						  dwMsecTimeout );
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrOpenLowestNodeObject()
//

HRESULT
CMetabase::HrOpenLowestNodeObject( LPWSTR pwszMDPath,
								   DWORD dwAccess,
								   LPWSTR * ppwszMDPath,
								   CMDObjectHandle * pmdoh )
{
	Assert(pwszMDPath);
	Assert(ppwszMDPath);
	Assert(pmdoh);

	return pmdoh->HrOpenLowestNode( m_pMSAdminBase.get(),
									pwszMDPath,
									dwAccess,
									ppwszMDPath );
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrIsAuthorViaFrontPageNeeded()
//
//	Description: Function goes directly to the metabase and checks if
//				 the given path is configured as "FrontPageWeb". We need
//				 to do that via direct read from the metabase rather than
//				 going through dataset cache, as as that does not work very
//				 well due to the fact, that we are reading inherited
//				 metadata and get stuck with it.
//	Parameters:
//
//	ecb			   - interface to ecb object, that will be needed for
//					 fetching the impersonation token for that we will need
//					 to impersonate as as soon as read from metabase is finished
//	pwszMDPath	   - metabase path that we want to check out
//	pfFrontPageWeb - pointer to the booleanin which the result of operation is
//					 returned
//
HRESULT
CMetabase::HrIsAuthorViaFrontPageNeeded(const IEcb& ecb,
										LPCWSTR pwszMDPath,
										BOOL * pfFrontPageWeb)
{
	HRESULT hr = S_OK;

	CMDObjectHandle mdoh(ecb, m_pMSAdminBase.get());

	BOOL fFrontPageWeb = FALSE;
	DWORD cbData = sizeof(BOOL);

	METADATA_RECORD mdrec;

	Assert( pwszMDPath );
	Assert( pfFrontPageWeb );

	//	Assume that we do not have "FrontPageWeb" set to TRUE
	//
	*pfFrontPageWeb = FALSE;

	//	We want just explicitely set data, not inherited one
	//
	mdrec.dwMDIdentifier = MD_FRONTPAGE_WEB;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType   = IIS_MD_UT_SERVER;
	mdrec.dwMDDataType   = DWORD_METADATA;
	mdrec.dwMDDataLen    = cbData;
	mdrec.pbMDData       = reinterpret_cast<PBYTE>(&fFrontPageWeb);

	hr = mdoh.HrGetMetaData(pwszMDPath,
							&mdrec,
							&cbData);
	if (FAILED(hr))
	{
		MBTrace( "MB: CMetabase::HrIsAuthorViaFrontPageNeeded() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", hr );
		goto ret;
	}

	//	If we succeeded then we should have the value in our hands
	//
	*pfFrontPageWeb = fFrontPageWeb;

ret:

	return hr;
}

//	The way IID_IMSAdminBaseSinkW is defined in IADMW.H does
//	not work well with EXO.  So it needs to be redefined
//	here in such a way that it will work.
//
const IID IID_IMSAdminBaseSinkW = {

	0xa9e69612,
	0xb80d,
	0x11d0,
	{
		0xb9, 0xb9, 0x0, 0xa0,
		0xc9, 0x22, 0xe7, 0x50
	}
};

//	------------------------------------------------------------------------
//
//	FHasCachedIDs()
//
//	Returns TRUE if any one of the IDs rgdwDataIDs is one of the IDs that
//	we care about in CMDData::FInitialize().
//
//	!!!IMPORTANT!!! The list of IDs in this function *MUST* be kept up to
//	date with the cases in CMDData::FInitialize().
//
__inline BOOL
FHasCachedIDs( DWORD dwcDataIDs,
			   DWORD * rgdwDataIDs )
{
	for ( DWORD iID = 0; iID < dwcDataIDs; iID++ )
	{
		switch ( rgdwDataIDs[iID] )
		{
			case MD_IP_SEC:
			case MD_ACCESS_PERM:
			case MD_IS_CONTENT_INDEXED:
			case MD_FRONTPAGE_WEB:
			case MD_DIRECTORY_BROWSING:
			case MD_AUTHORIZATION:
			case MD_DEFAULT_LOAD_FILE:
			case MD_CUSTOM_ERROR:
			case MD_MIME_MAP:
			case MD_SCRIPT_MAPS:
			case MD_APP_ISOLATED:
			case MD_VR_USERNAME:
			case MD_VR_PASSWORD:
			case MD_HTTP_EXPIRES:
			case MD_SERVER_BINDINGS:
				return TRUE;
		}
	}

	return FALSE;
}

//	------------------------------------------------------------------------
//
//	CMetabase::COpNotify::operator()
//
BOOL
CMetabase::COpNotify::operator()( const DwordKey& key,
								  const auto_ref_ptr<CMDData>& pMDData )
{
	//
	//	If the path for this cache entry is a child of the path
	//	being notified, then set this entry's data set ID in the
	//	array of IDs to blow from the cache.
	//
	if ( !_wcsnicmp( m_pwszMDPathNotify,
					 pMDData->PwszMDPathDataSet(),
					 m_cchMDPathNotify ) )
	{
		Assert (m_iCacheEntry < m_cCacheEntry);
		m_rgdwDataSets[m_iCacheEntry] = pMDData->DwDataSet();
		m_fDataSetsFlagged = TRUE;
	}

	++m_iCacheEntry;

	//
	//	ForEach() operators can cancel the iteration by returning FALSE.
	//	We always want to iterate over everything so return TRUE
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CMetabase::OnNotify()
//
VOID
CMetabase::OnNotify( DWORD cCO,
					 MD_CHANGE_OBJECT_W rgCO[] )
{
	INT cCacheEntries;
	CStackBuffer<DWORD> rgdwDataSets;
	BOOL fDataSetsFlagged;

	//
	//	Grab a read lock on the cache and go through it
	//	figuring out which items we want to blow away.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);

		cCacheEntries = m_cache.CItems();
		if (!rgdwDataSets.resize(sizeof(DWORD) * cCacheEntries))
			return;

		memset(rgdwDataSets.get(), 0, sizeof(DWORD) * cCacheEntries);
		COpNotify opNotify(cCacheEntries, rgdwDataSets.get());
		for ( DWORD iCO = 0; iCO < cCO; iCO++ )
		{
			LPWSTR pwszMDPath = reinterpret_cast<LPWSTR>(rgCO[iCO].pszMDPath);

			//	Quick litmus test: ignore any change that is not
			//	related to anything that we would ever cache -- i.e.
			//	anything that is not one of the following:
			//
			//	- The global mimemap (LM/MimeMap)
			//	- Anything in the W3SVC tree (LM/W3SVC/...)
			//
			//	Also ignore MD_CHANGE_TYPE_ADD_OBJECT notifications --
			//	even in combination with other notifications.  We simply
			//	don't care when something is added because we always
			//	read from the metabase when we don't find an item in
			//	the cache.
			//
			//	Finally, ignore changes to any data that isn't interesting
			//	to us -- i.e. that we don't cache.
			//
			if ( (!_wcsnicmp(gc_wsz_Lm_MimeMap, pwszMDPath, gc_cch_Lm_MimeMap) ||
				  !_wcsnicmp(gc_wsz_Lm_W3Svc, pwszMDPath, gc_cch_Lm_W3Svc - 1)) &&

				 !(rgCO[iCO].dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT) &&

				 FHasCachedIDs( rgCO[iCO].dwMDNumDataIDs,
								rgCO[iCO].pdwMDDataIDs ) )
			{
				//
				//	Flag each entry in the cache whose data set corresponds
				//	to a path that is a child of the one being notified.
				//
				MBTrace ("MB: cache: flagging '%S' as dirty\n", pwszMDPath);
				opNotify.Configure( pwszMDPath );

				m_cache.ForEach( opNotify );
			}
		}

		fDataSetsFlagged = opNotify.FDataSetsFlagged();
	}

	//
	//	If any data sets were flagged in our pass above then
	//	grab a write lock now and blow `em away.
	//
	//	Note: we don't care about any change to the cache between the
	//	time we sweep above and now.  If data sets are culled,
	//	and even re-added, between then and now, that's fine.
	//	The worst thing that this does is cause them to be
	//	faulted in again.  On the flip side, any new data sets
	//	brought into the cache after our pass above by definition
	//	has more recent data, so there is no possibility of
	//	missing any cached entries and ending up with stale data.
	//
	if ( fDataSetsFlagged )
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		for ( INT iCacheEntry = 0;
			  iCacheEntry < cCacheEntries;
			  iCacheEntry++ )
		{
			if ( rgdwDataSets[iCacheEntry] )
				m_cache.Remove( DwordKey(rgdwDataSets[iCacheEntry]) );
		}
	}
}

//	========================================================================
//
//	CLASS CNotifSink
//

//	------------------------------------------------------------------------
//
//	CNotifSink::SinkNotify()
//
//	Metabase change notification callback
//
HRESULT STDMETHODCALLTYPE
CNotifSink::SinkNotify(/* [in] */ DWORD dwMDNumElements,
					   /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ])
{
	OnNotify( dwMDNumElements,
			  pcoChangeList );

	return S_OK;
}

VOID
CNotifSink::OnNotify( DWORD cCO,
					  MD_CHANGE_OBJECT_W rgCO[] )
{
	//	Trace out the information with which we have been called
	//
#ifdef DBG

	MBTrace("MB: CNotifSink::OnNotify() - TID %3d: MD_CHANGE_OBJECT_W array length 0x%08lX\n", GetCurrentThreadId(), cCO );

	for ( DWORD idwElem = 0; idwElem < cCO; idwElem++ )
	{
		MBTrace("   Element %d:\n", idwElem );
		MBTrace("      pszMDPath '%S'\n", rgCO[idwElem].pszMDPath );
		MBTrace("      dwMDChangeType 0x%08lX\n", rgCO[idwElem].dwMDChangeType );
		MBTrace("      dwMDNumDataIDs 0x%08lX\n", rgCO[idwElem].dwMDNumDataIDs );
		for (DWORD idwID = 0; idwID < rgCO[idwElem].dwMDNumDataIDs; idwID++)
		{
			MBTrace("         pdwMDDataIDs[%d] is 0x%08lX\n", idwID, rgCO[idwElem].pdwMDDataIDs[idwID] );
		}
	}

#endif

	CMetabase::Instance().OnNotify( cCO,
									rgCO );

	CChildVRCache::Instance().OnNotify( cCO,
										rgCO );

}

//	========================================================================
//
//	FREE Functions
//

BOOL
FMDInitialize()
{
	//	Instantiate the CMetabase object and initialize it.
	//	Note that if initialization fails, we don't destroy
	//	the instance.  MDDeinitialize() must still be called.
	//
	return CMetabase::CreateInstance().FInitialize();
}

VOID
MDDeinitialize()
{
	CMetabase::DestroyInstance();
}

//	------------------------------------------------------------------------
//
//	In the future we might need Copy/Rename/Delete operations
//	on metabase objects.
//	For Copy following steps should apply:
//		a) Lock dst
//		b) Kick dst and children out of cache
//		c) Copy the raw metadata
//		d) Unlock dst
//		e) Send update notifications
//
//	For Rename:
//		a) Lock common parent of src and dst
//		b) Kick dst and children out of cache
//		c) Rename src to dst
//		d) Kick src and children out of cache
//		e) Unlock common parent of src and dst
//		f) Send update notifications
//	For Delete:
//		a) Lock path
//		b) Kick path and children out of cache
//		c) Unlock path
//		d) Send update notifications

//	------------------------------------------------------------------------
//
//	HrMDGetData()
//
//	Intended primarily for use by impls.  This call fetches the metadata
//	for the specified URI.  If the URI is the request URI then this
//	function uses the copy of the metadata cached on the ecb.  This saves
//	a cache lookup (and read lock) in the majority of cases.
//
HRESULT
HrMDGetData( const IEcb& ecb,
			 LPCWSTR pwszURI,
			 IMDData ** ppMDData )
{
	SCODE sc = S_OK;
	auto_heap_ptr<WCHAR> pwszMDPathURI;
	auto_heap_ptr<WCHAR> pwszMDPathOpenOnHeap;
	LPWSTR pwszMDPathOpen;

	//
	//	If the URI is the request URI then we already have the data cached.
	//
	//	Note that we only test for pointer equality here because
	//	typically callers will pass in THE request URI from
	//	the ECB rather than a copy of it.
	//
	if ( ecb.LpwszRequestUrl() == pwszURI )
	{
		*ppMDData = &ecb.MetaData();

		Assert (*ppMDData);
		(*ppMDData)->AddRef();

		goto ret;
	}

	//
	//	Map the URI to its equivalent metabase path, and make sure
	//	the URL is stripped before we call into the MDPath processing
	//
	Assert (pwszURI == PwszUrlStrippedOfPrefix (pwszURI));

	pwszMDPathURI = static_cast<LPWSTR>(ExAlloc(CbMDPathW(ecb, pwszURI)));
	if (NULL == pwszMDPathURI.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	MDPathFromURIW(ecb, pwszURI, pwszMDPathURI);
	pwszMDPathOpen = const_cast<LPWSTR>(ecb.PwszMDPathVroot());

	//	If the URI requested is in NOT in the current request's vroot,
	//	start the metabase search from the virtual server root.
	//
	if (_wcsnicmp(pwszMDPathURI, pwszMDPathOpen, wcslen(pwszMDPathOpen)))
	{
		pwszMDPathOpenOnHeap = static_cast<LPWSTR>(ExAlloc(CbMDPathW(ecb, L"")));
		if (NULL == pwszMDPathOpenOnHeap.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		pwszMDPathOpen = pwszMDPathOpenOnHeap.get();

		MDPathFromURIW(ecb, L"", pwszMDPathOpen);
	}

	//
	//	Fetch and return the metadata
	//
	sc = CMetabase::Instance().HrGetData( ecb,
										  pwszMDPathURI,
										  pwszMDPathOpen,
										  ppMDData );

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	HrMDGetData()
//
//	Fetch metadata for the specified metabase path.
//
HRESULT
HrMDGetData( const IEcb& ecb,
			 LPCWSTR pwszMDPathAccess,
			 LPCWSTR pwszMDPathOpen,
			 IMDData ** ppMDData )
{
	return CMetabase::Instance().HrGetData( ecb,
											pwszMDPathAccess,
											pwszMDPathOpen,
											ppMDData );
}

//	------------------------------------------------------------------------
//
//	DwMDChangeNumber()
//
//	Get the metabase change number .
//
DWORD
DwMDChangeNumber()
{
	return CMetabase::Instance().DwChangeNumber();
}

//	------------------------------------------------------------------------
//
//	HrMDOpenMetaObject()
//
//	Open a metadata object, given a path
//
HRESULT
HrMDOpenMetaObject( LPCWSTR pwszMDPath,
					DWORD dwAccess,
					DWORD dwMsecTimeout,
					CMDObjectHandle * pmdoh )
{
	return CMetabase::Instance().HrOpenObject( pwszMDPath,
											   dwAccess,
											   dwMsecTimeout,
											   pmdoh );
}

HRESULT
HrMDOpenLowestNodeMetaObject( LPWSTR pwszMDPath,
							  DWORD dwAccess,
							  LPWSTR * ppwszMDPath,
							  CMDObjectHandle * pmdoh )
{
	return CMetabase::Instance().HrOpenLowestNodeObject( pwszMDPath,
														 dwAccess,
														 ppwszMDPath,
														 pmdoh );
}


HRESULT
HrMDIsAuthorViaFrontPageNeeded(const IEcb& ecb,
							   LPCWSTR pwszURI,
							   BOOL * pfFrontPageWeb)
{
	return CMetabase::Instance().HrIsAuthorViaFrontPageNeeded( ecb,
															   pwszURI,
															   pfFrontPageWeb );
}

//	class CMetaOp -------------------------------------------------------------
//
SCODE __fastcall
CMetaOp::ScEnumOp (LPWSTR pwszMetaPath, UINT cch)
{
	Assert (cch <= METADATA_MAX_NAME_LEN);

	DWORD dwIndex = 0;
	LPWSTR pwszKey;
	SCODE sc = S_OK;

	//	First and formost, call out on the key handed in
	//
	MBTrace ("MB: CMetaOp::ScEnumOp(): calling op() on '%S'\n", pwszMetaPath);
	sc = ScOp (pwszMetaPath, cch);
	if (FAILED (sc))
		goto ret;

	//	If the Op() returns S_FALSE, that means the operation
	//	knows enough that it does not have to be called for any
	//	more metabase paths.
	//
	if (S_FALSE == sc)
		goto ret;

	//	Then enumerate all the child nodes and recurse.  To do
	//	this, we are going use the fact that we have been passed
	//	a buffer big enough to handle CCH_BUFFER_SIZE chars.
	//
	Assert ((cch + 1 + METADATA_MAX_NAME_LEN) <= CCH_BUFFER_SIZE);
	pwszKey = pwszMetaPath + cch;
	*(pwszKey++) = L'/';
	*pwszKey = L'\0';

	while (TRUE)
	{
		//	Enum the next key in the set of child keys, and process it.
		//
		sc = m_mdoh.HrEnumKeys (pwszMetaPath, pwszKey, dwIndex);
		if (FAILED (sc))
		{
			sc = S_OK;
			break;
		}

		//	Recurse on the new path.
		//
		Assert (wcslen(pwszKey) <= METADATA_MAX_NAME_LEN);
		sc = ScEnumOp (pwszMetaPath, cch + 1 + static_cast<UINT>(wcslen(pwszKey)));
		if (FAILED (sc))
			goto ret;

		//	If the EnumOp() returns S_FALSE, that means the operation
		//	knows enough that it does not have to be called for any
		//	more metabase paths.
		//
		if (S_FALSE == sc)
			goto ret;

		//	Increment the index to make sure the traversing continues
		//
		dwIndex++;

		//	Truncate the metapath again
		//
		*pwszKey = 0;
	}

ret:
	return sc;
}

SCODE __fastcall
CMetaOp::ScMetaOp()
{
	auto_heap_ptr<WCHAR> prgwchMDPaths;
	SCODE sc = S_OK;

	//	Initialize the metabase
	//
	sc = HrMDOpenMetaObject( m_pwszMetaPath,
							 m_fWrite ? METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE : METADATA_PERMISSION_READ,
							 5000,
							 &m_mdoh );
	if (FAILED (sc))
	{
		//	If the path is not found, then it really is
		//	not a problem...
		//
		if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc)
		{
			MBTrace ("MB: CMetaOp::ScMetaOp(): '%S' does not exist\n", m_pwszMetaPath);
			return S_OK;
		}

		DebugTrace ("Dav: MCD: unable to initialize metabase\n");
		return sc;
	}

	//	Get the set of paths for which the metabase property
	//	is explicitly specified.
	//
	//	Since the size of the buffer needed to hold the paths
	//	is initially unknown, guess at a reasonable size.  If
	//	it's not large enough, then then we will fallback to
	//	iterating throught the tree.
	//
	//	Either way, for each directory where the value is set
	//	explicitly, the call to ScOp() will be called (and in
	//	the fallback scenario, sometimes it won't be set).
	//
	prgwchMDPaths = static_cast<LPWSTR>(g_heap.Alloc(CCH_BUFFER_SIZE * sizeof(WCHAR)));
	DWORD cchMDPaths = CCH_BUFFER_SIZE;

	sc = m_mdoh.HrGetDataPaths( L"",
								m_dwId,
								m_dwType,
								prgwchMDPaths,
								&cchMDPaths );
	if (FAILED(sc))
	{
		//	Ok, this is the fallback position...
		//
		MBTrace ("MB: CMetaOp::ScMetaOp(): falling back to enumeration for op()\n");
		//
		//	We want to enumerate all the possible metabase paths and call
		//	the sub-op for each.  In this scenario, the sub-op is must be
		//	able to handle the case where the value is not explicitly set.
		//
		//	We are first going to copy the metapath into our buffer from
		//	above and pass it in so that we can use it and not have to
		//	do any real allocations.
		//
		*prgwchMDPaths = 0;
		sc = ScEnumOp (prgwchMDPaths, 0);

		//	Error or failure - we are done with processing this
		//	request.
		//
		goto ret;
	}
	else
	{
		//	Woo hoo.  The number/size of the paths all fit within
		//	the initial buffer!
		//
		//	Go ahead and call the sub-op for each of these paths
		//
		LPCWSTR pwsz = prgwchMDPaths;
		while (*pwsz)
		{
			MBTrace ("MB: CMetaOp::ScMetaOp(): calling op() on '%S'\n", pwsz);

			//	Call the sub-op.  The sub-op is responsible for
			//	handling all possible errors, but can pass back
			//	any terminating errors.
			//
			UINT cch = static_cast<UINT>(wcslen (pwsz));
			sc = ScOp (pwsz, cch);
			if (FAILED (sc))
				goto ret;

			//	If the Op() returns S_FALSE, that means the operation
			//	knows enough that it does not have to be called for any
			//	more metabase paths.
			//
			if (S_FALSE == sc)
				goto ret;

			//	Move to the next metapath
			//
			pwsz += cch + 1;
		}

		//	All the explict paths have been processed. We are done
		//	with processing this request.
		//
		goto ret;
	}

ret:

	//	Close up the metabase regardless
	//
	m_mdoh.Close();
	return sc;
}

//	------------------------------------------------------------------------
//
//	FParseMDData()
//
//	Parses a comma-delimited metadata string into fields.  Any whitespace
//	around the delimiters is considered insignificant and removed.
//
//	Returns TRUE if the data parsed into the expected number of fields
//	and FALSE otherwise.
//
//	Pointers to the parsed are returned in rgpwszFields.  If a string
//	parses into fewer than the expected number of fields, NULLs are
//	returned for all of the fields beyond the last one parsed.
//
//	If a string parses into the expected number of fields then
//	the last field is always just the remainder of the string beyond
//	the second to last field, regardless whether the string could be
//	parsed into additional fields.  For example "  foo , bar ,  baz  "
//	parses into three fields as "foo", "bar" and "baz", but parses
//	into two fields as "foo" and "bar ,  baz"
//
//	The total number of characters in pwszData, including the null
//	terminator, is also returned in *pcchData.
//
//	Note: this function MODIFIES pwszData.
//
BOOL
FParseMDData( LPWSTR pwszData,
			  LPWSTR rgpwszFields[],
			  UINT cFields,
			  UINT * pcchData )
{
	Assert( pwszData );
	Assert( pcchData );
	Assert( cFields > 0 );
	Assert( !IsBadWritePtr(rgpwszFields, cFields * sizeof(LPWSTR)) );

	//	Clear our "out" parameter
	//
	memset(rgpwszFields, 0, sizeof(LPWSTR) * cFields);

	WCHAR * pwchDataEnd = NULL;
	LPWSTR pwszField = pwszData;
	BOOL fLastField = FALSE;

	UINT iField = 0;

	while (!fLastField)
	{
		WCHAR * pwch;

		//
		//	Strip leading WS
		//
		while ( *pwszField && L' ' == *pwszField )
			++pwszField;

		if ( !*pwszField )
			break;

		//
		//	Locate the delimiter following the field.
		//	For all fields but the last field the delimiter
		//	is a ','.  For the last field, the "delimiter"
		//	is the terminating null.
		//
		if ( cFields - 1 == iField )
		{
			pwch = pwszField + wcslen(pwszField);
			fLastField = TRUE;
		}
		else
		{
			pwch = wcschr(pwszField, L',');
			if ( NULL == pwch )
			{
				//
				//	If we don't find a comma after the field
				//	then it is the last field.
				//
				pwch = pwszField + wcslen(pwszField);
				fLastField = TRUE;
			}
		}

		//	At this point we should have found a comma
		//	or the null terimator after the field.
		//
		Assert( pwch );

		pwchDataEnd = pwch;

		//
		//	Eat trailing whitespace at the end of the
		//	field up to the delimiter we just found
		//	by backing up from the delimiter's position
		//	and null-terminating the field after the
		//	last non-whitespace character.
		//
		while ( pwch-- > pwszField && L' ' == *pwch )
			;

		*++pwch = '\0';

		//
		//	Fill in the pointer to this field
		//
		rgpwszFields[iField] = pwszField;

		//
		//	Proceed to the next field
		//
		pwszField = pwchDataEnd + 1;
		++iField;
	}

	Assert( pwchDataEnd > pwszData );

	*pcchData = static_cast<UINT>(pwchDataEnd - pwszData + 1);

	return iField == cFields;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\header.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HEADER.CPP
//
//		HTTP header cache implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <buffer.h>
#include "header.h"
#include <tchar.h>


//	========================================================================
//
//	CLASS CHeaderCache
//



//	------------------------------------------------------------------------
//
//	CHeaderCacheForResponse::DumpData()
//	CHeaderCacheForResponse::CEmit::operator()
//
//		Dump headers to a string buffer.
//
void CHeaderCacheForResponse::DumpData( StringBuffer<CHAR>& bufData ) const
{
	CEmit emit(bufData);

	//	Iterate over all cache items, emitting each to our buffer
	//	The cache controls the iteration here; we just provide
	//	the operation to apply to each iterated item.
	//
	m_cache.ForEach( emit );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\evtlog.h ===
#ifndef _EVTLOG_H_
#define _EVTLOG_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EVTLOG.H
//
//		Header for event log cache class.
//		This cache is meant to serve as a map. indexes on the event key.
//		we really don't care the concrete value, but only it is NULL or not
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CEventLogCache
//
#include "gencache.h"
class CEventLogCache
{
	typedef CCache<CRCSzi, LPCSTR> CHdrCache;

	// String data storage area.
	//
	ChainedStringBuffer<char>	m_sb;

	// Cache of header values, keyed by CRC'd name
	//
	CHdrCache					m_cache;

	//	NOT IMPLEMENTED
	//
	CEventLogCache& operator=( const CEventLogCache& );
	CEventLogCache( const CEventLogCache& );

public:
	//	CREATORS
	//
	CEventLogCache()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();
	}

	//	ACCESSORS
	//
	BOOL FExist( LPCSTR lpszName );

	//	MANIPULATORS
	void AddKey (LPCSTR lpszName);
};

#endif // !_EVTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\ecb.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ECB.CPP
//
//	Implementation of CEcb methods and non-member functions
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "ecb.h"
#include "instdata.h"
#include "ecbimpl.h"

//	========================================================================
//
//	CLASS IEcb
//

//	------------------------------------------------------------------------
//
//	IEcb::~IEcb()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class.
//
IEcb::~IEcb()
{
}


#ifdef DBG	// ECB logging

const CHAR gc_szDbgECBLogging[] = "ECB Logging";

//	========================================================================
//
//	CLASS CEcbLog (DBG only)
//
class CEcbLog : private Singleton<CEcbLog>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CEcbLog>;

	//
	//	Critical section to serialize writes to
	//	the log file
	//
	CCriticalSection	m_cs;

	//
	//	Handle to the log file
	//
	auto_handle<HANDLE>	m_hfLog;

	//
	//	Monotonically increasing unique identifier
	//	for ECB logging;
	//
	LONG				m_lMethodID;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CEcbLog();

	//	NOT IMPLEMENTED
	//
	CEcbLog( const CEcbLog& );
	CEcbLog& operator=( const CEcbLog& );

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CEcbLog>::CreateInstance;
	using Singleton<CEcbLog>::DestroyInstance;

	static void LogString( const EXTENSION_CONTROL_BLOCK * pecb,
						   LONG   lMethodID,
						   LPCSTR szLocation );

	static LONG LNextMethodID();
};


//	------------------------------------------------------------------------
//
//	CEcbLog::CEcbLog()
//
CEcbLog::CEcbLog() :
	m_lMethodID(0)
{
	CHAR rgch[MAX_PATH];

	//	Init our ECB log file.
	if (GetPrivateProfileString( gc_szDbgECBLogging,
								 gc_szDbgLogFile,
								 "",
								 rgch,
								 sizeof(rgch),
								 gc_szDbgIni ))
	{
		m_hfLog = CreateFile( rgch,
							  GENERIC_WRITE,
							  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_SEQUENTIAL_SCAN
							  NULL );
	}
	else
		m_hfLog = INVALID_HANDLE_VALUE;
}

//	------------------------------------------------------------------------
//
//	CEcbLog::LogString()
//
void
CEcbLog::LogString( const EXTENSION_CONTROL_BLOCK * pecb,
					LONG   lMethodID,
					LPCSTR szLocation )
{
	if ( INVALID_HANDLE_VALUE == Instance().m_hfLog )
		return;

	Assert( pecb );

	CHAR rgch[MAX_PATH];
	int cch;

	//	Dump a line to the log:
	//	Thread: <tid> pECB <ecb> MethodID: <id> <meth name> <szLocation>
	//
	cch = wsprintfA( rgch, "Thread: %08x pECB: 0x%08x MethodID: 0x%08x %hs %hs %hs\n",
					 GetCurrentThreadId(), pecb, lMethodID,
					 gc_szSignature, pecb->lpszMethod, szLocation );

	DWORD cbActual;
	CSynchronizedBlock sb(Instance().m_cs);

	WriteFile( Instance().m_hfLog,
			   rgch,
			   cch,
			   &cbActual,
			   NULL );
}

//	------------------------------------------------------------------------
//
//	CEcbLog::LNextMethodID()
//
LONG
CEcbLog::LNextMethodID()
{
	return InterlockedIncrement(&Instance().m_lMethodID);
}

void InitECBLogging()
{
	CEcbLog::CreateInstance();
}

void DeinitECBLogging()
{
	CEcbLog::DestroyInstance();
}

#endif // DBG ECB logging


//	========================================================================
//
//	CLASS IIISAsyncIOCompleteObserver
//

//	------------------------------------------------------------------------
//
//	IIISAsyncIOCompleteObserver::~IIISAsyncIOCompleteObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IIISAsyncIOCompleteObserver::~IIISAsyncIOCompleteObserver() {}


//	========================================================================
//
//	CLASS CAsyncErrorResponseInterlock
//
class CAsyncErrorResponseInterlock
{
	enum
	{
		STATE_ENABLED,
		STATE_DISABLED,
		STATE_TRIGGERED
	};

	//	Interlock state
	//
	LONG m_lState;

	//	NOT IMPLEMENTED
	//
	CAsyncErrorResponseInterlock( const CAsyncErrorResponseInterlock& );
	CAsyncErrorResponseInterlock& operator=( const CAsyncErrorResponseInterlock& );

public:
	CAsyncErrorResponseInterlock() :
		m_lState(STATE_ENABLED)
	{
	}

	//	------------------------------------------------------------------------
	//
	//	CAsyncErrorResponseInterlock::FDisable()
	//
	//	Tries to disable the interlock.  Returns TRUE if successful; subsequent
	//	calls to FTrigger() will return FALSE.
	//
	BOOL FDisable()
	{
		//	Return TRUE if the lock is already disabled OR if the lock is
		//	still enabled and we succeeded in disabling it.  Return FALSE
		//	otherwise.
		//
		return STATE_DISABLED == m_lState ||
			   (STATE_ENABLED == m_lState &&
				STATE_ENABLED == InterlockedCompareExchange(
									&m_lState,
									STATE_DISABLED,
									STATE_ENABLED));
	}

	//	------------------------------------------------------------------------
	//
	//	CAsyncErrorResponseInterlock::FTrigger()
	//
	//	Tries to trigger the interlock.  Returns TRUE if successful; subsequent
	//	calls to FDisable() will return FALSE.
	//
	BOOL FTrigger()
	{
		//	We can only trigger the lock once.
		//
		Assert(STATE_TRIGGERED != m_lState);

		//	Return TRUE if the lock is still enabled and we succeed in
		//	triggering it.  Return FALSE otherwise.
		//
		return STATE_ENABLED == m_lState &&
			   STATE_ENABLED == InterlockedCompareExchange(
									&m_lState,
									STATE_TRIGGERED,
									STATE_ENABLED);
	}
};

//	========================================================================
//
//	CLASS CEcb
//
//		Implementation of the caching ECB
//
class CEcb : public CEcbBaseImpl<IEcb>
{	
	//	Cached user impersonation token
	//
	mutable HANDLE m_hTokUser;

	//
	//  Did we have to modify the m_hTokUser to take Universal Security Groups into
	//  account?  If so, store the information in m_ptmcUSG.
	//
	mutable VOID * m_pTokCtx;

	//	Cached instance data -- owned by the instance cache,
	//	not us, so don't free it (not an auto-ptr!!).
	//
	mutable CInstData * m_pInstData;

	//	Cached HTTP version (e.g. "HTTP/1.1")
	//
	mutable CHAR			m_rgchVersion[10];

	//	Cached Connection: header
	//
	mutable auto_heap_ptr<WCHAR> m_pwszConnectionHeader;

	//	Cached metadata
	//
	auto_ref_ptr<IMDData> m_pMD;

	//	State in which we leave the connection
	//	when we're done.
	//
	mutable enum
	{
		UNKNOWN,	// Don't know yet
		CLOSE,		// Close it
		KEEP_ALIVE	// Keep it open

	} m_connState;

	//	Brief'ness
	//
	enum { BRIEF_UNKNOWN = -1, BRIEF_NO, BRIEF_YES };
	mutable LONG m_lBrief;

	//	Acceptable transfer coding method:
	//
	//	TC_UNKNOWN  - Acceptable transfer coding has not yet been determined.
	//	TC_CHUNKED  - Chunked transfer coding is acceptable.
	//	TC_IDENTITY - No transfer coding is acceptable.
	//
	mutable TRANSFER_CODINGS m_tcAccepted;

	//	Authentication State information:
	//		Bit		Means
	//		============================
	//		31		Queried against ECB
	//		30-4	Unused
	//		3		Kerberos
	//		2		NTLM
	//		1		Basic
	//		0		Authenticated

	mutable DWORD			m_rgbAuthState;

	//	Init flag set to TRUE once we've registered our
	//	I/O completion routine with IIS.
	//
	enum { NO_COMPLETION, IO_COMPLETION, CUSTERR_COMPLETION, EXECURL_COMPLETION };
	LONG m_lSetIISIOCompleteCallback;

	//	Flag stating whether a child ISAPI has been successfully executed.  If this is the
	//	case, we don't want to reset dwHttpStatusCode later or we will lose whatever
	//	status code they set.
	//
	BOOL m_fChildISAPIExecSuccess;

	//
	//	Interlock used to prevent a race condition between a thread
	//	sending a normal response and a thread sending an error in response
	//	to an async event such as an exception or epoxy shutdown.
	//
	CAsyncErrorResponseInterlock m_aeri;

	//	Status string for async custom error response.
	//	Format "nnn reason".
	//
	auto_heap_ptr<CHAR> m_pszStatus;

	//
	//	Refcount to track number of outstanding async I/O operations.
	//	There should never be more than one.
	//
	LONG m_cRefAsyncIO;

	//
	//	Pointer to the current async I/O completion observer
	//
	IIISAsyncIOCompleteObserver * m_pobsAsyncIOComplete;

#ifdef DBG
	LONG					m_lEcbLogMethodID;
#endif

	//	ECB tracing (not to be confused with ECB logging!)
	//
#ifdef DBG
	void TraceECB() const;
#else
	void TraceECB() const {}
#endif

	//
	//	Async I/O
	//
	SCODE ScSetIOCompleteCallback(LONG lCompletion);
	static VOID WINAPI IISIOComplete( const EXTENSION_CONTROL_BLOCK * pecbIIS,
									  CEcb *	pecb,
									  DWORD		dwcbIO,
									  DWORD		dwLastError );
	static VOID WINAPI CustomErrorIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
												CEcb *	pecb,					
												DWORD   dwcbIO,
												DWORD   dwLastError );
	static VOID WINAPI ExecuteUrlIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
											   CEcb *	pecb,
											   DWORD    dwcbIO,
											   DWORD    dwLastError );

	//	NOT IMPLEMENTED
	//
	CEcb( const CEcb& );
	CEcb& operator=( const CEcb& );

	SCODE ScSyncExecuteChildWide60Before( LPCWSTR pwszUrl,
										  LPCSTR pszQueryString,
										  BOOL fCustomErrorUrl );

	SCODE ScAsyncExecUrlWide60After( LPCWSTR pwszUrl,
									 LPCSTR pszQueryString,
									 BOOL fCustomErrorUrl );

			
public:

	CEcb( EXTENSION_CONTROL_BLOCK& ecb );
	BOOL FInitialize( BOOL fUseRawUrlMappings );
	~CEcb();

	//	URL prefix
	//
	UINT CchUrlPortW( LPCWSTR * ppwszPort ) const;

	//	Instance data access
	//
	CInstData& InstData() const;

	//	Impersonation token access
	//
	HANDLE HitUser() const;

	//	ACCESSORS
	//
	LPCSTR LpszVersion() const;
	BOOL FKeepAlive() const;
	BOOL FCanChunkResponse() const;
	BOOL FAuthenticated() const;
	BOOL FProcessingCEUrl() const;

	BOOL FIIS60OrAfter() const
	{
		return (m_pecb->dwVersion >= IIS_VERSION_6_0);
	}

	BOOL FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei );

	SCODE ScAsyncRead( BYTE * pbBuf,
					   UINT * pcbBuf,
					   IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncWrite( BYTE * pbBuf,
						DWORD  dwcbBuf,
						IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
							   IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
									 LPSTR pszStatus );

	SCODE ScAsyncExecUrl60After( const HSE_EXEC_URL_INFO& eui );

	SCODE ScExecuteChild( LPCWSTR pwszURI, LPCSTR pszQueryString, BOOL fCustomErrorUrl )
	{
		//	IIS 6.0 or after has a different way of executing child
		//	
		if (m_pecb->dwVersion >= IIS_VERSION_6_0)
		{
			return ScAsyncExecUrlWide60After (pwszURI, pszQueryString, fCustomErrorUrl);
		}
		else
		{
			return ScSyncExecuteChildWide60Before (pwszURI, pszQueryString, fCustomErrorUrl);
		}
	}

	SCODE ScSendRedirect( LPCSTR lpszURI );

	IMDData& MetaData() const
	{
		Assert( m_pMD.get() );
		return *m_pMD;
	}

	BOOL FBrief () const;

	LPCWSTR PwszMDPathVroot() const
	{
		Assert( m_pInstData );
		return m_pInstData->GetNameW();
	}

#ifdef DBG
	virtual void LogString( LPCSTR lpszLocation ) const
	{
		if ( DEBUG_TRACE_TEST(ECBLogging) )
			CEcbLog::LogString( m_pecb, m_lEcbLogMethodID, lpszLocation );
	}
#endif

	//	MANIPULATORS
	//
	VOID SendAsyncErrorResponse( DWORD dwStatusCode,
								 LPCSTR pszStatusDescription,
								 DWORD cchzStatusDescription,
								 LPCSTR pszBody,
								 DWORD cchzBody );

	DWORD HSEHandleException();

	//	Session handling
	//
	VOID DoneWithSession( BOOL fKeepAlive );

	//	To be used ONLY by request/response.
	//
	void SetStatusCode( UINT iStatusCode );
	void SetConnectionHeader( LPCWSTR pwszValue );
	void SetAcceptLanguageHeader( LPCSTR pszValue );
	void CloseConnection();
};


//	------------------------------------------------------------------------
//
//	CEcb Constructor/Destructor
//
CEcb::CEcb( EXTENSION_CONTROL_BLOCK& ecb ) :
   CEcbBaseImpl<IEcb>(ecb),
   m_hTokUser(NULL),
   m_pTokCtx(NULL),
   m_pInstData(NULL),
   m_connState(UNKNOWN),
   m_tcAccepted(TC_UNKNOWN),
   m_rgbAuthState(0),
   m_cRefAsyncIO(0),
   m_lSetIISIOCompleteCallback(NO_COMPLETION),
   m_fChildISAPIExecSuccess(FALSE),
   m_lBrief(BRIEF_UNKNOWN)
{
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		m_lEcbLogMethodID = CEcbLog::LNextMethodID();
#endif

	//	Auto-pointers will be init'd by their own ctors.
	//

	//	Zero the first char of the m_rgchVersion.
	//
	*m_rgchVersion = '\0';

	//	Clear out the status code in the EXTENSION_CONTROL_BLOCK so that
	//	we will be able to tell whether we should try to send a 500
	//	Server Error response in the event of an exception.
	//
	SetStatusCode(0);

	//	Set up our instance data now.  We need it for the perf counters below.
	//
	m_pInstData = &g_inst.GetInstData( *this );

	//	The ECB exactly scopes the lifetime of the handling of the request,
	//	so use it to drive the perf counter that tracks the
	//	number of requests concurrently being processed.
	//
	IncrementInstancePerfCounter( *m_pInstData, IPC_CURRENT_REQUESTS_EXECUTING );

	//	And trace out the ECB info (If we're debug, if we're tracing....)
	//
	TraceECB();
}

//	------------------------------------------------------------------------
//
//	CEcb::FInitialize()
//
BOOL
CEcb::FInitialize( BOOL fUseRawUrlMappings )
{
	auto_heap_ptr<WCHAR>	pwszMDUrlOnHeap;
			
	//
	//	Fault in a few things like the vroot (LPSTR) and its length
	//	and the corresponding path information.
	//	The mapex info is already "faulted in" during the CEcb constructor.
	//	(ctor calls GetInstData, which calls CEcbBaseImpl<>::GetMapExInfo)
	//	However, fault in other pieces, like our translated request URI
	//	and our MD path.
	//

	//
	//	Cache the metabase paths for both the vroot and the request URI.
	//
	//	Note that the metabase path for the vroot is just the instance name.
	//
	//	Special case: If '*' is the request URI.
	//
	//	IMPORTANT: this is only valid for an OPTIONS request.  The handling
	//	of the validitiy of the request is handled later.  For now, lookup
	//	the data for the default site root.
	//
	//	IMPORTANT:
	//	LpszRequestUrl() will return FALSE in the case of a bad URL (in
	//	DAVEX, if the ScNormalizeUrl() call fails).  If that happens,
	//	set our status code to HSC_BAD_REQUEST and return FALSE from here.
	//	The calling code (NewEcb()) will handle this gracefully.
	//
	LPCWSTR pwszRequestUrl = LpwszRequestUrl();
	if (!pwszRequestUrl)
	{
		SetStatusCode(HSC_BAD_REQUEST);
		return FALSE;
	}

	LPCWSTR pwszMDUrl;
	if ( L'*'  == pwszRequestUrl[0] &&
		 L'\0' == pwszRequestUrl[1] )
	{
		pwszMDUrl = PwszMDPathVroot();
	}
	else
	{
		pwszMDUrlOnHeap = static_cast<LPWSTR>(ExAlloc(CbMDPathW(*this, pwszRequestUrl)));
		if (NULL == pwszMDUrlOnHeap.get())
			return FALSE;

		pwszMDUrl = pwszMDUrlOnHeap.get();
		MDPathFromURIW( *this, pwszRequestUrl, const_cast<LPWSTR>(pwszMDUrl) );
	}

	//
	//$REVIEW	It would be nice to propagate out the specific HRESULT
	//$REVIEW	so that we could send back an appropriate suberror,
	//$REVIEW	but sending a suberror could be difficult if we can't
	//$REVIEW	get to the metadata that contains the suberror mappings....
	//
	return SUCCEEDED(HrMDGetData( *this,
								  pwszMDUrl,
								  PwszMDPathVroot(),
								  m_pMD.load() ));
}

//	------------------------------------------------------------------------
//
//	CEcb::~CEcb()
//
CEcb::~CEcb()
{
	//
	//	If we've already given back the EXTENSION_CONTROL_BLOCK then
	//	we don't need to do anything else here.  Otherwise we should
	//	return it (call HSE_REQ_DONE_WITH_SESSION) with the appropriate
	//	keep-alive.
	//
	if ( m_pecb )
	{
		//
		//	At this point someone should have generated a response,
		//	even in the case of an exception (see HSEHandleException()).
		//
		Assert( m_pecb->dwHttpStatusCode != 0 );

		//
		//	Tell IIS that we're done for this request.
		//
		DoneWithSession( FKeepAlive() );
	}
}

//	========================================================================
//
//	PRIVATE CEcb methods
//

//	------------------------------------------------------------------------
//
//	CEcb::DoneWithSession()
//
//	Called whenever we are done with the raw EXTENSION_CONTROL_BLOCK.
//
VOID
CEcb::DoneWithSession( BOOL fKeepAlive )
{
	//
	//	We should only call DoneWithSession() once.  We null out m_pecb
	//	at the end, so we can assert that we are only called once by
	//	checking m_pecb here.
	//
	Assert( m_pecb );

	//
	//	We should never release the EXTENSION_CONTROL_BLOCK if there
	//	is async I/O outstanding.
	//
	Assert( 0 == m_cRefAsyncIO );

	//
	//	When we call this function, we're done with the request.  Period.
	//	So decrement the current requests counter we incremented
	//	in our constructor.
	//
	Assert( m_pInstData );
	DecrementInstancePerfCounter( *m_pInstData, IPC_CURRENT_REQUESTS_EXECUTING );

	//
	//  Cleanup the hToken
	//
	if (m_pTokCtx)
	{
		ReleaseTokenCtx(m_pTokCtx);
		m_pTokCtx = NULL;
	}

	//
	//	"Release" the raw EXTENSION_CONTROL_BLOCK inherited from IEcb.
	//
	static const DWORD sc_dwKeepConn = HSE_STATUS_SUCCESS_AND_KEEP_CONN;

	(VOID) m_pecb->ServerSupportFunction(
						m_pecb->ConnID,
						HSE_REQ_DONE_WITH_SESSION,
						fKeepAlive ? const_cast<DWORD *>(&sc_dwKeepConn) : NULL,
						NULL,
						NULL );

	//
	//	We can no longer use the EXTENSION_CONTROL_BLOCK so remove any
	//	temptation to do so by nulling out the pointer.
	//
	m_pecb = NULL;
}


//	------------------------------------------------------------------------
//
//	CEcb::SendAsyncErrorResponse()
//
VOID
CEcb::SendAsyncErrorResponse( DWORD dwStatusCode,
							  LPCSTR pszStatusDescription,
							  DWORD cchzStatusDescription,
							  LPCSTR pszBody,
							  DWORD cchzBody )
{
	//	Try to trigger the async error response mechanism.  If successful
	//	then we are responsible for sending the entire repsonse.  If not
	//	then we are already sending a response on some other thread, so
	//	don't confuse things by sending any thing here.
	//
	if (!m_aeri.FTrigger())
	{
		DebugTrace( "CEcb::SendAsyncErrorResponse() - Non-error response already in progress\n" );
		return;
	}

	HSE_SEND_HEADER_EX_INFO shei;
	CHAR rgchStatusDescription[256];

	//	Blow away any previously set status code in favor of
	//	the requested status code.  Even though there may have
	//	been an old status code set, it was never sent -- the
	//	fact that our interlock triggered proves that no other
	//	response has been sent.
	//
	SetStatusCode(dwStatusCode);

	//	If we don't have a status description then fetch the default
	//	for the given status code.
	//
	if ( !pszStatusDescription )
	{
		LpszLoadString( dwStatusCode,
						LcidAccepted(),
						rgchStatusDescription,
						sizeof(rgchStatusDescription) );

		pszStatusDescription = rgchStatusDescription;
	}

	shei.pszStatus = pszStatusDescription;
	shei.cchStatus = cchzStatusDescription;

	//	Don't send any body unless we are given one.
	//
	shei.pszHeader = pszBody;
	shei.cchHeader = cchzBody;

	//	Always close the connection on errors -- and we should
	//	only ever be called for serious server errors.
	//
	Assert(dwStatusCode >= 400);
	shei.fKeepConn = FALSE;

	//	Send the response.  We don't care at all about the return
	//	value because there's nothing we can do if the response
	//	cannot be sent.
	//
	(VOID) m_pecb->ServerSupportFunction(
				m_pecb->ConnID,
				HSE_REQ_SEND_RESPONSE_HEADER_EX,
				&shei,
				NULL,
				NULL );
}


//	------------------------------------------------------------------------
//
//	CEcb::HSEHandleException()
//
DWORD
CEcb::HSEHandleException()
{
	//
	//	!!! IMPORTANT !!!
	//
	//	This function is called after an exception has occurred.
	//	Don't do ANYTHING outside of a try/catch block or a secondary
	//	exception could take out the whole IIS process.
	//
	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		//
		//	Send a 500 Server Error response.  We use the async error
		//	response mechanism, because we may have been in the middle
		//	of sending some other response on another thread.
		//
		SendAsyncErrorResponse(500,
							   gc_szDefErrStatusLine,
							   gc_cchszDefErrStatusLine,
							   gc_szDefErrBody,
							   gc_cchszDefErrBody);
	}
	catch ( CDAVException& )
	{
		//
		//	We blew up trying to send a response.  Oh well.
		//
	}

	//
	//	Tell IIS that we are done with the EXTENSION_CONTROL_BLOCK that
	//	it gave us.  We must do this or IIS will not be able to shut down.
	//	We would normally do this from within our destructor, but since
	//	we are handling an exception, there is no guarantee that our
	//	destructor will ever be called -- that is, there may be outstanding
	//	refs that will never be released (i.e. we will leak).
	//
	DWORD dwHSEStatusRet;

	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		DoneWithSession( FALSE );

		//
		//	If this call succeeds, we MUST return HSE_STATUS_PENDING to
		//	let IIS know that we claimed a ref on the EXTENSION_CONTROL_BLOCK.
		//
		dwHSEStatusRet = HSE_STATUS_PENDING;
	}
	catch ( CDAVException& )
	{
		//
		//	We blew up trying to tell IIS that we were done with
		//	the EXTENSION_CONTROL_BLOCK.  There is absolutely nothing
		//	we can do at this point.  IIS will probably hang on shutdown.
		//
		dwHSEStatusRet = HSE_STATUS_ERROR;
	}

	return dwHSEStatusRet;
}

//	------------------------------------------------------------------------
//
//	CEcb::TraceECB()
//
//		Traces out the EXTENSION_CONTROL_BLOCK
//
#ifdef DBG
void
CEcb::TraceECB() const
{
	EcbTrace( "ECB Contents:\n" );
	EcbTrace( "\tcbSize             = %lu\n",    m_pecb->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    m_pecb->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", m_pecb->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", m_pecb->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", m_pecb->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", m_pecb->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    m_pecb->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    m_pecb->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", m_pecb->lpszContentType );
	EcbTrace( "\n" );

	{
		char	rgch[256];
		DWORD	dwCbRgch;

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "SCRIPT_NAME", rgch, &dwCbRgch );

		EcbTrace( "Script name = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "SCRIPT_MAP", rgch, &dwCbRgch );

		EcbTrace( "Script map = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "HTTP_REQUEST_URI", rgch, &dwCbRgch );

		EcbTrace( "Request URI = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->ServerSupportFunction( m_pecb->ConnID, HSE_REQ_MAP_URL_TO_PATH, rgch, &dwCbRgch, NULL );

		EcbTrace( "Path from request URI = \"%s\"\n", rgch );
	}
}
#endif // defined(DBG)


//	========================================================================
//
//	PUBLIC CEcb methods
//

//	------------------------------------------------------------------------
//
//	CEcb::CchUrlPortW
//
//		Get the string with the port based on the fact if we are secure
//
UINT
CEcb::CchUrlPortW( LPCWSTR * ppwszPort ) const
{
	Assert (ppwszPort);

	//	If we are secure...
	//
	if (FSsl())
	{
		*ppwszPort = gc_wszUrl_Port_443;
		return gc_cchUrl_Port_443;
	}

	*ppwszPort = gc_wszUrl_Port_80;
	return gc_cchUrl_Port_80;
}

//	------------------------------------------------------------------------
//
//	CEcb::InstData
//
//		Fetch and cache our per-vroot instance data
//
CInstData&
CEcb::InstData() const
{
	Assert( m_pInstData );

	return *m_pInstData;
}

//	------------------------------------------------------------------------
//
//	CEcb::HitUser
//
//		Fetch and cache our impersonation token
//
HANDLE
CEcb::HitUser() const
{
	if ( m_hTokUser == NULL )
	{
		ULONG cb = sizeof(HANDLE);

		m_pecb->ServerSupportFunction( m_pecb->ConnID,
									   HSE_REQ_GET_IMPERSONATION_TOKEN,
									   &m_hTokUser,
									   &cb,
									   NULL );
		//
		//  Convert this token to include Universal Security Groups
		//
		if (m_hTokUser)
		{
			SCODE sc;
			VOID * pTokCtx = NULL;
			HANDLE hToken = NULL;

			sc = ScFindOrCreateTokenContext( m_hTokUser,
											 &pTokCtx,
											 &hToken );

			//$	REVIEW: SECURITY: If there was a failure to augment
			//	the security token to include USG group membership,
			//	we should hand back an invalid handle value.  This
			//	is needed such that we do not allow access to a user
			//	who should be denied by virtue of belonging to a USG
			//	that has been included in a deny ACE.
			//
			if (S_OK != sc)
			{
				Assert (NULL == hToken);
				Assert (NULL == pTokCtx);

				hToken = INVALID_HANDLE_VALUE;
				pTokCtx = NULL;
			}
			//
			//$	REVIEW: SECURITY: end.

			m_hTokUser = hToken;
			m_pTokCtx = pTokCtx;
		}

	}

	return m_hTokUser;
}


//	------------------------------------------------------------------------
//
//	CEcb::LpszVersion()
//
LPCSTR
CEcb::LpszVersion() const
{
	if ( !*m_rgchVersion )
	{
		DWORD cbVersion = sizeof(m_rgchVersion);

		if ( !FGetServerVariable( gc_szHTTP_Version,
								  m_rgchVersion,
								  &cbVersion ) )
		{
			//
			//	If we are unable to get a value for HTTP_VERSION then
			//	the string is probably longer than the buffer we gave.
			//	Rather than deal with a potentially arbitrarily long
			//	string, default to HTTP/1.1.  This is consistent with
			//	observed IIS behavior (cf. NT5:247826).
			//
			memcpy( m_rgchVersion,
					gc_szHTTP_1_1,
					sizeof(gc_szHTTP_1_1) );
		}
		else if ( !*m_rgchVersion )
		{
			//
			//	No value for HTTP_VERSION means that nothing was
			//	specified on the request line, which means HTTP/0.9
			//
			memcpy( m_rgchVersion,
					gc_szHTTP_0_9,
					sizeof(gc_szHTTP_0_9) );
		}
	}

	return m_rgchVersion;
}

//	------------------------------------------------------------------------
//
//	CEcb::FKeepAlive()
//
//		Returns whether to keep alive the client connection after sending
//		the response.
//
//		The connection logic has changed over the various HTTP versions;
//		this function uses the logic appropriate to the HTTP version
//		of the request.
//
BOOL
CEcb::FKeepAlive() const
{
	//
	//	If we haven't already determined what we want, then begin
	//	the process of figuring it out...
	//
	if ( m_connState == UNKNOWN )
	{
		//
		//	If someone set a Connection: header then pay attention to it
		//
		if (m_pwszConnectionHeader.get())
		{
			//
			//	Set the connection state based on the current value of
			//	the request's Connection: header, and the HTTP version.
			//	NOTE: The request MUST forward us any updates to the
			//	Connection: header for this to work!
			//	NOTE: Comparing the HTTP version strings using C-runtime strcmp,
			//	because the version string is pure ASCII.
			//

			//
			//	HTTP/1.1
			//
			//	(Consider the HTTP/1.1 case FIRST to minimize the number
			//	of string compares in this most common case).
			//
			if ( !strcmp( LpszVersion(), gc_szHTTP_1_1 ) )
			{
http_1_1:
				//
				//	The default for HTTP/1.1 is to keep the connection alive
				//
				m_connState = KEEP_ALIVE;

				//
				//	But if the request's Connection: header says close,
				//	then close.
				//
				//	This compare should be case-insensitive.
				//
				//	Using CRT skinny-string func here 'cause this header is pure ASCII,
				//	AND because _stricmp (and his brother _strcmpi) doesn't cause us
				//	a context-switch!
				//
				if ( !_wcsicmp( m_pwszConnectionHeader.get(), gc_wszClose ) )
					m_connState = CLOSE;
			}

			//
			//	HTTP/1.0
			//
			else if ( !strcmp( LpszVersion(), gc_szHTTP_1_0 ) )
			{
				//
				//	For HTTP/1.0 requests, the default is to close the connection
				//	unless a "Connection: Keep-Alive" header exists.
				//
				m_connState = CLOSE;

				if ( !_wcsicmp( m_pwszConnectionHeader.get(), gc_wszKeep_Alive ) )
					m_connState = KEEP_ALIVE;
			}

			//
			//	HTTP/0.9
			//
			else if ( !strcmp( LpszVersion(), gc_szHTTP_0_9 ) )
			{
				//
				//	For HTTP/0.9, always close the connection.  There was no
				//	other option for HTTP/0.9.
				//
				m_connState = CLOSE;
			}

			//
			//	Other (future) HTTP versions
			//
			else
			{
				//
				//	We really are only guessing what to do here, but assuming
				//	that the HTTP spec doesn't change the Connection behavior
				//	again, we should behave like HTTP/1.1
				//
				goto http_1_1;
			}
		}

		//
		//	If no one set a Connection: header, than use whatever IIS
		//	tells us to use.
		//
		//	NOTE: Currently, this value can only be ADDED, never DELETED.
		//	If that fact changes, FIX this code!
		//
		else
		{
			BOOL fKeepAlive;

			if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
												 HSE_REQ_IS_KEEP_CONN,
												 &fKeepAlive,
												 NULL,
												 NULL ))
			{
				DebugTrace( "CEcb::FKeepAlive--Failure (0x%08x) from SSF(IsKeepConn).\n",
							GetLastError() );

				//	No big deal?  If we're getting errors like this
				//	we probably want to close the connection anyway....
				//
				m_connState = CLOSE;
			}

			m_connState = fKeepAlive ? KEEP_ALIVE : CLOSE;
		}
	}

	//
	//	By now we must know what we want
	//
	Assert( m_connState == KEEP_ALIVE || m_connState == CLOSE );

	return m_connState == KEEP_ALIVE;
}

//	------------------------------------------------------------------------
//
//	CEcb::FCanChunkResponse()
//
//	Returns TRUE if the client will accept a chunked response.
//
BOOL
CEcb::FCanChunkResponse() const
{
	if ( TC_UNKNOWN == m_tcAccepted )
	{
		//
		//	According to the HTTP/1.1 draft, section 14.39 TE:
		//
		//		"A server tests whether a transfer-coding is acceptable,
		//		acording to a TE field, using these rules:
		//
		//		1.
		//			The "chunked" transfer-coding is always acceptable.
		//
		//		[...]"
		//
		//	and section 3.6 Transfer Codings, last paragraph:
		//
		//		"A server MUST NOT send transfer-codings to an HTTP/1.0
		//		client."
		//
		//	Therefore, deciding whether a client accepts a chunked
		//	transfer coding is simple:  If the request is an HTTP/1.1
		//	request, then it accepts chunked coding.  Otherwise it doesn't.
		//
		m_tcAccepted = strcmp( gc_szHTTP_1_1, LpszVersion() ) ?
						TC_IDENTITY :
						TC_CHUNKED;
	}

	Assert( m_tcAccepted != TC_UNKNOWN );

	return TC_CHUNKED == m_tcAccepted;
}

BOOL
CEcb::FBrief() const
{
	//	If we don't have a value yet...
	//
	if (BRIEF_UNKNOWN == m_lBrief)
	{
		CHAR rgchBrief[8] = {0};
		ULONG cbBrief = 8;

		//	Brief is expected when:
		//
		//		The "brief" header has a value of "t"
		//
		//	NOTE: The default is brief to false.
		//
		//	We addapt overwrite checking model here. Just first letter for true case.
		//
		//	NOTE also: the default value if there is no Brief: header
		//	is FALSE -- give the full response.
		//
		FGetServerVariable("HTTP_BRIEF", rgchBrief, &cbBrief);
		if ((rgchBrief[0] != 't') && (rgchBrief[0] != 'T'))
			m_lBrief = BRIEF_NO;
		else
			m_lBrief = BRIEF_YES;
	}
	return (BRIEF_YES == m_lBrief);
}


//	------------------------------------------------------------------------
//
//	CEcb::FAuthenticated()
//

const DWORD c_AuthStateQueried			= 0x80000000;
const DWORD c_AuthStateAuthenticated	= 0x00000001;
const DWORD c_AuthStateBasic			= 0x00000002;
const DWORD c_AuthStateNTLM				= 0x00000004;
const DWORD c_AuthStateKerberos			= 0x00000008;
const DWORD c_AuthStateUnknown			= 0x00000010;

const CHAR	c_szBasic[]					= "Basic";
const CHAR	c_szNTLM[]					= "NTLM";
const CHAR	c_szKerberos[]				= "Kerberos";

BOOL
CEcb::FAuthenticated() const
{
	if (!(m_rgbAuthState & c_AuthStateQueried))
	{
		CHAR	szAuthType[32];
		ULONG	cb = sizeof(szAuthType);

		Assert(m_rgbAuthState == 0);

		if (FGetServerVariable(gc_szAuth_Type, szAuthType, &cb))
		{
			// For now, lets just check the first character (it's cheaper).
			// If this proves problematic then we can do a full string
			// compair.  Also, SSL by itself is not to be considered a form
			// of domain authentication.  The only time that SSL does imply
			// and authenticated connection is when Cert Mapping is enabled
			// and I don't think this is an interesting scenario. (russsi)

			if (*szAuthType == 'B')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateBasic);
			else if (*szAuthType == 'N')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateNTLM);
			else if (*szAuthType == 'K')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateKerberos);
			else
				m_rgbAuthState = c_AuthStateUnknown; // it could be "SSL/PCT"
		}

		m_rgbAuthState |= c_AuthStateQueried;
	}

	return (m_rgbAuthState & c_AuthStateAuthenticated);
}

//	------------------------------------------------------------------------
//
//	CEcb::SetStatusCode()
//
//	Sets the HTTP status code that IIS uses in logging
//
void
CEcb::SetStatusCode( UINT iStatusCode )
{
	//	If we have executed a child ISAPI successfully, we don't want to overwrite the
	//	status code in the ECB.  This will end up causing IIS to log this status code
	//	rather than the one left in the ECB by the ISAPI.
	//
	if (!m_fChildISAPIExecSuccess)
		m_pecb->dwHttpStatusCode = iStatusCode;
}

//	MANIPULATORS
//	To be used ONLY by request/response.
//
//	NOTE: These member vars start out NULL.  Inside CEcb, we are using NULL
//	as a special value that means the data has NEVER been set, so if
//	we get an lpszValue of NULL (meaning to delete the header), store
//	an empty string instead, so that we know the data has been forcefully erased.
//
void CEcb::SetConnectionHeader( LPCWSTR pwszValue )
{
	auto_heap_ptr<WCHAR> pwszOld;
	pwszOld.take_ownership(m_pwszConnectionHeader.relinquish());

	//	If they want to delete the value, set an empty string.
	//
	if (!pwszValue)
		pwszValue = gc_wszEmpty;

	m_pwszConnectionHeader = WszDupWsz( pwszValue );
}

void CEcb::CloseConnection()
{
	m_connState = CLOSE;
}

void CEcb::SetAcceptLanguageHeader( LPCSTR pszValue )
{
	auto_heap_ptr<CHAR> pszOld;
	pszOld.take_ownership(m_pszAcceptLanguage.relinquish());
	
	//	If they want to delete the value, set an empty string.
	//
	if (!pszValue)
		pszValue = gc_szEmpty;

	m_pszAcceptLanguage = LpszAutoDupSz( pszValue );
}

SCODE CEcb::ScAsyncRead( BYTE * pbBuf,
						 UINT * pcbBuf,
						 IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncRead() called...\n", GetCurrentThreadId(), this );

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncRead() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncRead() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncRead() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start reading.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_ASYNC_READ_CLIENT,
											   pbBuf,
											   reinterpret_cast<LPDWORD>(pcbBuf),
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncRead() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncRead() - ServerSupportFunction(HSE_REQ_ASYNC_READ_CLIENT) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncRead() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncRead() - m_cRefAsyncIO wrong after failed async read" );

			goto ret;
		}
	}

ret:

	return sc;
}

BOOL CEcb::FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei )
{
	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		DebugTrace( "CEcb::FSyncTransmitHeaders() - Async error response already in progress\n" );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		SetLastError(static_cast<ULONG>(E_FAIL));
		return FALSE;
	}

	//
	//	Send the response
	//
	if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
										 HSE_REQ_SEND_RESPONSE_HEADER_EX,
										 const_cast<HSE_SEND_HEADER_EX_INFO *>(&shei),
										 NULL,
										 NULL ) )
	{
		DebugTrace( "CEcb::FSyncTransmitHeaders() - SSF::HSE_REQ_SEND_RESPONSE_HEADER_EX failed (%d)\n", GetLastError() );
		return FALSE;
	}

	return TRUE;
}

SCODE CEcb::ScAsyncWrite( BYTE * pbBuf,
						  DWORD  dwcbBuf,
						  IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncWrite() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncWrite() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncWrite() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncWrite() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncWrite() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start writing.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->WriteClient( m_pecb->ConnID, pbBuf, &dwcbBuf, HSE_IO_ASYNC ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncWrite() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncWrite() - _EXTENSION_CONTROL_BLOCK::WriteClient() failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncWrite() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncWrite() - m_cRefAsyncIO wrong after failed async write" );

			goto ret;
		}
	}

ret:

	return sc;
}

SCODE CEcb::ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
								 IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncTransmitFile() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncTransmitFile() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncTransmitFile() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Async I/O completion routine and context should have been passed
	//	in as parameters.  Callers should NOT use the corresponding members
	//	of the HSE_TF_INFO structure.  IIS has to call CEcb::IISIOComplete()
	//	so that it can release the critsec.
	//
	Assert( !tfi.pfnHseIO );
	Assert( !tfi.pContext );

	//
	//	Verify that the caller has set the async I/O flag
	//
	Assert( tfi.dwFlags & HSE_IO_ASYNC );

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_TRANSMIT_FILE,
											   const_cast<HSE_TF_INFO *>(&tfi),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncTransmitFile() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncTransmitFile() - ServerSupportFunction(HSE_REQ_TRANSMIT_FILE) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncTransmitFile() - m_cRefAsyncIO wrong after failed async transmit file" );

			goto ret;
		}
	}

ret:

	return sc;
}

//	Other functions that start async IO with IIS. These functions are for IIS 6.0 or later
//	only. We will not even use observers on them, as the completion esentially will serve
//	just to signal some cleanup on a single string, which does not make much sense to wrap
//	it up as the observer.
//	
SCODE CEcb::ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
									   LPSTR pszStatus )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncCustomError60After() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncCustomError60After() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncCustomError60After() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Verify that the caller has set the async I/O flag
	//
	Assert( TRUE == cei.fAsync );

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(CUSTERR_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_SEND_CUSTOM_ERROR,
											   const_cast<HSE_CUSTOM_ERROR_INFO *>(&cei),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncCustomError60After() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncCustomError60After() - ServerSupportFunction(HSE_REQ_SEND_CUSTOM_ERROR) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncCustomError60After() - m_cRefAsyncIO wrong after failed async custom error" );

			goto ret;
		}
	}

	//	We need to take ownership of the status string that was passed in in the case of success
	//	From looking in the code in IIS it does not mater if we keep it alive until completion,
	//	as it is anyway realocated before going onto another thread. But just in case something
	//	changes and to be doing what IIS people asked us to do we will keep it alive. String has
	//	the format of "nnn reason".
	//	
	m_pszStatus.take_ownership(pszStatus);

ret:

	return sc;
}

SCODE CEcb::ScAsyncExecUrl60After( const HSE_EXEC_URL_INFO& eui )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncExecUrl60After() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncExecUrl60After() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{			
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncExecUrl60After() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Verify that the caller has set the async I/O flag
	//
	Assert( eui.dwExecUrlFlags & HSE_EXEC_URL_ASYNC );

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(EXECURL_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_EXEC_URL,
											   const_cast<HSE_EXEC_URL_INFO *>(&eui),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncExecUrl60After() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncExecUrl60After() - ServerSupportFunction(HSE_REQ_EXEC_URL) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncExecUrl60After() - m_cRefAsyncIO wrong after failed async exec url" );

			goto ret;
		}
	}

ret:

	return sc;
}

SCODE CEcb::ScSetIOCompleteCallback( LONG lCompletion )
{
	SCODE sc = S_OK;

	//
	//	Do not reset the completion function if it is already set to the
	//	same one we want to set. There is no need to protect the member
	//	variable against multithreaded access as the callers of this
	//	function are already protecting against the overlap of 2 async
	//	IO-s and this function is the only one changing variable value
	//	and is always called within protected zone.
	//
	if ( lCompletion != m_lSetIISIOCompleteCallback )
	{
		//
		//	Figure out what completion function we need
		//
		PFN_HSE_IO_COMPLETION pfnCallback;

		if (IO_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(IISIOComplete);
		}
		else if (CUSTERR_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(CustomErrorIOCompletion);
		}
		else if (EXECURL_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(ExecuteUrlIOCompletion);
		}
		else
		{
			EcbTrace( "CEcb::ScSetIOCompleteCallback() - attempting to set unknown completion function. Failing out with 0x%08lX\n", E_FAIL );

			sc = E_FAIL;
			goto ret;
		}

		//	Set the IIS I/O completion routine to the requested one. Some of those
		//	routines will simply handle the completion, others will forward to the
		//	right observer.
		//
		if (!m_pecb->ServerSupportFunction(m_pecb->ConnID,
										   HSE_REQ_IO_COMPLETION,
										   pfnCallback,
										   NULL,
										   reinterpret_cast<LPDWORD>(this)))
		{
			EcbTrace( "CEcb::ScSetIOCompleteCallback() - ServerSupportFunction(HSE_REQ_IO_COMPLETION) failed with last error 0x%08lX\n", GetLastError() );

			sc = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}

		m_lSetIISIOCompleteCallback = lCompletion;
	}

ret:

	return sc;
}

VOID WINAPI
CEcb::IISIOComplete( const EXTENSION_CONTROL_BLOCK * pecbIIS,
					 CEcb * pecb,
					 DWORD dwcbIO,
					 DWORD dwLastError )
{
	BOOL fCaughtException = FALSE;

	//	PLEASE SEE *** EXTREMELY IMPORTANT NOTE *** near the bottom of this
	//	function for more information on the proper way to unwind (deinit())
	//	this auto_ref_ptr!
	//
	auto_ref_ptr<CEcb> pThis;

	//
	//	Don't let thrown C++ exceptions propagate out of this entrypoint.
	//
	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;
		LONG cRefAsyncIO;

		//
		//	Take ownership of the reference added
		//	on our behalf by the thread that started the async I/O.
		//
		pThis.take_ownership(pecb);

		EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::IISIOComplete() called\n", GetCurrentThreadId(), pecb );

		//
		//	A quick sanity check to make sure the context
		//	is really us...
		//
		Assert( !IsBadReadPtr( pecb, sizeof(CEcb) ) );
		Assert( pecb->m_pecb == pecbIIS );

		IIISAsyncIOCompleteObserver * pobsAsyncIOComplete = pThis->m_pobsAsyncIOComplete;

		//
		//	Decrement the async I/O refcount added by the routine that
		//	started the async I/O.  Do this before calling the I/O
		//	completion routine which can start new async I/O.
		//
		cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
		AssertSz( 0 == cRefAsyncIO,
				  "CEcb::IISIOComplete() - m_cRefAsyncIO wrong after async I/O complete" );

		//	Tell the observer that the I/O is complete
		//
		pobsAsyncIOComplete->IISIOComplete( dwcbIO, dwLastError );
	}
	catch ( CDAVException& )
	{
		fCaughtException = TRUE;
	}

	//
	//	If we caught an exception then handle it as best we can
	//
	if ( fCaughtException )
	{
		//
		//	If we have a CEcb then use it to handle the exception.
		//	If we don't have one then there's nothing we can do --
		//	there is no way to return any status from this function.
		//
		if ( pThis.get() )
			(VOID) pThis->HSEHandleException();
	}

	//
	//	Release the instance ref added by the routine that started the async I/O.
	//	We must do this as the VERY LAST THING(tm) before returning control back
	//	to IIS because during shutdown, this could be the last reference to the
	//	instance data.
	//
	//	EXTREMELY IMPORTANT NOTE: If this is the last reference on the instance
	//	data, everything will get torn down (we're finished with everything, so
	//	we can clean up everything).  Specifically, our HEAPS will be DESTROYED
	//	here in this situation.  Hence, we need to clear out the auto_ref_ptr
	//	from above ********** BEFORE ********** we call ReleaseImplInst().
	//	Otherwise, we could end up trying to touch the reference count on the
	//	CEcb object pointed to by the auto_ref_ptr AFTER we have destroyed the
	//	heap it was allocated on.  This is A BAD THING(tm).
	//
	//	This bug was found in IIS stress on 18 June 1999, and was filed as NTRAID
	//	bug #358578.
	//

	//	Per "EXTREMELY IMPORTANT NOTE" above: CLEAR the auto_ref_ptr
	//	********** BEFORE ********** calling ReleaseImplInst().
	//
	pThis.clear();

	//	Now it is safe to call ReleaseImplInst().
	//
	ReleaseImplInst();
}

VOID WINAPI
CEcb::CustomErrorIOCompletion ( const EXTENSION_CONTROL_BLOCK * pecbIIS,
								CEcb * pecb,
								DWORD dwcbIO,
								DWORD dwLastError )
{
	auto_ref_ptr<CEcb> pThis;
	LONG cRefAsyncIO;

	//
	//	Take ownership of the reference added
	//	on our behalf by the thread that started the async I/O.
	//
	pThis.take_ownership(pecb);

	//
	//	Decrement the async I/O refcount added by the routine that
	//	started the async I/O.
	//
	cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
	AssertSz( 0 == cRefAsyncIO,
			  "CEcb::CustomErrorIOCompletion() - m_cRefAsyncIO wrong after async I/O complete" );

	
	EcbTrace( "Custom Error finished with dwcbIO = %d, error = %d\n", dwcbIO, dwLastError);
	EcbTrace( "More info about the request:\n");
	EcbTrace( "\tcbSize             = %lu\n",    pecbIIS->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    pecbIIS->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", pecbIIS->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", pecbIIS->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", pecbIIS->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", pecbIIS->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    pecbIIS->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    pecbIIS->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", pecbIIS->lpszContentType );
	EcbTrace( "\n" );

	//	We need to make sure that last release of memory is finished before we release
	//	ref on CImplInst (as when CImplInst goes away so does our heap and we do not
	//	want to do operations on memory if the heap itself is gone).
	//
	pThis.clear();
	ReleaseImplInst();
}

VOID WINAPI
CEcb::ExecuteUrlIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
							  CEcb * pecb,
							  DWORD dwcbIO,
							  DWORD dwLastError )
{
	auto_ref_ptr<CEcb> pThis;
	LONG cRefAsyncIO;

	//
	//	Take ownership of the reference added
	//	on our behalf by the thread that started the async I/O.
	//
	pThis.take_ownership(pecb);

	//
	//	Decrement the async I/O refcount added by the routine that
	//	started the async I/O.
	//
	cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
	AssertSz( 0 == cRefAsyncIO,
			  "CEcb::CustomErrorIOCompletion() - m_cRefAsyncIO wrong after async I/O complete" );

	
	EcbTrace( "Exec_URL finished with dwcbIO = %d, error = %d\n", dwcbIO, dwLastError);
	EcbTrace( "More info about the request:\n");
	EcbTrace( "\tcbSize             = %lu\n",    pecbIIS->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    pecbIIS->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", pecbIIS->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", pecbIIS->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", pecbIIS->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", pecbIIS->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    pecbIIS->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    pecbIIS->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", pecbIIS->lpszContentType );
	EcbTrace( "\n" );

	//	We need to make sure that last release of memory is finished before we release
	//	ref on CImplInst (as when CImplInst goes away so does our heap and we do not
	//	want to do operations on memory if the heap itself is gone).
	//
	pThis.clear();
	ReleaseImplInst();
}

//	This is how we execute a child in any IIS version before IIS 6.0
//
SCODE CEcb::ScSyncExecuteChildWide60Before( LPCWSTR pwszUrl,
											LPCSTR pszQueryString,
											BOOL fCustomErrorUrl )
{
	SCODE sc = S_OK;

	auto_heap_ptr<CHAR> pszUrlEscaped;
	CStackBuffer<CHAR, MAX_PATH> pszUrl;
	DWORD dwExecFlags;
	LPCSTR pszUrlToForward;
	LPCSTR pszVerb = NULL;
	UINT cch;
	UINT cb;
	UINT cbQueryString = 0;

	Assert( m_pecb );
	Assert( pwszUrl );

	cch = static_cast<UINT>(wcslen(pwszUrl));
	Assert(L'\0' == pwszUrl[cch]);
	cb = cch * 3;

	if (pszQueryString)
	{
		cbQueryString = static_cast<UINT>(strlen(pszQueryString));
	}

	//	Resize the buffer to the sufficient size, leave place for '\0' termination.
	//	We also add the length of the query string there, although it is not necessary
	//	at this step - but in many cases it will save us the allocation afterwards,
	//	as we already will have sufficient buffer even for escaped version of the string.
	//
	if (!pszUrl.resize(cb + cbQueryString + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	//	Convert URL to skinny including '\0' termination.
	//
	cb = WideCharToMultiByte(CP_UTF8,
							 0,
							 pwszUrl,
							 cch + 1,
							 pszUrl.get(),
							 cb + 1,
							 0,
							 0);
	if (0 == cb)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Escape the URL
	//
	HttpUriEscape( pszUrl.get(), pszUrlEscaped );

	//	Handle the query string
	//
	if (cbQueryString)
	{
		//	Find out the length of new URL
		//
		cb = static_cast<UINT>(strlen(pszUrlEscaped.get()));

		//	Resize the buffer to the sufficient size, leave place for '\0' termination.
		//	
		if (!pszUrl.resize(cb + cbQueryString + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Copy the escaped version of the URL
		//
		memcpy(pszUrl.get(), pszUrlEscaped.get(), cb);

		//	Copy the query string at the end together with it's '\0' termination.
		//
		memcpy(pszUrl.get() + cb, pszQueryString, cbQueryString + 1);

		//	Point to the constructed URL
		//
		pszUrlToForward = pszUrl.get();
	}
	else
	{
		//	In the case we do not have query string then the URL to forward to
		//	is the same as the escaped URL.
		//
		pszUrlToForward = pszUrlEscaped.get();
	}

	//	Depending on the fact if we are doing custom error or executing script
	//	determine the execution flags and the verb.
	//
	if ( fCustomErrorUrl )
	{
		//	We enable wildcard processing here, since we want
		//	to give one chance to all CE URLs.
		//	Calling into ourselves is fine here and we prevent
		//	recusrion using another scheme!
		//
		dwExecFlags = HSE_EXEC_CUSTOM_ERROR;
		if (!strcmp(LpszMethod(), gc_szHEAD))
		{
			//	If this is a HEAD request, tell whomever we
			//	forward this to to only pass back the status
			//	line and headers.
			//
			pszVerb = gc_szHEAD;
		}
		else
		{
			pszVerb = gc_szGET;
		}

		//	If we're doing a custom error then someone has
		//	already set the status code.
		//
		Assert( m_pecb->dwHttpStatusCode != 0 );
	}
	else
	{
		//	When we are executing scripts, we disable wild card
		//	execution to prevent recursion.
		//	Also the verb field is allowed to be NULL, it is optional and
		//	used only for custom error processing.
		//
		dwExecFlags = HSE_EXEC_NO_ISA_WILDCARDS;
		pszVerb = NULL;

		//	We need to set the status code here to 200 (like it
		//	was set when we were first called) just in case
		//	child ISAPIs depend on it.
		//
		SetStatusCode(200);
	}

	if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
										HSE_REQ_EXECUTE_CHILD,
										const_cast<LPSTR>(pszUrlToForward),
										reinterpret_cast<LPDWORD>(const_cast<LPSTR>(pszVerb)),
										&dwExecFlags ))
	{
		//	Reset the status code back to 0 if we failed to execute
		//	the child ISAPI because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		if (!fCustomErrorUrl)
		{
			SetStatusCode(0);
		}

		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - ServerSupportFunction(HSE_REQ_EXECUTE_CHILD) failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	Set the flag stating that we have successfully executed a child ISAPI.
	//
	m_fChildISAPIExecSuccess = TRUE;

ret:

	return sc;
}

SCODE CEcb::ScAsyncExecUrlWide60After( LPCWSTR pwszUrl,
									   LPCSTR pszQueryString,
									   BOOL fCustomErrorUrl )
{
	SCODE sc = S_OK;
	HSE_EXEC_URL_INFO execUrlInfo;

	auto_heap_ptr<CHAR> pszUrlEscaped;
	CStackBuffer<CHAR, MAX_PATH> pszUrl;
	UINT cch;
	UINT cb;
	UINT cbQueryString = 0;

	Assert( m_pecb );
	Assert( pwszUrl );
	Assert(!fCustomErrorUrl);	//	In IIS60 custom error is NOT done by execute URL


	cch = static_cast<UINT>(wcslen(pwszUrl));
	Assert(L'\0' == pwszUrl[cch]);
	cb = cch * 3;

	if (pszQueryString)
	{
		cbQueryString = static_cast<UINT>(strlen(pszQueryString));
	}

	//	Resize the buffer to the sufficient size, leave place for '\0' termination.
	//	We also add the length of the query string there, although it is not necessary
	//	at this step - but in many cases it will save us the allocation afterwards,
	//	as we already will have sufficient buffer even for escaped version of the string.
	//
	if (!pszUrl.resize(cb + cbQueryString + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	//	Convert to skinny including '\0' termination
	//
	cb = WideCharToMultiByte(CP_UTF8,
							 0,
							 pwszUrl,
							 cch + 1,
							 pszUrl.get(),
							 cb + 1,
							 0,
							 0);
	if (0 == cb)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Escape the URL
	//
	HttpUriEscape( pszUrl.get(), pszUrlEscaped );

	//	Handle the query string
	//
	if (cbQueryString)
	{
		//	Find out the length of new URL
		//
		cb = static_cast<UINT>(strlen(pszUrlEscaped.get()));

		//	Resize the buffer to the sufficient size, leave place for '\0' termination.
		//	
		if (!pszUrl.resize(cb + cbQueryString + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("CEcb::ScAsyncExecUrlWide60After() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Copy the escaped version of the URL
		//
		memcpy(pszUrl.get(), pszUrlEscaped.get(), cb);

		//	Copy the query string at the end together with it's '\0' termination.
		//
		memcpy(pszUrl.get() + cb, pszQueryString, cbQueryString + 1);

		//	Point to the constructed URL
		//
		execUrlInfo.pszUrl = pszUrl.get();
	}
	else
	{
		//	In the case we do not have query string then the URL to forward to
		//	is the same as the escaped URL.
		//
		execUrlInfo.pszUrl = pszUrlEscaped.get();
	}

	//	Initialize method name
	//
	execUrlInfo.pszMethod = NULL;

	//	Initialize child headers
	//
	execUrlInfo.pszChildHeaders = NULL;

	//	We don't need a new user context,
	//
	execUrlInfo.pUserInfo = NULL;

	//	We don't need a new entity either
	//
	execUrlInfo.pEntity = NULL;

	//	Pick up the execution flags
	//
	execUrlInfo.dwExecUrlFlags = HSE_EXEC_URL_ASYNC;
	execUrlInfo.dwExecUrlFlags |= HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR;
	execUrlInfo.dwExecUrlFlags |= HSE_EXEC_URL_DISABLE_CUSTOM_ERROR;
	
	//	We need to set the status code here to 200 (like it
	//	was set when we were first called) just in case
	//	child ISAPIs depend on it.
	//
	SetStatusCode(200);

	sc = ScAsyncExecUrl60After( execUrlInfo );
	if (FAILED(sc))
	{
		//	Reset the status code back to 0 if we failed to execute
		//	the child ISAPI because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		SetStatusCode(0);

		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - CEcb::ScAsyncExecUrl60After() failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	Set the flag stating that we have successfully executed a child ISAPI.
	//
	m_fChildISAPIExecSuccess = TRUE;

ret:

	return sc;
}

SCODE CEcb::ScSendRedirect( LPCSTR pszURI )
{
	SCODE sc = S_OK;

	//
	//	We cannot assert that the dwHttpStatusCode status code in ECB is
	//	some particular value. On IIS 5.X it will be 0, IIS 6.0 has changed
	//	the behaviour and will shuffle 200 into it upon calling us. Also we
	//	have seen ourselves be called from IIS 6.0 when If-Modified-Since,
	//	Translate: t request is given which is the bug in IIS (WB 277208),
	//	as in that case IIS must be handling that. So untill we could assert
	//	for the response code to be 0 (IIS 5.X) or 200 (IIS 6.0) we will have
	//	to wait till IIS 6.0 is fixed up.
	//

	//
	//	Fill in the appropriate status code in the ECB
	//	(for IIS logging).
	//
	SetStatusCode(HSC_MOVED_TEMPORARILY);

	//
	//	Attempt to send a redirection response.  If successful then
	//	the response will be handled by IIS.  If unsuccessful
	//	then we will handle the response later.
	//
	Assert( pszURI );
	DWORD cbURI = static_cast<DWORD>(strlen( pszURI ) * sizeof(CHAR));

	if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
										 HSE_REQ_SEND_URL_REDIRECT_RESP,
										 const_cast<LPSTR>(pszURI),
										 &cbURI,
										 NULL ) )
	{
		//
		//	Reset the status code back to 0 if we failed to send
		//	the redirect because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		SetStatusCode(0);

		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace( "CEcb::ScSendRedirect() - ServerSupportFunction(HSE_REQ_SEND_URL_REDIRECT_RESP) failed with error 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CEcb::FProcessingCEUrl()
//
//	Find out if we are called with a CE URL.
//	Important to avoid recursive invocation while
//	doing custom error URLs.
//

BOOL
CEcb::FProcessingCEUrl( ) const
{
	//	Assume that we are not doing custom error processing.
	//	For IIS 6.0 and after it is always the right thing to assume,
	//	due to the changes in behaviour from IIS 5.x
	//
	BOOL fCustErr = FALSE;

	//	In the case of IIS 5.x we do the usual determinatin.
	//
	if (m_pecb->dwVersion < IIS_VERSION_6_0)
	{
		//	By default assume custom error processing.
		//	Why? Suppose somebody forgets to tell us that
		//	it is a custom error url. We dont want recursive
		//	calls in that case. So it is safer to assume that
		//	we are doing custom error processing. This is only
		//	used to determine if we want to invoke custom
		//	error URLs and hence has no other side effects.
		//
		DWORD	dwExecFlags = HSE_EXEC_CUSTOM_ERROR;

		if (!(m_pecb->ServerSupportFunction( m_pecb->ConnID,
										  HSE_REQ_GET_EXECUTE_FLAGS,
										  NULL,
										  NULL,
										  &dwExecFlags )))
		{
			DebugTrace("CEcb::FProcessingCEUrl Server supportFunction call failed.\n");
			DebugTrace("CEcb::FProcessingCEUrl Assuming custom error processing.\n");
		}

		fCustErr = !!(dwExecFlags & HSE_EXEC_CUSTOM_ERROR);
	}

	return fCustErr;
}



//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewEcb
//
IEcb * NewEcb( EXTENSION_CONTROL_BLOCK& ecbRaw,
			   BOOL fUseRawUrlMappings,
			   DWORD * pdwHSEStatusRet )
{
	Assert( !IsBadWritePtr(pdwHSEStatusRet, sizeof(DWORD)) );


	auto_ref_ptr<CEcb> pecb;

	pecb.take_ownership(new CEcb(ecbRaw));

	if ( pecb->FInitialize(fUseRawUrlMappings) )
		return pecb.relinquish();

	//
	//	If we couldn't init, there are two cases: If there is a status code
	//	set into the (raw) ECB, then the error was that LpszRequestUrl() returned
	//	NULL (bad URL).  In this case, we need to go ahead and send a response to
	//	the client that is appropriate (400 Bad Request) and then continue on
	//	the way we normally would.  Since the CEcb was already constructed, we can
	//	do everything just as we would for a normal request, calling
	//	DoneWithSession() and then returning HSE_STATUS_PENDING to IIS.
	//
	//	If there was NOT a status code in the (raw) ECB, we just treat it as an
	//	exception.  Think of this as functionally equal to throwing from a
	//	constructor.
	//
	if (ecbRaw.dwHttpStatusCode)
	{
		//
		//	The only path that can get here right now is if LpszRequestUrl()
		//	returns NULL during the CEcb FInitialize() call.  Assert that
		//	we had 400 (Bad Request) in the ECB.
		//
		Assert(HSC_BAD_REQUEST == ecbRaw.dwHttpStatusCode);

		//
		//	Send a 400 Bad Request response.  We use the async error
		//	response mechanism, but that technically doesn't matter since we
		//	are for sure are not in the middle of sending some other response on
		//	another thread (we've not even dispatched out to the actual methods
		//	(DAV*) yet).
		//
		Assert(pecb.get());
		pecb->SendAsyncErrorResponse(HSC_BAD_REQUEST,
									 gc_szDefErr400StatusLine,
									 CchConstString(gc_szDefErr400StatusLine),
									 NULL,
									 0);
		//
		//	Tell IIS that we are done with the EXTENSION_CONTROL_BLOCK that
		//	it gave us.  We must do this or IIS will not be able to shut down.
		//	If this call succeeds (doesn't except), we MUST return
		//	HSE_STATUS_PENDING to let IIS know that we claimed a ref on the
		//	EXTENSION_CONTROL_BLOCK.
		//
		pecb->DoneWithSession( FALSE );
		*pdwHSEStatusRet = HSE_STATUS_PENDING;
	}
	else
	{
		*pdwHSEStatusRet = pecb->HSEHandleException();
	}
	return NULL;
}

//	------------------------------------------------------------------------
//
//	CbMDPathW
//
ULONG CbMDPathW (const IEcb& ecb, LPCWSTR pwszURI)
{
	//	The number of bytes we returned could be more than the path needs
	//
	return static_cast<UINT>((wcslen(ecb.InstData().GetNameW()) + wcslen(pwszURI) + 1) * sizeof(WCHAR));
}

//	------------------------------------------------------------------------
//
//	MDPathFromURIW
//
VOID MDPathFromURIW (const IEcb& ecb, LPCWSTR pwszURI, LPWSTR pwszMDPath)
{
	LPCWSTR pwszVroot;

	//	If the URI is fully qualified, then somebody is not
	//	playing fair.  Gently nudge them.
	//
	Assert (pwszURI);
	Assert (pwszURI == PwszUrlStrippedOfPrefix (pwszURI));

	//	Copy the root name the instance -- MINUS the vroot
	//
	UINT cch = static_cast<UINT>(wcslen(ecb.InstData().GetNameW()));
	cch -= ecb.CchGetVirtualRootW(&pwszVroot);
	memcpy (pwszMDPath, ecb.InstData().GetNameW(), sizeof(WCHAR) * cch);

	// 	Copy the rest that is after the vroot path.
	//
	wcscpy (pwszMDPath + cch, pwszURI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\htmlmap.cpp ===
/*
 *	H T M L M A P . C P P
 *
 *	HTML .MAP file processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <htmlmap.h>

//	.MAP file parsing ---------------------------------------------------------
//
//	This code has been stolen from IIS and rewritten to work within the
//	DAV/Caligula sources.  The original code can be found in the IIS slm
//	project at \\kernel\razzle3\slm\iis\svcs\w3\server\doget.cxx.
//
#define SQR(x)		((x) * (x))
#define MAXVERTS	160
#define X			0
#define Y			1

inline bool IsWhiteA (CHAR ch)
{
	return ((ch) == '\t' || (ch) == ' ' || (ch) == '\r');
}

inline CHAR * SkipNonWhite( CHAR * pch )
{
	while (*pch && !IsWhiteA(*pch))
		pch++;

	return pch;
}

inline CHAR * SkipWhite( CHAR * pch )
{
	while (IsWhiteA(*pch) || (*pch == ')') || (*pch == '('))
		pch++;

	return pch;
}

int GetNumber( CHAR ** ppch )
{
	CHAR * pch = *ppch;
	INT	   n;

	//	Make sure we don't get into the URL
	//
	while ( *pch &&
			!isdigit( *pch ) &&
			!isalpha( *pch ) &&
			*pch != '/'		 &&
			*pch != '\r'	 &&
			*pch != '\n' )
	{
		pch++;
	}

	if ( !isdigit( *pch ) )
		return -1;

	n = atoi( pch );

	while ( isdigit( *pch ))
		pch++;

	*ppch = pch;
	return n;
}

int pointinpoly(int point_x, int point_y, double pgon[MAXVERTS][2])
{
	int i, numverts, inside_flag, xflag0;
	int crossings;
	double *p, *stop;
	double tx, ty, y;

	for (i = 0; pgon[i][X] != -1 && i < MAXVERTS; i++)
		;

	numverts = i;
	crossings = 0;

	tx = (double) point_x;
	ty = (double) point_y;
	y = pgon[numverts - 1][Y];

	p = (double *) pgon + 1;

	if ((y >= ty) != (*p >= ty))
	{
		if ((xflag0 = (pgon[numverts - 1][X] >= tx)) == (*(double *) pgon >= tx))
		{
			if (xflag0)
				crossings++;
		}
		else
		{
			crossings += (pgon[numverts - 1][X] - (y - ty) *
			(*(double *) pgon - pgon[numverts - 1][X]) /
			(*p - y)) >= tx;
		}
	}

	stop = pgon[numverts];

	for (y = *p, p += 2; p < stop; y = *p, p += 2)
	{
		if (y >= ty)
		{
			while ((p < stop) && (*p >= ty))
				p += 2;

			if (p >= stop)
				break;

			if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
			{
				if (xflag0)
					crossings++;
			}
			else
			{
				crossings += (*(p - 3) - (*(p - 2) - ty) *
					(*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
			}
		}
		else
		{
			while ((p < stop) && (*p < ty))
				p += 2;

			if (p >= stop)
				break;

			if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
			{
				if (xflag0)
					crossings++;

			}
			else
			{
				crossings += (*(p - 3) - (*(p - 2) - ty) *
					(*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
			}
		}
	}

	inside_flag = crossings & 0x01;
	return (inside_flag);
}

BOOL
FSearchMapFile (LPCSTR pszMap,
	INT x,
	INT y,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf)
{
	BOOL fRet = FALSE;
	CHAR * pch;
	CHAR * pchDefault = NULL;
	CHAR * pchPoint = NULL;
	CHAR * pchStart;
	UINT cchUrl;
	UINT dis;
	UINT bdis = static_cast<UINT>(-1);
	BOOL fComment = FALSE;
	BOOL fIsNCSA = FALSE;
	LPSTR pURL;					// valid only if fIsNCSA is TRUE

	//	We should now be ready to parse the map.  Here is where the
	//	IIS code begins.
	//
	fRet = TRUE;

	//	Loop through the contents of the buffer and see what we've got
	//
	for (pch = const_cast<CHAR *>(pszMap); *pch; )
	{
		fIsNCSA = FALSE;

		//	note: _tolower doesn't check case (tolower does)
		//
		switch( ( *pch >= 'A' && *pch <= 'Z' ) ? _tolower( *pch ) : *pch )
		{
			case '#':

				fComment = TRUE;
				break;

			case '\r':
			case '\n':

				fComment = FALSE;
				break;

			//	Rectangle
			//
			case 'r':
			case 'o':

				//	In the IIS code, "oval" and "rect" are treated the
				//	same.  The code is commented with a BUGBUG comment.
				//
				if( !fComment &&
					( !_strnicmp( "rect", pch, 4)
					  // BUGBUG handles oval as a rect, as they are using
					  // the same specification format. Should do better.
					  || !_strnicmp( "oval", pch, 4 )) )
				{
					INT x1, y1, x2, y2;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					x1 = GetNumber( &pch );
					y1 = GetNumber( &pch );
					x2 = GetNumber( &pch );
					y2 = GetNumber( &pch );

					if ( x >= x1 && x < x2 &&
						 y >= y1 && y < y2	 )
					{
						if ( fIsNCSA )
							pch = pURL;
						goto Found;
					}

					//	Skip the URL
					//
					if( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				break;

			//	Circle
			//
			case 'c':
				if ( !fComment &&
					 !_strnicmp( "circ", pch, 4 ))
				{
					INT xCenter, yCenter, xEdge, yEdge;
					INT r1, r2;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if ( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					//	Get the center and edge of the circle
					//
					xCenter = GetNumber( &pch );
					yCenter = GetNumber( &pch );

					xEdge = GetNumber( &pch );
					yEdge = GetNumber( &pch );

					//	If there's a yEdge, then we have the NCSA format, otherwise
					//	we have the CERN format, which specifies a radius
					//
					if ( yEdge != -1 )
					{
						r1 = ((yCenter - yEdge) * (yCenter - yEdge)) +
							 ((xCenter - xEdge) * (xCenter - xEdge));

						r2 = ((yCenter - y) * (yCenter - y)) +
							 ((xCenter - x) * (xCenter - x));

						if ( r2 <= r1 )
						{
							if ( fIsNCSA )
								pch = pURL;
							goto Found;
						}
					}
					else
					{
						INT radius;

						//	CERN format, third param is the radius
						//
						radius = xEdge;

						if ( SQR( xCenter - x ) + SQR( yCenter - y ) <=
							 SQR( radius ))
						{
							if ( fIsNCSA )
								pch = pURL;
							goto Found;
						}
					}

					//	Skip the URL
					//
					if ( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				break;

			//	Polygon
			//
			case 'p':
				if ( !fComment &&
					 !_strnicmp( "poly", pch, 4 ))
				{
					double pgon[MAXVERTS][2];
					DWORD  i = 0;
					BOOL fOverflow = FALSE;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if ( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					//	Build the array of points
					//
					while ( *pch && *pch != '\r' && *pch != '\n' )
					{
						pgon[i][0] = GetNumber( &pch );

						//
						//	Did we hit the end of the line (and go past the URL)?
						//

						if ( pgon[i][0] != -1 )
						{
							pgon[i][1] = GetNumber( &pch );
						}
						else
						{
							break;
						}

						if ( i < MAXVERTS-1 )
						{
							i++;
						}
						else
						{
							fOverflow = TRUE;
						}
					}

					pgon[i][X] = -1;

					if ( !fOverflow && pointinpoly( x, y, pgon ))
					{
						if ( fIsNCSA )
							pch = pURL;
						goto Found;
					}

					//	Skip the URL
					//
					if ( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				else if ( !fComment &&
						  !_strnicmp( "point", pch, 5 ))
				{
					INT x1,y1;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );
					pch = SkipNonWhite( pch );

					x1 = GetNumber( &pch );
					y1 = GetNumber( &pch );

					x1 -= x;
					y1 -= y;
					dis = x1*x1 + y1*y1;
					if ( dis < bdis )
					{
						pchPoint = pURL;
						bdis = dis;
					}
				}
				break;

			//	Default URL
			//
			case 'd':
				if ( !fComment &&
					 !_strnicmp( "def", pch, 3 ) )
				{
					//
					//	Skip "default" (don't skip white space)
					//

					pch = SkipNonWhite( pch );

					pchDefault = pch;

					//
					//	Skip URL
					//

					pch = SkipWhite( pch );
					pch = SkipNonWhite( pch );
					continue;
				}
				break;
		}

		pch++;
		pch = SkipWhite( pch );
	}

	//	If we didn't find a mapping and a default was specified, use
	//	the default URL
	//
	if ( pchPoint )
	{
		pch = pchPoint;
		goto Found;
	}

	if ( pchDefault )
	{
		pch = pchDefault;
		goto Found;
	}

	DebugTrace ("Dav: no mapping found for (%d, %d)\n", x, y);
	goto Exit;

Found:

	//	pch should point to the white space immediately before the URL
	//
	pch = SkipWhite( pch );
	pchStart = pch;
	pch = SkipNonWhite( pch );

	//	Determine the length of the URL and copy it out
	//
	cchUrl = static_cast<UINT>(pch - pchStart);
	Assert (cchUrl < cchBuf);
	CopyMemory (pszRedirect, pchStart, cchUrl);
	*(pszRedirect + cchUrl) = 0;
	*pfRedirect = TRUE;

	DebugTrace ("Dav: mapping for (%d, %d) is %hs\n", x, y, pszRedirect);

Exit:
	return fRet;
}

BOOL
FIsMapProcessed (
	LPCSTR lpszQueryString,
	LPCSTR lpszUrlPrefix,
	LPCSTR lpszServerName,
	LPCSTR pszMap,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf)
{
	INT x = 0;
	INT y = 0;
	LPCSTR pch = lpszQueryString;

	//	Ensure the *pfRedirect is initialized
	//
	Assert( pfRedirect );
	*pfRedirect = FALSE;

	//	If there is no query string, I don't think we want to process
	//	the file as if it were a .map request.
	//
	if ( pch == NULL )
		return TRUE;

	//	Get the x and y cooridinates of the mouse click on the image
	//
	x = strtoul( pch, NULL, 10 );

	//	Move past x and any intervening delimiters
	//
	while ( isdigit( *pch ))
		pch++;
	while ( *pch && !isdigit( *pch ))
		pch++;
	y = strtoul( pch, NULL, 10 );

	//	Search the map file
	//
	if ( !FSearchMapFile( pszMap,
						  x,
						  y,
						  pfRedirect,
						  pszRedirect,
						  cchBuf))
	{
		DebugTrace ("Dav: FSearchMapFile() failed with %ld\n", GetLastError());
		return FALSE;
	}

	//	If no redirected URL was passed back, then we are done.
	//
	if ( !*pfRedirect )
	{
		//	Returning true does not indicate success, it really
		//	just means that there were no processing errors
		//
		goto ret;
	}

	//	If the found URL starts with a forward slash ("/foo/bar/doc.htm")
	//	and it doesn't contain a bookmark ('#') then the URL is local and
	//	we build a fully qualified URL to send back to the client. We assume
	//	it's a fully qualified URL ("http://foo/bar/doc.htm") and send the
	//	client a redirection notice to the mapped URL
	//
	if ( *pszRedirect == '/' )
	{
		CHAR rgch[MAX_PATH];
		UINT cch;
		UINT cchUri;

        if ( strlen(lpszUrlPrefix) + strlen(lpszServerName) >= MAX_PATH )
        {
            return FALSE;
        }

		//	Build up the full qualification to the url
		//
		strcpy (rgch, lpszUrlPrefix);
		strcat (rgch, lpszServerName);

		//	See how much we need to shif the URL by
		//
		cch = static_cast<UINT>(strlen (rgch));
		cchUri = static_cast<UINT>(strlen (pszRedirect));
		Assert (cchBuf > (cchUri + cch));
		MoveMemory (pszRedirect + cch, pszRedirect, cchUri + 1);
		CopyMemory (pszRedirect, rgch, cch);
	}

ret:
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\header.h ===
#ifndef _HEADER_H_
#define _HEADER_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HEADER.H
//
//		Header for HTTP header cache class.
//		This cache is meant to hold pairs of strings, indexed by the first
//		string in the pair.  The indexing string will be treated
//		as case-insensitive (Content-Type and content-type are treated as
//		the same slot in the cache).
//
//	NOTE: Header names are NOT localized strings -- they are always 7-bit ASCII,
//		and should NEVER be treated as MBCS strings.
//		Later, this cache might make optimizations that depend on the indexing
//		string being 7-bit ASCII.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CHeaderCache
//
#include "gencache.h"

template<class _T>
class CHeaderCache
{
	typedef CCache<CRCSzi, const _T *> CHdrCache;

	// String data storage area.
	//
	ChainedStringBuffer<_T>	m_sb;

protected:

	// Cache of header values, keyed by CRC'd name
	//
	CHdrCache					m_cache;

	//	NOT IMPLEMENTED
	//
	CHeaderCache& operator=( const CHeaderCache& );
	CHeaderCache( const CHeaderCache& );

public:
	//	CREATORS
	//
	CHeaderCache()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();
	}

	//	ACCESSORS
	//

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::LpszGetHeader()
	//
	//		Fetch a header from the cache.  Return the header value if found,
	//		NULL otherwise.
	//
	const _T * LpszGetHeader( LPCSTR pszName ) const
	{
		const _T ** ppszValue;

		Assert( pszName );

		ppszValue = m_cache.Lookup( CRCSzi(pszName) );
		if ( !ppszValue )
			return NULL;

		return *ppszValue;
	}

	//	MANIPULATORS
	//

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::ClearHeaders()
	//
	//		Clear all headers from the cache.
	//
	void ClearHeaders()
	{
		//	Clear all data from the map.
		//
		m_cache.Clear();

		//	Also clear out the string buffer.
		//
		m_sb.Clear();
	}
	
	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::DeleteHeader()
	//
	//		Remove a header from the cache.
	//
	void DeleteHeader( LPCSTR pszName )
	{
		//
		//	Note: this just removes the cache item (i.e. the header
		//	name/value pair).  It DOES NOT free up the memory used by the
		//	header name/value strings which are stored in our string buffer.
		//	We would need a string buffer class which supports deletion
		//	(and a smarter string class) for that.
		//
		m_cache.Remove( CRCSzi(pszName) );
	}

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::SetHeader()
	//
	//		Set a header in the cache.
	//		If pszValue NULL, just set NULL as the header value.
	//		If pszValue is the empty string, just set the header string to the
	//		empty string.
	//		Return the string's cache placement (same as GetHeader) for convenience.
	//
	//	NOTE:
	//		fMultiple is an optional param that defaults to FALSE
	//
	const _T * SetHeader( LPCSTR pszName, const _T * pszValue, BOOL fMultiple = FALSE)
	{
		Assert( pszName );

		pszName = reinterpret_cast<LPCSTR>(m_sb.Append( static_cast<UINT>(strlen(pszName) + 1), reinterpret_cast<const _T *>(pszName) ));
		if ( pszValue )
		{
			if (sizeof(_T) == sizeof(WCHAR))
			{
				pszValue = m_sb.Append( static_cast<UINT>(CbSizeWsz(wcslen(reinterpret_cast<LPCWSTR>(pszValue)))), pszValue );
			}
			else
			{
				pszValue = m_sb.Append( static_cast<UINT>(strlen(reinterpret_cast<LPCSTR>(pszValue)) + 1), pszValue );
			}
		}

		if (fMultiple)
			(void)m_cache.FAdd( CRCSzi(pszName), pszValue );
		else
			(void)m_cache.FSet( CRCSzi(pszName), pszValue );

		return pszValue;
	}

};

class CHeaderCacheForResponse : public CHeaderCache<CHAR>
{
	//	========================================================================
	//
	//	CLASS CEmit
	//
	//	Functional class to emit a header name/value pair to a buffer
	//
	class CEmit : public CHdrCache::IOp
	{
		StringBuffer<CHAR>&	m_bufData;

		//	NOT IMPLEMENTED
		//
		CEmit& operator=( const CEmit& );

	public:
		CEmit( StringBuffer<CHAR>& bufData ) : m_bufData(bufData) {}

		virtual BOOL operator()( const CRCSzi& crcsziName,
								 const LPCSTR& pszValue )
		{
			//	Throw in the header name string.
			//
			m_bufData.Append( crcsziName.m_lpsz );

			//	Throw in a colon delimiter.
			//
			m_bufData.Append( gc_szColonSp );

			//	Throw in the header value string.
			//
			m_bufData.Append( pszValue );

			//	Terminate the header line (CRLF).
			//
			m_bufData.Append( gc_szCRLF );

			//	Tell the cache to keep iterating.
			//
			return TRUE;
		}
	};

	//	NOT IMPLEMENTED
	//
	CHeaderCacheForResponse& operator=( const CHeaderCacheForResponse& );
	CHeaderCacheForResponse( const CHeaderCacheForResponse& );

public:
	//	CREATORS
	//
	CHeaderCacheForResponse()
	{
	}

	void DumpData( StringBuffer<CHAR>& bufData ) const;
};

#endif // !_HEADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\instdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	INSTDATA.CPP
//
//		HTTP instance data cache implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <buffer.h>
#include "instdata.h"

//	========================================================================
//
//	class CInstData
//

//	------------------------------------------------------------------------
//
//	CInstData::CInstData()
//
//		Constructor.  Init all variables.  Make a copy of the name string
//		for us to keep.
//
//		NOTE: This object must be constructed while we are REVERTED.
//
CInstData::CInstData( LPCSTR szName )
{
	//	Make our own copy of the instance name.
	//
	m_szVRoot = LpszAutoDupSz( szName );

	//	Make copy of wide instance name
	//
	m_wszVRoot = LpwszWideVroot( szName );

	//	Parse out and store service instance, otherwise
	//	sometimes referred as the server ID.
	//
	m_lServerID = LInstFromVroot( m_szVRoot );
	
	//	Create our objects.  Please read the notes about the
	//	relative costs and reasons behind creating these objects
	//	now rather than on demand.  Don't create anything here that
	//	can be created on demand unless at least one of the
	//	following is true:
	//
	//		1. The object is lightweight and cheap to create.
	//		   Example: an empty cache.
	//
	//		2. The object is used in the processing of a vast
	//		   majority of HTTP requests.
	//		   Example: any object used on every GET request.
	//

	//	Create the perf counters for this instance.
	//	Perf counters are used everywhere.  (Or at least
	//	they should be!)
	//
	m_pPerfCounterBlock = NewVRCounters( m_szVRoot );

}

//	------------------------------------------------------------------------
//
//	CInstData::LpwszWideVroot()
//
//		Init the wide version of the name, it and return it to the caller.
//
LPWSTR
CInstData::LpwszWideVroot( LPCSTR pszVRoot )
{
	auto_heap_ptr<WCHAR> pwszVRoot;
	
	UINT cbVRoot = static_cast<UINT>(strlen(pszVRoot));
	pwszVRoot = static_cast<LPWSTR>(g_heap.Alloc (CbSizeWsz(cbVRoot)));

	UINT cch = MultiByteToWideChar(CP_ACP,
								   MB_ERR_INVALID_CHARS,
								   pszVRoot,
								   cbVRoot + 1,
								   pwszVRoot,
								   cbVRoot + 1);
	if (0 == cch)
	{
		DebugTrace( "CInstData::LpwszWideVroot() - MultiByteToWideChar() failed 0x%08lX\n",
					HRESULT_FROM_WIN32(GetLastError()) );

		throw CLastErrorException();
	}

	return pwszVRoot.relinquish();
}

//	========================================================================
//
//	class CInstDataCache
//

//	------------------------------------------------------------------------
//
//	CInstDataCache::GetInstData()
//
//		Fetch a row from the cache.
//
CInstData& CInstDataCache::GetInstData( const IEcb& ecb )
{
	auto_ref_ptr<CInstData> pinst;
	char rgchMetaPath[MAX_PATH];
	char rgchVRoot[MAX_PATH];
	LPCSTR pszRootName;
	UINT cch;
	ULONG ulSize;

	//	Format string used in building the instance data name.
	//
	static char szVRootFormat[] = "%s/root%s";
		// NOTE: We're using the leading '/' from the root name
		// to separate "root" from <vroot name> (second %s above).

	//	Build up a unique string from the vroot and instance:
	//	lm/w3svc/<site id>/root/<vroot name>
	//

	//	Get the virtual root from the ecb (accessor).
	//
	cch = ecb.CchGetVirtualRoot( &pszRootName );

	//	pszRootName should still be NULL-terminated.  Check it, 'cause
	//	we're going to put the next string after there, and we don't want
	//	to get them mixed....
	//
	Assert( pszRootName );
	Assert( !pszRootName[cch] );

	//	Ask IIS for the metabase prefix for the virtual server (site) we're on...
	//
	ulSize = CElems(rgchMetaPath);
	if ( !ecb.FGetServerVariable( "INSTANCE_META_PATH",
								  rgchMetaPath, &ulSize ) )
	{
		DebugTrace( "CInstDataCache::GetInstData() - GetServerVariable() failed"
					" to get INSTANCE_META_PATH\n" );
		throw CLastErrorException();
	}

	//	Check that the root name is either NULL (zero-length string)
	//	or has its own separator.
	//
	//	NOTE: This is conditional because IF we are installed at the ROOT
	//	(on w3svc/1 or w3svc/1/root) and you throw a method against
	//	a file that doesn't live under a registered K2 vroot
	//	(like /default.asp) -- we DO get called, but the mi.cchMatchingURL
	//	comes back as 0, so pszRootName is a zero-len string.
	//	(In IIS terms, you are not really hitting a virtual root,
	//	so your vroot is "".)
	//	I'm making this assert CONDITIONAL until we figure out more about
	//	how we'll handle this particular install case.
	//$REVIEW: The installed-at-the-root case needs to be examined more
	//$REVIEW: becuase we DON'T always build the same instance string
	//$REVIEW: in that case -- we'll still get vroot strings when the URI
	//$REVIEW: hits a resource under a REGISTERED vroot, and so we'll
	//$REVIEW: build different strings for the different vroots, even though
	//$REVIEW: we are running from a single, global install of DAV.
	//$REVIEW: The name might need to be treated as a starting point for a lookup.
	//	NTBug #168188: On OPTIONS, "*" is a valid URI.  Need to handle this
	//	special case without asserting.
	//
	AssertSz( ('*' == pszRootName[0] && 1 == cch) ||
			  !cch ||
			  '/' == pszRootName[0],
			  "(Non-zero) VRoot name doesn't have expected slash delimiter.  Instance name string may be malformed!" );

	//	Build the final vroot string. LM/w3svc/<id>/root/<vroot>
	//	NOTE: id is the site-determiner.  Different IP addresses or different
	//	hostnames map to different sites.  The first site is id 1.
	//	NTBug # 168188: Special case for OPTIONS * -- map us to the root
	//	instdata name of "/w3svc/#/root" (don't want an instdata named
	//	"/w3svc/#/root*" that noone else can ever use!).
	//
	if ('*' == pszRootName[0] && 1 == cch)
		wsprintfA( rgchVRoot, szVRootFormat, rgchMetaPath, gc_szEmpty );
	else
		wsprintfA( rgchVRoot, szVRootFormat, rgchMetaPath, pszRootName );

	//	Slam the string to lower-case so that all variations on the vroot
	//	name will match.  (IIS doesn't allow vroots with the same name --
	//	and "VRoot" and "vroot" count as the same!)
	//
	_strlwr( rgchVRoot );

	//
	//	Demand load the instance data for this vroot
	//
	{
		CRCSz crcszVRoot( rgchVRoot );

		while ( !Instance().m_cache.FFetch( crcszVRoot, &pinst ) )
		{
			CInitGate ig( L"DAV/CInstDataCache::GetInstData/", rgchVRoot );

			if ( ig.FInit() )
			{
				//	Setup instance data from the system security context,
				//	not the client's security context.
				//
				safe_revert sr(ecb.HitUser());

				pinst = new CInstData(rgchVRoot);

				//	Since we are going to use this crcsz as a key in a cache,
				//	need to make sure that it's built on a name string that
				//	WON'T EVER MOVE (go away, get realloc'd).  The stack-based one
				//	above just isn't good enough.  SO, build a new little CRC-dude
				//	on the UNMOVABLE name data in the inst object.
				//	(And check that this new crc matches the old one!)
				//
				CRCSz crcszAdd( pinst->GetName() );
				AssertSz( crcszVRoot.isequal(crcszAdd),
						  "Two CRC's from the same string don't match!" );

				Instance().m_cache.Add( crcszAdd, pinst );

				//	Log the fact that we've got a new instance pluged in.
				//	Message DAVPRS_VROOT_ATTACH takes two parameters:
				//	the signature of the impl and the vroot.
				//
				//$	RAID:NT:283650: Logging each attach causes a large
				//	number of events to be registered.  We really should
				//	only Log one-time-startup/failure events.
				//
				#undef	LOG_STARTUP_EVENT
				#ifdef	LOG_STARTUP_EVENT
				{
					LPCSTR	lpStrings[2];

					lpStrings[0] = gc_szSignature;
					lpStrings[1] = rgchVRoot;
					LogEvent( DAVPRS_VROOT_ATTACH,
							  EVENTLOG_INFORMATION_TYPE,
							  2,
							  lpStrings,
							  0,
							  NULL );
				}
				#endif	// LOG_STARTUP_EVENT
				//
				//$	RAID:X5:283650: end.

				break;
			}
		}
	}

	return *pinst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\if.cpp ===
/*
 *	I F . C P P
 *
 *	If-xxx header processing and ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"

//$ REVIEW: This file was once the same as \exdav\davif.cpp.  
//$ REVIEW: These two files should really be merged.  They share a lot of 
//$ REVIEW: common functionality, but they have been evolving separately.
//$ REVIEW: We need to be very careful because different bug fixes have 
//$ REVIEW: been going into each of them.

//	ETag formation ------------------------------------------------------------
//
/*
 *	FETagFromFiletime()
 *
 *	Purpose:
 *
 *		Derives an ETag for a given resource or a given last modification
 *		time.
 *
 *	Parameters:
 *
 *		pft			[in]  last modification time
 *		pwszETag	[out] ETag buffer
 *
 *	Returns:
 *
 *		TRUE if ETag was created.
 */
BOOL
FETagFromFiletime (FILETIME * pft, LPWSTR pwszEtag)
{
	Assert (pwszEtag);
	swprintf (pwszEtag,
			 L"\"%x%x%x%x%x%x%x%x:%x\"",
			 (DWORD)(((PUCHAR)pft)[0]),
			 (DWORD)(((PUCHAR)pft)[1]),
			 (DWORD)(((PUCHAR)pft)[2]),
			 (DWORD)(((PUCHAR)pft)[3]),
			 (DWORD)(((PUCHAR)pft)[4]),
			 (DWORD)(((PUCHAR)pft)[5]),
			 (DWORD)(((PUCHAR)pft)[6]),
			 (DWORD)(((PUCHAR)pft)[7]),
			 DwMDChangeNumber());
	return TRUE;
}

//	If-xxx header processing --------------------------------------------------
//
SCODE
ScCheckEtagAgainstHeader (LPCWSTR pwszEtag, LPCWSTR pwszHeader)
{
	LPCWSTR pwsz;
	Assert (pwszHeader);

	//	Get the ETag we are going to compare against, and then
	//	look at what was passed it.  It should either be an ETAG
	//	or an '*'.  We fail if the value does not exist or the
	//	ETag does not match.
	//
	HDRITER_W hdri(pwszHeader);

	for (pwsz = hdri.PszNext(); pwsz; pwsz = hdri.PszNext())
	{
		//	Since we do not do week ETAG checking, if the
		//	ETAG starts with "W/" skip those bits
		//
		if (L'W' == *pwsz)
		{
			Assert (L'/' == pwsz[1]);
			pwsz += 2;
		}

		//	If we see stars, then we match
		//
		if (L'*' == *pwsz)
			return S_OK;
		else
		{
			//	For DAVFS, we don't do weak matching today
			//
			if (pwszEtag && !wcscmp (pwsz, pwszEtag))
				return S_OK;
		}
	}
	return E_DAV_IF_HEADER_FAILURE;
}

SCODE
ScCheckFileTimeAgainstHeader (FILETIME * pft, LPCWSTR pwszHeader)
{
	FILETIME ftHeader;
	FILETIME ftTmp;
	SYSTEMTIME st;

	Assert (pft);
	Assert (pwszHeader);

	//	The header passed in here should be an HTTP-date
	//	of the format "ddd, dd, mmm yyyy HH:mm:ss GMT".
	//	We can spit this into a SYSTEMTIME and then compare
	//	it against the filetime for the resource.
	//
	DebugTrace ("DAV: evaluating If-Unmodified-Since header\n");

	memset (&st, 0, sizeof(SYSTEMTIME));

	if (SUCCEEDED (HrHTTPDateToFileTime(pwszHeader, &ftHeader)))
	{
		FILETIME 	ftCur;
		
		//	The filetime retrieved from FGetLastModTime is acurate
		//	down to 100-nanosecond increments.  The converted date
		//	is acurate down to seconds.  Adjust for that.
		//
		FileTimeToSystemTime (pft, &st);
		st.wMilliseconds = 0;
		SystemTimeToFileTime (&st, &ftTmp);

		//	Get current time
		//
        GetSystemTimeAsFileTime(&ftCur);

		//	Compare the two filetimes
		//	Note that we also need to make sure the Modified-Since time is
		//	less than our current time
		//
		if ((CompareFileTime (&ftHeader, &ftTmp) >= 0) &&
			(CompareFileTime (&ftHeader, &ftCur) < 0))
			return S_OK;

		return E_DAV_IF_HEADER_FAILURE;
	}

	return S_FALSE;
}


SCODE
ScCheckIfHeaders(IMethUtil * pmu,
				 FILETIME * pft,
				 BOOL fGetMethod)
{
	WCHAR pwszEtag[CCH_ETAG];
	SideAssert(FETagFromFiletime (pft, pwszEtag));
	
	return ScCheckIfHeadersFromEtag (pmu,
									 pft,
									 fGetMethod,
									 pwszEtag);
}

SCODE
ScCheckIfHeadersFromEtag (IMethUtil * pmu,
						  FILETIME* pft,
						  BOOL fGetMethod,
						  LPCWSTR pwszEtag)
{
	SCODE sc = S_OK;
	LPCWSTR pwsz;
	
	Assert (pmu);
	Assert (pft);
	Assert (pwszEtag);

	//	There're several bugs related with DAV not matching IIS behavior
	//	on these If-xxx header processing.
	//	So we now just copy their logic over
	
	//	Check the 'if-match' header
	//
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-match' header\n");
		sc = ScCheckEtagAgainstHeader (pwszEtag, pwsz);
		if (FAILED (sc))
			goto ret;
	}

    // Now see if we have an If-None-Match, and if so handle that.
    //
    BOOL fIsNoneMatchPassed = TRUE;
    BOOL fSkipIfModifiedSince = FALSE;
	
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_None_Match, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-none-match' header\n");
		if (!FAILED (ScCheckEtagAgainstHeader (pwszEtag, pwsz)))
		{
			//	Etag match, so nonmatch test is NOT passed
			//
			fIsNoneMatchPassed = FALSE;
		}
		else
		{
			fSkipIfModifiedSince = TRUE;
		}
	}
	
	//	The "if-modified-since" really only applies to GET-type
	//	requests
	//
	if (!fSkipIfModifiedSince && fGetMethod)
	{
		if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Modified_Since, FALSE)) != NULL)
		{
			DebugTrace ("DAV: evaluating 'if-none-match' header\n");
			if (S_OK == ScCheckFileTimeAgainstHeader (pft, pwsz))
			{
				sc = fGetMethod
					 ? E_DAV_ENTITY_NOT_MODIFIED
					 : E_DAV_IF_HEADER_FAILURE;
				goto ret;
			}

			fIsNoneMatchPassed = TRUE;
		}
	}

	if (!fIsNoneMatchPassed)
	{
		sc = fGetMethod
			 ? E_DAV_ENTITY_NOT_MODIFIED
			 : E_DAV_IF_HEADER_FAILURE;
		goto ret;
	}

    // Made it through that, handle If-Unmodified-Since if we have that.
    //
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Unmodified_Since, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-unmodified-since' header\n");
		sc = ScCheckFileTimeAgainstHeader (pft, pwsz);
		if (FAILED (sc))
			goto ret;
	}

ret:

	if (sc == E_DAV_ENTITY_NOT_MODIFIED)
	{
		//	Let me quote from the HTTP/1.1 draft...
		//
		//	"The response MUST include the following header fields:
		//
		//	...
		//
		//	.  ETag and/or Content-Location, if the header would have been sent in
		//	a 200 response to the same request
		//
		//	..."
		//
		//	So what that means, is that we really just want to do is suppress the
		//	body of the response, set a 304 error code and do everything else as
		//	normal.  All of which is done by setting a hsc of 304.
		//
		DebugTrace ("Dav: suppressing body for 304 response\n");
		pmu->SetResponseCode (HSC_NOT_MODIFIED, NULL, 0);
		sc = S_OK;
	}

	return sc;
}

SCODE
ScCheckIfRangeHeader (IMethUtil * pmu, FILETIME * pft)
{
	WCHAR pwszEtag[CCH_ETAG];
	SideAssert(FETagFromFiletime (pft, pwszEtag));

	return ScCheckIfRangeHeaderFromEtag (pmu, pft, pwszEtag);
}

SCODE
ScCheckIfRangeHeaderFromEtag (IMethUtil * pmu, FILETIME * pft, LPCWSTR pwszEtag)
{
	SCODE sc = S_OK;
	LPCWSTR pwsz;

	Assert (pmu);
	Assert (pft);
	Assert (pwszEtag);

	//	Check "If-Range". Do not apply URL conversion rules to this header
	//
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Range, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-range' header\n");

		//	The format of this header is either an ETAG or a
		//	date.  Process accordingly...
		//
		if ((L'"' == *pwsz) || (L'"' == *(pwsz + 2)))
		{
			if (L'W' == *pwsz)
			{
				Assert (L'/' == *(pwsz + 1));
				pwsz += 2;
			}
			sc = ScCheckEtagAgainstHeader (pwszEtag, pwsz);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			sc = ScCheckFileTimeAgainstHeader (pft, pwsz);
			goto ret;
		}
	}

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\method.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	METHOD.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <statcode.h>
#include "ecb.h"
#include "instdata.h"


//	------------------------------------------------------------------------
//
//	DAVUnsupported()
//
//	Execute an unsupported method --> Return "501 Not Supported" to client
//
void
DAVUnsupported( LPMETHUTIL pmu )
{
	//	Get our access perms
	//
	SCODE sc = S_OK;
	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

ret:
	pmu->SetResponseCode( FAILED(sc)
							  ? HscFromHresult(sc)
							  : HSC_NOT_IMPLEMENTED,
						  NULL,
						  0 );
}

//	========================================================================
//
//	STRUCT SMethod
//
//	Encapsulates DAV method execution information.
//
//	This is represented as a structure rather than a class since the method
//	objects are all const globals and MSVC won't initialize global objects
//	in a DLL to anything but 0-filled memory without an explicit call to
//	_CRT_INIT at process attach.  _CRT_INIT is too expensive to call just
//	to initialize globals with constant data values which are known
//	at compile time.
//
typedef struct SMethod
{
	//
	//	Verb ("GET", "PUT", etc.)
	//
	//
	LPCSTR						lpszVerb;
	LPCWSTR						pwszVerb;

	//
	//	Method ID
	//
	METHOD_ID					mid;

	//
	//	Implementation execution function
	//
	DAVMETHOD *					Execute;

	//
	//	Verb-specific perf counter indices
	//
	UINT						ipcTotal;
	UINT						ipcPerSec;

} SMethod;

const SMethod g_rgMethods[] =
{
	//
	//	For best performance, entries in this array should be
	//	ordered by relative frequency.
	//
	//$OPT	Right now, they obviously are not.
	//
	{
		"OPTIONS",
		L"OPTIONS",
		MID_OPTIONS,
		DAVOptions,
		IPC_TOTAL_OPTIONS_REQUESTS,
		IPC_OPTIONS_REQUESTS_PER_SECOND
	},
	{
		"GET",
		L"GET",
		MID_GET,
		DAVGet,
		IPC_TOTAL_GET_REQUESTS,
		IPC_GET_REQUESTS_PER_SECOND
	},
	{
		"HEAD",
		L"HEAD",
		MID_HEAD,
		DAVHead,
		IPC_TOTAL_HEAD_REQUESTS,
		IPC_HEAD_REQUESTS_PER_SECOND
	},
	{
		"PUT",
		L"PUT",
		MID_PUT,
		DAVPut,
		IPC_TOTAL_PUT_REQUESTS,
		IPC_PUT_REQUESTS_PER_SECOND
	},
	{
		"POST",
		L"POST",
		MID_POST,
		DAVPost,
		IPC_TOTAL_POST_REQUESTS,
		IPC_POST_REQUESTS_PER_SECOND
	},
	{
		"MOVE",
		L"MOVE",
		MID_MOVE,
		DAVMove,
		IPC_TOTAL_MOVE_REQUESTS,
		IPC_MOVE_REQUESTS_PER_SECOND
	},
	{
		"COPY",
		L"COPY",
		MID_COPY,
		DAVCopy,
		IPC_TOTAL_COPY_REQUESTS,
		IPC_COPY_REQUESTS_PER_SECOND
	},
	{
		"DELETE",
		L"DELETE",
		MID_DELETE,
		DAVDelete,
		IPC_TOTAL_DELETE_REQUESTS,
		IPC_DELETE_REQUESTS_PER_SECOND
	},
	{
		"MKCOL",
		L"MKCOL",
		MID_MKCOL,
		DAVMkCol,
		IPC_TOTAL_MKCOL_REQUESTS,
		IPC_MKCOL_REQUESTS_PER_SECOND
	},
	{
		"PROPFIND",
		L"PROPFIND",
		MID_PROPFIND,
		DAVPropFind,
		IPC_TOTAL_PROPFIND_REQUESTS,
		IPC_PROPFIND_REQUESTS_PER_SECOND
	},
	{
		"PROPPATCH",
		L"PROPPATCH",
		MID_PROPPATCH,
		DAVPropPatch,
		IPC_TOTAL_PROPPATCH_REQUESTS,
		IPC_PROPPATCH_REQUESTS_PER_SECOND,
	},
	{
		"SEARCH",
		L"SEARCH",
		MID_SEARCH,
		DAVSearch,
		IPC_TOTAL_SEARCH_REQUESTS,
		IPC_SEARCH_REQUESTS_PER_SECOND
	},
	{
		"LOCK",
		L"LOCK",
		MID_LOCK,
		DAVLock,
		IPC_TOTAL_LOCK_REQUESTS,
		IPC_LOCK_REQUESTS_PER_SECOND
	},
	{
		"UNLOCK",
		L"UNLOCK",
		MID_UNLOCK,
		DAVUnlock,
		IPC_TOTAL_UNLOCK_REQUESTS,
		IPC_UNLOCK_REQUESTS_PER_SECOND
	},
	{
		"SUBSCRIBE",
		L"SUBSCRIBE",
		MID_SUBSCRIBE,
		DAVSubscribe,
		IPC_TOTAL_SUBSCRIBE_REQUESTS,
		IPC_SUBSCRIBE_REQUESTS_PER_SECOND
	},
	{
		"UNSUBSCRIBE",
		L"UNSUBSCRIBE",
		MID_UNSUBSCRIBE,
		DAVUnsubscribe,
		IPC_TOTAL_UNSUBSCRIBE_REQUESTS,
		IPC_UNSUBSCRIBE_REQUESTS_PER_SECOND
	},
	{
		"POLL",
		L"POLL",
		MID_POLL,
		DAVPoll,
		IPC_TOTAL_POLL_REQUESTS,
		IPC_POLL_REQUESTS_PER_SECOND
	},
	{
		"BDELETE",
		L"BDELETE",
		MID_BATCHDELETE,
		DAVBatchDelete,
		IPC_TOTAL_BATCHDELETE_REQUESTS,
		IPC_BATCHDELETE_REQUESTS_PER_SECOND
	},
	{
		"BCOPY",
		L"BCOPY",
		MID_BATCHCOPY,
		DAVBatchCopy,
		IPC_TOTAL_BATCHCOPY_REQUESTS,
		IPC_BATCHCOPY_REQUESTS_PER_SECOND
	},
	{
		"BMOVE",
		L"BMOVE",
		MID_BATCHMOVE,
		DAVBatchMove,
		IPC_TOTAL_BATCHMOVE_REQUESTS,
		IPC_BATCHMOVE_REQUESTS_PER_SECOND
	},
	{
		"BPROPPATCH",
		L"BPROPPATCH",
		MID_BATCHPROPPATCH,
		DAVBatchPropPatch,
		IPC_TOTAL_BATCHPROPPATCH_REQUESTS,
		IPC_BATCHPROPPATCH_REQUESTS_PER_SECOND
	},
	{
		"BPROPFIND",
		L"BPROPFIND",
		MID_BATCHPROPFIND,
		DAVBatchPropFind,
		IPC_TOTAL_BATCHPROPFIND_REQUESTS,
		IPC_BATCHPROPFIND_REQUESTS_PER_SECOND
	},
	{
		"X-MS-ENUMATTS",
		L"X-MS-ENUMATTS",
		MID_X_MS_ENUMATTS,
		DAVEnumAtts,
		IPC_TOTAL_OTHER_REQUESTS,		//	no special perf count
		IPC_OTHER_REQUESTS_PER_SECOND	//	no special perf count
	},
	{
		NULL,
		NULL,
		MID_UNKNOWN,
		DAVUnsupported,
		IPC_TOTAL_OTHER_REQUESTS,
		IPC_OTHER_REQUESTS_PER_SECOND
	}

};

METHOD_ID
MidMethod (LPCSTR pszMethod)
{
	const SMethod * pMethod;

	for ( pMethod = g_rgMethods; pMethod->lpszVerb != NULL; pMethod++ )
		if ( !strcmp( pszMethod, pMethod->lpszVerb ) )
			break;

	return pMethod->mid;
}

METHOD_ID
MidMethod (LPCWSTR pwszMethod)
{
	const SMethod * pMethod;

	for ( pMethod = g_rgMethods; pMethod->pwszVerb != NULL; pMethod++ )
		if ( !wcscmp( pwszMethod, pMethod->pwszVerb ) )
			break;

	return pMethod->mid;
}


//	Debug SID vs Name ---------------------------------------------------------
//
#ifdef	DBG
VOID
SpitUserNameAndSID (CHAR * rgch)
{
	enum { TOKENBUFFSIZE = (256*6) + sizeof(TOKEN_USER)};

	auto_handle<HANDLE> hTok;
	BYTE tokenbuff[TOKENBUFFSIZE];
	TOKEN_USER *ptu = reinterpret_cast<TOKEN_USER *>(tokenbuff);
	ULONG ulcbTok = sizeof(tokenbuff);

	*rgch = '\0';

	//	Open the process and the process token, and get out the
	//	security ID.
	//
	if (!OpenThreadToken (GetCurrentThread(),
						  TOKEN_QUERY,
						  TRUE,  //$ TRUE for Process security!
						  hTok.load()))
	{
		if (ERROR_NO_TOKEN != GetLastError())
		{
			DebugTrace( "OpenThreadToken() failed %d\n", GetLastError() );
			return;
		}

		if (!OpenProcessToken (GetCurrentProcess(),
							   TOKEN_QUERY,
							   hTok.load()))
		{
			DebugTrace( "OpenProcessToken() failed %d\n", GetLastError() );
			return;
		}
	}

	if (GetTokenInformation	(hTok,
							 TokenUser,
							 ptu,
							 ulcbTok,
							 &ulcbTok))
	{
		ULONG IdentifierAuthority;
		BYTE * pb = (BYTE*)&IdentifierAuthority;
		SID * psid = reinterpret_cast<SID *>(ptu->User.Sid);

		for (INT i = 0; i < sizeof(ULONG); i++)
		{
			*pb++ = psid->IdentifierAuthority.Value[5-i];
		}
		wsprintfA (rgch, "S-%d-%d",
				   psid->Revision,
				   IdentifierAuthority);

		for (i = 0; i < psid->SubAuthorityCount; i++)
		{
			CHAR rgchT[10];
			wsprintfA (rgchT, "-%d", psid->SubAuthority[i]);
			lstrcatA (rgch, rgchT);
		}

		if (1 == psid->Revision)
		{
			if (0 == IdentifierAuthority)
				lstrcatA (rgch, " (Null)");
			if (1 == IdentifierAuthority)
				lstrcatA (rgch, " (World)");
			if (2 == IdentifierAuthority)
				lstrcatA (rgch, " (Local)");
			if (3 == IdentifierAuthority)
				lstrcatA (rgch, " (Creator)");
			if (4 == IdentifierAuthority)
				lstrcatA (rgch, " (Non-Unique)");
			if (5 == IdentifierAuthority)
				lstrcatA (rgch, " (NT)");
		}

		CHAR rgchAccount[MAX_PATH];
		CHAR rgchDomain[MAX_PATH];
		DWORD cbAccount = sizeof(rgchAccount);
		DWORD cbDomain = sizeof(rgchAccount);
		SID_NAME_USE snu;
		LookupAccountSidA (NULL,
						   psid,
						   rgchAccount,
						   &cbAccount,
						   rgchDomain,
						   &cbDomain,
						   &snu);
		lstrcatA (rgch, " ");
		lstrcatA (rgch, rgchDomain);
		lstrcatA (rgch, "\\");
		lstrcatA (rgch, rgchAccount);
		DavprsDbgHeadersTrace ("Dav: header: x-Dav-Debug-SID: %hs\n", rgch);
	}
}

VOID DebugAddSIDHeader( IMethUtil& mu )
{
	CHAR rgch[1024];

	if (!DEBUG_TRACE_TEST(DavprsDbgHeaders))
		return;

	SpitUserNameAndSID (rgch);
	mu.SetResponseHeader ("x-Dav-Debug-SID", rgch);
}

#else
#define DebugAddSIDHeader(_mu)
#endif	// DBG

// ----------------------------------------------------------------------------
//
//	CDAVExt::DwMain()
//
//	Invokes a DAV method.  This is THE function called by our IIS entrypoint
//	DwDavXXExtensionProc() to start processing a request.
//
//	If MINIMAL_ISAPI is defined, this function is implemented in another
//	file (.\appmain.cpp).  See the implementation there for what MINIMAL_ISAPI
//	does.
//
#ifndef MINIMAL_ISAPI
DWORD
CDAVExt::DwMain( LPEXTENSION_CONTROL_BLOCK pecbRaw,
				 BOOL fUseRawUrlMappings /* = FALSE */ )
{
#ifdef	DBG
	CHAR rgch[1024];
	DWORD cch;

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "REQUEST_METHOD", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called via method: %hs\n", rgch);

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "ALL_RAW", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called with RAW:\n%hs\n", rgch);

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "ALL_HTTP", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called with HTTP:\n%hs\n", rgch);
#endif	// DBG

	auto_ref_ptr<IEcb> pecb;
	DWORD dwHSEStatusRet = 0;
	BOOL fCaughtException = FALSE;
	HANDLE hitUser = INVALID_HANDLE_VALUE;

	try
	{
		//
		//	Don't let hardware exceptions (AVs, etc.)
		//	leave this try block
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		pecb.take_ownership(NewEcb(*pecbRaw, fUseRawUrlMappings, &dwHSEStatusRet));

		//
		//	If for whatever reason we failed to create a CEcb then bail
		//	and return whatever status we were told to return.
		//
		//	Note: return HSE_STATUS_SUCCESS here, not HSE_STATUS_ERROR.
		//	We have sent back a 500 Server Error response to the client
		//	so we don't need to send back any kind of error to IIS.
		//
		if ( !pecb.get() )
		{
			//	All valid HSE status codes are non-zero (how convenient!)
			//	so we can make sure that we are returning a valid HSE
			//	status code here.
			//
			Assert( dwHSEStatusRet != 0 );
			return dwHSEStatusRet;
		}

		const SMethod * pMethod;

		//
		//	Lookup the method object for this verb
		//
		for ( pMethod = g_rgMethods; pMethod->lpszVerb != NULL; pMethod++ )
			if ( !strcmp( pecb->LpszMethod(), pMethod->lpszVerb ) )
				break;

		//
		//	Build request and response objects.
		//
		auto_ref_ptr<IRequest> prequest( NewRequest( *pecb ) );
		auto_ref_ptr<IResponse> presponse( NewResponse( *pecb ) );

		//
		//	Bump all the per-request, per-instance perf counters
		//
		{
			const CInstData& cid = pecb->InstData();

			IncrementInstancePerfCounter( cid, IPC_TOTAL_REQUESTS );
			IncrementInstancePerfCounter( cid, IPC_REQUESTS_PER_SECOND );
			IncrementInstancePerfCounter( cid, pMethod->ipcTotal );
			IncrementInstancePerfCounter( cid, pMethod->ipcPerSec );
		}

		//
		//	If impersonation is required, do it here
		//
		hitUser = pecb->HitUser();
		if (INVALID_HANDLE_VALUE == hitUser)
		{
			//$	REVIEW: SECURITY: If HitUser() returns any
			//	value of INVALID_HANDLE_VALUE, then a call
			//	to augment the user's token to include USG
			//	group membership failed.  Since this token
			//	is not augmented with the additional group
			//	that may be included in any/all deny ACL's
			//	we want to fail this request immediately.
			//
			//	We treat the failure as a 500 level error.
			//
			pecb->SendAsyncErrorResponse (500,
										  gc_szDefErrStatusLine,
										  gc_cchszDefErrStatusLine,
										  gc_szUsgErrBody,
										  gc_cchszUsgErrBody);

			//
			//	Return HSE_STATUS_PENDING on success.  We will call
			//	HSE_REQ_DONE_WITH_SESSION when the CEcb is destroyed.
			//
			dwHSEStatusRet = HSE_STATUS_PENDING;
			//
			//$	REVIEW: SECURITY: end.
		}
		else
		{
			safe_impersonation si( hitUser );

			//
			//	Let the implementation handle the request.
			//
			{
				auto_ref_ptr<CMethUtil> pmu( CMethUtil::NewMethUtil( *pecb,
					*prequest,
					*presponse,
					pMethod->mid ) );

				DebugAddSIDHeader( *pmu );

				//
				//	Execute the method
				//
				pMethod->Execute( pmu.get() );
			}

			//
			//	Call the method completion function on the response.
			//	This does all work necessary to finish handling the
			//	response as far as the method is concerned, including
			//	sending the response if it was not deferred by the impl.
			//
			presponse->FinishMethod();

			//
			//	Return HSE_STATUS_PENDING on success.  We will call
			//	HSE_REQ_DONE_WITH_SESSION when the CEcb is destroyed.
			//
			dwHSEStatusRet = HSE_STATUS_PENDING;
		}
	}
	catch ( CDAVException& )
	{
		fCaughtException = TRUE;
	}

	//
	//	If we caught an exception then handle it as best we can
	//
	if ( fCaughtException )
	{
		//
		//	If we have a CEcb then use it to handle the server error.
		//	If we don't have one (i.e. we threw an exception trying
		//	to allocate/build one) then return an error to IIS
		//	and let it handle it.
		//
		dwHSEStatusRet =
			pecb.get() ? pecb->HSEHandleException() :
						 HSE_STATUS_ERROR;
	}

	//
	//	All valid HSE status codes are non-zero (how convenient!)
	//	so we can make sure that we are returning a valid HSE
	//	status code here.
	//
	Assert( dwHSEStatusRet != 0 );

	return dwHSEStatusRet;
}
#endif // !defined(MINIMAL_ISAPI)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\lockmeta.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	L O C K M E T A . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <tchar.h>	//_strspnp

#include <gencache.h>
#include <sz.h>
#include <xemit.h>
#include <xlock.h>
#include <statetok.h>
#include <nonimpl.h>

//	LockDiscovery -------------------------------------------------------------
//
SCODE
ScAddInLockToken (CEmitterNode& en, LPCWSTR pwszLockToken)
{
	//	Outer nodes must be declared first
	//
	CEmitterNode enLToken;
	CEmitterNode enToken;

	SCODE sc = S_OK;
	WCHAR rgwsz[MAX_LOCKTOKEN_LENGTH];
	LPCWSTR pwsz;

	//	Make sure they give us a locktoken string.
	//
	Assert(pwszLockToken);

	//	Widen the locktoken string.
	//	AND remove the quote marks (currently <>)
	//
	if (L'<' == pwszLockToken[0])
		pwszLockToken++;

	pwsz = wcschr(pwszLockToken, L'>');
	if (pwsz)
	{
		UINT cch = static_cast<UINT>(pwsz - pwszLockToken);
		if (MAX_LOCKTOKEN_LENGTH - 1 < cch)
		{
			sc = E_FAIL;
			goto ret;
		}
		Assert(MAX_LOCKTOKEN_LENGTH > cch);
		memcpy(rgwsz, pwszLockToken, cch * sizeof(WCHAR));
		rgwsz[cch] = L'\0';
		pwszLockToken = rgwsz;
	}

	//	Create and add a locktoken node under activelock.
	//	(locktoken node contains a single href node.)
	//
	sc = en.ScAddNode (gc_wszLockToken, enLToken);
	if (FAILED (sc))
		goto ret;

	sc = enLToken.ScAddNode (gc_wszXML__Href, enToken, pwszLockToken);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

//	========================================================================
//
//	ScBuildLockDiscovery
//
//		Takes an emitter and an already-constructed lockdiscovery node,
//		and adds an activelock node under it.
//		May be called multiple times -- each call will add a new activelock
//		node under the lockdiscovery node in en.
//
SCODE
ScBuildLockDiscovery (CXMLEmitter& emitter,
	CEmitterNode& en,
	LPCWSTR wszLockToken,
	LPCWSTR wszLockType,
	LPCWSTR wszLockScope,
	BOOL fRollback,
	BOOL fDepthInfinity,
	DWORD dwTimeout,
	LPCWSTR pwszOwnerComment,
	LPCWSTR pwszSubType)
{
	CEmitterNode enActive;
	SCODE sc = S_OK;
	WCHAR wsz[50];

	//	Zero is an invalid timeout.
	//
	Assert(dwTimeout);

	//	Add in the 'DAV:activelock' node
	//
	sc = en.ScAddNode (gc_wszLockActive, enActive);
	if (FAILED (sc))
		goto ret;

	//	Create a node for the locktype.
	//
	{
		CEmitterNode enLType;

		sc = enActive.ScAddNode (gc_wszLockType, enLType);
		if (FAILED (sc))
			goto ret;

		{
			CEmitterNode enType;
			sc = enLType.ScAddNode (wszLockType, enType);
			if (FAILED (sc))
				goto ret;

			if (pwszSubType)
			{
				CEmitterNode enSubLType;
				sc = enType.ScAddNode (pwszSubType, enSubLType);
				if (FAILED (sc))
					goto ret;
			}
		}
	}

	//	Create a node for the lockscope
	//
	{
		CEmitterNode enLScope;

		sc = enActive.ScAddNode (gc_wszLockScope, enLScope);
		if (FAILED (sc))
			goto ret;

		{
			CEmitterNode enScope;

			sc = enLScope.ScAddNode (wszLockScope, enScope);
			if (FAILED (sc))
				goto ret;
		}
	}

	//	Create a node for the owner. The comment is well contructed XML already
	//
	if (pwszOwnerComment)
	{
		sc = enActive.Pxn()->ScSetFormatedXML (pwszOwnerComment, static_cast<UINT>(wcslen(pwszOwnerComment)));
		if (FAILED (sc))
			goto ret;
	}

	//	If this is a rollback lock...
	//
	if (fRollback)
	{
		CEmitterNode enRollback;
		sc = enActive.ScAddNode (gc_wszLockRollback, enRollback);
		if (FAILED (sc))
			goto ret;
	}

	//	Add in the lock token
	//
	sc = ScAddInLockToken (enActive, wszLockToken);
	if (FAILED (sc))
		goto ret;

	//	Add an appropriate depth node.
	//
	{
		CEmitterNode enDepth;

		if (fDepthInfinity)
		{
			sc = enActive.ScAddNode (gc_wszLockDepth, enDepth, gc_wszInfinity);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			sc = enActive.ScAddNode (gc_wszLockDepth, enDepth, gc_wsz0);
			if (FAILED (sc))
				goto ret;
		}
	}

	//	Finally, create and add a timeout node
	//
	{
		CEmitterNode enTimeout;
		wsprintfW (wsz, L"Second-%d", dwTimeout);

		sc = enActive.ScAddNode (gc_wszLockTimeout, enTimeout, wsz);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

//	========================================================================
//
//	Lock utility functions
//
//$REVIEW: This should really be common impl code.  Move to _davcom later.
//

//	------------------------------------------------------------------------
//
//	FGetLockTimeout
//
//		Fetches and parses an incoming Time-Out header on the request.
//		Returns FALSE if an invalid option was encountered.
//		Returns TRUE with *pdwSeconds=gc_cSecondsDefaultLock
//		if NO Time-Out header was present.
//
BOOL
FGetLockTimeout (LPMETHUTIL pmu, DWORD * pdwSeconds, DWORD dwMaxOverride)
{
	LPCWSTR pwsz;
	DWORD  dwMax = gc_cSecondsMaxLock;

	Assert (pmu);
	Assert (pdwSeconds);

	*pdwSeconds = gc_cSecondsDefaultLock;

	//	If there is NO Time-Out header, leave our timeout set to the default,
	//	which was set at construction time.
	//	NOTE: It IS valid to have NO Time-Out header.  Just use the defaults.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szTimeout, FALSE);
	if (!pwsz)
	{
		LockTrace ("Dav: No Timeout header found.\n");
		goto ret;
	}

	//	Skip any initial whitespace.
	//
	pwsz = _wcsspnp(pwsz, gc_wszLWS);
	if (!pwsz)
	{
		LockTrace ("Dav: No params found in LOCK Time-Out header.\n");
		return FALSE;
	}

	Assert(pwsz);

	//	Check for a new-style timeout header.
	//

	//	Load a header iterator -- there could be multiple values here.
	//
	{
		HDRITER_W hdr(pwsz);

		pwsz = hdr.PszNext();
		if (!pwsz)
		{
			//	No data found.  That's an error.
			//
			return FALSE;
		}

		if (dwMaxOverride)
			dwMax = dwMaxOverride;

		while (pwsz)
		{
			//	Loop until we find an acceptable time.
			//	(Ignore any header values we don't understand.)
			//	If no acceptable time is found, it's okay.
			//	dwSeconds stays zero, and return TRUE.
			//

			if (!_wcsnicmp (gc_wszSecondDash, pwsz, gc_cchSecondDash))
			{
				DWORD dwSeconds;

				pwsz += gc_cchSecondDash;
				if (!*pwsz)
					return FALSE;

				dwSeconds = _wtol(pwsz);

				if (dwSeconds > dwMax)
				{
					//	Remember that they asked for something huge.
					//
					*pdwSeconds = dwMax;
				}
				else
				{
					//	We found a request that we'll grant.
					//	Set it and stop looping.
					//
					*pdwSeconds = dwSeconds;
					break;
				}
			}
			else if (!_wcsnicmp (gc_wszInfinite, pwsz, gc_cchInfinite))
			{
				//	We don't yet handle infinite timeouts.
				//	Remember that they asked for something huge.
				//	Skip to the next token.
				//
				*pdwSeconds = dwMax;

			}

			//	else skip to next token
			//	(ignore unrecognized tokens).
			//
			pwsz = hdr.PszNext();

		} // elihw
	}

ret:

	//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
    //  For the bug where rosebud waits until the last second
    //  before issueing the refresh. Need to filter out this check with
    //  the user agent string. The hack is to increase the timeout
	//	by 30 seconds and return the actual timeout.
    //
	if (pmu->FIsOffice9Request())
	{
		*pdwSeconds += gc_dwSecondsHackTimeoutForRosebud;
	}
	//$HACK:END:ROSEBUD_OFFICE9_TIMEOUT_HACK

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\langtocpid.cpp ===
//	========================================================================
//
//	Module:		   langtocpid.cpp
//
//	Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//	Description:	Implements language to cpid mapping cache
//					defined in inc\langtocpid.cpp
//
//	========================================================================

#include "_davprs.h"
#include <langtocpid.h>

//	========================================================================
//
//	Singleton class CLangToCpidCache
//
//	The CLangToCpidCache singleton class which provides a cache for fast
//	retrieval of code pages based on values in the Accept-Language header.
//
//	========================================================================

//	CLangToCpidCache::FCreateInstance() ------------------------------------
//
//	Initialization of the singleton class
//
BOOL
CLangToCpidCache::FCreateInstance()
{
	BOOL fSuccess = FALSE;
	UINT uiCpid;	// Index into the static table mapping language strings and cpids

	//	Init ourselves
	//
	CreateInstance();

	//	Init our cache
	//
	if (!Instance().m_cacheAcceptLangToCPID.FInit())
		goto ret;

	//	Fill our cache with all the language strings from
	//	the static table defined in the header.
	//
	for (uiCpid = 0; uiCpid < gc_cAcceptLangToCPIDTable; uiCpid++)
	{
		CRCSzi szKey (gc_rgAcceptLangToCPIDTable[uiCpid].pszLang);

		//	Check that we don't have duplicate NAMES in our table
		//	by doing a Lookup before we actually add each prop -- debug only!
		//
		Assert (!Instance().m_cacheAcceptLangToCPID.Lookup (szKey));

		//	Add the lang string.  Report a failure if we can't add.
		//
		if (!Instance().m_cacheAcceptLangToCPID.FAdd (szKey,
													  gc_rgAcceptLangToCPIDTable[uiCpid].cpid))
			goto ret;
	}

	//	Completed successfully.
	//
	fSuccess = TRUE;

ret:

	return fSuccess;
}

//	CLangToCpidCache::FFindCpid() ------------------------------------------
//
//	Find the CPID from language string
//
BOOL
CLangToCpidCache::FFindCpid(IN LPCSTR pszLang, OUT UINT * puiCpid)
{
	return Instance().m_cacheAcceptLangToCPID.FFetch(CRCSzi(pszLang),
													 puiCpid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\instdata.h ===
#ifndef _INSTDATA_H_
#define _INSTDATA_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	INSTDATA.H
//
//		Header for Dav Instance cache class.
//		(This cache hold per-instance data.  An instance is an
//		installation of DAV with a particular VServer-VRoot combination.)
//		Items declared here are defined(implemented) in inst.cpp.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//	Implementation note:
//	We need the classes CONTAINED in the inst to be completely defined here.
//	I decided to make these classes CONTAINED directly for speed purposes.
//	If we ever want to switch to holding an interface instead, replace
//	these definitions with the interface declaration, and have all the
//	actual classes use the interface.  The interface must provide for
//	creating and destroying the objects -- don't forget to change the
//	CInstData dtor to destroy all its objects!		--BeckyAn
//

// Caches
#include "gencache.h"
// Scrip map cache
#include "scrptmps.h"
// Singleton template
#include <singlton.h>
// Instance data object
#include <instobj.h>

//	========================================================================
//
//	CLASS CInstDataCache
//
//		The instance data cache.  Contains one "row" (CInstData) for each
//		"instance" (virtual server/virtual root combination).
//		Only one should ever be created in any DAV dll.
//
//		A virtual server (or site) is IIS's mechanism for hosting more than one
//		web site on a single machine -- www.msn.com and www.microsoft.com
//		running off of different directories on the same machine.
//		A virtual server is addressed by IIS as an instance number under
//		the w3svc service (w3svc/1/root, w3svc/2/root, etc)
//		A virtual root is IIS's mechanism for mapping virtual directories
//		under a particular vserver to different parts of the file system --
//		the URI /becky could map to d:\msn\web\users\b\becky.
//		DAV uses a virtual directory as the root of its document access --
//		all requests with URIs under our vroot are serviced by DAV.
//		DAV can also be installed under many different vroots at the same
//		time.  The instance data allows us to maintain seperate setting
//		and data for each vroot.
//
//		To get the data row for the current instance, use GetInstData(ECB).
//
class CInstDataCache : private Singleton<CInstDataCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CInstDataCache>;

	//	The instance data cache
	//
	CMTCache<CRCSz, auto_ref_ptr<CInstData> > m_cache;

	//	NOT IMPLEMENTED
	//
	CInstDataCache& operator=( const CInstDataCache& );
	CInstDataCache( const CInstDataCache& );

	//	CONSTRUCTORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CInstDataCache() {}

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CInstDataCache>::CreateInstance;
	using Singleton<CInstDataCache>::DestroyInstance;

	//
	//	Per-vroot instance data accessor
	//
	static CInstData& GetInstData( const IEcb& ecb );
};


#endif // _INSTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\perfctrs.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PERFCTRS.CPP
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>
#include "instdata.h"


//	--- !!! INSTRUCTIONS !!! ---
//
//	To add new counters:
//
//	1) Read the instructions in \cal\src\inc\perfctrs.h to make sure
//	   you know what else you need to update.
//
//	2) Cut and paste a block from the PERF_COUNTER_DEFINITIONs in
//	   gsc_ObjectType below and update the appropriate counter-specific
//	   things like counter type, detail level, etc.  Make sure the
//	   Be sure to update the IPC_ and CTI_ symbolic names to match
//	   those that you just added in perfctrs.h
//
//	--- !!! INSTRUCTIONS !!! ---

//	========================================================================
//
//	Common perf counters
//
//	These are layed out just as they would be for data collection
//	by perfmon.  See winperf.h in the NT includes for all of the
//	PERF_xxx structure definitions.  Also, for a good visual picture
//	of perf counter data layout, see Matt Pietrek's "Under The Hood"
//	MSDN article (April 1996, Number 4) on the subject.
//
#pragma pack(8)
static const struct SCounterBlock
{
	PERF_COUNTER_BLOCK pcb;
	LONG rglCounters[CPC_COMMON];
}
gsc_CounterBlock =
{
	//
	//	PERF_COUNTER_BLOCK
	//
	{
		sizeof(SCounterBlock)	// ByteLength (including counters)
	}
};

static const struct SInstanceDefinition
{
	PERF_INSTANCE_DEFINITION pid;
	WCHAR rgwchName[];
}
gsc_InstanceDef =
{
	//
	//	PERF_INSTANCE_DEFINITION
	//
	{
		sizeof(PERF_INSTANCE_DEFINITION), // ByteLength (computed)
		0,	// ParentObjectTitleIndex (no "parent" object)
		0,	// ParentObjectIndex (no "parent" object)
		-1,	// UniqueID (none; use name string to choose among instances)
		sizeof(PERF_INSTANCE_DEFINITION), // NameOffset (UNICODE name immediately follows definition)
		0,	// NameLength (computed)
	}
};

static const struct SObjectType
{
	PERF_OBJECT_TYPE pot;
	PERF_COUNTER_DEFINITION rgcd[CPC_COMMON];
}
gsc_ObjectType =
{
	//
	//	PERF_OBJECT_TYPE
	//
	{
		0,                        // TotalByteLength (computed by PCLIB)
		sizeof(PERF_OBJECT_TYPE) +
			CPC_COMMON * sizeof(PERF_COUNTER_DEFINITION), // DefinitionLength

		sizeof(PERF_OBJECT_TYPE), // HeaderLength
		CTI_OBJECT,               // ObjectNameTitleIndex (0-relative)
		NULL,					  // ObjectNameTitle (monitor-computed)
		1 + CTI_OBJECT,           // ObjectHelpTitleIndex (0-relative)
		NULL,                     // ObjectHelpTitle (monitor-computed)
		PERF_DETAIL_NOVICE,		  // DetailLevel
		CPC_COMMON,				  // NumCounters
		IPC_TOTAL_REQUESTS,       // DefaultCounter
		0,						  // NumInstances (initially 0)
		0						  // CodePage (0 --> instance strings in UNICODE)
		//
		//	PerfTime/PerfFreq implicitly initialized to LARGE_INTEGER(0)
		//
	},

	//
	//	PERF_COUNTER_DEFINITIONs
	//
	{
		//
		//	Per-vroot (per-instance) counters
		//	------------------------------------------------------
		//

		//
		//	SERVER_ID
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_SERVER_ID,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_SERVER_ID,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_DISPLAY_NOSHOW | PERF_SIZE_DWORD | PERF_TYPE_NUMBER, // CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_SERVER_ID]))
		},

		//
		//		Per second verb counters
		//
		//		"What is the current distribution of requests?"
		//
		//
		//	REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_REQUESTS_PER_SECOND]))
		},

		//
		//	OPTIONS_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_OPTIONS_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_OPTIONS_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_OPTIONS_REQUESTS_PER_SECOND]))
		},

		//
		//	GET_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_GET_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_GET_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_GET_REQUESTS_PER_SECOND]))
		},

		//
		//	HEAD_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_HEAD_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_HEAD_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_HEAD_REQUESTS_PER_SECOND]))
		},

		//
		//	PUT_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_PUT_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_PUT_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_PUT_REQUESTS_PER_SECOND]))
		},

		//
		//	POST_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_POST_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_POST_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_POST_REQUESTS_PER_SECOND]))
		},

		//
		//	DELETE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_DELETE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_DELETE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_DELETE_REQUESTS_PER_SECOND]))
		},

		//
		//	COPY_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_COPY_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_COPY_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_COPY_REQUESTS_PER_SECOND]))
		},

		//
		//	MOVE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_MOVE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_MOVE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_MOVE_REQUESTS_PER_SECOND]))
		},

		//
		//	MKCOL_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_MKCOL_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_MKCOL_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_MKCOL_REQUESTS_PER_SECOND]))
		},

		//
		//	PROPFIND_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_PROPFIND_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_PROPFIND_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_PROPFIND_REQUESTS_PER_SECOND]))
		},

		//
		//	PROPPATCH_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_PROPPATCH_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_PROPPATCH_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_PROPPATCH_REQUESTS_PER_SECOND]))
		},

		//
		//	LOCK_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_LOCK_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_LOCK_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_LOCK_REQUESTS_PER_SECOND]))
		},

		//
		//	UNLOCK_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_UNLOCK_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_UNLOCK_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_UNLOCK_REQUESTS_PER_SECOND]))
		},

		//
		//	SEARCH_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_SEARCH_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_SEARCH_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_SEARCH_REQUESTS_PER_SECOND]))
		},

		//
		//	OTHER_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_OTHER_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_OTHER_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_OTHER_REQUESTS_PER_SECOND]))
		},

		//
		//	200_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_200_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_200_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_200_RESPONSES_PER_SECOND]))
		},

		//
		//	201_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_201_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_201_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_201_RESPONSES_PER_SECOND]))
		},

		//
		//	400_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_400_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_400_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_400_RESPONSES_PER_SECOND]))
		},

		//
		//	401_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_401_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_401_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_401_RESPONSES_PER_SECOND]))
		},

		//
		//	404_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_404_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_404_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_404_RESPONSES_PER_SECOND]))
		},

		//
		//	423_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_423_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_423_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_423_RESPONSES_PER_SECOND]))
		},

		//
		//	500_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_500_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_500_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_500_RESPONSES_PER_SECOND]))
		},

		//
		//	REDIRECT_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_REDIRECT_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_REDIRECT_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_REDIRECT_RESPONSES_PER_SECOND]))
		},

		//
		//		Total verb counters
		//
		//		"What is the historical (cumulative) distribution of requests?"
		//
		//
		//	TOTAL_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_REQUESTS]))
		},

		//
		//	TOTAL_OPTIONS_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_OPTIONS_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_OPTIONS_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_OPTIONS_REQUESTS]))
		},

		//
		//	TOTAL_GET_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_GET_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_GET_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_GET_REQUESTS]))
		},

		//
		//	TOTAL_HEAD_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_HEAD_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_HEAD_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_HEAD_REQUESTS]))
		},

		//
		//	TOTAL_PUT_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PUT_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PUT_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PUT_REQUESTS]))
		},

		//
		//	TOTAL_POST_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_POST_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_POST_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_POST_REQUESTS]))
		},

		//
		//	TOTAL_DELETE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_DELETE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_DELETE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_DELETE_REQUESTS]))
		},

		//
		//	TOTAL_COPY_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_COPY_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_COPY_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_COPY_REQUESTS]))
		},

		//
		//	TOTAL_MOVE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MOVE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MOVE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MOVE_REQUESTS]))
		},

		//
		//	TOTAL_MKCOL_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MKCOL_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MKCOL_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MKCOL_REQUESTS]))
		},

		//
		//	TOTAL_PROPFIND_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPFIND_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPFIND_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPFIND_REQUESTS]))
		},

		//
		//	TOTAL_PROPPATCH_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPPATCH_REQUESTS]))
		},

		//
		//	TOTAL_LOCK_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_LOCK_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_LOCK_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_LOCK_REQUESTS]))
		},

		//
		//	TOTAL_UNLOCK_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_UNLOCK_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_UNLOCK_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_UNLOCK_REQUESTS]))
		},

		//
		//	TOTAL_SEARCH_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SEARCH_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SEARCH_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SEARCH_REQUESTS]))
		},

		//
		//	TOTAL_OTHER_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_OTHER_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_OTHER_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_OTHER_REQUESTS]))
		},

#ifdef TRANSACTION_SIZE_COUNTERS
		//
		//		Historical (cumulative) requests/responses by body
		//		size/content.
		//
		//		Useful in analyzing usage characteristics for methods
		//		whose performance can vary widely depending on certain
		//		per-request factors.
		//
		//
		//	TOTAL_GET_RESPONSES_0_5K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_GET_RESPONSES_0_5K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_GET_RESPONSES_0_5K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_GET_RESPONSES_0_5K_BYTES]))
		},

		//
		//	TOTAL_GET_RESPONSES_5_15K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_GET_RESPONSES_5_15K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_GET_RESPONSES_5_15K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_GET_RESPONSES_5_15K_BYTES]))
		},

		//
		//	TOTAL_GET_RESPONSES_GT_15K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_GET_RESPONSES_GT_15K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_GET_RESPONSES_GT_15K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_GET_RESPONSES_GT_15K_BYTES]))
		},

		//
		//	TOTAL_PUT_REQUESTS_0_5K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PUT_REQUESTS_0_5K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PUT_REQUESTS_0_5K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PUT_REQUESTS_0_5K_BYTES]))
		},

		//
		//	TOTAL_PUT_REQUESTS_5_15K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PUT_REQUESTS_5_15K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PUT_REQUESTS_5_15K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PUT_REQUESTS_5_15K_BYTES]))
		},

		//
		//	TOTAL_PUT_REQUESTS_GT_15K_BYTES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PUT_REQUESTS_GT_15K_BYTES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PUT_REQUESTS_GT_15K_BYTES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PUT_REQUESTS_GT_15K_BYTES]))
		},

		//
		//	TOTAL_COPY_REQUESTS_DEPTH_0
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_COPY_REQUESTS_DEPTH_0,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_COPY_REQUESTS_DEPTH_0,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_COPY_REQUESTS_DEPTH_0]))
		},

		//
		//	TOTAL_COPY_REQUESTS_DEPTH_INFINITY
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_COPY_REQUESTS_DEPTH_INFINITY,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_COPY_REQUESTS_DEPTH_INFINITY,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_COPY_REQUESTS_DEPTH_INFINITY]))
		},

		//
		//	TOTAL_MKCOL_REQUESTS_0_10_ITEMS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MKCOL_REQUESTS_0_10_ITEMS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MKCOL_REQUESTS_0_10_ITEMS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MKCOL_REQUESTS_0_10_ITEMS]))
		},

		//
		//	TOTAL_MKCOL_REQUESTS_10_100_ITEMS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MKCOL_REQUESTS_10_100_ITEMS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MKCOL_REQUESTS_10_100_ITEMS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MKCOL_REQUESTS_10_100_ITEMS]))
		},

		//
		//	TOTAL_MKCOL_REQUESTS_100_1K_ITEMS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MKCOL_REQUESTS_100_1K_ITEMS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MKCOL_REQUESTS_100_1K_ITEMS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MKCOL_REQUESTS_100_1K_ITEMS]))
		},

		//
		//	TOTAL_MKCOL_REQUESTS_GT_1K_ITEMS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_MKCOL_REQUESTS_GT_1K_ITEMS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_MKCOL_REQUESTS_GT_1K_ITEMS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_MKCOL_REQUESTS_GT_1K_ITEMS]))
		},

		//
		//	TOTAL_PROPFIND_RESPONSES_0_10_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_0_10_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_0_10_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPFIND_RESPONSES_0_10_PROPERTIES]))
		},

		//
		//	TOTAL_PROPFIND_RESPONSES_10_100_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_10_100_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_10_100_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPFIND_RESPONSES_10_100_PROPERTIES]))
		},

		//
		//	TOTAL_PROPFIND_RESPONSES_100_1K_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_100_1K_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_100_1K_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPFIND_RESPONSES_100_1K_PROPERTIES]))
		},

		//
		//	TOTAL_PROPFIND_RESPONSES_GT_1K_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_GT_1K_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPFIND_RESPONSES_GT_1K_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPFIND_RESPONSES_GT_1K_PROPERTIES]))
		},

		//
		//	TOTAL_PROPPATCH_REQUESTS_0_10_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_0_10_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_0_10_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPPATCH_REQUESTS_0_10_PROPERTIES]))
		},

		//
		//	TOTAL_PROPPATCH_REQUESTS_10_100_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_10_100_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_10_100_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPPATCH_REQUESTS_10_100_PROPERTIES]))
		},

		//
		//	TOTAL_PROPPATCH_REQUESTS_100_1K_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_100_1K_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_100_1K_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPPATCH_REQUESTS_100_1K_PROPERTIES]))
		},

		//
		//	TOTAL_PROPPATCH_REQUESTS_GT_1K_PROPERTIES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_GT_1K_PROPERTIES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_PROPPATCH_REQUESTS_GT_1K_PROPERTIES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_PROPPATCH_REQUESTS_GT_1K_PROPERTIES]))
		},

		//
		//	TOTAL_SEARCH_RESPONSES_0_10_ROWS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SEARCH_RESPONSES_0_10_ROWS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SEARCH_RESPONSES_0_10_ROWS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SEARCH_RESPONSES_0_10_ROWS]))
		},

		//
		//	TOTAL_SEARCH_RESPONSES_10_100_ROWS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SEARCH_RESPONSES_10_100_ROWS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SEARCH_RESPONSES_10_100_ROWS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SEARCH_RESPONSES_10_100_ROWS]))
		},

		//
		//	TOTAL_SEARCH_RESPONSES_100_1K_ROWS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SEARCH_RESPONSES_100_1K_ROWS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SEARCH_RESPONSES_100_1K_ROWS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SEARCH_RESPONSES_100_1K_ROWS]))
		},

		//
		//	TOTAL_SEARCH_RESPONSES_GT_1K_ROWS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SEARCH_RESPONSES_GT_1K_ROWS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SEARCH_RESPONSES_GT_1K_ROWS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SEARCH_RESPONSES_GT_1K_ROWS]))
		},

#endif // TRANSACTION_SIZE_COUNTERS

		//
		//		Historical (cumulative) response percentages by status code
		//
		//
		//	TOTAL_200_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_200_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_200_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_200_RESPONSES]))
		},

		//
		//	TOTAL_201_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_201_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_201_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_201_RESPONSES]))
		},

		//
		//	TOTAL_400_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_400_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_400_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_400_RESPONSES]))
		},

		//
		//	TOTAL_401_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_401_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_401_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_401_RESPONSES]))
		},

		//
		//	TOTAL_404_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_404_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_404_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_404_RESPONSES]))
		},

		//
		//	TOTAL_423_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_423_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_423_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_423_RESPONSES]))
		},

		//
		//	TOTAL_500_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_500_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_500_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_500_RESPONSES]))
		},

		//
		//	TOTAL_REDIRECT_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_REDIRECT_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_REDIRECT_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_REDIRECT_RESPONSES]))
		},

		//
		//		Concurrent data flow counters
		//
		//		"Where is the data flow path spending most of its time?"
		//
		//
		//	CURRENT_REQUESTS_EXECUTING
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_CURRENT_REQUESTS_EXECUTING,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_CURRENT_REQUESTS_EXECUTING,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_CURRENT_REQUESTS_EXECUTING]))
		},

		//
		//		Historical data flow counters for presumably uncommon
		//		(and possibly expensive) code paths.
		//
		//
		//	TOTAL_REQUESTS_FORWARDED
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_REQUESTS_FORWARDED,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_REQUESTS_FORWARDED,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_REQUESTS_FORWARDED]))
		},

		//
		//	TOTAL_EXCEPTIONS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_EXCEPTIONS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_EXCEPTIONS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_EXCEPTIONS]))
		},

		//
		//	POLL_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_POLL_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_POLL_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_POLL_REQUESTS_PER_SECOND]))
		},

		//
		//	SUBSCRIBE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_SUBSCRIBE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_SUBSCRIBE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_SUBSCRIBE_REQUESTS_PER_SECOND]))
		},

		//
		//	UNSUBSCRIBE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_UNSUBSCRIBE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_UNSUBSCRIBE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_UNSUBSCRIBE_REQUESTS_PER_SECOND]))
		},

		//
		//	BATCHDELETE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_BATCHDELETE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_BATCHDELETE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_BATCHDELETE_REQUESTS_PER_SECOND]))
		},

		//
		//	BATCHCOPY_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_BATCHCOPY_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_BATCHCOPY_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_BATCHCOPY_REQUESTS_PER_SECOND]))
		},

		//
		//	BATCHMOVE_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_BATCHMOVE_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_BATCHMOVE_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_BATCHMOVE_REQUESTS_PER_SECOND]))
		},

		//
		//	BATCHPROPPATCH_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_BATCHPROPPATCH_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_BATCHPROPPATCH_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_BATCHPROPPATCH_REQUESTS_PER_SECOND]))
		},

		//
		//	BATCHPROPFIND_REQUESTS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_BATCHPROPFIND_REQUESTS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_BATCHPROPFIND_REQUESTS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_BATCHPROPFIND_REQUESTS_PER_SECOND]))
		},

		//
		//	204_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_204_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_204_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_204_RESPONSES_PER_SECOND]))
		},

		//
		//	207_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_207_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_207_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_207_RESPONSES_PER_SECOND]))
		},

		//
		//	302_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_302_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_302_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_302_RESPONSES_PER_SECOND]))
		},

		//
		//	403_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_403_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_403_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_403_RESPONSES_PER_SECOND]))
		},

		//
		//	405_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_405_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_405_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_405_RESPONSES_PER_SECOND]))
		},

		//
		//	406_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_406_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_406_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_406_RESPONSES_PER_SECOND]))
		},

		//
		//	409_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_409_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_409_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_409_RESPONSES_PER_SECOND]))
		},

		//
		//	412_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_412_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_412_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_412_RESPONSES_PER_SECOND]))
		},

		//
		//	415_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_415_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_415_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_415_RESPONSES_PER_SECOND]))
		},

		//
		//	422_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_422_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_422_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_422_RESPONSES_PER_SECOND]))
		},

		//
		//	424_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_424_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_424_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_424_RESPONSES_PER_SECOND]))
		},

		//
		//	501_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_501_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_501_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_501_RESPONSES_PER_SECOND]))
		},

		//
		//	503_RESPONSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_503_RESPONSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_503_RESPONSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_503_RESPONSES_PER_SECOND]))
		},

		//
		//	TOTAL_POLL_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_POLL_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_POLL_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_POLL_REQUESTS]))
		},

		//
		//	TOTAL_SUBSCRIBE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_SUBSCRIBE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_SUBSCRIBE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_SUBSCRIBE_REQUESTS]))
		},

		//
		//	TOTAL_UNSUBSCRIBE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_UNSUBSCRIBE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_UNSUBSCRIBE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_UNSUBSCRIBE_REQUESTS]))
		},

		//
		//	TOTAL_BATCHDELETE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_BATCHDELETE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_BATCHDELETE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_BATCHDELETE_REQUESTS]))
		},

		//
		//	TOTAL_BATCHCOPY_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_BATCHCOPY_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_BATCHCOPY_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_BATCHCOPY_REQUESTS]))
		},

		//
		//	TOTAL_BATCHMOVE_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_BATCHMOVE_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_BATCHMOVE_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_BATCHMOVE_REQUESTS]))
		},

		//
		//	TOTAL_BATCHPROPPATCH_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_BATCHPROPPATCH_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_BATCHPROPPATCH_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_BATCHPROPPATCH_REQUESTS]))
		},

		//
		//	TOTAL_BATCHPROPFIND_REQUESTS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_BATCHPROPFIND_REQUESTS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_BATCHPROPFIND_REQUESTS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_BATCHPROPFIND_REQUESTS]))
		},

		//
		//	TOTAL_204_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_204_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_204_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_204_RESPONSES]))
		},

		//
		//	TOTAL_207_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_207_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_207_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_207_RESPONSES]))
		},

		//
		//	TOTAL_302_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_302_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_302_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_302_RESPONSES]))
		},

		//
		//	TOTAL_403_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_403_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_403_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_403_RESPONSES]))
		},

		//
		//	TOTAL_405_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_405_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_405_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_405_RESPONSES]))
		},

		//
		//	TOTAL_406_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_406_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_406_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_406_RESPONSES]))
		},

		//
		//	TOTAL_409_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_409_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_409_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_409_RESPONSES]))
		},

		//
		//	TOTAL_412_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_412_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_412_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_412_RESPONSES]))
		},

		//
		//	TOTAL_415_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_415_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_415_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_415_RESPONSES]))
		},

		//
		//	TOTAL_422_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_422_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_422_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_422_RESPONSES]))
		},

		//
		//	TOTAL_424_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_424_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_424_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_424_RESPONSES]))
		},

		//
		//	TOTAL_501_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_501_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_501_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_501_RESPONSES]))
		},

		//
		//	TOTAL_503_RESPONSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_503_RESPONSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_503_RESPONSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_503_RESPONSES]))
		},

		//
		//	REDIRECTS_FROM_BACKEND_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_REDIRECTS_FROM_BACKEND_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_REDIRECTS_FROM_BACKEND_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_REDIRECTS_FROM_BACKEND_PER_SECOND]))
		},

		//
		//	TOTAL_REDIRECTS_FROM_BACKEND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_REDIRECTS_FROM_BACKEND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_REDIRECTS_FROM_BACKEND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_REDIRECTS_FROM_BACKEND]))
		},

		//
		//	IFS_CACHE_HITS_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_IFS_CACHE_HITS_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_IFS_CACHE_HITS_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_IFS_CACHE_HITS_PER_SECOND]))
		},

		//
		//	TOTAL_IFS_CACHE_HITS
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_IFS_CACHE_HITS,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_IFS_CACHE_HITS,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_IFS_CACHE_HITS]))
		},

		//
		//	IFS_CACHE_MISSES_PER_SECOND
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_IFS_CACHE_MISSES_PER_SECOND,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_IFS_CACHE_MISSES_PER_SECOND,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_COUNTER,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_IFS_CACHE_MISSES_PER_SECOND]))
		},

		//
		//	TOTAL_IFS_CACHE_MISSES
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_TOTAL_IFS_CACHE_MISSES,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_TOTAL_IFS_CACHE_MISSES,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_TOTAL_IFS_CACHE_MISSES]))
		},

		//
		//	CURRENT_ITEM_COUNT_IN_IFS_CACHE
		//
		{
			sizeof(PERF_COUNTER_DEFINITION),	// ByteLength
												// CounterNameTitleIndex
			CTI_COUNTER_CURRENT_ITEM_COUNT_IN_IFS_CACHE,
			NULL,								// CounterNameTitle (monitor-computed)
												// CounterHelpTitleIndex
			1 + CTI_COUNTER_CURRENT_ITEM_COUNT_IN_IFS_CACHE,
			NULL,								// CounterHelpTitle (monitor-computed)
			0,									// DefaultScale (10^n)
			PERF_DETAIL_NOVICE,					// DetailLevel
			PERF_COUNTER_RAWCOUNT,				// CounterType
			sizeof(DWORD),						// CounterSize
												// CounterOffset
			static_cast<DWORD>(offsetof(SCounterBlock, rglCounters[IPC_CURRENT_ITEM_COUNT_IN_IFS_CACHE]))
		}
	}
};
#pragma pack()

//	========================================================================
//
//	CLASS CPerfCounters
//
class CPerfCounters : private Singleton<CPerfCounters>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CPerfCounters>;

	//
	//	PCLIB Initializer
	//
	CPclibInit m_pclib;

	//
	//	The perf object (we only have one)
	//
	auto_ptr<IPerfObject> m_pObject;

	//
	//	The "_Total" counter block instance
	//
	auto_ptr<IPerfCounterBlock> m_pCounterBlockTotal;

	//	NOT IMPLEMENTED
	//
	CPerfCounters& operator=(const CPerfCounters&);
	CPerfCounters(const CPerfCounters&);

	//	CREATORS
	//
	CPerfCounters() {}

public:
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CPerfCounters>::CreateInstance;
	using Singleton<CPerfCounters>::DestroyInstance;
	using Singleton<CPerfCounters>::Instance;

	//	MANIPULATORS
	//
	BOOL FInitialize( const VOID * lpvCounterDefs );

	IPerfCounterBlock * NewVRCounters( LPCSTR lpszVRoot );
	VOID IncrementTotalCounter( UINT iCounter );
	VOID DecrementTotalCounter( UINT iCounter );
};

//	------------------------------------------------------------------------
//
//	CPerfCounters::FInitialize()
//
BOOL
CPerfCounters::FInitialize( const VOID * lpvCounterDefs )
{
	//
	//	Initialize PCLIB
	//
	if ( !m_pclib.FInitialize( gc_wszSignature ) )
		return FALSE;

	//
	//	Build our perf object
	//
	m_pObject = PCLIB::NewPerfObject( gsc_ObjectType.pot );
	if ( !m_pObject.get() )
		return FALSE;

	UINT cbWszTotal = static_cast<UINT>((wcslen(gc_wsz_Total) + 1) * sizeof(WCHAR));

	//	Add a "_Total" instance.
	//
	Assert (1024 >= (sizeof(gsc_InstanceDef) + Align8(cbWszTotal)));
	CStackBuffer<SInstanceDefinition,1024> psid;

	psid->pid = gsc_InstanceDef.pid;
	CopyMemory( psid->rgwchName, gc_wsz_Total, cbWszTotal );
	psid->pid.ByteLength = sizeof(gsc_InstanceDef) + Align8(cbWszTotal);
	psid->pid.NameLength = cbWszTotal;
	m_pCounterBlockTotal = m_pObject->NewInstance( psid->pid, gsc_CounterBlock.pcb );
	if ( !m_pCounterBlockTotal.get() )
		return FALSE;

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CPerfCounters::NewVRCounters()
//
IPerfCounterBlock *
CPerfCounters::NewVRCounters( LPCSTR pszVRoot )
{
	Assert( m_pObject.get() );

	//	Convert the VRoot string to UNICODE so it can
	//	be used as an instance name.
	//
	UINT cbVRoot = static_cast<UINT>(strlen(pszVRoot) + 1);

	Assert (1024 >= (sizeof(gsc_InstanceDef) + Align8(sizeof(WCHAR) * cbVRoot)));
	CStackBuffer<SInstanceDefinition,1024> psid;

	psid->pid = gsc_InstanceDef.pid;

	//  We know that the buffer size is big enough.
	//
	UINT cchVRoot = MultiByteToWideChar(CP_ACP,
										MB_ERR_INVALID_CHARS,
										pszVRoot,
										cbVRoot,
										psid->rgwchName,
										cbVRoot);
	if (0 == cchVRoot)
	{
		Assert(FAILED(HRESULT_FROM_WIN32(GetLastError())));
		throw CLastErrorException();
	}

	//	The characters '/' are not allowed in perfcounter
	//	instance name any more. Munge them to '\'.
	//
	LPWSTR pwszName = psid->rgwchName;
	while (*pwszName)
	{
		if (L'/' == *pwszName)
			*pwszName = L'\\';
		pwszName++;
	}

	psid->pid.ByteLength = sizeof(gsc_InstanceDef) + Align8(sizeof(WCHAR) * cchVRoot);
	psid->pid.NameLength = sizeof(WCHAR) * cchVRoot;

	IPerfCounterBlock * ppcb = m_pObject->NewInstance( psid->pid, gsc_CounterBlock.pcb );
	if ( ppcb )
	{
		//
		//	Set the server ID perf counter.  This allows us to report
		//	perf counter data on a per-server rather than a per-vroot
		//	basis (as is done for W3SVC).
		//
		//	If the server ID could not be converted, LInstFromVroot()
		//	returns 0. The counter data will then be reported as part
		//	of the _Total instance.
		//
		ppcb->SetCounter( IPC_SERVER_ID, LInstFromVroot( pszVRoot ) );
	}

	return ppcb;
}

//	------------------------------------------------------------------------
//
//	CPerfCounters::IncrementTotalCounter()
//
VOID
CPerfCounters::IncrementTotalCounter( UINT iCounter )
{
	Assert( m_pCounterBlockTotal.get() );
	m_pCounterBlockTotal->IncrementCounter( iCounter );
}

//	------------------------------------------------------------------------
//
//	CPerfCounters::DecrementTotalCounter()
//
VOID
CPerfCounters::DecrementTotalCounter( UINT iCounter )
{
	Assert( m_pCounterBlockTotal.get() );
	m_pCounterBlockTotal->DecrementCounter( iCounter );
}

//	------------------------------------------------------------------------
//
//	InitPerfCounters()
//
BOOL FInitPerfCounters( const VOID * lpvCounterDefs )
{
	if ( CPerfCounters::CreateInstance().FInitialize( lpvCounterDefs ) )
		return TRUE;

	CPerfCounters::DestroyInstance();
	return FALSE;
}

//	------------------------------------------------------------------------
//
//	DeinitPerfCounters()
//
void
DeinitPerfCounters()
{
	CPerfCounters::DestroyInstance();
}

//	------------------------------------------------------------------------
//
//	NewVRCounters()
//
IPerfCounterBlock * NewVRCounters( LPCSTR lpszVRoot )
{
	return CPerfCounters::Instance().NewVRCounters( lpszVRoot );
}

//	------------------------------------------------------------------------
//
//	IncrementGlobalPerfCounter()
//
VOID IncrementGlobalPerfCounter( UINT iCounter )
{
	CPerfCounters::Instance().IncrementTotalCounter( iCounter );
}

//	------------------------------------------------------------------------
//
//	DecrementGlobalPerfCounter()
//
VOID DecrementGlobalPerfCounter( UINT iCounter )
{
	CPerfCounters::Instance().DecrementTotalCounter( iCounter );
}

//	------------------------------------------------------------------------
//
//	IncrementInstancePerfCounter()
//
VOID IncrementInstancePerfCounter( const CInstData& cid, UINT iCounter )
{
	cid.PerfCounterBlock().IncrementCounter( iCounter );
	CPerfCounters::Instance().IncrementTotalCounter( iCounter );
}

//	------------------------------------------------------------------------
//
//	DecrementInstancePerfCounter()
//
VOID DecrementInstancePerfCounter( const CInstData& cid, UINT iCounter )
{
	cid.PerfCounterBlock().DecrementCounter( iCounter );
	CPerfCounters::Instance().DecrementTotalCounter( iCounter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\request.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REQUEST.CPP
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include "ecb.h"
#include "body.h"
#include "header.h"


//	========================================================================
//
//	CLASS IRequest
//

//	------------------------------------------------------------------------
//
//	IRequest::~IRequest()
//
//		Out of line virtual destructor for request interface class
//		necessary for proper destruction of derived request classes
//		via a pointer to an IRequest
//
IRequest::~IRequest() {}



//	========================================================================
//
//	CLASS ISubPart
//
//	Interface class for the request body part (CEcbRequestBodyPart)
//	"sub parts".  CEcbRequestBodyPart has two "modes" of operation
//	through which execution flows:
//
//	1.	Accessing the first 48K of data which IIS caches in the ECB.
//	2.	Accessing remaining unread data from the ECB in the form of an
//		asynchronous read-once stream.
//
//	An ISubPart is a stripped-down IBodyPart (..\inc\body.h) -- it does
//	not provide any Rewind() semantics because there's nothing that
//	needs to (or can be) rewound.  It does, however, provide a function
//	to proceed from one mode to the next.
//
class CEcbRequestBodyPart;
class ISubPart
{
	//	NOT IMPLEMENTED
	//
	ISubPart& operator=( const ISubPart& );
	ISubPart( const ISubPart& );

protected:
	ISubPart() {}

public:
	//	CREATORS
	//
	virtual ~ISubPart() = 0;

	//	ACCESSORS
	//
	virtual ULONG CbSize() const = 0;
	virtual ISubPart * NextPart( CEcbRequestBodyPart& part ) const = 0;

	//	MANIPULATORS
	//
	virtual VOID Accept( IBodyPartVisitor& v,
						 UINT ibPos,
						 IAcceptObserver& obsAccept ) = 0;
};

//	------------------------------------------------------------------------
//
//	ISubPart::~ISubPart()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
ISubPart::~ISubPart()
{
}


//	========================================================================
//
//	CLASS CEcbCache
//
//
//
class CEcbCache : public ISubPart
{
	//
	//	Our IEcb.  Note that this is a C++ reference and not
	//	a auto_ref_ptr.  This is simply an optimization since
	//	lifetime of CEcbCache is entirely scoped by the lifetime
	//	of the request body which in turn is scoped by the
	//	lifetime of the request which holds an auto_ref_ptr
	//	to the IEcb.
	//
	IEcb& m_ecb;

	//	NOT IMPLEMENTED
	//
	CEcbCache& operator=( const CEcbCache& );
	CEcbCache( const CEcbCache& );

public:
	//	CREATORS
	//
	CEcbCache( IEcb& ecb ) : m_ecb(ecb) {}

	//	ACCESSORS
	//
	ULONG CbSize() const { return m_ecb.CbAvailable(); }
	ISubPart * NextPart( CEcbRequestBodyPart& ecbRequestBodyPart ) const;

	//	MANIPULATORS
	//
	VOID Accept( IBodyPartVisitor& v,
				 UINT ibPos,
				 IAcceptObserver& obsAccept );
};


//	========================================================================
//
//	CLASS CEcbStream
//
//	Accesses remaining unread data from the ECB in the form of an
//	asynchronous read-once stream.
//
class CEcbStream :
	public ISubPart,
	private IAsyncStream,
	private IAsyncWriteObserver,
	private IIISAsyncIOCompleteObserver
{
	//
	//	Size of the static buffer that we read into.  This buffer
	//	improves performance by reducing the number of times we
	//	have to call into IIS to read data from the ECB when we
	//	are being called to read only a few bytes at a time.
	//
	enum
	{
		CB_BUF = 32 * 1024	//$??? Is 32K reasonable?
	};

	//
	//	Ref back to our request object.  This need not be a counted
	//	ref because its lifetime scopes ours AS LONG AS we add a ref
	//	when starting any async operation which could extend our
	//	lifetime -- i.e. an async read from the ECB.
	//
	IRequest& m_request;

	//
	//	Ref to the IEcb.  This need not be a counted ref because its
	//	lifetime, like ours, is scoped by the lifetime of the request
	//	object.
	//
	IEcb& m_ecb;

	//
	//	Last error HRESULT.  Used in state processing to determine
	//	when to quit because of an error
	//
	HRESULT m_hr;

	//
	//	Size of the ECB stream and the amount of data that has
	//	been consumed (read into the buffer below).
	//
	DWORD m_dwcbStreamSize;
	DWORD m_dwcbStreamConsumed;

	//
	//	The three states of the buffer:
	//
	//	IDLE
	//	Data is present in the buffer or the buffer is empty
	//	because we've reached the end of the stream.  The
	//	buffer is not being filled.
	//
	//	FILLING
	//	The buffer is in the process of being filled from the stream.
	//	Data may or may not already be present.  Nobody is waiting
	//	on the data.
	//
	//	FAULTING
	//	The buffer is in the process of being filled from the stream.
	//	There is no data present.  A caller pended and needs to be
	//	notified when data becomes available.
	//
	//	WRITE_ERROR
	//	This state is only enterable if the stream is in a CopyTo()
	//	operation.  See CEcbStream::WriteComplete() and
	//	CEcbStream::FillComplete() for the conditions under which
	//	the buffer is in this state.
	//
	enum
	{
		STATUS_IDLE,
		STATUS_FILLING,
		STATUS_FAULTING,
		STATUS_WRITE_ERROR
	};

	mutable LONG m_lBufStatus;

	//
	//	AsyncRead()/AsyncCopyTo() observer to notify as soon as the
	//	stream is ready after FAULTING in data.
	//
	union
	{
		IAsyncReadObserver *   m_pobsAsyncRead;
		IAsyncCopyToObserver * m_pobsAsyncCopyTo;
	};

	//
	//	Wakeup functions and function pointer used to get processing
	//	started again after an AsyncRead() or AsyncCopyTo() request
	//	returns because data has to be faulted into the buffer.
	//	All these functions do is notify their associated observer
	//	(m_pobsAsyncRead or m_pobsAsyncCopyTo).
	//
	VOID WakeupAsyncRead();
	VOID WakeupAsyncCopyTo();

	typedef VOID (CEcbStream::*PFNWAKEUP)();
	PFNWAKEUP m_pfnWakeup;

	//
	//	Hint as to the amount of data that we can expect to
	//	be returned from a single async read from the
	//	read-once ECB stream.  Used to help fully utilize
	//	the available space in the buffer.  The hint is the
	//	historical maximum over all of the previous reads.
	//
	UINT m_cbBufFillHint;

	//
	//	Indices into the buffer that implement the 'ring' property.
	//
	//	The Fill index (m_ibBufFill) is where data is read into the
	//	buffer from the async stream.
	//
	//	The Drain index (m_ibBufDrain) is where data is read from or
	//	copied out of the buffer.
	//
	//	The Wrap index (m_ibBufWrap) is used by the drainer to tell
	//	it where the data in the buffer ends.  This is needed because
	//	we may not have filled all the way to the end of the buffer.
	//	m_ibBufWrap has no meaning until m_ibBufDrain > m_ibBufFill,
	//	so we explicitly leave it unitialized at construction time.
	//
	//	The ring property of the buffer holds if and only if the
	//	following condition is met:
	//
	//	m_ibBufDrain <= m_ibBufFill
	//	Data exists in the half-open interval [m_ibBufDrain,m_ibBufFill).
	//
	//	m_ibBufDrain > m_ibBufFill
	//	Data exists in the half-open interval [m_ibBufDrain,m_ibBufWrap)
	//	and the half-open interval [0,m_ibBufFill).
	//
	UINT m_ibBufFill;
	mutable UINT m_ibBufDrain;
	mutable UINT m_ibBufWrap;

	//
	//	Static buffer for requests of less than CB_BUF bytes.
	//	Note that this variable is located at the END of the class
	//	definition to make debugging in CDB easier -- all of the
	//	other member variables are visible up front.
	//
	BYTE m_rgbBuf[CB_BUF];

	//
	//	Debugging variables for easy (yeah, right) detection
	//	of async buffering problems and interactions with
	//	external streams.
	//
#ifdef DBG
	UINT dbgm_cbBufDrained;
	UINT dbgm_cbBufAvail;
	UINT dbgm_cbToCopy;
	LONG dbgm_cRefAsyncWrite;
#endif

	//
	//	IAsyncWriteObserver
	//
	void AddRef();
	void Release();
	VOID WriteComplete( UINT cbWritten,
						HRESULT hr );

	//
	//	IAsyncStream
	//
	UINT CbReady() const;

	VOID AsyncRead( BYTE * pbBuf,
					UINT   cbBuf,
					IAsyncReadObserver& obsAsyncRead );

	VOID AsyncCopyTo( IAsyncStream& stmDst,
					  UINT          cbToCopy,
					  IAsyncCopyToObserver& obsAsyncCopyTo );

	//
	//	IIISAsyncIOCompleteObserver
	//
	VOID IISIOComplete( DWORD dwcbRead,
						DWORD dwLastError );

	//
	//	Buffer functions
	//
	VOID AsyncFillBuf();
	VOID FillComplete();

	HRESULT HrBufReady( UINT * pcbBufReady,
						const BYTE ** ppbBufReady ) const;

	UINT CbBufReady() const;
	const BYTE * PbBufReady() const;

	VOID DrainComplete( UINT cbDrained );

	//	NOT IMPLEMENTED
	//
	CEcbStream& operator=( const CEcbStream& );
	CEcbStream( const CEcbStream& );

public:
	//	CREATORS
	//
	CEcbStream( IEcb& ecb,
				IRequest& request ) :
		m_ecb(ecb),
		m_request(request),
		m_hr(S_OK),
		m_dwcbStreamSize(ecb.CbTotalBytes() - ecb.CbAvailable()),
		m_dwcbStreamConsumed(0),
		m_lBufStatus(STATUS_IDLE),
		m_cbBufFillHint(0),
		m_ibBufFill(0),
#ifdef DBG
		dbgm_cbBufDrained(0),
		dbgm_cbBufAvail(0),
		dbgm_cRefAsyncWrite(0),
#endif
		m_ibBufDrain(0),
		m_ibBufWrap(static_cast<UINT>(-1))
	{
	}

	//	ACCESSORS
	//
	ULONG CbSize() const
	{
		//
		//	Return the size of the stream.  Normally this is just
		//	the value we initialized above.  But for chunked requests
		//	this value changes as soon as we know the real
		//	size of the request.
		//
		return m_dwcbStreamSize;
	}

	ISubPart * NextPart( CEcbRequestBodyPart& part ) const
	{
		//
		//	The stated size of the CEcbRequestBodyPart should keep
		//	us from ever getting here.
		//
		TrapSz( "CEcbStream is the last sub-part. There is NO next part!" );
		return NULL;
	}

	//	MANIPULATORS
	//
	VOID Accept( IBodyPartVisitor& v,
				 UINT ibPos,
				 IAcceptObserver& obsAccept );
};


//	========================================================================
//
//	CLASS CEcbRequestBodyPart
//
class CEcbRequestBodyPart : public IBodyPart
{
	//
	//	Position in the entire body part at the time of the most recent
	//	call to Accept().  This value is used to compute the number of
	//	bytes accepted by the previous call so that the sub-parts can
	//	be properly positioned for the next call.
	//
	ULONG m_ibPosLast;

	//
	//	The sub-parts
	//
	//$NYI	If we ever need caching of data from the ECB stream again,
	//$NYI	it should be implemented as a third sub-part comprised of
	//$NYI	or derived from a CTextBodyPart.
	//
	CEcbCache  m_partEcbCache;
	CEcbStream m_partEcbStream;

	//
	//	Pointer to the current sub-part
	//
	ISubPart * m_pPart;

	//
	//	Position in the current sub-part
	//
	ULONG m_ibPart;

	//	NOT IMPLEMENTED
	//
	CEcbRequestBodyPart& operator=( const CEcbRequestBodyPart& );
	CEcbRequestBodyPart( const CEcbRequestBodyPart& );

public:
	CEcbRequestBodyPart( IEcb& ecb,
						 IRequest& request ) :
		m_partEcbCache(ecb),
		m_partEcbStream(ecb, request)
	{
		Rewind();
	}

	//	ACCESSORS
	//
	UINT64 CbSize64() const
	{
		//
		//	The size of the whole really is the sum of its parts.
		//	But -- and this is a big but -- the reported size of
		//	the stream may change, so we must not cache its value.
		//	The reason is that chunked requests may not have a
		//	Content-Length so the final size is not known until
		//	we have read the entire stream.
		//
		return m_partEcbCache.CbSize() + m_partEcbStream.CbSize();
	}

	//	MANIPULATORS
	//
	ISubPart& EcbCachePart() { return m_partEcbCache; }
	ISubPart& EcbStreamPart() { return m_partEcbStream; }

	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};

//	------------------------------------------------------------------------
//
//	CEcbRequestBodyPart::Rewind()
//
VOID
CEcbRequestBodyPart::Rewind()
{
	m_ibPosLast = 0;
	m_pPart = &m_partEcbCache;
	m_ibPart = 0;
}

//	------------------------------------------------------------------------
//
//	CEcbRequestBodyPart::Accept()
//
VOID
CEcbRequestBodyPart::Accept( IBodyPartVisitor& v,
							 UINT64 ibPos64,
							 IAcceptObserver& obsAccept )
{
	UINT ibPos;

	//		NOTE: To be compatable with IBodyPart the position is passed
	//	in as 64 bit value (this is necessary to support file body parts
	//	that are bigger than 4GB). However we do not want anyone to create
	//	text body parts that are bigger than 4GB. So assert that it is not
	//	the case here and truncate the passed in 64 bit value to 32 bits.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibPos64));
	ibPos = static_cast<UINT>(ibPos64);

	//
	//	Check our assumption that the position has increased since the
	//	last call by not more than what was left of the current sub-part.
	//
	Assert( ibPos >= m_ibPosLast );
	Assert( ibPos - m_ibPosLast <= m_pPart->CbSize() - m_ibPart );

	//
	//	Adjust the position of the current sub-part by the
	//	previously accepted amount.
	//
	m_ibPart += ibPos - m_ibPosLast;

	//
	//	Remember the current position so that we can do the above
	//	computations again the next time through.
	//
	m_ibPosLast = ibPos;

	//
	//	If we're at the end of the current sub-part, go on to the next one.
	//
	while ( m_ibPart == m_pPart->CbSize() )
	{
		m_pPart = m_pPart->NextPart(*this);
		m_ibPart = 0;
	}

	//
	//	Forward the accept call to the current sub-part
	//
	m_pPart->Accept( v, m_ibPart, obsAccept );
}


//	========================================================================
//
//	CLASS CEcbCache
//
//	Accessing the first 48K of data which IIS caches in the ECB.
//

//	------------------------------------------------------------------------
//
//	CEcbCache::Accept()
//
VOID
CEcbCache::Accept( IBodyPartVisitor& v,
				   UINT ibPos,
				   IAcceptObserver& obsAccept )
{
	//
	//	Limit the request to just the amount of data cached in the ECB.
	//
	v.VisitBytes( m_ecb.LpbData() + ibPos,
				  m_ecb.CbAvailable() - ibPos,
				  obsAccept );
}

//	------------------------------------------------------------------------
//
//	CEcbCache::NextPart()
//
ISubPart *
CEcbCache::NextPart( CEcbRequestBodyPart& ecbRequestBodyPart ) const
{
	return &ecbRequestBodyPart.EcbStreamPart();
}


//	========================================================================
//
//	CLASS CEcbStream
//

//	------------------------------------------------------------------------
//
//	CEcbStream::AddRef()
//
void
CEcbStream::AddRef()
{
	m_request.AddRef();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::Accept()
//
void
CEcbStream::Release()
{
	m_request.Release();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::Accept()
//
VOID
CEcbStream::Accept( IBodyPartVisitor& v,
					UINT ibPos,
					IAcceptObserver& obsAccept )
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::Accept() ibPos = %u\n", GetCurrentThreadId(), this, ibPos );

	v.VisitStream( *this,
				   m_dwcbStreamSize - ibPos,
				   obsAccept );
}

//	------------------------------------------------------------------------
//
//	CEcbStream::CbReady()
//
//	Returns the number of bytes that are instantly available to be read.
//
UINT
CEcbStream::CbReady() const
{
	return CbBufReady();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncRead()
//
VOID
CEcbStream::AsyncRead( BYTE * pbBufCaller,
					   UINT   cbToRead,
					   IAsyncReadObserver& obsAsyncRead )
{
	//
	//	Don't assert that cbToRead > 0.  It is a valid request to read 0
	//	bytes from the stream.  The net effect of such a call is to just
	//	start/resume asynchronously filling the buffer.
	//
	//	Assert( cbToRead > 0 );
	//

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncRead() cbToRead = %u\n", GetCurrentThreadId(), this, cbToRead );

	//
	//	Stash away the observer and wakeup method so that if
	//	the call to HrBufReady() returns E_PENDING then then
	//	wakeup function will be called when the data becomes
	//	available.
	//
	m_pobsAsyncRead = &obsAsyncRead;
	m_pfnWakeup = WakeupAsyncRead;

	//
	//	Start/Continue asynchronously filling the buffer
	//
	AsyncFillBuf();

	//
	//	Check whether the buffer has data available to be read.  If so, then
	//	read it into the caller's buffer.  If not, then it will wake us up
	//	when data becomes available.
	//
	UINT cbBufReady;
	const BYTE * pbBufReady;

	HRESULT hr = HrBufReady( &cbBufReady, &pbBufReady );

	if ( FAILED(hr) )
	{
		//
		//	If HrBufReady() returns a "real" error, then report it.
		//
		if ( E_PENDING != hr )
			obsAsyncRead.ReadComplete(0, hr);

		//
		//	HrBufReady() returns E_PENDING if there is no data immediately
		//	available.  If it does then it will wake us up when data
		//	becomes available.
		//
		return;
	}

	//
	//	Limit what we read to the minimum of what's available in the
	//	buffer or what was asked for.  Keep in mind that cbBufReady or
	//	cbToRead may be 0.
	//
	cbToRead = min(cbToRead, cbBufReady);

	//
	//	Copy whatever is to be read from the I/O buffer into
	//	the caller's buffer.
	//
	if ( cbToRead )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncRead() %lu bytes to read\n", GetCurrentThreadId(), this, cbToRead );

		Assert( !IsBadWritePtr(pbBufCaller, cbToRead) );

		//
		//	Copy data from our buffer into the caller's
		//
		memcpy( pbBufCaller, pbBufReady, cbToRead );

		//
		//	Tell our buffer how much we've consumed so it can
		//	continue to fill and replace what we consumed.
		//
		DrainComplete( cbToRead );
	}

	//
	//	Tell our observer that we're done.
	//
	obsAsyncRead.ReadComplete(cbToRead, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WakeupAsyncRead()
//
//	Called by FillComplete() when the buffer returns to IDLE after
//	FAULTING because an observer pended trying to access an empty buffer
//	while the buffer was FILLING.
//
VOID
CEcbStream::WakeupAsyncRead()
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WakeupAsyncRead()\n", GetCurrentThreadId(), this );

	//
	//	Now that that the buffer is ready, tell the observer to try again.
	//
	m_pobsAsyncRead->ReadComplete(0, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncCopyTo
//
//	Called by FillComplete() when the buffer returns to IDLE after
//	FAULTING because an observer pended trying to access an empty buffer
//	while the buffer was FILLING.
//
VOID
CEcbStream::AsyncCopyTo( IAsyncStream& stmDst,
						 UINT          cbToCopy,
						 IAsyncCopyToObserver& obsAsyncCopyTo )
{
	Assert( cbToCopy > 0 );

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncCopyTo() cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Stash away the observer and wakeup method so that if
	//	the call to HrBufReady() returns E_PENDING then the
	//	wakeup function will be called when the data becomes
	//	available.
	//
	m_pobsAsyncCopyTo = &obsAsyncCopyTo;
	m_pfnWakeup = WakeupAsyncCopyTo;

	//
	//	Start/Continue asynchronously filling the buffer
	//
	AsyncFillBuf();

	//
	//	Check whether the buffer has data available to be read.  If so, then
	//	copy it to the caller's stream.  If not, then it will wake us up
	//	when data becomes available.
	//
	UINT cbBufReady;
	const BYTE * pbBufReady;

	HRESULT hr = HrBufReady( &cbBufReady, &pbBufReady );

	if ( FAILED(hr) )
	{
		//
		//	If HrBufReady() returns a "real" error, then report it.
		//
		if ( E_PENDING != hr )
			obsAsyncCopyTo.CopyToComplete(0, hr);

		//
		//	HrBufReady() returns E_PENDING if there is no data immediately
		//	available.  If it does then it will wake us up when data
		//	becomes available.
		//
		return;
	}

	//
	//	Limit what we copy to the minimum of what's available in the
	//	buffer or what was asked for.  Keep in mind cbBufReady may
	//	be 0.
	//
	cbToCopy = min(cbToCopy, cbBufReady);

	//
	//	Write whatever there is to write, if anything.  If there is
	//	nothing to write then notify the observer immediately that
	//	we're done -- i.e. do not ask the destination stream to
	//	write 0 bytes.
	//
	if ( cbToCopy )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncCopyTo() %lu bytes to copy\n", GetCurrentThreadId(), this, cbToCopy );

#ifdef DBG
		//
		//	In DBG builds, remember how much we're writing so that
		//	we can quickly catch streams that do something stupid
		//	like tell our WriteComplete() that it wrote more than
		//	we asked it to.
		//
		dbgm_cbToCopy = cbToCopy;
#endif

		//
		//	We should only ever be doing one AsyncWrite() at a time.
		//
		Assert( InterlockedIncrement(&dbgm_cRefAsyncWrite) == 1 );

		stmDst.AsyncWrite( pbBufReady, cbToCopy, *this );
	}
	else
	{
		obsAsyncCopyTo.CopyToComplete(0, S_OK);
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WakeupAsyncCopyTo()
//
VOID
CEcbStream::WakeupAsyncCopyTo()
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WakeupAsyncCopyTo()\n", GetCurrentThreadId(), this );

	//
	//	Now that that the buffer is ready, tell the observer to try again.
	//
	m_pobsAsyncCopyTo->CopyToComplete(0, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WriteComplete
//
VOID
CEcbStream::WriteComplete(
	UINT cbWritten,
	HRESULT hr )
{
	//
	//	Make sure the stream isn't telling us it wrote more than we asked for!
	//
	Assert( dbgm_cbToCopy >= cbWritten );

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() %u "
					"bytes written (0x%08lX)\n", GetCurrentThreadId(),
					this, cbWritten, hr );

	//
	//	If no error has occurred, we want to call DrainComplete as soon as
	//	possible, as it will begin another AsyncFillBuf to fill in the part of
	//	the buffer that was drained.
	//
	//	However, in the case of error, we do not want to call DrainComplete
	//	before the error gets set into m_hr and the state of the stream gets
	//	set to STATUS_WRITE_ERROR.  We don't want to call AsyncFillBuf without
	//	the error latched in, or it will start another async. operation, which
	//	is not good since we've already errored!
	//
    if (SUCCEEDED(hr))
        DrainComplete( cbWritten );

	//
	//	We should only ever do one AsyncWrite() at a time.  Assert that.
	//
	Assert( InterlockedDecrement(&dbgm_cRefAsyncWrite) == 0 );

	//
	//	If the async write completed successfully just notify the CopyTo observer.
	//
	if ( SUCCEEDED(hr) )
	{
		m_pobsAsyncCopyTo->CopyToComplete( cbWritten, hr );
	}

	//
	//	Otherwise things get a little tricky....
	//
	else
	{
		//
		//	Normally we would just notify the CopyTo observer of the error.
		//	But if we are FILLING that could be a bad idea.  When we notify
		//	the observer it will most likely send back an error to the client
		//	via async I/O.  If we are still FILLING at that point then we would
		//	have multiple async I/Os outstanding which is a Bad Thing(tm) --
		//	ECB leaks making the web service impossible to shut down, etc.
		//
		//	So instead of notifying the observer unconditionally we latch
		//	in the error and transition to a WRITE_ERROR state.  If the
		//	previous state was FILLING then don't notify the observer.
		//	CEcbStream::FillComplete() will notify the observer when
		//	FILLING completes (i.e. when it is safe to do another async I/O).
		//	If the previous state was IDLE (and it must have been either IDLE
		//	or FILLING) then it is safe to notify the observer because
		//	the transition to WRITE_ERROR prevents any new filling operations
		//	from starting.
		//

		//
		//	Latch in the error now.  FillComplete() can potentially send
		//	the error response immediately after we change state below.
		//
		m_hr = hr;

		//
		//	Change state.  If the previous state was IDLE then it is safe
		//	to notify the observer from this thread.  No other thread can
		//	start FILLING once the state changes.
		//
		LONG lBufStatusPrev = InterlockedExchange( &m_lBufStatus, STATUS_WRITE_ERROR );

		//
		//	Now that we've latched in the errors, we can safely call
		//	DrainComplete.  AsyncFillBuf checks that the state of the
		//	stream is NOT STATUS_WRITE_ERROR before beginning an
		//	asynchronous read.
		//
        DrainComplete( cbWritten );

		if ( STATUS_IDLE == lBufStatusPrev )
		{
			EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() - Error writing.  Notifying CopyTo observer.\n", GetCurrentThreadId(), this );

			m_pobsAsyncCopyTo->CopyToComplete( cbWritten, hr );
		}
		else
		{
			//
			//	The previous state was not IDLE, so it must have
			//	been FILLING.  In no other state could we have been
			//	writing.
			//
			Assert( STATUS_FILLING == lBufStatusPrev );

			EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() - Error writing while filling.  FillComplete() will notify CopyTo observer\n", GetCurrentThreadId(), this );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::DrainComplete()
//
//	Called by AsyncRead() and WriteComplete() when draining (consuming)
//	data from the buffer.  This function updates the drain position of
//	the buffer and allows the buffer to continue filling the space
//	just drained.
//
VOID
CEcbStream::DrainComplete( UINT cbDrained )
{
#ifdef DBG
	dbgm_cbBufDrained += cbDrained;

	UINT cbBufAvail = InterlockedExchangeAdd( reinterpret_cast<LONG *>(&dbgm_cbBufAvail),
											  -static_cast<LONG>(cbDrained) );
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: !!!CEcbStream::DrainComplete() %lu left to write (%u in buffer)\n", GetCurrentThreadId(), this, m_dwcbStreamSize - dbgm_cbBufDrained, cbBufAvail );

	Assert( dbgm_cbBufDrained <= m_dwcbStreamConsumed );
#endif

	//
	//	Update the drain position of the buffer.  Don't wrap here.
	//	We wrap only in CbBufReady().
	//
	m_ibBufDrain += cbDrained;

	//
	//	Resume/Continue filling the buffer
	//
	AsyncFillBuf();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::CbBufReady()
//
UINT
CEcbStream::CbBufReady() const
{
	//
	//	Poll the filling position now so that it doesn't change
	//	between the time we do the comparison below and the time
	//	we use its value.
	//
	UINT ibBufFill = m_ibBufFill;

	//
	//	If the fill position is still ahead of the drain position
	//	then the amount of data available is simply the difference
	//	between the two.
	//
	if ( ibBufFill >= m_ibBufDrain )
	{
		return ibBufFill - m_ibBufDrain;
	}

	//
	//	If the fill position is behind the drain then the fillling
	//	side must have wrapped.  If the drain position has not yet
	//	reached the wrap position then the amount of data available
	//	is the difference between the two.
	//
	else if ( m_ibBufDrain < m_ibBufWrap )
	{
		Assert( ibBufFill < m_ibBufDrain );
		Assert( m_ibBufWrap != static_cast<UINT>(-1) );

		return m_ibBufWrap - m_ibBufDrain;
	}

	//
	//	Otherwise the fill position has wrapped and the drain
	//	position has reached the wrap position so wrap the
	//	drain position back to the beginning.  At that point
	//	the amount of data available will be the difference
	//	between the fill and the drain positions.
	//
	else
	{
		Assert( ibBufFill < m_ibBufDrain );
		Assert( m_ibBufDrain == m_ibBufWrap );
		Assert( m_ibBufWrap != static_cast<UINT>(-1) );

		m_ibBufWrap = static_cast<UINT>(-1);
		m_ibBufDrain = 0;

		return m_ibBufFill;
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::PbBufReady()
//
const BYTE *
CEcbStream::PbBufReady() const
{
	return m_rgbBuf + m_ibBufDrain;
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncFillBuf()
//
//	Starts asynchronously filling the buffer.  The buffer may not (and
//	usually won't) fill up with just one call.  Called by:
//
//	AsyncRead()/AsyncCopyTo()
//		to start filling the buffer for the read/copy request.
//
//	DrainComplete()
//		to resume filling the buffer after draining some amount
//		from a previously full buffer.
//
//	IISIOComplete()
//		to continue filling the buffer after the initial call.
//
VOID
CEcbStream::AsyncFillBuf()
{
	//
	//	Don't do anything if the buffer is already FILLING (or FAULTING).
	//	We can have only one outstanding async I/O at once.  If the buffer
	//	is IDLE, then start filling.
	//
	if ( STATUS_IDLE != InterlockedCompareExchange(
							&m_lBufStatus,
							STATUS_FILLING,
							STATUS_IDLE ) )
		return;

	//
	//	Important!!!  The following checks CANNOT be moved outside
	//	the 'if' clause above without introducing the possibility
	//	of having multiple outstanding async I/O operations.
	//	So don't even consider that "optimization".
	//

	//
	//	First, check whether we are in an error state.  If we are
	//	then don't try to read any more data.  The stream is ready
	//	with whatever data (if any) is already there when it goes
	//	idle.
	//
	if ( FAILED(m_hr) )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_hr = 0x%08lX\n", GetCurrentThreadId(), this, m_hr );
		FillComplete();
		return;
	}

	//
	//	If we've read everything there is to read, then the buffer
	//	is ready (though it may be empty) once we return to idle.
	//	The only time we would not be idle in this case is if the
	//	thread completing the final read is in IISIOComplete() and
	//	has updated m_dwcbStreamConsumed, but has not yet returned
	//	the status to idle.
	//
	if ( m_dwcbStreamConsumed == m_dwcbStreamSize )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() End Of Stream\n", GetCurrentThreadId(), this );
		FillComplete();
		return;
	}

	//
	//	Poll the current drain position and use the polled value
	//	for all of the calculations below to keep them self-consistent.
	//	We would have serious problems if the drain position were to
	//	change (specifically, if it were to wrap) while we were in
	//	the middle of things.
	//
	UINT ibBufDrain = m_ibBufDrain;

	Assert( m_ibBufFill < CB_BUF );
	Assert( ibBufDrain <= CB_BUF );

	//
	//	If there's no space to fill, then we can't do anything more.
	//	The buffer is already full of data.  Note that the situation
	//	can change the instant after we do the comparison below.
	//	In particular, if another thread is draining the buffer at
	//	the same time, it is possible that there may be no data
	//	available by the time we return TRUE.  Callers which
	//	allow data to be drained asynchronously must be prepared
	//	to deal with this.
	//
	if ( (m_ibBufFill + 1) % CB_BUF == ibBufDrain % CB_BUF )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() buffer full\n", GetCurrentThreadId(), this );
		FillComplete();
		return;
	}

	//	Ideally, we could read up to as much data as is left in the stream.
	//
	UINT cbFill = m_dwcbStreamSize - m_dwcbStreamConsumed;

	//
	//	But that amount is limited by the amount of buffer available
	//	for filling.  If the current fill position in the buffer is
	//	ahead of (greater than) the drain position, that amount is
	//	the greater of the distance from the current fill position
	//	to the end of the buffer or the distance from the beginning
	//	of the buffer to the current drain position.  If the fill
	//	position is behind (less than) the drain position, the amount
	//	is simply the distance from the fill position to the drain
	//	position.
	//
	if ( m_ibBufFill == ibBufDrain )
	{
		//	Case 1.
		
		//
		//	The buffer is empty so wrap both the fill and drain
		//	positions back to the beginning of the buffer to get
		//	maximum usage of the buffer.  Note that it is safe for
		//	us (the filling code) to move m_ibBufDrain here because
		//	there can be nobody draining the buffer at this point -- it's empty!
		//
		//	Note that above comment is NOT correct (but leave it here to that it's
		//	easy to understand why the following code is necessary). We can't assume
		//	nobody is draing the buffer at the same time, because the draining
		//	side may be in the middle of checking buffer status, say it's calling
		//	CbBufReady() to check the number of bytes availble, if this happens
		//	right after we set m_ibBufFill to 0 and before set m_ibBufDrain to 0,
		//	then CbBufReady() will report the buffer as not empty and we end up
		//	reading garbage data or crash.
		//
		if (STATUS_FAULTING == m_lBufStatus)
		{
			//	Case 1.1
			
			//	This is what the original code looks like. this code is safe only
			//	when the status if in FAULING state, which means the draining side
			//	is in waiting state already.
			
			//  We have:
			//
			//  [_________________________________________________]
			//                                          ^
			//                                          m_ibBufFill == ibBufDrain
			//                                          (i.e. empty buffer)
			//
			//	After filling, we will have:
			//
			//  [DATADATADATADATADATADATADATADATADATADATADAT______]
			//   ^                                          ^
			//   ibBufDrain                                 m_ibBufFill
			//
			m_ibBufFill = 0;
			m_ibBufDrain = 0;
			cbFill = min(cbFill, CB_BUF - 1);
		}
		//	If the status is not FAULTING (which means the draining side is not in
		//	waiting state yet), one alternative is to wait for the status
		//	to turn to FAULTING, but that will drag the performance, because the whole
		//	design of this async draining/filling mechanism is to avoid any expensive
		//	synchronization.	
		else
		{
			//	Though we can't move both pointers, we still want to fill as much
			//	as we can. so depends on whether the fill pointer in the lower half
			//	or higher half of the buffer, different approach is used.
			//
			if (m_ibBufFill < (CB_BUF - 1) / 2)
			{
				//	Case 1.2 - similar logic to case 3
				
				//  We have:
				//
				//  [_________________________________________________]
				//              ^
				//              m_ibBufFill == ibBufDrain
				//              (i.e. empty buffer)
				//
				//	After filling, we will have:
				//
				//  [___________DATADATADATADATADATADATADATADAT______]
				//				^                              ^
				//				ibBufDrain                     m_ibBufFill
				//
				cbFill = min(cbFill, CB_BUF - m_ibBufFill - !ibBufDrain);
			}
			else
			{
				//	Case 1.3 - similiar logic to case 4.
				
				//  We have:
				//
				//  [_________________________________________________]
				//									     ^
				//										 m_ibBufFill == ibBufDrain
				//										 (i.e. empty buffer)
				//
				//	After filling, we will have:
				//
				//  [DATADATADATADATADAT______________________________]
				//				        ^                ^
				//					    m_ibBufFill		 m_ibBufWrap == ibBufDrain

				//	Yes, we touch both m_ibBufWrap and m_ibBufFill. However, as
				//  in case 4, we are safe here, because, CbBufReady() get ibBufFill
				//	first, and then access m_ibBufWrap etc.
				//	Here we are setting	these two members in reverse order, so that,
				//	if CbBufReady()	doesn't see the new m_ibBufFill, then it simply
				//	returns 0 as usual, If it does see the new m_ibBufFill, the m_ibBufWrap
				//	is already set and thus CbBufReady will reset both m_ibBufWrap and
				//	m_ibBufDRain.
				//

				//	If this thread is here when CbBufReady is called, CbBufReady will
				//	return 0, which means buffer empty and will put draining side to wait
				
				//	Set the wrap position so that a draining thread will
				//	know when to wrap the drain position.
				//
				m_ibBufWrap = m_ibBufFill;

				//	If this thread is here when CbBufReady is called, Again, CbBufRead will
				//	return 0, which means buffer empty and will put draining side to wait
				
				//	Set the fill position back at the beginning of the buffer
				//
				m_ibBufFill = 0;

				//	If this thread is here when CbBufReady is called, CbBufReady will
				//	reset m_ibBufWrap to -1, and m_ibBufDrain to 0, which is exactly
				//	what we want.
				
				cbFill = min(cbFill, ibBufDrain - 1);
			}
		}

		Assert( cbFill > 0 );
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill == ibBufDrain (empty buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else if ( m_ibBufFill < ibBufDrain )
	{
		//	Case 2
		
		//
		//  We have:
		//
		//  [DATADATA_______________DATADATADATADA***UNUSED***]
		//           ^              ^             ^
		//           m_ibBufFill    ibBufDrain    m_ibBufWrap
		//
		//	After filling, we will have:
		//
		//  [DATADATADATADATADATADA_DATADATADATADA***UNUSED***]
		//                         ^^             ^
		//                         |ibBufDrain    m_ibBufWrap
		//                         m_ibBufFill
		//
		cbFill = min(cbFill, ibBufDrain - m_ibBufFill - 1);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill < ibBufDrain.  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else if ( ibBufDrain <= CB_BUF - m_ibBufFill ||
			  m_cbBufFillHint <= CB_BUF - m_ibBufFill )

	{
		//	Case 3
				
		Assert( m_ibBufFill > ibBufDrain );

		//
		//	If ibBufDrain is 0 then we can't fill all the way to
		//	the end of the buffer (since the end of the buffer is
		//	synonymous with the beginning).  To account for this
		//	we need to subtract 1 from cbFill if ibBufDrain is 0.
		//	We can do that without the ?: operator as long as the
		//	following holds true:
		//
		Assert( 0 == !ibBufDrain || 1 == !ibBufDrain );

		//
		//  We have:                                v------v m_cbBufFillHint
		//
		//  [________________DATADATADATADATADATADAT__________]
		//                   ^                      ^
		//                   ibBufDrain             m_ibBufFill
		//	-OR-
		//
		//  We have:                                v------------v m_cbBufFillHint
		//
		//  [DATADATADATADATADATADATADATADATADATADAT__________]
		//   ^                                      ^
		//   ibBufDrain                             m_ibBufFill
		//
		//
		//	After filling, we will have:
		//
		//  [________________DATADATADATADATADATADATADATADATAD]
		//   ^               ^                                ^
		//   m_ibBufFill     ibBufDrain                       m_ibBufWrap
		//
		//	-OR-
		//
		//  [DATADATADATADATADATADATADATADATADATADATADATADATA_]
		//   ^                                               ^
		//   ibBufDrain                                      m_ibBufFill
		//
		cbFill = min(cbFill, CB_BUF - m_ibBufFill - !ibBufDrain);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill > ibBufDrain (enough room at end of buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else
	{
		//	Case 4
		
		Assert( m_ibBufFill > ibBufDrain );
		Assert( m_cbBufFillHint > CB_BUF - m_ibBufFill );
		Assert( ibBufDrain > CB_BUF - m_ibBufFill );

		//
		//  We have:                                v------------v m_cbBufFillHint
		//
		//  [________________DATADATADATADATADATADAT__________]
		//                   ^                      ^
		//                   ibBufDrain             m_ibBufFill
		//
		//
		//	After filling, we will have:
		//
		//  [DATADATADATADAT_DATADATADATADATADATADAT***UNUSED*]
		//                  ^^                      ^
		//                  |ibBufDrain             m_ibBufWrap
		//                  m_ibBufFill
		//

		//
		//	Set the wrap position so that a draining thread will
		//	know when to wrap the drain position.
		//
		m_ibBufWrap = m_ibBufFill;

		//
		//	Set the fill position back at the beginning of the buffer
		//
		m_ibBufFill = 0;

		//
		//	And fill up to the drain position - 1
		//
		Assert( ibBufDrain > 0 );
		cbFill = min(cbFill, ibBufDrain - 1);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill > ibBufDrain (not enough room at end of buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}

	//
	//	Start async I/O to read from the ECB.
	//
	{
		SCODE sc = S_OK;

		//
		//	Add a reference to our parent request to keep us alive
		//	for the duration of the async call.
		//
		//	Use auto_ref_ptr so that we release the ref if the
		//	async call throws an exception.
		//
		auto_ref_ptr<IRequest> pRef(&m_request);

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() reading %u bytes\n", GetCurrentThreadId(), this, cbFill );

		//	Assert that we are actually going to fill something and that
		//	we aren't going to fill past the end of our buffer.
		//
		Assert( m_ibBufFill + cbFill <= CB_BUF );

		sc = m_ecb.ScAsyncRead( m_rgbBuf + m_ibBufFill,
								&cbFill,
								*this );
		if (SUCCEEDED(sc))
		{
			pRef.relinquish();
		}
		else
		{
			DebugTrace( "CEcbStream::AsyncFillBuf() - IEcb::ScAsyncRead() failed with error 0x%08lX\n", sc );

			m_hr = sc;
			FillComplete();
		}
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::FillComplete()
//
VOID
CEcbStream::FillComplete()
{
	//
	//	Poll the wakeup function pointer now before the ICE() below
	//	so that we don't lose the value if another thread immediately
	//	starts filling immediately after we transition to IDLE.
	//
	PFNWAKEUP pfnWakeup = m_pfnWakeup;

	//
	//	At this point we had better be FILLING or FAULTING because
	//	we are completing async I/O started from AsyncFillBuf().
	//
	//	We could actually be in WRITE_ERROR as well.  See below
	//	and CEcbStream::WriteComplete() for why.
	//
	Assert( STATUS_FILLING == m_lBufStatus ||
			STATUS_FAULTING == m_lBufStatus ||
			STATUS_WRITE_ERROR == m_lBufStatus );

	//
	//	Attempt to transition to IDLE from FILLING.  If successful then
	//	we're done.  Otherwise we are either FAULTING or in the WRITE_ERROR
	//	state.  Handle those below.
	//
	LONG lBufStatus = InterlockedCompareExchange(
							&m_lBufStatus,
							STATUS_IDLE,
							STATUS_FILLING );

	if ( STATUS_FAULTING == lBufStatus )
	{
		//
		//	We are FAULTING.  This means the writing side of things
		//	needs to be notified now that data is available.  So
		//	change state to IDLE (remember: ICE() didn't change state
		//	above -- it just told us what the state is) and call
		//	the registered wakeup function.
		//
		m_lBufStatus = STATUS_IDLE;
		Assert( pfnWakeup );
		(this->*pfnWakeup)();
	}
	else if ( STATUS_WRITE_ERROR == lBufStatus )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FillComplete() - Error writing while filling.  Notifying CopyTo observer\n", GetCurrentThreadId(), this );

		//
		//	We are in the WRITE_ERROR state.  This state is entered
		//	by CEcbStream::WriteComplete() during an async CopyTo operation
		//	when a write fails.  This terminal state prevents new async fill
		//	operations from starting.  When WriteComplete() transitioned into
		//	this state, it also checked if we were FILLING at the time.
		//	If we were then WriteComplete() left the responsibility for notifying
		//	the CopyTo observer up to us.  See CEcbStream::WriteComplete()
		//	for the reason why.
		//
		Assert( m_pobsAsyncCopyTo );
		m_pobsAsyncCopyTo->CopyToComplete( 0, m_hr );

		//
		//	Note that once in the WRITE_ERROR state we DO NOT transition
		//	back to IDLE.  WRITE_ERROR is a terminal state.
		//
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::IISIOComplete()
//
//	Our IIISAsyncIOCompleteObserver method called by CEcb::IISIOComplete()
//	when the async I/O to read from the read-once request body stream
//	completes.
//
VOID
CEcbStream::IISIOComplete( DWORD dwcbRead,
						   DWORD dwLastError )
{
	//
	//	Claim the reference to our parent request added in AsyncFillBuf()
	//
	auto_ref_ptr<IRequest> pRef;
	pRef.take_ownership(&m_request);

	//
	//	Update the m_dwcbStreamConsumed *before* m_ibBufFill so that
	//	we can safely assert at any time on any thread that we never
	//	drain more than has been consumed.
	//
	//	Chunked requests: If we successfully read 0 bytes then we have
	//	reached the end of the request and should report the real
	//	stream size.
	//
	if ( ERROR_SUCCESS == dwLastError )
	{
		if ( 0 == dwcbRead )
			m_dwcbStreamSize = m_dwcbStreamConsumed;
		else
			m_dwcbStreamConsumed += dwcbRead;
	}
	else
	{
		DebugTrace( "CEcbStream::IISIOComplete() - Error %d during async read\n", dwLastError );
		m_hr = HRESULT_FROM_WIN32(dwLastError);
	}

#ifdef DBG
	UINT cbBufAvail = InterlockedExchangeAdd( reinterpret_cast<LONG *>(&dbgm_cbBufAvail), dwcbRead ) + dwcbRead;
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: !!!CEcbStream::IISIOComplete() %lu left to read (%u in buffer)\n", GetCurrentThreadId(), this, m_dwcbStreamSize - m_dwcbStreamConsumed, cbBufAvail );
#endif

	//	Assert that we didn't just read past the end of our buffer.
	//
	Assert( m_ibBufFill + dwcbRead <= CB_BUF );

	//	Update the fill position.  If we've reached the end of the buffer
	//	then wrap back to the beginning.  We must do this here BEFORE
	//	calling FillComplete() -- the fill position must be valid (i.e.
	//	within the bounds of the buffer) before we start off another
	//	fill cycle.
	//
	m_ibBufFill += dwcbRead;
	if ( CB_BUF == m_ibBufFill )
	{
		m_ibBufWrap = CB_BUF;
		m_ibBufFill = 0;
	}

	//	If we read more than the last fill hint then we know we
	//	can try to read at least this much next time.
	//
	if ( dwcbRead > m_cbBufFillHint )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::IISIOComplete() setting m_cbBufFillHint = %lu\n", GetCurrentThreadId(), this, dwcbRead );
		m_cbBufFillHint = dwcbRead;
	}

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::IISIOComplete() dwcbRead = %lu, m_ibBufFill = %lu, m_dwcbStreamConsumed = %lu, m_dwcbStreamSize = %lu, dwLastError = %lu\n", GetCurrentThreadId(), this, dwcbRead, m_ibBufFill, m_dwcbStreamConsumed, m_dwcbStreamSize, dwLastError );

	//
	//	Indicate that we're done filling.  This resets the state from FILLING
	//	(or FAULTING) to idle and wakes up the observer if it is blocked.
	//
	FillComplete();

	//
	//	Kick off the next read cycle.  AsyncFillBuf() checks for error and
	//	end-of-stream conditions, so we don't have to.
	//
	AsyncFillBuf();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::HrBufReady()
//
//	Determines how much and the location of the next block of data that
//	is instantaneously accessible in the buffer.  Also determines whether
//	the stream is in an error state (e.g. due to a failure reading
//	from the stream while filling the buffer).
//
//	The matrix of return results is:
//
//	HRESULT		*pcbBufReady	*ppbBufReady	Meaning
//	----------------------------------------------------
//	S_OK		> 0				valid			Data available
//	S_OK		0				n/a				No data available (EOS)
//	E_PENDING	n/a				n/a				No data available (pending)
//	E_xxx		n/a				n/a				Error
//
HRESULT
CEcbStream::HrBufReady( UINT * pcbBufReady,
						const BYTE ** ppbBufReady ) const
{
	Assert( pcbBufReady );
	Assert( ppbBufReady );

	//
	//	If the buffer has data ready, then return the amount and
	//	its location.
	//
	*pcbBufReady = CbBufReady();
	if ( *pcbBufReady )
	{
		*ppbBufReady = PbBufReady();
		return S_OK;
	}

	//
	//	No data ready.  If the buffer is in an error state
	//	then return the fact.
	//
	if ( m_hr )
		return m_hr;

	//
	//	No data ready and we haven't had an error.  If the buffer
	//	is FILLING then transition to FAULTING and tell it to
	//	notify the observer when data becomes ready.  Return
	//	E_PENDING to the caller to tell it that we will be
	//	notifying the observer later.
	//
	//	Note that the very instant before we try to transition to FAULTING,
	//	the buffer may go from FILLING back to IDLE.  If that
	//	happens, then data should be ready, so go `round the loop
	//	and check again.
	//
	Assert( STATUS_FAULTING != m_lBufStatus );

	if ( STATUS_FILLING == InterlockedCompareExchange(
								&m_lBufStatus,
								STATUS_FAULTING,
								STATUS_FILLING ) )
		return E_PENDING;

	//
	//	The buffer must have finished FILLING sometime between
	//	when we did the initial poll and now.  At this point
	//	there must be data ready.
	//
	*pcbBufReady = CbBufReady();
	*ppbBufReady = PbBufReady();
	return S_OK;
}


//	========================================================================
//
//	CLASS CRequest
//
//		Request class
//
class CRequest : public IRequest
{
	//	Extension control block passed in through the ISAPI interface
	//
	auto_ref_ptr<IEcb>		m_pecb;

	//	Header caches. We retrieve headers as skinny, as no other
	//	choice is available.
	//		But sometimes we need wide version to operate on, so in
	//	that case we will get the skinny version, convert it properly
	//	and store in the wide header cache.
	//
	mutable CHeaderCache<CHAR>	m_hcHeadersA;
	mutable CHeaderCache<WCHAR>	m_hcHeadersW;

	//	This flag tells us whether we have cleared the headers
	//	and thus whether we should check the ECB when we cannot
	//	find a header in the cache.  Since we cannot actually remove
	//	headers from from the ECB, we just remember not to check the
	//	ECB if the headers have ever been "cleared".
	//
	bool					m_fClearedHeaders;

	//	Request body
	//
	auto_ptr<IBody>			m_pBody;

	//  NOT IMPLEMENTED
	//
	CRequest& operator=( const CRequest& );
	CRequest( const CRequest& );

public:
	//	CREATORS
	//
	CRequest( IEcb& ecb );

	//	ACCESSORS
	//
	LPCSTR LpszGetHeader( LPCSTR pszName ) const;
	LPCWSTR LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const;
	BOOL FExistsBody() const;
	IStream * GetBodyIStream( IAsyncIStreamObserver& obs ) const;
	VOID AsyncImplPersistBody( IAsyncStream& stm,
							   IAsyncPersistObserver& obs ) const;

	//	MANIPULATORS
	//
	VOID ClearBody();
	VOID AddBodyText( UINT cbText, LPCSTR pszText );
	VOID AddBodyStream( IStream& stm );
};

//	------------------------------------------------------------------------
//
//	CRequest::CRequest()
//
CRequest::CRequest( IEcb& ecb ) :
    m_pecb(&ecb),
	m_pBody(NewBody()),
	m_fClearedHeaders(false)
{
	//
	//	If the ECB contains a body, then create a body part for it.
	//
	if ( ecb.CbTotalBytes() > 0 )
		m_pBody->AddBodyPart( new CEcbRequestBodyPart(ecb, *this) );

	//	HACK: The ECB needs to keep track of two pieces of request info,
	//	the Accept-Language and Connection headers.
	//	"Prime" the ECB with the Accept-Language value (if one is specified).
	//	The Connection header is sneakier -- read about that in
	//	CEcb::FKeepAlive.  Don't set it here, but do push updates through
	//	from SetHeader.
	//
	LPCSTR pszValue = LpszGetHeader( gc_szAccept_Language );
	if (pszValue)
		m_pecb->SetAcceptLanguageHeader( pszValue );
}


//	------------------------------------------------------------------------
//
//	CRequest::LpszGetHeader()
//
//		Retrieves the value of the specified HTTP request header.  If the
//		request does not have the specified header, LpszGetHeader() returns
//		NULL.  The header name, pszName, is in the standard HTTP header
//		format (e.g. "Content-Type")
//
LPCSTR
CRequest::LpszGetHeader( LPCSTR pszName ) const
{
	Assert( pszName );

	LPCSTR pszValue;

	//	Check the cache.
	//
	pszValue = m_hcHeadersA.LpszGetHeader( pszName );

	//	If we don't find the header in the cache then check
	//	the ECB
	//
	if ( !pszValue )
	{
		UINT cbName = static_cast<UINT>(strlen(pszName));
		CStackBuffer<CHAR> pszVariable( gc_cchHTTP_ + cbName + 1 );
		CStackBuffer<CHAR> pszBuf;

		//	Headers retrieved via the ECB are named using the ECB's
		//	server variable format (e.g. "HTTP_CONTENT_TYPE"), so we must
		//	convert our header name from its HTTP format to its ECB
		//	server variable equivalent.
		//
		//	Start with the header, prepended with "HTTP_"
		//
		memcpy( pszVariable.get(), gc_szHTTP_, gc_cchHTTP_ );
		memcpy( pszVariable.get() + gc_cchHTTP_, pszName, cbName + 1 );

		//	Replace all occurrences of '-' with '_'
		//
		for ( CHAR * pch = pszVariable.get(); *pch; pch++ )
		{
			if ( *pch == '-' )
				*pch = '_';
		}

		//	And uppercasify the whole thing
		//
		_strupr( pszVariable.get() );

		//	Get the value of this server variable from the ECB and
		//	add it to the header cache using its real (HTTP) name
		//
		for ( DWORD cbValue = 256; cbValue > 0; )
		{
			if (NULL == pszBuf.resize(cbValue))
			{
				SetLastError(E_OUTOFMEMORY);
				DebugTrace("CRequest::LpszGetHeader() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				throw CLastErrorException();
			}

			if ( m_pecb->FGetServerVariable( pszVariable.get(),
											 pszBuf.get(),
											 &cbValue ))
			{
				pszValue = m_hcHeadersA.SetHeader( pszName, pszBuf.get() );
				break;
			}
		}
	}

	return pszValue;
}

//	------------------------------------------------------------------------
//
//	CRequest::LpwszGetHeader()
//
//		Provides and caches wide version of the header value
//
//	PARAMETERS:
//
//		pszName			- header name
//		fUrlConversion	- flag that if set to TRUE indicates that special
//						  conversion rules should be applied. I.e. the
//						  header contains URL-s, that need escaping and
//						  codepage lookup. If set to FALSE the header will
//						  simply be converted using UTF-8 codepage. E.g.
//						  we do expect only US-ASCII characters in that
//						  header (or any other subset of UTF-8).
//							Flag is ignored once wide version gets cached.
//
LPCWSTR
CRequest::LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const
{
	Assert( pszName );

	//	Check the cache
	//
	LPCWSTR pwszValue = m_hcHeadersW.LpszGetHeader( pszName );

	//	If we don't find the header in the cache then out for
	//	the skinny version, convert it and cache.
	//
	if ( !pwszValue )
	{
		//	Check the skinny cache
		//
		LPCSTR pszValue = LpszGetHeader( pszName );
		if (pszValue)
		{
			SCODE sc;

			CStackBuffer<WCHAR> pwszBuf;
			UINT cbValue = static_cast<UINT>(strlen(pszValue));
			UINT cchValue = cbValue + 1;

			//	Make sure we have sufficient buffer for conversion
			//
			if (NULL == pwszBuf.resize(CbSizeWsz(cbValue)))
			{
				sc = E_OUTOFMEMORY;
				SetLastError(sc);
				DebugTrace("CRequest::LpwszGetHeader() - Error while allocating memory 0x%08lX\n", sc);
				throw CLastErrorException();
			}

			sc = ScConvertToWide(pszValue,
								 &cchValue,
								 pwszBuf.get(),
								 LpszGetHeader(gc_szAccept_Language),
								 fUrlConversion);
			if (S_OK != sc)
			{
				//	We gave sufficient buffer
				//
				Assert(S_FALSE != sc);
				SetLastError(sc);
				throw CLastErrorException();
			}

			pwszValue = m_hcHeadersW.SetHeader( pszName, pwszBuf.get() );
		}
	}

	return pwszValue;
}

//	------------------------------------------------------------------------
//
//	CRequest::FExistsBody()
//
BOOL
CRequest::FExistsBody() const
{
	return !m_pBody->FIsEmpty();
}

//	------------------------------------------------------------------------
//
//	CRequest::GetBodyIStream()
//
IStream *
CRequest::GetBodyIStream( IAsyncIStreamObserver& obs ) const
{
	//
	//	With the assumption above in mind, persist the request body.
	//
	return m_pBody->GetIStream( obs );
}

//	------------------------------------------------------------------------
//
//	CRequest::AsyncImplPersistBody()
//
VOID
CRequest::AsyncImplPersistBody( IAsyncStream& stm,
								IAsyncPersistObserver& obs ) const
{
	m_pBody->AsyncPersist( stm, obs );
}

//	------------------------------------------------------------------------
//
//	CRequest::ClearBody()
//
VOID
CRequest::ClearBody()
{
	m_pBody->Clear();
}

//	------------------------------------------------------------------------
//
//	CRequest::AddBodyText()
//
//		Adds the specified text to the end of the request body.
//
VOID
CRequest::AddBodyText( UINT cbText, LPCSTR pszText )
{
	m_pBody->AddText( pszText, cbText );
}


//	------------------------------------------------------------------------
//
//	CRequest::AddBodyStream()
//
//		Adds the specified stream to the end of the request body.
//
VOID
CRequest::AddBodyStream( IStream& stm )
{
	m_pBody->AddStream( stm );
}



//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewRequest
//
IRequest *
NewRequest( IEcb& ecb )
{
	return new CRequest(ecb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\methutil.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	METHUTIL.CPP
//
//		Implementation of external IMethUtil interface
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "instdata.h"

//	IIS MetaData header
#include <iiscnfg.h>


//	========================================================================
//
//	CLASS CMethUtil
//

//	------------------------------------------------------------------------
//
//	CMethUtil::FInScriptMap()
//
//	Utility to determine whether there is information in the scriptmaps
//	about a particular URI and whether it applies.
//
BOOL
CMethUtil::FInScriptMap (LPCWSTR pwszURI,
						 DWORD dwAccess,
						 BOOL * pfCGI,
						 SCODE * pscMatch) const
{
	SCODE	scMatch;

	//	Fetch the script map.
	//
	const IScriptMap * pScriptMap = m_pecb->MetaData().GetScriptMap();

	//	If we have a script map at all then check it for a match.
	//	Otherwise we have no match by definition.
	//
	if (pScriptMap)
	{
		scMatch = pScriptMap->ScMatched (LpwszMethod(),
										 MidMethod(),
										 pwszURI,
										 dwAccess,
										 pfCGI);

		if (S_OK != scMatch)
		{
			//	ScApplyChildISAPI need the SCODE value
			//
			if (pscMatch)
				*pscMatch = scMatch;
			return TRUE;
		}
	}

	return FALSE;
}

//	------------------------------------------------------------------------
//
//	CMethUtil::ScApplyChildISAPI()
//
//	During normal method processing to actually forward a method.
//
//	fCheckISAPIAccess flag tells us whether to do the "extra ACL check for ASP".
//	FALSE means don't check for READ & WRITE in the acl, TRUE means do the check.
//
//	fKeepQueryString is a special flag, TRUE by default.  This flag is only
//	used when actually forwarding the method.  It can be set to FALSE
//	when we are forwarding the request to a different URI
//	(like a default document in a folder).
//
//	fDoNotForward	if set to TRUE instead of forwarding request to the child ISAPI the
//					function will return error mapping to 502 bad gateway (necessary for
//					batch methods for which forwarding to child ISAPI id done just on
//					request URL basis)
//
//	fCheckImpl		for folder level script execute permissions.  TRUE if we need to
//					make a trip to the store to verify that the parent does not have
//					the ScriptAccess property set to FALSE -- meaning we don't want to
//					forward the request to a child isapi
//
//	Return codes
//		NOTE: These codes were carefully chosen so that the FAILED() macro
//		can be applied to the return code and tell us whether to
//		terminate our method processing.
//
//		This may seem counterintuitive, but this function FAILS if
//		any of the following happened:
//		o	An ISAPI was found to handle this method (and the method
//			was forwarded successfully.
//		o	The caller said Translate:F, but doesn't have correct Metabase access.
//		o	The caller said Translate:F, but doesn't have correct ACL access.
//
//		This method SUCCEEDS if:
//		o	The caller said Translate:F, and passed all access checks.
//		o	No matching ISAPI was found.
//
//	S_OK	There was NO ISAPI to apply
//	E_DAV_METHOD_FORWARDED
//			There was an ISAPI to apply, and the method WAS successfully
//			forwarded.  NOTE: This IS a FAILED return code!  We should STOP
//			method processing if we see this return code!
//
//
//$REVIEW: Right now, we check the Author bit (Metabase::MD_ACCESS_SOURCE)
//$REVIEW: if they say Translate:F, but NOT if there are no scriptmaps or
//$REVIEW: if our forwarding fails.  Is this right?


SCODE
CMethUtil::ScApplyChildISAPI(LPCWSTR pwszURI,
							 DWORD	dwAccess,
							 BOOL	fCheckISAPIAccess,
							 LPBYTE pbSD,
							 BOOL	fKeepQueryString,
							 BOOL	fIgnoreTFAccess,
							 BOOL	fDoNotForward,
							 BOOL	fCheckImpl) const
{
	BOOL fFoundMatch = FALSE;
	BOOL fCGI;
	SCODE sc = S_OK;
	UINT cchURI = 0;

	//	if pbSD is passed in, fCheckISAPIAccess must be TRUE
	//
	Assert (!pbSD || fCheckISAPIAccess);

	//	If there is a scriptmap then grab it and see if there is a match.
	//	(If there is, remember if this was a CGI script or no.)
	//
	fFoundMatch = FInScriptMap (pwszURI,
								dwAccess,
								&fCGI,
								&sc);

	ScriptMapTrace ("CMethUtil::ScApplyChildISAPI()"
					"-- matching scriptmap %s, sc=0x%08x\n",
					fFoundMatch ? "found" : "not found",
					sc);

	//	If we are just being called to check for matching scriptmaps,
	//	report our findings now.  Or if there were no scriptmaps that
	//	applied, then we are also good to go.
	//
	if (!fFoundMatch)
		goto ret;

	//	We do not call into the child ISAPI's if the "Translate" header
	//	is present and its value is "F"
	//
	if (!FTranslated())
	{
		//	Translate header indicates no translation is allowed.
		//


		//	If the access check on translate: f is to be ignored
		//	return straight away
		//
		if (fIgnoreTFAccess)
		{
			sc = S_OK;
			goto ret;
		}

		//	Check our metabase access.  We must have the Author bit
		//	(MD_ACCESS_SOURCE) in order to process raw source bits
		//	if, and only if, a scriptmap did apply to the resource.
		//
		if (!(dwAccess & MD_ACCESS_SOURCE))
		{
			DebugTrace ("CMethUtil::ScApplyChildISAPI()"
						"-- Translate:F with NO metabase Authoring access.\n");

			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}

		//	One more thing, tho....
		//
		//	IF they've asked for special access checking, AND we found a match,
		//	AND it's a script (NOT a CGI), then do the special access checking.
		//
		//	NOTE: This all comes from "the ASP access bug".  ASP overloaded
		//	the NTFS read-access-bit to also mean execute-access.
		//	That means that many agents will have read-access to ASP files.
		//	So how do we restrict access to fetch the raw ASP bits, when
		//	the read-bit means execute?  Well, we're gonna assume that
		//	an agent that is allowed to read the raw bits is also allowed to
		//	WRITE the raw bits.  If they have WRITE access to the ASP-file,
		//	then, and only then, let them fetch raw scriptfile bits.
		//
		if (fCheckISAPIAccess && !fCGI)
		{
			if (FAILED (ScChildISAPIAccessCheck (*m_pecb,
				m_pecb->LpwszPathTranslated(),
				GENERIC_READ | GENERIC_WRITE,
				pbSD)))
			{
				//	They didn't have read AND WRITE access.
				//	Return FALSE, and tell the caller that the access check failed.
				//
				DebugTrace ("ScChildISAPIAccessCheck() fails the processing of this method!\n");
				sc = E_ACCESSDENIED;
				goto ret;
			}
		}
	}
	else
	{
		//	Translate header says TRUE. we need execute permission to forward
		//	the request
		//
		if ((dwAccess & (MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT)) == 0)
		{
			sc = E_DAV_NO_IIS_EXECUTE_ACCESS;
			goto ret;
		}

		ScriptMapTrace ("ScApplyChildISAPI -- Forwarding method\n");

		//	If the method is excluded, then we really do not want to
		//	touch the source, so "translate: t"/excluded is a no-access
		//
		if (sc == W_DAV_SCRIPTMAP_MATCH_EXCLUDED)
		{
			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}

		Assert (sc == W_DAV_SCRIPTMAP_MATCH_FOUND);

		//	Make a check, if we are allowed to forward
		//	to child ISAPI, if not return error mapping
		//	to 502 bad gateway
		//
		if (fDoNotForward)
		{
			sc = E_DAV_STAR_SCRIPTMAPING_MISMATCH;
			goto ret;
		}

		//  if we are going forwarding this to a child ISAPI, we need to check
		//  if the URI has a trailing slash or backslash.  if it does we will
		//  model httpext behavior and fail as file not found.  trailing
		//  backslashes and slashes are not handled well if forwarded...
		//
		Assert (pwszURI);
		cchURI = static_cast<UINT>(wcslen(pwszURI));
		if (1 < cchURI)
		{
			if (L'/' == pwszURI[cchURI-1] || L'\\' == pwszURI[cchURI-1])
			{
				sc = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
				goto ret;
			}
		}

		//	Try the forward.
		//
		//	BIG NOTE: If it fails, we're gonna check the GetLastError,
		//	and if that happens to be ERROR_INVALID_PARAMETER,
		//	we're gonna assume that there's not actually any applicable
		//	scriptmap, and process the method ourselves after all!
		//
		sc = m_presponse->ScForward(pwszURI,
									fKeepQueryString,
									FALSE);
		if (FAILED(sc))
		{
			//	The forward attempt failed because there is no applicable
			//	scriptmap.  Let's handle the method ourselves.
			//$REVIEW: This is going to have the same end result as
			//$REVIEW: Translate:F.  Should we check the "author" bit here???
			//
			if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == sc)
			{
				//	We get to handle this method.
				//
				sc = S_OK;

				if (!(dwAccess & MD_ACCESS_SOURCE))
				{
					DebugTrace ("ScApplyChildISAPI"
								"-- Forward FAIL with NO metabase Authoring access.\n");
					sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
					goto ret;
				}
			}

			goto ret;
		}

		//	We were forwarded...
		//
		sc = E_DAV_METHOD_FORWARDED;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	DwDirectoryAccess()
//
//	Fetch access perms for the specified URI.
//
DWORD
DwDirectoryAccess(
	const IEcb &ecb,
	LPCWSTR pwszURI,
	DWORD dwAccIfNone)
{
	DWORD dwAcc = dwAccIfNone;
	auto_ref_ptr<IMDData> pMDData;

	if (SUCCEEDED(HrMDGetData(ecb, pwszURI, pMDData.load())))
		dwAcc = pMDData->DwAccessPerms();

	return dwAcc;
}

//	IIS Access ----------------------------------------------------------------
//
SCODE
CMethUtil::ScIISAccess (
	LPCWSTR pwszURI,
	DWORD dwAccessRequested,
	DWORD* pdwAccessOut,
	UINT mode) const
{
	DWORD dw;

	//	Make sure the url is stripped of any prefix
	//
	pwszURI = PwszUrlStrippedOfPrefix (pwszURI);

	//$	SECURITY:
	//
	//	Plug the ::$DATA security hole for NT5.
	//
	if (! FSucceededColonColonCheck(pwszURI))
		return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);

	//	Get the access from the cache
	//
	dw = DwDirectoryAccess( *m_pecb,
							pwszURI,
							dwAccessRequested );

	//	If the caller actually needs the bits back, pass them
	//	back here
	//
	if (pdwAccessOut)
		*pdwAccessOut = dw;

	//	Check the access bits against the requested bits
	//
	if ((dw & dwAccessRequested) == dwAccessRequested)
		return S_OK;
	else if ((mode & ACS_LOOSE) && (dw & dwAccessRequested))
		return S_OK;

	return E_DAV_NO_IIS_ACCESS_RIGHTS;
}

//	Common IIS checking
//		Apply child ISAPI if necessary, if not, verify if desired access
//	is granted
//
//	parameters
//		pszURI			the request URI
//		dwDesired		desired access, default is zero
//		fCheckISAPIAccess	Only used by GET/HEAD, default to FALSE.
//		fDoNotForward	if set to TRUE instead of forwarding request to the child ISAPI the
//						function will return error mapping to 502 bad gateway (necessary for
//						batch methods for which forwarding to child ISAPI id done just on
//						request URL basis)
//		fCheckImpl		for folder level script execute permissions.  TRUE if we need to
//						make a trip to the store to verify that the parent does not have
//						the ScriptAccess property set to FALSE -- meaning we don't want to
//						forward the request to a child isapi
//
SCODE
CMethUtil::ScIISCheck( LPCWSTR pwszURI,
					   DWORD dwDesired			/* = 0 */,
					   BOOL fCheckISAPIAccess 	/* = FALSE */,
					   LPBYTE pbSD 				/* = NULL */,
					   BOOL	fDoNotForward 		/* = FALSE */,
					   BOOL fCheckImpl 			/* = TRUE */,
					   DWORD * pdwAccessOut		/* = NULL */) const
{
	SCODE	sc = S_OK;

	//$	SECURITY:
	//
	//	Plug the ::$DATA security hole for NT5.
	//
	if (! FSucceededColonColonCheck(pwszURI))
		return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);

	//	Whoa, baby.  Do not let "*" urls get through this
	//	check unless the method is unknown or is an OPTIONS
	//	request.
	//
	if ((L'*' == pwszURI[0]) && ('\0' == pwszURI[1]))
	{
		if ((MID_UNKNOWN != m_mid) && (MID_OPTIONS != m_mid))
		{
			DebugTrace ("Dav: url: \"*\" not valid for '%ls'\n",
						m_pecb->LpwszMethod());

			return E_DAV_METHOD_FAILURE_STAR_URL;
		}
	}

	//	Get IIS access rights
	//
	DWORD dwAcc = DwDirectoryAccess (*m_pecb, pwszURI, 0);

	//	See if we need to hand things off to a child ISAPI.
	//
	sc = ScApplyChildISAPI (pwszURI,
							dwAcc,
							fCheckISAPIAccess,
							pbSD,
							TRUE,
							0 == dwDesired,
							fDoNotForward,
						    fCheckImpl);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check to see if the desired access is granted
	//
	if (dwDesired != (dwAcc & dwDesired))
	{
		//	At least one of the desired access rights is not granted,
		//	so generate an appropriate error.  Note: if multiple rights
		//	were requested then multiple rights may not have been granted.
		//	The error is guaranteed to be appropriate to at least one
		//	of the rights not granted, but not necessariliy all of them.
		//
		switch (dwDesired & (MD_ACCESS_READ|MD_ACCESS_WRITE))
		{
			case MD_ACCESS_READ:
				sc = E_DAV_NO_IIS_READ_ACCESS;
				break;

			case MD_ACCESS_WRITE:
				sc = E_DAV_NO_IIS_WRITE_ACCESS;
				break;

			default:
				sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
				break;
		}
		goto ret;
	}

	//	Pass back the metabase access setting
	//
	if (pdwAccessOut)
		*pdwAccessOut = dwAcc;

ret:
	return sc;
}

//	Destination url access ------------------------------------------------
//
SCODE __fastcall
CMethUtil::ScGetDestination (LPCWSTR* ppwszUrl,
							 LPCWSTR* ppwszPath,
							 UINT* pcchPath,
							 CVRoot** ppcvr) const		//	Defaults to NULL
{
	SCODE sc = S_OK;

	LPCWSTR	pwszFullUrl = NULL;

	Assert (ppwszUrl);
	Assert (ppwszPath);
	Assert (pcchPath);

	*ppwszUrl = NULL;
	*ppwszPath = NULL;
	*pcchPath = 0;
	if (ppcvr)
		*ppcvr = NULL;

	//	If we haven't done this yet...
	//
	if (NULL == m_pwszDestinationUrl.get())
	{
		LPCWSTR pwszStripped;
		UINT cch;

		//	Get the header in unicode, apply URL conversion. I.e.
		//	value will be escaped and and translated into unicode
		//	taking into account the Accept-Language: header
		//
		pwszFullUrl = m_prequest->LpwszGetHeader(gc_szDestination, TRUE);

		//	If they asked for a destination, there better be one...
		//
		if (NULL == pwszFullUrl)
		{
			sc = E_DAV_NO_DESTINATION;
			DebugTrace ("CMethUtil::ScGetDestination() - required destination header not present\n");
			goto ret;
		}

		//	URL has been escaped at header retrieval step, the last step
		//	in order to get normalized URL is to canonicalize what we have
		//	at the current moment. So allocate enough space and fill it.
		//
		cch = static_cast<UINT>(wcslen(pwszFullUrl) + 1);
		m_pwszDestinationUrl = static_cast<LPWSTR>(g_heap.Alloc(cch * sizeof(WCHAR)));

		//	Canonicalize the absolute URL. It does not mater what value we
		//	pass in for cch here - it is just an output parameter.
		//
		sc = ScCanonicalizePrefixedURL (pwszFullUrl,
										m_pwszDestinationUrl.get(),
										&cch);
		if (S_OK != sc)
		{
			//	We've given ScCanonicalizeURL() sufficient space, we
			//	should never see S_FALSE here - size can only shrink.
			//
			Assert(S_FALSE != sc);
			DebugTrace ("CMethUtil::ScGetDestination() - ScCanonicalizeUrl() failed 0x%08lX\n", sc);
			goto ret;
		}
		
		//	Now translate the path, take a best guess and use MAX_PATH as
		//	the initial size of the path
		//
		cch = MAX_PATH;
		m_pwszDestinationPath = static_cast<LPWSTR>(g_heap.Alloc(cch * sizeof(WCHAR)));

		sc = ::ScStoragePathFromUrl (*m_pecb,
									 m_pwszDestinationUrl.get(),
									 m_pwszDestinationPath.get(),
									 &cch,
									 m_pcvrDestination.load());

		//	If there was not enough space -- ie. S_FALSE was returned --
		//	then reallocate and try again...
		//
		if (sc == S_FALSE)
		{
			m_pwszDestinationPath.realloc(cch * sizeof(WCHAR));

			sc = ::ScStoragePathFromUrl (*m_pecb,
										 m_pwszDestinationUrl.get(),
										 m_pwszDestinationPath.get(),
										 &cch,
										 m_pcvrDestination.load());

			//	We should not get S_FALSE again --
			//	we allocated as much space as was requested.
			//
			Assert (S_FALSE != sc);
		}
		if (FAILED(sc))
			goto ret;

		//	We always will get '\0' terminated string back, and cch will indicate
		//	the number of characters written (including '\0' termination). Thus it
		//	will always be greater than 0 at this point
		//
		Assert( cch > 0 );
		m_cchDestinationPath = cch - 1;

		//	We must remove all trailing slashes, in case the path is not empty string
		//
		if ( 0 != m_cchDestinationPath )
		{
			//	Since URL is normalized there may be not more than one trailing slash
			//
			if ((L'\\' == m_pwszDestinationPath[m_cchDestinationPath - 1]) ||
				(L'/'  == m_pwszDestinationPath[m_cchDestinationPath - 1]))
			{
				m_cchDestinationPath--;
				m_pwszDestinationPath[m_cchDestinationPath] = L'\0';
			}
		}
	}

	//	We will have S_OK or W_DAV_SPANS_VIRTUAL_ROOTS here.
	//	In any case it is success
	//
	Assert(SUCCEEDED(sc));

	//	Return the pointers. For the url, make sure that any
	//	prefix is stripped off.
	//
	//	Note that the ScStoragePathFromUrl() already has checked
	//	to see if the all important prefix matched, so we just need
	//	to strip
	//
	*ppwszUrl = PwszUrlStrippedOfPrefix (m_pwszDestinationUrl.get());

	//	Pass everything back to the caller
	//
	*ppwszPath = m_pwszDestinationPath.get();
	*pcchPath = m_cchDestinationPath;

	//	If they wanted the destination virtual root, hand that back
	//	as well.
	//
	if (ppcvr)
	{
		*ppcvr = m_pcvrDestination.get();
	}

ret:

	//	Do a cleanup if we failed. Subsequent calls to the
	//	function just may start returning partial data if
	//	we do not do that. That is undesirable.
	//
	if (FAILED (sc))
	{
		if (m_pwszDestinationUrl.get())
			m_pwszDestinationUrl.clear();

		if (m_pwszDestinationPath.get())
			m_pwszDestinationPath.clear();

		if (m_pcvrDestination.get())
			m_pcvrDestination.clear();

		m_cchDestinationPath = 0;
	}

	return sc;
}

//	------------------------------------------------------------------------
//
//	CMethUtil::ScGetExpirationTime
//
//	Gets the expiration time string from the metabase corresponding to a
//	particular resource.  If pszURI is NULL and there is information in the
//	metabase for the particular resource, the function will return (in pcb) the number
//	of bytes necessary to pass in as pszBuf to get the requested expiration
//	string.
//
//			[in]	pszURI		The resource you want the expiration time string for
//			[in]	pszBuf,		The buffer we put the string into
//			[in out]pcb			On [in], the size of the buffer passed in,
//								On [out], if the buffer size passed in would be
//								insufficient or there was no buffer passed in.
//								Otherwise unchanged from [in].
//
//	Return values:
//		S_OK: If pszBuf was non-NULL, then the data was successfully retrieved and
//			  the length of the actual data was put in pcb.
//		HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): The buffer passed in is not
//													   large enough to hold
//													   the requested data.
//		HRESULT_FROM_WIN32(ERROR_NO_DATA): No data for expiration time exists in the
//										   metabase for this resource.  Default value
//										   of 1 day expiration should be used in this
//										   case.
//
SCODE
CMethUtil::ScGetExpirationTime(IN		LPCWSTR	pwszURI,
							   IN		LPWSTR	pwszBuf,
							   IN OUT	UINT *	pcch)
{
	SCODE sc = S_OK;
	auto_ref_ptr<IMDData> pMDData;
	LPCWSTR pwszExpires = NULL;
	UINT cchExpires;

	//
	//	Fetch the metadata for this URI.  If it has a content type map
	//	then use it to look for a mapping.  If it does not have a content
	//	type map then check the global mime map.
	//
	//	Note: if we fail to get the metadata at all then default the
	//	content type to application/octet-stream.  Do not use the global
	//	mime map just because we cannot get the metadata.
	//
	if ( FAILED(HrMDGetData(pwszURI, pMDData.load())) ||
		 (NULL == (pwszExpires = pMDData->PwszExpires())) )
	{
		sc = HRESULT_FROM_WIN32(ERROR_NO_DATA);
		goto ret;
	}

	cchExpires = static_cast<UINT>(wcslen(pwszExpires) + 1);
	if (*pcch < cchExpires)
	{
		sc = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		*pcch = cchExpires;
		goto ret;
	}
	else
	{
		memcpy(pwszBuf, pwszExpires, cchExpires * sizeof(WCHAR));
		*pcch = cchExpires;
	}

ret:

	return sc;
}

//	ScCheckMoveCopyDeleteAccess() ---------------------------------------------
//
SCODE
CMethUtil::ScCheckMoveCopyDeleteAccess (
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvrUrl,			//	OPTIONAL (may be NULL)
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess)
{
	Assert (pwszUrl);

	auto_ref_ptr<IMDData> pMDData;
	BOOL fCGI = FALSE;
	DWORD dwAccessActual = 0;
	SCODE sc = S_OK;

	//	Get the metadata object
	//
	//$	REVIEW: Ideally we could get this without it being cached
	//
	if (NULL == pcvrUrl)
	{
		sc = HrMDGetData (pwszUrl, pMDData.load());
		if (FAILED (sc))
			goto ret;
	}
	else
	{
		LPCWSTR pwszMbPathVRoot;
		CStackBuffer<WCHAR> pwszMbPathChild;
		UINT cchPrefix;
		UINT cchUrl = static_cast<UINT>(wcslen(pwszUrl));

		//	Map the URI to its equivalent metabase path, and make sure
		//	the URL is stripped before we call into the MDPath processing
		//
		Assert (pwszUrl == PwszUrlStrippedOfPrefix (pwszUrl));
		cchPrefix = pcvrUrl->CchPrefixOfMetabasePath (&pwszMbPathVRoot);
		if (!pwszMbPathChild.resize(CbSizeWsz(cchPrefix + cchUrl)))
			return E_OUTOFMEMORY;

		memcpy (pwszMbPathChild.get(), pwszMbPathVRoot, cchPrefix * sizeof(WCHAR));
		memcpy (pwszMbPathChild.get() + cchPrefix, pwszUrl, (cchUrl + 1) * sizeof(WCHAR));
		sc = HrMDGetData (pwszMbPathChild.get(), pwszMbPathVRoot, pMDData.load());
		if (FAILED (sc))
			goto ret;
	}
	//
	//$	REVIEW: end.

	//	Check metabase access to see if we have the minimal access
	//	required for this operation.
	//
	dwAccessActual = pMDData->DwAccessPerms();
	if ((dwAccessActual & dwAccess) != dwAccess)
	{
		sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
		goto ret;
	}

	//$	SECURITY: check for IP restrictions placed on this resource
	//$	REVIEW: this may not be good enough, we may need to do more
	//	than this...
	//
	if (!m_pecb->MetaData().FSameIPRestriction(pMDData.get()))
	{
		sc = E_DAV_BAD_DESTINATION;
		goto ret;
	}
	//
	//$	REVIEW: end.

	//$	SECURITY: Check to see if authorization is different than the
	//	request url's authorization.
	//
	if (m_pecb->MetaData().DwAuthorization() != pMDData->DwAuthorization())
	{
		sc = E_DAV_BAD_DESTINATION;
		goto ret;
	}
	//
	//$	REVIEW: end.

	//	Check to see if we have 'star' scriptmap honors over this
	//	file.
	//
	if (!m_pecb->MetaData().FSameStarScriptmapping(pMDData.get()))
	{
		sc = E_DAV_STAR_SCRIPTMAPING_MISMATCH;
		goto ret;
	}

	//	Check to see if there is a scriptmap that applies.  If so, then
	//	we had better have MD_ACCESS_SOURCE rights to do a move or a copy.
	//
	if (fCheckScriptmaps && FInScriptMap(pwszUrl,
										 dwAccessActual,
										 &fCGI))
	{
		if (0 == (MD_ACCESS_SOURCE & dwAccessActual))
		{
			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}
	}

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\scrptmps.cpp ===
/*
 *	S C R P T M P S . C P P
 *
 *	Scriptmaps cacheing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "scrptmps.h"
#include "instdata.h"

//	========================================================================
//	class CScriptMap
//
//	Contains the parsed set of scriptmaps for a single metabase entry.
//	Contains lookup functions to find scriptmaps that match certain
//	conditions.
//
class CScriptMap :
	public IScriptMap,
	public CMTRefCounted
{

	typedef struct _inclusions {

		DWORD	fdwInclusions;
		LPCWSTR	pwszMethods;

		BOOL FAllMethodsIncluded ()
		{
			//	When a script map has an empty inclusion verb list, it means all verbs included
			//	(NOT all verbs excluded).
			//
			Assert (pwszMethods);
			return L'\0' == pwszMethods[0];
		}

	} INCLUSIONS, * PINCLUSIONS;

	typedef CCache<CRCWszi, PINCLUSIONS> CInclusionsCache;

	//	INCLUSIONS data storage area.
	//
	ChainedBuffer<INCLUSIONS>	m_bInclusions;

	//	Cache of scriptmap entries
	//
	CInclusionsCache			m_cache;

	//	Pointer to first 'star' scriptmap in the list.
	//	This is the one that IIS will have called to process
	//	the request for this url.  This is used by the virtual
	//	root cache.
	//
	//	Note that we should ignore any 'star' scriptmaps when
	//	evaluating for matches.  The first 'star' gets a crack
	//	at it, and that's that.
	//
	LPCWSTR						m_pwszStarScriptmap;

	//	Private accessors
	//
	VOID AddMapping (LPCWSTR pwszMap, HDRITER_W* pit);
	BOOL FLoadScriptmaps (LPWSTR pwszScriptMaps);

	//	CLASS CIsMatch --------------------------------------------------------
	//
	//	Functional class to find if a given scriptmap applys to a URI
	//
	class CIsMatch : public CInclusionsCache::IOp
	{
		const CInclusionsCache& m_cache;
		const LPCWSTR m_pwszMethod;
		const METHOD_ID m_midMethod;
		BOOL m_fCGI;
		DWORD m_dwAccess;
		LPCWSTR m_pwszMatch;
		LPCWSTR m_pwszURI;
		SCODE m_sc;

		//	NOT IMPLEMENTED
		//
		CIsMatch& operator=(const CIsMatch&);

	public:

		CIsMatch(const CInclusionsCache& cache,
				 const LPCWSTR pwszMethod,
				 const METHOD_ID midMethod,
				 LPCWSTR pwszUri,
				 LPCWSTR pwszMatch,
				 DWORD dwAcc)

				: m_cache(cache),
				  m_pwszMethod(pwszMethod),
				  m_midMethod(midMethod),
				  m_fCGI(FALSE),
				  m_dwAccess(dwAcc),
				  m_pwszURI(pwszUri),
				  m_pwszMatch(pwszMatch),
				  m_sc(S_OK)
		{}

		SCODE ScMatched() const		{ return m_sc; }
		BOOL FMatchIsCGI() const	{ return m_fCGI; }

		virtual BOOL operator()(const CRCWszi& crcwszi, const PINCLUSIONS& pin);
	};

	//	NOT IMPLEMENTED
	//
	CScriptMap& operator=(const CScriptMap&);
	CScriptMap(const CScriptMap&);

	//	Helper function
	//
public:

	//	CREATORS
	//
	CScriptMap() : m_pwszStarScriptmap(NULL)
	{
		//	Use COM-style ref-counting.  Start with 1.
		//
		m_cRef = 1;
	}

	BOOL FInit (LPWSTR pwszScriptMaps);

	//	Implementation of IRefCounted members
	//	Simply route them to our own CMTRefCounted members.
	//
	void AddRef()
	{
		CMTRefCounted::AddRef();
	}
	void Release()
	{
		CMTRefCounted::Release();
	}

	//	ACCESSORS
	//
	SCODE ScMatched (LPCWSTR pwszMethod,
					 METHOD_ID midMethod,
					 LPCWSTR pwszMap,
					 DWORD dwAccess,
					 BOOL * pfCGI) const;

	//	Used by MOVE/COPY/DELETE to check for star scriptmapping
	//	overrides
	//
	BOOL FSameStarScriptmapping (const IScriptMap * pism) const
	{
		const CScriptMap* prhs = static_cast<const CScriptMap*>(pism);
		if (m_pwszStarScriptmap != prhs->m_pwszStarScriptmap)
		{
			if (m_pwszStarScriptmap && prhs->m_pwszStarScriptmap)
				if (0 == _wcsicmp (m_pwszStarScriptmap, prhs->m_pwszStarScriptmap))
					return TRUE;
		}
		else
			return TRUE;

		return FALSE;
	}
};

CScriptMap::FInit (LPWSTR pwszScriptMaps)
{
	//	Init the cache
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//	Load the scriptmaps
	//
	return FLoadScriptmaps(pwszScriptMaps);
}

void
CScriptMap::AddMapping(LPCWSTR pwszMap, HDRITER_W * pitInclusions)
{
	LPCWSTR pwszInclusion;
	METHOD_ID mid;
	PINCLUSIONS pin = NULL;

	Assert (pwszMap);

	//	If there is a DLL, then we want to assemble an inclusions list
	//
	if (pitInclusions)
	{
		pin = m_bInclusions.Alloc (sizeof(INCLUSIONS));

		//	Record the start of the inclusion list
		//
		pin->pwszMethods = pitInclusions->PszRaw();
		pin->fdwInclusions = 0;

		//	Rip through the list and identify all the known
		//	inclusions
		//
		while ((pwszInclusion = pitInclusions->PszNext()) != NULL)
		{
			mid = MidMethod (pwszInclusion);
			if (mid != MID_UNKNOWN)
				pin->fdwInclusions |= (1 << mid);
		}
	}

	//	At this point, we can add the cache item...
	//
	ScriptMapTrace ("Dav: adding scriptmap for %S -- including %S\n",
					pwszMap,
					(pin && pin->pwszMethods) ? pin->pwszMethods : L"none");

	//	CRC the mapping and stuff it into the cache.
	//	Note that we are safe in using the actual parameter string
	//	here because the CScriptMap object's lifetime is the same
	//	as the lifetime of the metadata on which it operates.  See
	//	\cal\src\_davprs\davmb.cpp for details.
	//
	CRCWszi crcwszi(pwszMap);

	(void) m_cache.FSet (crcwszi, pin);
}

BOOL
CScriptMap::FLoadScriptmaps (LPWSTR pwszScriptMaps)
{
	HDRITER_W it(NULL);

	UINT cchDav = static_cast<UINT>(wcslen(gc_wszSignature));

	Assert (pwszScriptMaps);

	ScriptMapTrace ("Dav: loading scriptmap cache\n");

	//	Add in the default CGI/BGI mappings
	//
	AddMapping (L".EXE", NULL);
	AddMapping (L".CGI", NULL);
	AddMapping (L".COM", NULL);
	AddMapping (L".DLL", NULL);
	AddMapping (L".ISA", NULL);

	//
	//	Parse through the scriptmap list and build up the cache.
	//
	//	Each mapping is a string of the form:
	//
	//		"<ext>|<*>,<path>,<flags>[,<included verb>...]"
	//
	//	Note that if any of the mappings is invalid we fail the whole call.
	//	This is consistent with IIS' behavior.
	//
	UINT cchMapping = 0;
	for ( LPWSTR pwszMapping = pwszScriptMaps;
		  *pwszMapping;
		  pwszMapping += cchMapping )
	{
		enum {
			ISZ_SM_EXT = 0,
			ISZ_SM_PATH,
			ISZ_SM_FLAGS,
			ISZ_SM_INCLUSION_LIST,
			CSZ_SM_FIELDS
		};

		//	Figure out the length of the mapping
		//	including the null terminator
		//
		cchMapping = static_cast<UINT>(wcslen(pwszMapping) + 1);

		//	Special case: star (wildcard) scriptmaps.
		//
		//	These should mostly be ignored.  We will never
		//	forward to a star scriptmap.  If we find a star
		//	scriptmap, the only reason to keep track of it
		//	is so that we can compare it against another
		//	star scriptmap when checking the feasibility
		//	of a trans-vroot MOVE/COPY/DELETE.  And for this
		//	comparsion, we check for EXACT equality between
		//	the scriptmaps by checking the entire scriptmap
		//	string.
		//
		//	See the comments regarding m_pszStarScriptMap
		//	above for more detail.
		//
		if (L'*' == *pwszMapping)
		{
			if (NULL == m_pwszStarScriptmap)
				m_pwszStarScriptmap = pwszMapping;

			continue;
		}

		//	Digest the metadata.
		//
		LPWSTR rgpwsz[CSZ_SM_FIELDS];

		UINT cchUnused;
		if (!FParseMDData (pwszMapping,
						   rgpwsz,
						   CSZ_SM_FIELDS,
						   &cchUnused))
		{
			//	FParseMDData() will return FALSE if there is no verb
			//	exclusion list because it is an optional parameter.
			//	If all the other parameters exist though then it's
			//	really ok.
			//
			if (!(rgpwsz[ISZ_SM_EXT] &&
				  rgpwsz[ISZ_SM_PATH] &&
				  rgpwsz[ISZ_SM_FLAGS]))
			{
				DebugTrace ("CScriptMap::FLoadScriptMaps() - Malformed scriptmaps\n");

				//$NYI	Log a server config error?

				return FALSE;
			}
		}

		//	We belive that all the scriptmaps are
		//	extension based.  But other than that
		//	there is no validation.
		//
		Assert (*rgpwsz[ISZ_SM_EXT] == L'.');

		//	If the path refers to our DAV DLL then skip this mapping.
		//
		//	The way this works is:  If the length of the path is at least
		//	as long as the length of our DLL name AND the final component
		//	of that path is the name of our DLL then skip the mapping.
		//	Eg. "HTTPEXT.DLL" will match the first condition of the if,
		//	"c:\foo\bar\HTTPEXT.DLL" will match the second condition of the if.
		//
		static const UINT cchDll = CchConstString(L".DLL");
		UINT cchPath = static_cast<UINT>(wcslen(rgpwsz[ISZ_SM_PATH]));
		if (cchPath == cchDav + cchDll ||
			((cchPath > cchDav + cchDll) &&
			 *(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll - cchDav - 1) == L'\\'))
		{
			//	Now we know the final piece of the path is the correct length.
			//	Check the data!  If it matches our dll name, skip this mapping.
			//
			if (!_wcsnicmp(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll - cchDav,
						   gc_wszSignature,
						   cchDav) &&

				!_wcsicmp(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll,
						  L".DLL"))
			{
				continue;
			}
		}

		//	Feed the optional inclusion list into a header iterator
		//	that AddMapping() will use to determine what verbs
		//	are included for this mapping.  If there is no inclusion
		//	list then use an empty iterator.
		//
		//	Adding a mapping with an empty iterator (vs. NULL)
		//	allows the scriptmap matching code to distinguish
		//	between a "real" scriptmap with an empty inclusion
		//	list and a default CGI-style scriptmap like those
		//	added at the beginning of this function.
		//
		it.NewHeader(rgpwsz[ISZ_SM_INCLUSION_LIST] ?
					 rgpwsz[ISZ_SM_INCLUSION_LIST] :
					 gc_wszEmpty);

		//	Add the extension-based mapping
		//
		AddMapping (rgpwsz[ISZ_SM_EXT], &it);
	}

	return TRUE;
}

SCODE
CScriptMap::ScMatched (
	LPCWSTR pwszMethod,
	METHOD_ID midMethod,
	LPCWSTR pwszURI,
	DWORD dwAccess,
	BOOL * pfCGI) const
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	Assert(pwszURI);

	//
	//	Scan down the URI, looking for extensions.  When one is found
	//	zip through the list of mappings.  While this may not seem the
	//	most optimal, it really is.  If we simply scaned the URI for
	//	each mapping.  We would be scaning the URI multiple times.  In
	//	this model, we scan the URI once.
	//
	if ((pwsz = wcsrchr(pwszURI, L'.')) != NULL)
	{
		//	We have an extension so take a look
		//
		CIsMatch cim(m_cache, pwszMethod, midMethod, pwszURI, pwsz, dwAccess);

		m_cache.ForEach(cim);

		sc = cim.ScMatched();

		if (pfCGI && (sc != S_OK))
			*pfCGI = cim.FMatchIsCGI();
	}

	return sc;
}

//	CLASS CIsMatch ------------------------------------------------------------
//
//$REVIEW: Does this code work for DBCS/UTF-8 map names?  These are filenames....
//$REVIEW: This function does not currently check the METHOD EXCLUSION LIST.
//$REVIEW: This might cause us to report a match when actually there are NO matches.
//
BOOL
CScriptMap::CIsMatch::operator()(const CRCWszi& crcwszi, const PINCLUSIONS& pin)
{
	Assert (crcwszi.m_pwsz);

	//	Every scriptmap in the cache should be an extension-based mapping.
	//	Compare the extension vs. the part of the URI that we're looking at.
	//	If they match then we have a scriptmap.
	//
	Assert (L'.' == *crcwszi.m_pwsz);

	UINT cch = static_cast<UINT>(wcslen (crcwszi.m_pwsz));

	if (!_wcsnicmp (crcwszi.m_pwsz, m_pwszMatch, cch) &&
		((m_pwszMatch[cch] == '\0')
		 || !wcscmp (m_pwszMatch+cch, L"/")
		 || !wcscmp (m_pwszMatch+cch, L"\\")))
	{
		//	Looks like we have a match
		//
		ScriptMapTrace ("Dav: %S matched scriptmap %S\n", m_pwszURI, crcwszi.m_pwsz);

		//	However, we only allow execution of CGI type child
		//	ISAPI's if EXECUTE priviledge is enabled
		//
		if ((pin != NULL) || (m_dwAccess & MD_ACCESS_EXECUTE))
			m_sc = W_DAV_SCRIPTMAP_MATCH_FOUND;

		m_fCGI = !pin;
	}

	//	See if it is included
	//	Note that, if all methods are included, no need to do further checking
	//
	if ((m_sc != S_OK) && pin && !pin->FAllMethodsIncluded())
	{
		ScriptMapTrace ("Dav: checking '%S' against scriptmap inclusions: %S\n",
						m_pwszMethod,
						pin->pwszMethods);

		//	In the unknown method scenario, we just need
		//	to iterate the set of methods that are included
		//	and check it against the request method
		//
		if (m_midMethod == MID_UNKNOWN)
		{
			BOOL fIncluded = FALSE;
			HDRITER_W it(pin->pwszMethods);
			LPCWSTR pwsz;

			while ((pwsz = it.PszNext()) != NULL)
			{
				fIncluded = !wcscmp (pwsz, m_pwszMethod);
				if (fIncluded)
					break;
			}

			if (!fIncluded)
			{
				ScriptMapTrace ("Dav: unknown '%S' excluded from scriptmap\n",
								m_pwszMethod);

				m_sc = W_DAV_SCRIPTMAP_MATCH_EXCLUDED;
			}
		}
		//
		//	Otherwise, the inclusions flags have the MID'th bit
		//	set if it is excluded.
		//
		else if (!(pin->fdwInclusions & (1 << m_midMethod)))
		{
			ScriptMapTrace ("Dav: '%S' excluded from scriptmap\n",
						m_pwszMethod);

			m_sc = W_DAV_SCRIPTMAP_MATCH_EXCLUDED;
		}
	}

	return (m_sc == S_OK);
}

IScriptMap *
NewScriptMap( LPWSTR pwszScriptMaps )
{
	auto_ref_ptr<CScriptMap> pScriptMap;

	pScriptMap.take_ownership (new CScriptMap());

	if (pScriptMap->FInit(pwszScriptMaps))
		return pScriptMap.relinquish();

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\traces.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <exo.h>

void InitDavprsTraces()
{
	INIT_TRACE(Actv);
	INIT_TRACE(BodyStream);
	INIT_TRACE(Content);
	INIT_TRACE(Ecb);
	INIT_TRACE(ECBLogging);
	INIT_TRACE(EcbStream);
	INIT_TRACE(Event);
	INIT_TRACE(Lock);
	INIT_TRACE(Method);
	INIT_TRACE(Persist);
	INIT_TRACE(Request);
	INIT_TRACE(Response);
	INIT_TRACE(ScriptMap);
	INIT_TRACE(Transmit);
	INIT_TRACE(Url);
	INIT_TRACE(DavprsDbgHeaders);
	INIT_TRACE(Metabase);

	//	Also init the EXO trace flag.
#ifdef	DBG
	g_fExoDebugTraceOn = GetPrivateProfileInt(gc_szDbgTraces, "ExoDebugTraceOn",
											  FALSE, gc_szDbgIni);
#else	// DBG
#endif	// DBG, else
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\security.cpp ===
/*
 *	S E C U R I T Y . C P P
 *
 *	Url security checks.  While these would seem to only apply to HttpEXT,
 *	all impls. that care about ASP execution should really think about this.
 *
 *	Bits stolen from the IIS5 project 'iis5\infocom\cache2\filemisc.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"

//	This function takes a suspected NT/Win95 short filename and checks
//	if there's an equivalent long filename.
//
//		For example, c:\foobar\ABCDEF~1.ABC is the same as
//		c:\foobar\abcdefghijklmnop.abc.
//
//	If there is an equivalent, we need to FAIL this path, because our metabase
//	will NOT have the correct values listed under the short paths!
//	If there is no equivalent, this path can be allowed through, because it
//	might be a real storage entitiy (not an alias for a real storage entity).
//
//	NOTE: This function should be called unimpersonated - the FindFirstFile()
//	must be called in the system context since most systems have traverse
//	checking turned off - except for the UNC case where we must be impersonated
//	to get network access.
//
SCODE __fastcall
ScCheckIfShortFileName (
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ const HANDLE hitUser)
{
    WIN32_FIND_DATAW fd;
    LPCWSTR pwsz;
    BOOL fUNC = FALSE;

	//	Skip forward to find the first '~'
	//
	if (NULL == (pwsz = wcschr(pwszPath, L'~')))
		return S_OK;

	//$	REVIEW: this is not sufficient for DavEX, but it is unclear that
	//	this function applies there.  Certainly the FindFirstFile() call
	//	will fail at this time.
	//
    fUNC = (*pwszPath == L'\\');
	Assert (!fUNC || (NULL != hitUser));

    //	We actually need to loop in case multiple '~' appear in the filename
    //
	do
    {
		//	At this point, pwsz should be pointing to the '~'
		//
		Assert (L'~' == *pwsz);

		//	Is the next char a digit?
		//
		pwsz++;
        if ((*pwsz >= L'0') && (*pwsz <= L'9'))
        {
            WCHAR wszTmp[MAX_PATH];
            const WCHAR * pwchEndSeg;
            const WCHAR * pwchBeginSeg;
            HANDLE hFind;

            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirstFile with that path
            //
            pwchEndSeg = wcschr (pwsz, L'\\');
            if (!pwchEndSeg)
            {
                pwchEndSeg = pwsz + wcslen (pwsz);
            }

            //  If the string is beyond MAX_PATH then we allow
			//	it through (returning S_OK).
			//
			//	Also check that our buffer is big enough to handle anything
			//	that gets through this check.
			//
			//	NOTE: We are assuming that other code outside this function
			//	will catch paths that are larger than MAX_PATH and FAIL them.
			//
			//$	REVIEW: the MAX_PATH restriction is very important because
			//	the call to FindFirstFile() will fail if the path is larger
			//	than MAX_PATH.  Should we ever decide to support larger paths
			//	in HttpEXT, this code will have to change.
            //
			Assert (MAX_PATH == CElems(wszTmp));
            if ((pwchEndSeg - pwszPath) >= MAX_PATH)
				return S_OK;

			//	Make a copy of the string up to this point in the path
			//
			wcsncpy (wszTmp, pwszPath, pwchEndSeg - pwszPath);
			wszTmp[pwchEndSeg - pwszPath] = 0;

			//	If we are not accessing a unc, then we need to revert
			//	for our call to FindFirstFile() -- see comment above.
			//
			if (!fUNC)
			{
				safe_revert (const_cast<HANDLE>(hitUser));
				hFind = FindFirstFileW (wszTmp, &fd);
			}
			else
				hFind = FindFirstFileW (wszTmp, &fd);

            if (hFind == INVALID_HANDLE_VALUE)
            {
                //  If the FindFirstFile() fails to find the file then
				//	the filename cannot be a short name.
                //
				DWORD dw = GetLastError();
                if ((ERROR_FILE_NOT_FOUND != dw) && (ERROR_PATH_NOT_FOUND != dw))
					return HRESULT_FROM_WIN32(dw);

				return S_OK;
            }

			//	Make sure the find context gets closed.
			//
            FindClose (hFind);

            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //
			pwchBeginSeg = wcsrchr (wszTmp, '\\');
			Assert (pwchBeginSeg);
			pwchBeginSeg++;

            //  If the last segment doesn't match the long name then
			//	this is the short name version (alias) of the path -- so
			//	fail this function.
			//
            if (_wcsicmp (fd.cFileName, pwchBeginSeg))
			{
				DebugTrace ("Dav: Url: refers to shortname for file\n");
				Assert (!_wcsicmp (fd.cAlternateFileName, pwchBeginSeg));
				return E_DAV_SHORT_FILENAME;
			}
        }

    } while (NULL != (pwsz = wcschr (pwsz, L'~')));

    return S_OK;
}

SCODE __fastcall
ScCheckForAltFileStream (
	/* [in] */ LPCWSTR pwszPath)
{
    //	Avoid the infamous ::$DATA bug
	//
    if (wcsstr (pwszPath, L"::"))
		return E_DAV_ALT_FILESTREAM;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\response.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RESPONSE.CPP
//
//		HTTP 1.1/DAV 1.0 response handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <new.h>
#include "ecb.h"
#include "header.h"
#include "body.h"
#include "instdata.h"
#include "custerr.h"


enum
{
	//
	//	Protocol overhead for a chunk prefix, which is:
	//
	//	chunk-size - formatted as 1*HEX
	//	CRLF
	//
	CB_CHUNK_PREFIX = 2 * sizeof(ULONG) + 2,

	//
	//	Protocol overhead for a chunk suffix, which is:
	//
	//	CRLF - at the end of chunk-data
	//	0    - if this is the last chunk
	//	CRLF - again, if this is the last chunk
	//	CRLF - terminate the chunked-body (no trailers)
	//
	CB_CHUNK_SUFFIX = 7,

	//
	//	Maximum amount of data (in bytes) per packet.
	//	We SHOULD limit ourselves to a reasonable maximum amount
	//	to get good chunking performance.  At one time, we had to
	//	ourselves to 8K at most because the socket transport layer
	//	did not accept more than this amount for sending.
	//	WriteClient() and SSF::HSE_REQ_TRANSMIT_FILE failed when
	//	more than this amount is submitted.
	//
	//	However, as of 06/03/1999, bumping this amount to 64K seems
	//	to work just fine.
	//
	CB_PACKET_MAX = 64 * 1024, // 64K

	//
	//	So the amount of data that we can put in a chunk then is just
	//	the max packet size minus the chunked encoding protocol overhead
	//	minus one byte because packets containing headers must be
	//	null-terminated (IIS doesn't use the byte counts we pass in).
	//
	CB_WSABUFS_MAX = CB_PACKET_MAX - CB_CHUNK_PREFIX - CB_CHUNK_SUFFIX - 1
};

//
//	Utility to check if the HTTP response code is one of the
//	"real" error response codes. Inlined here so that we use
//	it consistantly. Particularly, this is used to check if
//	we want to do custom error processing.
//
static BOOL inline FErrorStatusCode ( int nCode )
{
	return ( ( nCode >= 400 ) && ( nCode <= 599 ) );
}

//	========================================================================
//
//	CLASS CWSABufs
//
class CWSABufs
{
	//
	//	Having a small number of buffers in a fixed size array means
	//	that we can delay, if not avoid altogether, dynamic allocation.
	//	The number of buffers is somewhat arbitrary, but should be large
	//	enough to handle the common cases.  For example, DAVOWS GET
	//	typically uses two buffers: one for the headers, one for the body.
	//	Another example: error responses can use up to eight buffers (one
	//	per text body part added via AddText() by
	//	CResponse::FinalizeContent()).
	//
	enum
	{
		C_WSABUFS_FIXED = 8
	};

	WSABUF m_rgWSABufsFixed[C_WSABUFS_FIXED];

	//
	//	Dynamically sized array of WSABUFs for when we need more buffers
	//	than we can hold in the fixed array.
	//
	auto_heap_ptr<WSABUF> m_pargWSABufs;

	//
	//	Pointer to which of the two WSABUF arrays above we use.
	//
	WSABUF * m_pWSABufs;

	//
	//	Count of WSABUFs allocated/used
	//
	UINT m_cWSABufsAllocated;
	UINT m_cWSABufsUsed;

	//
	//	Total size of the data in all WSABUFS used
	//
	UINT m_cbWSABufs;

	//	NOT IMPLEMENTED
	//
	CWSABufs( const CWSABufs& );
	CWSABufs& operator=( const CWSABufs& );

public:
	//	CREATORS
	//
	CWSABufs();

	//	MANIPULATORS
	//
	UINT CbAddItem( const BYTE * pbItem, UINT cbItem );

	VOID Clear()
	{
		m_cWSABufsUsed = 0;
		m_cbWSABufs = 0;
	}

	//	ACCESSORS
	//
	UINT CbSize() const
	{
		return m_cbWSABufs;
	}

	VOID DumpTo( LPBYTE lpbBuf,
				 UINT   ibFrom,
			     UINT   cbToDump ) const;
};

//	------------------------------------------------------------------------
//
//	CWSABufs::CWSABufs()
//
CWSABufs::CWSABufs() :
   m_pWSABufs(m_rgWSABufsFixed),
   m_cWSABufsAllocated(C_WSABUFS_FIXED),
   m_cWSABufsUsed(0),
   m_cbWSABufs(0)
{
}

//	------------------------------------------------------------------------
//
//	CWSABufs::CbAddItem()
//
UINT
CWSABufs::CbAddItem( const BYTE * pbItem, UINT cbItem )
{
	//
	//	We can only hold up to CB_WSABUFS_MAX bytes.  Any more than
	//	that would exceed the capacity of the socket transport layer's
	//	buffer at transmit time.
	//
	Assert( m_cbWSABufs <= CB_WSABUFS_MAX );

	//
	//	Limit what we add so that the total does not exceed CB_WSABUFS_MAX.
	//
	cbItem = min( cbItem, CB_WSABUFS_MAX - m_cbWSABufs );

	//
	//	Resize the WSABUF array if necessary.
	//
	if ( m_cWSABufsUsed == m_cWSABufsAllocated )
	{
		m_cWSABufsAllocated *= 2;

		if ( m_pWSABufs == m_rgWSABufsFixed )
		{
			m_pargWSABufs =
				reinterpret_cast<WSABUF *>(
					g_heap.Alloc( sizeof(WSABUF) *
								  m_cWSABufsAllocated ));

			CopyMemory( m_pargWSABufs,
						m_rgWSABufsFixed,
						sizeof(WSABUF) * m_cWSABufsUsed );
		}
		else
		{
			m_pargWSABufs.realloc( sizeof(WSABUF) * m_cWSABufsAllocated );
		}

		m_pWSABufs = m_pargWSABufs;
	}

	//
	//	Add the new data to the end of the array
	//
	m_pWSABufs[m_cWSABufsUsed].len = cbItem;
	m_pWSABufs[m_cWSABufsUsed].buf = const_cast<LPSTR>(
										reinterpret_cast<LPCSTR>(pbItem));
	++m_cWSABufsUsed;

	//
	//	Update the total byte count
	//
	m_cbWSABufs += cbItem;

	return cbItem;
}

//	------------------------------------------------------------------------
//
//	CWSABufs::DumpTo()
//
//	Dumps cbToDump bytes of data from the WSA buffers starting at ibFrom
//	into a block of contiguous memory starting at lpbBuf.
//
VOID
CWSABufs::DumpTo( LPBYTE lpbBuf,
				  UINT   ibFrom,
				  UINT   cbToDump ) const
{
	UINT iWSABuf;


	Assert( !IsBadWritePtr(lpbBuf, m_cbWSABufs + 1) );

	//
	//	Skip WSA buffers up to the first one from which we will copy.
	//
	for ( iWSABuf = 0;
		  iWSABuf < m_cWSABufsUsed && m_pWSABufs[iWSABuf].len <= ibFrom;
		  iWSABuf++ )
	{
		ibFrom -= m_pWSABufs[iWSABuf].len;
		++iWSABuf;
	}

	//
	//	Copy data from this and subsequent buffers up to the lesser
	//	of the number of bytes requested or the number of bytes
	//	remaining in the WSA buffers.
	//
	for ( ;
		  iWSABuf < m_cWSABufsUsed && cbToDump > 0;
		  iWSABuf++ )
	{
		UINT cbToCopy = min(m_pWSABufs[iWSABuf].len - ibFrom, cbToDump);

		memcpy( lpbBuf,
				m_pWSABufs[iWSABuf].buf + ibFrom,
				cbToCopy );

		cbToDump -= cbToCopy;
		lpbBuf   += cbToCopy;

		ibFrom = 0;
	}
}



//	========================================================================
//
//	CLASS CResponse
//
//		The response consists of a header and a body.
//
class CResponse : public IResponse
{
	//	Our reference to the ECB.  This must a refcounted reference because
	//	the lifetime of the response object is indefinite.
	//
	auto_ref_ptr<IEcb> m_pecb;

	//
	//	Response status (not to be confused with HTTP status below)
	//
	enum RESPONSE_STATUS
	{
		RS_UNSENT = 0,
		RS_DEFERRED,
		RS_FORWARDED,
		RS_REDIRECTED,
		RS_SENDING
	};

	RESPONSE_STATUS	m_rs;

	//
	//	The variable that will hold one of 2 values:
	//		0 - we never started the responce through
	//			the transmitter, it was never created
	//		1 - we already attempted to initiate the
	//			responce, so no new initiations should
	//			be allowed
	//
	LONG			m_lRespStarted;

	//
	//	HTTP status code (e.g. 501)
	//
	int				m_iStatusCode;

	//
	//	IIS-defined suberror used in custom error processing
	//	to generate the most specific response body possible
	//	for a given status code.
	//
	UINT			m_uiSubError;

	//
	//	Full status line (e.g. "HTTP/1.1 404 Resource Not Found")
	//	generated whenever the status code is set.
	//
	auto_heap_ptr<CHAR>	m_lpszStatusLine;

	//
	//	Body detail for error response body.
	//
	auto_heap_ptr<CHAR> m_lpszBodyDetail;

	//
	//	Response header cache
	//
	CHeaderCacheForResponse	m_hcHeaders;

	//	Response body
	//
	auto_ptr<IBody>	 m_pBody;
	BOOL			 m_fSupressBody;

	//
	//	The response transmitter.  Make this class a friend for
	//	easy access to private data (ecb, headers, body parts, etc.)
	//
	friend class CTransmitter;
	CTransmitter *	m_pTransmitter;

	//
	//	Private helpers
	//
	VOID FinalizeContent( BOOL fResponseComplete );
	VOID SetStatusLine(	int iStatusCode );

	//
	//	NOT IMPLEMENTED
	//
	CResponse( const CResponse& );
	CResponse& operator=( const CResponse& );

public:
	//	CREATORS
	//
	CResponse( IEcb& ecb );

	//	ACCESSORS
	//
	IEcb * GetEcb() const;
	BOOL FIsEmpty() const;
	BOOL FIsUnsent() const;

	DWORD DwStatusCode() const;
	DWORD DwSubError() const;
	LPCSTR LpszStatusDescription() const;
	LPCSTR LpszStatusCode() const;

	LPCSTR LpszGetHeader( LPCSTR pszName ) const;

	//	MANIPULATORS
	//
	VOID SetStatus( int    iStatusCode,
					LPCSTR lpszReserved,
					UINT   uiCustomSubError,
					LPCSTR lpszBodyDetail,
					UINT   uiBodyDetail );

	VOID ClearHeaders() { m_hcHeaders.ClearHeaders(); }
	VOID SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple = FALSE );
	VOID SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple = FALSE );

	VOID ClearBody() { m_pBody->Clear(); }
	VOID SupressBody() { m_fSupressBody = TRUE; }
	VOID AddBodyText( UINT cbText, LPCSTR pszText );
	VOID AddBodyText( UINT cchText, LPCWSTR pwszText );
	VOID AddBodyFile( const auto_ref_handle& hf,
					  UINT64 ibFile64,
					  UINT64 cbFile64 );
	VOID AddBodyStream( IStream& stm );
	VOID AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize );
	VOID AddBodyPart( IBodyPart * pBodyPart );

	//
	//	Various sending mechanisms
	//
	SCODE ScForward( LPCWSTR pwszURI,
					 BOOL   fKeepQueryString = TRUE,
					 BOOL   fCustomErrorUrl = FALSE);
	SCODE ScRedirect( LPCSTR pszURI );
	VOID Defer() { m_rs = RS_DEFERRED; }

	VOID SendPartial();
	VOID SendComplete();
	VOID SendStart( BOOL fComplete );
	VOID FinishMethod();

};

//	========================================================================
//
//	CLASS CTransmitter
//
class CTransmitter :
	public CMTRefCounted,
	private IBodyPartVisitor,
	private IAsyncCopyToObserver,
	private IAcceptObserver,
	private IAsyncStream,
	private IIISAsyncIOCompleteObserver
{
	//
	//	Back-reference to our response object.  This is an
	//	auto_ref because, once created, the transmitter owns
	//	the response.
	//
	auto_ref_ptr<CResponse> m_pResponse;

	//
	//	Transfer coding method
	//
	TRANSFER_CODINGS m_tc;

	//
	//	Error information
	//
	HRESULT	m_hr;

	//
	//	Iterator used to traverse the body
	//
	IBody::iterator * m_pitBody;

	//
	//	Async driving mechanism
	//
	CAsyncDriver<CTransmitter> m_driver;
	friend class CAsyncDriver<CTransmitter>;

	//
	//	Buffers for headers and text body parts
	//
	StringBuffer<CHAR>			m_bufHeaders;
	ChainedStringBuffer<CHAR>	m_bufBody;

	//
	//	Accept observer passed to VisitStream().  This observer must
	//	be stashed in a member variable because reading from the stream
	//	is asynchronous and we need to be able to notify the observer
	//	when the read completes.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	WSA buffers for text data
	//
	CWSABufs	m_wsabufsPrefix;
	CWSABufs	m_wsabufsSuffix;
	CWSABufs *	m_pwsabufs;

	//
	//	TransmitFile info for file data
	//
	auto_ref_handle m_hf;
	HSE_TF_INFO	m_tfi;

	//
	//	Fixed-size buffers to hold prefix and suffix text packets
	//	being transmitted until async I/O completes.
	//
	BYTE	m_rgbPrefix[CB_PACKET_MAX];
	BYTE	m_rgbSuffix[CB_PACKET_MAX];

	//
	//	Amount of header data left to accept
	//
	UINT	m_cbHeadersToAccept;

	//
	//	Amount of header data left to send.
	//
	UINT	m_cbHeadersToSend;

	//	------------------------------------------------------------------------
	//
	//	FSendingIISHeaders()
	//
	//	Returns TRUE if we want to have IIS format and send a status
	//	line along with any custom headers of its own.
	//
	BOOL FSendingIISHeaders() const
	{
		//
		//	If we have headers to send and we haven't sent any
		//	of them yet then we want to include custom IIS
		//	headers as well.
		//
		return m_cbHeadersToSend &&
			   (m_cbHeadersToSend == m_bufHeaders.CbSize());
	}

	//
	//	Flag which is TRUE when the impl has submitted the last
	//	part of the response for transmitting.  It can be FALSE
	//	only with chunked responses.
	//
	BOOL	m_fImplDone;

	//
	//	Transmitter status.  The transmitter status is always one
	//	of the following:
	//
	enum
	{
		//
		//	STATUS_IDLE
		//		The transmitter is idle.  That is, it is not executing
		//		any of the state functions below.
		//
		STATUS_IDLE,

		//
		//	STATUS_RUNNING_ACCEPT_PENDING
		//		The transmitter is running.  The impl has added new
		//		response data (via ImplStart()) to be accepted while
		//		the transmitter is working on existing data on another
		//		thread.
		//
		STATUS_RUNNING_ACCEPT_PENDING,

		//
		//	STATUS_RUNNING_ACCEPTING
		//		The transmitter is running and accepting existing
		//		response data.
		//
		STATUS_RUNNING_ACCEPTING,

		//
		//	STATUS_RUNNING_ACCEPT_DONE
		//		The transmitter is running and has finished accepting
		//		all existing response data.  If the transmitter is
		//		working on a chunked response then it will go idle
		//		from here until the impl indicates that it has added
		//		more data via ImplStart().
		//
		STATUS_RUNNING_ACCEPT_DONE
	};

	LONG	m_lStatus;

	//
	//	Function which returns TRUE if the entire response has
	//	been accepted, FALSE otherwise.
	//
	BOOL FAcceptedCompleteResponse() const
	{
		//
		//	We have accepted the last chunk of the response when
		//	the impl is done adding chunks to the response and we've
		//	accepted the last chunk added.
		//
		//	!!! IMPORTANT !!!
		//	The order of comparison here (m_lStatus then m_fImplDone)
		//	is important.  Checking the other way around could result
		//	in a false positive if another thread were in ImplStart()
		//	right after setting m_fImplDone to TRUE.
		//
		return (STATUS_RUNNING_ACCEPT_DONE == m_lStatus) && m_fImplDone;
	}

	//
	//	IAcceptObserver
	//
	VOID AcceptComplete( UINT64 );

	//
	//	Transmitter state functions.  When running, the transmitter is
	//	always executing one of the following state functions:
	//
	//	SAccept
	//		The accepting state.  When in this state the transmitter
	//		accepts resposne data in preparation for transmitting it.
	//		The impl can add data to the response body while the transmitter
	//		is accepting it -- the mechanism is thread-safe.  In fact the
	//		best performance is realized when the transmitter accepts and
	//		transmits data at the same rate that the impl adds it.
	//		When the transmitter accepts a sufficient amount data
	//		(determined by the amount and type of data accepted)
	//		it enters the transmitting state.
	//
	//	STransmit
	//		The transmitting state.  The transmitter is transmitting
	//		accepted response data via the selected method (m_pfnTransmitMethod).
	//		The impl can add data to the response body while the transmitter
	//		is in this state.  When transmission completes (the transmit methods
	//		are asynchronous) the transmitter enters the cleanup state.
	//
	//	SCleanup
	//		The cleanup state.  Cleans up transmitted data.  From here the
	//		transmitter enters the accepting state if there is more data to
	//		transmit or the idle state if there isn't and the impl hasn't
	//		finished adding data yet.
	//
	typedef VOID (CTransmitter::*PFNSTATE)();
	VOID SAccept();
	VOID STransmit();
	VOID SCleanup();
	PFNSTATE m_pfnState;

	//
	//	Transmit methods.  When the transmitter enters the transmit state,
	//	it will transmit accepted data via the selected transmit method.
	//
	typedef VOID (CTransmitter::*PFNTRANSMIT)();
	VOID TransmitNothing();
	VOID AsyncTransmitFile();
	VOID AsyncTransmitText();
	VOID SyncTransmitHeaders();
	PFNTRANSMIT m_pfnTransmitMethod;

	//
	//	CAsyncDriver
	//
	VOID Run();
	VOID Start()
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Start()\n", GetCurrentThreadId(), this );
		m_driver.Start(*this);
	}

	//
	//	IAsyncStream
	//
	VOID AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );

	//
	//	IAsyncCopyToObserver
	//
	VOID CopyToComplete( UINT cbCopied, HRESULT hr );

	//
	//	IIISAsyncIOCompleteObserver
	//
	VOID IISIOComplete( DWORD dwcbSent,
						DWORD dwLastError );

	//	NOT IMPLEMENTED
	//
	CTransmitter( const CTransmitter& );
	CTransmitter& operator=( const CTransmitter& );

public:
	//	CREATORS
	//
	CTransmitter( CResponse& response );
	~CTransmitter() { TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Transmitter destroyed\n", GetCurrentThreadId(), this ); }

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT         cbToSend,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64   ibOffset64,
					UINT64   cbToSend64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToSend,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	VOID ImplStart( BOOL fResponseComplete );
};



//	========================================================================
//
//	CLASS IResponse
//

//	------------------------------------------------------------------------
//
//	IResponse::~IResponse()
//
IResponse::~IResponse()
{
}



//	========================================================================
//
//	CLASS CResponse
//

//	------------------------------------------------------------------------
//
//	CResponse::CResponse()
//
CResponse::CResponse( IEcb& ecb ) :
   m_pecb(&ecb),
   m_pBody(NewBody()),
   m_pTransmitter(NULL),
   m_rs(RS_UNSENT),
   m_iStatusCode(0),
   m_uiSubError(CSE_NONE),
   m_fSupressBody(FALSE),
   m_lRespStarted(0)
{
}

//	------------------------------------------------------------------------
//
//	CResponse::GetEcb()
//
//		Returns the pointer to the ECB. We are holding a ref on it
//	so make sure that returned pointer is used no longer than this
//	response object.
//
IEcb *
CResponse::GetEcb() const
{
	//
	//	Return the raw pointer
	//
	return m_pecb.get();
}

//	------------------------------------------------------------------------
//
//	CResponse::FIsEmpty()
//
//		Returns TRUE if the response is empty, FALSE otherwise.
//
BOOL
CResponse::FIsEmpty() const
{
	//
	//	The response is empty IFF no status code has been set
	//
	return m_iStatusCode == 0;
}


//	------------------------------------------------------------------------
//
//	CResponse::FIsUnsent()
//
//		Returns TRUE if the response is unsent (not deferred,
//		forwarded or redirected), FALSE otherwise.
//
BOOL
CResponse::FIsUnsent() const
{
	return m_rs == RS_UNSENT;
}


//	------------------------------------------------------------------------
//
//	CResponse::DwStatusCode()
//
DWORD
CResponse::DwStatusCode() const
{
	return m_iStatusCode;
}

//	------------------------------------------------------------------------
//
//	CResponse::DwSubError()
//
DWORD
CResponse::DwSubError() const
{
	return m_uiSubError;
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszStatusDescription()
//
LPCSTR
CResponse::LpszStatusDescription() const
{
	//
	//	Getting just the status description is a little tricky since
	//	we only keep around the full status line (to avoid having to
	//	compute it more than once).  Given that the format of the
	//	status line is ALWAYS "HTTP-version Status-Code Description"
	//	we know that the status line always appears immediately after
	//	the HTTP version and status code.
	//
	return m_lpszStatusLine +
			strlen( m_pecb->LpszVersion() ) +	//	description
			1 +							//  " "
			3 +							//  3-digit status code (e.g. "404")
			1;							//  " "

	//
	//	Ok, so it's not that tricky...
	//
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszStatusCode()
//
LPCSTR
CResponse::LpszStatusCode() const
{
	Assert( m_lpszStatusLine != NULL );

	return m_lpszStatusLine +
		   strlen(m_pecb->LpszVersion()) +
		   1; // (e.g. "HTTP/1.1 200 OK" -> "200 OK")
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszGetHeader()
//
LPCSTR
CResponse::LpszGetHeader( LPCSTR pszName ) const
{
	return m_hcHeaders.LpszGetHeader( pszName );
}

//	------------------------------------------------------------------------
//
//	CResponse::SetStatus()
//
//		Sets the status line portion of the response, superceding any
//		previously set status line.
//
//	Parameters:
//		iStatusCode [in]
//			A standard HTTP/DAV response status code (e.g. 404)
//
//		lpszReserved [in]
//			Reserved.  Must be NULL.
//
//		uiCustomSubError [in]
//			Custom error Sub Error (CSE).  If the status code is in the
//			error range ([400,599]) and this value is anything except
//			CSE_NONE then this value specifies the suberror used to
//			generate a more specific custom error response body than
//			the default for a given status code.
//
//		lpszBodyDetail [in]
//			Optional string to use as detail in an error response body.
//			If NULL, use uiBodyDetail instead.  If that is also 0,
//			an error response body just consists of an HTML
//			version of the status line.
//
//		uiBodyDetail [in]
//			Optional resource id to use as detail in an error response body.
//			If 0, an error response body just consists of an HTML
//			version of the status line.
//
VOID
CResponse::SetStatus( int	 iStatusCode,
					  LPCSTR lpszReserved,
					  UINT   uiCustomSubError,
					  LPCSTR lpszBodyDetail,
					  UINT   uiBodyDetail )
{
	CHAR rgchStatusDescription[256];

	//	We must not change the response status once the response has
	//	started sending. Sometimes it's hard for client to keep track
	//	response has started sending. Now that the response object
	//	has the information, we can simply ignore the set status request
	//	when the response has started sending
	//
	//	was Assert( RS_SENDING != m_rs );
	//
	if (RS_SENDING == m_rs)
		return;

	//	If we are setting the same status code again,
	//	do nothing!
	//
	if ( m_iStatusCode == iStatusCode )
		return;

	//	Quick check -- the iStatusCode must be in the valid HSC range:
	//	100 - 599.
	//	Assert this here to catch any callers who forget to map their
	//	SCODEs/HRESULTs to HSCs first (HscFromHresult).
	//
	Assert (100 <= iStatusCode &&
			599 >= iStatusCode);

	//	When a 304 response is to be generated, the request becomes
	//	very much like a HEAD request in that the whole response is
	//	processed, but not transmitted.  The important part here is
	//	that you do not want to overwrite the 304 response with any
	//	other code other than error responses.
	//
	if ( m_iStatusCode == 304 ) // HSC_NOT_MODIFIED
	{
		//	304's should really be restricted to GET/HEAD
		//
		AssertSz ((!strcmp (m_pecb->LpszMethod(), "GET") ||
				   !strcmp (m_pecb->LpszMethod(), "HEAD") ||
				   !strcmp (m_pecb->LpszMethod(), "PROPFIND")),
				  "304 returned on non-GET/HEAD request");

		if ( iStatusCode < 300 )
			return;

		DebugTrace ("non-success response over-rides 304 response\n");
	}

	//
	//	Remember the status code for our own use ...
	//
	m_iStatusCode = iStatusCode;

	//
	//	... and stash it away in the ECB as well.
	//	IIS uses it for logging.
	//
	m_pecb->SetStatusCode( iStatusCode );

	//
	//	Remember the suberror for custom error processing
	//
	m_uiSubError = uiCustomSubError;

	//
	//	IF we are setting a NEW status code (we are),
	//	AND it's an error status code,
	//	clear out the body.
	//
	if ( FErrorStatusCode(m_iStatusCode) )
	{
		m_pBody->Clear();
	}

	SetStatusLine( iStatusCode );

	//
	//	Save the error body detail (if any).  We'll use it in
	//	CResponse::FinalizeContent() later to build the error response
	//	body if the final result is an error.
	//
	m_lpszBodyDetail.clear();

	//
	//	Figure out what to use for the body detail string:
	//
	//		Use the string if one is provided.  If no string
	//		is provided, use the resource ID.  If no resource ID,
	//		then don't bother setting any body detail!
	//
	if ( !lpszBodyDetail && uiBodyDetail )
	{
		//
		//	Load up the body detail string
		//
		LpszLoadString( uiBodyDetail,
						m_pecb->LcidAccepted(),
						rgchStatusDescription,
						sizeof(rgchStatusDescription) );

		lpszBodyDetail = rgchStatusDescription;
	}

	//	Save off the body detail string.
	//
	if ( lpszBodyDetail )
	{
		m_lpszBodyDetail = LpszAutoDupSz( lpszBodyDetail );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SetHeader()
//
//		Sets the specified header to the specified value
//
//		If lpszValue is NULL, deletes the header
//
VOID
CResponse::SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple )
{
	//	We must not modify any headers once the response has started sending.
	//	It is up to the impl to enforce this -- we just assert it here.
	//
	Assert( RS_SENDING != m_rs );

	if ( pszValue == NULL )
		m_hcHeaders.DeleteHeader( pszName );
	else
		m_hcHeaders.SetHeader( pszName, pszValue, fMultiple );
}

VOID
CResponse::SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple )
{
	//	We must not modify any headers once the response has started sending.
	//	It is up to the impl to enforce this -- we just assert it here.
	//
	Assert( RS_SENDING != m_rs );

	if ( pwszValue == NULL )
		m_hcHeaders.DeleteHeader( pszName );
	else
	{
		UINT cchValue = static_cast<UINT>(wcslen(pwszValue));
		UINT cbValue = cchValue * 3;
		CStackBuffer<CHAR> pszValue(cbValue + 1);

		//	We have received wide string for the value. We need to convert it
		//	to skinny.
		//
		cbValue = WideCharToMultiByte(CP_ACP,
									  0,
									  pwszValue,
									  cchValue + 1,
									  pszValue.get(),
									  cbValue + 1,
									  NULL,
									  NULL);
		if (0 == cbValue)
		{
			DebugTrace ( "CResponse::SetHeader(). Error 0x%08lX from WideCharToMultiByte()\n", GetLastError() );
			throw CLastErrorException();
		}

		m_hcHeaders.SetHeader( pszName, pszValue.get(), fMultiple );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyText()
//
//		Appends a string to the response body
//
VOID
CResponse::AddBodyText( UINT cbText, LPCSTR pszText )
{
	m_pBody->AddText( pszText, cbText );
}


VOID
CResponse::AddBodyText( UINT cchText, LPCWSTR pwszText )
{

	UINT cbText = cchText * 3;
	CStackBuffer<CHAR> pszText(cbText);
	LPCSTR pszTextToAdd;

	//	We have received wide string for the value. We need to convert it
	//	to skinny.
	//
	if (cbText)
	{
		cbText = WideCharToMultiByte(CP_ACP,
									 0,
									 pwszText,
									 cchText,
									 pszText.get(),
									 cbText,
									 NULL,
									 NULL);
		if (0 == cbText)
		{
			DebugTrace ( "CResponse::SetHeader(). Error 0x%08lX from WideCharToMultiByte()\n", GetLastError() );
			throw CLastErrorException();
		}

		pszTextToAdd = pszText.get();
	}
	else
	{
		//	Make sure that we do not pass NULL forward,
		//	but instead we use empty string, as the callee
		//	may not handle NULL.
		//
		pszTextToAdd = gc_szEmpty;
	}

	m_pBody->AddText( pszTextToAdd, cbText );
}
//	------------------------------------------------------------------------
//
//	CResponse::AddBodyFile()
//
//		Appends a file to the current response state
//
VOID
CResponse::AddBodyFile( const auto_ref_handle& hf,
						UINT64 ibFile64,
						UINT64 cbFile64 )
{
	m_pBody->AddFile( hf, ibFile64, cbFile64 );
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyStream()
//
//		Appends a stream to the current response state
//
VOID
CResponse::AddBodyStream( IStream& stm )
{
	m_pBody->AddStream( stm );
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyStream()
//
//		Appends a stream to the current response state
//
VOID
CResponse::AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize )
{
	m_pBody->AddStream( stm, ibOffset, cbSize );
}


//	------------------------------------------------------------------------
//
//	CResponse::AddBodyPart()
//
//		Appends a body part to the current response state
//
VOID CResponse::AddBodyPart( IBodyPart * pBodyPart )
{
	m_pBody->AddBodyPart( pBodyPart );
}

//	------------------------------------------------------------------------
//
//	CResponse::ScForward()
//
//		Instructs IIS to forward responsibility for handling the
//		current request to another ISAPI.
//
//	Returns:
//		S_OK - if forwarding succeeded, error otherwise		
//
SCODE
CResponse::ScForward( LPCWSTR pwszURI, BOOL fKeepQueryString, BOOL fCustomErrorUrl)
{
	CStackBuffer<CHAR, MAX_PATH> pszQS;
	LPCSTR	pszQueryString;
	SCODE sc = S_OK;

	//
	//	Verify that the response is still unsent.  A response can be
	//	either sent, forwarded, or redirected, but only one of the three
	//	and only once
	//
	AssertSz( m_rs == RS_UNSENT || m_rs == RS_DEFERRED,
			  "Response already sent, forwarded or redirected!" );

	Assert(pwszURI);

	//	Get the query string
	//
	pszQueryString = m_pecb->LpszQueryString();

	//	If there was custom error processing, construct query string for it ...
	//
	if (fCustomErrorUrl)
	{
		//	The query string for custom error to be forwarded is to be of the
		//	format ?nnn;originaluri, where nnn is the error code. Find out the
		//	length of the URL. Reallocate required space accounting for ?nnn;
		//	and '\0' termination.
		//
		UINT cb = static_cast<UINT>(strlen(m_pecb->LpszRequestUrl()));
		LPSTR psz = pszQS.resize( 5 + cb + 1 );
		if (NULL == psz)
		{
			DebugTrace( "CResponse::ScForward() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY );

			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Copy '?'
		//
		*psz = '?';
		psz++;

		// Copy the status code
		//
		Assert(0 <= m_iStatusCode && m_iStatusCode <= 999);
		_itoa( m_iStatusCode, psz, 10);
		while ('\0' != *psz)
		{
			psz++;
		}

		//	Copy ';'
		//
		*psz = ';';
		psz++;

		//	Copy the request URL including '\0' termination
		//
		memcpy(psz, m_pecb->LpszRequestUrl(), cb + 1);

		//	Just point the query string to the start.
		//	Note that if we are handling a custom error url we discard
		//	original query string
		//
		pszQueryString = pszQS.get();
	}
	//
	//	... otherwise if we have query string processing, construct the
	//	query string too...
	//
	else if (fKeepQueryString && pszQueryString && *pszQueryString)
	{
		//	The composed query string has to be of the format ?querystring
		//	and '\0' termination.
		//
		UINT cb = static_cast<UINT>(strlen(pszQueryString));
		LPSTR psz = pszQS.resize( 1 + cb + 1 );
		if (NULL == psz)
		{
			DebugTrace( "CResponse::ScForward() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY );
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Copy '?'
		//
		*psz = '?';
		psz++;

		//	Copy the query string including '\0' termination
		//
		memcpy( psz, pszQueryString, cb + 1 );

		//	Just point the query string to the start
		//
		pszQueryString = pszQS.get();
	}
	//
	//	... otherwise we do not need the query string
	//
	else
	{
		pszQueryString = NULL;
	}

	//	If the forward request URI is fully qualified, strip it to
	//	an absolute URI
	//
	if ( FAILED( ScStripAndCheckHttpPrefix( *m_pecb, &pwszURI )))
	{
		DebugTrace( "CResponse::ScForward() - ScStripAndCheckHttpPrefix() failed, "
					"forward request not local to this server.\n" );

		//	Why do we override error maping to 502 Bad Gateway with
		//	the error maping to 404 Not Found?
		//
		sc = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
		goto ret;
	}

	//	Forward the request to the child ISAPI
	//
	sc = m_pecb->ScExecuteChild( pwszURI, pszQueryString, fCustomErrorUrl );
	if (FAILED(sc))
	{
		DebugTrace( "CResponse::ScForward() - IEcb::ScExecuteChild() "
					"failed to execute child ISAPI for %S (0x%08lX)\n",
					pwszURI,
					sc );
		goto ret;
	}

	IncrementInstancePerfCounter( m_pecb->InstData(), IPC_TOTAL_REQUESTS_FORWARDED );
	m_rs = RS_FORWARDED;

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CResponse::ScRedirect()
//
//		Instructs IIS to send a redirect (300) response to the client.
//
//	Returns:
//		S_OK - if forwarding succeeded, error otherwise
//
SCODE
CResponse::ScRedirect( LPCSTR pszURI )
{
	SCODE sc = S_OK;

	//
	//	Verify that the response is still unsent.  A response can be
	//	either sent, forwarded, or redirected, but only one of the three
	//	and only once
	//
	AssertSz( m_rs == RS_UNSENT || m_rs == RS_DEFERRED,
			  "Response already sent, forwarded or redirected!" );

	//
	//	Tell IIS to send a redirect response
	//
	sc = m_pecb->ScSendRedirect( pszURI );
	if (FAILED(sc))
	{
		DebugTrace( "CResponse::FRedirect() - ServerSupportFunction() failed to redirect to %hs (0x%08lX)\n", pszURI, sc );
		goto ret;
	}

	IncrementInstancePerfCounter( m_pecb->InstData(), IPC_TOTAL_REDIRECT_RESPONSES );
	m_rs = RS_REDIRECTED;

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CResponse::FinalizeContent()
//
//		Prepare the response for sending by filling in computed values for
//		headers (Content-Length, Connection, etc) and body (for error
//		responses).  After this function is called, the response should be
//		ready for transmission.
//
VOID
CResponse::FinalizeContent( BOOL fResponseComplete )
{
	BOOL	fDoingCustomError = m_pecb->FProcessingCEUrl();

	//	Special case:
	//	If we have a FAILING error code, DO NOT send back an ETag header.
	//
	//	This is somewhat of a hack because we should never have set an
	//	ETag on an error response in the first place.  However, several
	//	places in the code blindly stuff the ETag into the response headers
	//	before determining the final status code.  So rather than
	//	fix the code in each place (which is a pain) we filter out
	//	the ETag here.
	//
	//	300-level responses are considered to be errors by FSuccessHSC(),
	//	but the HTTP/1.1 spec says that an ETag must be emitted for
	//	a "304 Not Modified" response, so we treat that status code
	//	as a special case.
	//
	if (!FSuccessHSC(m_iStatusCode) && m_iStatusCode != 304)
		m_hcHeaders.DeleteHeader( gc_szETag );

	//	Handle error responses.  This may mean setting default or custom
	//	error body text, or executing an error-handling URL.  In the latter
	//	case, we want to get out immediately after fowarding.
	//
	if ( FErrorStatusCode(m_iStatusCode) )
	{
		if ( m_pBody->FIsEmpty() && !fDoingCustomError && !m_pecb->FBrief())
		{
			if (m_pecb->FIIS60OrAfter())
			{
				//	For IIS 6.0 or after, we use the new way to send custom error
				//
				HSE_CUSTOM_ERROR_INFO  custErr;
				UINT cbStatusLine;

				//	Perf Wadeh, we should hold on to the string till the IO completion
				//	routine returns
				//
				auto_heap_ptr<CHAR>	pszStatus;

				//	Make sure that status line starts with one of HTTP versions.
				//	
				Assert(!_strnicmp(m_lpszStatusLine.get(), gc_szHTTP, gc_cchHTTP));
				Assert(' ' == m_lpszStatusLine[gc_cchHTTP_X_X]);

				//	Allocate the space for status string that we pass onto the CEcb.
				//	We will treat the space occupied by ' ' as accounting for space
				//	we will need for '\0' in the mathematics below.
				//
				cbStatusLine = static_cast<UINT>(strlen(m_lpszStatusLine.get()));
				cbStatusLine -= gc_cchHTTP_X_X;

				pszStatus = static_cast<LPSTR>(g_heap.Alloc(cbStatusLine));
				if (NULL != pszStatus.get())
				{
					//	m_lpszStatusLine has format "HP/x.x nnn yyyy...", where
					//	nnn is the status code. IIS expects up to pass in format
					//	"nnn yyyy....", so we need to skip the version part.
					//	Note, all the version part are of same length, this makes
					//	the adjustment easier. We copy including '\0' termination.
					//
					memcpy(pszStatus.get(), m_lpszStatusLine.get() + gc_cchHTTP_X_X + 1, cbStatusLine);

					//	Populate custom error info
					//
					custErr.pszStatus = pszStatus.get();
					custErr.uHttpSubError = static_cast<USHORT>(m_uiSubError);
					custErr.fAsync = TRUE;

					//	Try to send the custom error. The ownership of the string
					//	will be taken by CEcb only in the case of success.
					//
					if (SUCCEEDED(m_pecb->ScAsyncCustomError60After( custErr,
																	 pszStatus.get() )))
					{
						//	Relinquish the ref, as if we succeeeded in the function
						//	above it has been taken ownership by CEcb.
						//
						pszStatus.relinquish();

						m_rs = RS_FORWARDED;
						return;
					}
				}

				//	Otherwise, fall through to send error
			}
			else
			{
				//	Try a custom error.  If a custom error exists, use it.
				//	Note that a custom error can refer to a URL in which
				//	case the request is forwarded to that URL to generate
				//	appropriate error content.  If there is no custom error,
				//	then use the body detail (if any) formatted as a short
				//	HTML document. Before we start we check if the ECB is
				//	already for a custom error request. This is to prevent
				//	us from recursively calling ourselves on some custom error
				//	url that does not exist.
				//
				if ( FSetCustomErrorResponse( *m_pecb, *this ) )
				{
					//
					//	If the custom error caused the response to be forwarded
					//	(i.e. the custom error was a URL) then we are done.
					//
					if ( m_rs == RS_FORWARDED)
						return;

					//
					//	Raid NT5:187545 & X5:70652
					//
					//	This is somewhat of a hack:  IIS won't send a
					//	Connection: close header for us if the following
					//	conditions are true:
					//
					//	1. The original request was keep-alive.
					//	2. We are sending an error response.
					//	3. We have a file response body.
					//	4. We intend to send the body.
					//
					//	Because we are in this code path, we know we are sending
					//	an error (condition 2).  If custom error processing added
					//	a body, we know that it must be a file body because the
					//	only custom error types are URL or file, and the URL case
					//	is handled above by fowarding the response.  So, if we have
					//	a body, then condition 3 is satisfied.  To check for
					//	condition 1, test the state of the connection before we
					//	close it (below).  Condition 4 is satisfied if and only
					//	if do not supress the body.  The body is supressed, for
					//	example, in a HEAD response.
					//
					//	If all of the conditions are satisfied, then add our own
					//	Connection: close header.
					//
					if ( m_pecb->FKeepAlive() &&
						 !m_pBody->FIsEmpty() &&
						 !m_fSupressBody )
					{
						SetHeader( gc_szConnection, gc_szClose );
					}
				}
			}
		}

		//	Check if the body is still empty and send some
		//	stuff.
		//
		if ( m_pBody->FIsEmpty() )
		{
			m_hcHeaders.SetHeader( gc_szContent_Type, gc_szText_HTML );

			m_pBody->AddText( "<body><h2>" );
			m_pBody->AddText( m_lpszStatusLine );
			m_pBody->AddText( "</h2>" );

			if ( m_lpszBodyDetail != NULL && *m_lpszBodyDetail )
			{
				m_pBody->AddText( "<br><h3>" );
				m_pBody->AddText( m_lpszBodyDetail );
				m_pBody->AddText( "</h3>" );
			}
			m_pBody->AddText( "</body>" );
		}

		//	error response: Always close the connection.
		//
		m_pecb->CloseConnection();
	}

	//	Set the status code from the original request
	//	if we are procesing the custom URL. We expect that
	//	the query string is of the format XXX;original url.
	//
	if ( fDoingCustomError )
	{
		LPCSTR	lpszQueryString = m_pecb->LpszQueryString();
		int		iOrgStatCode = 0;

		//	Normally we expect the query string to be present.
		//	However there is a possibility that ISAPIs can initiate
		//	this request and some ISAPI may misbehave.
		//	So we check if the query string is really there and
		//	silently fail.
		//
		if (lpszQueryString)
		{
			if ( 1 == sscanf(lpszQueryString, "%3d;", &iOrgStatCode) )
			{
				//	IIS behaved as per the promise.
				//	Set the response code in the ecb and hack our
				//	status line accordingly.
				//
				m_pecb->SetStatusCode( iOrgStatCode );
				SetStatusLine( iOrgStatCode );
			}
		}

		//	error response: Always close the connection.
		//
		m_pecb->CloseConnection();

		DebugTrace("CResponse::FinalizeContent Original Status code in CEURL request %d",
				   iOrgStatCode );
	}

	//
	//	If we can chunk the response and we don't have a complete
	//	response already then include a Transfer-Encoding: chunked
	//	header.
	//
	if ( m_pecb->FCanChunkResponse() && !fResponseComplete )
	{
		m_hcHeaders.SetHeader( gc_szTransfer_Encoding, gc_szChunked );
	}

	//
	//	Otherwise the response body is already complete (i.e. we
	//	can quickly calculate its content length) or the client
	//	won't let us do chunking so set the correct Content-Length header.
	//
	else
	{
		char rgchContentLength[24];

		//	WININET HACK
		//	A 304 *can* send back all the headers of the real resource,
		//	(and we're trying to be a good little HTTP server, so we do!)
		//	BUT if we send back a >0 content-length on a 304, WININET
		//	hangs trying to read the body (which isn't there!).
		//	So hack the content type in this one case.
		//
		if (m_iStatusCode != 304)
		{
			_ui64toa( m_pBody->CbSize64(), rgchContentLength, 10 );
		}
		else
			_ultoa( 0, rgchContentLength, 10 );

		m_hcHeaders.SetHeader( gc_szContent_Length, rgchContentLength );
	}

	//
	//	If the body is to be supressed, then nuke it
	//
	//	We nuke the body in two cases: if the body was suppressed
	//	or if the status code is a 304 not-modified.
	//
	if ( m_fSupressBody  || (m_iStatusCode == 304)) // HSC_NOT_MODIFIED
		m_pBody->Clear();

#ifdef	DBG
	//
	//	Add useful debug headers
	//
	{
		if (DEBUG_TRACE_TEST(DavprsDbgHeaders))
		{
			CHAR rgch[11];
			wsprintfA( rgch, "0x%08X", GetCurrentThreadId() );
			m_hcHeaders.SetHeader( "X-Dav-Debug-WorkerThreadID", rgch );
			m_hcHeaders.SetHeader( "X-Dav-Debug-InstanceName",
								   m_pecb->InstData().GetName()  );
		}
	}
#endif	// DBG

	//
	//	Nuke the status line and headers (EVEN DBG HEADERS!)
	//	for HTTP/0.9 responses.
	//
	if ( !strcmp( m_pecb->LpszVersion(), gc_szHTTP_0_9 ) )
	{
		//
		//	Clear the status line.
		//
		m_lpszStatusLine.clear();

		//
		//	Clear the headers.
		//
		m_hcHeaders.ClearHeaders();
	}
}


//	------------------------------------------------------------------------
//
//	CResponse::SetStatusLine()
//
//	Sets the status line according to the info given.
//
VOID
CResponse::SetStatusLine(int iStatusCode)
{
	CHAR rgchStatusDescription[256];

	//
	//	Load up the status string
	//
	//	(Conveniently, the status description resource ID
	//	for any given status code is just the status code itself!)
	//
	LpszLoadString( iStatusCode,
					m_pecb->LcidAccepted(),
					rgchStatusDescription,
					sizeof(rgchStatusDescription) );

	//
	//	Generate the status line by concatenating the HTTP
	//	version string, the status code (in decimal) and
	//	the status description.
	//
	{
		CHAR rgchStatusLine[256];
		UINT cchStatusLine;

		strcpy(rgchStatusLine, m_pecb->LpszVersion());
		cchStatusLine = static_cast<UINT>(strlen(rgchStatusLine));
		rgchStatusLine[cchStatusLine++] = ' ';

		Assert( iStatusCode >= 100 && iStatusCode <= 999 );
		_itoa( iStatusCode, rgchStatusLine + cchStatusLine, 10 );
		cchStatusLine += 3;

		rgchStatusLine[cchStatusLine++] = ' ';
		strcpy( rgchStatusLine + cchStatusLine, rgchStatusDescription );

		m_lpszStatusLine.clear();
		m_lpszStatusLine = LpszAutoDupSz( rgchStatusLine );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SendStart()
//
//	Starts sending accumulated response data.  If fComplete is TRUE then
//	the accumulated data constitutes the entire response or remainder
//	thereof.
//
VOID
CResponse::SendStart( BOOL fComplete )
{
	switch ( m_rs )
	{
		case RS_UNSENT:
		{
			Assert( fComplete );

			if (0 == InterlockedCompareExchange(&m_lRespStarted,
												1,
												0))
			{
				FinalizeContent( fComplete );

				if ( m_rs == RS_UNSENT )
				{
					Assert( m_pTransmitter == NULL );
					m_pTransmitter = new CTransmitter(*this);
					m_pTransmitter->ImplStart( fComplete );

					//	This is the path where response is complete.
					//	The ref of transmitter will be be taken
					//	ownership inside ImplStart() so noone should
					//	attempt to access it after this point as it
					//	may be released.
					//
					m_pTransmitter = NULL;

					//	Change the state after the transmitter pointer
					//	is changed to NULL, so that any thread that comes
					//	into SendStart() in the RS_SENDING state could be
					//	checked and denied the service. (i.e. by the time
					//	we check state for RS_SENDING we know that pointer
					//	is NULL if it is ment to be nulled in here).
					//
					m_rs = RS_SENDING;
				}
			}

			break;
		}

		case RS_DEFERRED:
		{
			//
			//	If the client does not accept a chunked response then we
			//	cannot start sending until the response is complete because
			//	we need the entire response to be able to compute the
			//	content length
			//
			if ( fComplete || m_pecb->FCanChunkResponse() )
			{
				if (0 == InterlockedCompareExchange(&m_lRespStarted,
													1,
													0))
				{

					FinalizeContent( fComplete );
					if ( m_rs == RS_DEFERRED )
					{
						Assert( m_pTransmitter == NULL );

						m_pTransmitter = new CTransmitter(*this);
						m_pTransmitter->ImplStart( fComplete );

						//	This is the path where response is complete.
						//	The ref of transmitter will be be taken
						//	ownership inside ImplStart() so noone should
						//	attempt to access it after this point as it
						//	may be released.
						//
						if ( fComplete )
						{
							m_pTransmitter = NULL;
						}

						//	Change the state after the transmitter pointer
						//	is changed to NULL, so that any thread that comes
						//	into SendStart() in the RS_SENDING state could be
						//	checked and denied the service. (i.e. by the time
						//	we check state for RS_SENDING we know that pointer
						//	is NULL if it is ment to be nulled in here).
						//
						m_rs = RS_SENDING;

					}
				}
			}

			break;
		}

		//
		//	If we're forwarding to another ISAPI or we already sent back
		//	a redirection response, then don't do anything further.
		//
		case RS_FORWARDED:
		case RS_REDIRECTED:
		{
			break;
		}

		case RS_SENDING:
		{
			Assert( m_rs == RS_SENDING );
			Assert( m_pecb->FCanChunkResponse() );

			//	If someone came here when transmitter is not available
			//	(was not created or complete response was already sent
			//	and the pointer was NULL-ed above, then there is no work
			//	for us.
			//
			if (NULL != m_pTransmitter)
			{
				m_pTransmitter->ImplStart( fComplete );
			}

			break;
		}

		default:
		{
			TrapSz( "Unknown response transmitter state!" );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SendPartial()
//
//	Starts sending accumulated response data.  Callers may continue to add
//	response data after calling this function.
//
VOID
CResponse::SendPartial()
{
	SendStart( FALSE );
}

//	------------------------------------------------------------------------
//
//	CResponse::SendComplete)
//
//	Starts sending all of the accumulated response data.  Callers must not
//	add response data after calling this function.
//
VOID
CResponse::SendComplete()
{
	SendStart( TRUE );
}

//	------------------------------------------------------------------------
//
//	CResponse::FinishMethod()
//
VOID
CResponse::FinishMethod()
{
	//
	//	If no one else has taken responsibility for sending the
	//	response, then send the entire thing now.
	//
	if ( m_rs == RS_UNSENT )
		SendStart( TRUE );
}



//	------------------------------------------------------------------------
//
//	ReportNumResponsesByStatusCode()
//
VOID
ReportNumResponsesByStatusCode( const CInstData& cid,
								DWORD hsc )
{
	//
	//	For best performance, keep these entries ordered
	//	by decreasing expected frequency of hsc.
	//
	static struct SStatCodeMap
	{
		DWORD hsc;
		UINT  ipcTotal;
		UINT  ipcPerSec;
	}
	gsc_rgMappings[] =
	{
		{
			HSC_OK,
			IPC_TOTAL_200_RESPONSES,
			IPC_200_RESPONSES_PER_SECOND
		},
		{
			HSC_CREATED,
			IPC_TOTAL_201_RESPONSES,
			IPC_201_RESPONSES_PER_SECOND
		},
		{
			HSC_NO_CONTENT,
			IPC_TOTAL_204_RESPONSES,
			IPC_204_RESPONSES_PER_SECOND
		},
		{
			HSC_MULTI_STATUS,
			IPC_TOTAL_207_RESPONSES,
			IPC_207_RESPONSES_PER_SECOND
		},
		{
			HSC_MOVED_TEMPORARILY,
			IPC_TOTAL_302_RESPONSES,
			IPC_302_RESPONSES_PER_SECOND
		},
		{
			HSC_BAD_REQUEST,
			IPC_TOTAL_400_RESPONSES,
			IPC_400_RESPONSES_PER_SECOND
		},
		{
			HSC_UNAUTHORIZED,
			IPC_TOTAL_401_RESPONSES,
			IPC_401_RESPONSES_PER_SECOND
		},
		{
			HSC_FORBIDDEN,
			IPC_TOTAL_403_RESPONSES,
			IPC_403_RESPONSES_PER_SECOND
		},
		{
			HSC_NOT_FOUND,
			IPC_TOTAL_404_RESPONSES,
			IPC_404_RESPONSES_PER_SECOND
		},
		{
			HSC_METHOD_NOT_ALLOWED,
			IPC_TOTAL_405_RESPONSES,
			IPC_405_RESPONSES_PER_SECOND
		},
		{
			HSC_NOT_ACCEPTABLE,
			IPC_TOTAL_406_RESPONSES,
			IPC_406_RESPONSES_PER_SECOND
		},
		{
			HSC_CONFLICT,
			IPC_TOTAL_409_RESPONSES,
			IPC_409_RESPONSES_PER_SECOND
		},
		{
			HSC_PRECONDITION_FAILED,
			IPC_TOTAL_412_RESPONSES,
			IPC_412_RESPONSES_PER_SECOND
		},
		{
			HSC_UNSUPPORTED_MEDIA_TYPE,
			IPC_TOTAL_415_RESPONSES,
			IPC_415_RESPONSES_PER_SECOND
		},
		{
			HSC_UNPROCESSABLE,
			IPC_TOTAL_422_RESPONSES,
			IPC_422_RESPONSES_PER_SECOND
		},
		{
			HSC_LOCKED,
			IPC_TOTAL_423_RESPONSES,
			IPC_423_RESPONSES_PER_SECOND
		},
		{
			HSC_METHOD_FAILURE,
			IPC_TOTAL_424_RESPONSES,
			IPC_424_RESPONSES_PER_SECOND
		},
		{
			HSC_INTERNAL_SERVER_ERROR,
			IPC_TOTAL_500_RESPONSES,
			IPC_500_RESPONSES_PER_SECOND
		},
		{
			HSC_NOT_IMPLEMENTED,
			IPC_TOTAL_501_RESPONSES,
			IPC_501_RESPONSES_PER_SECOND
		},
		{
			HSC_SERVICE_UNAVAILABLE,
			IPC_TOTAL_503_RESPONSES,
			IPC_503_RESPONSES_PER_SECOND
		}
	};

	for ( UINT i = 0; i < sizeof(gsc_rgMappings)/sizeof(SStatCodeMap); i++ )
	{
		if ( gsc_rgMappings[i].hsc == hsc )
		{
			IncrementInstancePerfCounter( cid, gsc_rgMappings[i].ipcTotal );
			IncrementInstancePerfCounter( cid, gsc_rgMappings[i].ipcPerSec );
			break;
		}
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::CTransmitter()
//
//	A few things to note about this constructor:
//
//	The keep-alive value is cached to avoid having to get it off of the
//	IEcb for every packet transmitted.  Getting the value from the IEcb
//	can incur a SSF call.  Since the value can't change once we start
//	transmitting, it is safe to cache it.
//
//	The size of the text buffer is initialized to be twice as large as
//	the maximum amount of text data that can be sent in a single network
//	packet.  The reason for this is to eliminate reallocations when adding
//	to the buffer.  The buffer may potentially be used for prefix and
//	suffix text data, each being up to CB_WSABUFS_MAX in size.
//
//	Headers are dumped into the text buffer and a pointer to them is
//	then added to the WSABufs so that the headers count against the
//	total amount of text that can be accepted for the first packet.
//	If additional body text is later added to the WSABufs for that packet,
//	it may be transmitted along with the headers in the same packet.
//
CTransmitter::CTransmitter( CResponse& response ) :
    m_pResponse(&response),
	m_hr(S_OK),
	m_tc(TC_UNKNOWN),
	m_pitBody(response.m_pBody->GetIter()),
	m_bufBody(2 * CB_WSABUFS_MAX),
	m_cbHeadersToSend(0),
	m_cbHeadersToAccept(0),
	m_fImplDone(FALSE),
	m_pwsabufs(&m_wsabufsPrefix),
	m_lStatus(STATUS_IDLE),
	m_pfnTransmitMethod(TransmitNothing)
{
	ZeroMemory( &m_tfi, sizeof(HSE_TF_INFO) );

	//
	//	If we are sending a status line and headers (i.e. we don't
	//	have an HTTP/0.9 response) then set up to send them along
	//	with the custom IIS headers in the first packet.
	//
	if ( response.m_lpszStatusLine )
	{
		response.m_hcHeaders.DumpData( m_bufHeaders );
		m_bufHeaders.Append( 2, gc_szCRLF );	// Append extra CR/LF
		m_cbHeadersToAccept = m_bufHeaders.CbSize();
		m_cbHeadersToSend = m_cbHeadersToAccept;
		m_pfnTransmitMethod = SyncTransmitHeaders;
	}

	//
	//	Gather and report some final statistics of the response
	//	such as the status code.
	//
	ReportNumResponsesByStatusCode( response.m_pecb->InstData(),
									response.DwStatusCode() );

	//
	//	Add the first transmitter ref on the impl's behalf.
	//	This ref is released when the impl says that it's
	//	done with the response in ImplStart().
	//
	//	Other refs may be added by the transmitter itself
	//	whenever it starts an async operation, so this
	//	ref may not be the last one released.
	//
	AddRef();

	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Transmitter created\n",
				   GetCurrentThreadId(),
				   this );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::ImplStart()
//
VOID
CTransmitter::ImplStart( BOOL fResponseComplete )
{
	//	We must not be called with fResponseComplete equal to TRUE
	//	several times. We can finish doing the work only once.
	//	This would prevent us from taking out IIS process if the
	//	callers would make that mistake.
	//
	if (m_fImplDone)
	{
		TrapSz("CTransmitter::ImplStart got called twice! That is illegal! Please grab a DEV to look at it!");
		return;
	}

	//
	//	If we don't know it already, figure out the transfer coding
	//	to use in the response.
	//
	if ( TC_UNKNOWN == m_tc )
	{
		//
		//	If the response is not complete then we should not have
		//	a Content-Length header in the response.
		//
		Assert( fResponseComplete ||
				NULL == m_pResponse->LpszGetHeader( gc_szContent_Length ) );

		//
		//	Use chunked coding in the response only if the client
		//	will accept it and if we don't have a complete response
		//	(i.e. we do not have a Content-Length header).
		//
		m_tc = (!fResponseComplete && m_pResponse->m_pecb->FCanChunkResponse()) ?
					TC_CHUNKED :
					TC_IDENTITY;
	}

	Assert( m_tc != TC_UNKNOWN );

	//
	//	If the impl says it's done with the response then
	//	ensure we release its ref to the transmitter when
	//	we're done here.
	//
	auto_ref_ptr<CTransmitter> pRef;
	if ( fResponseComplete )
		pRef.take_ownership(this);

	//
	//	Note whether this is the last chunk of the response
	//	being added by the impl.
	//
	//	!!!IMPORTANT!!!
	//	Set m_fImplDone before changing the status below because the
	//	transmitter may already be running (if this is a chunked response)
	//	and may run to completion before we get a chance to do anything
	//	after the InterlockedExchange() below.
	//
	m_fImplDone = fResponseComplete;

	//
	//	Tell everyone that there is new data pending and ping the transmitter.
	//
	LONG lStatusPrev =
		InterlockedExchange( &m_lStatus, STATUS_RUNNING_ACCEPT_PENDING );

	//
	//	If the transmitter is idle then start it accepting.
	//
	if ( STATUS_IDLE == lStatusPrev )
	{
		m_pfnState = SAccept;
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SAccept()
//
//	Accept data for transmitting.
//
VOID
CTransmitter::SAccept()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SAccept()\n", GetCurrentThreadId(), this );

	//
	//	At this point we are either about to accept newly pended response
	//	data or we are continuing to accept existing data.  Either way
	//	we are going to be accepting, so change the status to reflect that.
	//
	Assert( STATUS_RUNNING_ACCEPT_PENDING == m_lStatus ||
			STATUS_RUNNING_ACCEPTING == m_lStatus );

	m_lStatus = STATUS_RUNNING_ACCEPTING;

	//
	//	If we have headers left to accept then
	//	accept as much of them as possible.
	//
	if ( m_cbHeadersToAccept > 0 )
	{
		UINT cbAccepted = m_wsabufsPrefix.CbAddItem(
			reinterpret_cast<const BYTE *>(m_bufHeaders.PContents()) +
				(m_bufHeaders.CbSize() - m_cbHeadersToAccept),
			m_cbHeadersToAccept );

		m_cbHeadersToAccept -= cbAccepted;

		//
		//	If we could not accept all of the headers then send
		//	whatever we did accept now and we will accept more
		//	the next time around.
		//
		if ( m_cbHeadersToAccept > 0 )
		{
			//
			//	Presumably we did not accept all of the headers
			//	because we filled up the prefix WSABUF.
			//
			Assert( m_wsabufsPrefix.CbSize() == CB_WSABUFS_MAX );

			//
			//	Send the headers
			//
			m_pfnState = STransmit;
			Start();
			return;
		}
	}

	//
	//	Accept a body part.  CTransmitter::AcceptComplete() will be called
	//	repeatedly for body parts as they are accepted.
	//
	//	Add a transmitter ref before starting the next async operation.
	//	Use auto_ref_ptr to simplify resource recording and to
	//	prevent resource leaks if an exception is thrown.
	//	Ref is claimed by AcceptComplete() below.
	//
	{
		auto_ref_ptr<CTransmitter> pRef(this);

		m_pitBody->Accept( *this, *this );

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitComplete()
//
//	IBodyPartVisitor callback called when we accept the last response body
//	part added so far.  Note that the impl may still be adding body parts
//	on another thread at this point.
//
VOID
CTransmitter::VisitComplete()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitComplete()\n", GetCurrentThreadId(), this );

	//
	//	Sanity check: the transmitter must be running (or we wouldn't
	//	be here) and we must be accepting data.  In fact we think we
	//	just finished or we wouldn't be here.  However ImplStart() may
	//	have pended new data between the time we were called and now.
	//
	Assert( STATUS_RUNNING_ACCEPT_PENDING == m_lStatus ||
			STATUS_RUNNING_ACCEPTING == m_lStatus );

	//
	//	If ImplStart() has not pended any new data yet then let
	//	everyone know that we are done accepting for now.
	//
	(VOID) InterlockedCompareExchange( &m_lStatus,
									   STATUS_RUNNING_ACCEPT_DONE,
									   STATUS_RUNNING_ACCEPTING );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AcceptComplete()
//
//	IAcceptObserver callback called when we are done accepting data from
//	a body part.  We don't care here how much data was accepted --
//	each VisitXXX() function takes care of limiting the amount of
//	accepted data by putting the transmitter into the transmit state
//	once the optimal amount of data for a transmittable packet is reached.
//	Here we only care about the case where we reach the end of the response
//	body before accepting an optimal amount of data.
//
VOID
CTransmitter::AcceptComplete( UINT64 )
{
	//
	//	Claim the transmitter ref added by AcceptBody()
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AcceptComplete()\n", GetCurrentThreadId(), this );

	//
	//	If we have finished accepting the entire the response
	//	then transmit it.
	//
	if ( FAcceptedCompleteResponse() )
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AcceptComplete() - Last chunk accepted.\n", GetCurrentThreadId(), this );
		m_pfnState = STransmit;
		Start();
	}

	//
	//	If there is still data left to accept or ImplStart() has pended
	//	more data then continue accepting.
	//
	//	Otherwise there is nothing to accept so try to go idle.  ImplStart()
	//	may pend new data right as we try to go idle.  If that happens then
	//	just continue accepting as if the data had been pended before.
	//
	else if ( STATUS_RUNNING_ACCEPT_DONE != m_lStatus ||
			  STATUS_RUNNING_ACCEPT_PENDING ==
				  InterlockedCompareExchange( &m_lStatus,
											  STATUS_IDLE,
											  STATUS_RUNNING_ACCEPT_DONE ) )
	{
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::STransmit()
//
//	Transmit accepted data via the current transmit method.
//
VOID
CTransmitter::STransmit()
{
	(this->*m_pfnTransmitMethod)();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SCleanup()
//
//	Cleanup transmitted data.
//
VOID
CTransmitter::SCleanup()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SCleanup()\n", GetCurrentThreadId(), this );

	//
	//	Quick check: If we are done accepting/transmitting the response then
	//	don't bother doing any explicit cleanup here -- our destructor
	//	will take care of everything.
	//
	if ( FAcceptedCompleteResponse() )
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SCleanup() - Last chunk has been transmitted.\n", GetCurrentThreadId(), this );
		return;
	}

	//
	//	Clear any file part.
	//
	ZeroMemory( &m_tfi, sizeof(HSE_TF_INFO) );

	//
	//	Clear any buffered text parts.
	//
	m_bufBody.Clear();

	//
	//	Clear the WSABUFS and use the prefix buffers again.
	//
	m_wsabufsPrefix.Clear();
	m_wsabufsSuffix.Clear();
	m_pwsabufs = &m_wsabufsPrefix;

	//
	//	Destroy any body parts we just sent.
	//
	m_pitBody->Prune();

	//
	//	Reset the transmit method
	//
	m_pfnTransmitMethod = TransmitNothing;

	//
	//	At this point the transmitter must be running and in
	//	one of the three accepting states.
	//
	Assert( (STATUS_RUNNING_ACCEPT_PENDING == m_lStatus) ||
			(STATUS_RUNNING_ACCEPTING == m_lStatus) ||
			(STATUS_RUNNING_ACCEPT_DONE == m_lStatus) );

	//
	//	If there is still data left to accept or ImplStart() has pended
	//	more data then continue accepting.
	//
	//	Otherwise there is nothing to accept so try to go idle.  ImplStart()
	//	may pend new data right as we try to go idle.  If that happens then
	//	just continue accepting as if the data had been pended before.
	//
	if ( STATUS_RUNNING_ACCEPT_DONE != m_lStatus ||
		 STATUS_RUNNING_ACCEPT_PENDING ==
			 InterlockedCompareExchange( &m_lStatus,
										 STATUS_IDLE,
										 STATUS_RUNNING_ACCEPT_DONE ) )
	{
		m_pfnState = SAccept;
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::Run()
//
VOID
CTransmitter::Run()
{
	//
	//	Keep things running as long as we're still transmitting
	//
	if ( !FAILED(m_hr) )
	{
		//
		//	Assert: we aren't idle if we're executing state functions.
		//
		Assert( m_lStatus != STATUS_IDLE );

		(this->*m_pfnState)();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::IISIOComplete()
//
//	Response transmitter async I/O completion routine.
//
VOID
CTransmitter::IISIOComplete( DWORD dwcbSent,
							 DWORD dwLastError )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX IISIOComplete() Sent %d bytes (last error = %d)\n", GetCurrentThreadId(), this, dwcbSent, dwLastError );

	//
	//	Take ownership of the transmitter reference added
	//	on our behalf by the thread that started the async I/O.
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	//
	//	If we had headers left to send then theoretically we just
	//	finished sending some of them.  If so then subtract off
	//	what we just sent before continuing.
	//
	if ( m_cbHeadersToSend > 0 && dwLastError == ERROR_SUCCESS )
	{
		//	Note: dwcbSent does not in any way give use the amount of
		//	headers sent.  Use the size of the prefix buffer instead.
		//
		Assert( m_wsabufsPrefix.CbSize() <= m_cbHeadersToSend );

		m_cbHeadersToSend -= m_wsabufsPrefix.CbSize();
	}

	//
	//	Proceed with cleanup.
	//
	m_hr = HRESULT_FROM_WIN32(dwLastError);
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::TransmitNothing()
//
//	This transmit function is used as the initial default transmit function.
//	If no body data is accepted for transmission before the transmitter
//	is invoked (e.g. either because the body is empty, or because the
//	previous transmission transmitted the last of the body).
//
VOID
CTransmitter::TransmitNothing()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX TransmitNothing()\n", GetCurrentThreadId(), this );

	//
	//	Nothing to transmit, just proceed to cleanup.
	//
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SyncTransmitHeaders()
//
VOID
CTransmitter::SyncTransmitHeaders()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SyncTransmitHeaders()\n", GetCurrentThreadId(), this );

	HSE_SEND_HEADER_EX_INFO shei;

	//
	//	This function should (obviously) only be used to send headers
	//	including IIS headers.
	//
	Assert( m_cbHeadersToSend > 0 );
	Assert( FSendingIISHeaders() );

	shei.cchHeader = m_wsabufsPrefix.CbSize();
	if ( shei.cchHeader > 0 )
	{
		Assert( shei.cchHeader + 1 <= sizeof(m_rgbPrefix) );

		//
		//	Dump the contents of the prefix WSABUF into our prefix buffer
		//
		m_wsabufsPrefix.DumpTo( m_rgbPrefix,
								0,
								shei.cchHeader );

		//
		//	Null-terminate the headers because IIS doesn't pay any attention
		//	to cchHeader....
		//
		m_rgbPrefix[shei.cchHeader] = '\0';

		shei.pszHeader = reinterpret_cast<LPSTR>(m_rgbPrefix);
	}

	shei.pszStatus = m_pResponse->LpszStatusCode();
	shei.cchStatus = static_cast<DWORD>(strlen(shei.pszStatus));
	shei.fKeepConn = m_pResponse->m_pecb->FKeepAlive();

	if ( m_pResponse->m_pecb->FSyncTransmitHeaders(shei) )
	{
		m_cbHeadersToSend -= shei.cchHeader;
	}
	else
	{
		DebugTrace( "CTransmitter::SyncTransmitHeaders() - SSF::HSE_REQ_SEND_RESPONSE_HEADER_EX failed (%d)\n", GetLastError() );
		m_hr = HRESULT_FROM_WIN32(GetLastError());
	}

	//
	//	Next thing to do is cleanup the headers we just transmitted.
	//
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	PbEmitChunkPrefix()
//
//	Emit a chunked encoding prefix.
//
inline LPBYTE
PbEmitChunkPrefix( LPBYTE pbBuf,
				   UINT cbSize )
{
	//
	//	Emit the chunk size expressed in hex
	//
	_ultoa( cbSize,
			reinterpret_cast<LPSTR>(pbBuf),
			16 );

	pbBuf += strlen(reinterpret_cast<LPSTR>(pbBuf));

	//
	//	followed by a CRLF
	//
	*pbBuf++ = '\r';
	*pbBuf++ = '\n';

	return pbBuf;
}

//	------------------------------------------------------------------------
//
//	PbEmitChunkSuffix()
//
//	Emit a chunked encoding suffix.
//
inline LPBYTE
PbEmitChunkSuffix( LPBYTE pbBuf,
				   BOOL fLastChunk )
{
	//
	//	CRLF to end the current chunk
	//
	*pbBuf++ = '\r';
	*pbBuf++ = '\n';

	//
	//	If this is the last chunk
	//
	if ( fLastChunk )
	{
		//
		//	then add a 0-length chunk
		//
		*pbBuf++ = '0';
		*pbBuf++ = '\r';
		*pbBuf++ = '\n';

		//
		//	and there are no trailers,
		//	so just add the final CRLF
		//	to finish things off.
		//
		*pbBuf++ = '\r';
		*pbBuf++ = '\n';
	}

	return pbBuf;
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncTransmitFile()
//
VOID
CTransmitter::AsyncTransmitFile()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AsyncTransmitFile()\n", GetCurrentThreadId(), this );

	Assert( m_tfi.hFile != NULL );


	//
	//	Always async I/O
	//
	m_tfi.dwFlags = HSE_IO_ASYNC;

	//
	//	Start building up the prefix...
	//
	LPBYTE pbPrefix = m_rgbPrefix;

	//
	//	If we are sending headers then we dump those out
	//	first followed by the chunk prefix (if we are using
	//	Transfer-Encoding: chunked.
	//
	if ( m_cbHeadersToSend )
	{
		Assert( m_wsabufsPrefix.CbSize() > 0 );

		m_wsabufsPrefix.DumpTo( pbPrefix,
								0,
								m_wsabufsPrefix.CbSize() );

		pbPrefix += m_wsabufsPrefix.CbSize();

		if ( TC_CHUNKED == m_tc )
		{
			pbPrefix = PbEmitChunkPrefix( pbPrefix,
										  m_tfi.BytesToWrite +
										  m_wsabufsSuffix.CbSize() );
		}

		//
		//	Oh yeah, we need to do a little more work here when
		//	we are including IIS headers
		//
		if ( FSendingIISHeaders() )
		{
			//	First, tell IIS to include the headers and format
			//	the status code.
			//
			m_tfi.dwFlags |= HSE_IO_SEND_HEADERS;
			m_tfi.pszStatusCode = m_pResponse->LpszStatusCode();

			//
			//	Then null-terminate the headers in the prefix because
			//	IIS doesn't pay any attention to m_tfi.HeadLength in
			//	this case.
			//
			//	Note: we do NOT increment pbPrefix here because we are
			//	not including the NULL as part of the data.  It's just
			//	there to keep IIS from overrunning our buffer.  Yes,
			//	our buffer size accounts for this.  We assert it below.
			//
			*pbPrefix = '\0';
		}
	}

	//
	//	Otherwise, we are not sending headers so all of the data
	//	in the prefix WSABUF is body data, so emit the chunk prefix
	//	before dumping the body data.
	//
	else
	{
		if ( TC_CHUNKED == m_tc )
		{
			pbPrefix = PbEmitChunkPrefix( pbPrefix,
										  m_tfi.BytesToWrite +
										  m_wsabufsSuffix.CbSize() +
										  m_wsabufsPrefix.CbSize() );
		}

		if ( m_wsabufsPrefix.CbSize() )
		{
			m_wsabufsPrefix.DumpTo( pbPrefix,
									0,
									m_wsabufsPrefix.CbSize() );

			pbPrefix += m_wsabufsPrefix.CbSize();
		}
	}

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.  Remember, we might have stuffed a
	//	null in at *pbPrefix, so don't forget to include it.
	//
	Assert( pbPrefix - m_rgbPrefix + 1 <= sizeof(m_rgbPrefix) );

	//
	//	Finish up the prefix
	//
	m_tfi.HeadLength = (DWORD)(pbPrefix - m_rgbPrefix);
	m_tfi.pHead = m_rgbPrefix;

	//
	//	Now start building up the suffix...
	//
	LPBYTE pbSuffix = m_rgbSuffix;

	//
	//	If there is any data in the suffix WSABUF then add that first.
	//
	if ( m_wsabufsSuffix.CbSize() )
	{
		m_wsabufsSuffix.DumpTo( pbSuffix,
								0,
								m_wsabufsSuffix.CbSize() );

		pbSuffix += m_wsabufsSuffix.CbSize();
	}

	//
	//	If we are using Transfer-Encoding: chunked then append the
	//	protocol suffix.
	//
	if ( TC_CHUNKED == m_tc )
		pbSuffix = PbEmitChunkSuffix( pbSuffix, FAcceptedCompleteResponse() );

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.
	//
	Assert( pbSuffix - m_rgbSuffix <= sizeof(m_rgbSuffix) );

	//
	//	Finish up the suffix
	//
	m_tfi.TailLength = (DWORD)(pbSuffix - m_rgbSuffix);
	m_tfi.pTail = m_rgbSuffix;

	//
	//	If this will be the last packet sent AND we will be closing
	//	the connection, then also throw the HSE_IO_DISCONNECT_AFTER_SEND
	//	flag.  This VASTLY improves throughput by allowing IIS to close
	//	and reuse the socket as soon as the file is sent.
	//
	if ( FAcceptedCompleteResponse() &&
		 !m_pResponse->m_pecb->FKeepAlive() )
	{
		m_tfi.dwFlags |= HSE_IO_DISCONNECT_AFTER_SEND;
	}

	//
	//	Start async I/O to transmit the file.  Make sure the transmitter
	//	has an added ref if the async I/O starts successfully.  Use
	//	auto_ref to make things exception-proof.
	//
	{
		SCODE sc = S_OK;
		auto_ref_ptr<CTransmitter> pRef(this);

		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX   prefix=%d, suffix=%d, content=%d\n", GetCurrentThreadId(), this, m_tfi.HeadLength, m_tfi.TailLength, m_tfi.BytesToWrite );

		sc = m_pResponse->m_pecb->ScAsyncTransmitFile( m_tfi, *this ); 
		if (FAILED(sc))
		{
			DebugTrace( "CTransmitter::AsyncTransmitFile() - IEcb::ScAsyncTransmitFile() failed with error 0x%08lX\n", sc );
			IISIOComplete( 0, sc );
		}

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncTransmitText()
//
//	Start transmitting the text-only response.
//
VOID
CTransmitter::AsyncTransmitText()
{
	LPBYTE pb = m_rgbPrefix;


	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AsyncTransmitText()\n", GetCurrentThreadId(), this );

	//
	//	If we are sending text then there must be data in m_wsabufsPrefix.
	//
	Assert( m_wsabufsPrefix.CbSize() > 0 );

	//
	//	Figure out the amount of headers we have in the prefix WSABUF.
	//	Given that all of the headers must be transmitted before any
	//	of the body, the amount of headers in the WSABUF is the lesser
	//	of the amount of headers left to send or the size of the WSABUF.
	//
	//	The size of the body chunk is whatever is left (if anything).
	//
	UINT cbHeaders = min(m_cbHeadersToSend, m_wsabufsPrefix.CbSize());
	UINT cbChunk = m_wsabufsPrefix.CbSize() - cbHeaders;

	//
	//	If we are sending any headers then dump those out first.
	//
	if ( cbHeaders )
	{
		m_wsabufsPrefix.DumpTo( pb,
								0,
								cbHeaders );

		pb += cbHeaders;
	}

	//
	//	Then, if we are using Transfer-Encoding: chunked, include
	//	the size of this chunk.
	//
	if ( TC_CHUNKED == m_tc )
		pb = PbEmitChunkPrefix( pb, cbChunk );

	//
	//	Next, dump out the data for this chunk
	//
	if ( cbChunk > 0 )
	{
		m_wsabufsPrefix.DumpTo( pb,
								cbHeaders,
								cbChunk );

		pb += cbChunk;
	}

	//
	//	Finally, dump out the chunk suffix if we're using
	//	chunked encoding.
	//
	if ( TC_CHUNKED == m_tc )
		pb = PbEmitChunkSuffix( pb, FAcceptedCompleteResponse() );

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.
	//
	Assert( pb - m_rgbPrefix <= sizeof(m_rgbPrefix) );

	//
	//	Start async I/O to transmit the text.  Make sure the transmitter
	//	has an added ref if the async I/O starts successfully.  Use
	//	auto_ref to make things exception-proof.
	//
	{
		SCODE sc = S_OK;
		auto_ref_ptr<CTransmitter> pRef(this);

		sc = m_pResponse->m_pecb->ScAsyncWrite( m_rgbPrefix,
												static_cast<DWORD>(pb - m_rgbPrefix),
												*this );
		if (FAILED(sc))
		{
			DebugTrace( "CTransmitter::AsyncTransmitText() - IEcb::ScAsyncWrite() failed to start transmitting with error 0x%08lX\n", sc );
			IISIOComplete( 0, sc );
		}

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitBytes()
//
VOID
CTransmitter::VisitBytes( const BYTE * pbData,
						  UINT         cbToSend,
						  IAcceptObserver& obsAccept )
{
//	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitBytes()\n", GetCurrentThreadId(), this );

	UINT cbAccepted;

	//
	//$IIS	If we still have IIS headers to send, then we must send them now.
	//$IIS	One might wonder why we can't simply be clever and effecient
	//$IIS	and just add the bytes to send along with the headers.  The reason
	//$IIS	we cannot is because the IIS send headers call pays no attention
	//$IIS	to the stated size of the headers and sends only up to the first
	//$IIS	NULL.  Since binary body part data could contain several NULLs,
	//$IIS	the result would be that part of the body would be lost.
	//
	if ( FSendingIISHeaders() )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	//
	//	Accept as many bytes as we can.  Note that we may not
	//	accept everything because of the WSABUFS size limit.
	//	(See CWSABufs class definition for an explanation.)
	//
	cbAccepted = m_pwsabufs->CbAddItem( pbData, cbToSend );

	//
	//	If we accepted anything at all, then we'll want to use
	//	the text transmitter to send it later, unless we are
	//	already planning to use another transmitter (e.g. the
	//	file transmitter or header transmitter) for better
	//	performance.
	//
	if ( cbAccepted > 0 && m_pfnTransmitMethod == TransmitNothing )
		m_pfnTransmitMethod = AsyncTransmitText;

	//
	//	If we couldn't accept everything, then the WSABUFS are full
	//	so we have to transmit them before we can accept anything more.
	//
	if ( cbAccepted < cbToSend )
		m_pfnState = STransmit;

	//
	//	Finally, don't forget to tell our observer that we're done visiting.
	//
	obsAccept.AcceptComplete( cbAccepted );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitFile()
//
VOID
CTransmitter::VisitFile( const auto_ref_handle& hf,
						 UINT64   ibOffset64,
						 UINT64   cbToSend64,
						 IAcceptObserver& obsAccept )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitFile()\n", GetCurrentThreadId(), this );

	//
	//	We can only transmit one file at a time.  If we've already
	//	accepted a file for transmission then we cannot accept another
	//	one.  We must transmit now.
	//
	if ( m_tfi.hFile != NULL )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	//	If we need to send headers with this packet, then we can only
	//	send them along with the file
	//
	//	Accept as much of the file as we were told to.  The amount of
	//	file data we can transmit is unlimited.
	//
	m_hf = hf;
	m_tfi.hFile = m_hf.get();

	//	Our way of seting it up depends on the fact if the file is larger
	//	than 4GB. Also we have no way to do offsets that are above 4GB
	//	through _HSE_TF_INFO. We should not get them here though as
	//	byteranges are disabled for files above 4GB. And seting 0 for
	//	BytesToWrite is special value that is to be used to ask for the
	//	whole file.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibOffset64));
	m_tfi.Offset = static_cast<DWORD>(ibOffset64);
	if (0x00000000FFFFFFFF < cbToSend64)
	{
		m_tfi.BytesToWrite = 0;
	}
	else
	{	
		m_tfi.BytesToWrite = static_cast<DWORD>(cbToSend64);
	}

	//
	//	Subsequent text data (if any) will form the suffix to the file data,
	//	so cut over to the suffix WSABUFs.
	//
	m_pwsabufs = &m_wsabufsSuffix;

	//
	//	Use the file transmitter come send time.
	//
	m_pfnTransmitMethod = AsyncTransmitFile;

	obsAccept.AcceptComplete( cbToSend64 );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitStream()
//
VOID
CTransmitter::VisitStream( IAsyncStream& stmSrc,
						   UINT cbToSend,
						   IAcceptObserver& obsAccept )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitStream()\n", GetCurrentThreadId(), this );

	//
	//$IIS	If we still have IIS headers to send, then we must send them now.
	//$IIS	One might wonder why we can't simply be clever and effecient
	//$IIS	and just stream in bytes to send along with the headers.  The reason
	//$IIS	we cannot is because the IIS send headers call pays no attention
	//$IIS	to the stated size of the headers and sends only up to the first
	//$IIS	NULL.  Since binary body part data could contain several NULLs,
	//$IIS	the result would be that part of the body would be lost.
	//
	if ( FSendingIISHeaders() )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	m_pobsAccept = &obsAccept;

	cbToSend = min( cbToSend, CB_WSABUFS_MAX - m_pwsabufs->CbSize() );

	//
	//	Add a transmitter ref before starting the next async operation.
	//	Use auto_ref_ptr to simplify resource recording and to
	//	prevent resource leaks if an exception is thrown.
	//
	auto_ref_ptr<CTransmitter> pRef(this);

	stmSrc.AsyncCopyTo( *this, cbToSend, *this );

	pRef.relinquish();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::CopyToComplete()
//
VOID
CTransmitter::CopyToComplete( UINT cbCopied, HRESULT hr )
{
	//
	//	Claim the transmitter ref added by VisitStream()
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	m_hr = hr;
	m_pobsAccept->AcceptComplete( cbCopied );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncWrite()
//
//	"Write" text to the transmitter by adding it to the transmit buffers.
//	Despite its name, this call executes synchronously (note the call
//	to WriteComplete() at the end) so it does NOT need an additional
//	transmitter reference.
//
VOID
CTransmitter::AsyncWrite(
	const BYTE * pbBuf,
	UINT         cbToWrite,
	IAsyncWriteObserver& obsAsyncWrite )
{
	UINT cbWritten;

	Assert( cbToWrite <= CB_WSABUFS_MAX - m_pwsabufs->CbSize() );

	cbWritten = m_pwsabufs->CbAddItem(
		reinterpret_cast<LPBYTE>(m_bufBody.Append( cbToWrite,
		reinterpret_cast<LPCSTR>(pbBuf) )),
		cbToWrite );

	//
	//	If we accepted anything at all, then we'll want to use
	//	the text transmitter to send it later, unless we are
	//	already planning to use another transmitter (e.g. the
	//	file transmitter or header transmitter) for better
	//	performance.
	//
	if ( cbWritten > 0 && m_pfnTransmitMethod == TransmitNothing )
		m_pfnTransmitMethod = AsyncTransmitText;

	if ( m_pwsabufs->CbSize() == CB_WSABUFS_MAX )
		m_pfnState = STransmit;

	obsAsyncWrite.WriteComplete( cbWritten, NOERROR );
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewResponse
//
IResponse * NewResponse( IEcb& ecb )
{
	return new CResponse(ecb);
}

//
//	Disable stubborn level 4 warnings generated by expansion of inline STL
//	member functions.  Why do it way down here?  Because it appears to
//	silence these expanded functions without supressing warnings for any
//	code we've written above!
//
#pragma warning(disable:4146)	//	negative unsigned is still unsigned
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\sz.cpp ===
/*
 *	S Z . C P P
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */


//-----------------------------------------------------------------------------
//
//	NOTE: This file doesn't exist anymore.  All string go in \cal\src\inc\sz.h
//		  and are declared using DEC_CONST.  This is just a tombstone!  This
//		  file has been removed from the SOURCES list in the makefile.
//
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\szsrc.cpp ===
/*
 *	S Z S R C . C P P
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <langid.h>

/*
 *	FLookupWSz()
 *
 *	Purpose:
 *
 *		Looks up a string given a specific language ID.
 *
 *	Parameters:
 *
 *		rid			[in]  resource ID of string in localized table
 *		lcid		[in]  locale ID
 *		ppwsz		[out] pointer to reequested string
 */
BOOL
FLookupWSz (UINT rid, LCID lcid, LPWSTR pwsz, UINT cch)
{
	safe_lcid sl(lcid);

	//	Try the requested language identifier
	//
	if (!LoadStringW (g_inst.Hinst(), rid, pwsz, cch))
	{
		DebugTrace ("Dav: Failed to find requested language string\n");

		//	If that wasn't there, then try try stripping the sub-lang
		//
		SetThreadLocale (MAKELCID (MAKELANGID (PRIMARYLANGID (lcid),
											   SUBLANG_DEFAULT),
								   SORT_DEFAULT));

		if (!LoadStringW (g_inst.Hinst(), rid, pwsz, cch))
		{
			DebugTrace ("Dav: Failed to find next best language string\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	FLoadLangSpecificString()
 *
 *	Purpose:
 *
 *		Loads a language specific string.  If lang is unavailable, try
 *		LANG_ENGLISH.
 *
 *	Parameters:
 *
 *		rid			[in]  string resource ID
 *		lcid		[in]  locale ID
 *		rgchBuf		[out] loaded string
 *		cbBuf		[in]  size of rgchBuf
 */
BOOL
FLoadLangSpecificString (UINT rid, LCID lcid, LPSTR psz, UINT cch)
{
	CStackBuffer<WCHAR,128> pwsz(cch * sizeof(WCHAR));

	//	Try the requested language
	//
	if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
	{
		//	If we couldn't find the requested language, then
		//	try for the machine default.
		//
		lcid = MAKELCID (GetSystemDefaultLangID(), SORT_DEFAULT);
		if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
		{
			//	And lastly try for english, cause we know that one
			//	is there.
			//
			lcid = MAKELCID (MAKELANGID (LANG_ENGLISH,
										 SUBLANG_ENGLISH_US),
							 SORT_DEFAULT);

			if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
				return FALSE;
		}
	}

	return WideCharToMultiByte (CP_UTF8,
								0,
								pwsz.get(),
								-1,
								psz,
								cch,
								NULL,
								NULL);
}

BOOL
FLoadLangSpecificStringW (UINT rid, LCID lcid, LPWSTR pwsz, UINT cch)
{
	//	Try the requested language
	//
	if (!FLookupWSz (rid, lcid, pwsz, cch))
	{
		//	If we couldn't find the requested language, then
		//	go for US English
		//
		lcid = MAKELCID (MAKELANGID (LANG_ENGLISH,
									 SUBLANG_ENGLISH_US),
						 SORT_DEFAULT);

		if (!FLookupWSz (rid, lcid, pwsz, cch))
			return FALSE;
	}

	return TRUE;
}

//	========================================================================
//
//	CLASS CIDPair
//
//	Key class used with the caches in CResourceStringCache below.  Each key
//	is just a pair of IDs: the resource ID and the LCID.
//
class CIDPair
{
public:

	UINT m_uiResourceID;
	LCID m_lcid;

	CIDPair(UINT uiResourceID,
			LCID lcid) :
		m_uiResourceID(uiResourceID),
		m_lcid(lcid)
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		//
		//	Ignore the LCID and hash only on resource ID.
		//	Typically the server will only deal with one language.
		//
		return m_uiResourceID % rhs;
	}

	bool isequal( const CIDPair& rhs ) const
	{
		return (m_lcid == rhs.m_lcid) &&
			   (m_uiResourceID == rhs.m_uiResourceID);
	}
};


//	========================================================================
//
//	CLASS CResourceStringCache
//
//	Cache of resource strings to minimize expensive LoadString() calls.
//
class CResourceStringCache : private Singleton<CResourceStringCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CResourceStringCache>;

	//
	//	Caches for ANSI and Unicode strings, keyed by LCID/ResourceID pair.
	//	These must be multithread-safe caches as accesses and additions
	//	can occur simultaneously from multiple threads.
	//
	CMTCache<CIDPair, LPSTR>  m_cacheA;
	CMTCache<CIDPair, LPWSTR> m_cacheW;

	//
	//	Buffers in which the strings in the caches are stored.
	//
	ChainedStringBuffer<CHAR>  m_sbA;
	ChainedStringBuffer<WCHAR> m_sbW;

	//	NOT IMPLEMENTED
	//
	CResourceStringCache& operator=(const CResourceStringCache&);
	CResourceStringCache(const CResourceStringCache&);

public:
	//	STATICS
	//
	using Singleton<CResourceStringCache>::CreateInstance;
	using Singleton<CResourceStringCache>::DestroyInstance;
	using Singleton<CResourceStringCache>::Instance;

	//	CREATORS
	//
	CResourceStringCache() {}
	BOOL FInitialize() { return TRUE; } //$NYI Planning for when CMTCache initialization can fail...

	//	MANIPULATORS
	//
	BOOL FFetchStringA( UINT  uiResourceID,
						LCID  lcid,
						LPSTR lpszBuf,
						INT   cchBuf );

	BOOL FFetchStringW( UINT   uiResourceID,
						LCID   lcid,
						LPWSTR lpwszBuf,
						INT    cchBuf );
};

/*
 *	CResourceStringCache::FFetchStringA()
 *
 *	Purpose:
 *
 *		Fetches an ANSI string from the cache, faulting the string into
 *		the cache on first access.
 */
BOOL
CResourceStringCache::FFetchStringA(
	UINT  uiResourceID,
	LCID  lcid,
	LPSTR lpszBuf,
	INT   cchBuf )

{
	CIDPair ids( uiResourceID, lcid );
	LPSTR lpszCached = NULL;

	Assert( lpszBuf );

	//
	//	Lookup the string in the cache.  If it isn't there, then fault it in.
	//
	while ( !m_cacheA.FFetch( ids, &lpszCached ) )
	{
		//
		//	Use an init gate.  If there are multiple threads all trying
		//	to fault in the same string, this will block all but the first
		//	one through until we're done.  Use the full LCID/Resource ID
		//	pair when naming the init gate to minimize possible contention
		//	on the gate to just those threads that are trying to fault
		//	in this particular string.
		//
		CHAR rgchIDs[(sizeof(LCID) + sizeof(UINT)) * 2 + 1];

		wsprintf( rgchIDs, "%x%lx", lcid, uiResourceID );

		CInitGate ig( L"DAV/CResourceStringCache::FFetchStringA/", rgchIDs );

		if ( ig.FInit() )
		{
			//
			//	We be the thread to fault in the string.  Load up the string
			//	and cache it.  Since we load the string into the caller-supplied
			//	buffer directly, we can return as soon as we're done adding
			//	to the cache.  No need for another lookup.
			//
			if ( FLoadLangSpecificString( uiResourceID, lcid, lpszBuf, cchBuf ) )
			{
				m_cacheA.Add( ids, m_sbA.AppendWithNull(lpszBuf) );
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}

	Assert( lpszCached );

	//
	//	Copy up to cchBuf characters from the cached string into
	//	the provided buffer.  If the cached string is longer than
	//	the buffer, then the copied string is truncated
	//
	strncpy( lpszBuf, lpszCached, cchBuf );

	//
	//	Make sure the copied string is null-terminated, which
	//	it may not have been if it was truncated above.
	//
	lpszBuf[cchBuf-1] = '\0';

	return TRUE;
}

/*
 *	CResourceStringCache::FFetchStringW()
 *
 *	Purpose:
 *
 *
 *		Fetches a UNICODE string from the cache, faulting the string into
 *		the cache on first access.
 */
BOOL
CResourceStringCache::FFetchStringW(
	UINT   uiResourceID,
	LCID   lcid,
	LPWSTR lpwszBuf,
	INT    cchBuf )
{
	CIDPair ids( uiResourceID, lcid );
	LPWSTR lpwszCached = NULL;

	Assert( lpwszBuf );

	//
	//	Lookup the string in the cache.  If it isn't there, then fault it in.
	//
	while ( !m_cacheW.FFetch( ids, &lpwszCached ) )
	{
		//
		//	Use an init gate.  If there are multiple threads all trying
		//	to fault in the same string, this will block all but the first
		//	one through until we're done.  Use the full LCID/Resource ID
		//	pair when naming the init gate to minimize possible contention
		//	on the gate to just those threads that are trying to fault
		//	in this particular string.
		//
		CHAR rgchIDs[(sizeof(LCID) + sizeof(UINT)) * 2 + 1];

		wsprintf( rgchIDs, "%x%lx", lcid, uiResourceID );

		CInitGate ig( L"DAV/CResourceStringCache::FFetchStringW/", rgchIDs );

		if ( ig.FInit() )
		{
			//
			//	We be the thread to fault in the string.  Load up the string
			//	and cache it.  Since we load the string into the caller-supplied
			//	buffer directly, we can return as soon as we're done adding
			//	to the cache.  No need for another lookup.
			//
			if ( FLoadLangSpecificStringW( uiResourceID, lcid, lpwszBuf, cchBuf ) )
			{
				m_cacheW.Add( ids, m_sbW.AppendWithNull(lpwszBuf) );
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}

	Assert( lpwszCached );

	//
	//	Copy up to cchBuf characters from the cached string into
	//	the provided buffer.  If the cached string is longer than
	//	the buffer, then the copied string is truncated
	//
	wcsncpy( lpwszBuf, lpwszCached, cchBuf );

	//
	//	Make sure the copied string is null-terminated, which
	//	it may not have been if it was truncated above.
	//
	lpwszBuf[cchBuf-1] = L'\0';

	return TRUE;
}

/*
 *	FInitResourceStringCache()
 *
 *	Purpose:
 *
 *		Initializes the resource string pool.
 */
BOOL
FInitResourceStringCache()
{
	return CResourceStringCache::CreateInstance().FInitialize();
}

/*
 *	DeinitResourceStringCache()
 *
 *	Purpose:
 *
 *		Deinitializes the resource string pool.
 */
VOID
DeinitResourceStringCache()
{
	CResourceStringCache::DestroyInstance();
}

/*
 *	LpszLoadString()
 *
 *	Purpose:
 *
 *		Loads a string based on localization.
 */
LPSTR
LpszLoadString (UINT uiResourceID,
	ULONG lcid,
	LPSTR lpszBuf,
	INT cchBuf)
{
	if (!CResourceStringCache::Instance().FFetchStringA(uiResourceID, lcid, lpszBuf, cchBuf))
	{
		DebugTrace ("LpszLoadString() - Could not load string for resource ID %u (%d)\n",
					uiResourceID,
					GetLastError());
		throw CDAVException();
	}
	return lpszBuf;
}

/*
 *	LpwszLoadString()
 *
 *	Purpose:
 *
 *		Loads a string based on localization.
 */
LPWSTR
LpwszLoadString (UINT uiResourceID,
	ULONG lcid,
	LPWSTR lpwszBuf,
	INT cchBuf)
{
	if (!CResourceStringCache::Instance().FFetchStringW(uiResourceID, lcid, lpwszBuf, cchBuf))
	{
		DebugTrace ("LpszLoadString() - Could not load string for resource ID %u (%d)\n",
					uiResourceID,
					GetLastError());
		throw CDAVException();
	}
	return lpwszBuf;
}

/*
 *	LInstFromVroot()
 *
 *	Purpose:
 *
 *		Compute the server ID from the vroot (format of the vroot
 *		is "/lm/w3svc/<ID>/root/vroot/...").  The computation should
 *		be robust -- if for whatever reason the server ID can't
 *		be determined from the vroot, leave it with a value of 0.
 *
 */
LONG LInstFromVroot( LPCSTR lpszServerId )
{
	LONG	lServerId = 0;
	CStackBuffer<CHAR> pszInstance;

	//
	//	Make sure the vroot begins with "/lm/w3svc"
	//
	if ( strstr( lpszServerId, gc_sz_Lm_W3Svc ) == lpszServerId )
	{
		//
		//	If it does, then skip past that part and try to
		//	locate the '/' which should follow it.  If there
		//	isn't one, that's fine; we'll just be unable to
		//	convert whatever is there to a number and we'll
		//	end up with a server id of 0, which as we said
		//	above is just fine.
		//
		lpszServerId += gc_cch_Lm_W3Svc;
		if ( *lpszServerId && *lpszServerId == '/' )
			++lpszServerId;

		//
		//	At this point, lpszServerId should look like
		//	"1/root/vroot/..."  Locate the first '/' (should
		//	be immediately following the number) and null
		//	it out.  Again, if for some oddball reason
		//	we don't find a '/', then we'll just try to
		//	convert whatever is there and end up with
		//	a server ID of 0.
		//
		CHAR * pch = strchr( lpszServerId, '/' );
		if ( pch )
		{
			//	Reallocate the string with server ID on the stack
			//	so that we do not mess up the one passed in
			//
			UINT cchInstance = static_cast<UINT>(pch - lpszServerId);
			pszInstance.resize(cchInstance + 1);

			//	Copy the string and terminate it
			//
			memcpy(pszInstance.get(), lpszServerId, cchInstance);
			pszInstance[cchInstance] = '\0';

			//	Swap the pointer
			//
			lpszServerId = pszInstance.get();
		}

		//
		//	If we nulled out the '/', our lpszServerId
		//	should now just be a number formatted as
		//	decimal integer string.  Attempt to convert
		//	it to its corresponding binary value to get
		//	the ServerId.  Conveniently, atoi returns 0
		//	if it can't convert the string, which is
		//	exactly what we would want.
		//
		lServerId = atoi(lpszServerId);
	}

	return lServerId;
}

/*
 *	LpszAutoDupSz()
 *
 *	Purpose:
 *
 *		Duplicates a string
 */
LPSTR
LpszAutoDupSz (LPCSTR psz)
{
	Assert(psz);
	LPSTR pszDup;
	UINT cb = static_cast<UINT>((strlen(psz) + 1) * sizeof(CHAR));

	pszDup = static_cast<LPSTR>(g_heap.Alloc (cb));
	if (pszDup)
		CopyMemory (pszDup, psz, cb);

	return pszDup;
}
LPWSTR WszDupWsz (LPCWSTR psz)
{
	Assert(psz);
	LPWSTR pszDup;
	UINT cb = static_cast<UINT>((wcslen(psz) + 1) * sizeof(WCHAR));

	pszDup = static_cast<LPWSTR>(g_heap.Alloc (cb));
	if (pszDup)
		CopyMemory (pszDup, psz, cb);

	return pszDup;
}

//	Language to LANGID mapping ------------------------------------------------
//

/*
 *	FLookupLCID()
 *
 *	Purpose:
 *
 *		Looks up a locale identifier given a particular language.
 *
 *	Parameters:
 *
 *		psz			[in]  pointer to the language name
 *		plcid		[out] locale identifier
 *
 *	Returns:
 *
 *		TRUE if a locale identifier for the language is found.  Its
 *		value is returned in plcid.
 */
BOOL
FLookupLCID (LPCSTR psz, ULONG * plcid)
{
	//	Find it in the cache
	//
	*plcid = CLangIDCache::LcidFind (psz);
	return (0 != *plcid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\traces.h ===
#ifndef _TRACES_H_
#define _TRACES_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.H
//
//	.INI file tagged traces
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

DEFINE_TRACE(Actv);
DEFINE_TRACE(BodyStream);
DEFINE_TRACE(Content);
DEFINE_TRACE(Ecb);
DEFINE_TRACE(ECBLogging);
DEFINE_TRACE(EcbStream);
DEFINE_TRACE(Event);
DEFINE_TRACE(Lock);
DEFINE_TRACE(Method);
DEFINE_TRACE(Persist);
DEFINE_TRACE(Request);
DEFINE_TRACE(Response);
DEFINE_TRACE(ScriptMap);
DEFINE_TRACE(Transmit);
DEFINE_TRACE(Url);
DEFINE_TRACE(DavprsDbgHeaders);
DEFINE_TRACE(Metabase);

#define ActvTrace				DO_TRACE(Actv)
#define BodyStreamTrace			DO_TRACE(BodyStream)
#define ContentTrace			DO_TRACE(Content)
#define EcbStreamTrace			DO_TRACE(EcbStream)
#define EcbTrace				DO_TRACE(Ecb)
#define EventTrace				DO_TRACE(Event)
#define LockTrace				DO_TRACE(Lock)
#define MethodTrace				DO_TRACE(Method)
#define PersistTrace			DO_TRACE(Persist)
#define RequestTrace			DO_TRACE(Request)
#define ResponseTrace			DO_TRACE(Response)
#define ScriptMapTrace			DO_TRACE(ScriptMap)
#define TransmitTrace			DO_TRACE(Transmit)
#define UrlTrace				DO_TRACE(Url)
#define DavprsDbgHeadersTrace	DO_TRACE(DavprsDbgHeaders)
#define MBTrace					DO_TRACE(Metabase)

void InitDavprsTraces();

#endif // !defined(_TRACES_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_dbg\vmem.c ===
/*
 *	V M E M . C
 *
 *	Virtual Memory Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4206)	/* empty source file */

#if defined(DBG) && defined(_X86_)

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <caldbg.h>

#define PAGE_SIZE		4096
#define PvToVMBase(pv)	((void *)((ULONG)pv & 0xFFFF0000))

static BOOL VMValidatePvEx(VOID *pv, ULONG cbCluster)
{
	VOID *	pvBase;
	BYTE *	pb;

	pvBase = PvToVMBase(pv);
	pb = (BYTE *)pvBase + sizeof(ULONG);
	while (pb < (BYTE *)pv)
	{
		if (*pb++ != 0xAD)
		{
			TrapSz("VMValidatePvEx: Block leader overwrite");
			return(FALSE);
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					TrapSz("VMValidatePvEx: Block trailer overwrite");
					return(FALSE);
				}
			}
		}
	}

	return(TRUE);
}

VOID * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
	return VMAllocEx(cb, 1);
}

VOID * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
	ULONG	cbAlloc;
	VOID *	pvR;
	VOID *	pvC;
	ULONG 	cbPad	= 0;

	// a cluster size of 0 means don't use the virtual allocator.

	AssertSz(cbCluster != 0, "Cluster size is zero.");

	if (cb > 0x100000)
		return(0);

	if (cb % cbCluster)				/*lint !e414*/
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc	= sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
	cbAlloc -= cbAlloc % PAGE_SIZE;
	cbAlloc	+= PAGE_SIZE;

	pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

	if (pvR == 0)
		return(0);

	pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (pvC != pvR)
	{
		VirtualFree(pvR, 0, MEM_RELEASE);	/*lint !e534*/
		return(0);
	}

	*(ULONG *)pvC = cb;

	memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
		(UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

	if (cbPad)
		memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
			(UINT) cbPad);

	return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}

VOID EXPORTDBG __cdecl VMFree(VOID *pv)
{
	VMFreeEx(pv, 1);
}

VOID EXPORTDBG __cdecl VMFreeEx(VOID *pv, ULONG cbCluster)
{	/*lint -save -e534*/
	VMValidatePvEx(pv, cbCluster);	/*lint -restore*/

	if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
	{
		TrapSz("VMFreeEx: VirtualFree failed");
		GetLastError();
	}
}

VOID * EXPORTDBG __cdecl VMRealloc(VOID *pv, ULONG cb)
{
	return VMReallocEx(pv, cb, 1);
}

VOID * EXPORTDBG __cdecl VMReallocEx(VOID *pv, ULONG cb, ULONG cbCluster)
{
	VOID *	pvNew = 0;
	ULONG	cbCopy;
	/*lint -save -e534*/
	VMValidatePvEx(pv, cbCluster); /*lint -restore*/

	cbCopy = *(ULONG *)PvToVMBase(pv);
	if (cbCopy > cb)
		cbCopy = cb;

	pvNew = VMAllocEx(cb, cbCluster);

	if (pvNew)
	{
		memcpy(pvNew, pv, cbCopy);
		VMFreeEx(pv, cbCluster);
	}

	return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(VOID *pv)
{
	return VMGetSizeEx(pv, 1);
}

/*lint -save -e715*/
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *pv, ULONG cbCluster)
{
	return (*(ULONG *)PvToVMBase(pv));
} /*lint -restore*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\_evntlog.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EVNTLOG.H
//
//		EVNTLOG precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_evntlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\_davprs.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_DAVPRS.H
//
//		DAV parser precompiled header
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\_davprs.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_DAVPRS.H
//
//		DAV parser precompiled header
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Standard C/C++ headers
//
#include <malloc.h>	// For _alloca declaration ONLY!
#include <limits.h>

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>

//	IIS headers
//
#include <httpext.h>

//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss
#pragma warning(disable:4786)	//	symbol truncated in debug info (turn this one off forever)

// Put STL includes here
#include <list>

// Turn warnings back on
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

//	Global DAV subsystem headers
//
#include <autoptr.h>
#include <singlton.h>
#include <align.h>
#include <mem.h>
#include <util.h>
#include <except.h>
#include <caldbg.h>
#include <calrc.h>
#include <davimpl.h>
#include <davmb.h>
#include <nonimpl.h>
#include <ex\cnvt.h>
#include <crc.h>
#include <perfctrs.h>
#include <eventlog.h>
#include <statcode.h>
#include <sz.h>
#include <etag.h>
#include <synchro.h>
#include <profile.h>
#include "traces.h"


//	------------------------------------------------------------------------
//
//	CLASS CInst
//
//		THE one, global instance declataion.  Encapsulates both per process
//		and per thread instance information.
//
class CInstData;
class CInst
{
	HINSTANCE	m_hinst;

public:
#ifdef MINIMAL_ISAPI
	HANDLE				m_hfDummy;
#endif

	//	ACCESSORS
	//
	HINSTANCE Hinst() const { return m_hinst; }

	//	MANIPULATORS
	//
	void PerProcessInit( HINSTANCE hinst );

	CInstData& GetInstData( const IEcb& ecb );
};

extern CInst g_inst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\evntlog.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EVNTLOG.CPP
//
//	Event logging
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_evntlog.h"  // Precompiled header

//	_EVNTLOG headers
//
#include <eventlog.h>	// Event logging interface
#include <ex\reg.h>		// Registry access

static DWORD DwCreateAppLogSubkey( LPCWSTR lpwszDllPath, DWORD dwCategories = 0 );
static DWORD DwDeleteAppLogSubkey();
static const WCHAR gsc_wszAppLogRegKey[] =
	L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

//	------------------------------------------------------------------------
//
//	DWCreateAppLogSubkey()
//
DWORD
DwCreateAppLogSubkey( LPCWSTR lpwszDllPath, DWORD dwCategories )
{
	CRegKey regkey;
	DWORD dwResult = ERROR_SUCCESS;

	//
	//	Create a key for this source under the application log
	//
	{
		WCHAR lpwszKey[256];

		swprintf( lpwszKey, L"%ls%ls", gsc_wszAppLogRegKey, gc_wszSignature );
		dwResult = regkey.DwCreate( HKEY_LOCAL_MACHINE, lpwszKey );
		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error creating application log registry key (%d)\n", dwResult );
			goto ret;
		}
	}

	//
	//	Set EventMessageFile to the full DLL path
	//
	dwResult = regkey.DwSetValue( L"EventMessageFile",
								  REG_EXPAND_SZ,
								  reinterpret_cast<const BYTE *>(lpwszDllPath),
								  static_cast<DWORD>(sizeof(WCHAR) * (wcslen(lpwszDllPath) + 1)) );

	if ( ERROR_SUCCESS != dwResult )
	{
		DebugTrace( "DwCreateAppLogSubkey() - Error setting EventMessageFile value (%d)\n", dwResult );
		goto ret;
	}

	//
	//	Set TypesSupported -- Error, warning and information only
	//
	{
		DWORD dwTypesSupported = EVENTLOG_ERROR_TYPE |
								 EVENTLOG_WARNING_TYPE |
								 EVENTLOG_INFORMATION_TYPE;

		dwResult = regkey.DwSetValue( L"TypesSupported",
									  REG_DWORD,
									  reinterpret_cast<LPBYTE>(&dwTypesSupported),
									  sizeof(DWORD) );

		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error setting TypesSupported value (%d)\n", dwResult );
			goto ret;
		}
	}

	if (dwCategories)
	{
		//
		//	Set CategoryMessageFile to the full DLL path
		//
		dwResult = regkey.DwSetValue( L"CategoryMessageFile",
									  REG_EXPAND_SZ,
									  reinterpret_cast<const BYTE *>(lpwszDllPath),
									  static_cast<DWORD>(sizeof(WCHAR) * (wcslen(lpwszDllPath) + 1)) );

		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error setting CategoryMessageFile value (%d)\n", dwResult );
			goto ret;
		}

		//
		//	Set CategoryCount (to the specified one)
		//
		{
			dwResult = regkey.DwSetValue( L"CategoryCount",
										  REG_DWORD,
										  reinterpret_cast<LPBYTE>(&dwCategories),
										  sizeof(DWORD) );

			if ( ERROR_SUCCESS != dwResult )
			{
				DebugTrace( "DwCreateAppLogSubkey() - Error setting CategoryCount value (%d)\n", dwResult );
				goto ret;
			}
		}
	}

ret:
	return dwResult;
}

//	------------------------------------------------------------------------
//
//	DwDeleteAppLogSubkey()
//
DWORD
DwDeleteAppLogSubkey()
{
	WCHAR lpwszKey[256];

	swprintf( lpwszKey, L"%ls%ls", gsc_wszAppLogRegKey, gc_wszSignature );
	DWORD dwResult = RegDeleteKeyW( HKEY_LOCAL_MACHINE, lpwszKey );
	if ( dwResult != ERROR_SUCCESS )
		DebugTrace( "FDeleteAppLogSubkey() - RegDeleteKeyW() failed (%d)\n", dwResult );

	return dwResult;
}



//	========================================================================
//
//	PUBLIC INTERFACE
//

//	------------------------------------------------------------------------
//
//	LogEvent()
//
VOID
LogEvent( DWORD    dwEventID,
		  WORD     wEventType,
		  WORD     wcDataStrings,
		  LPCSTR * plpszDataStrings,
		  DWORD    dwcbRawData,
		  LPVOID   lpvRawData,
		  WORD	   wEventCategory )
{
	HANDLE hEventLog = RegisterEventSourceW( NULL, gc_wszSignature );

	if ( NULL != hEventLog )
	{
		if ( !ReportEventA( hEventLog,
							wEventType,
							wEventCategory, // Category
							dwEventID,
							NULL, // Optional security ID
							wcDataStrings,
							dwcbRawData,
							plpszDataStrings,
							lpvRawData ) )
		{
			DebugTrace( "LogEvent() - ReportEventA() failed (%d)\n", GetLastError() );
		}

		if ( !DeregisterEventSource( hEventLog ) )
		{
			DebugTrace( "LogEvent() - DeregisterEventSource() failed (%d)\n", GetLastError() );
		}
	}
	else
	{
		DebugTrace( "LogEvent() - RegisterEventSource() failed (%d)\n", GetLastError() );
	}
}

//	------------------------------------------------------------------------
//
//	LogEventW()
//
VOID
LogEventW( DWORD     dwEventID,
		   WORD      wEventType,
		   WORD      wcDataStrings,
		   LPCWSTR * plpwszDataStrings,
		   DWORD     dwcbRawData,
		   LPVOID    lpvRawData,
		   WORD		 wEventCategory )
{
	HANDLE hEventLog = RegisterEventSourceW( NULL, gc_wszSignature );

	if ( NULL != hEventLog )
	{
		if ( !ReportEventW( hEventLog,
							wEventType,
							wEventCategory, // Category
							dwEventID,
							NULL, // Optional security ID
							wcDataStrings,
							dwcbRawData,
							plpwszDataStrings,
							lpvRawData ) )
		{
			DebugTrace( "LogEventW() - ReportEventW() failed (%d)\n", GetLastError() );
		}

		if ( !DeregisterEventSource( hEventLog ) )
		{
			DebugTrace( "LogEventW() - DeregisterEventSource() failed (%d)\n", GetLastError() );
		}
	}
	else
	{
		DebugTrace( "LogEventW() - RegisterEventSource() failed (%d)\n", GetLastError() );
	}
}

//	------------------------------------------------------------------------
//
//	EventLogDllRegisterServer()
//
STDAPI EventLogDllRegisterServer( LPCWSTR lpwszDllPath, DWORD dwCategories )
{
	return HRESULT_FROM_WIN32(DwCreateAppLogSubkey(lpwszDllPath, dwCategories));
}

//	------------------------------------------------------------------------
//
//	EventLogDllUnregisterServer()
//
STDAPI EventLogDllUnregisterServer()
{
	return HRESULT_FROM_WIN32(DwDeleteAppLogSubkey());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\_evntlog.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EVNTLOG.H
//
//		EVNTLOG precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __EVNTLOG_H_
#define __EVNTLOG_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>

//	CRT headers
//
#include <malloc.h>	// For _alloca()
#include <wchar.h>	// For swprintf()

#endif // !defined(__EVNTLOG_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\url.cpp ===
/*
 *	U R L . C P P
 *
 *	Url normalization/canonicalization
 *
 *	Stolen from the IIS5 project 'iis5\svcs\iisrlt\string.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "xemit.h"

//	URI Escaping --------------------------------------------------------------
//
//	gc_mpbchCharToHalfByte - map a ASCII-encoded char representing a single hex
//	digit to a half-byte value.  Used to convert hex represented strings into a
//	binary representation.
//
//	Reference values:
//
//		'0' = 49, 0x31;
//		'A' = 65, 0x41;
//		'a' = 97, 0x61;
//
DEC_CONST BYTE gc_mpbchCharToHalfByte[] =
{
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,	0x8,0x9,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Caps here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Lowercase here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

//	Switches a wide char to a half-byte hex value.  The incoming char
//	MUST be in the "ASCII-encoded hex digit" range: 0-9, A-F, a-f.
//
inline BYTE
BCharToHalfByte(WCHAR wch)
{
    AssertSz (!(wch & 0xFF00), "BCharToHalfByte: char upper bits non-zero");
    AssertSz (iswxdigit(wch), "BCharToHalfByte: Char out of hex digit range.");

    return gc_mpbchCharToHalfByte[wch];
};

//	gc_mpwchhbHalfByteToChar - map a half-byte (low nibble) value to the
//	correspoding ASCII-encoded wide char.  Used to convert a single byte
//	into a hex string representation.
//
const WCHAR gc_mpwchhbHalfByteToChar[] =
{
    L'0', L'1', L'2', L'3',
    L'4', L'5', L'6', L'7',
    L'8', L'9', L'A', L'B',
    L'C', L'D', L'E', L'F',
};

//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline WCHAR WchHalfByteToWideChar(BYTE b)
{
    AssertSz (!(b & 0xF0), "WchHalfByteToWideChar: byte upper bits non-zero.");

    return gc_mpwchhbHalfByteToChar[b];
};

//	gc_mpchhbHalfByteToChar - map a half-byte (low nibble) value to the
//	correspoding ASCII-encoded wide char.  Used to convert a single byte
//	into a hex string representation.
//
const CHAR gc_mpchhbHalfByteToChar[] =
{
    '0', '1', '2', '3',
    '4', '5', '6', '7',
    '8', '9', 'A', 'B',
    'C', 'D', 'E', 'F',
};

//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline CHAR ChHalfByteToWideChar(BYTE b)
{
    AssertSz (!(b & 0xF0), "ChHalfByteToWideChar: byte upper bits non-zero.");

	return gc_mpchhbHalfByteToChar[b];
};


//	Note on HttpUriEscape and HttpUriUnescape
//
//	These functions do the HTTP URL escaping and Unescaping equivalent to
//	the one done by IIS. DAVEX URLs are escaped and unescaped thru a different
//	sets of routines in _urlesc subsystem. The rule is whenever we sent out
//	an Exchange HTTP wire URL, you should go thru the function in the
//	_urlesc. Right now old UrlEscape and UrlUnescape routines are routed
//	through those. However there exist cases where we need to do the
//	IIS style escape and unescape. One scenario is when we forward the
//	URLs to ISAPIs, where we use the HttpUriUnescape and HttpUriEscape functions.
//	File system DAV also uses HttpUriEscape and HttpUriUnescape.
//
//	HttpUriEscape()
//
//	This function is immigrated from iis5\svcs\w3\server\dirlist.cpp's
//	We should do the same URL escaping as IIS does.
//
//	Replaces all "bad" characters with their ASCII hex equivalent
//
VOID __fastcall HttpUriEscape (
	/* [in] */ LPCSTR pszSrc,
	/* [out] */ auto_heap_ptr<CHAR>& pszDst)
{
	enum { URL_BUF_INCREMENT = 16 };

	//	It is important that we operate on unsigned character, as otherwise
	//	checks below simply do not work correctly. E.g. UTF-8 characters will
	//	not get escaped, etc.
	//
    UCHAR uch;

	UINT cbDst;
	UINT cbSrc;
	UINT ibDst;
	UINT ibSrc;

	//	Set cbSrc to account for the string length of
	//	the url including the NULL
	//
	Assert(pszSrc);
    cbSrc = static_cast<UINT>(strlen (pszSrc) + 1);

	//	Allocate enough space for the expanded url -- and
	//	lets be a bit optimistic
	//
	cbDst = max (cbSrc + URL_BUF_INCREMENT, MAX_PATH);
    pszDst = static_cast<LPSTR>(g_heap.Alloc(cbDst));

	for (ibSrc = 0, ibDst = 0; ibSrc < cbSrc; ibSrc++)
    {
    	uch = pszSrc[ibSrc];

		//	Make sure we always have space to expand this character.
		//	Since we have allocated extra space to begin with, we should
		//	never have the scenario where we do a realloc just for the
		//	last char.
		//
		if (ibDst + 2 >= cbDst)		// enough space for three more chars
		{
			//	Destiniation buffer is not large enough, reallocate
			//	to get more space.
			//
			cbDst += URL_BUF_INCREMENT;
			pszDst.realloc (cbDst);
		}

        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF.
		//
		//	The inclusive ranges escaped are...
		//
		//	0x01 - 0x20		/* First non-printable range */
		//	0x80 - 0xBF		/* Trailing bytes of UTF8 sequence */
		//	0xC0 - 0xDF		/* Leading byte of UTF8 two byte sequence */
		//	0xE0 - 0xEF		/* Leading byte of UTF8 three byte sequence */
        //
        if ((((uch >= 0x01) && (uch <= 0x20)) /* First non-printable range */ ||
			 ((uch >= 0x80) && (uch <= 0xEF))	/* UTF8 sequence bytes */ ||
			 (uch == '%') ||
			 (uch == '?') ||
			 (uch == '+') ||
			 (uch == '&') ||
			 (uch == '#')) &&
			!(uch == '\n' || uch == '\r'))
        {
            //  Insert the escape character
            //
            pszDst[ibDst + 0] = '%';

            //  Convert the low then the high character to hex
            //
            BYTE bDigit = static_cast<BYTE>(uch % 16);
            pszDst[ibDst + 2] = ChHalfByteToWideChar (bDigit);
            bDigit = static_cast<BYTE>((uch/16) % 16);
            pszDst[ibDst + 1] = ChHalfByteToWideChar (bDigit);

			//	Adjust for the two extra characters for this sequence
			//
            ibDst += 3;
        }
        else
		{
            pszDst[ibDst] = uch;
			ibDst += 1;
		}
    }

	UrlTrace ("Url: UriEscape(): escaped url: %hs\n", pszDst.get());
	return;
}

//	HttpUriUnescape()
//
//	This function is immigrated from iis5\svcs\w3\server\dirlist.cpp's
//	We should do the same URL unescaping as IIS does.
//
//	Replaces all escaped characters with their byte equivalent
//
//
VOID __fastcall HttpUriUnescape (
	/* [in] */ const LPCSTR pszUrl,
	/* [out] */ LPSTR pszUnescaped)
{
	LPCSTR	pch;
	LPSTR	pchNew;

	Assert (pszUrl);
	Assert (pszUnescaped);

	pch = pszUrl;
	pchNew = pszUnescaped;

	while (*pch)
	{
		//	If this is a valid byte-stuffed character, unpack it.  For us
		//	to really unpack it, we need the sequence to be valid.
		//
		//	NOTE: we stole this code from IIS at one point, so we are
		//	pretty sure this is consistant with their behavior.
		//
		if  (('%' == pch[0]) &&
			 ('\0' != pch[1]) &&
			 ('\0' != pch[2]) &&
			 isxdigit(pch[1]) &&
			 isxdigit(pch[2]))
		{

#pragma warning(disable:4244)

			//	IMPORTANT: when we do this processing, there is no specific
			//	machine/byte ordering assumed.  The HEX digit is represented
			//	as a %xx, and the first char is multiplied by sixteen and
			//	then second char is added in.
			//
			UrlTrace ("HttpUriEscape () - unescaping: %hc%hc%hc\n", pch[0], pch[1], pch[2]);
			*pchNew = (BCharToHalfByte(pch[1]) * 16) + BCharToHalfByte(pch[2]);
			pch += 3;

#pragma warning(default:4244)

		}
		else
		{
		     *pchNew = *pch++;
		}

		//	If a NULL character was byte-stuffed, then that is the end of
		//	the url and we can stop processing now. Otherwise, path modifications
		//	could be used to bypass a NULL.
		//
		if ('\0' == *pchNew)
		{
			break;
		}

		pchNew++;
	}

    //	Close the new URI
    //
    *pchNew = '\0';

	UrlTrace ("HttpUriEscape() - resulting destination: \"%hs\"\n", pszUnescaped);
}

//	Prefix stripping ----------------------------------------------------------
//
SCODE __fastcall
ScStripAndCheckHttpPrefix (
	/* [in] */ const IEcb& ecb,
	/* [in/out] */ LPCWSTR * ppwszRequest)
{
	SCODE sc = S_OK;

	Assert (ppwszRequest);
	Assert (*ppwszRequest);
	LPCWSTR pwszRequest = *ppwszRequest;

	//	See if the servername matches
	//
	LPCWSTR pwsz;
	UINT cch;

	//	If the forward request URI is fully qualified, strip it to
	//	an absolute URI
	//
	cch = ecb.CchUrlPrefixW (&pwsz);
	if (!_wcsnicmp (pwsz, pwszRequest, cch))
	{
		pwszRequest += cch;
		cch = ecb.CchGetServerNameW (&pwsz);
		if (_wcsnicmp (pwsz, pwszRequest, cch))
		{
			sc = E_DAV_BAD_DESTINATION;
			DebugTrace ("ScStripAndCheckHttpPrefix(): server does not match 0x%08lX\n", sc);
			goto ret;
		}

		//	If the server name matched, make sure that if the
		//	next thing is a port number that it is ":80".
		//
		pwszRequest += cch;
		if (*pwszRequest == L':')
		{
			cch = ecb.CchUrlPortW (&pwsz);
			if (_wcsnicmp (pwsz, pwszRequest, cch))
			{
				sc = E_DAV_BAD_DESTINATION;
				DebugTrace ("ScStripAndCheckHttpPrefix(): port does not match 0x%08lX\n", sc);
				goto ret;
			}
			pwszRequest += cch;
		}
	}

	*ppwszRequest = pwszRequest;

ret:

	return sc;
}

LPCWSTR __fastcall
PwszUrlStrippedOfPrefix (
	/* [in] */ LPCWSTR pwszUrl)
{
	Assert (pwszUrl);

	//	Skip past the "http://" of the url
	//
	if (L'/' != *pwszUrl)
	{
		//	If the first slash occurance is a double slash, then
		//	move past the end of it.
		//
		LPWSTR pwszSlash = wcschr (pwszUrl, L'/');
		while (pwszSlash && (L'/' == pwszSlash[1]))
		{
			//	Skip past the host/server name
			//
			pwszSlash += 2;
			while (NULL != (pwszSlash = wcschr (pwszSlash, L'/')))
			{
				UrlTrace ("Url: PwszUrlStrippedOfPrefix(): normalizing: "
						  "skipping %d chars of '%S'\n",
						  pwszSlash - pwszUrl,
						  pwszUrl);

				pwszUrl = pwszSlash;
				break;
			}
			break;
		}
	}

	return pwszUrl;
}

//	Storage path to UTF8 url translation --------------------------------------
//
SCODE __fastcall
ScUTF8UrlFromStoragePath (
	/* [in]     */ const IEcbBase &	ecb,
	/* [in]     */ LPCWSTR			pwszPath,
	/* [out]    */ LPSTR			pszUrl,
	/* [in/out] */ UINT			  *	pcbUrl,
	/* [in]		*/ LPCWSTR			pwszServer)
{
	CStackBuffer<WCHAR,MAX_PATH> pwszUrl;
	SCODE sc = S_OK;
	UINT cbUrl;
	UINT cchUrl;

	//	Assume one skinny character will be represented by one wide character,
	//	Note that callers are indicating available space including 0 termination.
	//
	cchUrl = *pcbUrl;
	if (!pwszUrl.resize(cchUrl * sizeof(WCHAR)))
		return E_OUTOFMEMORY;

	sc = ScUrlFromStoragePath (ecb,
							   pwszPath,
							   pwszUrl.get(),
							   &cchUrl,
							   pwszServer);
	if (S_FALSE == sc)
	{
		if (!pwszUrl.resize(cchUrl * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		sc = ScUrlFromStoragePath (ecb,
								   pwszPath,
								   pwszUrl.get(),
								   &cchUrl,
								   pwszServer);
	}
	if (S_OK != sc)
	{
		//	There is no reason to fail because for being short of buffer - we gave as
		//	much as we were asked for
		//
		Assert(S_FALSE != sc);
		DebugTrace( "ScUrlFromStoragePath() - ScUrlFromStoragePath() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find out the length of buffer needed for the UTF-8
	//	version of the URL. Functions above return the length
	//	including '\0' termination, so number of charasters
	//	to convert will always be more than zero.
	//
	Assert(0 < cchUrl);
	cbUrl = WideCharToMultiByte(CP_UTF8,
								0,
								pwszUrl.get(),
								cchUrl,
								NULL,
								0,
								NULL,
								NULL);
	if (0 == cbUrl)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace( "ScUTF8UrlFromStoragePath() - WideCharToMultiByte() failed 0x%08lX\n", sc );
		goto ret;
	}

	if (*pcbUrl < cbUrl)
	{
		sc = S_FALSE;
		*pcbUrl = cbUrl;
		goto ret;
	}
	else
	{
		//	Convert the URL to skinny including 0 termination
		//
		cbUrl = WideCharToMultiByte( CP_UTF8,
									 0,
									 pwszUrl.get(),
									 cchUrl,
									 pszUrl,
									 cbUrl,
									 NULL,
									 NULL);
		if (0 == cbUrl)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace( "ScUrlFromStoragePath() - WideCharToMultiByte() failed 0x%08lX\n", sc );
			goto ret;
		}

		*pcbUrl = cbUrl;
	}

ret:

	if (FAILED(sc))
	{
		//	Zero out the return in the case of failure
		//
		*pcbUrl = 0;
	}
	return sc;
}

//	Redirect url construction -------------------------------------------------
//
SCODE __fastcall
ScConstructRedirectUrl (
	/* [in] */ const IEcb& ecb,
	/* [in] */ BOOL fNeedSlash,
	/* [out] */ LPSTR * ppszUrl,
	/* [in] */ LPCWSTR pwszServer )
{
	SCODE sc;

	auto_heap_ptr<CHAR> pszEscapedUrl;	//	We will need to escape the url we construct, so we will store it there

	CStackBuffer<CHAR,MAX_PATH> pszLocation;
	LPCSTR	pszQueryString;
	UINT	cchQueryString;
	LPCWSTR	pwsz;
	UINT	cch;

	//	This request needs to be redirected.  Allocate
	//	enough space for the URI and an extra trailing
	//	slash and a null terminator.
	//
	pwsz = ecb.LpwszPathTranslated();
	pszQueryString = ecb.LpszQueryString();
	cchQueryString = static_cast<UINT>(strlen(pszQueryString));

	//	Make a best guess. We allow for additional trailing '/'
	//	here (thus we show one character less than we actually
	//	have to the functions bellow).
	//
	cch = pszLocation.celems() - 1;
	sc = ::ScUTF8UrlFromStoragePath (ecb,
									 pwsz,
									 pszLocation.get(),
									 &cch,
									 pwszServer);
	if (S_FALSE == sc)
	{
		//	Try again. Also do not forget that we may
		//	add trailing '/' later, thus allow space for
		//	it too.
		//
		if (!pszLocation.resize(cch + 1))
			return E_OUTOFMEMORY;

		sc = ::ScUTF8UrlFromStoragePath (ecb,
										 pwsz,
										 pszLocation.get(),
										 &cch,
										 pwszServer);
	}
	if (S_OK != sc)
	{
		//	We gave sufficient space, we must not be asked for more
		//
		Assert(S_FALSE != sc);
		DebugTrace("ScConstructRedirectUrl() - ScUTF8UrlFromStoragePath() failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	The translation above results in a URI that does not
	//	have a trailing slash.  So if one is required, do that
	//	here.
	//
	//	The value of cch at this point includes the
	//	null-termination character.  So we need to look
	//	back two characters instead of one.
	//
	//$	DBCS: Since we are always spitting back UTF8, I don't think
	//	forward-slash characters are likely to be an issue here.  So
	//	there should be no need for a DBCS lead byte check to determine
	//	if a slash is required.
	//
	Assert (0 == pszLocation[cch - 1]);
	if (fNeedSlash && ('/' != pszLocation[cch - 2]))
	{
		pszLocation[cch - 1] = '/';
		pszLocation[cch] = '\0';
	}
	//
	//$ DBCS: end.

	//	Escape the URL
	//
	HttpUriEscape (pszLocation.get(), pszEscapedUrl);

	//	Copy the query string if we have got one
	//
	if (cchQueryString)
	{
		cch = static_cast<UINT>(strlen(pszEscapedUrl.get()));
		pszEscapedUrl.realloc(cch + cchQueryString + 2);	//	One for the '?' and one for zero termination.

		pszEscapedUrl[cch] = '?';
		memcpy(pszEscapedUrl.get() + cch + 1, pszQueryString, cchQueryString);
		pszEscapedUrl[cch + 1 + cchQueryString] = '\0';
	}
	*ppszUrl = pszEscapedUrl.relinquish();

ret:

	return sc;
}

//	Virtual roots -------------------------------------------------------------
//
/*
 *	FIsVRoot()
 *
 *	Purpose:
 *
 *		Returns TRUE iif the specified URI is the VRoot
 *
 *	Parameters:
 *
 *		pmu			[in]  method utility function
 *		pszURI		[in]  URI to check
 */
BOOL __fastcall
CMethUtil::FIsVRoot (LPCWSTR pwszURI)
{
	LPCWSTR pwsz;
	LPCWSTR pwszUnused;

	Assert(pwszURI);
	UINT cch = static_cast<UINT>(wcslen (pwszURI));

	//	The virtual root as determined by CchGetVirtualRoot(),
	//	will truncate the trailing slash, if any.
	//
	pwsz = pwszURI + cch - 1;
	if (L'/' == *pwsz)
	{
			cch -= 1;
	}

	return (cch == CchGetVirtualRootW(&pwszUnused));
}

//	Path conflicts ------------------------------------------------------------
//
BOOL __fastcall
FSizedPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ UINT cchSrc,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ UINT cchDst)
{
	//	For which ever path is shorter, see if it is
	//	a proper subdir of the longer.
	//
	if ((0 == cchSrc) || (0 == cchDst))
	{
		DebugTrace ("Dav: Url: FSizedPathConflict(): zero length path is "
					"always in conflict!\n");
		return TRUE;
	}
	if (cchDst < cchSrc)
	{
		//	When the destination is shorter, if the paths
		//	match up to the full length of the destination
		//	and the last character or the one immediately
		//	following the destination is a backslash, then
		//	the paths are conflicting.
		//
		if (!_wcsnicmp (pwszSrc, pwszDst, cchDst))
		{
			if ((L'\\' == *(pwszDst + cchDst - 1)) ||
				(L'\\' == *(pwszSrc + cchDst)) ||
				//$$DAVEX BUG: We could get here in a case where we have:
				//	pwszSrc  = \\.\ExchangeIfs\Private Folders/this/is/my/path
				//	pwszDest = \\.\ExchangeIfs\Private Folders
				//	The two comparisons above balk on this.  Add the two
				//	comparisons below to handle this case properly.
				(L'/'  == *(pwszDst + cchDst - 1)) ||
				(L'/'  == *(pwszSrc + cchDst)))
			{
				DebugTrace ("Dav: Url: FSizedPathConflict(): destination is "
							"parent to source\n");
				return TRUE;
			}
		}
	}
	else if (cchSrc < cchDst)
	{
		//	When the source is shorter, if the paths
		//	match up to the full length of the source
		//	and the last character or the one immediately
		//	following the source is a backslash, then
		//	the paths are conflicting.
		//
		if (!_wcsnicmp (pwszSrc, pwszDst, cchSrc))
		{
			if ((L'\\' == *(pwszSrc + cchSrc - 1)) ||
				(L'\\' == *(pwszDst + cchSrc)) ||
				//$$DAVEX BUG: We could get here in a case where we have:
				//	pwszSrc  = \\.\ExchangeIfs\Private Folders/this/is/my/path
				//	pwszDest = \\.\ExchangeIfs\Private Folders
				//	The two comparisons above balk on this.  Add the two
				//	comparisons below to handle this case properly.
				(L'/'  == *(pwszSrc + cchSrc - 1)) ||
				(L'/' == *(pwszDst + cchSrc)))
			{
				DebugTrace ("Dav: Url: FSizedPathConflict(): source is parent "
							"to destination\n");
				return TRUE;
			}
		}
	}
	else
	{
		//	If the paths are the same length, and are infact
		//	equal, why do anything?
		//
		if (!_wcsicmp (pwszSrc, pwszDst))
		{
			DebugTrace ("Dav: Url: FSizedPathConflict(): source and "
						"destination refer to same\n");
			return TRUE;
		}
	}
	return FALSE;
}

BOOL __fastcall
FPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszDst)
{
	Assert (pwszSrc);
	Assert (pwszDst);

	UINT cchSrc = static_cast<UINT>(wcslen (pwszSrc));
	UINT cchDst = static_cast<UINT>(wcslen (pwszDst));

	return FSizedPathConflict (pwszSrc, cchSrc, pwszDst, cchDst);
}

BOOL __fastcall
FIsImmediateParentUrl (LPCWSTR pwszParent, LPCWSTR pwszChild)
{
	LPCWSTR pwsz;

	Assert(pwszChild);
	UINT cchChild = static_cast<UINT>(wcslen (pwszChild));
	UINT cchMatch;

	//	Skip back from the end of the child until the last
	//	path segment has been reached
	//
	pwsz = pwszChild + cchChild - 1;

	//	Child may terminate in a slash, trim it if need be
	//
	if (*pwsz == L'/')
	{
		--pwsz;
	}

	//	Ok, now we can try and isolate the last segment
	//
	for (; pwsz > pwszChild; --pwsz)
	{
		if (*pwsz == L'/')
		{
			break;
		}
	}

	//	See if the parent and child match up to this point
	//
	cchMatch = static_cast<UINT>(pwsz - pwszChild);
	if (!_wcsnicmp (pwszParent, pwszChild, cchMatch))
	{
		//	Make sure that the parent doesn't trail off onto another
		//	branch of the tree, and yes these asserts are DBCS correct.
		//
		Assert ((*(pwszParent + cchMatch) == L'\0') ||
				((*(pwszParent + cchMatch) == L'/') &&
				 (*(pwszParent + cchMatch + 1) == L'\0')));

		return TRUE;
	}

	return FALSE;
}

SCODE
ScAddTitledHref (CEmitterNode& enParent,
				 IMethUtil * pmu,
				 LPCWSTR pwszTag,
				 LPCWSTR pwszPath,
				 BOOL fCollection,
				 CVRoot* pcvrTranslate)
{
	auto_heap_ptr<CHAR> pszUriEscaped;
	CEmitterNode en;
	SCODE sc = S_OK;

	//	Just see if we have the path and tag to process
	//
	Assert(pwszTag);
	Assert(pwszPath);

	sc = ScWireUrlFromStoragePath (pmu,
								   pwszPath,
								   fCollection,
								   pcvrTranslate,
								   pszUriEscaped);
	if (FAILED (sc))
		goto ret;

	sc = enParent.ScAddUTF8Node (pwszTag, en, pszUriEscaped.get());
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_dbg\caldbg.c ===
/*
 *	C A L D B G . C
 *
 *	Debugging Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4206)	/* empty source file */

#ifdef	DBG

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <objerror.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>

#include <lmcons.h>
#include <lmalert.h>

#include <caldbg.h>

//	global debugging indicators -----------------------------------------------
//

//	Values for Assert flags
#define ASSERTFLAG_UNINITIALIZED	0xffffffff
#define ASSERTFLAG_DEFAULT			0x00000000
#define ASSERTFLAG_IF_DEBUGGING		0x00000001
#define ASSERTFLAG_POPUP			0x00000002
#define ASSERTFLAG_KD_SAFE			0x00000004

//	Values for TraceError() settings (these are NOT flags!)
#define TRACEERROR_UNINITIALIZED	0xffffffff
#define TRACEERROR_NONE				0x00000000
#define TRACEERROR_FAILED_SCODE		0x00000001
#define TRACEERROR_NATURAL			0x00000002
#define TRACEERROR_FAILING_EC		0x00000003
#define TRACEERROR_ALWAYS			0x00000004

static BOOL g_fTraceEnabled			= -1;
static BOOL g_fUseEventLog			= -1;
static BOOL g_fAssertLeaks			= -1;
static DWORD g_dwAssertFlags		= ASSERTFLAG_UNINITIALIZED;
static DWORD g_dwDefaultAssertFlags	= ASSERTFLAG_DEFAULT;
static DWORD g_dwErrorTraceLevel	= TRACEERROR_UNINITIALIZED;


//	Debug strings -------------------------------------------------------------
//
const CHAR gc_szDbgAssertLeaks[]		= "AssertLeaks";
const CHAR gc_szDbgAssertCloses[]		= "AssertCloses";
const CHAR gc_szDbgDebugTrace[]			= "DebugTrace";
const CHAR gc_szDbgErrorTrace[]			= "Error";
const CHAR gc_szDbgEventLog[]			= "EventLog";
const CHAR gc_szDbgGeneral[]			= "General";
const CHAR gc_szDbgLeakLogging[]		= "Leak Logging";
const CHAR gc_szDbgLogFile[]			= "LogFile";
const CHAR gc_szDbgRecordResources[]	= "RecordResources";
const CHAR gc_szDbgSymbolicDumps[]		= "SymbolicDumps";
const CHAR gc_szDbgTraces[]				= "Traces";
const CHAR gc_szDbgUseVirtual[]			= "UseVirtual";
const CHAR gc_szDbgUseExchmem[]			= "UseExchmem";
const CHAR gc_szDbgPopupAsserts[]		= "PopupAsserts";

//	Debugging routines --------------------------------------------------------
//
typedef	BOOL  (WINAPI *REPORTEVENT)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCTSTR *, LPVOID);
typedef HANDLE (WINAPI *REGISTEREVENTSOURCEA)(LPCTSTR, LPCTSTR);
typedef NET_API_STATUS (WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *);

#define MAX_LINE		256

//	LogIt() -------------------------------------------------------------------
//

VOID
LogIt (LPSTR plpcText, BOOL	fUseAlert)
{
	LPSTR llpcStr[2];
	static HANDLE hEventSource = NULL;
	static REPORTEVENT pfnReportEvent = NULL;
	static REGISTEREVENTSOURCEA pfnRegisterEventSourceA = NULL;

	if (pfnRegisterEventSourceA == NULL)
	{
		//	This handle is not important as the lib will be
		//	freed on exit (and it's debug only)
		//
		HINSTANCE lhLib;

		lhLib = LoadLibraryA("advapi32.dll");
		if (!lhLib)
			return;

		pfnRegisterEventSourceA = (REGISTEREVENTSOURCEA) GetProcAddress(lhLib, "RegisterEventSourceA");
		pfnReportEvent = (REPORTEVENT) GetProcAddress(lhLib, "ReportEventA");
		if (!pfnRegisterEventSourceA || !pfnReportEvent)
			return;
	}

	if (!hEventSource)
		hEventSource = pfnRegisterEventSourceA(NULL, "Caligula Debug");

	llpcStr[0] = "Caligula Debug Log";
	llpcStr[1] = plpcText;

	pfnReportEvent(hEventSource,	/* handle of event source */
		EVENTLOG_ERROR_TYPE,		/* event type			  */
		0,							/* event category		  */
		0,							/* event ID				  */
		NULL,						/* current user's SID	  */
		2,							/* strings in lpszStrings */
		0,							/* no bytes of raw data	  */
		llpcStr,					/* array of error strings */
		NULL);						/* no raw data			  */

	//	The code for raising an alert was taken from code in the
	//	admin tree.  It needs to be UNICODE
	//
	if (fUseAlert)
	{
		BYTE rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)];
		ADMIN_OTHER_INFO * poi = (ADMIN_OTHER_INFO *) rgb;
		WCHAR *	pch = (WCHAR *)(rgb + sizeof(ADMIN_OTHER_INFO));	/*lint -esym(550,nas) */
		NET_API_STATUS nas;
		static NAREFN fnNetAlertRaiseEx = NULL;

		//	Load the alert library, and as before, unloading is taken
		//	care of when the DLL goes away.
		//
		if (!fnNetAlertRaiseEx)
		{
			HINSTANCE lhLib;

			lhLib = LoadLibrary("NETAPI32.DLL");
			if (!lhLib)
				return;

			fnNetAlertRaiseEx = (NAREFN)GetProcAddress(lhLib, "NetAlertRaiseEx");
			if (!fnNetAlertRaiseEx)
				return;
		}

		poi->alrtad_errcode = (DWORD) -1;
		poi->alrtad_numstrings = 1;
		if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, plpcText, -1, pch, MAX_LINE))
		{
			nas = fnNetAlertRaiseEx ((TCHAR *)L"ADMIN",
									 poi,
									 sizeof(ADMIN_OTHER_INFO) + ((lstrlenW(pch) + 1) * sizeof(WCHAR)),
									 (TCHAR *)L"Caligula Assert");


		}
	}
}

//	DebugOutputNoCRLFFn() -----------------------------------------------------
//
void DebugOutputNoCRLFFn(char *psz)
{
	if (g_fTraceEnabled == -1)
	{
		g_fTraceEnabled = GetPrivateProfileIntA (gc_szDbgGeneral,
			gc_szDbgDebugTrace,
			FALSE,
			gc_szDbgIni);

		g_fUseEventLog = GetPrivateProfileIntA (gc_szDbgGeneral,
												gc_szDbgEventLog,
												FALSE,
												gc_szDbgIni);
	}
	if (!g_fTraceEnabled)
		return;

	if (g_fUseEventLog)
		LogIt (psz, FALSE);

	OutputDebugStringA(psz);
}


//	DebugOutputFn() -----------------------------------------------------------
//
void DebugOutputFn(char *psz)
{
	static CHAR szCRLF[] = "\r\n";

	DebugOutputNoCRLFFn(psz);

	//Temporarily disabled until we yank out all the "\n"s from the calling code.
	//OutputDebugStringA(szCRLF);
}


//	DebugTrapFn() -------------------------------------------------------------
//
typedef struct _MBCONTEXT
{
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;

} MBCONTEXT;

DWORD WINAPI
MessageBoxFnThreadMain(MBCONTEXT *pmbc)
{
	if (g_fUseEventLog)
	{
		LogIt (pmbc->sz1, TRUE);
		pmbc->iResult = IDIGNORE;
	}
	else
	{
		pmbc->iResult = MessageBoxA (NULL,
									 pmbc->sz1,
									 pmbc->sz2,
									 pmbc->rgf | MB_SETFOREGROUND);
	}
	return (0);
}

INT
MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE hThread;
	DWORD dwThreadId;
	MBCONTEXT mbc;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	mbc.sz1 = sz1;
	mbc.sz2 = sz2;
	mbc.rgf = rgf;
	mbc.iResult = IDRETRY;

	hThread = CreateThread (NULL,
							0,
							(PTHREAD_START_ROUTINE)MessageBoxFnThreadMain,
							&mbc,
							0,
							&dwThreadId);
	if (hThread != NULL)
	{
		WaitForSingleObject (hThread, INFINITE);
		CloseHandle (hThread);
	}

	SetLastError(dwErr);

	return mbc.iResult;
}

//	------------------------------------------------------------------------
//	DebugTrapFn
//
//	Main Assert/DebugTrap handling routine.
//
//	Meanings of the g_dwAssertFlags:
//
//#define ASSERTFLAG_IF_DEBUGGING	0x00000001
//#define ASSERTFLAG_POPUP			0x00000002
//#define ASSERTFLAG_KD_SAFE		0x00000004
//
//	0 -- (default if no inifile or unrecognized value in inifile)
//		Default behavior -- DebugBreak() and then dump our strings.
//		NOTE: HTTPEXT needs this to remain their default because
//		of the way that IIS runs their stress testing.  DO NOT CHANGE THIS!
//	ASSERTFLAG_IF_DEBUGGING
//		-- use MessageBox asserts only if no debugger attached.
//		Why not use MessageBox everywhere?
//		Because MessageBox lets all the other threads keep going,
//		so we lose some amount of the state of the assert.
//		If this flag is NOT set, or a debugger is NOT connected,
//		we obey the other flags.
//	ASSERTFLAG_POPUP
//		-- use MessageBox asserts.  Our MessageBox has three buttons:
//		Abort,Retry,Ignore do "*(0)=1",DebugBreak,go
//	ASSERTFLAG_KD_SAFE	
//		-- use HardCrash instead of DebugBreak
//		Use hard-av if debugger is attached.
//		(Option for devs with CDB and no KD attached, or for anyone
//		who wants to do ALL their debugging in KD! ;-)
//		Why not just DebugBreak() if a debugger is attached?
//		Because DebugBreak() will catch in the kernel debugger first --
//		so if I have a both kd and cdb hooked up, DebugBreak() will 
//		hit in the kd, even though this is user-mode code.
//
//	Alternate code for IsDebuggerPresent()
//		peb = NtCurrentPeb();
//		if (peb->BeingDebugged) ...
//
INT EXPORTDBG __cdecl
DebugTrapFn (int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
	char	sz[512];
	va_list	vl;
	int		id;
	static BOOL s_fBuiltDebugStrings = FALSE;
	static char s_rgchMessageBoxTitle[MAX_PATH];

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	if (ASSERTFLAG_UNINITIALIZED == g_dwAssertFlags)
	{
		//	Check the ini file.
		//	Pass in our default flags -- if there's no inifile, we'll
		//	get back our default.
		//
		g_dwAssertFlags = GetPrivateProfileIntA (gc_szDbgGeneral,
												 gc_szDbgPopupAsserts,
												 g_dwDefaultAssertFlags,
												 gc_szDbgIni);
	}

	//	Check our static flag to see if we've already built the
	//	title string for our Asserts/DebugTraces.
	//
	if (!s_fBuiltDebugStrings)
	{
		char * pch;
		lstrcpyA (s_rgchMessageBoxTitle, gc_szDbgIni);
		pch = strchr (s_rgchMessageBoxTitle, '.');
		if (pch)
			*pch = '\0';
		lstrcatA (s_rgchMessageBoxTitle, " Debug Assert");
		s_fBuiltDebugStrings = TRUE;
	}

	//	Build the assert strings and dump the first line.
	//
	lstrcpyA(sz, "++++ ");
	lstrcatA(sz, s_rgchMessageBoxTitle);
	lstrcatA(sz, " (");
	_strdate(sz + lstrlenA(sz));
	lstrcatA(sz, " ");
	_strtime(sz + lstrlenA(sz));
	lstrcatA(sz, ")\n");
	DebugOutputFn(sz);

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

	//	Check our assert flags
	//

	//	See if MessageBoxes are desired....
	//
	//	If the "msg-box-if-no-debugger" flag is set,
	//	and there is no debugger -- give 'em message boxes!
	//	If they specifically requested message boxes, give 'em message boxes.
	//
	if (((ASSERTFLAG_IF_DEBUGGING & g_dwAssertFlags) && !IsDebuggerPresent()) ||
		(ASSERTFLAG_POPUP & g_dwAssertFlags))
	{
		//	Use MessageBox asserts
		//
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		DebugOutputFn(sz);

		//	Always act as if we are a service (why not?)
		//
		uiFlags |= MB_ICONSTOP | MB_TASKMODAL | MB_SERVICE_NOTIFICATION;
		id = MessageBoxFn (sz, s_rgchMessageBoxTitle, uiFlags);
		if (id == IDABORT)
		{
			*((LPBYTE)NULL) = 0;
		}
		else if (id == IDRETRY)
			DebugBreak();
	}
	else if (ASSERTFLAG_KD_SAFE & g_dwAssertFlags)
	{
		//	Hard-av and then dump our string.
		//
		*((LPBYTE)NULL) = 0;
		DebugOutputFn(sz);
	}
	else
	{
		//	Do the default behavior:
		//	DebugBreak() and then dump our string.
		//
		DebugBreak();
		DebugOutputFn(sz);
	}

	SetLastError(dwErr);

	return 0;
}

//	------------------------------------------------------------------------
//	EnablePopupAsserts
//	Changes the default Assert flags to use popup asserts
//	NOTE: This value will be OVERRIDDEN by any inifile setting!
//
void EXPORTDBG __cdecl
EnablePopupAsserts ()
{
	g_dwDefaultAssertFlags = ASSERTFLAG_POPUP;
}

//$	HACK: Avoids problems introduced by the BUILD switch to _DEBUG
//
#ifdef _HTTPEXT_
#pragma message ("WARNING: hacking around _DEBUG problem")
int __cdecl _CrtDbgReport(
        int iReserved1,
        const char * fmt1,
        int iReserved2,
        const char * sz1,
        const char * sz2,
        ...)
{
	return 0;
}
#endif	// _HTTPEXT_

//	DebugTraceFn() ------------------------------------------------------------
//
INT EXPORTDBG __cdecl
DebugTraceFn(char *pszFormat, ...)
{
	//	hopefully, 4K is large enough
	char sz[4096];
	int fAutoLF = 0;
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	if (*pszFormat == '~')
	{
		pszFormat += 1;
		fAutoLF = 1;		//$REVIEW: where is this used?
	}

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	DebugOutputFn(sz);

	SetLastError(dwErr);

	return(0);
}

INT EXPORTDBG __cdecl
DebugTraceNoCRLFFn(char *pszFormat, ...)
{
	//	hopefully, 4K is large enough -- same limit as above...
	char sz[4096];
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	DebugOutputNoCRLFFn(sz);

	SetLastError(dwErr);

	return(0);
}

INT EXPORTDBG __cdecl
DebugTraceCRLFFn(char *pszFormat, ...)
{
	//	hopefully, 4K is large enough -- same limit as above...
	char sz[4096];
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	DebugOutputNoCRLFFn(sz);

	DebugOutputNoCRLFFn("\r\n");

	SetLastError(dwErr);

	return(0);
}


//	TraceErrorFn() ------------------------------------------------------------
//
INT EXPORTDBG __cdecl
TraceErrorFn (DWORD error, char *pszFunction,
				   char *pszFile, int iLine,
				   BOOL fEcTypeError)	// defaults to FALSE
{
	BOOL fTraceIt = FALSE;
	
	if (TRACEERROR_UNINITIALIZED == g_dwErrorTraceLevel)
	{
		g_dwErrorTraceLevel = GetPrivateProfileIntA (gc_szDbgGeneral,
			gc_szDbgErrorTrace,
			FALSE,
			gc_szDbgIni);
	}
	if (TRACEERROR_NONE == g_dwErrorTraceLevel)
		return 0;

	//	Logic for trace error levels:
	//	Error tracing, like all our tracing, is OFF by default.
	//	TRACEERROR_NONE			-- don't trace errors
	//	TRACEERROR_FAILED_SCODE -- trace only if FAILED(error)
	//	TRACEERROR_NATURAL		-- if fEcTypeError, use if (error)
	//							-- if !fEcTypeError, use if (FAILED(error))
	//	TRACEERROR_FAILING_EC	-- trace only if (error)
	//	TRACEERROR_ALWAYS		-- always trace
	//
	switch (g_dwErrorTraceLevel)
	{
	case TRACEERROR_FAILED_SCODE:
		if (FAILED(error))
			fTraceIt = TRUE;
		break;
	case TRACEERROR_FAILING_EC:
		if (0 != error)
			fTraceIt = TRUE;
		break;

	case TRACEERROR_ALWAYS:
		fTraceIt = TRUE;
		break;

	case TRACEERROR_NATURAL:
		if (fEcTypeError)
			fTraceIt = (0 != error);
		else
			fTraceIt = (FAILED(error));
		break;
	default:
		break;
	}

	if (fTraceIt)
	{
		char pszFormat[] = "%hs Error Trace: 0x%08x from function %hs (%hs line %d)\r\n";

		DebugTraceNoCRLFFn (pszFormat, gc_szDbgIni,
							error, pszFunction, pszFile, iLine);
	}

	return 0;
}


//	Call Stack (WIN32) --------------------------------------------------------
//
#define dwStackLimit	0x00010000		/*	64KB for NT */

void EXPORTDBG __cdecl
GetCallStack (DWORD *pdwCaller, int cSkip, int cFind)
{
#ifdef	_X86_
	DWORD *	pdwStack;
	DWORD *	pdwStackPrev = (DWORD *)0;
	DWORD	dwCaller;

	__asm mov pdwStack, ebp

	memset(pdwCaller, 0, cFind * sizeof(DWORD));

	while (cSkip + cFind > 0)
	{
		pdwStack = (DWORD *)*pdwStack;

		if (pdwStack <= (DWORD *)dwStackLimit ||
			pdwStackPrev >= pdwStack ||
			IsBadReadPtr(pdwStack, 2 * sizeof(DWORD)))
			break;

		dwCaller = *(pdwStack + 1);

		if (dwCaller <= dwStackLimit)
			break;
		else if (cSkip > 0)
			cSkip -= 1;
		else
		{
			*pdwCaller++ = dwCaller;
			cFind -= 1;

			pdwStackPrev = pdwStack;
		}
	}
#endif	// _X86_
}

//	Symbol names --------------------------------------------------------------
//
BOOL EXPORTDBG __cdecl
GetSymbolName (DWORD dwAddress,
	LPSTR rgchModule,
	LPSTR rgchFunc,
	DWORD * pdwDisp)
{
#ifdef	_X86_
	static BOOL fSymbolsLoaded = FALSE;
	static SYMINITIALIZE * pfnInit = NULL;
	static SYMGETMODULE * pfnGetModule = NULL;
	static SYMGETSYMBOL * pfnGetSymbol = NULL;
	static SYMUNDECORATE * pfnUndecorate = NULL;
	static HANDLE hlib = NULL;

	//	Ensure the sybols are loaded
	//
	if (hlib == NULL)
	{
		hlib = LoadLibraryA ("IMAGEHLP.DLL");
		if (hlib)
		{
			pfnInit = (SYMINITIALIZE *)GetProcAddress (hlib, "SymInitialize");
			pfnGetModule = (SYMGETMODULE *)GetProcAddress (hlib, "SymGetModuleInfo");
			pfnGetSymbol = (SYMGETSYMBOL *)GetProcAddress (hlib, "SymGetSymFromAddr");
			pfnUndecorate = (SYMUNDECORATE *)GetProcAddress (hlib, "SymUnDName");

			//	If we found all of the functions we need, then
			//	go ahead and load the critters
			//
			if (pfnInit && pfnGetModule && pfnGetSymbol && pfnUndecorate)
			{
				(*pfnInit) (GetCurrentProcess(), NULL, TRUE);
				fSymbolsLoaded = GetPrivateProfileIntA (gc_szDbgGeneral,
					gc_szDbgSymbolicDumps,
					FALSE,
					gc_szDbgIni);
			}
		}
	}

	//	If the symbols are loaded, then try to sus out the
	//	name of the fuction for the given address
	//
	if (fSymbolsLoaded)
	{
		IMAGEHLP_MODULE		mod;
		IMAGEHLP_SYMBOL	*	psym;
		BYTE				rgbBuffer[512];

		//	Initialize the module & symbol structures:
		//
		mod.SizeOfStruct	= sizeof ( IMAGEHLP_MODULE );
		psym = (IMAGEHLP_SYMBOL *) rgbBuffer;
		psym->SizeOfStruct	= sizeof ( IMAGEHLP_SYMBOL );
		psym->MaxNameLength	=
			sizeof ( rgbBuffer ) -
			sizeof ( IMAGEHLP_SYMBOL ) -
			10; 						// To be safe

		if ((*pfnGetModule) (GetCurrentProcess(), dwAddress, &mod))
		{
			lstrcpyA (rgchModule, mod.ModuleName);

			if ((*pfnGetSymbol) (GetCurrentProcess(),
								 dwAddress,
								 pdwDisp,
								 psym))
			{
				//	We have found a symbolic name for the
				//	function, use it!
				//
				(*pfnUndecorate) (psym, rgchFunc, CB_SYM_MAX);

				return TRUE;
			}
			else
			{
				//	Otherwise, we simply do not know the
				//	function name
				//
				wsprintfA (rgchFunc, "%08lX", dwAddress);
			}
		}
		else
			*rgchModule = '\0';
	}
	else
		*rgchModule = '\0';

#endif	// _X86_
	return FALSE;
}

#else

#if defined(_AMD64_)

//
// ****** temporary ******
//

int
DebugTrapFn (
    int fFatal,
    char *pszFile,
    int iLine,
    char *pszFormat,
    ...
    )
{
    return 0;
}

int
DebugTraceFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

int
DebugTraceCRLFFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

int
DebugTraceNoCRLFFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

#endif

#endif	//	DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_except\_except.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EXCEPT.H
//
//		EXCEPT precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_langid\langid.cpp ===
//	========================================================================
//
//	LANGID.CPP
//
//	DAV language id cache
//	Maps between MIME language identifiers and Win32 LCIDs.
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//
//	========================================================================

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4127)	//  conditional expression is constant
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Standard C/C++ headers
//
#include <malloc.h>	// For _alloca declaration ONLY!

//	Windows headers
//
#include <windows.h>

//	CAL headers
//
#include <caldbg.h>
#include <calrc.h>
#include <crc.h>
#include <ex\autoptr.h>
#include <ex\buffer.h>

#include <langid.h>

static LONG
LHexFromSz (LPCSTR psz)
{
	LONG lVal = 0;

	Assert (psz);
	Assert (*psz);

	do
	{
		lVal = lVal << 4;

		if (('0' <= *psz) && ('9' >= *psz))
			lVal += *psz - '0';
		else if (('A' <= *psz) && ('F' >= *psz))
			lVal += *psz - L'A' + 10;
		else if (('a' <= *psz) && ('f' >= *psz))
			lVal += *psz - 'a' + 10;
		else
			return 0;

	} while (*++psz);

	return lVal;
}

//	LcidFind() - lookup language ID from the locale.
//
LONG
CLangIDCache::LcidFind (LPCSTR pszLangID)
{
	LONG * plid;
	plid = Instance().m_cache.Lookup (CRCSzi(pszLangID));
	return plid ? *plid : 0;
}

//	FFillCacheData() for filling the cache with data
//
BOOL
CLangIDCache::FFillCacheData()
{
	BOOL fSuccess = FALSE;
	HKEY hkey = 0;
	CStackBuffer<CHAR,256> rgchKey;
	CStackBuffer<CHAR,256> rgchValue;
	LONG lRet;
	DWORD dwIndex = 0;

	//	Querying registry for buffer sizes
	//
	DWORD cchMaxKeyLen;			// longest value name length (in characters without zero termination)
	DWORD cbMaxKeyLen;			// longest value name length (in bytes, including zero termination)
	DWORD cbMaxValueLen;		// longest value data length (in bytes, including zero termination)

	//	Load all thet lang ID's that come from the registry
	//
	lRet = RegOpenKeyExA (HKEY_CLASSES_ROOT,
						  "MIME\\DATABASE\\RFC1766",
						  0,
						  KEY_READ,
						  &hkey);
	if (ERROR_SUCCESS != lRet)
	{
		DebugTrace("LANGID: Failed to get MIME\\DATABASE\\RFC1766 registry key handle, error code 0x%08X.\n", lRet);
		goto ret;
	}

	//	Query for the length of the longest value name and for the length of the longest data piece under the key we have got.
	//	That will give us enough information about what size buffers we need for querying.
	//
	lRet = RegQueryInfoKeyA(hkey,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							&cchMaxKeyLen,			//	Value names come back in number of characters
							&cbMaxValueLen,			//	Data length comes back in number of bytes
							NULL,
							NULL);
	if (ERROR_SUCCESS != lRet)
	{
		DebugTrace("LANGID: Failed to get registry key MIME\\DATABASE\\RFC1766 max data length buffer sizes, error code 0x%08X.\n", lRet);
		goto ret;
	}

	//	Calculate maximum number of bytes needed for the value name
	//
	cbMaxKeyLen = (cchMaxKeyLen + 1) * sizeof(CHAR);

	//	Allocate the query buffers on the stack
	//
	if ((NULL == rgchKey.resize(cbMaxKeyLen)) ||
		(NULL == rgchValue.resize(cbMaxValueLen)))
		goto ret;

	do
	{
		DWORD cbKey		= cbMaxKeyLen;
		DWORD cbValue	= cbMaxValueLen;
		DWORD dwType;
		LPSTR pch;
		LONG lLangId;

		lRet = RegEnumValueA(hkey,
							 dwIndex++,
							 rgchKey.get(),
							 &cbKey,
							 NULL,
							 &dwType,
							 reinterpret_cast<LPBYTE>(rgchValue.get()),
							 &cbValue);
		if (ERROR_NO_MORE_ITEMS == lRet)
			break;

		//	Encountering unknown error code is a failure
		//
		if (ERROR_SUCCESS != lRet)
		{
			DebugTrace("LANGID: Failed to query registry key MIME\\DATABASE\\RFC1766 data with error code 0x%08X.\n", lRet);
			goto ret;
		}

		//	Skip unacceptable types.
		//
		if (REG_SZ != dwType)
			continue;

		//	Find the semi-colon that separates the ID from the name
		//	and terminate the ID.
		//
		pch = strchr (rgchValue.get(), ';');
		if (pch != NULL)
			*pch++ = '\0';

		//	Persist the name and add the key to the cache
		//
#ifdef	DBG
		if (NULL != Instance().m_cache.Lookup (CRCSzi(rgchValue.get())))
			DebugTrace ("Dav: language identifier repeated (%hs)\n", rgchValue.get());
#endif	// DBG

		//	If making the copy of the string failed... Well we can live with it.
		//
		pch = Instance().m_sb.Append (
			static_cast<UINT>((strlen (rgchValue.get()) + 1) * sizeof(CHAR)),
			rgchValue.get());
		if (!pch)
			continue;	//	Skip addition to the cache if allocation failed so we do not crash in CRCSzi(pch).

		//	If we did not succeeded adding to the cache... Well we can live with it too.
		//
		lLangId = LHexFromSz(rgchKey.get());
		if (0 != lLangId)
		{
			(void)Instance().m_cache.FSet (CRCSzi(pch), lLangId);
		}

	} while (TRUE);

	//	Set in one ISO language code which W2K forgot in RTM bits (2195)
	//
	(void)Instance().m_cache.FSet ("fr-mc", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH_MONACO));

	//	Set in some additional ISO language codes supported by Navigator,
	//	but not present in the Windows registry.
	//
	(void)Instance().m_cache.FSet ("fr-fr", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("de-de", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("es-es", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH));

	//	Set in some of the known three-char language identifiers.
	//	We can live without them if addition to the cache failed.
	//
	(void)Instance().m_cache.FSet ("eng", MAKELANGID (LANG_ENGLISH,SUBLANG_ENGLISH_US));
	(void)Instance().m_cache.FSet ("fra", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("fre", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("deu", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("ger", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("esl", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH_MODERN));
	(void)Instance().m_cache.FSet ("spa", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH_MODERN));

	fSuccess = TRUE;

ret:

	if (hkey)
	{
		RegCloseKey (hkey);
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_exo\nonimpl.cpp ===
/*
 *	N O N I M P L . C P P
 *
 *	Base classes for COM interfaces with no functionality except IUnknown.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>

#include <nonimpl.h>

//	CStreamNonImpl class ------------------------------------------------------
//
BEGIN_INTERFACE_TABLE(CStreamNonImpl)
	INTERFACE_MAP(CStreamNonImpl, IStream)
END_INTERFACE_TABLE(CStreamNonImpl);

EXO_GLOBAL_DATA_DECL(CStreamNonImpl, EXO);

//	CPersistStreamInitNonImpl class -----------------------------------------------
//
BEGIN_INTERFACE_TABLE(CPersistStreamInitNonImpl)
	INTERFACE_MAP(CPersistStreamInitNonImpl, IPersistStreamInit)
END_INTERFACE_TABLE(CPersistStreamInitNonImpl);
	
EXO_GLOBAL_DATA_DECL(CPersistStreamInitNonImpl, EXO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_idlethd\idlethrd.cpp ===
/*=========================================================================*\

	Module:      idlethrd.cpp

	Copyright Microsoft Corporation 1998, All Rights Reserved.

	Author:      zyang

	Description: Idle thread implementation

\*=========================================================================*/

#include <windows.h>
#include <limits.h>
#include <caldbg.h>
#include <ex\exmem.h>
#include <ex\autoptr.h>
#include <ex\idlethrd.h>

#pragma warning(disable:4127)	// 	conditional expression is constant
#pragma warning(disable:4244)	//	possible loss of data

class CIdleThread;

//	Globals
//
CIdleThread * g_pIdleThread = NULL;

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(IdleThrd);
#define IdleThrdTrace		DO_TRACE(IdleThrd)

enum
{
	EVENT_SHUTDOWN = WAIT_OBJECT_0,
	EVENT_REGISTER = WAIT_OBJECT_0 + 1
};

//	class CIdleThread
//
//		This is the idle thread implementation. it accept clients callback
//	registration, and call back to the client when timeout.
//
//		Instead of periodically wake up the thread, we maitain the minimal
//	time to wait, so that we wake only when it is necessary.
//
//		As there could be a huge number of the registrations, so we maintain
//	a heap ordered by their next timeout value. so that we don't have to
//	iterate through all the registrations each time.
//
//		When the callback is registered, DwWait will be called to get
//	initial timeout. Client can return zero thus cause the Execute be called
//	immediately.
//
class CIdleThread
{
private:

	struct REGISTRATION
	{
		__int64 	m_i64Wakeup;			// Time to wake up
		auto_ref_ptr<IIdleThreadCallBack> m_pCallBack;	// Call back object
	};

	struct IDLETHREADTASKITEM
	{
		BOOL		m_fRegister;			// TRUE - register,
											// FALSE - unregister
		auto_ref_ptr<IIdleThreadCallBack> m_pCallBack;	// Call back object
	};

	// Default starting chunk size (in number of registrations)
	//
	enum {
#ifdef DBG
	CHUNKCOUNT_START = 2	//	must be 2 or greater, as our first reg starts at index 1
#else
	CHUNKCOUNT_START = 8192 / sizeof (REGISTRATION)
#endif
	};

	HANDLE		m_hIdleThread;
	HANDLE 		m_hevShutDown;		// signaled to inform the idle
									// thread to shutdown
	HANDLE 		m_hevRegister;		// signaled when new registration
									// comes.

	CRITICAL_SECTION 	m_csRegister;	//	Used to serialize registration operations

	ULONG		m_cSize;			//	Length of the current priority queue
	ULONG		m_cAllocated;		//	Size of the physical array allocated

	REGISTRATION * m_pData;			//	The registration priority queue.
									//	prioritized on the wake up time.
	LONG		m_lSleep;			//	Time to sleep before wakeup.
									//	Negative or 0 means wakeup immediately.
									//	To sleep forever, use LONG_MAX instead
									//	of INFINITE because INFINITE (as a LONG)
									//	is a *negative* number (i.e. it would be
									//	interpreted as wake up immediately).

	IDLETHREADTASKITEM * m_pTask;	//	Array of reg/unregs to be processed
	ULONG		m_cTask;			//	number of reg/unregs to be processed
	ULONG		m_cTaskAllocated;	//	size of the array

	BOOL	FStartIdleThread();

	static DWORD __stdcall DwIdleThreadProc(PVOID pvThreadData);

	inline VOID	HeapAdd ();
	inline VOID	HeapDelete (ULONG ulIndex);

	//$HACK
	//	In order to avoid calling SetIndex on the deleted object
	//	in Exchange, we pass in a flag to indicate whether this
	//	Exchange() call is to delete a node, if so, then we should
	//	not call SetIndex on the node that is at the end of the queue
	//	(which is to be deleted)
	//$HACK
	inline VOID	Exchange (ULONG ulIndex1, ULONG ulIndex2, BOOL fDelete = FALSE);
	inline VOID	Heapify (ULONG ulIndex);

	VOID 	EnterReg() { EnterCriticalSection (&m_csRegister); }
	VOID 	LeaveReg() { LeaveCriticalSection (&m_csRegister); }

	//	non-implemented
	//
	CIdleThread( const CIdleThread& );
	CIdleThread& operator=( const CIdleThread& );

public:
	CIdleThread () :
		m_cSize (0),
		m_cAllocated (0),
		m_lSleep (LONG_MAX),
		m_pData (NULL),
		m_pTask (NULL),
		m_cTaskAllocated (0),
		m_cTask (0),
		m_hIdleThread (NULL),
		m_hevShutDown (NULL),
		m_hevRegister (NULL)
	{
		INIT_TRACE (IdleThrd);
		InitializeCriticalSection (&m_csRegister);
	}

	~CIdleThread();

	BOOL FAddNewTask (IIdleThreadCallBack * pCallBack, BOOL fRegister);
};

//	CIdleThread::DwIdleThreadProc
//		This is idle thread implementation.
//
DWORD __stdcall CIdleThread::DwIdleThreadProc(PVOID pvThreadData)
{
	//	Get the CIdlThread object
	//
	CIdleThread * pit =  reinterpret_cast<CIdleThread *>(
		pvThreadData );
	HANDLE rgh[2];
	FILETIME ftNow;
	DWORD	dw;

	//	This thread wait for two events:
	//		shutdown event, and
	//		register event.
	//
	rgh[0] = pit->m_hevShutDown;
	rgh[1] = pit->m_hevRegister;

	//	This thread maintains a mininum timeout it could wait.
	//	and would wake up when it tiemouts

	do
	{
		DWORD dwRet;

		dwRet = WaitForMultipleObjects(2, 		//	two events
									   rgh,  	//	event handles
									   FALSE,	//	return if any event signaled
									   pit->m_lSleep);// 	timeout in milliseconds.

		//	If our shutdown event handle was signalled, suicide.
		//	(OR if the event object is gonzo....)
		//
		switch (dwRet)
		{
			case WAIT_TIMEOUT:

				//$REVIEW
				//	How accurate do we use the time? is a snapshot like this enough?
				//	or we may need to this inside the loop
				//
				GetSystemTimeAsFileTime( &ftNow );

				//	Now that Unregister is supported, we need to check the size of
				//	the heap before we call back, as it's possible the call back
				//	has been unregistered.
				//
				while (pit->m_cSize &&
					   (pit->m_pData[1].m_i64Wakeup <= *(__int64 *)(&ftNow)))
				{
					//	Call back to client
					//	Unregister if client required
					//
					Assert (pit->m_pData[1].m_pCallBack->UlIndex() == 1);
					if (!pit->m_pData[1].m_pCallBack->FExecute())
					{
						pit->m_pData[1].m_pCallBack.clear();

						//$HACK
						//	In order to avoid calling SetIndex on the deleted object
						//	in Exchange, we pass in a flag to indicate whether this
						//	Exchange() call is to delete a node, if so, then we should
						//	not call SetIndex on the node that is at the end of the queue
						//	(which is to be deleted)
						//$HACK
						pit->Exchange (1, pit->m_cSize, TRUE);
						pit->m_cSize--;
						if (!pit->m_cSize)
							break;
					}
					else
					{
						//	Get the next wakeup time
						//	1 millisecond = 10,000 of 100-nanoseconds
						//
						pit->m_pData[1].m_i64Wakeup = *(__int64 *)(&ftNow) +
								static_cast<__int64>(pit->m_pData[1].m_pCallBack->DwWait()) * 10000;
					}

					//	Get the next value
					//
					pit->Heapify(1);
				}

				//	Compute how long to wait before the next timeout
				//
				if (!pit->m_cSize)
					pit->m_lSleep = LONG_MAX;
				else
				{
					pit->m_lSleep = (pit->m_pData[1].m_i64Wakeup - *(__int64 *)(&ftNow)) / 10000;
					if (pit->m_lSleep < 0)
					{
						IdleThrdTrace ("Dav: Idle: zero or negative sleep: idle too active?");
						pit->m_lSleep = 0;
					}
				}

				IdleThrdTrace ("Dav: Idle: next idle action in:\n"
							   "- milliseconds: %ld\n"
							   "- seconds: %ld\n",
							   pit->m_lSleep,
							   pit->m_lSleep / 1000);
				break;

			case EVENT_REGISTER:
			{
				ULONG	ul;
				ULONG	ulNew;

				//	Register the callback and obtain the initial timeout setting

				//$REVIEW
				//	How accurate do we use the time? is a snapshot like this enough?
				//	or we may need to this inside the loop
				//
				GetSystemTimeAsFileTime( &ftNow );

				//	It's possbile we've processed all the new regs in the
				//	last time we were signaled
				//
				if (!pit->m_cTask)
					break;

				//	Make sure no one would add a new reg when we process the
				//	new regs
				//
				pit->EnterReg();

				//	Expand the queue to the maximum possible required length
				//
				if (pit->m_cSize + pit->m_cTask >= pit->m_cAllocated)
				{
					REGISTRATION * pData = NULL;
					ULONG	cNewSize = 0;

					if (!pit->m_pData)
					{
						//	Initial size of the priority queue
						//$Note: we need at least one more slot for exchange
						//
						cNewSize = max(pit->m_cTask + 1, CHUNKCOUNT_START);

						pData = static_cast<REGISTRATION *>(ExAlloc (
							cNewSize * sizeof (REGISTRATION)));

					}
					else
					{
						//	Double the size, to get "logarithmic allocation behavior"
						//
						cNewSize  = (pit->m_cSize + pit->m_cTask) * 2;

						//	Realloc the array
						//	If the realloc fails, the original remain unchanged
						//
						pData = static_cast<REGISTRATION *>(ExRealloc (pit->m_pData,
							cNewSize * sizeof(REGISTRATION)));
					}

					//	It's possible that allocation failed
					//
					if (!pData)
					{
						//$REVIEW: Anything else can we do other than a debugtrace ?
						//
						IdleThrdTrace ("Cannot allocate more space\n");
						break;
					}

					//	Initialize
					//
					ZeroMemory (pData + pit->m_cSize + 1,
								sizeof(REGISTRATION) * (cNewSize - pit->m_cSize - 1));

					//	Update information
					//
					pit->m_pData = pData;
					pit->m_cAllocated = cNewSize;

					IdleThrdTrace ("priority queue size = %d\n", pit->m_cAllocated);
				}

				for (ul=0; ul < pit->m_cTask; ul++)
				{
					if (pit->m_pTask[ul].m_fRegister)
					{
						//	New position of the reg
						//
						ulNew = pit->m_cSize + 1;

						IdleThrdTrace ("Dav: Idle: add new reg %x\n", pit->m_pTask[ul].m_pCallBack.get());

						dw = pit->m_pTask[ul].m_pCallBack->DwWait();
						pit->m_pData[ulNew].m_pCallBack.take_ownership (pit->m_pTask[ul].m_pCallBack.relinquish());

						//	dw is give in milliseconds, FILETIME unit is 100-nanoseconds.
						//
						pit->m_pData[ulNew].m_i64Wakeup = *(__int64 *)(&ftNow) +
									static_cast<__int64>(dw) * 10000;

						//	Update the index
						//
						pit->m_pData[ulNew].m_pCallBack->SetIndex(ulNew);

						// Add to the heap, m_cSize is updated inside
						//
						pit->HeapAdd();
					}
					else
					{
						Assert (pit->m_pTask[ul].m_pCallBack->UlIndex() <= pit->m_cSize);

						IdleThrdTrace ("Dav: Idle: delete reg %x\n", pit->m_pTask[ul].m_pCallBack.get());

						//	Delete from the priority queue, m_cSize is updated inside
						//	it also release our ref on the deleted object
						//
						pit->HeapDelete (pit->m_pTask[ul].m_pCallBack->UlIndex());

						pit->m_pTask[ul].m_pCallBack.clear();
					}
				}

				//	Now that all task item are processed, reset
				//
				pit->m_cTask = 0;

				//	Done with the task array
				//
				pit->LeaveReg();

				//	Compute the mininum time to wait
				//
				if (pit->m_cSize)
				{
					pit->m_lSleep = (pit->m_pData[1].m_i64Wakeup -
								*(__int64 *)(&ftNow)) / 10000;
					if (pit->m_lSleep < 0)
					{
						IdleThrdTrace ("Dav: Idle: zero or negative sleep: "
									   "idle too active?");
						pit->m_lSleep = 0;
					}
				}
				else
					pit->m_lSleep = LONG_MAX;

				break;
			}

			default:
				//	Either shutdown event is signaled or other failure
				//
#ifdef DBG
				if (dwRet != EVENT_SHUTDOWN)
				{
					IdleThrdTrace ("Dav: Idle: thread quit because of failure\n");
					if (WAIT_FAILED == dwRet)
					{
						IdleThrdTrace ("Dav: Idle: last error = %d\n", GetLastError());
					}
				}
#endif
				for (UINT i = 1; i <= pit->m_cSize; i++)
				{
					//	Tell clients that the idle thread is being shutdown
					//
					Assert (pit->m_pData[i].m_pCallBack->UlIndex() == i);
					pit->m_pData[i].m_pCallBack->Shutdown ();
					pit->m_pData[i].m_pCallBack.clear();
				}

				IdleThrdTrace ("Dav: Idle: thread is stopping\n");

				//	Shutdown this thread
				//
				return 0;
		}

	} while (TRUE);
}

CIdleThread::~CIdleThread()
{
	if (m_hevShutDown && INVALID_HANDLE_VALUE != m_hevShutDown)
	{
		//	Signal the idle thread to shutdown
		//
		SetEvent(m_hevShutDown);

		//	Wait for the idle thread to shutdown
		//
		WaitForSingleObject(m_hIdleThread, INFINITE);
	}

	CloseHandle (m_hevShutDown);
	CloseHandle (m_hevRegister);

	//$REVIEW
	//	Do I need to close the thread handle?
	//$REVIEW
	//	Yes,
	//
	CloseHandle (m_hIdleThread);

	DeleteCriticalSection (&m_csRegister);

	//	Free our array of items.
	ExFree (m_pData);
	ExFree (m_pTask);

	IdleThrdTrace ("DAV: Idle: CIdleThread destroyed\n");
}

//
//	CIdleThread::FStartIdleThead
//
//		Helper method to start the idle thread and create the events
//
BOOL
CIdleThread::FStartIdleThread()
{
	BOOL	fRet = FALSE;
	DWORD	dwThreadId;

	m_hevShutDown = CreateEvent(	NULL, 	// handle cannot be inherited
									FALSE, 	// auto reset
									FALSE,  // nosignaled
									NULL);	// no name
	if (!m_hevShutDown)
	{
		IdleThrdTrace( "Failed to create event: error: %d", GetLastError() );
		TrapSz( "Failed to create idle thread event" );
		goto ret;
	}

	m_hevRegister = CreateEvent(	NULL, 	// handle cannot be inherited
									FALSE, 	// auto reset
									FALSE,  // nosignaled
									NULL);	// no name
	if (!m_hevRegister)
	{
		IdleThrdTrace( "Failed to create register event: error: %d", GetLastError() );
		TrapSz( "Failed to create register event" );
		goto ret;
	}

	m_hIdleThread = CreateThread( NULL,
								   0,
								   DwIdleThreadProc,
								   this,
								   0,	//	Start immediately -- no need to resume...
								   &dwThreadId );
	if (!m_hIdleThread)
	{
		IdleThrdTrace( "Failed to create thread: error: %d", GetLastError() );
		TrapSz( "Failed to create Notif Cache Timer thread" );
		goto ret;
	}

	fRet = TRUE;

ret:
	if (!fRet)
	{
		if (m_hevShutDown)
		{
			if (m_hevRegister && (INVALID_HANDLE_VALUE != m_hevRegister))
			{
				CloseHandle (m_hevRegister);
				m_hevRegister = NULL;
			}

			CloseHandle (m_hevShutDown);
			m_hevShutDown = NULL;
		}
	}
	return fRet;
}

//
//	CIdleThread::HeapAdd
//
//		Add the the next node into the priority queue
//
inline
VOID
CIdleThread::HeapAdd ()
{
	ULONG	 ulCur = m_cSize + 1;
	ULONG	ulParent;

	Assert (m_pData);

	//	We go bottom up, compare the node with the parent node,
	//	exchange the two nodes if the child win. it stops when
	//	the parent win.
	//
	while ( ulCur != 1)
	{
		ulParent = ulCur >> 1;
		if (m_pData[ulParent].m_i64Wakeup <= m_pData[ulCur].m_i64Wakeup)
			break;

		Exchange (ulCur, ulParent);

		ulCur = ulParent;
	}

	m_cSize++;
}

//
//	CIdleThread::HeapDelete
//
//		Delete an arbitary node from the priority queue
//
inline
VOID
CIdleThread::HeapDelete (ULONG ulIndex)
{
	Assert (ulIndex <= m_cSize);

	//	Exchange the node to the end of the queue first
	//	then heapify to maintain the heap property
	//
	//$HACK
	//	In order to avoid calling SetIndex on the deleted object
	//	in Exchange, we pass in a flag to indicate whether this
	//	Exchange() call is to delete a node, if so, then we should
	//	not call SetIndex on the node that is at the end of the queue
	//	(which is to be deleted)
	//$HACK
	Exchange (ulIndex, m_cSize, TRUE);
	m_cSize--;
	Heapify (ulIndex);
	
	//	Must Release our ref. m_cSize+1 is the one just deleted
	//
	m_pData[m_cSize+1].m_pCallBack.clear();
}

//
//	CIdleThread::Exchange
//
//		Exchange two nodes
//
//$HACK
//	In order to avoid calling SetIndex on the deleted object
//	in Exchange, we pass in a flag to indicate whether this
//	Exchange() call is to delete a node, if so, then we should
//	not call SetIndex on the node that is at the end of the queue
//	(which is to be deleted)
//$HACK
inline
VOID
CIdleThread::Exchange (ULONG ulIndex1, ULONG ulIndex2, BOOL fDelete)
{
	Assert ((ulIndex1 != 0) && (ulIndex1 <= m_cAllocated) &&
			(ulIndex2 != 0) && (ulIndex2 <= m_cAllocated));

	if (ulIndex1 != ulIndex2)
	{
		//	Use the 0th node as the temp node
		//
		CopyMemory (m_pData, m_pData + ulIndex1, sizeof(REGISTRATION));
		CopyMemory (m_pData + ulIndex1, m_pData + ulIndex2, sizeof(REGISTRATION));
		CopyMemory (m_pData + ulIndex2, m_pData, sizeof(REGISTRATION));

		//	Remember the index to facilitate unregister
		//	Note the index is set if only the node is not deleted
		//
		if (!((ulIndex1 == m_cSize) && fDelete))
			m_pData[ulIndex1].m_pCallBack->SetIndex (ulIndex1);

		if (!((ulIndex2 == m_cSize) && fDelete))
			m_pData[ulIndex2].m_pCallBack->SetIndex (ulIndex2);
	}
}

//
//	CIdleThread::Heapify
//
//		Maintain the heap property
//
inline
VOID
CIdleThread::Heapify (ULONG ulIndex)
{
	ULONG ulLeft;
	ULONG ulRight;
	ULONG ulWin;

	Assert (m_pData);

	while (ulIndex <= m_cSize)
	{
		//	Find out the winner (i.e. the one with earlier wakeup time)
		//	between the parent and left node.
		//
		ulLeft = ulIndex * 2;
		if (ulLeft > m_cSize)
			break;
		if (m_pData[ulIndex].m_i64Wakeup > m_pData[ulLeft].m_i64Wakeup)
			ulWin = ulLeft;
		else
			ulWin = ulIndex;

		//	Compare with the right node, and find out the final winner
		//
		ulRight = ulLeft + 1;
		if (ulRight <= m_cSize)
		{
			if (m_pData[ulWin].m_i64Wakeup > m_pData[ulRight].m_i64Wakeup)
				ulWin = ulRight;
		}

		//	If the parent node is already the winner, then we are done,
		//
		if (ulIndex == ulWin)
			break;

		//	Otherwise, exchange the parent node and winner node,
		//
		Exchange (ulWin, ulIndex);
		
		ulIndex = ulWin;
	}
}

//
//	CIdleThread::FAddNewTask
//
//		Called by client to register or unregister a callback object
//
BOOL
CIdleThread::FAddNewTask (IIdleThreadCallBack * pCallBack, BOOL fRegister)
{
	BOOL	fRet = TRUE;

	//	Caller must garantee a valid callback object
	//
	Assert (pCallBack);

	EnterReg();

	Assert (!m_cTaskAllocated || (m_cTask <= m_cTaskAllocated));

	//	Allocate more space if necessary
	//
	if (m_cTask == m_cTaskAllocated)
	{
		IDLETHREADTASKITEM * pTask = NULL;
		ULONG	cNewSize = 0;

		if (!m_pTask)
		{
			Assert (m_cTask == 0);

			//	Initial size of the priority queue
			//	Starting at 8, we don't expect this queue will grow too big
			//
			cNewSize = 8;

			//	Start idle thread when add the first registration
			//
			if (!FStartIdleThread ())
			{
				fRet = FALSE;
				goto ret;
			}

			pTask = static_cast<IDLETHREADTASKITEM *>(ExAlloc (
				cNewSize * sizeof (IDLETHREADTASKITEM)));
		}
		else
		{
			//	Double the size, to get "logarithmic allocation behavior"
			//
			cNewSize  = m_cTaskAllocated * 2;

			//	Realloc the array
			//	If the realloc fails, the original remain unchanged
			//
			pTask = static_cast<IDLETHREADTASKITEM *>(ExRealloc (m_pTask,
					cNewSize * sizeof(IDLETHREADTASKITEM)));
		}

		//	It's possible that allocation failed
		//
		if (!pTask)
		{
			fRet = FALSE;
			goto ret;
		}

		//	Must initialize, otherwise, we may start with uninitialize auto_ref_ptr
		//
		ZeroMemory (pTask + m_cTask, sizeof(IDLETHREADTASKITEM) * (cNewSize - m_cTask));

		//	Update information
		//
		m_pTask = pTask;
		m_cTaskAllocated = cNewSize;

		IdleThrdTrace ("Taskitem queue size = %d\n", m_cTaskAllocated);
	}

	//	Remember the new registration
	//
	m_pTask[m_cTask].m_pCallBack = pCallBack;
	m_pTask[m_cTask].m_fRegister = fRegister;
	m_cTask++;

	IdleThrdTrace ("New reg %x added at %d\n", pCallBack, m_cTask-1);

ret:
	LeaveReg();

	//	Inform the idle thread that new registration arrived
	//
	if (fRet)
		SetEvent (m_hevRegister);

	return fRet;
}

//	FInitIdleThread
//
//	Initialize the idle thread object. It can be out only once,
//	Note this call only initialize the CIdleThread object, the
//	idle thread is not started until the first registration
//
BOOL	FInitIdleThread()
{
	Assert (!g_pIdleThread);

	g_pIdleThread = new CIdleThread();

	return (g_pIdleThread != NULL);
}

//	FDeleteIdleThread
//
//	Delete the idle thread object. again, it can be called only once.
//
//	Note this must be called before any other uninitialization work,
//	Because we don't own a ref to the callback object, all what we
//	have is a pointer to the object. in the shutdown time, we must
//	clear all the callback registration before the callback object
//	go away.
//
VOID	DeleteIdleThread()
{
	if (g_pIdleThread)
		delete g_pIdleThread;
}

//	FRegister
//
//	Register a callback
//
BOOL	FRegister (IIdleThreadCallBack * pCallBack)
{
	Assert (g_pIdleThread);

	return g_pIdleThread->FAddNewTask (pCallBack, TRUE);
}

VOID 	Unregister (IIdleThreadCallBack * pCallBack)
{
	Assert (g_pIdleThread);
 	g_pIdleThread->FAddNewTask (pCallBack, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_locks\statetok.cpp ===
/*
 *	S T A T E T O K. C P P
 *
 *	Sources implementation of DAV-Lock common definitions.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_locks.h"

//	This is the character that will be part of the opaquelocktoken
//	for transaction tokens.
//
DEC_CONST WCHAR gc_wszTransactionOpaquePathPrefix[] = L"XN";
DEC_CONST UINT gc_cchTransactionOpaquePathPrefix = CchConstString(gc_wszTransactionOpaquePathPrefix);

/*
 *	This file contains the definitions used for parsing state token
 *	relared headers.
 *
 *	
 *	If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
 *	No-tag-list = List
 *	Tagged-list = Resource 1*List
 *	Resource = Coded-url
 *	List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
 *	State-token = Coded-url
 *	Coded-url = "<" URI ">"
 *
 *$BIG NOTE
  *	If headers are used for two things - once to check preconditions
 *	of the operation and once to find out the lock contexts to be
 *	used for the operation. The second part differs in store and fs
 *	implementations - since in fs we look for the lock only if the
 *	operation fails because of lock conflict. In our store implementation we have
 *	lock contexts added to the login before we start the operation.
 *	But if-header asks us to use only certain tokens with certain resources.
 *	We fall short here in the store implementation.
 *
 *	Precondition checking should behave exactly the same in the two impls.
 *
 *	Notes on the match operator:
 *	We use the caller defined match operator to determine whether the
 *	resource (resource path) statisfies the condition. For non-tagged
 *	production this condition is applied for (each of) the original
 *	operand resources for the verb. We pass the recursive flag to
 *	check for all sub-resources or not. In the case of tagged production,
 *	it is little more complex - first for each tagged path the parser
 *	determines whether it comes under the scope of the operation or
 *	not. If it does come under the scope we call the operator to apply
 *	the condition check. Here we do not want the match to be applied to
 *	the child resources and the recursive flag is set to FALSE;
 *	
 */


/*
 -	CIfHeadParser
 -
 *	This is used for syntax parse of the If: header as opposed to the
 *	tokenization done by the IFITER.
 *
 *
 */

class CIfHeadParser
{
private:

	//	The header string
	//
	LPCWSTR	 m_pwszHeader;

	//	BOOL flag indicating if it is a tagged production or not
	//
	BOOL	 m_fTagged;

	//	Bool flag to indicate child resource processing.
	//	The flag is set differently for tag and non-tag
	//	productions. However the meaning of the flag is
	//	consistent - it is used to tell the matchop if
	//	we want it to look the children of the given
	//	resource.
	//
	BOOL	m_fRecursive;

    SCODE   ScValidateTagged(LPCWSTR pwszPath);
    SCODE   ScValidateNonTagged(LPCWSTR rgpwszPaths[], DWORD cPaths, SCODE * pSC);

	//	Takes an array of pointers to paths and an array of bool-flags.
	//	Requires the size of the arrays (should be same).
	//
	SCODE	ScValidateList(IN LPCWSTR *ppwszPathList, IN DWORD crPaths, OUT BOOL *pfMatch);

	SCODE	ScMatch(LPCWSTR pwszPath);

	//	Very private member shared by our methods
	//	to keep track of current parse head.
	//
	LPCWSTR	m_pwszParseHead;

	//	String parser
	//
	IFITER	m_iter;

	//	Match operator given to us.
	//
	CStateMatchOp	*m_popMatch;

	//	NOT IMPLEMENTED
	//
	CIfHeadParser( const CIfHeadParser& );
	CIfHeadParser& operator=( const CIfHeadParser& );

public:

	//	Useful consts
	//
	enum
	{
		TAG_HEAD  =	L'<',
		TAG_TAIL  = L'>',
		ETAG_HEAD = L'[',
		ETAG_TAIL = L']',
		LIST_HEAD = L'(',
		LIST_TAIL =	L')'   
	};

	CIfHeadParser (LPCWSTR pwszHeader, CStateMatchOp *popMatch) :
			m_pwszHeader(pwszHeader),
			m_iter(pwszHeader),
			m_popMatch(popMatch)
	{
		Assert(pwszHeader);

		m_pwszParseHead = const_cast<LPWSTR>(pwszHeader);

		while (*m_pwszParseHead && iswspace(*m_pwszParseHead))
			m_pwszParseHead++;

		//	Checks if the header is a tagged or non-tagged production.
		//	If we find a "Coded-URI" (a URIs inside angle brackets, <uri>)
		//	before the first list (before the first "(" char)
		//	then we have a tagged production.
		//
		m_fTagged = (TAG_HEAD == *m_pwszParseHead);
	}

	~CIfHeadParser()
	{
	}

	//	Apply the if header production to the paths.
	//	Path2 is optional. fRecursive says if the validation
	//	is to be done to all children of the given path(s).
	//	We may need to change the interface to support a list
	//	of paths so that we can use it in Batch methods as well.
	//
	SCODE ScValidateIf(LPCWSTR rgpwszPaths[], DWORD cPaths, BOOL fRecursive = FALSE, SCODE * pSC = NULL);
};



//	--------------------------------------------------------------------------------
//	----------------------------- Free Helper Functions ----------------------------
//	--------------------------------------------------------------------------------

/*
 -	PwszSkipCodes
 -
 *	
 *	skip white spaces and the delimiters in a tagged string part
 *	of an if-header. We expect the codes to be <> or [].
 *
 *	*pdwLen must be zero or actual length of the input string.
 *	when the call returns it will have the length of the token san
 *	LWS and tags.
 *
 */
LPCWSTR
PwszSkipCodes(IN LPCWSTR pwszTagged, IN OUT DWORD *pcchLen)
{
	LPCWSTR	pwszTokHead = pwszTagged;
	DWORD	cchTokLen;

	Assert(pcchLen);

	//	find the actual length, if not specified
	//
	if (! *pcchLen)
		*pcchLen = static_cast<DWORD>(wcslen(pwszTokHead));

	cchTokLen = *pcchLen;
	
	//	Calculate relevant token length skipping LWS in the
	//	head and tail.
	//
	//	Skip any LWS near the head
	//
	while((*pwszTokHead) && (iswspace(*pwszTokHead)) && (cchTokLen > 0))
	{
		cchTokLen--;
		pwszTokHead++;
	}

	//	Skip any LWS near the tail
	//
	while(iswspace(pwszTokHead[cchTokLen-1]) && (cchTokLen  > 0))
	{
		cchTokLen--;
	}

	//	At least two characters are expected now
	//
	if (cchTokLen < 2)
	{
		*pcchLen = 0;
		DebugTrace("PszSkipCodes: Invalid token.\n");
		return NULL;
	}
	//	skip delimiters if they are present.
	//
	if (((*pwszTokHead == CIfHeadParser::TAG_HEAD) && (pwszTokHead[cchTokLen-1] == CIfHeadParser::TAG_TAIL)) ||
		((*pwszTokHead == CIfHeadParser::ETAG_HEAD) && (pwszTokHead[cchTokLen-1] == CIfHeadParser::ETAG_TAIL)))
	{
		pwszTokHead++;
		cchTokLen -= 2;
	}

	//	LWS are legal within the tags as well.
	//	Skip any LWS near the head
	//
	while((*pwszTokHead) && (iswspace(*pwszTokHead)) && (cchTokLen > 0))
	{
		pwszTokHead++;
		cchTokLen--;
	}

	//	Skip any LWS near the tail
	//
	while(iswspace(pwszTokHead[cchTokLen-1]) && (cchTokLen  > 0))
	{
		cchTokLen--;
	}

	if (cchTokLen > 0)
	{
		*pcchLen = cchTokLen;
		return pwszTokHead;
	}
	else
	{
		*pcchLen = 0;
		DebugTrace("PszSkipCodes Invalid token length.\n");
		return NULL;
	}
}

//	--------------------------------------------------------------------------------
//	----------------------------- CIfHeadParser Impl -------------------------------
//	--------------------------------------------------------------------------------


/*
 -	CIfHeadParser::ScValidateTagged
 -
 *
 *	Apply the tagged production.
 *
 *
 *	Simply put we do this:
 *
 *		for each list within the list of list
 *			we apply the list production
 *
 *	we expect the parse string to be 1 * List as the resource is
 *	already consumed by the caller.
 *
 */

//$REVIEW: How is this function any different from ScValidateNonTagged(pwsz, NULL)???
SCODE
CIfHeadParser::ScValidateTagged(LPCWSTR	pwszPath)
{
	SCODE	sc = E_DAV_IF_HEADER_FAILURE;
	LPCWSTR	rpwszPath[1];
	BOOL	rfMatch[1];
	BOOL	fMatchAny = FALSE;
	
	Assert(m_fTagged);

	rpwszPath[0] = pwszPath;
	rfMatch[0] = FALSE;
	
	//	Apply one list which is
	//	LIST_HEAD 1 * ( [ not ] (statetoken | e-tag ) ) LIST_TAIL
	//
	while ( SUCCEEDED(sc = ScValidateList(rpwszPath, 1, rfMatch)) )
	{
		if (TRUE == rfMatch[0])
			fMatchAny = TRUE;
	}

	//	Status cannot be succesfull there as that is condition
	//	to exit the loop above
	//
	Assert(S_OK != sc);

	//	Now if the status is special failing error
	//	and we found the match then we need to return S_OK.
	//	Otherwise we will go down and return whatever
	//	error we are given.
	//
	if ((E_DAV_IF_HEADER_FAILURE == sc) && fMatchAny)
	{
		sc = S_OK;
	}

	return sc;
}

/*
 -	CIfHeadParser::ScValidateNonTagged
 -
 *
 *	Apply the non-tagged if header production.
 *
 *
 *	Simply put we do this:
 *
 *		for each list in the header
 *			we apply the list production
 *
 *	we expect the parse string to be 1 * List as the resource is
 *	already consumed by the caller.
 *
 *	Unlike the tagged production, a non tagged production is
 *	applied to all the resources in the scope of the operation.
 *	This is really complex and we shifted the complexity to
 *	the ApplyList function below which supports two resources.
 *
 *	If we succesfully finish the list, both the resources must
 *	have atleast one successful (TRUE) list production for the
 *	whole operation to succeed.
 *
 *  If pSC is NULL we'll return success or failure based on whether 
 *  or not the if header passes or fails.  
 *
 *  If pSC is not NULL, it points to an array of SCODEs that 
 *  indicate whether or not the if header passed for each resource 
 *  in the list.  Note that in this case we will return S_OK
 *  as the return value even if one of the resources fails.  We'll
 *  only send back a failure if there was some other unexpected 
 *  error
 *
 */

SCODE
CIfHeadParser::ScValidateNonTagged(LPCWSTR rgpwszPaths[], DWORD cPaths, SCODE * pSC)
{
	BOOL	*rgfMatches = NULL;			//	Flags indicating overall evaluation status for each path
	BOOL	*rgfNextListMatch = NULL;	//	Flags used to return the results of validating next list
    SCODE   sc = S_OK;
    DWORD   iPath = 0;

	Assert(! m_fTagged);
    Assert(rgpwszPaths);
    Assert(cPaths);

    rgfMatches = static_cast<BOOL*> (_alloca(sizeof(BOOL) * cPaths));
    rgfNextListMatch = static_cast<BOOL*> (_alloca(sizeof(BOOL) * cPaths));

    //  Init the match flag list: to default FALSE
    //
    for ( iPath = 0; iPath < cPaths; iPath++ )
    {
        rgfMatches[iPath] = FALSE;
        if (pSC)
        {
        	pSC[iPath] = E_DAV_IF_HEADER_FAILURE;
        }
        
    }
	//	Apply one list which is
	//	LIST_HEAD 1 * ( [ not ] (statetoken | e-tag ) ) LIST_TAIL
	//
	while ( SUCCEEDED(sc = ScValidateList(rgpwszPaths, cPaths, rgfNextListMatch)) )
	{	
        //  For all the paths that evaluated to TRUE in this list, 
        //  update the result flag. 
        //
        for ( iPath = 0; iPath < cPaths; iPath++ )
        {
			//	The result is interesting only for those whose current state is FALSE
			//	because each of the lists of ids are OR'd together to decide whether
			//  or not they passed.
			//
			if ( (FALSE == rgfMatches[iPath]) && (TRUE == rgfNextListMatch[iPath]) )
			{
				//  Note: you may be thinking why I don't break 
				//  here. With depth locks, same list/lock can
				//  satisfy multiple resources.
				//
				rgfMatches[iPath] = TRUE;
				if (pSC)
				{
					//  If we are asked for a resource by resource record
					//  of matching resource, mark that we found a success
					//  for the current resource.
					//
					pSC[iPath] = S_OK;
				}
			}
        }
		//$NOTE
		//	Two levels of optimization on this evaluation may look feasible:
		//	1) Stop evaluating when we find all the paths are validated
		//	2) Do not validate a path if the path is already validated against a list
		//	Both these optimizations will work for pre-condition evaluation, however
		//	we use the state tokens to add lock content to the logon: so we still need
		//	to parse the entire list to obtain all the applicable lock tokens..
		//	3) Another possibility is to do only the lock-token matching in the above
		//	scenario. There is no point in the etag/restag comparison if the path is
		//	already validated: but lock token check is still required as we need to
		//	collect all the lock tokens. This would require sharing the current global
		//	results with the basic match function. I think I would do this some time later.
		//$NOTE
		//
	}

	//	Check if that is any of special errors and reset the error code to S_OK
	//	if that is the case. Otherwise fail out straight of.
	//	
	if ((S_OK != sc) && (E_DAV_IF_HEADER_FAILURE != sc))
	{
		goto ret;
	}
	else
	{
		sc = S_OK;
	}

	//  if we were asked for a resource by resource account of matching resources
	//  we have succeeded the request.  Otherwise, if any resource failed, the
	//  if header failed.
	//
	if (pSC)
	{
		sc = S_OK;
		goto ret;
	}

	for ( iPath = 0; iPath < cPaths; iPath++ )
	{
		if (FALSE == rgfMatches[iPath])
		{
			sc = E_DAV_IF_HEADER_FAILURE;
			break;
		}
	}

ret:

    return sc;
}


/*
 -	CIfHeadParser::ScValidateList
 -
 *
 *	Apply the list production on the  resources.
 *	For non tagged resources we need to apply the
 *	list to all operand resources. We iterate the
 *	header once and achieve this. 
 *
 *	Return: FALSE on malformed input otherwise TRUE.
 *
 *	we parse the list and apply the match operation on
 *	all the resources. In order for a TRUE match result all
 *	the list elements must succesfully "apply" to the
 *	resource. If atleast one element did not apply
 *	with a truth result, we stop applying elements to
 *	that resource.
 *
 *	We return on end of list or malformed list.
 *
 */

SCODE
CIfHeadParser::ScValidateList(IN LPCWSTR *ppwszPathList, IN DWORD crPaths, OUT BOOL *pfMatch)
{
	SCODE sc = S_OK;
	DWORD iIndex;

	//	Do some input verification.
	//	size of the list must be at least one.
	//
	Assert(crPaths>0);
	Assert(ppwszPathList[0]);
	Assert(pfMatch);
	
#ifdef DBG
	{
		for (iIndex=0; iIndex<crPaths; iIndex++)
		{
			Assert(ppwszPathList[iIndex]);
		}
	}
#endif

	//	From now on, we are driven by the input.
	//	Look for the token and decide what to do.
	//
	m_pwszParseHead = m_iter.PszNextToken(TOKEN_START_LIST);

	//	Not a list: it is important that we fail
	//	here specifically to handle syntaxt errors
	//	in the list.
	//
	if (NULL == m_pwszParseHead)
	{
		sc = E_DAV_IF_HEADER_FAILURE;
		goto ret;
	}

	//	Initialize the match flag list.
	//	we start by assuming TRUE, since we
	//	know that there is atleast one token in the list.
	//
	for (iIndex=0; iIndex<crPaths; iIndex++)
	{
		pfMatch[iIndex] = TRUE;
	}

	//	Apply one match element at a time - which is
	//	( [ not ] ( statetoken | e-tag ) )
	//
	while (NULL != m_pwszParseHead)
	{
		BOOL	fEtag = (ETAG_HEAD == *m_pwszParseHead);

		//	set the current token of the operator
		//
		if (! m_popMatch->FSetToken(m_pwszParseHead, fEtag))
		{
			DebugTrace("CIfHeadParser::ScValidateList Invalid token\n");

			//	return immediately
			//
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
		}

		//	Now we obtained one complete match condition-
		//	for all the paths check if the condition is good.
		//	we need to do this only if all previous matchs
		//	succeeded for the given path.
		//	i.e if a match failed, the list is anyway going to fail
		//	for the particular path.
		//
		for (iIndex=0; iIndex<crPaths; iIndex++)
		{
			if (TRUE == pfMatch[iIndex])
			{
				//	Change the match flag only if the condition
				//	failed. This is because the expression within a
				//	list is ANDed together. If one fails, the whole
				//	list fails.
				//
				sc = ScMatch(ppwszPathList[iIndex]);
				if (FAILED(sc))
				{
					if (E_DAV_IF_HEADER_FAILURE == sc)
					{
						pfMatch[iIndex] = FALSE;
					}
					else
					{
						goto ret;
					}
				}
			}
		}
		
		m_pwszParseHead = m_iter.PszNextToken(TOKEN_SAME_LIST);
	}

	//	List is a syntactically correct one.
	//
	sc = S_OK;

ret:

	return sc;
}

/*
 -	CIfHeadParser::ScValidateIf
 -
 *
 *	Apply the if production.
 *
 *  If pSC is NULL we'll return success or failure based on whether 
 *  or not the if header passes or fails.  
 *
 *  If pSC is not NULL, it points to an array of SCODEs that 
 *  indicate whether or not the if header passed for each resource 
 *  in the list.  Note that in this case we will return S_OK
 *  as the return value even if one of the resources fails.  We'll
 *  only send back a failure if there was some other unexpected 
 *  error
 */

SCODE
CIfHeadParser::ScValidateIf(	LPCWSTR rgpwszPaths[], 
								DWORD cPaths, 
								BOOL fRecursive /* = FALSE */, 
								SCODE * pSC /* = NULL */)
{
	SCODE sc = S_OK;

	//	If it is a tagged production, we do not
	//	apply the match to the children - the
	//	match op is for the tagged resource only. If non
	//	tagged, the method is to be applied
	//	depending on the method's depth flag.
	//
	if (m_fTagged)
		m_fRecursive = FALSE;
	else
		m_fRecursive = fRecursive;

	//	if tagged
	//		while ok
	//			find the tagged uri 
	//			see if the uri is within scope of the operands
	//			if within scope apply tagged production
	//	if non tagged
	//		apply nontagged production on the two input uris
	//	we are done
	//
	if (m_fTagged)
	{
		BOOL	fDone = FALSE;
        DWORD   iPath = 0;
		
        //  Initialize the results array if required ...
        //
        if (pSC)
        {
            for (iPath = 0; iPath < cPaths; iPath++)
                pSC[iPath] = S_OK;
        }
		while(! fDone)
		{
			LPCWSTR		pwszUri;
			LPCWSTR		pwszPath;
			DWORD		dwLen;

			//	find the URI in the header
			//
			m_pwszParseHead = m_iter.PszNextToken(TOKEN_NEW_URI);

			if (NULL == m_pwszParseHead)
			{
				sc = S_OK;
				goto ret;
			}
			
			//	got the tagged uri - skip the tags in both
			//	sides and get a clean uri.
			//
			dwLen = 0;
			pwszUri = PwszSkipCodes(m_pwszParseHead, &dwLen);

            if ( (pwszUri == NULL) || (dwLen<1) )
            {
			    sc = E_DAV_IF_HEADER_FAILURE;
			    goto ret;
            }

			//	convert the uri to the resource path
			//
			sc = m_popMatch->ScGetResourcePath(pwszUri, &pwszPath);
			if (FAILED(sc))
			{
				//  error code will be E_OUTOFMEMORY
				//  if we get here
				//
				goto ret;
			}

			//	Check if the tagged URI is within scope of
			//	the method and apply the state match operation
			//	only if it does.
			//
            for (iPath = 0; iPath < cPaths; iPath++)
			{
				
				//	check path validity - depending on the operation depth.
				//	If the operation is not deep, the paths must match
				//	exactly.
				//			
				if (FIsChildPath(rgpwszPaths[iPath], pwszPath, fRecursive))
				{
					sc = ScValidateTagged(pwszPath);
					
					//  If the caller wants a list of the scodes resource
					//  by resource, set it into the array.  Otherwise
					//  we can stop verifying the resource because we've
					//  already found a resource that fails the if statement.
					//	Note that we return the failure in the scode array
					//	only for pre-condition failures, other errors like
					//	memory errors (or even redirect errors) fail the
					//	whole request immediately.
					//
					if ((E_DAV_IF_HEADER_FAILURE == sc) && (pSC))
						pSC[iPath] = sc;
					else if (FAILED(sc))
						goto ret;

                    //  This path is done
                    //
                    break;
				}
			}
		}
	}
	else
	{
		sc = ScValidateNonTagged(rgpwszPaths, cPaths, pSC);
		goto ret;
	}

	sc = E_DAV_IF_HEADER_FAILURE;

ret:

	return sc;
}

/*
 -	CIfHeadParser::ScMatch
 -
 *	Call the appropriate operator and return the value of the
 *	expression.
 *
 *
 */

SCODE
CIfHeadParser::ScMatch(LPCWSTR pwszPath)
{
	SCODE	sc = S_OK;
	BOOL	fNot = m_iter.FCurrentNot();

	Assert(m_popMatch);
	
	//	determine the type of the token and call the
	//	appropriate handler
	//
	switch(m_popMatch->GetTokenType())
	{
		case CStateToken::TOKEN_LOCK:
			sc = m_popMatch->ScMatchLockToken(pwszPath, m_fRecursive);
			break;

		case CStateToken::TOKEN_RESTAG:
			sc = m_popMatch->ScMatchResTag(pwszPath);
			break;

		case CStateToken::TOKEN_ETAG:
			sc = m_popMatch->ScMatchETag(pwszPath, m_fRecursive);
			break;

		case CStateToken::TOKEN_TRANS:
			sc = m_popMatch->ScMatchTransactionToken(pwszPath);
			break;

		default:
			DebugTrace("CStateMatchOp::Unsupported token type\n");
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
	}
	
	//	Unless we applied the match operators above we
	//	should not even reach here.
	//
	if (fNot)
	{
		if (E_DAV_IF_HEADER_FAILURE == sc)
		{
			sc = S_OK;
		}
		else if (S_OK == sc)
		{
			sc = E_DAV_IF_HEADER_FAILURE;
		}
	}

ret:

	return sc;
}

//	--------------------------------------------------------------------------------
//	----------------------------- CStateMatchOp Impl -------------------------------
//	--------------------------------------------------------------------------------

/*
 -	CStateMatchOp::ScParseIf
 -
 *
 *
 */
SCODE
CStateMatchOp::ScParseIf(LPCWSTR  pwszIfHeader,
						LPCWSTR rgpwszPaths[],
                        DWORD   cPaths,
						BOOL    fRecur,
						SCODE *	pSC)
{
	SCODE			sc = S_OK;
	CIfHeadParser	ifParser(pwszIfHeader, this);

	sc = ifParser.ScValidateIf(rgpwszPaths, cPaths, fRecur, pSC);

    return sc;
}

//	--------------------------------------------------------------------------------
//	----------------------------- CStateToken Impl -------------------------------
//	--------------------------------------------------------------------------------

/*
 -	CStateToken::FSetToken
 -
 *	We expect pszToken to be an e-tag enclosed within [ ] or
 *	a state token enclosed within < >.
 *
 */
BOOL
CStateToken::FSetToken(LPCWSTR pwszToken, BOOL fEtag, DWORD dwLen)
{
	LPCWSTR	pwszTokHead = pwszToken;

	m_tType = TOKEN_NONE;

	//	update the length and skip the tags
	//
	pwszTokHead = PwszSkipCodes(pwszToken, &dwLen);
	
    if ( (NULL == pwszTokHead) || (dwLen < 1) )
    {
        return FALSE;
    }

	//	add one for the null char.
	//
	dwLen++;

	//	allocate buffer for the token.
	//	we try to optimize allocations by using a heuristic
	//	size value. Most of our tokens are of form
	//	prefix-guid-smallstring
	//
	if ((NULL == m_pwszToken) || (dwLen > m_cchBuf))
	{
		if (NULL != m_pwszToken)
			ExFree(m_pwszToken);
		
		if (dwLen > NORMAL_STATE_TOKEN_SIZE)
		{
			m_pwszToken = reinterpret_cast<LPWSTR>(ExAlloc(dwLen * sizeof(WCHAR)));
			m_cchBuf   = dwLen;
		}
		else
		{
			m_pwszToken = reinterpret_cast<LPWSTR>(ExAlloc(NORMAL_STATE_TOKEN_SIZE * sizeof(WCHAR)));
			m_cchBuf   = NORMAL_STATE_TOKEN_SIZE;
		}
	}
	if (NULL == m_pwszToken)
	{
		m_cchBuf = 0;
		return FALSE;
	}

	//	Remember that dwLen contains size of the buffer (including
	//	Null char).
	//	Make our copy of the string
	//
	wcsncpy(m_pwszToken, pwszTokHead, (dwLen - 1));

	//	add the null character to terminate the string.
	//
	m_pwszToken[dwLen-1] = L'\0';
	
	if (fEtag)
	{
		Assert(CIfHeadParser::ETAG_HEAD == *pwszToken);
		m_tType = CStateToken::TOKEN_ETAG;
		return TRUE;
	}
	//	parse the token to find our the token type.
	//
	else if (0 == _wcsnicmp(pwszTokHead,
							gc_wszOpaquelocktokenPrefix,
							gc_cchOpaquelocktokenPrefix) )
	{
		//	Since token is a client input, let us be careful
		//	with it. Make sure that the size is minimum expected,
		//	which is opaquelocktoken:guid:<at least one char extension>.
		//	Lock tokens, unfortunately, can be either transaction
		//	or plain lock tokens. To find out if it is transaction
		//	token, we will have to parse the token and reach the
		//	extension part. For performance reasons I am going to
		//	skip parsing and jump directly to the place where I
		//	can get the information. This is not bad as we any way
		//	correctly parse the token when we are looking for its
		//	contents.
		//
		//	gc_cchOpaquelocktokenPrefix includes the :, gc_cchMaxGuid
		//	includes the null char (cch?). Hence the expression below.
		//
		if ( dwLen > (gc_cchOpaquelocktokenPrefix + gc_cchMaxGuid) )
		{
			if (0 == _wcsnicmp(&pwszTokHead[gc_cchOpaquelocktokenPrefix + gc_cchMaxGuid],
							gc_wszTransactionOpaquePathPrefix,
							gc_cchTransactionOpaquePathPrefix) )
			{
				m_tType = TOKEN_TRANS;
				return TRUE;
			}
			else
			{
				m_tType = TOKEN_LOCK;
				return TRUE;
			}
		}
		else
		{
			DebugTrace("CStateMatchOp::lock state token too small %ls\n", pwszTokHead);
			return FALSE;
		}
	}
	//	Our restag-type URIs all start with 'r'.
	//	(And no other URIs that start with 'r' are valid statetokens.)
	//	
	else if (L'r' == *pwszTokHead)
	{
		m_tType = TOKEN_RESTAG;
		return TRUE;
	}
	else
	{
		DebugTrace("CStateMatchOp::Unsupported/unrecognized state token %ls\n",
				  pwszTokHead);
		return FALSE;
	}
}

/*
 -	CStateToken::FGetLockTokenInfo
 -
 *	Parse the state token as if it is a lock token. Note that this
 *	works for transaction tokens as well.
 *
 */
BOOL
CStateToken::FGetLockTokenInfo(unsigned __int64 *pi64SeqNum, LPWSTR	pwszGuid)
{
	LPWSTR	pwszToken = m_pwszToken;

	Assert(pwszGuid);
	
	if ((TOKEN_LOCK != m_tType) && (TOKEN_TRANS != m_tType))
	{
		return FALSE;
	}

	//	We assume that the token is validated when we reach here.
    //  skip any LWS and the opaquetoken part.
    //
    while((*pwszToken) && iswspace(*pwszToken))
        pwszToken++;

	//	we check for opaque token when we set the token - so
	//	just skip the portion
	//
	pwszToken += gc_cchOpaquelocktokenPrefix;

	//	no check for validity of buf size. duh factor.
	//
	wcsncpy(pwszGuid, pwszToken, gc_cchMaxGuid - 1);

	//	terminate the guid string.
	//
	pwszGuid[gc_cchMaxGuid - 1] = L'\0';
	
	pwszToken = wcschr(pwszToken, L':');

	if (NULL == pwszToken)
	{
		DebugTrace("CStateToken::FGetLockTokenInfo invalid lock token.\n");
		return FALSE;
	}
	Assert(L':' == *pwszToken);

	//	skip the ":"
	//
	pwszToken++;

	//	Transaction tokens will have a T at the head of the extension
	//	part of the token.
	//
	if (TOKEN_TRANS == m_tType)
	{
		Assert(gc_wszTransactionOpaquePathPrefix[0] == *pwszToken);
		pwszToken += gc_cchTransactionOpaquePathPrefix;
	}
	
	//	the lock-id string follows
	//
	*pi64SeqNum = _wtoi64(pwszToken);

	//$TODO:
	//	Is there a way to validate if atoi failed?
	//
	return TRUE;
}

/*
 -	CStateToken::FIsEqual
 -
 *	Nifty equality operator
 *
 *
 */
BOOL
CStateToken::FIsEqual(CStateToken *pstokRhs)
{
	if (pstokRhs->GetTokenType() != m_tType)
		return FALSE;

	LPCWSTR	pwszLhs = m_pwszToken;
	LPCWSTR	pwszRhs = pstokRhs->WszGetToken();

	if (!pwszLhs || !pwszRhs)
		return FALSE;

	return (0 == _wcsicmp(pwszLhs, pwszRhs));
}

/*
 -	IFITER::PszNextToken
 -
 *
 *
 */
//	------------------------------------------------------------------------
//	IFITER::PszNextToken
//
//	Fetch the next token.
//	Can be restricted to the next token in this list (AND-ed set inside a
//	particular set of parens), the next token in a new list (new set of parens),
//	or the next token in the whole header-line.
//
LPCWSTR
IFITER::PszNextToken (FETCH_TOKEN_TYPE type)
{
	LPCWSTR pwsz;
	LPCWSTR pwszEnd;
	WCHAR wchEnd = L'\0';

	//	If no header existed, then there is nothing to do
	//
	if (NULL == m_pwch)
		return NULL;

	//	Quick state-check.
	//	If the current node is a "Not", then we MUST be in a list.
	//	(Not is a qualifier on a token inside a list.  Can't have a Not
	//	outside of a list.)
	//	Logically, m_fCurrentNot _implies_ m_state is STATE_LIST.
	//
	Assert (!m_fCurrentNot || STATE_LIST == m_state);

	//	Clear our "Not" bit before starting our fetch of the next token.
	//	If the token we return has a "Not" qualifier, set the flag correctly below.
	//
	m_fCurrentNot = FALSE;


	//	Eat all the white space
	//
	while (*m_pwch && iswspace(*m_pwch))
		m_pwch++;

	//	Quit if there is nothing left to process
	//
	if (L'\0' == *m_pwch)
		return NULL;

	//	If the last state was a LIST, we need to check for the close
	//	of the list, and set our state back to NONE.
	//
	if (STATE_LIST == m_state)
	{
		//	If the next char is a close paren, that's the end of this list.
		if (L')' == *m_pwch)
		{
			m_pwch++;
			m_state = STATE_NONE;

			//	Eat all the white space
			//
			while (*m_pwch && iswspace(*m_pwch))
				m_pwch++;

			//	Quit if there is nothing left to process
			//
			if (L'\0' == *m_pwch)
				return NULL;

			//	Update our state if we were asked for "any list item".
			//	(Now we should find a list start.)
			//
			if (TOKEN_ANY_LIST == type)
				type = TOKEN_START_LIST;
		}
	}

	//	If the caller asked for any list item, and we didn't change that
	//	request because of our state above, change it here to specifically
	//	search for the next item in the same list.
	//
	if (TOKEN_ANY_LIST == type)
		type = TOKEN_SAME_LIST;

	//
	//	Process the request.
	//

	switch (type)
	{
		//	This case is really dumb.  I thought I might use
		//	it for "counting" tokens.  If it's not being used, remove it!
		//
		case TOKEN_NONE:
		{
			//	If they're asking for a raw count (type == TOKEN_NONE),
			//	give it to 'em.....
			//	NOTE: This code is a little sloppy.  It will count names
			//	as state tokens.
			//
			m_pwch = wcschr (m_pwch, L'<');
			if (!m_pwch)
			{
				return NULL;
			}
			wchEnd = L'>';

			//	Go copy the data.
			//
			break;
		}

		case TOKEN_NEW_URI:
		{
			//	Grab a name, skipping all lists.
			//	If there are no names left, give NULL.

			//	Three places we could be -- NONE, NAME, LIST.
			//
			while (m_pwch && *m_pwch)
			{
				//	If we're at a uri-delimiter now, AND
				//	we're in the NONE state, just go fetch the token below...
				//
				if (L'<' == *m_pwch &&
					STATE_NONE == m_state)
				{
					break;
				}

#ifdef	DBG
				//	Debug-only check of our state.
				if (L'(' == *m_pwch)
				{
					Assert(STATE_NONE == m_state ||
						   STATE_NAME == m_state);
				}
				else if (L'<' == *m_pwch)
				{
					Assert(STATE_LIST == m_state);
				}
#endif	// DBG

				//	Zip to the end of the current list.
				//
				m_pwch = wcschr (m_pwch + 1, L')');
				if (!m_pwch)
				{
					return NULL;
				}
				m_pwch++;	// Skip past the closing paren.

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;

				m_state = STATE_NONE;
			}

			//	Fallthrough to the next segment to check the token
			//	and fetch our uri.
		}

		case TOKEN_URI:
		{
			//	Grab a name, iff the next item is a name.
			//	Otherwise, give NULL.

			//	Quit if the next item is not a name.
			//
			if (L'<' != *m_pwch)
				return NULL;

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we already have a name, or if we are
			//	already INSIDE a list....)
			//
			if (STATE_NONE != m_state)
				return NULL;

			//	Set our state and fallthru to fetch the data.
			//
			m_state = STATE_NAME;
			wchEnd = L'>';

			//	Go copy the data.
			//
			break;
		}

		case TOKEN_NEW_LIST:
		{
			//	Fast-forward to the next new list and fetch the first item.
			//	If we're still inside a list, must skip the rest of this list.
			//	If there are no more new lists for this URI, return NULL.

			if (STATE_LIST == m_state)
			{
				//	We're inside a list.  Get out by seeking to the next
				//	list-end-char (right paren).
				//
				m_pwch = wcschr (m_pwch, L')');
				if (!m_pwch)
					return NULL;

				m_state = STATE_NONE;
				m_pwch++;	// Skip past the closing paren.

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;
			}

			Assert(m_pwch);
			Assert(*m_pwch);

			//	And fallthrough here to the TOKEN_START_LIST case.
			//	It will verify & skip past the list start char
			//	and fetch out the next token.
			//
		}
		case TOKEN_START_LIST:
		{
			//	Grab a list item, iff the next item is a NEW list item.
			//	Otherwise, return NULL.

			//	Quit if the next item is not a list.
			//
			if (L'(' != *m_pwch)
				return NULL;

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we are already INSIDE a list....)
			//
			if (STATE_LIST == m_state)
				return NULL;

			//	Fetch the token.
			//
			m_state = STATE_LIST;
			m_pwch++;	// Skip the open paren.

			//	Eat all the white space
			//
			while (*m_pwch && iswspace(*m_pwch))
				m_pwch++;

			//	Quit if there is nothing left to process
			//
			if (L'\0' == *m_pwch)
				return NULL;

			//	Fallthrough to the TOKEN_SAME_LIST processing
			//	to actually fetch the token.
			//
		}

		case TOKEN_SAME_LIST:
		{
			//	Grab the next list item.
			//	If the next item is not a list item, return NULL.

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we are NOT inside a list....)
			//
			if (STATE_LIST != m_state)
				return NULL;

			//	Check for the magic "Not" qualifier.
			//
			if (!_wcsnicmp (gc_wszNot, m_pwch, 3))
			{
				//	Remember the data and skip these chars.
				//
				m_fCurrentNot = TRUE;
				m_pwch += 3;

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;
			}

			//	Quit if the next item is not a token.
			//
			if (L'<' != *m_pwch &&
				L'[' != *m_pwch)
			{
				return NULL;
			}

			//	Fetch the token.
			//
			//	Next token must start with either < for statetokens, or [ for etags.
			//
			if (L'<' == *m_pwch)
			{
				wchEnd = L'>';
			}
			else if (L'[' == *m_pwch)
			{
				wchEnd = L']';
			}
			else
			{
				DebugTrace("HrCheckIfHeaders -- Found list start, but no tokens!\n");
				return NULL;
			}

			//	Go copy the data.
			//
			break;
		}

		default:
		{
			DebugTrace("HrCheckIfHeaders -- Unrecognized request: 0x%0x", type);
			return NULL;
		}
	}
	//	We should have set these items above.  They are needed to
	//	snip off the current token string (below).
	//
	Assert (m_pwch);
	Assert (*m_pwch);
	Assert (wchEnd);

	//	Quick state-check.
	//	If the current node is a "Not", then we MUST be in a list.
	//	(Not is a qualifier on a token inside a list.  Can't have a Not
	//	outside of a list.)
	//	Logically, m_fCurrentNot _implies_ m_state is STATE_LIST.
	//
	Assert (!m_fCurrentNot || STATE_LIST == m_state);


	//	Find the end of this data item.
	//
	//	Keep a pointer to the start, and seek for the end.
	//$REVIEW: Do we need to be super-careful here?
	//$REVIEW: This strchr *could* jump past stuff, but only in MALFORMED data.
	//
	pwsz = m_pwch;
	m_pwch = wcschr (pwsz + 1, wchEnd);
	if (!m_pwch)
	{
		//	No end-of-token-char found for this token!
		//
		DebugTrace("HrCheckIfHeader -- No end char (%lc) found for token %ls",
				   wchEnd, pwsz);
		return NULL;
	}
	//	Save off the end pointer, then advance past the end char.
	//	(m_pch now points to the start for the NEXT token.)
	//
	pwszEnd = m_pwch++;

	//	Copy the data.
	//

	//	The two pointers better be set before we try to copy the data.
	Assert (pwsz);
	Assert (pwszEnd);

	//	The difference between, the two pointers gives us
	//	the size of the current entry.
	//
	m_buf.AppendAt (0, static_cast<UINT>(pwszEnd - pwsz + 1) * sizeof(WCHAR), pwsz);
	m_buf.Append (sizeof(WCHAR), L"");	// NULL-terminate it!

	//	Return the string
	//
	return m_buf.PContents();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_except\_except.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EXCEPT.H
//
//		EXCEPT precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __EXCEPT_H_
#define __EXCEPT_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>

//	_EXCEPT headers
//
#include <except.h> // Exception throwing/handling interfaces

#endif // !defined(__EXCEPT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_except\except.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EXCEPT.CPP
//
//		Exception classes used by this implementation
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_except.h>
#include <perfctrs.h>


//	========================================================================
//
//	CLASS CWin32ExceptionHandler
//

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::CWin32ExceptionHandler()
//
//	Exception handler constructor.  Just installs our exception handler,
//	saving off the old one for restoration by the destructor.
//
CWin32ExceptionHandler::CWin32ExceptionHandler()
{
	m_pfnOldHandler = _set_se_translator( HandleWin32Exception );
}

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::~CWin32ExceptionHandler()
//
//	Exception handler destructor.  Just restores the exception handler
//	we saved off in the constructor.
//
CWin32ExceptionHandler::~CWin32ExceptionHandler()
{
	_set_se_translator( m_pfnOldHandler );
}

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::HandleWin32Exception()
//
//	Our Win32 exception handler.  Just stuffs the Win32 exception
//	information into a C++ exception object and throws it so we
//	can catch it with a regular C++ exception handler.
//
void __cdecl
CWin32ExceptionHandler::HandleWin32Exception( unsigned int code, _EXCEPTION_POINTERS * pep )
{
	throw CWin32Exception( code, *pep );
}


//	========================================================================
//
//	CLASS CDAVException
//

//	------------------------------------------------------------------------
//
//	CDAVException::CDAVException()
//
CDAVException::CDAVException( const char * s ) :
   exception(s)
{
#ifdef DBG
	//
	//	When we're attached to a debugger, stop here so that
	//	the soul who is debugging can actually see where the
	//	exception is being thrown from before it is thrown.
	//
	if ( GetPrivateProfileInt( "General", "TrapOnThrow", FALSE, gc_szDbgIni ) )
		TrapSz( "Throwing DAV exception.  Retry now to catch it." );
#endif

	//
	//	Bump the exceptions counter
	//
	IncrementGlobalPerfCounter( IPC_TOTAL_EXCEPTIONS );
}

#ifdef DBG
//	------------------------------------------------------------------------
//
//	CDAVException::DbgTrace()
//
void
CDAVException::DbgTrace() const
{
	DebugTrace( "%s\n", what() );
}
#endif

//	------------------------------------------------------------------------
//
//	CDAVException::Hresult()
//
HRESULT
CDAVException::Hresult() const
{
	return E_FAIL;
}

//	------------------------------------------------------------------------
//
//	CDAVException::DwLastError()
//
DWORD
CDAVException::DwLastError() const
{
	return ERROR_NOT_ENOUGH_MEMORY;	//$ Is there a better default?
}


//	========================================================================
//
//	CLASS CHresultException
//

//	------------------------------------------------------------------------
//
//	CHresultException::Hresult()
//
HRESULT
CHresultException::Hresult() const
{
	return m_hr;
}


//	========================================================================
//
//	CLASS CLastErrorException
//

//	------------------------------------------------------------------------
//
//	CLastErrorException::DwLastError()
//
DWORD
CLastErrorException::DwLastError() const
{
	return m_dwLastError;
}


//	========================================================================
//
//	CLASS CWin32Exception
//

#ifdef DBG
//	------------------------------------------------------------------------
//
//	CWin32Exception::DbgTrace()
//
void
CWin32Exception::DbgTrace() const
{
	DebugTrace( "Win32 exception 0x%08lX at address 0x%08lX\n", m_code, m_ep.ExceptionRecord->ExceptionAddress );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_exo\exo.cpp ===
/*
 *  e x o . c p p
 *
 *  Purpose:
 *      Base Exchange COM Object
 *
 *      Any Exchange object that implements one or more COM interfaces
 *      should 'derive' from EXObject using the macros below.
 *
 *	Originator:
 *		JohnKal
 *  Owner:
 *      BeckyAn
 *
 *  Copyright (C) Microsoft Corp 1993-1997. All rights reserved.
 */

#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>

#include <caldbg.h>
#include "exo.h"


#ifndef NCHAR
#define NCHAR CHAR
#endif // !NCHAR


// Debugging traces.
// Change the function name in the define to match your system's debug calls.
#ifdef DBG
BOOL g_fExoDebugTraceOn = -1;
#define ExoDebugTrace		(!g_fExoDebugTraceOn)?0:DebugTrace
#else // !DBG
#define ExoDebugTrace		1?0:DebugTrace
#endif // DBG, else


// Forward function declarations ////////////////////////////////////////

#ifdef DBG

// EXO supporting debug structures.
#define IID_PAIR(_iid)  { (IID *) & IID_ ## _iid, #_iid }

const struct
{
    IID *   piid;
    LPSTR   szIidName;
} c_rgiidpair[] =
{
    IID_PAIR(IUnknown),

    IID_PAIR(IDataObject),
//  IID_PAIR(IMAPITable),
    IID_PAIR(IOleObject),
    IID_PAIR(IOleInPlaceObject),
    IID_PAIR(IPersist),
//  IID_PAIR(IPersistMessage),
    IID_PAIR(IPersistStorage),
    IID_PAIR(IStorage),
    IID_PAIR(IStream),
    IID_PAIR(IViewObject),
    IID_PAIR(IViewObject2),
//  IID_PAIR(IMAPIForm),
//  IID_PAIR(IMAPIFormAdviseSink),
//  IID_PAIR(IMAPISession),
    IID_PAIR(IMoniker),
    IID_PAIR(IROTData),


    { 0, 0 }        // end of table marker.
};


// EXO supporting debug function.
// Gets a name for a given IID.
LPCSTR NszFromIid(REFIID riid)
{
    int i = 0;
    static NCHAR    rgnch[80];           //$ REVIEW: not thread safe.

    while (c_rgiidpair[i].piid)
    {
        if (*c_rgiidpair[i].piid == riid)
            return c_rgiidpair[i].szIidName;
        ++i;
    }
    wsprintfA(rgnch, "{%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}",
             riid.Data1, riid.Data2, riid.Data3,
             riid.Data4[0],riid.Data4[1],riid.Data4[2],riid.Data4[3],
             riid.Data4[4],riid.Data4[5],riid.Data4[6],riid.Data4[7]);
    return rgnch;
}
#endif  // DBG



// EXO base class: implementation ////////////////////////////////////////

// EXO's own interface mapping table & class info definitions.
BEGIN_INTERFACE_TABLE(EXO)
END_INTERFACE_TABLE(EXO);

DECLARE_EXOCLSINFO(EXO) =
	EXOCLSINFO_CONTENT_EX( EXO, NULL, exotypNonserver, &CLSID_NULL, NULL );


EXO::EXO() :
    m_cRef(1)
{
}

EXO::~EXO()
{                           // must have this or linker whines.
}

/*
 *  EXO::InternalQueryInterface
 *
 *  Purpose:
 *      Given an interface ID, check to see if the object implements the interface.
 *      If the interface is supported, return a pointer to it.
 *      Otherwise, return E_NOINTERFACE.
 *      This function scans the object's classinfo chain, starting at the lowest
 *		level, looking for the requested IID. The lowest classinfo struct is
 *		obtained by calling a virtual function.
 *
 *  Arguments:
 *      riid    in  IID of the requested interface.
 *      ppvOut  out Returned interface pointer.
 *
 *  Returns:
 *      S_OK or E_NOINTERFACE.
 *
 *  Notes:
 *      This needs to be virtual for several reasons:
 *          1) so classes derived from EXO can aggregate other objects and still have EXO routines
 *             access the interfaces of the aggregated object,
 *          2) so that EXOA_UNK members can call it
 *      All QI work should be routed here using EXO[A]_INCLASS_DECL().
 *		(The only exception is if you are an aggregator -- you have a kid --
 *		and then you should still CALL this function to search throught your own interfaces.)
 *  Notes:
 *      Note that pexoclsinfo is looked up using the virtual call to GetEXOClassInfo instead of using the object's m_pexoclsinfo.  This is so
 *      that a derived object's IIDINFO table need only contain interfaces new to that object instead of
 *      all the interfaces of the derived object and all the interfaces of it's parent.
 *      A class's InternalQueryInterface() method general calls this method explicitly passing
 *      the classes EXOCLSINFO (*not* m_pexoclsinfo) and if that fails calls it's parent's
 *      InternalQueryInterface().
 */
HRESULT EXO::InternalQueryInterface(REFIID riid, LPVOID * ppvOut)
{
    UINT ciidinfo;
    const EXOCLSINFO * pexoclsinfo;
	const IIDINFO * piidinfo;
#ifdef DBG
#ifdef UNICODE
    UsesMakeANSI;
    LPCSTR szClassName = MakeANSI(GetEXOClassInfo()->szClassName);
#else   // !UNICODE
    LPCSTR szClassName = GetEXOClassInfo()->szClassName;
#endif  // !UNICODE
    ExoDebugTrace("%s::QueryInterface(%08lx): being asked for %s\n", szClassName, this, NszFromIid(riid));
#endif  // DBG

	Assert(ppvOut);
    *ppvOut = NULL;

	// Get the lowest (leaf) classinfo for this object.
	pexoclsinfo = GetEXOClassInfo();

	// Search up the classinfo chain.  EXO's parent classinfo pointer is NULL,
	// and will terminate this loop.
	while (pexoclsinfo)
	{
		// Get the interface mapping table from the classinfo struct.
		ciidinfo = pexoclsinfo->ciidinfo;
		piidinfo = pexoclsinfo->rgiidinfo;

		// Search through this interface mapping table.
		for ( ; ciidinfo--; ++piidinfo)
		{
			// If the iid is found.
			if (*piidinfo->iid == riid)
			{
				// Apply the offset for this iid.
				IUnknown * const punk = EXOApplyDbCast(IUnknown, this,
													   piidinfo->cbDown, piidinfo->cbUp);

#ifdef DBG
				// Uses a debug-only variable.
				ExoDebugTrace("%s::QueryInterface(%08lx): cRef: %d -> %d\n", szClassName, this, m_cRef, m_cRef+1);
#endif // DBG

				// Need to AddRef the resulting object.  This ref is for the caller.
				*ppvOut = punk;
				punk->AddRef();

				return S_OK;
			}
		}

		// Fetch the next classinfo struct up the chain.
		pexoclsinfo = pexoclsinfo->pexoclsinfoParent;
	}

    // No support for the requested inteface.

#ifdef DBG
	// Uses a debug-only variable.
    ExoDebugTrace("%s::QueryInterface(%08lx): E_NOINTERFACE\n", szClassName, this);
#endif  // DBG

    return E_NOINTERFACE;
}

/*
 *  EXO::InternalAddRef
 *
 *  Purpose:
 *      Increments the reference count on the object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */
ULONG EXO::InternalAddRef()
{
#ifdef DBG
#ifdef UNICODE
	UsesMakeANSI;
	ExoDebugTrace("%s::AddRef(%08lx): cRef: %ld->%ld\n", MakeANSI(GetEXOClassInfo()->szClassName), this, m_cRef, m_cRef+1);
#else // !UNICODE
	ExoDebugTrace("%s::AddRef(%08lx): cRef: %ld->%ld\n", GetEXOClassInfo()->szClassName, this, m_cRef, m_cRef+1);
#endif // !UNICODE
#endif // DBG

	//	NOTE: On Win95 or NT3.51, this won't return the exact m_cRef....
	//	(People shouldn't depend on the value returned from AddRef anyway!!!)
	//
	return InterlockedIncrement(&m_cRef);
}



/*
 *  EXO::InternalRelease
 *
 *  Purpose:
 *      Decrements the reference count on the object. If the reference
 *      count reaches zero, we destroy the object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count, 0 if the object is destroyed.
 */
ULONG EXO::InternalRelease()
{
#ifdef DBG
#ifdef UNICODE
    UsesMakeANSI;
    ExoDebugTrace("%s::Release(%08lx): cRef: %ld->%ld\n", MakeANSI(GetEXOClassInfo()->szClassName), this, m_cRef, m_cRef-1);
#else   // !UNICODE
    ExoDebugTrace("%s::Release(%08lx): cRef: %ld->%ld\n", GetEXOClassInfo()->szClassName, this, m_cRef, m_cRef-1);
#endif  // !UNICODE
#endif  // DBG

    AssertSz(m_cRef > 0, "cRef is already 0!");

    if (InterlockedDecrement(&m_cRef) > 0)
        return m_cRef;

    delete this;

    return 0;
}

// Implementation of EXOA::EXOA_UNK methods //////////////////

/*
 *  EXOA::EXOA_UNK::QueryInterface
 *
 *  Purpose:
 *      Given an interface ID 'riid', first calls out through a virtual
 *      function EXOA::AggregatorQueryInterface() to allow an aggregated
 *      aggregator to QI any of his children for the interface pointer.
 *      If that doesn't result in an interface, we then perform the
 *      EXO::QueryInterface() scan on the derived object itself.
 *
 *  Arguments:
 *      riid    in  IID of the requested interface.
 *      ppvOut  out Returned interface pointer.
 *
 *  Returns:
 *      S_OK or E_NOINTERFACE.
 */

STDMETHODIMP EXOA::EXOA_UNK::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    // We need to preserve object identity when IUnknown is requested.
    if (IID_IUnknown == riid)
    {
        *ppvOut = this;
        AddRef();
        return S_OK;
    }
    return m_pexoa->InternalQueryInterface(riid, ppvOut);
}

/*
 *  EXOA::EXOA_UNK::AddRef
 *
 *  Purpose:
 *      Increases the reference count on the object, by deferring
 *      to EXO::AddRef(). Note that we're _not_ calling EXOA::Addref()
 *      as that would release the refcount of the aggregate, not this
 *      object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */

STDMETHODIMP_(ULONG) EXOA::EXOA_UNK::AddRef()
{
    return m_pexoa->InternalAddRef();
}

/*
 *  EXOA::EXOA_UNK::Release
 *
 *  Purpose:
 *      Decreases the reference count on the object, by deferring
 *      to EXO::Release(). Note that we're _not_ calling EXOA::Release()
 *      as that would release the refcount of the aggregate, not this
 *      object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */

STDMETHODIMP_(ULONG) EXOA::EXOA_UNK::Release()
{
    return m_pexoa->InternalRelease();
}


// Implementation of EXOA methods ////////////////////////////////////////

EXOA::EXOA(IUnknown * punkOuter)
{
    m_exoa_unk.m_pexoa = this;
    m_punkOuter = (punkOuter) ? punkOuter : &m_exoa_unk;
}

EXOA::~EXOA()
{                           // must have this or linker whines.
}

// end of exo.cpp ////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_locks\_locks.cpp ===
/*
 *	_ L O C K S . C P P
 *
 *	Pre-compiled header for _locks
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <_locks.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_locks\_locks.h ===
/*
 *	_ L O C K S . H
 *
 *	Pre-compiled header for _locks
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)	/* (inline) function not expanded */

//	Windows headers
//
#include <windows.h>

#pragma warning(disable:4201)	/* nameless struct/union */

#include <malloc.h>
#include <caldbg.h>
#include <calrc.h>

#include <align.h>
#include <ex\calcom.h>
#include <ex\buffer.h>
#include <ex\cnvt.h>

#include <davsc.h>

#include <statetok.h>
#include <sz.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\pclibdef.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PCLIBDEF.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_pclib.h"



//	========================================================================
//
//	CLASS CPublisher
//
class CPublisher : private Singleton<CPublisher>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CPublisher>;

	//
	//	Shared memory heap initialization.  Declare before any member
	//	variables which use the shared memory heap to ensure proper
	//	order of destruction.
	//
	CSmhInit m_smh;

	//
	//	Perf counter data
	//
	auto_ptr<ICounterData> m_pCounterData;

	//	CREATORS
	//
	CPublisher() {}

	//	NOT IMPLEMENTED
	//
	CPublisher& operator=( const CPublisher& );
	CPublisher( const CPublisher& );

public:
	//	STATICS
	//
	using Singleton<CPublisher>::CreateInstance;
	using Singleton<CPublisher>::DestroyInstance;
	using Singleton<CPublisher>::Instance;

	//	CREATORS
	//
	BOOL FInitialize( LPCWSTR lpwszInstanceName );

	//	MANIPULATORS
	//
	IPerfObject * NewPerfObject( const PERF_OBJECT_TYPE& pot )
	{
		Assert( m_pCounterData.get() );
		return m_pCounterData->CreatePerfObject( pot );
	}
};

//	------------------------------------------------------------------------
//
//	CPublisher::FInitialize()
//
BOOL
CPublisher::FInitialize( LPCWSTR lpwszInstanceName )
{
	//
	//	Initialize the shared memory heap
	//
	if ( !m_smh.FInitialize( lpwszInstanceName ) )
		return FALSE;

	//
	//	Bind to the counter data
	//
	m_pCounterData = NewCounterPublisher( lpwszInstanceName );
	if ( !m_pCounterData.get() )
		return FALSE;

	return TRUE;
}


//	========================================================================
//
//	NAMESPACE PCLIB
//
BOOL __fastcall
PCLIB::FInitialize( LPCWSTR lpwszSignature )
{
	if ( CPublisher::CreateInstance().FInitialize( lpwszSignature ) )
		return TRUE;

	CPublisher::DestroyInstance();
	return FALSE;
}

VOID __fastcall
PCLIB::Deinitialize()
{
	CPublisher::DestroyInstance();
}

IPerfObject * __fastcall
PCLIB::NewPerfObject( const PERF_OBJECT_TYPE& pot )
{
	return CPublisher::Instance().NewPerfObject( pot );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\_pclib.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_PCLIB.H
//
//		PCLIB precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_pclib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\ctripc.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CTRIPC.CPP
//
//	Perf counter data IPC
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//
//
//	PCLIB uses shared memory to communicate between one process
//	generating performance data and any number of processes gathering
//	the data.  Performance data is stored in shared memory in separate
//	structures whose layout is compatible with system-defined perf data
//	structures (PERF_OBJECT_TYPE, PERF_INSTANCE_DEFINITION, etc.).
//	Data collection is thus a simple matter of iterating over the data
//	in shared memory and copying it into the buffer provided by the
//	data-gathering process.
//
//	Additional structures -- links -- tie the data structures together
//	into doubly-linked lists to make the iteration possible and to make
//	removal of an individual structure an O(constant) operation.
//	Since pointers are meaningless in the context of shared memory,
//	links refer to one another using SharedHandles (see inc\smh.h).
//
//	Every item (data and links) in shared memory is refcounted and
//	all references between items are strong (i.e. "AddRef'd").  This
//	property simplifies memory management: an object is always freed
//	when its last reference goes away, regardless which process held
//	it.  It also eliminates a level of synchronization that would
//	otherwise be necessary to ensure that a process can always bind
//	a pointer to any given item in shared memory without having to
//	deal with the possibility of that item going away at the same time.
//
//	On the perf data generation side, classes are provided which encapsulate
//	access to the per-instance perf data in shared memory.  This decouples
//	PCLIB consumers from the format of the perf data in shared memory.
//	It also provides a way to manipulate the perf data through pointers
//	rather than through handles.
//
#include "_pclib.h"
#include "perfutil.h"


//	!!! IMPORTANT !!!
//
//	If you make ANY change to shared memory data structures (including
//	the CPerfHeader class), you MUST increment the version below.
//	Doing this prevents potentially incompatible publishers and monitors
//	from binding to one another and thus avoids the possibility of
//	crashes due to mismatched expectations about the format or
//	contents of those structures.
//
static WCHAR gsc_wszDataVersion[] = L"Version 1";


//	========================================================================
//
//	CLASS IPerfCounterBlock
//	CLASS IPerfObject
//	CLASS ICounterData
//

//	------------------------------------------------------------------------
//
//	Out of line virtual destructors for interface classes.
//
IPerfCounterBlock::~IPerfCounterBlock() {}
IPerfObject::~IPerfObject() {}
ICounterData::~ICounterData() {}


//	========================================================================
//
//	TEMPLATE CLASS CLink
//
//	Class used to implement linked lists in shared memory.  Making the
//	link itself a separate item from the data being linked together
//	means the list insertion/removal code is written once.
//
template<class _X>
class CLink
{
	//
	//	Handles to the previous and next links
	//
	SharedHandle<CLink<_X> > m_shLinkNext;
	SharedHandle<CLink<_X> > m_shLinkPrev;

	//
	//	Handle to the data
	//
	SharedHandle<_X> m_shX;

	//	NOT IMPLEMENTED
	//
	CLink& operator=( const CLink& );
	CLink( const CLink& );

public:
	//	CREATORS
	//
	CLink() {}

	//	STATICS
	//
	static VOID Link( SharedPtr<CLink<_X> >& pLinkHead,
					  SharedPtr<CLink<_X> >& pLinkNew )
	{
		SharedPtr<CLink<_X> > pLinkHeadNext;

		//
		//	Insert the new link at the head of the list.
		//	Note that the link representing the list head
		//	DOES NOT MOVE.  Rather, the new link is inserted
		//	immediately after the head.  This allows
		//	references to the head of the list to remain
		//	constant throughout insertions and deletions.
		//
		pLinkNew->m_shLinkPrev = pLinkHead.GetHandle();
		pLinkNew->m_shLinkNext = pLinkHead->m_shLinkNext;

		if ( pLinkHeadNext.FBind( pLinkHead->m_shLinkNext ) )
			pLinkHeadNext->m_shLinkPrev = pLinkNew.GetHandle();

		pLinkHead->m_shLinkNext = pLinkNew.GetHandle();
	}

	static VOID Unlink( SharedPtr<CLink<_X> >& pLink )
	{
		SharedPtr<CLink<_X> > pLinkPrev;

		if ( pLinkPrev.FBind( pLink->m_shLinkPrev ) )
			pLinkPrev->m_shLinkNext = pLink->m_shLinkNext;

		SharedPtr<CLink<_X> > pLinkNext;

		if ( pLinkNext.FBind( pLink->m_shLinkNext ) )
			pLinkNext->m_shLinkPrev = pLink->m_shLinkPrev;
	}

	//	MANIPULATORS
	//
	VOID SetData( SharedPtr<_X>& spX )
	{
		m_shX = spX.GetHandle();
	}

	SharedHandle<_X>& ShData()
	{
		return m_shX;
	}

	SharedHandle<CLink<_X> >& ShLinkNext()
	{
		return m_shLinkNext;
	}
};


//	========================================================================
//
//	CLASS CPerfHeader
//
//	Counter data header.  The sole instance of this class exists in
//	the named file mapping (not shared memory) agreed upon by the
//	data-generating and data-gathering processes.  That instance exists
//	exactly as long as a configured view of the file exists; it is never
//	explicitly delete()'d.
//
//	A refcounting mechanism similar to what is used for singletons in
//	global memory provides guarded process-independent access to the
//	counter data without synchronization.  I.e. the last process to
//	finish using the counter data is responsible for its cleanup,
//	regardless whether that process is data-generating or data-gathering.
//
//$OPT	The initialization mechanism of this class should be identical
//$OPT	to the RefCountedGlobal template in \cal\src\inc\singlton.h.
//$OPT	Unfortunately, we can't use the template because it requires
//$OPT	that the class be defined in static (global) memory.  This
//$OPT	class exists only in shared memory.  We should find a way
//$OPT	to eliminate that limitation and commonize the code.
//
struct SObjectDefinition;
class CPerfHeader
{
	//
	//	The object's reference count.
	//
	LONG m_lcRef;

	//
	//	Set of states which describe the state
	//	of initialization.  The state is
	//	STATE_UNKNOWN while we are initializing
	//	or deinitializing.
	//
	enum
	{
		STATE_UNINITIALIZED,
		STATE_INITIALIZED,
		STATE_UNKNOWN
	};

	LONG m_lState;

	//
	//	Handle to perf object list
	//
	SharedHandle<CLink<SObjectDefinition> > m_shLinkObjectList;

	//	MANIPULATORS
	//
	BOOL FInit()
	{
		SharedPtr<CLink<SObjectDefinition> > spLinkObjectList;

		if ( !spLinkObjectList.FCreate() )
			return FALSE;

		m_shLinkObjectList = spLinkObjectList.GetHandle();
		return TRUE;
	}

	VOID Deinit()
	{
		SharedHandle<CLink<SObjectDefinition> > shNull;

		m_shLinkObjectList = shNull;
	}

	//	CREATORS
	//
	//	The only instance of this class should never
	//	be destroyed, so declare the destructor as private.
	//
	~CPerfHeader();

public:
	//	STATICS
	//
	//	Define placement operator new so that we can instantiate
	//	the perf header in the mapped view of the named
	//	file mapping.
	//
	static void * operator new(size_t, void * pv)
	{
		Assert( pv != NULL );
		return pv;
	}

	//	CREATORS
	//
	CPerfHeader() :
		m_lcRef(0),
		m_lState(STATE_UNINITIALIZED)
	{
	}

	//	ACCESSORS
	//
	SharedHandle<CLink<SObjectDefinition> >& ShLinkObjectList()
	{
		Assert( m_lcRef > 0 );
		Assert( m_lState == STATE_INITIALIZED );

		return m_shLinkObjectList;
	}

	//	MANIPULATORS
	//
	DWORD DwInitRef()
	{
		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( m_lState != STATE_INITIALIZED || m_lcRef >= 1 );

		//
		//	Add the reference for the instance we're about
		//	to initialize.  Doing this now simplifies the
		//	code below at the expense of having to decrement
		//	if first time initialization (FInit()) fails.
		//	The only thing critical to the design is that
		//	at any point, when m_lState is STATE_INITIALIZED,
		//	m_lcRef is at least 1.
		//
		LONG lcRef = InterlockedIncrement( &m_lcRef );
		Assert( lcRef > 0 );

		//
		//	Don't proceed until the object is initialized.
		//
		while ( m_lState != STATE_INITIALIZED )
		{
			//
			//	Simultaneously check whether initialization has
			//	started and, if it has not, start it.
			//
			LONG lStatePrev = InterlockedCompareExchange(
								&m_lState,
								STATE_UNKNOWN,
								STATE_UNINITIALIZED );

			//
			//	If we're starting first time initialization,
			//	then create and initialize the sole instance.
			//
			if ( lStatePrev == STATE_UNINITIALIZED )
			{
				if ( FInit() )
				{
					m_lState = STATE_INITIALIZED;
					break;
				}

				//	We failed to init.
				//	Tear down now.
				//
				Assert( lcRef == 1 );
				Assert( m_lState == STATE_UNKNOWN );

				//	Let go of our ref on the object.
				//	Destroy the object.
				//	And LAST, set the state to UNINITIALIZED.
				//	NOTE: This will let the next caller through the
				//	InterlockedCompare above.
				//
				InterlockedDecrement( &m_lcRef );
				Deinit();
				m_lState = STATE_UNINITIALIZED;

				return 0;
			}

			//
			//	If first time initialization is in progress on
			//	another thread, then get out of the way so
			//	it can finish.
			//
			//$OPT	We should probably spin rather than Sleep()
			//$OPT	on multi-proc machines on the assumption that
			//$OPT	we only get here on a processor other than
			//$OPT	the one which is doing the initialization
			//$OPT	and we don't want to invite a task switch
			//$OPT	by calling Sleep() while we are waiting
			//$OPT	for initialization to complete.
			//
			if ( lStatePrev == STATE_UNKNOWN )
				Sleep(0);
		}

		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( m_lState == STATE_INITIALIZED );
		Assert( m_lcRef > 0 );

		return static_cast<DWORD>(lcRef);
	}

	VOID DeinitRef()
	{
		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( m_lState == STATE_INITIALIZED );
		Assert( m_lcRef > 0 );

		//
		//	Remove that reference.  If it is the last
		//	then deinit the object.
		//
		if ( 0 == InterlockedDecrement( &m_lcRef ) )
		{
			//
			//	After releasing the last reference, declare that
			//	the object is in an unknown state.  This prevents
			//	other threads trying to re-initialize the object
			//	from proceeding until we're done.
			//
			m_lState = STATE_UNKNOWN;

			//
			//	There is a tiny window between decrementing the
			//	refcount and changing the state where another
			//	initialization could have come through.  Test this
			//	by rechecking the refcount.
			//
			if ( 0 == m_lcRef )
			{
				//
				//	If the refcount is still zero, then no
				//	initializations happened before we changed
				//	states.  At this point, if an initialization
				//	starts, it will block until we change state,
				//	so it is safe to actually deinit the instance.
				//
				Deinit();

				//
				//	Once the object has been deinitialized, update
				//	the state information.  This unblocks any
				//	initializations waiting to happen.
				//
				m_lState = STATE_UNINITIALIZED;
			}
			else // refcount is now non-zero
			{
				//
				//	If the refcount is no longer zero, then an
				//	initialization happened between decrementing
				//	the refcount above and entering the unknown
				//	state.  When that happens, DO NOT deinit --
				//	there is now another valid reference somewhere.
				//	Instead, just restore the object's state to let
				//	other references proceed.
				//
				m_lState = STATE_INITIALIZED;
			}
		}

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( m_lState != STATE_INITIALIZED || m_lcRef >= 1 );
	}
};

//	========================================================================
//
//	STRUCT SObjectDefinition
//
//	Encapsulates the perf object type definition and the
//	counter definitions that follow it.
//
//	NOTE: Instances of this structure exist only in shared memory.
//
struct SInstanceDefinition;
struct SObjectDefinition
{
	//
	//	Handle to the instance list
	//
	SharedHandle<CLink<SInstanceDefinition> > shLinkInstanceList;

	//
	//	Object type
	//
	PERF_OBJECT_TYPE pot;

	//
	//	Array of counter definitions
	//
	PERF_COUNTER_DEFINITION rgcd[1];

	DWORD DwCollectData( DWORD dwFirstCounter,
						 LPBYTE * plpbPerfData,
						 LPDWORD lpdwcbPerfData );
};

//	========================================================================
//
//	STRUCT SInstanceDefinition
//
//	Counter instance definition which includes the instance name
//	and counter block that follows it.
//
//	NOTE: Instances of this structure exist only in shared memory.
//
struct SCounterBlock;
struct SInstanceDefinition
{
	//
	//	Instance definition, including instance name
	//	which must follow it immediately
	//
	PERF_INSTANCE_DEFINITION pid;
	WCHAR rgwchName[1];

	//
	//	Counter data beginning with the PERF_COUNTER_BLOCK resides
	//	at the next DWORD-aligned boundary following the instance name.
	//	However, since the length of the instance name is unknown at
	//	compile time, the address of the first counter cannot be identified
	//	by a symbol.  PerfCounterBlock() provides this information at
	//	runtime by returning the location of the counter block.
	//
	SCounterBlock& PerfCounterBlock()
	{
		return *reinterpret_cast<SCounterBlock *>(
					reinterpret_cast<BYTE *>(&pid) + pid.ByteLength );
	}

	DWORD DwCollectData( LPBYTE * plpbPerfData,
						 LPDWORD lpdwcbPerfData );
};

//	========================================================================
//
//	STRUCT SCounterBlock
//
//	Counter block definition which includes a symbol for the
//	array of counter values that follow it.
//
//	NOTE: Instances of this structure exist only in shared memory.
//
struct SCounterBlock
{
	PERF_COUNTER_BLOCK pcb;
	LONG rglValues[1];
};



//	========================================================================
//
//	CLASS CCounterData
//
class CCounterData :
	public ICounterData,
	private Singleton<CCounterData>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CCounterData>;

	//
	//	Named file mapping containing a handle to the
	//	location in shared memory of the counter data header
	//
	auto_handle<HANDLE>	m_hMapping;

	//
	//	Pointer to the perf data header in the mapped
	//	view of shared memory.
	//
	BOOL m_fInitializedPerfHeader;
	CPerfHeader * m_pPerfHeader;

	//
	//	Flag to indicate whether this counter data instance
	//	is initialized as a publisher.  If it is, then we
	//	need to make sure we set the appropriate bit in the
	//	perf header when we're done so that the next publisher
	//	to come will know whether we crashed.
	//
	BOOL m_fInitializedPublisher;

	//
	//	Pointer to the object list
	//
	SharedPtr<CLink<SObjectDefinition> > m_spLinkObjectList;

	//
	//	Event that is signalled whenever the mapped view
	//	is ready for use.  This event is non-signalled
	//	while the mapping is being set up.
	//
	CEvent m_evtViewReady;

	//	CREATORS
	//
	CCounterData() :
		m_fInitializedPerfHeader(FALSE),
		m_fInitializedPublisher(FALSE),
		m_pPerfHeader(NULL)
	{
	}

	~CCounterData();
	BOOL FInitialize( LPCWSTR lpwszSignature );

	//	NOT IMPLEMENTED
	//
	CCounterData& operator=( const CCounterData& );
	CCounterData( const CCounterData& );

public:
	using Singleton<CCounterData>::CreateInstance;
	using Singleton<CCounterData>::DestroyInstance;
	using Singleton<CCounterData>::Instance;

	//	CREATORS
	//
	BOOL FInitializePublisher( LPCWSTR lpwszSignature )
	{
		m_fInitializedPublisher = FInitialize( lpwszSignature );
		return m_fInitializedPublisher;
	}

	BOOL FInitializeMonitor( LPCWSTR lpwszSignature )
	{
		return FInitialize( lpwszSignature );
	}

	//	MANIPULATORS
	//
	IPerfObject * CreatePerfObject( const PERF_OBJECT_TYPE& pot );

	DWORD DwCollectData( LPCWSTR lpwszCounterIndices,
						 DWORD   dwFirstCounter,
						 LPVOID * plpvPerfData,
						 LPDWORD lpdwcbPerfData,
						 LPDWORD lpcObjectTypes );
};

//	========================================================================
//
//	CLASS CPerfObject
//
class CPerfObject : public IPerfObject
{
	//
	//	Pointer to the object definition in shared memory
	//
	SharedPtr<SObjectDefinition> m_spDefinition;

	//
	//	Pointer to the link to that definition
	//
	SharedPtr<CLink<SObjectDefinition> > m_spLinkObject;

	//
	//	Pointer to the list of instances of that definition
	//
	SharedPtr<CLink<SInstanceDefinition> > m_spLinkInstanceList;

	//
	//	Critical section to protect the instance list from
	//	multiple threads simultaneously trying to add instances.
	//
	CCriticalSection m_csInstanceList;

	//	CREATORS
	//
	CPerfObject() {}
	BOOL FInitialize( const PERF_OBJECT_TYPE& pot );

	//	NOT IMPLEMENTED
	//
	CPerfObject& operator=( const CPerfObject& );
	CPerfObject( const CPerfObject& );

public:
	//	STATICS
	//
	static CPerfObject *
	Create( const PERF_OBJECT_TYPE& pot );

	//	CREATORS
	//
	~CPerfObject();

	//	ACCESSORS
	//
	SharedPtr<CLink<SObjectDefinition> >& SpLink()
	{
		return m_spLinkObject;
	}

	//	MANIPULATORS
	//
	IPerfCounterBlock *
	NewInstance( const PERF_INSTANCE_DEFINITION& pid,
				 const PERF_COUNTER_BLOCK& pcb );
};

//	========================================================================
//
//	CLASS CPerfInstance
//
class CPerfInstance : public IPerfCounterBlock
{
	//
	//	Pointer to the instance definition in shared memory
	//
	SharedPtr<SInstanceDefinition> m_spDefinition;

	//
	//	Pointer to the link to that definition
	//
	SharedPtr<CLink<SInstanceDefinition> > m_spLinkInstance;

	//	CREATORS
	//
	CPerfInstance() {}
	BOOL FInitialize( const PERF_INSTANCE_DEFINITION& pid,
					  const PERF_COUNTER_BLOCK& pcb );

	//	NOT IMPLEMENTED
	//
	CPerfInstance& operator=( const CPerfInstance& );
	CPerfInstance( const CPerfInstance& );

public:
	//	STATICS
	//
	static CPerfInstance *
	Create( const PERF_INSTANCE_DEFINITION& pid,
			const PERF_COUNTER_BLOCK& pcb );

	//	CREATORS
	//
	~CPerfInstance();

	//	ACCESSORS
	//
	SharedPtr<CLink<SInstanceDefinition> >& SpLink()
	{
		return m_spLinkInstance;
	}

	//	MANIPULATORS
	//
	VOID IncrementCounter( UINT iCounter );
	VOID DecrementCounter( UINT iCounter );
	VOID SetCounter( UINT iCounter, LONG lValue );
};



//	========================================================================
//
//	CLASS CPerfInstance
//

//	------------------------------------------------------------------------
//
//	CPerfInstance::Create()
//
CPerfInstance *
CPerfInstance::Create(
	const PERF_INSTANCE_DEFINITION& pid,
	const PERF_COUNTER_BLOCK& pcb )
{
	CPerfInstance * pPerfInstance = new CPerfInstance();

	if ( pPerfInstance->FInitialize( pid, pcb ) )
		return pPerfInstance;

	delete pPerfInstance;
	return NULL;
}

//	------------------------------------------------------------------------
//
//	CPerfInstance::FInitialize()
//
BOOL
CPerfInstance::FInitialize(
	const PERF_INSTANCE_DEFINITION& pid,
	const PERF_COUNTER_BLOCK& pcb )
{
	if ( !m_spDefinition.FCreate( pid.ByteLength + pcb.ByteLength ) )
		return FALSE;

	memcpy( &m_spDefinition->pid,
			&pid,
			pid.ByteLength );

	memcpy( &m_spDefinition->PerfCounterBlock().pcb,
			&pcb,
			pcb.ByteLength );

	if ( !m_spLinkInstance.FCreate() )
		return FALSE;

	m_spLinkInstance->SetData( m_spDefinition );

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CPerfInstance::~CPerfInstance()
//
CPerfInstance::~CPerfInstance()
{
	//
	//	Unlink the instance definition.
	//
	CLink<SInstanceDefinition>::Unlink( m_spLinkInstance );
}

//	------------------------------------------------------------------------
//
//	CPerfInstance::IncrementCounter()
//
VOID
CPerfInstance::IncrementCounter( UINT iCounter )
{
	InterlockedIncrement( &m_spDefinition->PerfCounterBlock().rglValues[iCounter] );
}

//	------------------------------------------------------------------------
//
//	CPerfInstance::DecrementCounter()
//
VOID
CPerfInstance::DecrementCounter( UINT iCounter )
{
	InterlockedDecrement( &m_spDefinition->PerfCounterBlock().rglValues[iCounter] );
}

//	------------------------------------------------------------------------
//
//	CPerfInstance::SetCounter()
//
VOID
CPerfInstance::SetCounter( UINT iCounter, LONG lValue )
{
	m_spDefinition->PerfCounterBlock().rglValues[iCounter] = lValue;
}

//	========================================================================
//
//	CLASS CPerfObject
//

//	------------------------------------------------------------------------
//
//	CPerfObject::Create()
//
CPerfObject *
CPerfObject::Create( const PERF_OBJECT_TYPE& pot )
{
	CPerfObject * pPerfObject = new CPerfObject();

	if ( pPerfObject->FInitialize( pot ) )
		return pPerfObject;

	delete pPerfObject;
	return NULL;
}

//	------------------------------------------------------------------------
//
//	CPerfObject::FInitialize()
//
BOOL
CPerfObject::FInitialize( const PERF_OBJECT_TYPE& pot )
{
	if ( !m_spDefinition.FCreate( pot.DefinitionLength ) )
		return FALSE;

	memcpy( &m_spDefinition->pot,
			&pot,
			pot.DefinitionLength );

	if ( !m_spLinkObject.FCreate() )
		return FALSE;

	m_spLinkObject->SetData( m_spDefinition );

	if ( !m_spLinkInstanceList.FCreate() )
		return FALSE;

	m_spDefinition->shLinkInstanceList = m_spLinkInstanceList.GetHandle();

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CPerfObject::~CPerfObject()
//
CPerfObject::~CPerfObject()
{
	//
	//	Unlink the object definition.
	//
	CLink<SObjectDefinition>::Unlink( m_spLinkObject );
}

//	------------------------------------------------------------------------
//
//	CPerfObject::NewInstance()
//
IPerfCounterBlock *
CPerfObject::NewInstance(
	const PERF_INSTANCE_DEFINITION& pid,
	const PERF_COUNTER_BLOCK& pcb )
{
	CPerfInstance * pPerfInstance = CPerfInstance::Create( pid, pcb );

	if ( pPerfInstance )
	{
		//
		//	Lock down the instance list so that multiple threads
		//	adding instances simultaneously don't mess it up.
		//
		CSynchronizedBlock sb(m_csInstanceList);

		//
		//	Link the new instance into the instance list
		//
		CLink<SInstanceDefinition>::Link(
			m_spLinkInstanceList,
			pPerfInstance->SpLink() );
	}

	return pPerfInstance;
}


//	========================================================================
//
//	CLASS CCounterData
//

//	------------------------------------------------------------------------
//
//	CCounterData::~CCounterData()
//
CCounterData::~CCounterData()
{
	if ( m_fInitializedPerfHeader )
	{
		Assert( m_pPerfHeader );
		m_pPerfHeader->DeinitRef();
	}

	if ( m_pPerfHeader )
		(void) UnmapViewOfFile( m_pPerfHeader );
}

//	------------------------------------------------------------------------
//
//	CCounterData::FInitialize()
//
//	Initialize by binding to the block of shared memory where
//	the counter data is stored and getting or initializing the
//	handle to the counter data header.
//
BOOL
CCounterData::FInitialize( LPCWSTR lpwszSignature )
{
	SECURITY_DESCRIPTOR sdAllAccess;
	SECURITY_ATTRIBUTES saAllAccess;
	DWORD               dwLastError = 0;

	LPSECURITY_ATTRIBUTES lpsa = NULL;

	//
	//	First, set up security descriptor and attributes so that
	//	the system objects created below are accessible from both
	//	the process that produces the counter data and the process
	//	that consumes it.
	//
	//$HACK	- Special case for HTTPEXT
	//
	//	To meet C2 security requirements, we cannot have any completely
	//	open objects.  Fortunately, HTTPEXT only uses this code for its
	//	perf counters which are both generated and gathered in the same
	//	process (W3SVC) and same security context (local system).  Access
	//	can thus be left to the default (local system or admin only).
	//
	if (lpwszSignature != wcsstr(lpwszSignature, L"HTTPEXT"))
	{
		(void) InitializeSecurityDescriptor( &sdAllAccess, SECURITY_DESCRIPTOR_REVISION );
		SetSecurityDescriptorDacl( &sdAllAccess, TRUE, NULL, FALSE );

		saAllAccess.nLength              = sizeof(saAllAccess);
		saAllAccess.lpSecurityDescriptor = &sdAllAccess;
		saAllAccess.bInheritHandle       = FALSE;

		lpsa = &saAllAccess;
	}

	//
	//	Bind to a named file mapping containing the perf data header.
	//
	static const WCHAR sc_wszHeaderFileMappingName[] =
		L"Global\\PCLIB/%s/CCounterData/FInit/sc_wszHeaderFileMappingName: %s";

	WCHAR lpwszMappingName[256];
	Assert (sizeof(lpwszMappingName) >=
			(sizeof(sc_wszHeaderFileMappingName) +
			 sizeof(gsc_wszDataVersion) +
			 sizeof(WCHAR) * wcslen(lpwszSignature)));

	swprintf( lpwszMappingName,
			  sc_wszHeaderFileMappingName,
			  gsc_wszDataVersion,
			  lpwszSignature );

	m_hMapping = CreateFileMappingW( INVALID_HANDLE_VALUE,
									 lpsa,
									 PAGE_READWRITE,
									 0,
									 sizeof(CPerfHeader),
									 lpwszMappingName );

	if ( !m_hMapping.get() )
	{
		DebugTrace( "CCounterData::FInitialize() - CreateFileMappingW() failed (%d)\n", GetLastError() );
		return FALSE;
	}

    //  Remember the last error before the resource registration
    //  call since I have seen that GLE value may change inside
    //  this debug only function.
    //
    dwLastError = GetLastError();

	//
	//	Determine if the file mapping existed before we bound
	//	to it.  This tells us whether we need to initialize
	//	counter data structures in shared memory.
	//
	//	If the file mapping did not exist until we bound to it,
	//	then initialize the counter data by creating an empty
	//	counter data header.  Stuff the shared memory handle
	//	to the header into the mapping for all to use.
	//
	//	If the file mapping already exists, then another process
	//	has either already initialized the counter data or is
	//	in the process of doing so.  Wait on a named initialization
	//	completion event to be sure it's done before proceeding.
	//
	BOOL fCreatedView = (ERROR_SUCCESS == dwLastError);
	Assert( fCreatedView || ERROR_ALREADY_EXISTS == dwLastError );


	m_pPerfHeader = static_cast<CPerfHeader *>(
		MapViewOfFile( m_hMapping.get(),
					   FILE_MAP_ALL_ACCESS,
					   0,
					   0,
					   0 ) );

	if ( !m_pPerfHeader )
	{
		DebugTrace( "CCounterData::FInitialize() - MapViewOfFile() failed (%d)\n", GetLastError() );
		return FALSE;
	}

	static const WCHAR sc_wszEvtViewReadyFmt[] =
		L"Global\\PCLIB/%s/CCounterData/sc_wszEvtViewReady: %s";

	WCHAR lpwszEvtViewReady[256];
	Assert (sizeof(lpwszEvtViewReady) >=
			(sizeof(sc_wszEvtViewReadyFmt) +
			 sizeof(gsc_wszDataVersion) +
			 sizeof(WCHAR) * wcslen(lpwszSignature)));

	swprintf( lpwszEvtViewReady,
			  sc_wszEvtViewReadyFmt,
			  gsc_wszDataVersion,
			  lpwszSignature );

	if ( !m_evtViewReady.FCreate( "PCLIB/CCounterData/m_evtViewReady",
								  lpsa,			// global accessibility
								  TRUE,         // manual reset
								  FALSE,        // initially non-signalled
								  lpwszEvtViewReady,
								  TRUE) )		// don't munge the event name!  It has a '\' in
												// it intentionally.
	{
		DebugTrace( "CCounterData::FInitialize() - Error creating m_evtViewReady (%d)\n", GetLastError() );
		return FALSE;
	}

	//
	//	If we created the view then we'll need to initialize
	//	it to a known state before we (or any other process)
	//	can do anything useful with it.
	//
	if ( fCreatedView )
	{
		new(m_pPerfHeader) CPerfHeader();

		m_evtViewReady.Set();
	}
	else
	{
		m_evtViewReady.Wait();
	}

	//
	//	Get a reference to the perf header.  First thread/process in
	//	creates the header.  Note that the process that creates the
	//	header is not necessarily the same as the process that created
	//	and initialized the view above.
	//
	m_fInitializedPerfHeader = !!m_pPerfHeader->DwInitRef();
	if ( !m_fInitializedPerfHeader )
		return FALSE;

	//
	//	Bind a local pointer to the perf object list rooted at the header
	//
	if ( !m_spLinkObjectList.FBind( m_pPerfHeader->ShLinkObjectList() ) )
		return FALSE;

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CCounterData::CreatePerfObject()
//
IPerfObject *
CCounterData::CreatePerfObject( const PERF_OBJECT_TYPE& pot )
{
	CPerfObject * pPerfObject = CPerfObject::Create( pot );

	if ( pPerfObject )
	{
		CLink<SObjectDefinition>::Link(
			m_spLinkObjectList,
			pPerfObject->SpLink() );
	}

	return pPerfObject;
}

//	------------------------------------------------------------------------
//
//	CCounterData::DwCollectData()
//
DWORD
CCounterData::DwCollectData( LPCWSTR lpwszCounterIndices,
							 DWORD   dwFirstCounter,
							 LPVOID * plpvPerfData,
							 LPDWORD lpdwcbPerfData,
							 LPDWORD lpcObjectTypes )
{
	LPBYTE lpbPerfDataStart = static_cast<LPBYTE>(*plpvPerfData);
	LPBYTE lpbPerfDataCur = lpbPerfDataStart;
	DWORD  dwcbPerfDataBufRemaining = *lpdwcbPerfData;
	DWORD  cObjectTypes = 0;

	//
	//	Initialize the return values in case of failure
	//
	*lpdwcbPerfData = 0;
	*lpcObjectTypes = 0;

	//
	//	Figure out what kind of data is being asked for
	//
	DWORD dwQueryType = GetQueryType(lpwszCounterIndices);

	//
	//	We don't have any foreign data, so return immediately
	//	if that's what was asked for.
	//
	if ( QUERY_FOREIGN == dwQueryType )
		return ERROR_SUCCESS;

	SharedHandle<CLink<SObjectDefinition> > shLink;
	SharedPtr<CLink<SObjectDefinition> > spLink;

	for ( shLink = m_spLinkObjectList->ShLinkNext();
		  spLink.Clear(), spLink.FBind( shLink );
		  shLink = spLink->ShLinkNext() )
	{
		SharedPtr<SObjectDefinition> spDefinition;

		spDefinition.FBind( spLink->ShData() );

		if ( QUERY_GLOBAL == dwQueryType ||
			 IsNumberInUnicodeList( spDefinition->pot.ObjectNameTitleIndex + dwFirstCounter,
									lpwszCounterIndices ) )
		{
			DWORD dwResult =
				spDefinition->DwCollectData( dwFirstCounter,
											 &lpbPerfDataCur,
											 &dwcbPerfDataBufRemaining );

			if ( dwResult != ERROR_SUCCESS )
				return dwResult;

			// update the object count only if we collect data for the object.
			++cObjectTypes;
		}
	}

	//
	//	Fill in the successful return values
	//
	*plpvPerfData   = static_cast<LPVOID>(lpbPerfDataCur);
	*lpdwcbPerfData = static_cast<DWORD>(lpbPerfDataCur - lpbPerfDataStart);
	*lpcObjectTypes = cObjectTypes;

	return ERROR_SUCCESS;
}


//	========================================================================
//
//	CLASS SInstanceDefinition
//

//	------------------------------------------------------------------------
//
//	SInstanceDefinition::DwCollectData()
//
DWORD
SInstanceDefinition::DwCollectData( LPBYTE * plpbPerfData,
									LPDWORD lpdwcbPerfData )
{
	DWORD dwcbInstance = pid.ByteLength + PerfCounterBlock().pcb.ByteLength;

	if ( *lpdwcbPerfData < dwcbInstance )
		return ERROR_MORE_DATA;

	memcpy( *plpbPerfData,
			&pid,
			dwcbInstance );

	*plpbPerfData += dwcbInstance;
	*lpdwcbPerfData -= dwcbInstance;

	return ERROR_SUCCESS;
}


//	========================================================================
//
//	CLASS SObjectDefinition
//

//	------------------------------------------------------------------------
//
//	SObjectDefinition::DwCollectData()
//
DWORD
SObjectDefinition::DwCollectData( DWORD dwFirstCounter,
								  LPBYTE * plpbPerfData,
								  LPDWORD lpdwcbPerfData )
{
	//
	//	Determine whether we have enough room for at least the
	//	object definition (including the counter definitions).
	//
	if ( *lpdwcbPerfData < pot.DefinitionLength )
		return ERROR_MORE_DATA;

	//
	//	We've got enough room, so prepare to copy the data.  Set up
	//	pointers to the object type and counter defintions in the
	//	perf data being returned so that we can fixup things
	//	like total byte length and counter indices in the
	//	perf data before returning it.
	//
	PERF_OBJECT_TYPE * ppot =
		reinterpret_cast<PERF_OBJECT_TYPE *>( *plpbPerfData );

	PERF_COUNTER_DEFINITION * pcd =
		reinterpret_cast<PERF_COUNTER_DEFINITION *>( *plpbPerfData + pot.HeaderLength );

	//
	//	Copy over object type and counter definitions
	//
	memcpy( ppot,
			&pot,
			pot.DefinitionLength );

	*plpbPerfData += pot.DefinitionLength;
	*lpdwcbPerfData -= pot.DefinitionLength;

	//
	//	Copy over counter instances
	//
	SharedHandle<CLink<SInstanceDefinition> > shLink;
	SharedPtr<CLink<SInstanceDefinition> > spLink;

	SideAssert(spLink.FBind( shLinkInstanceList ));
	
	for ( shLink = spLink->ShLinkNext();
		  spLink.Clear(), spLink.FBind(shLink);
		  shLink = spLink->ShLinkNext()
				 )
	{
		SharedPtr<SInstanceDefinition> spDefinition;
		spDefinition.FBind( spLink->ShData() );

		DWORD dwResult = spDefinition->DwCollectData( plpbPerfData, lpdwcbPerfData );
		if ( dwResult != ERROR_SUCCESS )
			return dwResult;

		++ppot->NumInstances;		
	}

	//
	//	Compute the total byte length of the counter object and
	//	fixup the name/help title indices of the object and counters.
	//
	ppot->TotalByteLength = static_cast<DWORD>(*plpbPerfData - reinterpret_cast<LPBYTE>(ppot));
	Assert( ppot->TotalByteLength > 0 );

	ppot->ObjectNameTitleIndex += dwFirstCounter;
	ppot->ObjectHelpTitleIndex += dwFirstCounter;

	//
	//	Fixup the counters' title indices
	//
	for ( DWORD i = ppot->NumCounters; i-- > 0; )
	{
		pcd[i].CounterNameTitleIndex += dwFirstCounter;
		pcd[i].CounterHelpTitleIndex += dwFirstCounter;
	}

	return ERROR_SUCCESS;
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewCounterPublisher()
//
ICounterData * __fastcall
NewCounterPublisher( LPCWSTR lpwszSignature )
{
	if ( CCounterData::CreateInstance().FInitializePublisher( lpwszSignature ) )
		return &CCounterData::Instance();

	CCounterData::DestroyInstance();
	return NULL;
}

//	------------------------------------------------------------------------
//
//	NewCounterMonitor()
//
ICounterData * __fastcall
NewCounterMonitor( LPCWSTR lpwszSignature )
{
	if ( CCounterData::CreateInstance().FInitializeMonitor( lpwszSignature ) )
		return &CCounterData::Instance();

	CCounterData::DestroyInstance();
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\pclibmon.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PCLIBMON.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_pclib.h"		// Precompiled header

#include <ex\reg.h>		// Registry access
#include <eventlog.h>	// Event logging

static DWORD
DwGetFirstIndices( DWORD * pdwFirstCounter, DWORD * pdwFirstHelp );

static HINSTANCE g_hinst = NULL;
static WCHAR gc_wszDllPath[MAX_PATH+1];

//	========================================================================
//
//	CLASS CMonitor
//
class CMonitor : private Singleton<CMonitor>
{
	//
	//	Friend declaration required by Singleton template
	//
	friend class Singleton<CMonitor>;

	//
	//	"First Counter" and "First Help" indices from the registry.
	//	Added to the 0-relative indices of the counters in shared memory
	//	to get absolute indices to return to the monitoring application.
	//
	DWORD m_dwFirstCounter;
	DWORD m_dwFirstHelp;

	//
	//	Shared memory heap initialization.  Declare before any member
	//	variables which use the shared memory heap to ensure proper
	//	order of destruction.
	//
	CSmhInit m_smh;

	//
	//	Perf counter data
	//
	auto_ptr<ICounterData> m_pCounterData;

	//	CREATORS
	//
	CMonitor() {}

	//	NOT IMPLEMENTED
	//
	CMonitor& operator=( const CMonitor& );
	CMonitor( const CMonitor& );

public:
	using Singleton<CMonitor>::CreateInstance;
	using Singleton<CMonitor>::DestroyInstance;
	using Singleton<CMonitor>::Instance;

	//	CREATORS
	//
	BOOL FInitialize();

	//	ACCESSORS
	//
	DWORD DwCollectPerformanceData( LPCWSTR lpwszCounterIndices,
									LPVOID * plpvPerfData,
									LPDWORD lpdwcbPerfData,
									LPDWORD lpcObjectTypes )
	{
		return m_pCounterData->DwCollectData( lpwszCounterIndices,
											  m_dwFirstCounter,
											  plpvPerfData,
											  lpdwcbPerfData,
											  lpcObjectTypes );
	}
};

//	------------------------------------------------------------------------
//
//	CMonitor::FInitialize()
//
BOOL
CMonitor::FInitialize()
{
	//
	//	Get the "first counter" and "first help" values from the registry.
	//
	DWORD dwResult = DwGetFirstIndices( &m_dwFirstCounter, &m_dwFirstHelp );
	if ( ERROR_SUCCESS != dwResult )
		return FALSE;

	//
	//	Initialize the shared memory heap
	//
	if ( !m_smh.FInitialize( gc_wszPerfdataSource ) )
	{
		LPCWSTR rglpwsz[] = { gc_wszPerfdataSource };
		DWORD dwResult = GetLastError();

		DebugTrace( "CMonitor::FInitialize() - Error initializing shared memory heap %d\n", dwResult );

		LogEventW( PCLIB_ERROR_INITIALIZING_SHARED_MEMORY,
				   EVENTLOG_ERROR_TYPE,
				   sizeof(rglpwsz)/sizeof(LPCWSTR),
				   rglpwsz,
				   sizeof(DWORD),
				   &dwResult );

		return FALSE;
	}

	//
	//	Bind to the counter data
	//
	m_pCounterData = NewCounterMonitor( gc_wszPerfdataSource );
	if ( !m_pCounterData.get() )
	{
		LPCWSTR rglpwsz[] = { gc_wszPerfdataSource };
		DWORD dwResult = GetLastError();

		DebugTrace( "CMonitor::FInitialize() - Error binding to counter data %d\n", dwResult );

		LogEventW( PCLIB_ERROR_BINDING_TO_COUNTER_DATA,
				   EVENTLOG_ERROR_TYPE,
				   sizeof(rglpwsz)/sizeof(LPCWSTR),
				   rglpwsz,
				   sizeof(DWORD),
				   &dwResult );

		return FALSE;
	}

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	DwGetFirstIndices()
//
//	Gets the "first counter" and "first help" registry values for
//	this performance DLL.
//
DWORD
DwGetFirstIndices( DWORD * pdwFirstCounter, DWORD * pdwFirstHelp )
{
	DWORD dwResult;
	CRegKey regkey;

	//
	//	Open the registry key which contains the "first counter"
	//	and "first help" values.
	//
	{
		static const WCHAR sc_wszPerformanceRegKey[] =
			L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance";

		WCHAR lpwszKey[256];
		swprintf( lpwszKey, sc_wszPerformanceRegKey, gc_wszPerfdataSource );
		dwResult = regkey.DwOpen( HKEY_LOCAL_MACHINE, lpwszKey );
		if ( ERROR_SUCCESS != dwResult )
		{
			LPCWSTR rglpwsz[] = { gc_wszPerfdataSource, lpwszKey };
			DebugTrace( "DwGetFirstIndices() - Error opening Performance key (%d)\n", dwResult );
			LogEventW( PCLIB_ERROR_OPENING_PERF_KEY,
					   EVENTLOG_ERROR_TYPE,
					   sizeof(rglpwsz)/sizeof(LPCWSTR),
					   rglpwsz,
					   sizeof(DWORD),
					   &dwResult );

			return dwResult;
		}
	}

	//
	//	Query the "first counter" value
	//
	{
		DWORD dwcbFirstCounter = sizeof(*pdwFirstCounter);

		dwResult = regkey.DwQueryValue( L"First Counter",
										pdwFirstCounter,
										&dwcbFirstCounter );

		if ( ERROR_SUCCESS != dwResult )
		{
			LPCWSTR rglpwsz[] = { gc_wszPerfdataSource };
			DebugTrace( "DwGetFirstIndices() - Error querying First Counter value (%d)\n", dwResult );
			LogEventW( PCLIB_ERROR_READING_FIRST_COUNTER,
					   EVENTLOG_ERROR_TYPE,
					   sizeof(rglpwsz)/sizeof(LPCWSTR),
					   rglpwsz,
					   sizeof(DWORD),
					   &dwResult );

			return dwResult;
		}
	}

	//
	//	Query the "first help" value
	//
	{
		DWORD dwcbFirstHelp = sizeof(*pdwFirstHelp);
		dwResult = regkey.DwQueryValue( L"First Help",
										pdwFirstHelp,
										&dwcbFirstHelp );

		if ( ERROR_SUCCESS != dwResult )
		{
			LPCWSTR rglpwsz[] = { gc_wszPerfdataSource };
			DebugTrace( "DwGetFirstIndices() - Error querying First Help value (%d)\n", dwResult );
			LogEventW( PCLIB_ERROR_READING_FIRST_HELP,
					   EVENTLOG_ERROR_TYPE,
					   sizeof(rglpwsz)/sizeof(LPCWSTR),
					   rglpwsz,
					   sizeof(DWORD),
					   &dwResult );

			return dwResult;
		}
	}

	return ERROR_SUCCESS;
}


//	========================================================================
//
//	CLASS CMonitorInit
//
class CMonitorInit : private RefCountedGlobal<CMonitorInit>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CMonitorInit>;
	friend class RefCountedGlobal<CMonitorInit>;

	//
	//	Boolean flag whose value is TRUE if the
	//	monitor initialized, and FALSE if it didn't.
	//
	BOOL m_fMonitorInitialized;

	//	CREATORS
	//
	CMonitorInit()
	{
		m_fMonitorInitialized = CMonitor::CreateInstance().FInitialize();
	}

	~CMonitorInit()
	{
		CMonitor::DestroyInstance();
		m_fMonitorInitialized = FALSE;
	}

	BOOL FInit()
	{
		return TRUE;
	}

	//	NOT IMPLEMENTED
	//
	CMonitorInit& operator=( const CMonitorInit& );
	CMonitorInit( const CMonitorInit& );

public:
	using RefCountedGlobal<CMonitorInit>::DwInitRef;
	using RefCountedGlobal<CMonitorInit>::DeinitRef;

	static BOOL FInitialized()
	{
		return Instance().m_fMonitorInitialized;
	}
};


//	========================================================================
//
//	PUBLIC INTERFACE
//

//	------------------------------------------------------------------------
//
//	PclibOpenPerformanceData()
//
EXTERN_C DWORD APIENTRY
PclibOpenPerformanceData( LPCWSTR )
{
	CMonitorInit::DwInitRef();

	return ERROR_SUCCESS;
}

//	------------------------------------------------------------------------
//
//	PclibCollectPerfData()
//
EXTERN_C DWORD APIENTRY
PclibCollectPerformanceData( LPCWSTR lpwszCounterIndices,
							 LPVOID * plpvPerfData,
							 LPDWORD lpdwcbPerfData,
							 LPDWORD lpcObjectTypes )
{
	if ( CMonitorInit::FInitialized() )
		return CMonitor::Instance().
					DwCollectPerformanceData( lpwszCounterIndices,
											  plpvPerfData,
											  lpdwcbPerfData,
											  lpcObjectTypes );

	*lpdwcbPerfData = 0;
	*lpcObjectTypes = 0;
	return ERROR_SUCCESS;
}

//	------------------------------------------------------------------------
//
//	PclibClosePerformanceData()
//
EXTERN_C DWORD APIENTRY
PclibClosePerformanceData()
{
	CMonitorInit::DeinitRef();

	return ERROR_SUCCESS;
}

//	------------------------------------------------------------------------
//
//	PclibDllRegisterServer()
//
EXTERN_C STDAPI
PclibDllRegisterServer(VOID)
{
	HINSTANCE hinst;

	//	Get the module handle
	//
	hinst = GetModuleHandleW( gc_wszSignature );
	if (!hinst)
	{
		DebugTrace( "FDllEntry() - GetModuleFileName() failed in DLL_PROCESS_ATTACH\n" );
		return FALSE;
	}

	//	Get the full path to the DLL
	//
	if ( !GetModuleFileNameW( hinst, gc_wszDllPath, sizeof(gc_wszDllPath) ) )
	{
		DebugTrace( "FDllEntry() - GetModuleFileName() failed in DLL_PROCESS_ATTACH\n" );
		return FALSE;
	}

	return EventLogDllRegisterServer( gc_wszDllPath );
}

//	------------------------------------------------------------------------
//
//	PclibDllUnegisterServer()
//
EXTERN_C STDAPI
PclibDllUnregisterServer(VOID)
{
	return EventLogDllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\perfutil.h ===
/*
 *	P E R F U T I L . H
 *
 *	PerfCounter Utilities header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _PERFUTIL_H
#define _PERFUTIL_H

enum
{
	QUERY_GLOBAL = 1,
	QUERY_ITEMS,
	QUERY_FOREIGN,
	QUERY_COSTLY
};

BOOL IsNumberInUnicodeList (IN DWORD  dwNumber, IN LPCWSTR lpwszUnicodeList);
DWORD GetQueryType (IN LPCWSTR lpszValue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\perfutil.cpp ===
/*
 *	P E R F U T I L . C P P
 *
 *	PerfCounter Utilities source
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_pclib.h"   // Precompiled header
#include "perfutil.h"

#include <string.h>

WCHAR  GLOBAL_STRING[]	= L"Global";
WCHAR  FOREIGN_STRING[] = L"Foreign";
WCHAR  COSTLY_STRING[]	= L"Costly";
WCHAR  NULL_STRING[]	= L"\0";

#define DIGIT	  1
#define DELIMITER 2
#define INVALID	  3

#define EvalThisChar(c,d) ( \
	 (c == d) ? DELIMITER : \
	 (c == 0) ? DELIMITER : \
	 (c < (WCHAR)'0') ? INVALID : \
	 (c > (WCHAR)'9') ? INVALID : \
	 DIGIT)

//$--GetQueryType---------------------------------------------------------------
//	Returns the type of query described in the lpszValue string so that
//	the appropriate processing method may be used
//
//	Return Value
//
//	  QUERY_GLOBAL
//		  if lpszValue == NULL
//			 lpszValue == pointer to Null string
//			 lpszValue == pointer to "Global" string
//
//	  QUERY_FOREIGN
//		  if lpszValue == pointer to "Foriegn" string
//
//	  QUERY_COSTLY
//		  if lpszValue == pointer to "Costly" string
//
//	  otherwise:
//
//	  QUERY_ITEMS
//
// -----------------------------------------------------------------------------
DWORD GetQueryType(
	IN LPCWSTR lpszValue)
{
	const WCHAR * pwcArgChar	= NULL;
	const WCHAR * pwcTypeChar = NULL;
	BOOL	bFound		= FALSE;

	if(lpszValue == NULL)
	{
		return(QUERY_GLOBAL);
	}
	else if(*lpszValue == 0)
	{
		return(QUERY_GLOBAL);
	}

	// check for "Global" request

	pwcArgChar	= lpszValue;
	pwcTypeChar = GLOBAL_STRING;
	bFound		= TRUE;				// assume found until contradicted

	// check to the length of the shortest string

	while((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if(*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;			// bail out now
		}
	}

	if(bFound)
	{
		return(QUERY_GLOBAL);
	}

	// check for "Foreign" request

	pwcArgChar	= lpszValue;
	pwcTypeChar = FOREIGN_STRING;
	bFound		= TRUE;				// assume found until contradicted

	// check to the length of the shortest string

	while((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if(*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;			// bail out now
		}
	}

	if(bFound)
	{
		return(QUERY_FOREIGN);
	}

	// check for "Costly" request

	pwcArgChar	= lpszValue;
	pwcTypeChar = COSTLY_STRING;
	bFound		= TRUE;				// assume found until contradicted

	// check to the length of the shortest string

	while((*pwcArgChar != 0) && (*pwcTypeChar != 0))
	{
		if(*pwcArgChar++ != *pwcTypeChar++)
		{
			bFound = FALSE; // no match
			break;			// bail out now
		}
	}

	if(bFound)
	{
		return(QUERY_COSTLY);
	}

	//
	// If not Global and not Foreign and not Costly,
	// then it must be an item list.
	//

	return(QUERY_ITEMS);
}

//$--IsNumberInUnicodeList------------------------------------------------------
//	Checks for the existence of dwNumber in a list of UNICODE number strings.
// -----------------------------------------------------------------------------
BOOL IsNumberInUnicodeList(
	IN DWORD  dwNumber,
	IN LPCWSTR lpwszUnicodeList)
{
	DWORD	dwThisNumber = 0;
	const WCHAR * pwcThisChar	 = NULL;
	BOOL	bValidNumber = FALSE;
	BOOL	bNewItem	 = TRUE;
	WCHAR	wcDelimiter	 = L' ';

	if(lpwszUnicodeList == NULL)
	{
		return(FALSE);
	}

	pwcThisChar = lpwszUnicodeList;

	while(TRUE)
	{
		switch(EvalThisChar(*pwcThisChar, wcDelimiter))
		{
		case DIGIT:
			//
			// If this is the first digit after a delimiter, then
			// set flags to start computing the new number.
			//
			if(bNewItem)
			{
				bNewItem = FALSE;
				bValidNumber = TRUE;
			}

			if(bValidNumber)
			{
				dwThisNumber *= 10;
				dwThisNumber += (*pwcThisChar - (WCHAR)'0');
			}
			break;

		case DELIMITER:
			//
			// A delimter is either the delimiter character or the
			// end of the string ('\0') if, when the delimiter has been
			// reached, a valid number was found, then compare it to the
			// number from the argument list. If this is the end of the
			// string and no match was found, then return.
			//
			if(bValidNumber)
			{
				if(dwThisNumber == dwNumber)
				{
					return(TRUE);
				}

				bValidNumber = FALSE;
			}

			if(*pwcThisChar == 0)
			{
				return(FALSE);
			}
			else
			{
				bNewItem = TRUE;
				dwThisNumber = 0;
			}
			break;

		case INVALID:
			//
			// If an invalid character was encountered, ignore all
			// characters up to the next delimiter and then start fresh.
			// the invalid number is not compared.
			//
			bValidNumber = FALSE;
			break;

		default:
			break;
		}

		pwcThisChar++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pclib\_pclib.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_PCLIB.H
//
//		PCLIB precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __PCLIB_H_
#define __PCLIB_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>
#include <winperf.h>

//	CRT headers
//
#include <malloc.h>		// For _alloca()
#include <wchar.h>		// Wide character routines

//	Common DAV headers
//
#include <caldbg.h>		// Debugging support
#include <autoptr.h>	// Raw resource safe handling procedures
#include <synchro.h>	// Synchronization interfaces
#include <singlton.h>	// Singleton class templates
#include <smh.h>		// Shared memory

//	PCLIB headers
//
#include <pclib.h>		// PCLIB interface
#include <pclibmc.h>	// MC-Localized strings

#endif // !defined(__PCLIB_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pipeline\_pipeline.h ===
/*
 *	_ PIPELINE . H
 *
 *	Precompiled header sources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__PIPELINE_H_
#define __PIPELINE_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#include <malloc.h>




#endif	// __PIPELINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pipeline\_pipeline.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_PIPELINE.CPP
//
//		DAV parser precompiled header
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_pipeline.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_rgiter\rgiter.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RGITER.CPP
//
//		HTTP Range Iterator implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>

#pragma warning(disable:4201)	// nameless struct/union
#pragma warning(disable: 4284)	// operator-> to a non UDT

#include <tchar.h>
#include <stdio.h>
#include <string.h>

#include <caldbg.h>
#include <sz.h>
#include <davsc.h>
#include <ex\autoptr.h>
#include <ex\rgiter.h>

//	Class CRangeBase ----------------------------------------------------------
//
CRangeBase::~CRangeBase()
{
}

VOID
CRangeBase::CollapseUnknown()
{
	BYTE * pb;
	const RGITEM * prgi;
	DWORD cbrgi;
	DWORD dwOffset;
	DWORD irg;

	//	Rip through the list, collapsing as we go.
	//
	for (irg = 0, dwOffset = 0, pb = m_pbData.get();
		 irg < m_cRGList;
		 )
	{
		//	Find the current RGITEM structure
		//
		prgi = reinterpret_cast<RGITEM *>(pb + dwOffset);
		cbrgi = CbRangeItem(prgi);

		if (RANGE_UNKNOWN == prgi->uRT)
		{
			//	Slurp the remaining ranges down
			//
			memcpy (pb + dwOffset,					/* current rgitem */
					pb + dwOffset + cbrgi,			/* next rgitem    */
					m_cbSize - dwOffset - cbrgi);	/* size remaining */

			//	Adjust our stored values
			//
			m_cbSize -= cbrgi;
			m_cRGList -= 1;
		}
		else
		{
			dwOffset += cbrgi;
			irg += 1;
		}
	}
}

//	Fixup a range array against a given size
//
SCODE
CRangeBase::ScFixupRanges (DWORD dwSize)
{
	SCODE sc = W_DAV_PARTIAL_CONTENT;
	DWORD cUnknown = 0;

	//	The way this works is that we iterate through all the ranges and then
	//	fixup any of the items that need fixing up.  We remember the current
	//	position, and the current range -- this allows us to restore later as
	//	needed.
	//
	//	Store off the current item.
	//
	DWORD iCur = m_iCur;
	RGITEM * prgi = m_prgi;

	//	Rewind and iterate through....
	//
	for (Rewind(); PrgiNextRange(); )
	{
		//	Again, we only fixup RANGE_ROW items.
		//
		if (RANGE_ROW == m_prgi->uRT)
		{
			m_prgi->sc = S_OK;

			//	If we have a zero count of byte/rows, we need to handle it
			//	in a special way.
			//
			if (dwSize == 0)
			{
				//	Only range of format "-n" could be zero sized.
				//
				if (!FRangePresent (m_prgi->dwrgi.dwFirst))
				{
					Assert (FRangePresent(m_prgi->dwrgi.dwLast));

					//	Note, we don't have a way to represent NULL range.
					//	However, we do need to have range...
					//
					m_prgi->dwrgi.dwFirst = 0;
					m_prgi->dwrgi.dwLast = static_cast<DWORD>(RANGE_NOT_PRESENT);
				}
			}
			else
			{
				//	If we don't have a last count...
				//
				if (!FRangePresent (m_prgi->dwrgi.dwLast))
				{
					//	We must have checked the syntax already
					//
					Assert (FRangePresent(m_prgi->dwrgi.dwFirst));

					//	We have first byte to send, calculate last byte from size
					//	We need to send from first byte to end.
					//
					m_prgi->dwrgi.dwFirst = m_prgi->dwrgi.dwFirst;
					m_prgi->dwrgi.dwLast = dwSize - 1;
				}
				//
				//	... or a last count without a first count...
				//
				else if (!FRangePresent(m_prgi->dwrgi.dwFirst))
				{
					Assert (FRangePresent(m_prgi->dwrgi.dwLast));

					//	We have the last count dwLast, which means we need
					//	to send the last dwLast bytes. Calculate the first
					//	count from the size. If they specify a size greater
					//	then the size of entity, then use the size of the
					//	entire entity
					//
					DWORD dwLast = min(m_prgi->dwrgi.dwLast, dwSize);
					m_prgi->dwrgi.dwFirst = dwSize - dwLast;
					m_prgi->dwrgi.dwLast = dwSize - 1;
				}
				//
				//	... or both counts are present...
				//
				else
				{
					//	If they specify a last count that is beyond the actual
					//	count.
					//
					m_prgi->dwrgi.dwLast = min(m_prgi->dwrgi.dwLast, dwSize - 1);
				}

				//	Now perform one additional validity check.  If the start
				//	falls after the end, the range is not statisfiable.
				//
				if (m_prgi->dwrgi.dwLast < m_prgi->dwrgi.dwFirst)
				{
					//	In this case, we want to collapse this item out of the
					//	list so that we can handle the ranges properly in the
					//	IIS-side of range header handling.
					//
					//	Remember that we have this handling to do, and deal
					//	with it at a later time.
					//
					m_prgi->uRT = RANGE_UNKNOWN;
					m_prgi->sc = E_DAV_RANGE_NOT_SATISFIABLE;
					cUnknown += 1;
				}
			}
		}
	}

	//	If we did not find any valid ranges
	//
	if (cUnknown == m_cRGList)
	{
		//	None of the ranges were satisfiable for the entity size.
		//
		sc = E_DAV_RANGE_NOT_SATISFIABLE;
	}

	//	Now is the time when we want to collapse out any unknown ranges
	//	out of the list.
	//
	if (0 != cUnknown)
	{
		//	This is important handling for the case of byte-ranges where
		//	there is only one resulting range that is applicable.
		//
		CollapseUnknown();
	}

	//	Restore the current position and return
	//
	m_iCur = iCur;
	m_prgi = prgi;
	return sc;
}

const RGITEM *
CRangeBase::PrgiNextRange()
{
	const RGITEM * prgi = NULL;

	if (FMoreRanges())
	{
		UINT cb = 0;
		BYTE * pb = NULL;

		//	If the main pointer is NULL, then we know that we have not
		//	setup for any ranges yet.
		//
		if (NULL == m_prgi)
		{
			pb = reinterpret_cast<BYTE*>(m_pbData.get());
		}
		else
		{
			//	Otherwise, we need to adjust our position based
			//	on the size of the current item
			//
			//	Find the size of the item
			//
			cb = CbRangeItem (m_prgi);
			pb = reinterpret_cast<BYTE*>(m_prgi);
		}

		//	Scoot forward
		//
		m_prgi = reinterpret_cast<RGITEM*>(pb + cb);
		m_iCur += 1;

		//	Ensure the boundry
		//
		Assert (reinterpret_cast<BYTE*>(m_prgi) <= (m_pbData.get() + m_cbSize));
		prgi = m_prgi;
	}
	return prgi;
}

//	Class CRangeParser --------------------------------------------------------
//
CRangeParser::~CRangeParser()
{
}

//	Takes a range header and builds an array of ranges. Performs syntax
//	checking.
//
//	S_OK is returned if no syntax error, otherwise, S_FALSE is returned
//
SCODE
CRangeParser::ScParseRangeHdr (LPCWSTR pwszRgHeader, LPCWSTR pwszRangeUnit)
{
	LPCWSTR pwsz, pwszEnd;
	SCODE sc = S_OK;
	BOOL bFirst = FALSE, bLast = FALSE;
	DWORD dwFirst = 0, dwLast = 0;
	DWORD cRanges = 0;

	Assert (pwszRgHeader);
	pwsz = pwszRgHeader;

	//	The first word has to be the range unit, either gc_wszBytes
	//	or gc_wszRows
	//
	Assert (!_wcsnicmp (pwszRangeUnit, gc_wszBytes, wcslen(gc_wszBytes)) ||
			!_wcsnicmp (pwszRangeUnit, gc_wszRows, wcslen(gc_wszRows)));
	if (_wcsnicmp(pwsz, pwszRangeUnit, wcslen(pwszRangeUnit)))
	{
		//	OK, the header did not start with range unit
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Move past the range unit
	//
	pwsz = pwsz + wcslen(pwszRangeUnit);

	//	Skip any whitespace
	//
	pwsz = _wcsspnp (pwsz, gc_wszWS);
	if (!pwsz)
	{
		//	OK, the header does not have any ranges
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	We need an = immediately after the range unit
	//
	if (gc_wchEquals != *pwsz++)
	{
		//	OK, improper format
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Count the number of comma separated ranges we have
	//	While this algorithm results in m_cRGList being equal to one more
	//	than the number of commas, that is exactly what we want. The number
	//	of ranges is always less than or equal to one more than the number of
	//	commas.
	//
	while (pwsz)
	{
		//	Find a comma
		//
		pwsz = wcschr(pwsz, gc_wchComma);

		//	If we have a comma, move past it
		//
		if (pwsz)
			pwsz++;

		//	Increment the count
		//
		cRanges += 1;
	}

	//	Parse the header to find the byte ranges
	//
	//	Seek past the byte unit
	//
	pwsz = wcschr(pwszRgHeader, gc_wchEquals);

	//	We already checked for an =, so assert
	//
	Assert (pwsz);
	pwsz++;

	//	Any characters in our byte range except the characters 0..9,-,comma
	//	and whitespace are illegal. We check to see if we have any illegal characters
	//	using the function _wcsspnp(string1, string2) which finds the first character
	//	in string1 that does not belong to the set of characters in string2
	//
	pwszEnd = _wcsspnp(pwsz, gc_wszByteRangeAlphabet);
	if (pwszEnd)
	{
		//	We found an illegal character
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Skip any whitespace and separators
	//
	pwsz = _wcsspnp (pwsz, gc_wszSeparator);
	if (!pwsz)
	{
		//	OK, the header does not have any ranges
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Create the required storage
	//
	m_cRGList = 0;
	m_cbSize = cRanges * sizeof(RGITEM);
	m_pbData = static_cast<BYTE*>(ExAlloc(m_cbSize));
	m_prgi = reinterpret_cast<RGITEM*>(m_pbData.get());

	//	Make sure the allocation succeeds
	//
	if (NULL == m_prgi)
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Iterate through the byte ranges
	//
	while (*pwsz != NULL)
	{
		pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

		//	Do we have a first byte?
		//
		if (!pwszEnd)
		{
			//	This is illegal. We cannot just have a first byte and
			//	nothing after it
			//
			sc = E_INVALIDARG;
			goto ret;
		}
		else if (pwsz != pwszEnd)
		{
			dwFirst = _wtoi(pwsz);
			bFirst = TRUE;

			//	Seek past the end of the first byte
			//
			pwsz = pwszEnd;
		}

		//	Now we should find the -
		//
		if (*pwsz != gc_wchDash)
		{
			sc = E_INVALIDARG;
			goto ret;
		}
		pwsz++;

		//	If we aren't at the end of the string, look for the last byte
		//
		if (*pwsz != NULL)
		{
			pwszEnd = _wcsspnp(pwsz, gc_wszDigits);

			//	Do we have a last byte?
			//
			if (pwsz != pwszEnd)
			{
				dwLast = _wtoi(pwsz);
				bLast = TRUE;
			}

			//	Update psz to the end of the current range
			//
			if (!pwszEnd)
			{
				//	We must be at the end of the header. Update psz
				//
				pwsz = pwsz + wcslen(pwsz);
			}
			else
			{
				pwsz = pwszEnd;
			}
		}

		//	It's a syntax error if we don't have both first and last range
		//	or the last is less than the first
		//
		if ((!bFirst && !bLast) ||
			(bFirst && bLast && (dwLast < dwFirst)))
		{
			sc = E_INVALIDARG;
			goto ret;
		}

		//	We are done parsing the byte/row range, now save it.
		//
		Assert (m_cRGList < cRanges);
		m_prgi[m_cRGList].uRT = RANGE_ROW;
		m_prgi[m_cRGList].sc = S_OK;
		m_prgi[m_cRGList].dwrgi.dwFirst = bFirst ? dwFirst : RANGE_NOT_PRESENT;
		m_prgi[m_cRGList].dwrgi.dwLast = bLast ? dwLast : RANGE_NOT_PRESENT;
		m_cRGList += 1;

		//	Update variables
		//
		bFirst = bLast = FALSE;
		dwFirst = dwLast = 0;

		//	Skip any whitespace
		//
		pwsz = _wcsspnp (pwsz, gc_wszWS);
		if (!pwsz)
		{
			//	OK, we don't have anything beyond whitespace, we are at the end
			//
			goto ret;
		}
		else if (*pwsz != gc_wchComma)
		{
			//	The first non-whitespace character has to be a separator(comma)
			//
			sc = E_INVALIDARG;
			goto ret;
		}

		//	Now that we found the first comma, skip any number of subsequent
		//	commas and whitespace
		//
		pwsz = _wcsspnp (pwsz, gc_wszSeparator);
		if (!pwsz)
		{
			//	OK, we don't have anything beyond separator, we are at the end
			//
			goto ret;
		}
	}

ret:

	if (FAILED (sc))
	{
		//	Free up our storage
		//
		m_cbSize = 0;
		m_cRGList = 0;
		m_pbData.clear();
		Rewind();
	}
	return sc;
}

//	Don't use FAILED() macros on this return code!  You'll miss the details!
//
//	Takes a range header and builds an array of ranges. Performs syntax
//	checking and validation of the ranges against the entity size.
//	Returns an SCODE, but be careful!  These SCODEs are meant to be
//	mapped to HSCs at a higher level.
//
//		E_INVALIDARG means syntax error
//
//		E_DAV_RANGE_NOT_SATISFIABLE if none of the ranges were valid
//				for the entity size passed in.
//
//		W_DAV_PARTIAL_CONTENT if there was at least one valid range.
//
//	This function does NOT normally return S_OK.  Only one of the above!
//
SCODE
CRangeParser::ScParseByteRangeHdr (LPCWSTR pwszRgHeader, DWORD dwSize)
{
	SCODE sc = S_OK;

	Assert(pwszRgHeader);

	//	Parses the ranges header and builds an array of the ranges
	//
	sc = ScParseRangeHdr (pwszRgHeader, gc_wszBytes);
	if (FAILED (sc))
		goto ret;

	//	Fixup the ranges as needed
	//
	sc = ScFixupRanges (dwSize);
	Assert ((sc == W_DAV_PARTIAL_CONTENT) ||
			(sc == E_DAV_RANGE_NOT_SATISFIABLE));

ret:
	return sc;
}

//	Class CRangeIter ----------------------------------------------------------
//
CRangeIter::~CRangeIter()
{
}

SCODE
CRangeIter::ScInit (ULONG cRGList, const RGITEM * prgRGList, ULONG cbSize)
{
	SCODE sc = S_OK;

	//	The object must not have been initialized before
	//
	Assert (!m_pbData.get() && (0 == m_cRGList));

	//	Make sure we are given good bits...
	//
	Assert (cRGList);
	Assert (prgRGList);
	Assert (cbSize);

	//	Duplicate the RGITEM array
	//
	m_pbData = static_cast<BYTE*>(ExAlloc(cbSize));
	if (!m_pbData.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	CopyMemory (m_pbData.get(), prgRGList, cbSize);

	//	Remember the count and size
	//
	m_cRGList = cRGList;
	m_cbSize = cbSize;

	//	Rewind to the beginning of the ranges
	//
	Rewind();

ret:
	return sc;
}

//	Range Parsing -------------------------------------------------------------
//
SCODE
ScParseOneWideRange (LPCWSTR pwsz, DWORD * pdwStart, DWORD * pdwEnd)
{
	BOOL fEnd = FALSE;
	BOOL fStart = FALSE;
	DWORD dwEnd = static_cast<DWORD>(RANGE_NOT_PRESENT);
	DWORD dwStart = static_cast<DWORD>(RANGE_NOT_PRESENT);
	LPCWSTR	pwszEnd;
	SCODE sc = S_OK;

	//	A quick note about the format here...
	//
	//		row_range= digit* '-' digit*
	//		digit= [0-9]
	//
	//	So, the first thing we need to check is if there is a leading set of
	//	digits to indicate a starting point.
	//
	pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

	//	If the return value is NULL, or points to a NULL, then we have an
	//	invalid range.  It is not valid to simply have a set of digits
	//
	if ((NULL == pwszEnd) || (0 == *pwszEnd))
	{
		sc = E_INVALIDARG;
		goto ret;
	}
	//
	//	Else if the current position and the end refer to the same
	//	character, then there is no starting range.
	//
	else if (pwsz != pwszEnd)
	{
		dwStart = wcstoul (pwsz, NULL, 10 /* always base 10 */);
		pwsz = pwszEnd;
		fStart = TRUE;
	}

	//	Regardless, at this point we should have a single '-' character
	//
	if (L'-' != *pwsz++)
	{
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Any remaining characters should be the end of the range
	//
	if (0 != *pwsz)
	{
		pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

		//	Here we expect that the return value is not the same as
		//	the initial pointer
		//
		if ((NULL != pwszEnd) && (0 != pwszEnd))
		{
			sc = E_INVALIDARG;
			goto ret;
		}

		dwEnd = wcstoul (pwsz, NULL, 10 /* always base 10 */);
		fEnd = TRUE;
	}

	//	Can't have both end-points as non-existant ranges
	//
	if ((!fStart && !fEnd) ||
		(fStart && fEnd && (dwEnd < dwStart)))
	{
		sc = E_INVALIDARG;
		goto ret;
	}

ret:
	*pdwStart = dwStart;
	*pdwEnd = dwEnd;
	return sc;
}

//	ScGenerateContentRange() --------------------------------------------------
//
enum { BUFFER_INITIAL_SIZE = 512 };

//	ScGenerateContentRange
//
//	Helper function to build the content-range header
//
//	If ulTotal is RGITER_TOTAL_UNKNOWN ((ULONG)-1), then we give back "total=*".
//	This is needed for REPL, because our store api doesn't tell us how many possible
//	rows there are up front.
//
SCODE ScGenerateContentRange (
	/* [in]  */ LPCSTR pszRangeUnit,
	/* [in]  */ const RGITEM * prgRGList,
	/* [in]  */ ULONG cRanges,
	/* [in]  */ ULONG cbRanges,
	/* [in]  */ ULONG ulTotal,
	/* [out] */ LPSTR *ppszContentRange)
{
	auto_heap_ptr<CHAR>	pszCR;
	BOOL fMultipleRanges = FALSE;
	CRangeIter cri;
	SCODE sc = E_INVALIDARG;
	ULONG cb = 0;
	ULONG cbSize = BUFFER_INITIAL_SIZE;

	//	We must have something to emit
	//
	Assert (ppszContentRange);
	Assert (cRanges);

	sc = cri.ScInit (cRanges, prgRGList, cbRanges);
	if (FAILED (sc))
		goto ret;

	//	Allocate the space for the header
	//
	pszCR = static_cast<LPSTR>(ExAlloc (cbSize));
	if (!pszCR.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Setup the leading range units, etc...
	//
	strcpy (pszCR.get() + cb, pszRangeUnit);
	cb += static_cast<ULONG>(strlen(pszRangeUnit));

	//	Stuff in a leading space
	//
	pszCR.get()[cb++] = ' ';

	//	Now iterate through the ranges to add in
	//	each range.
	//
	while (NULL != (prgRGList = cri.PrgiNextRange()))
	{
		//	If the range is unknown, then it is a range
		//	that was not processed on the store side.
		//
		if (RANGE_UNKNOWN == prgRGList->uRT)
			continue;

		//	First off, make sure there is plenty of room
		//
		if (cb > cbSize - 50)
		{
			//	Realloc the buffer
			//
			cbSize = cbSize + BUFFER_INITIAL_SIZE;
			pszCR.realloc (cbSize);

			//	It's possible that the allocation fails
			//
			if (!pszCR.get())
				goto ret;
		}

		//	Now that we know we have space...
		//	If this is a subsequent range to the initial
		//	one, add in a comma.
		//
		if (fMultipleRanges)
		{
			//	Stuff in a comma and a space
			//
			pszCR.get()[cb++] = ',';
			pszCR.get()[cb++] = ' ';
		}

		if (RANGE_ROW == prgRGList->uRT)
		{
			//	50 is a safe numder of bytes to hold the last range and
			//	"total = <size>"
			//
			//	Append the next range
			//
			cb += sprintf (pszCR.get() + cb,
						   "%u-%u",
						   prgRGList->dwrgi.dwFirst,
						   prgRGList->dwrgi.dwLast);
		}
		else
		{
			//	For all non-row ranges, we really don't know the ordinals
			//	of the rows up front.  We only find that info out when the
			//	rows are actually queried.  This happens long after the
			//	content-range header is constructed, so we stuff in a place
			//	holder for these ranges.
			//
			pszCR.get()[cb++] = '*';
		}
		fMultipleRanges = TRUE;
	}

	//	Now it's time to append the "total=<size>"
	//	Handle the special case of RGITER_TOTAL_UNKNOWN -- give "total=*".
	//
	if (RANGE_TOTAL_UNKNOWN == ulTotal)
	{
		const char rgTotalStar[] = "; total=*";
		memcpy (pszCR.get() + cb, rgTotalStar, CElems(rgTotalStar));
	}
	else
	{
		sprintf(pszCR.get() + cb, "; total=%u", ulTotal);
	}

	//	Pass the buffer back
	//
	*ppszContentRange = pszCR.relinquish();
	sc = S_OK;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shlkcache\_shlkcache.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_ S H L K C A C H E . C P P
//
//		DAV parser precompiled header
//
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include <_shlkcache.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shlkcache\initobj.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	I N I T O B J . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//      Initalizes shared memory cache objects either
//      by creating the access file and creating the objects
//      or openning an existing file and binding to the objects. 
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include "_shlkcache.h"
#include <shlkcache.h>
#include <pipeline.h>

// Structure of the access file for linking to shared memory cache.
//
struct SharedMemMapping
{
    // Used to mark that the shared memory was initalized properly.
	//
    CHAR m_InitCode[5];
	
    // The pointer to the shared cache.
	//
    SharedHandle<CInShLockCache> m_shSharedCache;
	
    // The pointer to the static data for the cache.
	//
    SharedHandle<CInShCacheStatic> m_shSharedStatic;      
};

// Code used to tell that we are really looking at the appropriately defined
// memory access file.
//
const CHAR gc_szInitCode[]    = "Init";

// Name of the shared memory access file that links us with the shared memory lock cache.
//
const WCHAR gc_wszSharedMemoryFile[]    = L"EmsFile";

//=========================================================
// Supporting functions for InitalizeSharedCache.
// None of these should be called outside of this file.
//=========================================================

//
//  Either creates or links to the shared memory file that contains
//  the pointers into the shared memory heap that represent the 
//  shared cache.  This routine will error if the file exists and 
//  you request to create it, or if the file does not exist and you
//  request not to create it.
//
HRESULT CreateAndMapFile(BOOL fCreateFile, LPHANDLE phSMF, SharedMemMapping** ppSharedMem)
{

    // Declarations
	//
    HRESULT     hr      = S_OK;
    DWORD       dwError = 0;
    HANDLE      hSMF    = INVALID_HANDLE_VALUE;

    // Validate Arguments
	//
    Assert(phSMF && (*phSMF)==NULL && ppSharedMem && (*ppSharedMem)==NULL);
    if (!phSMF || 
        (*phSMF)!=NULL || 
        !ppSharedMem || 
        (*ppSharedMem)!=NULL) 
    {
        return E_INVALIDARG;
    }

    // Initalize out paramenters
	//
    *phSMF = NULL;
	
    // ppSharedMem is all ready initalized to NULL per above check.

    // Since DAVProc is the only one responsible for creating the shared
    // memory objects and there is only one DAVProc running we do not need
    // any locking to assure correct creation occurs.

    // Open up the shared memory file containing the LockCache Header information.
	//
    hSMF = CreateFileMappingW(   INVALID_HANDLE_VALUE,         // Use swap file
								 NULL,
								 PAGE_READWRITE,
								 0,                          // dwMaximumSizeHigh
								 sizeof(SharedMemMapping),   // dwMaximumSizeLow
								 gc_wszSharedMemoryFile);

    // If CreateFileMapping actually openned an existing file mapping then we will get a valid handle back
    // but we will also be able to retrieve an error from GetLastError.  We need to save that error
    // code here to assure nothing changes it before we do comparisions with it.
	//
    dwError = GetLastError();

    // Make sure we didn't get a truely fatal error.
	if (hSMF==NULL)
	{
    	ShlkTrace("Create File Mapping's dwError is %i \r\n", (int) dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto exit;
	}

    // Validate that we didn't find an existing file if we were trying to create it.
	//
    if (dwError==ERROR_ALREADY_EXISTS && fCreateFile)
    {
        ShlkTrace("File existed but we were suppose to create it. %i \r\n", (int) dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto exit;        
    }

    // Validate that we did find an existing file if we are not attempting to create it.
	//
    if (dwError!=ERROR_ALREADY_EXISTS && !fCreateFile)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        ShlkTrace("Trying to link to non existing memory mapped file %x \r\n", hr);
        goto exit;        
    }

    // If we get here than hr should still be S_OK
	//
    Assert(hr == S_OK);

    // Just an extra check to make sure that create file never returns a file handle
	// as INVALID_HANDLE_VALUE and we miss it.
	//
    Assert(hSMF != INVALID_HANDLE_VALUE);

    // Set the out parameters appropriately.
	//
    *ppSharedMem = (SharedMemMapping*) MapViewOfFile(hSMF, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(SharedMemMapping));
    if (*ppSharedMem==NULL)
    {
        // MapViewOfFile failed for some unknown reason.
		//
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    *phSMF = hSMF;

exit:

    // If we failed for any reason and we have a handle to the shared memory
    // file than we had better close it.
	//
    if ((FAILED(hr)) && (hSMF != NULL) && (hSMF != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hSMF);
    }

    return hr;
}

//
//  This routine will create new SharedCache and SharedStatic objects
//  using the shared memory heap.  It will then store references
//  to those objects in the access file's memory mapping and will
//  return yet another reference to those objects for the process
//  to use to interact with the Shared Lock Cache.
//
HRESULT CreateSharedObjects(SharedPtr<CInShLockCache>& spSharedCache
                            , SharedPtr<CInShCacheStatic>& spSharedStatic 
                            , SharedMemMapping* pMemMapping)
{

    // Validate Arguments
	//
    Assert(pMemMapping);
    if (pMemMapping==NULL)
        return E_INVALIDARG;

    // Validate that the objects have not been created yet.
	//
    Assert(spSharedCache.FIsNull());
    Assert(spSharedStatic.FIsNull());

    // Create the objects if they fail to create we will assume a low memory condition.
	//
    if (!(spSharedCache.FCreate()) || !(spSharedStatic.FCreate()))
    {
       return E_OUTOFMEMORY;
    }

    // Now that we have created the objects we can store them in the memory mapped
	// file we just created so the worker processes can find them.
	//
    pMemMapping->m_shSharedCache = spSharedCache.GetHandle();
    pMemMapping->m_shSharedStatic  = spSharedStatic.GetHandle();

    // Finally mark the shared memory as initalized so other routines can link using these handles.
	//
    strcpy(pMemMapping->m_InitCode, gc_szInitCode);

    return S_OK;
}

//
//  This routine will use the handles identified in the shared
//  memory mapping to establish shared pointers that can be used
//  to work of the shared memory cache.
//
HRESULT BindToSharedObjects(SharedPtr<CInShLockCache>& spSharedCache
                            , SharedPtr<CInShCacheStatic>& spSharedStatic
                            , SharedMemMapping* pMemMapping)
{
    HRESULT hr = S_OK;

    // Validate Arguments
	//
    Assert(pMemMapping);
    if (pMemMapping==NULL)
        return E_INVALIDARG;

    // Validate that the objects have not been created or linked to existing shared objects.
	//
    Assert(spSharedCache.FIsNull());
    Assert(spSharedStatic.FIsNull());

    // Validate that the memory has really been initalized.
	//
    if (strcmp(pMemMapping->m_InitCode, gc_szInitCode)==0)
    {
        // Bind to the objects using the object handles found in the memory mapped file.
		//
        spSharedCache.FBind(pMemMapping->m_shSharedCache);
        spSharedStatic.FBind(pMemMapping->m_shSharedStatic);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        ShlkTrace("File existed but wasn't initalized correctly %x \r\n", hr);
    }

    return hr;
}

//=========================================================
// InitalizeSharedCache is the main routine from this file.
// It will be called from DAVProc and SHLKMGR.
//
// This function is declared in sharedobj.h for external use.
//=========================================================

//
//  Function opens (or creates) the shared memory file that 
//  contains the references to the shared memory cache and shared
//  memory static data.  It then uses those pointers (or creates
//  them) to setup the spSharedCache and spSharedStatic objects
//  to be linked to the objects in shared memory.
//
//  Note that this routine will not hold open the shared memory
//  header file, unless it has created it.  Once the process has
//  these objects it will no longer need the access file.
//
HRESULT InitalizeSharedCache(SharedPtr<CInShLockCache>& spSharedCache
                             , SharedPtr<CInShCacheStatic>& spSharedStatic
                             , BOOL fCreateFile)
{
    HRESULT             hr          = S_OK;
    HANDLE              hSMF        = NULL;
    SharedMemMapping*   pMemMapping = NULL;

	// Init Shlktrace
	//
	INIT_TRACE (Shlk);
	
    // Validate that the objects have not been created or linked to existing shared objects.
	//
    Assert(spSharedCache.FIsNull());
    Assert(spSharedStatic.FIsNull());

    hr = CreateAndMapFile(fCreateFile, &hSMF, &pMemMapping);
    if (FAILED(hr))
	{
        return hr;
	}

    if (fCreateFile)
    {
        // Need to save the handle to the file so the access file exists when others 
        // try to link to it.
		//
		PIPELINE::SaveHandle(hSMF);

        hr = CreateSharedObjects(spSharedCache, spSharedStatic, pMemMapping);
    }
    else
    {
        hr = BindToSharedObjects(spSharedCache, spSharedStatic, pMemMapping);
    }


    // If we mapped the header file, now release it.
	//
    if (pMemMapping) UnmapViewOfFile((LPVOID) pMemMapping);

    // If we openned the file, close it.  Note the SaveHandle above
    // will have duplicated the file handle so the file will not close
    // in the case when we created it.
	//
    if (hSMF) CloseHandle(hSMF);

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_pipeline\pipeline.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	P I P E L I N E . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//      Contains global functions for pipelining data to the DAVProc.
// 
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
#include "_pipeline.h"
#include <smh.h>
#include <shlkcache.h>
#include <stdio.h>
#include <caldbg.h>
#include <safeobj.h>

BOOL gs_fFirstCall = TRUE;

SCODE	ScStartDavCData();

//
//  Function performs all pipeline calls to the DAVProc.  It will
//  send data in the form of Action, ProcessId, FileHandle and LockData
//  handle that is used to store the DAVProc file handle we saved.
//
SCODE ScPipeLineData(  DWORD dwAction,
					   DWORD dwProcess,
					   HANDLE hHandle,
					   SharedHandle<CInShLockData>& shLockData)
{
    SCODE sc = S_OK;

    BYTE buf[PIPE_MESSAGE_SIZE];

    DWORD outBufSize;
    DWORD inBufSize = 0;


	//	If this is the first call the pipeline, make sure DavCData
	//	process is up.
	//
	if (gs_fFirstCall)
	{
		sc = ScStartDavCData();
		if (FAILED(sc))
		{
			//	In case davcdata is shutting down, give it a second chance. 
			//
			sc = ScStartDavCData();
			if (FAILED(sc))
				goto exit;
		}
	}
	
	// Load up the information to pass over to DAVProc.
	//
    memcpy(buf, &dwAction, sizeof(DWORD));
    inBufSize = sizeof(DWORD);

    memcpy(buf + inBufSize, &dwProcess, sizeof(DWORD));
    inBufSize += sizeof(DWORD);

    memcpy(buf + inBufSize, &hHandle, sizeof(HANDLE));
    inBufSize += sizeof(HANDLE);

    memcpy(buf + inBufSize, &shLockData, sizeof(SharedHandle<CInShLockData>));
    inBufSize += sizeof(SharedHandle<CInShLockData>);

    // verify that we have loaded the number bytes we expected.
	//
    Assert(inBufSize == PIPE_MESSAGE_SIZE);

	{
		// Always run as system when sending information to server.
		// This class will RevertToSelf if we are running on a thread that 
		// may have impersonated.
		//
		safe_revert_self rs;

		// send it on over and wait for a reply
		//
		if (!CallNamedPipe ("\\\\.\\pipe\\SaveHandle"      // pipe name
							, buf                              // write buffer
							, PIPE_MESSAGE_SIZE                // size of write buffer
							, NULL                             // read buffer
							, 0                                // size of read buffer
							, &outBufSize                      // number of bytes read
							, NMPWAIT_WAIT_FOREVER))           // time-out value
		{
			DWORD dwError = GetLastError();

			// The server will disconnect when it is done so it can listen 
			// for the next caller, so we don't want to error if this is the case.
			//
			if (dwError != ERROR_PIPE_NOT_CONNECTED)
			{
				DebugTrace("(Call Name Pipe) Error code is %i ;", dwError);
				sc = HRESULT_FROM_WIN32(dwError);
				goto exit;
			}
		}
	}
	
exit:
    return sc;

};

SCODE	ScStartDavCData()
{
	SCODE	sc = S_OK;
	DWORD	dwRet;
	DWORD	dwErr;
	HANDLE	hEventDavCDataUp;
	
	// Always run as system when sending information to server.
	// This class will RevertToSelf if we are running on a thread that 
	// may have impersonated.
	//
	safe_revert_self rs;
	
	//	Open the event that we can listen to
	//
	hEventDavCDataUp = CreateEvent (NULL,	// lpEventAttributes
									TRUE,	// bManualReset
									FALSE,	// bInitialState
									g_szEventDavCData);	// lpName
	dwErr = GetLastError();
	
	if (NULL == hEventDavCDataUp)
	{
		sc = HRESULT_FROM_WIN32(dwErr);
		goto ret;
	}

	Assert ((ERROR_SUCCESS == dwErr) ||
			(ERROR_ALREADY_EXISTS == dwErr));

	//	If we created this event, then we know for sure that DavCData
	//	is not up yet.
	//
	if (ERROR_SUCCESS == dwErr)
	{
		STARTUPINFO				startinfo;
		PROCESS_INFORMATION		pi;
		CHAR					szPath[MAX_PATH];
		
		// Init Startup info
		//
		ZeroMemory(&startinfo, sizeof(STARTUPINFO));
		startinfo.cb = sizeof(STARTUPINFO);

		//	Compose the path to davcdata.exe
		//
		if (!GetSystemDirectory (szPath, MAX_PATH))
		{
			DebugTrace ("GetSystemDirectory failed with %d\n", GetLastError());
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}

		//$REVIEW - for now, assume DavCdata is under intesrv
		//
		strcat (szPath, "\\inetsrv\\DavCData.exe");
		
		//	Start the process. We now assume it's under inetsrv
		//	Don't worry about multiple worker process creating davcdata
		//	at the same time. davcdata allows only one instance.
		//
		if (!CreateProcess (szPath,	// lpApplicationName
							NULL,		// lpCommandLine
							NULL,		// lpProcessAttributes
							NULL,		// lpThreadAttributes
							FALSE,		// bInheritHandles
							CREATE_NO_WINDOW,	// dwCreationFlags
							NULL,		// lpEnvironment
							NULL,		// lpCurrentDirectory
							&startinfo,	// lpStartupInfo
							&pi))		// lpProcessInformation
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
	}

	//	Now wait for a short time (1min) to allow DavCData to initialize,
	//	if DavCData is up already, it will come back immediately
	//
	dwRet = WaitForSingleObject (hEventDavCDataUp, 60000);
	switch (dwRet)
	{
		case WAIT_OBJECT_0:
		{
			gs_fFirstCall = FALSE;
			SharedHandle<CInShLockData>	shNull;
			
			//	Let DavCData know this work process
			//
			sc = ScPipeLineData (DO_NEW_WP,
							   GetCurrentProcessId(),
							   INVALID_HANDLE_VALUE,	// not used for DO_NEW_WP
							   shNull);
			break;
		}

		default:
			//	Fail this request
			//
			sc = E_FAIL;
			
			break;
	}
	
ret:
	if (NULL != hEventDavCDataUp)
		CloseHandle (hEventDavCDataUp);
	return sc;
}

//
//  This routine uses PipeLineData to save a handle in the DAVProc.
//  Because some common code loads into DAVProc and we don't want it
//  going through the pipeline to talk to itself, we have the SaveHandle
//  routine which is what is actually called defined in the dll or exe
//  code.  If the dll or exe wants to use the pipeline it can just pass
//  the call off to WP_SaveHandle.
//
VOID
PIPELINE::SaveHandle(HANDLE hWPHandle)
{
    SharedHandle<CInShLockData> shNull;	
    (VOID)ScPipeLineData(DO_SAVE, GetCurrentProcessId(), hWPHandle, shNull);
}

//
//  This routine uses PipeLineData to save a handle in the DAVProc.
//  Because some common code loads into DAVProc and we don't want it
//  going through the pipeline to talk to itself, we have the SaveHandle
//  routine which is what is actually called defined in the dll or exe
//  code.  If the dll or exe wants to use the pipeline it can just pass
//  the call off to WP_SaveHandle.
//
VOID
PIPELINE::LockFile(HANDLE hWPHandle, SharedHandle<CInShLockData>& shLockData)
{
    (VOID)ScPipeLineData(DO_LOCK, GetCurrentProcessId(), hWPHandle, shLockData);
}

//
//  This routine uses PipeLineData to let DAVProc know that it can
//  release a handle it is holding.  The handle passed in is the value
//  of the handle in terms of the DAVProc procedure.  It was returned
//  by DAVProc when we did the SaveHandle call.
//
VOID
PIPELINE::RemoveHandle(HANDLE hDAVHandle)
{
    SharedHandle<CInShLockData> shNull;
    (VOID)ScPipeLineData(DO_REMOVE, 0, hDAVHandle, shNull);
}

//
//  In order to use any handles held by DAVProc we need to make a 
//  duplicate of them.  This routine does just that for us.  Any 
//  handles returned from here should have CloseHandle called on them
//  when we are through using them.
//
HRESULT DupHandle(  HANDLE i_hOwningProcess
                  , HANDLE i_hOwningProcessHandle
                  , HANDLE* o_phCreatedHandle)
{
	HRESULT hr = S_OK;
    HANDLE h = INVALID_HANDLE_VALUE;

	if (o_phCreatedHandle==NULL)
	{
		Assert (o_phCreatedHandle!=NULL);
		return E_INVALIDARG;
	}

    // Always attempt to run as system when duplicating handles.
	//
    safe_revert_self s;

    if (!DuplicateHandle(i_hOwningProcess
                        , i_hOwningProcessHandle
                        , GetCurrentProcess()
                        , &h
                        , 0
                        , FALSE
                        , DUPLICATE_SAME_ACCESS))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
    }

exit:
	
    // Return the handle, if we failed to duplicate it we will
    // just be returning INVALID_HANDLE_VALUE.
	//
	*o_phCreatedHandle = h;
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shlkcache\shlkcache.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	S H L K C A C H E . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//      Contains all classes that are created in shared memory
//      for use with the shared lock cache.
//
//  Classes are:
//      CInShBytes          = allocates bytes in shared memory.
//      CInShString         = allocates strings in shared memory.
//      CInShLockData       = handles all the information about
//                            a particular lock for a resource.
//      CInShCacheStatic    = holds all static information needed
//                            to use the shared cache.
//      CInShLockCache      = holds the hash table for the shared
//                            memory cache.
//
//  Author:  EmilyK
//  Date:    3/8/2000
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include "_shlkcache.h"
#include "shlkcache.h"
#include "smh.h"
#include "pipeline.h"
#include "crc.h"

enum { TOKENBUFFSIZE = (88) + sizeof(TOKEN_USER)};

//=========================================================
// Supporting functions:
//=========================================================

//  Figures out if to FILETIMEs are equal or not.  Is used below
//  to determine if we have all ready checked if a lock has expired
//  for a particular time.
//
BOOL TimesEqual(FILETIME ftNow, FILETIME ftRemembered)
{
	// If the low part is not equal than the times are not equal.
	//
	if (ftNow.dwLowDateTime != ftRemembered.dwLowDateTime)
		return FALSE;

	// If the low part was equal than we need to check if the
	// high part is equal.
	//
	if (ftNow.dwHighDateTime != ftRemembered.dwHighDateTime)
		return FALSE;

	// If we got here than we know that both parts match
	// and we can return true.
	//
	return TRUE;
}

// ===============================================================
// CInShBytes Class Method Implemenations
// ===============================================================

//
// Constructor for CInShBytes
//
CInShBytes::CInShBytes() : m_HandleToMemory(NULL)
{
}

//
// Destructor for CInShBytes
//
CInShBytes::~CInShBytes()
{
    // If we are holding an offset into the shared memory heap
    // we need to free the memory at that offset.
	//
    if (m_HandleToMemory)
    {
        SMH::Free(m_HandleToMemory);
    }
}

//
// GetPtrToBytes without any arguments returns a constant pointer to the data.
// This pointer is only valid as long as this class is alive. It should not
// be used to change the data, only to read the information the class holds.
//
LPCVOID CInShBytes::GetPtrToBytes()
{
    LPVOID pRetVal = NULL;

    if (m_HandleToMemory)
    {
        pRetVal = (LPVOID) SMH::PvFromSMBA(m_HandleToMemory);
    }

    return pRetVal;
}

//
// GetPtrToBytes with a size returns a pointer to the memory controlled by
// this class after allocating the amount of memory requested.  It is used
// when we need to copy a sid into shared memory and need to use the CopySid
// function.
//
LPVOID CInShBytes::GetPtrToBytes(LONG i_cbMemory)
{
	// Verify we haven't allocated any memory yet.
	//
	Assert (NULL == m_HandleToMemory);
	if (NULL != m_HandleToMemory)
		return NULL;

    // Only allocate memory if we have been provided with a reasonable size.
	//
    if (i_cbMemory > 0)
    {
	    return (LPVOID) SMH::PvAlloc(i_cbMemory, &m_HandleToMemory);
	}

	return NULL;
}

//
// CopyInBytes is used to initially set  the memory that this object holds to
// it's correct value.  This object is a set once read many object and can not
// have it's data updated once it has been initalized.
//
void CInShBytes::CopyInBytes(LONG i_cbMemory, LPVOID i_pvMemory)
{
    if (i_pvMemory != NULL && i_cbMemory > 0)
    {
	    memcpy(GetPtrToBytes(i_cbMemory), i_pvMemory, i_cbMemory);
    }
}


// ===============================================================
// CInShLockCache Class Method Implemenations - Public
// ===============================================================

//
//  Constructor for CInShLockCache
//
CInShLockCache::CInShLockCache()
   : m_dwItemsInCache(0)
{
}

//
//  Destructor for CInShLockCache
//
CInShLockCache::~CInShLockCache()
{
    // When the table goes away all handles to the shared data it holds
    // go away.  As long as the shared cache structure is not sorted then
    // the handles stored in the collision lists will also go away.  If we
    // ever start sorting data, or change the order of insert we need to watch
    // for the case when one lock data is holding another that is holding the
    // first lock data.
	//
};

//
//  Function will add a lock token to the cache.  It will first add
//  it to the ID part of the cache and then it will add to the name
//  part of the hash.
//
void CInShLockCache::Add(SharedPtr<CInShLockData>& spSharedEntry)
{
    // CODEWORK:  Cache could hold the end pointer as well as the
    //            start pointer so we don't end up walking for
    //            every insert.  We could also do a in order list
    //            that could make looking for the lock easier.
    //            Note if we change the ordering of the cache insert
    //            we need to be careful we don't get any circular
    //            references (see comment in destructor).
	//
    ShlkTrace("Add lock type is%d\n", spSharedEntry->GetLockType());

    // First figure out what the hash index.
	//
    DWORD dwIndexID = spSharedEntry->GetIDHashCode();
	DWORD dwIndexName = spSharedEntry->GetNameHashCode();

    // Lock everyone out of the cache so we can write to it.
	//
    SynchronizedWriteBlock<CSharedMRWLock> blk(m_lock);
    m_dwItemsInCache++;

	//	Prepend the node at the beginning of both ID and Name hask link.
	//
	spSharedEntry->SetNextHandleByID(m_hIDEntries[dwIndexID]);
	m_hIDEntries[dwIndexID] = spSharedEntry.GetHandle();

	spSharedEntry->SetNextHandleByName(m_hNameEntries[dwIndexName]);
	m_hNameEntries[dwIndexName] = spSharedEntry.GetHandle();
}

//
//  Function deletes the lock token from the cache based on it's
//  lock id.  This function will delete the lock token completely
//  from both hash tables (the name hash as well as the id hash)
//
void CInShLockCache::DeleteByID( __int64 i64LockID )
{
    // Figure out where the token has been stored.
	//
    DWORD dwIndexID = GetHashCodeByID(i64LockID);

    SharedPtr<CInShLockData> pForEvaluation;
    SharedHandle<CInShLockData> shPrev;

    // Lock others out of the cache.
	//
    SynchronizedWriteBlock<CSharedMRWLock> blk(m_lock);

    // Setup to start walking through the ID hash's collision
    // list looking for matching tokens.
	//
    SharedHandle<CInShLockData> shCurrent = m_hIDEntries[dwIndexID];

    while (pForEvaluation.FBind(shCurrent))
    {
        if (pForEvaluation->IsEqualByID(i64LockID))
            break;

		shPrev = shCurrent;
        shCurrent = pForEvaluation->GetNextHandleByID();;

		//	Be ready to bind for the next bind
		//
		pForEvaluation.Clear();
    }

    // If we are on an object then we are going to delete the object from
	// the cache.  Otherwise the lock doesn't exist.
	//
    if (!pForEvaluation.FIsNull())
    {
        // We found it for the ID, so we had better drop the name links as well.
		//
		DeleteByName( pForEvaluation->GetResourceName(),
					  i64LockID);
        DeleteFromIDList(pForEvaluation, shPrev, dwIndexID);
    }

    // At the end of this routine the handles held by pForEvaluation and hNextData
    // are released.  They will in return drop the CInShLockData object
    // ref counts.  It will hit zero and be freed from memory.
    // When it frees from memory, it will check if
    // it has any file handles and call a release to free them.
}

//
//  Evaluates the i64LockID sent in and returns the index into the
//  ID hash table that any object represented by this key would be
//  stored at.
//
DWORD CInShLockCache::GetHashCodeByID(__int64 i64LockID)
{
    Assert (CACHE_SIZE > 0);

    // Figuring out what the actual hash ID of the Lock item is.
	//
    return static_cast<UINT>(i64LockID) % CACHE_SIZE;
}

//
//  Evaluates the wszResource sent in and returns the index into the
//  name hash table that any object represented by this key would be
//  stored at.
//
DWORD CInShLockCache::GetHashCodeByName(LPCWSTR wszResource)
{
    Assert (CACHE_SIZE > 0);

    // Need to first convert the string to all lower case.  Since
    // we are not sure who owns the wszResource string we want to make
    // a copy of the string before changing it.
	//
	UINT cb = static_cast<UINT>(wcslen(wszResource)) * sizeof(WCHAR);
	CStackBuffer<WCHAR,MAX_PATH> pwszLower;
	if (NULL == pwszLower.resize(cb + sizeof(WCHAR)))
		return 0xFFFFFFFF;

	CopyMemory( pwszLower.get(), wszResource, cb + sizeof(WCHAR) );
	_wcslwr( pwszLower.get() );

    // Once we have a converted string we can call the computational
    // algorithm to get the index into the hash table.
	//
    return (DwComputeCRC( 0, pwszLower.get(), cb )) % CACHE_SIZE;
}

//
//  Finds any lock token in the cache that is represented by this
//  lock token ID.  If we do not find it plock will be bound to NULL.
//
BOOL CInShLockCache::FLookupByID( __int64 i64LockID
                                   , SharedPtr<CInShLockData>& plock )
{
    DWORD dwIndexID = GetHashCodeByID(i64LockID);
    SynchronizedReadBlock<CSharedMRWLock> blk(m_lock);
    SharedHandle<CInShLockData> shCurrent = m_hIDEntries[dwIndexID];

	// FBind will return false if it binds to a handle that does not have a
	// valid object under it.  Therefore we do not need to call FIsNull to
	// check if the handle pointed to an object or not.
	//
    while (plock.FBind(shCurrent))
    {
        if (plock->IsEqualByID(i64LockID))
            return TRUE;

        shCurrent = plock->GetNextHandleByID();

		//	Be ready for next bind
		//
		plock.Clear();
    };

    return FALSE;
}

#ifdef DBG
//
//  Used as a debugging function to dump the cache out and see what
//  it holds.
//
void CInShLockCache::DumpCache()
{
    SharedPtr<CInShLockData> splock;
	SharedHandle<CInShLockData> shNext;

    for (int i=0; i < CACHE_SIZE; i++)
    {
        if (splock.FBind(m_hIDEntries[i]))
        {
            ShlkTrace("%s: LockType: %d ID: %d Name: %d \r\n",
					  splock->GetResourceName(),
					  splock->GetLockType(),
					  splock->GetIDHashCode(),
					  splock->GetNameHashCode());

			//	Be ready for next bind
			//
			shNext = splock->GetNextHandleByID();
			splock.Clear();

            while (splock.FBind(shNext))
            {
				ShlkTrace ("%s: LockType: %d ID: %d Name: %d \r\n",
						   splock->GetResourceName(),
						   splock->GetLockType(),
						   splock->GetIDHashCode(),
						   splock->GetNameHashCode());

				//	Be ready for next bind
				//
				shNext = splock->GetNextHandleByID();
				splock.Clear();
            }
        }
    }
}
#endif // DBG

//
//  Finds all locks for a particular resource (matching a particular
//  lock type).  If fEmitXML is sent in then it will also use the
//  callback function to emit the lock info to the response body.
//
BOOL CInShLockCache::FLookUpAll(   LPCWSTR wszResource
                              , DWORD   dwLockType
                              , BOOL fEmitXML
                              , LPVOID pContext
                              , EmitLockInfoDecl* pEmitLockInfo )
{
    SharedPtr<CInShLockData> plock;

    // Register as a reader of this data.
	//
    SynchronizedReadBlock<CSharedMRWLock> blk(m_lock);

    // Find the starting lock token for this resource.
	//
    if(FLookupByName(wszResource, dwLockType, plock))
	{
		Assert (!plock.FIsNull());

		if (fEmitXML)
		{
			SharedHandle<CInShLockData>	shNext;

			// Walk through the whole list to emit all lock tokens.
			//
			do
			{
				pEmitLockInfo(&plock, pContext);

				//	Be Ready To bind to the next
				//
				shNext = plock->GetNextHandleByName();
				plock.Clear();

			} while (plock.FBind(shNext) &&
					 plock->IsEqualByName(wszResource, dwLockType));
		}

		return TRUE;
	}

	return FALSE;
}

//
//  Function goes through the whole cache and free's up any locks
//  that have out lasted their timeout values.
//
VOID CInShLockCache::ExpireLocks()
{
    // Loop through cache and look for any locks that say they have expired.
    // For each cache line entry first walk the ID links then the name links.
    // If you find one that has expired, drop it from the link list.
    // Once it has been dropped from both lists, normal clean up of the object
    // should release the file handle and the lock should be gone.

    SharedPtr<CInShLockData> pForEvaluation;

    SharedHandle<CInShLockData> shCurrent;
	SharedHandle<CInShLockData> shPrev;
    FILETIME ftNow;

    // Get one time to compare all the locks against.This is to avoid calling this
	// function per every lock we have.  And also to avoid only dropping a lock
	// from the Name list and not the ID list because the name list was looked at later.
	//
    GetSystemTimeAsFileTime( &ftNow );

    // For now we are locking for write the entire time we are walking the lock
	// cache.  This will probably be a nice bottle neck.  We need to change this
	// to lock in some sort of promotable way.
	//
    SynchronizedWriteBlock<CSharedMRWLock> blk(m_lock);

	// Track the num locks visited so we can stop early if we have found all the locks
	// in the cache.
	//
	if (m_dwItemsInCache > 0)
	{
		for (DWORD dwIndex = 0; dwIndex < CACHE_SIZE; dwIndex++)
		{
			shCurrent = m_hIDEntries[dwIndex];
			shPrev.Clear();

			// Drop the links for the ID list for the cache entry.
			//
			while (pForEvaluation.FBind(shCurrent))
			{
				if (pForEvaluation->IsExpired(ftNow))
				{
					DeleteFromIDList(pForEvaluation, shPrev, dwIndex);
				}
				else
				{
					// Only move the previous pointer if we did not
					// drop the item from the list.
					//
					shPrev = shCurrent;
				}

				// Even though we dropped pForEvaluation from the linked listed we
				// still have a handle on him here.
				//
				shCurrent = pForEvaluation->GetNextHandleByID();

				pForEvaluation.Clear();
			}

			// Drop the links for the ID list for the cache entry.
			//
			shCurrent = m_hNameEntries[dwIndex];
			shPrev.Clear();

			while (pForEvaluation.FBind(shCurrent))
			{
				if (pForEvaluation->IsExpired(ftNow))
				{
					DeleteFromNameList(pForEvaluation, shPrev, dwIndex);
				}
				else
				{
					// Only move the previous pointer if we did not
					// drop the item from the list.
					//
					shPrev = shCurrent;
				}

				// Even though we dropped pForEvaluation from the linked listed we
				// still have  a handle on him here.
				//
				shCurrent = pForEvaluation->GetNextHandleByName();

				pForEvaluation.Clear();
			}
		}	// for
	}
}

// ===============================================================
// CInShLockCache Class Method Implemenations - Private
// ===============================================================

//
//  Function deletes a found lock token from the name hash table.
//
VOID CInShLockCache::DeleteFromNameList(SharedPtr<CInShLockData>& spLockToDelete
                                        , SharedHandle<CInShLockData>& shLockPrev
                                        , DWORD dwIndexInCache)
{
    // If we are on an object then we are going to delete the object from the cache.
	// Otherwise the lock doesn't exist.
	//
    if (!spLockToDelete.FIsNull())
    {
        SharedPtr<CInShLockData> pLockPrev;

        if (pLockPrev.FBind(shLockPrev))
        {
            // If shObjBefore was an empty handle then this binding will return false.
            // in that case we are dealing with the first object.  otherwise we have
            // an object to alter.
			//
            pLockPrev->SetNextHandleByName (spLockToDelete->GetNextHandleByName());
        }
        else
        {
            m_hNameEntries[dwIndexInCache] = spLockToDelete->GetNextHandleByName();
        }
    }
}

//
//  Function deletes a found lock token from the ID hash table.
//
VOID CInShLockCache::DeleteFromIDList(SharedPtr<CInShLockData>& spLockToDelete
                                      , SharedHandle<CInShLockData>& shLockPrev
                                      , DWORD dwIndexInCache)
{
    // If we are on an object then we are going to delete the object from the cache.
	// Otherwise the lock doesn't exist.
	//
    if (!spLockToDelete.FIsNull())
    {
        SharedPtr<CInShLockData> pLockPrev;

        if (pLockPrev.FBind(shLockPrev))
        {
            // if shObjBefore was an empty handle then this binding will return false.
            // in that case we are dealing with the first object.  otherwise we have
            // an object to alter.
			//
            pLockPrev->SetNextHandleByID (spLockToDelete->GetNextHandleByID());
        }
        else
        {
            m_hIDEntries[dwIndexInCache] = spLockToDelete->GetNextHandleByID();
        }

		// We only record the deletion of an item when it is removed
		// from the ID list, this way we don't end up subtracting two
		// for each lock removed.
		//
		m_dwItemsInCache--;
	}
}


//
//  Function finds and deletes a token from the name hash table.
//
void CInShLockCache::DeleteByName ( LPCWSTR wszResource, __int64 i64LockID)
{
    DWORD dwIndex = GetHashCodeByName(wszResource);

    SharedPtr<CInShLockData> pForEvaluation;
    SharedHandle<CInShLockData> shPrev;
    SharedHandle<CInShLockData> shCurrent = m_hNameEntries[dwIndex];

    while (pForEvaluation.FBind(shCurrent))
    {
		//	Note because we must compare ID.
		//	The (resource name, locktype) pair is NOT unique
		//
		if (pForEvaluation->IsEqualByID(i64LockID))
            break;

        shPrev = shCurrent;
		shCurrent = pForEvaluation->GetNextHandleByName();

		//	Be ready for next bind
		//
		pForEvaluation.Clear();
    };

    DeleteFromNameList(pForEvaluation, shPrev, dwIndex);
}


//
//  Function finds a lock token based on name.  This function is used
//  by LookupAll to find all locks dealing with a particular resource.
//  If we do not find an object than plock will be bound to NULL.
//
//$IMPORTANT: this function returns the first lock that match the name
//$IMPORTANT: it's possible more than one lock of same type exists
//$IMPORTANT: on a single resource.
//
BOOL CInShLockCache::FLookupByName( LPCWSTR wszResource, DWORD dwLockType
                                     , SharedPtr<CInShLockData>& plock )
{
#ifdef DBG
	// Function should only be called from LookupAll
	// Function depends on LookupAll to perform the read locking that scopes this function.
    // Debug routine
	//
    DumpCache();
#endif

    DWORD dwIndex = GetHashCodeByName(wszResource);

    SharedHandle<CInShLockData> shCurrent = m_hNameEntries[dwIndex];

	// FBind will return false if it binds to a handle that does not have a valid object
	// under it.  Therefore we do not need to call FIsNull to check if the handle pointed
	// to an object or not.
	//
    while (plock.FBind(shCurrent))
    {
        if (plock->IsEqualByName(wszResource, dwLockType))
            return TRUE;

        shCurrent = plock->GetNextHandleByName();

		//	Be ready for next bind
		//
		plock.Clear();
    };

    return FALSE;
}


// ===============================================================
// CInShLockData Class Method Implemenations - Public
// ===============================================================

//
//  Constructor for CInShLockData
//
CInShLockData::CInShLockData()
: m_dwAccess(0)
, m_dwLockType(0)
, m_dwLockScope(0)
, m_dwNameHash(0)
, m_dwIDHash(0)
, m_dwSecondsTimeout(DEFAULT_LOCK_TIMEOUT)
, m_hDAVProcFileHandle(INVALID_HANDLE_VALUE)
, m_fHasTimedOut(FALSE)
{
    // CODEWORK: Review usage of m_fRememberFTnow.
    //         Need to make sure it makes sense
    //         and is not wasting perf while trying
    //         to improve perf.
    m_fRememberFtNow.dwLowDateTime = 0;
    m_fRememberFtNow.dwHighDateTime = 0;
}

//
//  Destructor for CInShLockData
//
CInShLockData::~CInShLockData()
{
    // Make sure we tell the DAV Process that this
    // file lock should be released.
	//
    if (m_hDAVProcFileHandle != INVALID_HANDLE_VALUE)
    {
		PIPELINE::RemoveHandle(m_hDAVProcFileHandle);
    }
}

//
//  Initialization routine used by the shared lock manager to setup
//  a valid new shared lock token with all the information it is
//  passed when fslock requests a new lock on a file.
//
HRESULT CInShLockData::Init (  LPCWSTR wszStoragePath
                                , DWORD dwAccess
                                , _int64 i64LockID
                                , LPCWSTR pwszGuid
                                , DWORD dwLockType
                                , DWORD dwLockScope
                                , DWORD dwTimeout
                                , LPCWSTR wszOwnerComment
                                , HANDLE hit
                               )
{
    HRESULT hr = S_OK;

    m_i64LockID = i64LockID;
	WCHAR rgwchBuffer[33];

	//	Opaquelocktoken format is partially defined by our IETF spec.
	//	First opaquelocktoken:<our guid>, then our specific lock id.
	//
	wsprintfW (m_rgwchToken, L"<opaquelocktoken:%ls:%ls>",
			   pwszGuid,
			   _i64tow (i64LockID, rgwchBuffer, 10));

    // Save the simple information in the new lock token
	//
    m_dwAccess = dwAccess;
    m_dwLockType = dwLockType;
    m_dwLockScope = dwLockScope;
    if (dwTimeout) m_dwSecondsTimeout = dwTimeout;

    // Create a shared memory object to hold the resource name
	//
    SharedPtr<CInShString> spResourceStr;
    if (!spResourceStr.FCreate())
        ShlkTrace("Error from spResourceStr.FCreate()\r\n");
    else
    {
        spResourceStr->CopyInString(wszStoragePath);
        m_hOffsetToResourceString = spResourceStr.GetHandle();
    }

    // Create a shared memory object to hold the owner comment.
	//
    if (wszOwnerComment!=NULL)
    {
    	SharedPtr<CInShString> spOwnerComment;

        if (!spOwnerComment.FCreate())
        ShlkTrace("Error from spOwnerComment.FCreate()\r\n");
        else
        {
            spOwnerComment->CopyInString(wszOwnerComment);
            m_hOffsetToOwnerComment = spOwnerComment.GetHandle();
        }
    }

    // Save the owners sid into the object.
	//
    hr = SetLockOwnerSID(hit);
    if (FAILED(hr))
        ShlkTrace("Error setting the SID\r\n");


    // Lastly set in the last file time that this was accessed.
	//
    GetSystemTimeAsFileTime(&m_ftLastAccess);

    return hr;
}

//
//  Routine determines if the lock token represents a lock on the
//  resource of the type specified.
//
BOOL CInShLockData::IsEqualByName(LPCWSTR wszResource, DWORD dwLockType)
{
    BOOL fRetVal = FALSE;

    // Locks only match if the lock type and the resource name match.
    // Check the locktype first to avoid the string compare if we don't
    // need to do it.
	//
    if ((dwLockType & m_dwLockType) && (wcscmp(GetResourceName(), wszResource) == 0))
    {
        fRetVal = TRUE;
    }

    return fRetVal;
}

//
//  Routine checks if the lock token has expired.  It was stolen from
//  FExpiredlock in lockmgr.cpp.  There are comments there about the
//  way this is done.
//
BOOL CInShLockData::IsExpired(FILETIME ftNow)
{
    // CODEWORK:  passing FILETIME's by pointers instead of value?
    //          should we be doing it that way?

    // This function will be called twice during each ExpiredLocks
    // check.  The first time it is called we should do the checks
    // and set the m_fHasTimedOut call.  The second time we want to
    // avoid it because we all ready know the answer.  By keeping
    // track of the ftNow times we are called with we can determine
    // if we have all ready done the calculation or not.
    // We also know that no matter what once a lock timesout, it should
    // remained timed out for it's lifetime.
	//
    if ((!m_fHasTimedOut) && (!TimesEqual(ftNow, m_fRememberFtNow)))
    {
        // Based on the time passed in has the lock expired??
		//
	    __int64 i64TimePassed = 0;
        DWORD dwTimePassed = 0;
	    DWORD dwSecondTimeout = GetTimeoutInSecs();

	    //	Do the math to figure out when this lock expires/expired.
	    //
	    //	First calc how many seconds have passed since this lock
	    //	was last accessed.
	    //	Subtract the filetimes to get the time passed in 100-nanosecond
	    //	increments. (That's how filetimes count.)
		//		NOTE: Operation bellow is very dangerous on 64 bit platforms,
		//	as the filetimes need to be alligned on 8 byte boundary. So even
		//	change in order of current member variables or adding new ones
		//	can get us in the trouble
		//
	    i64TimePassed = ( (*(__int64*)&ftNow) -
					      (*(__int64*)&m_ftLastAccess)
					    );


	    //	Convert our time passed into seconds (10,000,000 100-nanosec incs in a second).
		//
	    dwTimePassed = (DWORD)( i64TimePassed / (__int64)10000000 );

	    //	Compare the timeout from the lock object to the count of seconds.
	    //	If this lock object has expired, remove it.
		//
        m_fHasTimedOut = dwSecondTimeout < dwTimePassed;
        m_fRememberFtNow = ftNow;
    }

	return  m_fHasTimedOut;
}

//
//  Routine takes the two hash indexes provided by the shared lock
//  manager and saves them as part of the lock token data.
//
void CInShLockData::SetHashes(DWORD dwIDValue, DWORD dwNameValue)
{
    m_dwNameHash = dwNameValue;

    // Figuring out what the actual hash ID of the lock item is.
	//
    m_dwIDHash = dwIDValue;
}

//
//  Routine creates a valid file handle based on the handle value
//  that the DAVProc procedure holds on the file.  Handles returned
//  from this function should have CloseHandle called on them when
//  they are done being used.
//
HRESULT CInShLockData::GetUsableHandle(HANDLE i_hDAVProcess, HANDLE* o_phFile)
{
	// CodeWork:: Should not need to pass in the DAVProcess handle here.

	// hDAVProcess is the handle to the dav process
	// while m_hDAVProcFileHandle is the handle to the file
	// in terms of the DAV Process's scope.
	//
	return DupHandle(i_hDAVProcess, m_hDAVProcFileHandle, o_phFile);
}

// ===============================================================
// CInShLockData Class Method Implemenations - Private
// ===============================================================

//
//  Routine copies the SID from the handle passed in, into the
//  shared memory location that holds the owner sid for the lock.
//
HRESULT CInShLockData::SetLockOwnerSID(HANDLE hit)
{
	BYTE tokenbuff[TOKENBUFFSIZE];
	TOKEN_USER *ptu = reinterpret_cast<TOKEN_USER *>(tokenbuff);
	ULONG ulcbTok = sizeof(tokenbuff);
	DWORD dwErr = 0;

	Assert(hit);

	//	Try to get the SID on this handle.
	//
	if (GetTokenInformation	(hit,
							 TokenUser,
							 ptu,
							 ulcbTok,
							 &ulcbTok))
	{
		SID * psid = reinterpret_cast<SID *>(ptu->User.Sid);
		DWORD dwLength;
		BOOL fSuccess;

		//	Copy the SID over into the lock object.
		//
    	dwLength = GetSidLengthRequired(psid->SubAuthorityCount);
		Assert(dwLength);	// MSDN said this call "cannot fail".

	    SharedPtr<CInShBytes> spSID;

        if (!spSID.FCreate())
            ShlkTrace("Creating SID Error \r\n");
        else
        {
		    fSuccess = CopySid(dwLength, spSID->GetPtrToBytes(dwLength), ptu->User.Sid);
		    if (!fSuccess)
		    {
			    //	Fail the method.
				//
			    dwErr = GetLastError();

				ShlkTrace ("Dav: Could not copy the SID: %d\n", dwErr);
			    goto err;
		    }

            m_hOffsetToSidOwner = spSID.GetHandle();
        }

        ShlkTrace ("CInShLockData::SetLockOwnerSID: ");
	}
	else
	{
		dwErr = GetLastError();
		ShlkTrace ("Dav: Could not query on impersonation token: %d\n", dwErr);
		goto err;
	}

err:
	return HRESULT_FROM_WIN32(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\rdwrlock.cpp ===
/*==========================================================================*\

    Module:        rdwrlock.cpp

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Implements a MultipleReader/SingleWriter synchronization
                     object that's optimized for a high reader to writer ratio.

\*==========================================================================*/

#include "_shmem.h"

/*$--CReadWriteLock::CReadWriteLock=========================================*\

\*==========================================================================*/

CReadWriteLock::CReadWriteLock()
{
    m_dwOwningThreadId = 0;
    m_cActiveReaders   = 0;
    m_hevtRead         = NULL;
    m_hevtWrite        = NULL;
    InitializeCriticalSection(&m_csWrite);
}


/*$--CReadWriteLock::~CReadWriteLock========================================*\

\*==========================================================================*/

CReadWriteLock::~CReadWriteLock()
{
    DeleteCriticalSection(&m_csWrite);
    if (m_hevtRead)
        CloseHandle(m_hevtRead);
    if (m_hevtWrite)
        CloseHandle(m_hevtWrite);
}


/*$--CReadWriteLock::FInitialize============================================*\

  Returns FALSE on error, use GetLastError() for more info.

\*==========================================================================*/

BOOL
CReadWriteLock::FInitialize()
{
    BOOL fSuccess = FALSE;

    m_hevtRead = CreateEvent(NULL,  // NULL security
                             TRUE,  // manual reset
                             FALSE, // initially cleared
                             NULL); // unnamed
    if (NULL == m_hevtRead)
        goto Exit;
    
    m_hevtWrite = CreateEvent(NULL,  // NULL security
                              FALSE, // auto reset
                              FALSE, // initially cleared
                              NULL); // unnamed
    if (NULL == m_hevtWrite)
        goto Exit;
    
    fSuccess = TRUE;
    
Exit:
        
    return fSuccess;
}


/*$--CReadWriteLock::WriteLock==============================================*\

  Acquire a write lock.  No read locks must be acquired by this threads before
    makeing this call.  Read locks may be acquired after getting the write lock.

\*==========================================================================*/

void
CReadWriteLock::WriteLock()
{
    LONG  cActiveReaders = m_cActiveReaders;
    DWORD dwWait         = 0;

    //
    // Assert that we don't already have the write lock are we're trying to get
    //   it again.
    //
    Assert(GetCurrentThreadId() != m_dwOwningThreadId);

    //
    // only one writer at a time.
    //
    EnterCriticalSection(&m_csWrite);

    //
    // Now assert that nobody else has the write lock.
    //
    Assert(0 == m_dwOwningThreadId);

    //
    // Taking note of this allows us to get read locks after we've gotten
    //   the write lock.
    //
    m_dwOwningThreadId = GetCurrentThreadId();

    //
    // Close the reader waiting gate by clearing the Reader wait event.
    //
    if (!ResetEvent(m_hevtRead))
        Assert(FALSE);

    //
    // Now shut the front door by setting the write locked bit on the Readers count
    //
    while(InterlockedCompareExchange((LONG *)&m_cActiveReaders,
                                     (WRITE_LOCKED_FLAG | cActiveReaders),
                                     cActiveReaders) != cActiveReaders)
        cActiveReaders = m_cActiveReaders;
    
    //
    // We only need to do this if there aren't any active readers at this point.
    //
    if (0 != cActiveReaders)
    {
        //
        // Wait for all the active readers to leave the scene.
        //
        dwWait = WaitForSingleObject(m_hevtWrite, INFINITE);
        Assert(WAIT_FAILED != dwWait);
    }
    
    Assert(WRITE_LOCKED_FLAG == m_cActiveReaders);
}


/*$--CReadWriteLock::WriteUnlock============================================*\

  All acquired read locks must have been released before calling this.

\*==========================================================================*/

void
CReadWriteLock::WriteUnlock()
{
    Assert(WRITE_LOCKED_FLAG == m_cActiveReaders);
    Assert(m_dwOwningThreadId == GetCurrentThreadId());
    
    //
    // Open the flood gates for any new attempts to aquire the read lock.
    //   This clears the WRITE_LOCKED_FLAG bit.
    //
    m_cActiveReaders = 0;
    
    //
    // Let go of any threads that got stuck waiting while we owned the write lock.
    //
    if (!SetEvent(m_hevtRead))
        Assert(FALSE);

    //
    // Take note that we don't own the write lock any longer.
    //
    m_dwOwningThreadId = 0;

    //
    // Now allow any thread that's attempting to acquire the write lock through.
    //
    LeaveCriticalSection(&m_csWrite);
}


/*$--CReadWriteLock::ReadLock===============================================*\

  Multiple read locks may be acquired but must be released as many times as
  they are acquired.

\*==========================================================================*/

void
CReadWriteLock::ReadLock()
{
    LONG  cActiveReaders = m_cActiveReaders;
    DWORD dwWait         = 0;
    
    //
    // loop until we get it.
    //
    for(;;)
    {
        //
        // Is the front door unlocked? (IE, is the write locked bit clear?)
        //
        if ( ! (cActiveReaders & WRITE_LOCKED_FLAG) )
        {
            //
            // Try to increment the count and test if we're successful.
            //
            if (InterlockedCompareExchange((LONG *)&m_cActiveReaders,
                                           (cActiveReaders+1),
                                           cActiveReaders) == cActiveReaders)
                break;
        }
        //
        //  Test to see if we already own the write lock.
        //
        else if (GetCurrentThreadId() == m_dwOwningThreadId)
        {
            //
            // We already have the write lock, so we may pass.
            // We don't increment the active readers count in this case and we
            //   won't decrement the count when we call ReadUnlock().
            //
            break;
        }
        else
        {
            //
            // Apparently, a thread is acquiring or has acquired the write lock.
            // So let's wait until the Read event is set before checking the
            //   front door again.
            //
            dwWait = WaitForSingleObject(m_hevtRead, INFINITE);
            Assert(WAIT_FAILED != dwWait);
        }
        
        //
        // Need to know this for the next spin through the loop
        //
        cActiveReaders = m_cActiveReaders;
    }
}


/*$--CReadWriteLock::ReadUnlock=============================================*\

  This should be called once for each ReadLock() call.

\*==========================================================================*/

void
CReadWriteLock::ReadUnlock()
{
    //
    // If we own the write lock, we don't need to do anything.
    //   We didn't increment the active readers count when we called ReadLock()
    //   so we won't decrement it now.
    //
    if (GetCurrentThreadId() == m_dwOwningThreadId)
        return;

    //
    // decrement the active reader count and determine if we're the last
    //   reader and a writer is waiting.
    //
    if (InterlockedExchangeAdd((LONG *)&m_cActiveReaders, -1) == (WRITE_LOCKED_FLAG + 1))
    {
        // We're the last reader and a writer is requesting access.
        if (!SetEvent(m_hevtWrite))
            Assert(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shlkcache\_shlkcache.h ===
/*
 *	_ S H L K C A C H E  . H
 *
 *	Precompiled header sources
 *
 *	Copyright 2000 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__SHLKCACHE_H_
#define __SHLKCACHE_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#include <malloc.h>
#include <caldbg.h>

DEFINE_TRACE(Shlk);
#define ShlkTrace				DO_TRACE(Shlk)

#endif	// __DAVFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\smseg.cpp ===
/*==========================================================================*\

    Module:        smseg.cpp

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  
    
\*==========================================================================*/

#include "_shmem.h"

//
//  The following are used to tag the first and last DWORD in free shared memory
//    blocks.  They are checked (if DBG) upon allocation to help detect memory
//    overruns, etc..
//
const DWORD SMS_BLOCK_HEAD = 'HeaD';
const DWORD SMS_BLOCK_TAIL = 'TaiL';


/*$--CSharedMemorySegment::CSharedMemorySegment=============================*\

\*==========================================================================*/

CSharedMemorySegment::CSharedMemorySegment(IN CSharedMemoryBlockHeap * psmbh)
{
    Assert(psmbh);

    m_pfl          = NULL;
    m_hFileMapping = NULL;
    m_pbMappedView = NULL;
    m_dwSegmentId  = 0;
    m_cbBlockSize  = 0;
    m_fBlkSz       = 0;
    m_psmbh        = psmbh;
}



/*$--CSharedMemorySegment::~CSharedMemorySegment============================*\

\*==========================================================================*/

CSharedMemorySegment::~CSharedMemorySegment()
{
    Deinitialize();
}



/*$--CSharedMemorySegment::FInitialize======================================*\

  pszInstanceName:  Root names used to find to the shared memory for the SMS.
  cbBlockSize:      The size of blocks that this SMS will hold.
  dwSegmentId:      The SegmentId of this SMS.

  returns:          TRUE on success, FALSE on failure, see GetLastError() on
                      failure.

  Assumption:       The caller has obtain exclusive access to this shared memory
                    file mapping so that we can initialize the mapping if we
                    created it.

\*==========================================================================*/

BOOL
CSharedMemorySegment::FInitialize(IN LPCWSTR pwszInstanceName,
                                  IN DWORD   cbBlockSize,
                                  IN DWORD   dwSegmentId)
{
    BOOL                   fSuccess                = FALSE;
    BOOL                   fCreatedMapping         = FALSE;
    DWORD                  dwLastError             = 0;
    WCHAR                  wszBindingExtension[MAX_PATH+1];
    WCHAR                  wszSegmentId[MAX_PATH+1];
    WCHAR                  wszBlkSz[MAX_PATH+1];

    Assert(cbBlockSize);
    Assert(pwszInstanceName);
    Assert(m_psmbh);
    Assert(wcslen(pwszInstanceName) < MAX_PATH);
    //
    // The following makes sure that the block size is an even power of 2.
    //
    Assert(cbBlockSize == static_cast<DWORD>(1 << GetHighSetBit(cbBlockSize)));

    m_dwSegmentId = dwSegmentId;
    m_cbBlockSize = cbBlockSize;
    m_fBlkSz      = GetHighSetBit(m_cbBlockSize);

    //
    _ultow(dwSegmentId, wszSegmentId, 16 /* numeric base */);
    _ultow(m_fBlkSz, wszBlkSz, 16 /* numeric base */);

    //
    //  Make sure we have room for the concatenated string.
    //
    if ((wcslen(pwszInstanceName) +
         wcslen(L"_SMS_") +
         wcslen(wszSegmentId) +
         wcslen(L"_") +
         wcslen(wszBlkSz)) >= MAX_PATH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    lstrcpyW(wszBindingExtension, L"_SMS_");
    lstrcatW(wszBindingExtension, wszSegmentId);
    lstrcatW(wszBindingExtension, L"_");
    lstrcatW(wszBindingExtension, wszBlkSz);

    m_hFileMapping = BindToSharedMemory(pwszInstanceName,
                                        wszBindingExtension,
                                        SMH_SEGMENT_SIZE,
                                        (PVOID*)&m_pbMappedView,
                                        &fCreatedMapping);

    if (NULL == m_hFileMapping)
        goto Exit;

    Assert(m_pbMappedView);

    //
    // Now get the location of the FreeList for this segment.
    //
    m_pfl = m_psmbh->FreeListFromSegmentId(dwSegmentId, m_pbMappedView);

    Assert(m_pfl);

    //
    // Now, if we created this mapping, initialize the FreeList and mark all
    // the blocks as free (all blocks are unowned now)
    //
    if (fCreatedMapping)
        InitializeBlocks();
    
    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        dwLastError = GetLastError();  // Preserve LastError

        Deinitialize();

        SetLastError(dwLastError);     // Restore LastError
    }

    return fSuccess;
}



/*$--CSharedMemorySegment::Deinitialize=====================================*\

\*==========================================================================*/

void
CSharedMemorySegment::Deinitialize()
{
    m_pfl         = NULL;
    m_psmbh       = NULL;
    m_dwSegmentId = 0;
    m_cbBlockSize = 0;
    m_fBlkSz      = 0;

    if (m_pbMappedView)
        UnmapViewOfFile(m_pbMappedView);
    m_pbMappedView = NULL;

    if (m_hFileMapping)
        CloseHandle(m_hFileMapping);
    m_hFileMapping = NULL;
}



/*$--CSharedMemorySegment::InitializeBlocks===============================*\

  This resets the state of the SMS so that all blocks are free.
  It assumes that the FreeList is uninitialized and initializes it.

\*==========================================================================*/

void
CSharedMemorySegment::InitializeBlocks()
{
    DWORD cbOffset = 0;

    //
    // Set the free list to show that there's no blocks free.
    //
    m_pfl->flhFirstFree = BLOCK_OFFSET_NULL << FLH_BLOCK_OFFSET_SHIFT;
    
    //
    // Starting from the last block in the segment, free all the blocks,
    //   except for the very first block.
    //
    for(cbOffset = (SMH_SEGMENT_SIZE - m_cbBlockSize);
        cbOffset;
        cbOffset -= m_cbBlockSize)
	{        
		Free(MakeSMBA(m_dwSegmentId, cbOffset, m_fBlkSz));
	}

    //
    // Now do the first block if it's not being used to hold free list data
    //
	if (m_dwSegmentId % FreeListsPerSegment(m_cbBlockSize))
	{
		Free(MakeSMBA(m_dwSegmentId, 0, m_fBlkSz));
	}
}



/*$--CSharedMemorySegment::Free=============================================*\

  Frees the block associated with hSMBA.

\*==========================================================================*/

void
CSharedMemorySegment::Free(IN SHMEMHANDLE hSMBA)
{
    // Calculate everything that won't changed inside the do loop
    DWORD            cbOffsetSMBA     = SegmentOffsetFromSMBA(hSMBA);
    PVOID            pvSMBA           = PvFromSMBA(hSMBA);
    DWORD            flhNewHighBits   = cbOffsetSMBA << FLH_BLOCK_OFFSET_SHIFT;
    DWORD            cbNextFreeOffset = 0;
    FREE_LIST_HANDLE flhCurrent       = 0;
    FREE_LIST_HANDLE flhNew           = 0;

    if (0 == hSMBA)
    	return;

    // This should have been assured by SegmentOffsetFromSMBA()
    Assert(0 == (flhNewHighBits & FLH_SEQUENCE_MASK));
        
    //
    //  We store well known DWORDs at the beginning and the end of free blocks
    //    and check them just before allocating the blocks.  This should help
    //    detect if the blocks are being written past their ends.
    //  We can get more sophisticated than this if needed.
    //
    *(DWORD*)pvSMBA = SMS_BLOCK_HEAD;
    *(((DWORD*)(((BYTE*)pvSMBA) + m_cbBlockSize)) - 1) = SMS_BLOCK_TAIL;

    //
    // We will spin through this loop until the commit of the data to 
    //  m_pfl->flhFirstFree succeeds.
    //
    do
    {
        //
        // Copy the FREE_LIST_HANDLE that refers to the first free block.
        //
        flhCurrent = m_pfl->flhFirstFree;

        //
        // Get the offset to that free block
        //
        cbNextFreeOffset = (flhCurrent & FLH_BLOCK_OFFSET_MASK) >> FLH_BLOCK_OFFSET_SHIFT;

        //
        // Is there a next free block? (ie is the offset non-NULL)
        //
        if (cbNextFreeOffset != BLOCK_OFFSET_NULL)
            //
            // Set the offset to the next free block in the block we're freeing
            // We store this one DWORD past the beginning of the block
            //   so there's room for a marker to detect block overwrites.
            //
            *(((DWORD*)pvSMBA)+1) = cbNextFreeOffset;
        else
            *(((DWORD*)pvSMBA)+1) = BLOCK_OFFSET_NULL;

        //
        // Calculate the new flhFirstFree member value.
        // We don't need to increment the sequence when freeing.
        //
        flhNew = (flhCurrent & FLH_SEQUENCE_MASK) | flhNewHighBits;

    }   // Now let's attemp to commit this change.
    while(flhCurrent != static_cast<FREE_LIST_HANDLE>(
    								InterlockedCompareExchange((LONG *)&(m_pfl->flhFirstFree),
																flhNew,
																flhCurrent)));
}



/*$--CSharedMemorySegment::PvAlloc==========================================*\

  phSMBA:  point to location to place SMBA handle.

  returns: virtual address of the allocated block.
           NULL if there are no free blocks available.

\*==========================================================================*/

PVOID
CSharedMemorySegment::PvAlloc(OUT SHMEMHANDLE * phSMBA)
{
    PVOID            pvReturn         = NULL;
    FREE_LIST_HANDLE flhCurrent       = 0;
    FREE_LIST_HANDLE flhNew           = 0;
    DWORD            cbNextFreeOffset = 0;
    DWORD            cbFreeOffset     = 0;

    Assert(phSMBA);

    //
    // We will spin through this loop until the commit of the data to 
    //  m_pfl->flhFirstFree succeeds.
    //
    do
    {
        //
        // Get a copy of the current FreeList head
        //
        flhCurrent = m_pfl->flhFirstFree;

        //
        // Get the offset to the first free block
        //
        cbFreeOffset = (flhCurrent & FLH_BLOCK_OFFSET_MASK) >> FLH_BLOCK_OFFSET_SHIFT;

        //
        // If this offset is NULL, the list is empty and we should move on to
        //   greener pastures.
        //
        if (BLOCK_OFFSET_NULL == cbFreeOffset)
        {
            pvReturn = NULL;
            break;
        }

        Assert(cbFreeOffset < SMH_SEGMENT_SIZE);

        //
        // Calculate a pointer to the free block.
        //
        pvReturn = (PVOID)(m_pbMappedView + cbFreeOffset);

        //
        // Get the offset to the next free block from the one we're allocating
        // We store this one DWORD past the beginning of the block
        //   so there's room for a marker to detect block overwrites.
        //
        cbNextFreeOffset = *(((DWORD*)pvReturn)+1);

        //
        // Calculate the new flhFirstFree member value.
        // For an allocate, we must increment the sequence number.  See the
        //   description of FREE_LIST_HANDLE in smseg.h for an explaination of
        //   why we must do this.
        //
        flhNew = (((flhCurrent+1) & FLH_SEQUENCE_MASK) |
                  (cbNextFreeOffset << FLH_BLOCK_OFFSET_SHIFT));

    }   // Now let's attemp to commit this change.
    while(flhCurrent != static_cast<FREE_LIST_HANDLE>(
    								InterlockedCompareExchange((LONG *)&(m_pfl->flhFirstFree),
    															flhNew,
    															flhCurrent)));
    
    if (pvReturn)
    {
        //
        // Now figure out the SMBA handle for the block that we allocated
        //
        *phSMBA = MakeSMBA(m_dwSegmentId, cbFreeOffset, m_fBlkSz);

        //
        // Make sure it refers to the virtual address that we have
        //
        Assert(PvFromSMBA(*phSMBA) == pvReturn);

        //
        // Now let's verify that the head and tail signatures are correct
        //
        Assert(*(DWORD*)pvReturn == SMS_BLOCK_HEAD);
        Assert(*(((DWORD*)(((BYTE*)pvReturn) + m_cbBlockSize)) - 1) == SMS_BLOCK_TAIL);

#ifdef DBG
        //
        //  Lets use a fill pattern to catch clients that don't initialize
        //    their memory.
        //
        FillMemory(pvReturn, m_cbBlockSize, 0xfb);
#endif // DBG

    }

    return pvReturn;
}



/*$--CSharedMemorySegment::FIsValidSMBA=====================================*\

  This is mainly used in Asserts to validate SMBAs.

\*==========================================================================*/

BOOL
CSharedMemorySegment::FIsValidSMBA(IN SHMEMHANDLE hSMBA)
{
    return (!hSMBA ? TRUE : ((FBlkSzFromSMBA(hSMBA) == GetHighSetBit(m_cbBlockSize)) &&
                             (!(SegmentOffsetFromSMBA(hSMBA) % m_cbBlockSize)) &&
                             (SegmentIdFromSMBA(hSMBA) == m_dwSegmentId)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_shmem.cpp ===
/*==========================================================================*\

    Module:        _shmem.cpp

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  precompiled implementation file for SHMEM library
    
\*==========================================================================*/

#include "_shmem.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\smblockh.cpp ===
/*==========================================================================*\

    Module:        smblockh.cpp

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:

\*==========================================================================*/

#include "_shmem.h"



/*$--CSharedMemoryBlockHeap::CSharedMemoryBlockHeap=========================*\

\*==========================================================================*/

CSharedMemoryBlockHeap::CSharedMemoryBlockHeap()
{
    m_cbBlockSize        = 0;
    m_iSMSFirstFree      = 0;
    m_cSMSMac            = 0;
    m_cSMS               = 0;
    m_rgpSMS             = NULL;
    m_wszInstanceName[0] = L'\0';
    m_hmtxGrow           = NULL;
}



/*$--CSharedMemoryBlockHeap::~CSharedMemoryBlockHeap========================*\

\*==========================================================================*/

CSharedMemoryBlockHeap::~CSharedMemoryBlockHeap()
{
    Deinitialize();
}



/*$--CSharedMemoryBlockHeap::FInitialize====================================*\

  pwszInstanceName: this is used as the root of the shared memory segment names
  cbBlockSize:      this is the size of the memory blocks that this block heap
                      will be serving up.

  returns:          TRUE on success, FALSE on error.  Use GetLastError for
                      more information in case of failure.

\*==========================================================================*/

BOOL
CSharedMemoryBlockHeap::FInitialize(IN LPCWSTR pwszInstanceName,
                                    IN DWORD   cbBlockSize)
{
    BOOL  fSuccess = FALSE;
    WCHAR wszBindingExtension[MAX_PATH];

    Assert(cbBlockSize);
    Assert(wcslen(pwszInstanceName) < MAX_PATH);

    m_cbBlockSize        = cbBlockSize;
    m_iSMSFirstFree      = 0;
    m_cSMSMac            = 0;
    m_cSMS               = 0;
    m_rgpSMS             = NULL;
    m_wszInstanceName[0] = L'\0';

    if (wcslen(pwszInstanceName) >= MAX_PATH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
    else
        lstrcpyW(m_wszInstanceName, pwszInstanceName);


    _ultow(m_cbBlockSize, wszBindingExtension, 16 /* numeric base */);
    lstrcatW(wszBindingExtension, L"_GrowMutex");

    //
    // Now that we have a binding extension, let's create the mutex.
	//
    m_hmtxGrow = BindToMutex(pwszInstanceName,
                             wszBindingExtension,
                             FALSE,
                             NULL);
    if (NULL == m_hmtxGrow)
        goto Exit;

    if (!m_rwl.FInitialize())
        goto Exit;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}



/*$--CSharedMemoryBlockHeap::Deinitialize===================================*\

  Call Reset and zero some things out.

\*==========================================================================*/

void
CSharedMemoryBlockHeap::Deinitialize()
{
    if (m_cSMS)
    {
        Assert(m_cSMS <= m_cSMSMac);
        Assert(m_rgpSMS);
        while(m_cSMS)
        {
            Assert(m_rgpSMS[m_cSMS-1]);
            delete m_rgpSMS[--m_cSMS];
        }
        SharedMemory::Free(m_rgpSMS);
        m_rgpSMS = NULL;
    }

    m_iSMSFirstFree      = 0;
    m_cSMSMac            = 0;
    m_cSMS               = 0;
    m_cbBlockSize        = 0;
    m_wszInstanceName[0] = L'\0';

    if (m_hmtxGrow)
        CloseHandle(m_hmtxGrow);
    m_hmtxGrow = NULL;
}


/*$--CSharedMemoryBlockHeap::FreeListFromSegmentId==========================*\

  FreeLists are stored in the first block of the first SMS.  There are as many
    FreeLists in this first block as space for them permits.  If there's room
    for 8 FreeLists, then the FreeLists for SMSs 0 through 7 will be stored
    here.  The Freelists for SMSs 8 through 15 will then be stored in the first
    block on SMS 8. And so on.  This keeps the spaced used for the FreeLists to
    a minimum.

  This method returns the virtual address of the FreeList for a given Segment.
  It's necessary to pass in a pointer to that shared memory so that in the case
    that the FreeList is on the same Segment we have a pointer to calculate
    the location of the FreeList from.  This is because this SMS hasn't
    been registered with CSharedMemoryBlockHeap yet (it's initializing right
    now).

\*==========================================================================*/

FreeList *
CSharedMemoryBlockHeap::FreeListFromSegmentId(IN DWORD   dwSegmentId,
                                              IN BYTE  * pbMappedView)
{
    FreeList * pfl               = NULL;
    DWORD      dwFreeListSegment = (DWORD)(dwSegmentId / FreeListsPerSegment(m_cbBlockSize)) * FreeListsPerSegment(m_cbBlockSize);
    DWORD      iFreeList         = dwSegmentId % FreeListsPerSegment(m_cbBlockSize);

    Assert(pbMappedView);

    //
    // We must get a read lock to access the m_rgpSMS array.
    //
    m_rwl.ReadLock();

    Assert((0 == iFreeList) || (iFreeList && (dwFreeListSegment < m_cSMS)));

    //
    // If we're creating the segment that the FreeList is on, it won't be
    //    in the segment array yet, so we'll use the pointer that was passed
    //    in to this method.  Otherwise we calculate the location of the
    //    FreeList.
    //
    if (0 == iFreeList)
        //
        // In this case it's the first FreeList in the block
        //
        pfl = (FreeList *)pbMappedView;
    else
        pfl = (FreeList *)(m_rgpSMS[dwFreeListSegment]->PbGetMappedView() +
                           sizeof(FreeList) * iFreeList);

    m_rwl.ReadUnlock();

    return pfl;
}



/*$--CSharedMemoryBlockHeap::FGrowHeap======================================*\

  This is called from several other place to request that another SMS be
    added.  The cCurrentSegments count is the value of m_cSMS that the decision
    to call FGrowHeap was based on.  So if (m_cSMS > cCurrentSegments) any longer
    then we just return TRUE to indicate success without adding another SMS.
  This prevent too many SMSs from being added because of race condition.
  If the caller still needs another SMS, the caller will call again.

  FALSE is only returned if there's an error in attempting to add another SMS.
  GetLastError() can be used to get more information about the failure.

\*==========================================================================*/

BOOL
CSharedMemoryBlockHeap::FGrowHeap(IN DWORD cCurrentSegments)
{
    BOOL                   fSuccess       = FALSE;
    BOOL                   fMutexAcquired = FALSE;
    DWORD                  dwLastError    = NO_ERROR;
    PVOID                  pvTemp         = NULL;
    DWORD                  cSMSTemp       = 0;
    CSharedMemorySegment * pSMS           = NULL;

    //
    // We need to get a write lock in order to modify m_rgpSMS and friends
    //
    m_rwl.WriteLock();

    //
    // Now we have exclusive access to m_rgpSMS, m_cSMS, and m_cSMSMac
    //

    //
    // Check to see if what they thought was a current count of the segments
    //   changed because someone else just grew the heap.
    //
    if (cCurrentSegments < m_cSMS)
    {
        //
        // This is a special case of success.
        // We don't want to Grow the heap if someone else just did.
        // If we still need to grow, they'll just call us again.
        //
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // Does the array need to be grown?
    //
    if (m_cSMS + 1 > m_cSMSMac)
    {
        //
        // Double the array size if it's already been allocated, otherwise
        //   try the initial array size.
        //
        cSMSTemp = (m_cSMSMac ? (m_cSMSMac * 2) : INITIAL_SMS_ARRAY_SIZE);

        pvTemp = SharedMemory::PvReAllocate(m_rgpSMS,
                                            cSMSTemp * sizeof(CSharedMemorySegment *));
        if (!pvTemp)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }
        //
        // Now commit the new values to the class member vars
        //
        m_rgpSMS = (CSharedMemorySegment **)pvTemp;
        m_cSMSMac = cSMSTemp;
    }


    //
    // Create a new SMS and tell it who owns it so it can find its FreeList.
    //
    pSMS = new CSharedMemorySegment(this);
    if (NULL == pSMS)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    //
    // We must now acquire the grow mutex so that any other processes that might
    //   be growing this block heap in their process won't collide with us when
    //   we initialize the shared memory (if we're the creators of the mapping).
    //
    if (!FAcquireMutex(m_hmtxGrow))
        goto Exit;
    fMutexAcquired = TRUE;

    if (!pSMS->FInitialize(m_wszInstanceName,
                           m_cbBlockSize,
                           m_cSMS))
        goto Exit;

    //
    // It worked, so now add it to the SMS array.
    //
    m_rgpSMS[m_cSMS++] = pSMS;
    pSMS = NULL;

    Assert(m_cSMS <= m_cSMSMac);

    fSuccess = TRUE;

Exit:
    dwLastError = GetLastError();  // Preserve LastError

    if (fMutexAcquired)
        FReleaseMutex(m_hmtxGrow);

    m_rwl.WriteUnlock();

    //
    // If the SMS initialization failed this will be non-NULL, delete the SMS.
    //
    if (pSMS)
        delete pSMS;

    SetLastError(dwLastError);     // Restore LastError

    return fSuccess;
}



/*$--CSharedMemoryBlockHeap::Free===========================================*\

  For this we essentially identify which SMS the block was allocated on and
    forward the call to that SMS.
  We may need to grow the heap to get the SMS opened that the block was
    allocated from.
  We also update a hint we use to find free blocks in the lowest numbered
    SMSs.  With high allocation turnover, this will help maintain a good
    locallity of access amoung allocated blocks and help to minimize our
    working set.

\*==========================================================================*/

void
CSharedMemoryBlockHeap::Free(IN SHMEMHANDLE hSMBA)
{
    DWORD iFirstFree  = 0;
    DWORD dwSegmentId = SegmentIdFromSMBA(hSMBA);
    DWORD cSMS        = m_cSMS;

    //
    // Make sure we've got this segment opened.
    // If it was allocated on the heap from within another process, we may not
    //   have open this segment yet.
    //
    while(dwSegmentId >= cSMS)
    {
        //
        // cSMS is the SMS count that we based our decision upon to request that
        //    the heap be grown.
        //
        if (!FGrowHeap(cSMS))
            goto Exit;
        cSMS = m_cSMS;
    }

    //
    // Get a read lock so that m_rgpSMS doesn't changed underneath us.
    //
    m_rwl.ReadLock();

    //
    // Free the block from it's segment.
    //
    m_rgpSMS[dwSegmentId]->Free(hSMBA);

    //
    // Now let's update our hint
    //
    iFirstFree = m_iSMSFirstFree;
    if (dwSegmentId < iFirstFree)
        //
        // If someone else hasn't changed it, let's update it.
        //
        InterlockedCompareExchange((LONG *)&m_iSMSFirstFree,
                                   dwSegmentId,
                                   iFirstFree);
    //
    // We won't spin on this.  If someone else modified it before we did, that's
    //   fine.  We don't need to be perfect about this.
    //

    m_rwl.ReadUnlock();

Exit:
    return;
}

/*$--CSharedMemoryBlockHeap::PvAlloc========================================*\

  Find an SMS to allocate a block from.  On error, NULL is returned and
    GetLastError() can be used to get more information.

\*==========================================================================*/

PVOID
CSharedMemoryBlockHeap::PvAlloc(OUT SHMEMHANDLE * phSMBA)
{
    PVOID pvReturn          = NULL;
    BOOL  fReadLockEntered  = FALSE;
    DWORD iSMS              = 0;
    DWORD iFirstFree        = 0;
    DWORD cSMS              = 0;

    Assert(phSMBA);

    *phSMBA = NULL;

    //
    // prime the pump if it needs priming...
    //
    if (0 == m_cSMS)
    {
        if (!FGrowHeap(0))
        {
            Assert(FALSE);
            goto Exit;
        }
    }

    while(NULL == pvReturn)
    {
        //
        // Get a read lock so that m_rgpSMS doesn't change beneath us.
        //
        m_rwl.ReadLock();
        fReadLockEntered = TRUE;

        //
        // We'll start looking in the lowest segment that was recently freed
        //
        iFirstFree = m_iSMSFirstFree;

        //
        // Now try an allocation on that SMS
        //
        pvReturn = m_rgpSMS[iFirstFree]->PvAlloc(phSMBA);
        if (pvReturn)
            break;

        //
        // That didn't work, so let's start there and work our way up the
        //   segment numbers and then start at 0 up to our hinted SMS.
        //
        for (iSMS = (iFirstFree + 1) % m_cSMS;
             iSMS != iFirstFree;
             iSMS = (iSMS + 1) % m_cSMS)
        {
            pvReturn = m_rgpSMS[iSMS]->PvAlloc(phSMBA);
            if (pvReturn)
                break;
        }

        //
        // We successfully allocate something, so break out of here.
        //
        if (pvReturn)
            break;

        //
        // We've not had any success, so let's try to grow the heap.
        // First make a copy of m_cSMS so FGrowHeap knows what value of m_cSMS
        //   we were working from.
        //
        cSMS = m_cSMS;

        //
        // Now temporarily leave the read lock so we can attempt to grow the heap
        //
        m_rwl.ReadUnlock();
        fReadLockEntered = FALSE;

        //
        // It won't actually grow if (cSMS < m_cSMS)
        //
        if (!FGrowHeap(cSMS))
        {
            pvReturn = NULL;
            goto Exit;
        }

        //
        // Ok, so let's try this again.  We'll re-acquire the read lock at the
        //   top of the loop.
        //
    }

    //
    // Since m_iSMSFirstFree is only a hint, it's not critical that we're
    //    exact about doing this.
    //
    if (iSMS > iFirstFree)
        //
        // If someone else hasn't changed it, let's update it.
        //
        InterlockedCompareExchange((LONG *)&m_iSMSFirstFree,
                                   iSMS,
                                   iFirstFree);
    //
    // We won't spin on this.  If someone else modified it before we did, that's
    //   fine.  We don't need to be perfect about this.
    //

Exit:
    if (fReadLockEntered)
        m_rwl.ReadUnlock();

    return pvReturn;
}



/*$--CSharedMemoryBlockHeap::PvFromSMBA=====================================*\

  This returns the virtual address of a shared memory block.
  It may need to grow the heap, since the referred to block may have been
    allocated in another process.
  The growing of the heap may result in an error and a NULL value being returned.
  If the case of an error, GetLastError() can be used to get more information.

\*==========================================================================*/

PVOID
CSharedMemoryBlockHeap::PvFromSMBA(IN SHMEMHANDLE hSMBA)
{
    PVOID pvReturn    = NULL;
    DWORD dwSegmentId = SegmentIdFromSMBA(hSMBA);
    DWORD cSMS        = m_cSMS;

    //
    // Make sure we've got this segment opened.
    // If it was allocated on the heap from within another process, we may not
    //   have open this segment yet.
    //
    while(dwSegmentId >= cSMS)
    {
        //
        // cSMS is the SMS count that we based our decision upon to request that
        //    the heap be grown.
        //
        if (!FGrowHeap(cSMS))
            goto Exit;
        cSMS = m_cSMS;
    }

    //
    // Get a read lock so that m_rgpSMS doesn't changed underneath us.
    //
    m_rwl.ReadLock();

    //
    // Forward the call to the SMS that owns the block.
    //
    pvReturn = m_rgpSMS[dwSegmentId]->PvFromSMBA(hSMBA);

    m_rwl.ReadUnlock();

Exit:
    return pvReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_rdwrlck.h ===
/*==========================================================================*\

    Module:        _rdwrlck.h

    Copyright Microsoft Corporation 1997, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Defines a MultipleReaders/SingleWriter synchronization object.
                   It's optimized for a very high reader to writer ratio.
                   There's no support for promotion from a read lock to a write lock,
                      but this can be added.
                   There's no timeout for acquiring these locks, this can be
                      added too.
                   If you want either of these features, let me know and I'll add them.
                   Another limitation is that a thread can not enter a WriteLock()
                      without leaving all of its ReadLock()s.  Also it can not enter
                      another WriteLock() before leaving a previous WriteLock().

\*==========================================================================*/

#ifndef ___RDWRLCK_H__
#define ___RDWRLCK_H__


class CReadWriteLock {
    
    enum { WRITE_LOCKED_FLAG = 0x80000000 };

public:
    CReadWriteLock();
    ~CReadWriteLock();
    
    BOOL FInitialize();  // If it returns FALSE, use GetLastError() for more info.
    
    void ReadLock();
    void ReadUnlock();
    
    void WriteLock();
    void WriteUnlock();

private:
    
    CReadWriteLock(const CReadWriteLock&);               // don't allow this
    CReadWriteLock& operator=(const CReadWriteLock&);    // don't allow this
    
    DWORD            m_dwOwningThreadId; // Used to be able to enter a readlock
                                         // after already acquiring a writelock
    
    LONG   volatile  m_cActiveReaders;   // Count of active readers.
                                         // High bit represents a waiting writer.
    
    HANDLE           m_hevtRead;      // Used to hold readers when a writer is 
                                      //    waiting/active
    HANDLE           m_hevtWrite;     // Used to release a writer when there are 
                                      //    no more active readers.
    
    CRITICAL_SECTION m_csWrite;  // Used to serialize writers.
};


#endif // ___RDWRLCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\smheap.cpp ===
/*==========================================================================*\

    Module:        smheap.cpp

    Copyright Microsoft Corporation 1997, All Rights Reserved.

    Author:        mikepurt

    Descriptions:

\*==========================================================================*/

#include "_shmem.h"
#include <align.h>
#include <stddef.h>
#include <singlton.h>


/*$--CSharedMemoryHeap::~CSharedMemoryHeap==================================*\

\*==========================================================================*/

CSharedMemoryHeap::~CSharedMemoryHeap()
{
    Deinitialize();
}



/*$--CSharedMemoryHeap::FInitialize=========================================*\

  This simply runs through all the block heaps and initializes them.
  pszInstanceName:  This is used as the root of the shared memory segment names

\*==========================================================================*/

BOOL
CSharedMemoryHeap::FInitialize(IN LPCWSTR pwszInstanceName)
{
    DWORD iBlockHeap = 0;

    for (iBlockHeap = 0;
         iBlockHeap < (SMH_MAX_HEAP_BLKSZ - SMH_MIN_HEAP_BLKSZ + 1);
         iBlockHeap++)
    {
        if (!m_rgsmbh[iBlockHeap].FInitialize(pwszInstanceName,
                                              1 << (iBlockHeap + SMH_MIN_HEAP_BLKSZ)))
            return FALSE;
    }
    return TRUE;
}



/*$--CSharedMemoryHeap::Deinitialize========================================*\

  Opposite of FInitialize().

\*==========================================================================*/

void
CSharedMemoryHeap::Deinitialize()
{
    DWORD iBlockHeap = 0;

    for (iBlockHeap = 0;
         iBlockHeap < (SMH_MAX_HEAP_BLKSZ - SMH_MIN_HEAP_BLKSZ + 1);
         iBlockHeap++)
        m_rgsmbh[iBlockHeap].Deinitialize();
}


/*$--CSharedMemoryHeap::PvAlloc=============================================*\

  This takes a look at cbData and determines which block heap to forward the
    allocation request to.

\*==========================================================================*/

PVOID
CSharedMemoryHeap::PvAlloc(IN  DWORD    cbData,
                           OUT SHMEMHANDLE * phSMBA)
{
    PVOID pvReturn = NULL;
    DWORD fBlkSz   = 0;

    //
    // So let's figure out which block heap we should allocate this from.
    //
    // If (cbData == 0), we will allocate the smallest block that we're serving up.
    //

    //
    // First figure out the high bit that's set.
    //   if (cbData == 0) fBlkSz will equal 0.
    //
    fBlkSz = GetHighSetBit(cbData);

    //
    // If it's not an even power of two, round up to the next one.
    // if (cbData == 0)
    //   then fBlkSz will equal 1.
    //
    if (cbData != static_cast<DWORD>(1 << fBlkSz))
        fBlkSz++;
    //
    // If it's too big, return an error.
    //
    if (fBlkSz > SMH_MAX_HEAP_BLKSZ)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;        
    }

    //
    // if it's a small allocation, raise it to our smallest supported block size
    //
    if (fBlkSz < SMH_MIN_HEAP_BLKSZ)
        fBlkSz = SMH_MIN_HEAP_BLKSZ;

    //
    // Now dispatch it to the correct block heap.
    //
    pvReturn = m_rgsmbh[fBlkSz-SMH_MIN_HEAP_BLKSZ].PvAlloc(phSMBA);

Exit:

    return pvReturn;
}



/*$--CPubSharedMemoryHeap===================================================*\

  Implementation of public interface to shared memory heap.

\*==========================================================================*/

class CPubSharedMemoryHeap : private Singleton<CPubSharedMemoryHeap>
{
private:
	CSharedMemoryHeap m_smh;

    //
    // We want anyone copying this around.
    //
    CPubSharedMemoryHeap& operator=(const CPubSharedMemoryHeap&);
    CPubSharedMemoryHeap(const CPubSharedMemoryHeap&);

public:
	//
	//	Expose Singleton instance functions
	//
	using Singleton<CPubSharedMemoryHeap>::CreateInstance;
	using Singleton<CPubSharedMemoryHeap>::DestroyInstance;
	using Singleton<CPubSharedMemoryHeap>::Instance;


    CPubSharedMemoryHeap() {};
    
	BOOL FInitialize(IN LPCWSTR pwszInstanceName)
	{
		return m_smh.FInitialize( pwszInstanceName );
	}

	PVOID PvAlloc(IN DWORD cbData,
				  OUT SHMEMHANDLE * phSMBA)
	{
		return m_smh.PvAlloc(cbData, phSMBA);
	}

	VOID Free(IN SHMEMHANDLE hSMBA)
	{
		m_smh.Free(hSMBA);
	}

	PVOID PvFromSMBA(IN SHMEMHANDLE hSMBA)
	{
		return m_smh.PvFromSMBA(hSMBA);
	}
};

/*$--SMH::FInitialize=======================================================*\

\*==========================================================================*/

BOOL __fastcall
SMH::FInitialize( IN LPCWSTR pwszInstanceName )
{
	if (CPubSharedMemoryHeap::CreateInstance().FInitialize(pwszInstanceName))
		return TRUE;

	CPubSharedMemoryHeap::DestroyInstance();
	return FALSE;
}

/*$--SMH::Deinitialize======================================================*\

\*==========================================================================*/

VOID __fastcall
SMH::Deinitialize()
{
	CPubSharedMemoryHeap::DestroyInstance();
}

/*$--SMH::PvAlloc===========================================================*\

\*==========================================================================*/

PVOID __fastcall
SMH::PvAlloc( IN DWORD cbData, OUT SHMEMHANDLE * phsmba )
{
	return CPubSharedMemoryHeap::Instance().PvAlloc(cbData, phsmba);
}

/*$--SMH::Free==============================================================*\

\*==========================================================================*/

VOID __fastcall
SMH::Free( IN SHMEMHANDLE hsmba )
{
	CPubSharedMemoryHeap::Instance().Free(hsmba);
}

/*$--SMH::PvFromSMBA========================================================*\

\*==========================================================================*/

PVOID __fastcall
SMH::PvFromSMBA( IN SHMEMHANDLE hsmba )
{
	return CPubSharedMemoryHeap::Instance().PvFromSMBA(hsmba);
}


/*$--SharedMemory===========================================================*\

  Implementation of LOCAL memory allocators used with the SHARED memory
  subsystem.  Note: these are NOT shared memory allocators!

\*==========================================================================*/

struct SSize
{
	DWORD dwSize;
};

PVOID __stdcall
SharedMemory::PvAllocate(IN DWORD cb)
{
	SSize * pSize = static_cast<SSize *>(operator new(AlignNatural(sizeof(SSize)) + cb));

	if ( pSize )
	{
		pSize->dwSize = cb;
		return reinterpret_cast<LPBYTE>(pSize) + AlignNatural(sizeof(SSize));
	}

	return NULL;
}

VOID __stdcall
SharedMemory::Free(IN PVOID pv)
{
	if ( pv )
	{
		SSize * pSize = reinterpret_cast<SSize *>(static_cast<LPBYTE>(pv) - AlignNatural(sizeof(SSize)));

		Assert( !IsBadReadPtr(pSize, AlignNatural(sizeof(SSize))) );
		Assert( !IsBadReadPtr(pSize, AlignNatural(sizeof(SSize)) + pSize->dwSize) );

		operator delete(pSize);
	}
}

PVOID __stdcall
SharedMemory::PvReAllocate(IN PVOID pvOld,
						   IN DWORD cb)
{
	PVOID pvNew = SharedMemory::PvAllocate(cb);

	if ( pvNew && pvOld )
	{
		SSize * pSizeOld = reinterpret_cast<SSize *>(static_cast<LPBYTE>(pvOld) - AlignNatural(sizeof(SSize)));

		Assert( !IsBadReadPtr(pSizeOld, AlignNatural(sizeof(SSize))) );
		Assert( !IsBadReadPtr(pSizeOld, AlignNatural(sizeof(SSize)) + pSizeOld->dwSize) );

		CopyMemory( pvNew, pvOld, pSizeOld->dwSize );
		SharedMemory::Free( pvOld );
	}

	return pvNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\smqutil.cpp ===
/*==========================================================================*\

    Module:        smqutil.cpp

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Misc routines that don't belong in classes.

\*==========================================================================*/

#include "_shmem.h"

#include <implstub.h>

const CHAR DAV_IPC_INSTANCE_NAME[] = "DavExIpc";

const WCHAR gc_wszTSGlobal[] = L"Global\\";
const INT gc_cchszTSGlobal   = sizeof(gc_wszTSGlobal)/sizeof(WCHAR) - 1;

/*$--BindToMutex============================================================*\

  pwszInstanceName & pwszBindingExtension:concatenated to form the name
                                          that the mutex will be created with.
  fInitiallyOwn:                          Passed on to CreateMutex() call
  lpMutexAttributes:                      Passed on to CreateMutex() call

  returns:                                On Success, the mutex handle.
                                          On Failure, NULL.  GetLastError() to
                                          get more information.

\*==========================================================================*/

HANDLE
BindToMutex(IN LPCWSTR               pwszInstanceName,
            IN LPCWSTR               pwszBindingExtension,
            IN BOOL                  fInitiallyOwn,
            IN LPSECURITY_ATTRIBUTES lpMutexAttributes)
{
    Assert(pwszInstanceName);
    Assert(pwszBindingExtension);

    HANDLE hmtx = NULL;
    WCHAR  wszBindingName[MAX_PATH+1];
	SECURITY_DESCRIPTOR sd;
	SECURITY_ATTRIBUTES sa;
	UINT cchInstanceName = static_cast<UINT>(wcslen(pwszInstanceName));
	UINT cchBindingExtension = static_cast<UINT>(wcslen(pwszBindingExtension));

	if (lpMutexAttributes == NULL)
	{
		//	Initialize the security descriptor with completely open access
		//
		//$HACK	- Special case for HTTPEXT
		//
		//	To meet C2 security requirements, we cannot have any completely
		//	open objects.  Fortunately, HTTPEXT only uses this code for its
		//	perf counters which are both generated and gathered in the same
		//	process (W3SVC) and same security context (local system).  Access
		//	can thus be left to the default (local system or admin only).
		//
		if (pwszInstanceName != wcsstr(pwszInstanceName, L"HTTPEXT"))
		{
			InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
			SetSecurityDescriptorDacl (&sd, TRUE, NULL, FALSE);
			sa.nLength = sizeof(SECURITY_ATTRIBUTES);
			sa.lpSecurityDescriptor = &sd;
			sa.bInheritHandle = TRUE;

			lpMutexAttributes = &sa;
		}
	}

    //
    // Check to make sure we're not going to overrun our character buffer.
    //
	if (cchInstanceName +
		cchBindingExtension +
		gc_cchszTSGlobal >= MAX_PATH)
    {
        hmtx = NULL;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

	//
	//	Create the mutex.
	//
	//	Raid 137862
	//	The mutex must be named so that it will reside
	//	in the Global Kernel Object Name Space in order to be visible from
	//	a Terminal Services client.
	//
	{
		LPWSTR pwsz = wszBindingName;

		memcpy(pwsz,
			   gc_wszTSGlobal,
			   sizeof(WCHAR) * gc_cchszTSGlobal);

		pwsz += gc_cchszTSGlobal;

		memcpy(pwsz,
			   pwszInstanceName,
			   sizeof(WCHAR) * cchInstanceName);

		pwsz += cchInstanceName;

		memcpy(pwsz,
			   pwszBindingExtension,
			   sizeof(WCHAR) * cchBindingExtension);

		pwsz += cchBindingExtension;

		*pwsz = L'\0';
	}

    hmtx = CreateMutexW(lpMutexAttributes,
						fInitiallyOwn,
						wszBindingName);

Exit:
    return hmtx;
}


/*$--BindToSharedMemory=====================================================*\

  pwszInstanceName & pwszBindingExtension:concatenated to form the name that the
                                          file mapping will be created with.
  cbSize:                                 The size of the mapping/view.
  ppvFileView:                            The virtual address of the shared mem.
  pfCreatedMapping:                       Did we create this mapping?
  lpFileMappingAttributes:                Passed into CreateFileMappin() call

\*==========================================================================*/

HANDLE
BindToSharedMemory(IN  LPCWSTR                 pwszInstanceName,
                   IN  LPCWSTR                 pwszBindingExtension,
                   IN  DWORD                   cbSize,
                   OUT PVOID                 * ppvFileView,
                   OUT BOOL                  * pfCreatedMapping,
                   IN  LPSECURITY_ATTRIBUTES   lpFileMappingAttributes)
{
    Assert(pwszInstanceName);
    Assert(pwszBindingExtension);
    Assert(ppvFileView);

    HANDLE hReturn     = NULL;
    DWORD  dwLastError = 0;
    WCHAR  wszBindingName[MAX_PATH+1];
	SECURITY_DESCRIPTOR sd;
	SECURITY_ATTRIBUTES sa;
	UINT cchInstanceName = static_cast<UINT>(wcslen(pwszInstanceName));
	UINT cchBindingExtension = static_cast<UINT>(wcslen(pwszBindingExtension));
	
	if (lpFileMappingAttributes == NULL)
	{
		//	Initialize the security descriptor with completely open access
		//
		//$HACK	- Special case for HTTPEXT
		//
		//	To meet C2 security requirements, we cannot have any completely
		//	open objects.  Fortunately, HTTPEXT only uses this code for its
		//	perf counters which are both generated and gathered in the same
		//	process (W3SVC) and same security context (local system).  Access
		//	can thus be left to the default (local system or admin only).
		//
		if (pwszInstanceName != wcsstr(pwszInstanceName, L"HTTPEXT"))
		{
			InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
			SetSecurityDescriptorDacl (&sd, TRUE, NULL, FALSE);
			sa.nLength = sizeof(SECURITY_ATTRIBUTES);
			sa.lpSecurityDescriptor = &sd;
			sa.bInheritHandle = TRUE;

			lpFileMappingAttributes = &sa;
		}
	}

    *ppvFileView = NULL;

    //
    // Check to make sure we're not going to overrun our character buffer.
    //
	if (cchInstanceName +
		cchBindingExtension +
		gc_cchszTSGlobal >= MAX_PATH)
    {
        hReturn = NULL;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

	//
	//	Create the file mapping.
	//
	//	Raid 137862
	//	The mutex must be named so that it will reside
	//	in the Global Kernel Object Name Space in order to be visible from
	//	a Terminal Services client.
	//
	{
		LPWSTR pwsz = wszBindingName;

		memcpy(pwsz,
			   gc_wszTSGlobal,
			   sizeof(WCHAR) * gc_cchszTSGlobal);

		pwsz += gc_cchszTSGlobal;

		memcpy(pwsz,
			   pwszInstanceName,
			   sizeof(WCHAR) * cchInstanceName);

		pwsz += cchInstanceName;

		memcpy(pwsz,
			   pwszBindingExtension,
			   sizeof(WCHAR) * cchBindingExtension);

		pwsz += cchBindingExtension;

		*pwsz = L'\0';
	}

    hReturn = CreateFileMappingW(INVALID_HANDLE_VALUE,			// Use swap file
								 lpFileMappingAttributes,
								 PAGE_READWRITE | SEC_COMMIT,
								 0,								// dwMaximumSizeHigh
								 cbSize,						// dwMaximumSizeLow
								 wszBindingName);
	if (NULL == hReturn)
		goto Exit;

    //
    // Determine if we created the mapping (as opposed to it already existing)
    //
    if (pfCreatedMapping)
        *pfCreatedMapping = GetLastError() != ERROR_ALREADY_EXISTS;

    if (*pfCreatedMapping)
    {
        // Must save the shared memory handle so the memory will not go away when
		// the DAV process are all shutdown.
		//
		IMPLSTUB::SaveHandle(hReturn);   
    }

    //
    // Map the file mapping into our virtual address space
    //
    *ppvFileView = MapViewOfFile(hReturn,
                                 FILE_MAP_ALL_ACCESS,
                                 0, // dwFileOffsetHigh
                                 0, // dwFileOffsetLow
                                 cbSize);

Exit:
    if (*ppvFileView == NULL)
    {
        dwLastError = GetLastError(); // preserve LastError
        if (hReturn)
            CloseHandle(hReturn);
        hReturn = NULL;
        SetLastError(dwLastError);    // restore LastError
    }

    return hReturn;
}


/*$--FAcquireMutex==========================================================*\

  This returns only after either acquiring the mutex or an error occuring.
  If it returns FALSE, an error occurred and GetLastError() can be used to
    get more information.

\*==========================================================================*/

BOOL
FAcquireMutex(IN HANDLE hmtx)
{
    DWORD dwWait = 0;

    dwWait = WaitForSingleObject(hmtx, INFINITE);
    if ((WAIT_ABANDONED_0 == dwWait) || (WAIT_OBJECT_0 == dwWait))
        return TRUE;
    else
        return FALSE;
}



/*$--FReleaseMutex==========================================================*\

  Provides symmetry with above FAcquireMutex().

\*==========================================================================*/

BOOL
FReleaseMutex(IN HANDLE hmtx)
{
    return ReleaseMutex(hmtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_shmem.h ===
/*==========================================================================*\

    Module:        _shmem.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Precompiled header file for SHMEM library

\*==========================================================================*/

#ifndef ___SHMEM_H__
#define ___SHMEM_H__

#include <windows.h>

#include <caldbg.h>

#include <smh.h>
#include <spinlock.h>
#include "_smqutil.h"
#include "_rdwrlck.h"
#include "_smseg.h"
#include "_smblckh.h"
#include "_smheap.h"

#endif // ___SHMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_smblckh.h ===
/*==========================================================================*\

    Module:        _smblckh.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  This is used to maintain several shared memory segments (SMSs)
                   for a given size of memory block.

    Known Issues:  There's currently no way to free unused segments.

\*==========================================================================*/


#ifndef ___SMBLCKH_H__
#define ___SMBLCKH_H__

#pragma warning(disable:4511)   // Copy constructor could not be generated
#pragma warning(disable:4512)   // assignment operator could not be generated
#pragma warning(disable:4710)   // function 'X' not expanded

const DWORD INITIAL_SMS_ARRAY_SIZE = 16;


/*$--CSharedMemoryBlockHeap=================================================*\

  This class represents a heap for a given size of block.  The block must
    be a power of 2 in size.  Sizes supported range from 16 bytes to 32K bytes.

\*==========================================================================*/

class CSharedMemoryBlockHeap
{
public:
    CSharedMemoryBlockHeap();
    ~CSharedMemoryBlockHeap();
    
    BOOL FInitialize(IN LPCWSTR pwszInstanceName,
                     IN DWORD   cbBlockSize);
    
    void Deinitialize();

    void Free(IN SHMEMHANDLE hSMBA);

    PVOID PvAlloc(OUT SHMEMHANDLE * phSMBA);
    
    PVOID PvFromSMBA(IN SHMEMHANDLE hSMBA);
        
    FreeList * FreeListFromSegmentId(IN DWORD   dwSegmentId,
                                     IN BYTE  * pbMappedView);
    
private:

    BOOL FGrowHeap(IN DWORD cCurrentSegments);
    
    //
    //  This is the size of block that this block heap works with.
    //
    DWORD                   m_cbBlockSize;
    
    //
    //  This is a hint to find the first free block.  If it's not correct
    //    it's not a big deal.  Shared memory segments (SMSs) are searched
    //    beginning with this segment.
    //
    volatile DWORD          m_iSMSFirstFree;

    //
    // This mutex is needed to initialized a new SMS.  It prevents another
    //   process from initializing an other SMS possibly the same one at the
    //   same time.
    //
    HANDLE                  m_hmtxGrow;
    
    //
    // m_rwl protects: m_cSMSMac, m_cSMS, and m_rgpSMS
    // Accessing the SMS array requires a read lock.
    // Growing the SMS array requires a write lock.
    //
    CReadWriteLock          m_rwl;
    
    //
    // These vars keep track of the state of the SMS array.
    //
    DWORD                   m_cSMSMac;   // maximum allocated slots
    volatile DWORD          m_cSMS;      // current count of valid SMS pointers(slots)
                                         // This is also the number of SegmentIds
                                         // The Max valid SegmentID is (m_cSMS-1)
    CSharedMemorySegment ** m_rgpSMS;    // array of SMS pointers.

    //
    // We record the instance name so we can form the SMS names when we need to
    //   grow this heap.
    //
    WCHAR                   m_wszInstanceName[MAX_PATH];
    
    //
    // We don't want anyone copying this around.
    //
    CSharedMemoryBlockHeap& operator=(const CSharedMemoryBlockHeap&);
    CSharedMemoryBlockHeap(const CSharedMemoryBlockHeap&);
};


#endif // ___SMBLCKH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_smseg.h ===
/*==========================================================================*\

    Module:        _smseg.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  The Shared Memory Segment or SMS.
                   There's one of these for each file mapping and view.
                   Each file mapping and view is 64KB in size.

\*==========================================================================*/

#ifndef ___SMSEG_H__
#define ___SMSEG_H__

//
//  SharedMemoryBlockAddress (SMBA) bit assignments:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------------------------------+-----------------------+-------+
//  |      Shared Memory Segment #  |     Segment Offset    | BlkSz |
//  +-------------------------------+-----------------------+-------+
//
//  where
//
//      Shared Memory Segment # - used to find the named shared memory segment
// 
//      Segment Offset - Mask off these bits to get the offset into the segment
//                       for the block.
//
//      BlkSz - Block Size == (1 << BlkSz)
//
// The Shared Memory Segment #, the BlkSz, and the instance name uniquely identify
//   a share memory segment.
// 
// An SMBA handle with a value of NULL means what you'd generally expect it to mean.
//


//
// Some Utility functions
//

/*$--SegmentOffsetFromSMBA==================================================*\

  Given an SMBA handle, returns offset into the segment to get the virtual
  address of the block referred to by the handle.

\*==========================================================================*/

inline
DWORD
SegmentOffsetFromSMBA(IN SHMEMHANDLE hSMBA)
{
    return (DWORD)hSMBA & 0x0000fff0;
}


/*$--FBlkSzFromSMBA=========================================================*\

  Given an SMBA handle, returns the bit number that detemines the block size
  of the block of memory referred to by the handle.  The bit number is used to
  determine how many bits a 1 is shifted to the left to get the block size.

\*==========================================================================*/

inline
DWORD
FBlkSzFromSMBA(IN SHMEMHANDLE hSMBA)
{
    return (DWORD)hSMBA & 0x0000000f;
}


/*$--SegmentIdFromSMBA======================================================*\

  Given an SMBA handle, returns the Segment ID for the block of memory referred
  to by the handle.

\*==========================================================================*/

inline
DWORD
SegmentIdFromSMBA(IN SHMEMHANDLE hSMBA)
{
    return ((DWORD)hSMBA >> 16);
}


/*$--MakeSMBA===============================================================*\

  Composes an SMBA handle given the components that make up an SMBA handle.

\*==========================================================================*/

inline
SHMEMHANDLE
MakeSMBA(IN DWORD dwSegmentId,
         IN DWORD dwSegmentOffset,
         IN DWORD fBlkSz)
{
    Assert(!(dwSegmentId & 0xffff0000));
    Assert(!(dwSegmentOffset & 0xffff000f));
    Assert(!(fBlkSz & 0xfffffff0));
    
    return (SHMEMHANDLE)((dwSegmentId << 16) | dwSegmentOffset | fBlkSz);
}


//
//  The following is the size of the smallest chunk of virtual address space that
//  can be reserved.  Making it smaller than this wastes virtual address space.
//  Making it larger than this reduces the chance of successfully getting the 
//  address space if the virtual address space of the process is fragmented.
//
const DWORD SMH_SEGMENT_SIZE = 64 * 1024;


//
// The FREE_LIST_HANDLE is composed of two values.
// The high order 13 bits is the offset into the segment for the next free block
// The low order 19 bits is the operation sequence number and is incremented
//   each time an element is removed from the list.
//
// Without using a sequence number it's possible for another thread (or threads)
// to change the list in some way and still have the next free block be the same
// one that was there when you checked it.  Although it's still possible that
// this may happen with a sequence number, it would require 524288 allocates
// and the same free block offset in the flhFirstFree member between
// when we first copy the flhFirstFree member and when we attempt to update it.
//
// When adding (pushing) something onto this list (freeing), incrementing the
//   sequence isn't necessary because you don't care if the list changed.  All
//   you care about is that the same element is on the top of the list because
//   this is how your setting the "next" link in the element that you're freeing.
//

typedef DWORD FREE_LIST_HANDLE;
const DWORD BLOCK_OFFSET_NULL      = 0x0000fff8;
const DWORD FLH_BLOCK_OFFSET_SHIFT = 16;
const DWORD FLH_BLOCK_OFFSET_MASK  = 0xfff80000;
const DWORD FLH_SEQUENCE_MASK      = 0x0007ffff;


/*$--FreeList===============================================================*\

  There's one of these for each Shared Memory Segment (SMS).  This structure
  may be expanded to facilitate debugging or timestamping last accesses to
  facilitate freeing segments that haven't been used recently.

\*==========================================================================*/

struct FreeList
{
    volatile FREE_LIST_HANDLE flhFirstFree;
};


class CSharedMemoryBlockHeap;


/*$--CSharedMemorySegment===================================================*\

\*==========================================================================*/
class CSharedMemorySegment : public CSMBase
{
public:
    CSharedMemorySegment(IN CSharedMemoryBlockHeap * psmbh);
    ~CSharedMemorySegment();
    
    BOOL FInitialize(IN LPCWSTR pwszInstanceName,
                     IN DWORD   cbBlockSize,
                     IN DWORD   dwSegmentId);
    
    void Deinitialize();
    
    void InitializeBlocks();
    
    void Free(IN SHMEMHANDLE hSMBA);
    
    PVOID PvAlloc(OUT SHMEMHANDLE * phSMBA);
    
    PVOID PvFromSMBA(IN SHMEMHANDLE hSMBA);

    //
    // CSharedMemoryBlockHeap needs to get to m_pbMappedView so that it can
    // calculate the virtual address of the freelist for other SMSs.
    //
    BYTE * PbGetMappedView() { return m_pbMappedView; };
    
private:

    BOOL FIsValidSMBA(IN SHMEMHANDLE hSMBA);

    DWORD IndexFromOffset(IN DWORD cbOffset);
    
    //
    // This points to the FreeList for this SMS.
    //
    FreeList * m_pfl;

    //
    // The usual byprodcuts of creating and mapping a file view.
    //
    HANDLE   m_hFileMapping;
    BYTE   * m_pbMappedView;

    //
    //  These are kept around for convenience after Initialization
    //
    DWORD    m_dwSegmentId;
    DWORD    m_cbBlockSize;
    DWORD    m_fBlkSz;
    
    //
    //  This lets us find out way back to the block heap that owns us.
    //
    CSharedMemoryBlockHeap * m_psmbh;
    
    //
    // We want anyone copying this around.
    //
    CSharedMemorySegment& operator=(const CSharedMemorySegment&);
    CSharedMemorySegment(const CSharedMemorySegment&);
};


/*$--CSharedMemorySegment::IndexFromOffset==================================*\

  Given a block offset, calculate the index for the bit vector that represents
  this block.

\*==========================================================================*/

inline
DWORD
CSharedMemorySegment::IndexFromOffset(IN DWORD cbOffset)
{
    return cbOffset >> m_fBlkSz;
}

/*$--CSharedMemorySegment::PvFromSMBA=======================================*\

  This calculates the virtual address for a block given its SMBA handle.
  A side effect of this call is that the block is marked as owned.

\*==========================================================================*/

inline
PVOID
CSharedMemorySegment::PvFromSMBA(IN SHMEMHANDLE hSMBA)
{
    Assert(FIsValidSMBA(hSMBA));
        
    return (!hSMBA ? NULL : (PVOID)(SegmentOffsetFromSMBA(hSMBA) + m_pbMappedView));
}



/*$--FreeListsPerSegment====================================================*\

  This simply calculates the number of FreeLists a segment can host.
  FreeLists are stored in the first block of memory in a segment.
  In order to save space, the several FreeLists are stored in one block.
  The means that subsequent SMSs can save the overhead of putting their FreeList
  in the same SMS that it refers to.

  See CSharedMemoryBlockHeap::FreeListFromSegmentId() to understand better how
  this works.

\*==========================================================================*/

inline
DWORD
FreeListsPerSegment(IN DWORD cbBlockSize)
{
    return cbBlockSize / sizeof(FreeList);
}


#endif // ___SMSEG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_smqutil.h ===
/*==========================================================================*\

    Module:        _smqutil.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  These are generally useful functions.

\*==========================================================================*/

#ifndef ___SMQUTIL_H__
#define ___SMQUTIL_H__

HANDLE
BindToMutex(IN LPCWSTR               pwszInstanceName,
            IN LPCWSTR               pwszBindingExtension,
            IN BOOL                  fInitiallyOwn     = FALSE,
            IN LPSECURITY_ATTRIBUTES lpMutexAttributes = NULL);

HANDLE
BindToSharedMemory(IN  LPCWSTR                 pwszInstanceName,
                   IN  LPCWSTR                 pwszBindingExtension,
                   IN  DWORD                   cbSize,
                   OUT PVOID                 * ppvFileView,
                   OUT BOOL                  * pfCreatedMapping,
                   IN  LPSECURITY_ATTRIBUTES   lpFileMappingAttributes = NULL);

BOOL FAcquireMutex(IN HANDLE hmtx);

BOOL FReleaseMutex(IN HANDLE hmtx);


//
// This array is used to quickly determine the highest set bit in a byte
//
const DWORD HighSetBitInByteMap[256] =
{
 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};



/*$--GetHighSetBit==========================================================*\

   This returns the highest set bit in a DWORD.
   It will return 0 if (dwValue == 0)

\*==========================================================================*/

inline
DWORD
GetHighSetBit(IN DWORD dwValue)
{
    if (dwValue & 0xffff0000)
    {
        if (dwValue & 0xff000000)
            return HighSetBitInByteMap[dwValue>>24] + 24;
        else
            return HighSetBitInByteMap[dwValue>>16] + 16;
    }
    else
    {
        if (dwValue & 0x0000ff00)
            return HighSetBitInByteMap[dwValue>>8] + 8;
        else
            return HighSetBitInByteMap[dwValue];
    }
}

/*$--SharedMemory===========================================================*\

  This namespace is used to define the shared memory ipc library allocators in.
  These functions are to be implemented by the component that's linking to
    this library.

\*==========================================================================*/

namespace SharedMemory  // SharedMemory
{
    PVOID __stdcall PvAllocate(IN DWORD cb);
    VOID  __stdcall Free(IN PVOID pv);
    PVOID __stdcall PvReAllocate(IN PVOID pv,
                                 IN DWORD cb);
};

/*$--CSMBase================================================================*\

  This class should be used as a base class of any class within this shared
    memory library that will be created with the new operator.
  The functions in the SharedMemory namespace are defined in shmemipc.h and
    should be implemented by the user of this library.

\*==========================================================================*/

class CSMBase
{
public:
    PVOID operator new(size_t cb) { return SharedMemory::PvAllocate(static_cast<DWORD>(cb)); };
    void  operator delete(void* pv) { SharedMemory::Free(pv); };
};

#endif // ___SMQUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\synchro.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_synchro.h>

//	========================================================================
//
//	CLASS CMRWLock
//
//	EnterRead()/LeaveRead() respectively lets a reader enter or leave
//	the lock.  If there is a writer or promotable reader in the lock,
//	entry is delayed until the writer/promotable reader leaves.
//
//	EnterWrite()/LeaveWrite() respectively lets a single writer enter
//	or leave the lock.  If there are any readers in the lock, entry
//	is delayed until they leave.  If there is another writer or a
//	promotable reader in the lock, entry is delayed until it leaves.
//
//	EnterPromote()/LeavePromote() respectively lets a single promotable
//	reader enter or leave the lock.  If there is a writer or another
//	promotable reader in the lock, entry is delayed until the
//	writer/promotable reader leaves.  Otherwise entry is immediate,
//	even if there are other (non-promotable) readers in the lock.
//	Promote() promotes the promotable reader to a writer.  If there
//	are readers in the lock, promotion is delayed until they leave.
//
//	Once a writer or promotable reader has entered the lock, it may
//	reenter the lock as a reader, writer or promotable reader without
//	delay.  A reader cannot reenter the lock as a writer or promotable.
//

//	------------------------------------------------------------------------
//
//	CMRWLock::CMRWLock()
//
CMRWLock::CMRWLock() :
   m_lcReaders(0),
   m_dwWriteLockOwner(0),
   m_dwPromoterRecursion(0)
{
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FInitialize()
//
BOOL
CMRWLock::FInitialize()
{
	return m_evtEnableReaders.FCreate( "CMRWLock::m_evtEnableReaders",
									   NULL,	// default security
									   TRUE,	// manual-reset
									   FALSE,	// initially non-signalled
									   NULL )   // unnamed

		&& m_evtEnableWriter.FCreate( "CMRWLock::m_evtEnableWriter",
									   NULL,	// default security
									   FALSE,	// auto-reset
									   FALSE,	// initially non-signalled
									   NULL );  // unnamed
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterRead()
//
void
CMRWLock::EnterRead()
{
	(void) FAcquireReadLock(TRUE); // fBlock
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterRead()
//
BOOL
CMRWLock::FTryEnterRead()
{
	return FAcquireReadLock(FALSE); // fBlock
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FAcquireReadLock()
//
BOOL
CMRWLock::FAcquireReadLock(BOOL fAllowCallToBlock)
{
	//
	//	Loop around trying to enter the lock until successful
	//
	for ( ;; )
	{
		//
		//	Poll the reader count/write lock
		//
		LONG lcReaders = m_lcReaders;

		//
		//	If the write lock is held ...
		//
		if ( lcReaders & WRITE_LOCKED )
		{
			//
			//	... check whether the writer is on this thread.
			//	If it is, then let this thread reenter the
			//	lock as a reader.  Do not update the reader
			//	count in this case.
			//
			if ( m_dwWriteLockOwner == GetCurrentThreadId() )
				break;

			//
			//	If the writer is not on this thread, then wait
			//	until the writer leaves, then re-poll the
			//	reader count/write lock and try again.
			//
			//	We only block if the caller allows us to block.  If this is
			//	a FTryEnterRead call, we return FALSE right away.
			//
			if ( fAllowCallToBlock )
			{
				m_evtEnableReaders.Wait();
			}
			else
			{
				return FALSE;
			}
		}

		//
		//	Otherwise, the write lock was not held, so
		//	try to enter the lock as a reader.  This only
		//	succeeds when no readers or writers enter or leave
		//	the lock between the time the reader count/
		//	write lock is polled above and now.  If what is in
		//	the lock has changed, the whole operation is retried
		//	until the lock state doesn't change.
		//
		else
		{
			if ( lcReaders == /*reinterpret_cast<LONG>*/(
								InterlockedCompareExchange(
									(&m_lcReaders),
									(lcReaders + 1),
									(lcReaders)))  )
#ifdef NEVER
									reinterpret_cast<PVOID *>(&m_lcReaders),
									reinterpret_cast<PVOID>(lcReaders + 1),
									reinterpret_cast<PVOID>(lcReaders)))  )
#endif // NEVER
			{
				break;
			}
		}
	}

	//	If we made it to this point, we have acquired the read lock.
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeaveRead()
//
void
CMRWLock::LeaveRead()
{
	//
	//	If the thread on which the reader is leaving also owns
	//	the write lock, then the reader leaving has no effect,
	//	as did entering.
	//
	if ( m_dwWriteLockOwner == GetCurrentThreadId() )
		return;

	//
	//	Otherwise, atomically decrement the reader count and
	//	check if a writer is waiting to enter the lock.
	//	If the reader count goes to 0 and a writer is waiting
	//	to enter the lock, then notify the writer that
	//	it is safe to enter.
	//
	if ( WRITE_LOCKED == InterlockedDecrement(&m_lcReaders) )
		m_evtEnableWriter.Set();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterWrite()
//
void
CMRWLock::EnterWrite()
{
	//
	//	A writer is just a promotable reader that promotes immediately
	//
	EnterPromote();
	Promote();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterWrite()
//
BOOL
CMRWLock::FTryEnterWrite()
{
	BOOL fSuccess;

	//
	//	Try to enter the lock as a promotable reader.
	//	Promote to a writer immediately if successful
	//	and return the status of the operation.
	//
	fSuccess = FTryEnterPromote();

	if ( fSuccess )
		Promote();

	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeaveWrite()
//
void
CMRWLock::LeaveWrite()
{
	LeavePromote();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterPromote()
//
void
CMRWLock::EnterPromote()
{
	//
	//	Grab the writer critical section to ensure that no other thread
	//	is already in the lock as a writer or promotable reader.
	//
	m_csWriter.Enter();

	//
	//	Bump the promoter recursion count
	//
	++m_dwPromoterRecursion;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterPromote()
//
BOOL
CMRWLock::FTryEnterPromote()
{
	BOOL fSuccess;

	//
	//	Try to enter the writer critical section.
	//	Bump the recursion count if successful and
	//	return the status of the operation.
	//
	fSuccess = m_csWriter.FTryEnter();

	if ( fSuccess )
		++m_dwPromoterRecursion;

	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::Promote()
//
void
CMRWLock::Promote()
{
	//
	//	If the promotable reader has already been promoted
	//	then don't promote it again
	//
	if ( GetCurrentThreadId() == m_dwWriteLockOwner )
		return;

	//
	//	Assert that no other writer owns the lock.
	//
	Assert( 0 == m_dwWriteLockOwner );
	Assert( !(m_lcReaders & WRITE_LOCKED) );

	//
	//	Claim the lock
	//
	m_dwWriteLockOwner = GetCurrentThreadId();

	//
	//	Stop readers from entering the lock
	//
	m_evtEnableReaders.Reset();

	//
	//	If there are any readers in the lock
	//	then wait for them to leave.  The InterlockedExchangeOr()
	//	is used to ensure that the test is atomic.
	//
	if ( InterlockedExchangeOr( &m_lcReaders, WRITE_LOCKED ) )
		m_evtEnableWriter.Wait();

	//
	//	Assert that the (promoted) writer is now the only thing in the lock
	//
	Assert( WRITE_LOCKED == m_lcReaders );
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeavePromote()
//
void
CMRWLock::LeavePromote()
{
	//
	//	No one should attempt to leave a promote block
	//	that they never entered.
	//
	Assert( m_dwPromoterRecursion > 0 );

	//
	//	If the promotable reader promoted to a writer
	//	then start allowing readers back into the lock
	//	once the promoter recursion count reaches 0
	//
	if ( --m_dwPromoterRecursion == 0 &&
		 GetCurrentThreadId() == m_dwWriteLockOwner )
	{
		//
		//	Clear the write flag to allow new readers
		//	to start entering the lock.
		//
		m_lcReaders = 0;

		//
		//	Unblock any threads with readers that are
		//	already waiting to enter the lock.
		//
		m_evtEnableReaders.Set();

		//
		//	Release ownership of the write lock
		//
		m_dwWriteLockOwner = 0;
	}

	//
	//	Release the writer's/promoter's critical section reference.
	//	When this the last such reference is released, a new
	//	promoter/writer may enter the lock.
	//
	m_csWriter.Leave();
}


//	========================================================================
//
//	CLASS CSharedMRWLock
//
//	Implements a simple multi-reader, single writer lock designed to
//	guard access to objects in shared memory.
//
//	Some essential differences between this class and CMRWLock are:
//
//	o	This class is intended to be instantiated in shared memory.
//		It has no data members that cannot be simultaneously accessed
//		by multiple processes.
//
//	o	When asked to lock for read or write, the lock spins if it
//		cannot complete the request immediately.  Since this can consume
//		an enourmous amount of CPU resources, CSharedMRWLock should
//		only guard resources that can be acquired very quickly.
//
//	o	It does not support reader promotion.
//
//	o	It does not support conditional entry (TryEnterXXX()).
//

//	------------------------------------------------------------------------
//
//	CSharedMRWLock::EnterRead()
//
void
CSharedMRWLock::EnterRead()
{
	LONG lcReaders;

	do
	{
		//
		//	Poll the current reader count/write lock.
		//
		lcReaders = m_lcReaders;

		//
		//	If there's a writer in the lock then wait for it to leave.
		//	Once the lock is free of writers, try adding ourselves to
		//	the lock.  We've succeeded if the value returned from the
		//	interlocked operation is the one we passed in.  Otherwise
		//	a new writer has entered the lock or other readers have
		//	entered or left.  In any case, we need to keep trying
		//	until we succeed.
		//
		//$BUG	The extra () around the call to InterlockedCompareExchange()
		//$BUG	and its parameters are necessary to workaround a bug in the
		//$BUG	NT headers for Alpha which implements the function as a
		//$BUG	#define with improper parenthization of its arguments.
		//
	}
	while ( (lcReaders & WRITE_LOCKED) ||
			(lcReaders != (InterlockedCompareExchange(
							(const_cast<LONG*>(&m_lcReaders)),
							(lcReaders + 1),
							(lcReaders) ))) );

	//
	//	Note that we CANNOT assert that the WRITE_LOCKED bit is clear
	//	here because it may not be -- a writer may have started entering
	//	the lock the very instant after we entered the lock above.
	//
}

//	------------------------------------------------------------------------
//
//	CSharedMRWLock::LeaveRead()
//
void
CSharedMRWLock::LeaveRead()
{
	//
	//	Note that we CANNOT assert that the WRITE_LOCKED bit is clear
	//	here because it may not be -- a writer may have started entering
	//	the lock at any time.
	//
	//	Assert( !(m_lcReaders & WRITE_LOCKED) );
	//

	//
	//	Drop the reader from the lock
	//
	InterlockedDecrement(const_cast<LONG*>(&m_lcReaders));
}

//	------------------------------------------------------------------------
//
//	CSharedMRWLock::EnterWrite()
//
void
CSharedMRWLock::EnterWrite()
{
	LONG lcReaders;

	do
	{
		//
		//	Poll the current reader count/write lock.
		//
		lcReaders = m_lcReaders;

		//
		//	If there's already a writer in the lock then wait for it
		//	to leave.  Once the lock is free of writers, try to signal
		//	that we're entering the lock by setting the WRITE_LOCKED flag.
		//	We've succeeded if the value returned from the interlocked
		//	operation is the one we passed in.  Otherwise a new writer has
		//	entered the lock or other readers have entered or left.
		//	In any case, we need to keep trying until we succeed.
		//
		//$BUG	The extra () around the call to InterlockedCompareExchange()
		//$BUG	and its parameters are necessary to workaround a bug in the
		//$BUG	NT headers for Alpha which implements the function as a
		//$BUG	#define with improper parenthization of its arguments.
		//
	}
	while ( (lcReaders & WRITE_LOCKED) ||
			(lcReaders != (InterlockedCompareExchange(
							(const_cast<LONG*>(&m_lcReaders)),
							(lcReaders | WRITE_LOCKED),
							(lcReaders) ))) );

	//
	//	At this point there may still be readers in the lock so
	//	wait for them to leave.  When all readers are gone the
	//	reader count part of m_lcReaders will be 0, so the entire
	//	value of m_lcReaders should just be WRITE_LOCKED.
	//
	while ( m_lcReaders != WRITE_LOCKED )
		;
}

//	------------------------------------------------------------------------
//
//	CSharedMRWLock::LeaveWrite()
//
void
CSharedMRWLock::LeaveWrite()
{
	//
	//	Here, we can assert there is a writer in the lock (us) and that
	//	there are no readers.
	//
	Assert( m_lcReaders == WRITE_LOCKED );

	//
	//	Given that, when we leave, the value for the
	//	reader count/write flag should be 0.
	//
	m_lcReaders = 0;
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	InterlockedExchangeOr()
//
//	This function performs an atomic logical OR of a value to a variable.
//	The function prevents more than one thread from using the same
//	variable simultaneously.  (Well, actually, it spins until it
//	gets a consistent result, but who's counting...)
//
//	Returns the value of the variable before the logical OR was performed
//
LONG InterlockedExchangeOr( LONG * plVariable, LONG lOrBits )
{
	//	The rather cryptic way this works is:
	//
	//	Get the instantaneous value of the variable.  Stuff it into a
	//	local variable so that it cannot be changed by another thread.
	//	Then try to replace the variable with this value OR'd together
	//	with the OR bits.  But only replace if the variable's value
	//	is still the same as the local variable.  If it isn't, then
	//	another thread must have changed the value between the two
	//	operations, so keep trying until they both succeed as if
	//	they had executed as one.  Once the operation succeeds in
	//	changing the value atomically, return  the previous value.
	//
	for ( ;; )
	{
		LONG lValue = *plVariable;

		if ( lValue == /*reinterpret_cast<LONG>*/(
							InterlockedCompareExchange(
								(plVariable),
								(lValue | lOrBits),
								(lValue))) )
#ifdef NEVER
								reinterpret_cast<PVOID *>(plVariable),
								reinterpret_cast<PVOID>(lValue | lOrBits),
								reinterpret_cast<PVOID>(lValue))) )
#endif // NEVER
			return lValue;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\_synchro.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_SYNCHRO.H
//
//		SYNCHRO precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_synchro.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_shmem\_smheap.h ===
/*==========================================================================*\

    Module:        _smheap.h

    Copyright Microsoft Corporation 1997, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  

\*==========================================================================*/

#ifndef ___SMHEAP_H__
#define ___SMHEAP_H__

const DWORD SMH_MIN_HEAP_BLKSZ = 4;  // 16 bytes
const DWORD SMH_MAX_HEAP_BLKSZ = 15; // 32k bytes


/*$--CSharedMemoryHeap======================================================*\

  This class is mostly a shell that directs the calls to the correct
    CSharedMemoryBlockHeap instance.

\*==========================================================================*/

class CSharedMemoryHeap
{
public:
    CSharedMemoryHeap() {};
    ~CSharedMemoryHeap();
    
    BOOL FInitialize(IN LPCWSTR pwszInstanceName);
    
    void Deinitialize();
    
    PVOID PvAlloc(IN  DWORD    cbData,
                  OUT SHMEMHANDLE * phSMBA);
    
    void  Free(IN SHMEMHANDLE hSMBA);

    PVOID PvFromSMBA(IN SHMEMHANDLE hSMBA);
    
private:
    
    CSharedMemoryBlockHeap m_rgsmbh[SMH_MAX_HEAP_BLKSZ - SMH_MIN_HEAP_BLKSZ + 1];

    
    //
    // We want anyone copying this around.
    //
    CSharedMemoryHeap& operator=(const CSharedMemoryHeap&);
    CSharedMemoryHeap(const CSharedMemoryHeap&);
};



/*$--CSharedMemoryHeap::Free================================================*\

  Determine which block heap the handle refers to and direct the call to that
    block heap.

\*==========================================================================*/

inline
void
CSharedMemoryHeap::Free(IN SHMEMHANDLE hSMBA)
{
    DWORD fBlkSz = FBlkSzFromSMBA(hSMBA);
    
    Assert((fBlkSz <= SMH_MAX_HEAP_BLKSZ) && (fBlkSz >= SMH_MIN_HEAP_BLKSZ));
    
    m_rgsmbh[fBlkSz-SMH_MIN_HEAP_BLKSZ].Free(hSMBA);
}


/*$--CSharedMemoryHeap::PvFromSMBA==========================================*\

  Determine which block heap the handle refers to and direct the call to that
    block heap.

\*==========================================================================*/

inline
PVOID
CSharedMemoryHeap::PvFromSMBA(IN SHMEMHANDLE hSMBA)
{
    DWORD fBlkSz = FBlkSzFromSMBA(hSMBA);
    
    Assert((fBlkSz <= SMH_MAX_HEAP_BLKSZ) && (fBlkSz >= SMH_MIN_HEAP_BLKSZ));
    
    return m_rgsmbh[fBlkSz-SMH_MIN_HEAP_BLKSZ].PvFromSMBA(hSMBA);
}


#endif // ___SMHEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\cvroot.cpp ===
/*
 *	C V R O O T . C P P
 *
 *	Cached vroot information
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <_vroot.h>

DEC_CONST WCHAR gc_wszPort80[]	= L":80";
DEC_CONST UINT gc_cchPort80		= CchConstString(gc_wszPort80);
DEC_CONST WCHAR gc_wszPort443[]	= L":443";
DEC_CONST UINT gc_cchPort443	= CchConstString(gc_wszPort443);


//	CVRoot --------------------------------------------------------------------
//
CVRoot::CVRoot(
	/* [in] */ LPCWSTR pwszMetaUrl,
	/* [in] */ LPCWSTR pwszVrUrl,
	/* [in] */ UINT cchServerDefault,
	/* [in] */ LPCWSTR pwszServerDefault,
	/* [in] */ IMDData* pMDData ) :
	m_pMDData(pMDData),
	m_pwszMbPath(m_sb.AppendWithNull(pwszMetaUrl)),
	m_pwszVRoot(m_sb.AppendWithNull(pwszVrUrl)),
	m_cchVRoot(static_cast<UINT>(wcslen(pwszVrUrl))),
	m_pwszServer(pwszServerDefault), // Static from CChildVRCache
	m_cchServer(cchServerDefault),
	m_pwszPort(gc_wszPort80),
	m_cchPort(gc_cchPort80),
	m_fSecure(FALSE),
	m_fDefaultPort(TRUE)
{
	LPCWSTR pwsz;
	LPCWSTR pwszPort;

	//	Make a wide copy of the physical path
	//
	Assert (pMDData->PwszVRPath());
	pwsz =  pMDData->PwszVRPath();
	m_cchVRPath = static_cast<UINT>(wcslen(pwsz));
	m_pwszVRPath = static_cast<LPWSTR>(g_heap.Alloc(CbSizeWsz(m_cchVRPath)));
	memcpy(m_pwszVRPath, pwsz, CbSizeWsz(m_cchVRPath));

	//	Process the server information out of the server bindings
	//
	if (NULL != (pwsz = pMDData->PwszBindings()))
	{
		Assert (pwsz);
		pwszPort = wcschr (pwsz, L':');

		//	If there was no leading server name, then get the default
		//	server name for the machine
		//
		if (pwsz != pwszPort)
		{
			//	A specific name was specified, so use that instead of
			//	the default
			//
			m_cchServer = static_cast<UINT>(pwszPort - pwsz);
			m_pwszServer = pwsz;
		}

		//	For the port, trim off the trailing ":xxx"
		//
		if (NULL != (pwsz = wcschr (pwszPort + 1, L':')))
		{
			m_cchPort = static_cast<UINT>(pwsz - pwszPort);
			m_pwszPort = pwszPort;

			if ((gc_cchPort80 != m_cchPort) ||
				wcsncmp (m_pwszPort,
						 gc_wszPort80,
						 gc_cchPort80))
			{
				m_fDefaultPort = FALSE;
			}

			if ((gc_cchPort443 == m_cchPort) &&
				!wcsncmp (m_pwszPort,
						  gc_wszPort443,
						  gc_cchPort443))
			{
				m_fSecure = TRUE;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\_synchro.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_SYNCHRO.H
//
//		SYNCHRO precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __SYNCHRO_H_
#define __SYNCHRO_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>

//	_SYNCHRO headers
//
#include <synchro.h> // Synchronization interfaces

#endif // !defined(__SYNCHRO_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\_vroot.h ===
/*
 *	_ V R O O T . H
 *
 *	vroot lookup precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)

//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <ocidl.h>
#include <lm.h>


#include <caldbg.h>
#include <calrc.h>
#include <calpc.h>
#include <except.h>
#include <autoptr.h>
#include <buffer.h>
#include <gencache.h>
#include <sz.h>
#include <davimpl.h>
#include <davmb.h>
#include <vrenum.h>
#include <sz.h>

#define CElems(_rg)		(sizeof(_rg)/sizeof(_rg[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_thrdpl\thrdpool.cpp ===
/*
 *	T H R D P O O L . C P P
 *
 *	DAV Thread pool implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)	/* unexpanded virtual function */

#include <windows.h>
#include <thrdpool.h>
#include <except.h>
#include <caldbg.h>
#include <perfctrs.h>
#include <profile.h>
#include <ex\idlethrd.h>

//	CDavWorkerThread ----------------------------------------------------------
//
class CDavWorkerThread
{
private:

	//	Owning thread pool
	//
	CPoolManager&	m_cpm;

	//	Handle to completion port
	//
	HANDLE			m_hCompletionPort;

	//	Handle to worker thread
	//
	HANDLE			m_hThread;

	//	Shutdown event
	//
	HANDLE			m_hShutdownEvent;

	//	Block on GetQueuedCompletionStatus for work items
	//
	VOID GetWorkCompletion(VOID);

	//	Thread function
	//
	static DWORD __stdcall ThreadDispatcher(PVOID pvWorkerThread);

	//	NOT IMPLEMENTED
	//
	CDavWorkerThread(const CDavWorkerThread& p);
	CDavWorkerThread& operator=(const CDavWorkerThread& p);

public:

	explicit CDavWorkerThread (CPoolManager& cpm, HANDLE h);
	virtual ~CDavWorkerThread();

	//	Expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }
	BOOL ShutdownThread() { return SetEvent (m_hShutdownEvent); }

	//	Expose the thread handle
	//
	HANDLE QueryThread() { return m_hThread; }
};

//	CDavWorkerThread ----------------------------------------------------------
//
CDavWorkerThread::CDavWorkerThread (CPoolManager& cpm, HANDLE h)
	: m_cpm(cpm),
	  m_hCompletionPort(h),
	  m_hThread(0),
	  m_hShutdownEvent(0)
{
	DWORD dwThreadId;

	//	Create shutdown event
	//
	m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hShutdownEvent == NULL)
	{
		DebugTrace ("Dav: WorkerThread: failed to create shutdown event: %ld", GetLastError());
		return;
	}

	//	Create worker thread
	//
	m_hThread = CreateThread (NULL,
							  0,
							  ThreadDispatcher,
							  this,
							  CREATE_SUSPENDED,
							  &dwThreadId);
	if (m_hThread == NULL)
	{
		DebugTrace ("Dav: WorkerThread: failed to create thread: %ld", GetLastError());
		return;
	}
	ResumeThread (m_hThread);

	return;
}

CDavWorkerThread::~CDavWorkerThread()
{
	CloseHandle (m_hThread);
	CloseHandle (m_hShutdownEvent);
}

DWORD __stdcall
CDavWorkerThread::ThreadDispatcher (PVOID pvWorkerThread)
{
	//	Get pointer to this CWorkerThread object
	//
	CDavWorkerThread * pwt = reinterpret_cast<CDavWorkerThread *>(pvWorkerThread);

	//
	//	Run the thread until we're done -- i.e. until GetWorkCompletion() returns
	//	normally.  Note that I say 'normally' here.  If an exception is thrown
	//	anywhere below GetWorkCompletion(), catch it, deal with it, and continue
	//	execution.  Don't let the thread die off.
	//
	for ( ;; )
	{
		try
		{
			//
			//	Install our Win32 exception handler for the lifetime of the thread
			//
			CWin32ExceptionHandler win32ExceptionHandler;

			//	If GetWorkCompletion() ever returns normally
			//	we're done.
			//
			pwt->GetWorkCompletion();
			return 0;
		}
		catch ( CDAVException& )
		{
		}
	}
}

VOID
CDavWorkerThread::GetWorkCompletion (void)
{
	Assert (m_hThread);
	Assert (m_hCompletionPort);

	do
	{
		CDavWorkContext * pwc = NULL;
		DWORD dwBytesTransferred;
		LPOVERLAPPED po;
		DWORD dwLastError = ERROR_SUCCESS;

		//	Wait for work items to be queued.  Note that since we are using
		//	the lpOverlapped structure, a return value of 0 from
		//	GetQueuedCompletionStatus() does not mean the function failed.
		//	It means the async I/O whose status is being returned failed.
		//	We need to make the error information available to the context
		//	so that it can do the appropriate thing.
		//
		//	From the MSDN documentation:
		//
		//	"If *lpOverlapped is not NULL and the function dequeues a completion
		//	 packet for a failed I/O operation from the completion port,
		//	 the return value is zero. The function stores information in the
		//	 variables pointed to by lpNumberOfBytesTransferred, lpCompletionKey,
		//	 and lpOverlapped. To get extended error information, call GetLastError."
		//
		if ( !GetQueuedCompletionStatus (m_hCompletionPort,
										 &dwBytesTransferred,
										 reinterpret_cast<PULONG_PTR>(&pwc),
										 &po,
										 INFINITE) )
		{
			dwLastError = GetLastError();
			// Do NOT break; See above comment.
		}

		//	Check for termination packet
		//
		if (!pwc)
		{
			DebugTrace ("Dav: WorkerThread: received termination packet\n");
			break;
		}

		//	Check for termination signal.
		//
		if (WAIT_TIMEOUT != WaitForSingleObject (m_hShutdownEvent, 0))
		{
			DebugTrace ("Dav: WorkerThread: shutdown has been signaled\n");
			break;
		}

		// Record the completion status data.
		//
		pwc->SetCompletionStatusData(dwBytesTransferred, dwLastError, po);

		//	Execute the work context.
		//
//		DebugTrace ("Dav: WorkerThread: calling DwDoWork()\n"); // NOISY debug trace! -- should be tagged
		pwc->DwDoWork();

	} while (TRUE);

	return;
}

//	CPoolManager --------------------------------------------------------------
//
BOOL
CPoolManager::FInitPool (DWORD dwConcurrency)
{
	INT i;

	//	Create the completion port
	//
	m_hCompletionPort = CreateIoCompletionPort (INVALID_HANDLE_VALUE,
												NULL,
												0,
												dwConcurrency);
	if (!m_hCompletionPort.get())
	{
		DebugTrace ("Dav: thrdpool: failed to create completion port:"
					"GetLastError is %d",
					GetLastError());
		return FALSE;
	}

	//	Create the workers
	//
	for (i = 0; i < CTHRD_WORKER; i++)
		m_rgpdwthrd[i] = new CDavWorkerThread (*this, m_hCompletionPort.get());

	return TRUE;
}

BOOL
CPoolManager::PostWork (CDavWorkContext * pWorkContext)
{
	Assert (Instance().m_hCompletionPort.get());

	//	Post the work request
	//
	if (!PostQueuedCompletionStatus (Instance().m_hCompletionPort.get(),
									 0,
									 (ULONG_PTR)pWorkContext,
									 0))
	{
		DebugTrace ("Dav: PostQCompletionStatus() failed: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}

VOID
CPoolManager::TerminateWorkers()
{
	INT i;
	INT cWorkersRunning;
	HANDLE rgh[CTHRD_WORKER];

	//	Kill all workers that are running
	//
	for (cWorkersRunning = 0, i = 0; i < CTHRD_WORKER; i++)
	{
		if ( m_rgpdwthrd[i] )
		{
			PostWork (NULL);
			rgh[cWorkersRunning++] = m_rgpdwthrd[i]->QueryThread();
		}
	}

	//	Wait for all the threads to terminate
	//
	WaitForMultipleObjects (cWorkersRunning, rgh, TRUE, INFINITE);

	//	Delete the worker objects, and close the handles
	//
	for (i = 0; i < CTHRD_WORKER; i++)
	{
		delete m_rgpdwthrd[i];
		m_rgpdwthrd[i] = 0;
	}
}

CPoolManager::~CPoolManager()
{
	TerminateWorkers();

#ifdef	DBG
	for (INT i = 0; i < CTHRD_WORKER; i++)
		Assert (m_rgpdwthrd[i] == NULL);
#endif	// DBG
}

//	CDavWorkContext -----------------------------------------------------------
//

//	CDavWorkContext::~CDavWorkContext()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class.
//
CDavWorkContext::~CDavWorkContext()
{
}

//	CIdleWorkItem -------------------------------------------------------------
//
class CIdleWorkItem : 	public IIdleThreadCallBack
{
	//
	//	Work context to post
	//
	CDavWorkContext * m_pWorkContext;

	//
	//	Time (in milliseconds) `til when the context should be posted
	//
	DWORD m_dwMsecDelay;

	//	NOT IMPLEMENTED
	//
	CIdleWorkItem(const CIdleWorkItem& );
	CIdleWorkItem& operator=(const CIdleWorkItem& );

public:
	//	CREATORS
	//
	CIdleWorkItem( CDavWorkContext * pWorkContext,
				   DWORD dwMsecDelay ) :
		m_pWorkContext(pWorkContext),
		m_dwMsecDelay(dwMsecDelay)
	{
	}

	~CIdleWorkItem() {}

	//	ACCESSORS
	//
	DWORD DwWait()
	{
		return m_dwMsecDelay;
	}

	//	MANIPULATORS
	//
	BOOL FExecute()
	{
		//
		//	Return FALSE to remove idle work item, TRUE to keep it.
		//	We want to remove the item if we successfully posted it
		//	to the work queue.  We want to keep it otherwise (and
		//	presumably attempt to repost it later...)
		//
		return !CPoolManager::PostWork( m_pWorkContext );
	}

	VOID Shutdown()
	{
		//
		//	We have no idea what the work context may be waiting for.
		//	It could be something that would hang shutdown if it
		//	doesn't get another chance to run.  So just run it.
		//
		(void) FExecute();
	}
};

BOOL
CPoolManager::PostDelayedWork (CDavWorkContext * pWorkContext,
							   DWORD dwMsecDelay)
{
	//
	//$OPT	If the delay is very short and the queue length of
	//$OPT	the worker threads is "long enough" such that the
	//$OPT	probability that it will be at least dwMsecDelay
	//$OPT	milliseconds before the work context is executed,
	//$OPT	consider putting the work context directly on the
	//$OPT	worker queues.
	//
	auto_ref_ptr<CIdleWorkItem> pIdleWorkItem(new CIdleWorkItem(pWorkContext, dwMsecDelay));

	return pIdleWorkItem.get() && ::FRegister( pIdleWorkItem.get() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\vrenum.cpp ===
/*
 *	V R E N U M . C P P
 *
 *	Virtual root enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_vroot.h"

LPCWSTR __fastcall
PwszStripMetaPrefix (LPCWSTR pwszUrl)
{
	//	All metabase virtual roots are identified by the
	//	metabase path, minus a given prefix.
	//
	//	These paths uniformly look like:
	//
	//		'/lm/w3svc/' <site number> '/root'
	//
	//	Since the <site number> is an unnamed integer, the trick to
	//	skipping this stuff is to search for '/root' in the string
	//	and then bump ahead 5 characters.
	//
	Assert (pwszUrl);
	if (NULL == (pwszUrl = wcsstr(pwszUrl, L"/root")))
		return NULL;

	return pwszUrl + 5;
}

//	CVRootCache ---------------------------------------------------------------
//
VOID
CChildVRCache::OnNotify (DWORD dwElements, MD_CHANGE_OBJECT_W pcoList[])
{
	//	Go through the list of changes and see if any scriptmap/vrpath/bindings
	//	changes have been made to the metabase.  If any have changed, then we
	//	want to invalidate the cache.
	//
	for (UINT ice = 0; ice < dwElements; ice++)
	{
		for (UINT ico = 0; ico < pcoList[ice].dwMDNumDataIDs; ico++)
		{
			//	Only invalidate if the stuff that we use to compute our
			//	values changes changes.
			//
			if ((pcoList[ice].pdwMDDataIDs[ico] == MD_SERVER_BINDINGS) ||
				(pcoList[ice].pdwMDDataIDs[ico] == MD_VR_PATH))
			{
				DebugTrace ("Dav: CVRoot: invalidating cache\n");
				Invalidate();
				return;
			}
		}
	}
}

VOID
CChildVRCache::RefreshOp(const IEcb& ecb)
{
	//	Out with the old...
	//
	m_cache.Clear();
	m_sb.Clear();

	//	... and in with the new!
	//
	(void) ScCacheVroots(ecb);
}

//	Cache construction --------------------------------------------------------
//
//	class CVirtualRootMetaOp --------------------------------------------------
//
class CVirtualRootMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	CVRCache& m_cache;

	ChainedStringBuffer<WCHAR>& m_sb;
	LPCWSTR m_pwszServerDefault;
	UINT m_cchServerDefault;

	//	non-implemented
	//
	CVirtualRootMetaOp& operator=( const CVirtualRootMetaOp& );
	CVirtualRootMetaOp( const CVirtualRootMetaOp& );

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CVirtualRootMetaOp() {}
	CVirtualRootMetaOp (const IEcb * pecb,
						LPCWSTR pwszPath,
						UINT cchServerDefault,
						LPCWSTR pwszServerDefault,
						ChainedStringBuffer<WCHAR>& sb,
						CVRCache& cache)
			: CMetaOp (pecb, pwszPath, MD_VR_PATH, STRING_METADATA, FALSE),
			  m_pwszServerDefault(pwszServerDefault),
			  m_cchServerDefault(cchServerDefault),
			  m_cache(cache),
			  m_sb(sb)
	{
	}
};

DEC_CONST WCHAR gc_wszLmW3svc[]	= L"/lm/w3svc";
DEC_CONST UINT gc_cchLmW3svc	= CchConstString(gc_wszLmW3svc);

SCODE __fastcall
CVirtualRootMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	CStackBuffer<WCHAR,MAX_PATH> wszBuf;
	LPWSTR pwsz;
	LPCWSTR pwszUrl;
	SCODE sc = S_OK;
	auto_ref_ptr<CVRoot> pvr;
	auto_ref_ptr<IMDData> pMDData;

	Assert (MD_VR_PATH == m_dwId);
	Assert (STRING_METADATA == m_dwType);

	//	If the url ends in a trailing slash, snip it...
	//
	if (L'/' == pwszMbPath[cch - 1])
		cch -= 1;

	//	Construct the full metabase path
	//
	if (NULL == wszBuf.resize(CbSizeWsz(gc_cchLmW3svc + cch)))
		return E_OUTOFMEMORY;

	memcpy (wszBuf.get(), gc_wszLmW3svc, gc_cchLmW3svc * sizeof(WCHAR));
	memcpy (wszBuf.get() + gc_cchLmW3svc, pwszMbPath, cch * sizeof(WCHAR));
	wszBuf[gc_cchLmW3svc + cch] = L'\0';

	//	Make a copy of the meta path for use as the cache
	//	key and for use by the CVRoot object.
	//
	_wcslwr (wszBuf.get());
	pwsz = m_sb.Append (CbSizeWsz(gc_cchLmW3svc + cch), wszBuf.get());

	//	Create a CVRoot object and cache it.  First get the metadata
	//	associated with this path and then construct the CVRoot out
	//	of that.
	//
	sc = HrMDGetData (*m_pecb, pwsz, pwsz, pMDData.load());
	if (FAILED (sc))
		goto ret;

	if (NULL != (pwszUrl = PwszStripMetaPrefix (pwsz)))
	{
		//$ RAID:304272:  There is a stress app/case where roots
		//	are being created that have no vrpath.
		//
		if (NULL != pMDData->PwszVRPath())
		{
			//	Construct the virtual root object
			//
			pvr = new CVRoot (pwsz,
							  pwszUrl,
							  m_cchServerDefault,
							  m_pwszServerDefault,
							  pMDData.get());

			DebugTrace ("Dav: CVRoot: caching vroot\n"
						" MetaPath: %S\n"
						" VrPath: %S\n"
						" Bindings: %S\n",
						pwsz,
						pMDData->PwszVRPath(),
						pMDData->PwszBindings());

			m_cache.FSet (CRCWsz(pwsz), pvr);
		}
		//
		//$	RAID:304272: end
	}

ret:

	return sc;
}

SCODE
CChildVRCache::ScCacheVroots (const IEcb& ecb)
{
	SCODE sc = S_OK;

	CVirtualRootMetaOp vrmo(&ecb,
							gc_wszLmW3svc,
							m_cchServerDefault,
							m_wszServerDefault,
							m_sb,
							m_cache);

	//	Gather all the virtual root information
	//
	sc = vrmo.ScMetaOp();
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

//	CFindChildren -------------------------------------------------------------
//
BOOL
CChildVRCache::CFindChildren::operator()(
	/* [in] */ const CRCWsz& crcwsz,
	/* [in] */ const auto_ref_ptr<CVRoot>& arpRoot)
{
	//	If the root we are checking is a proper ancestor to the
	//	vroot we are checking, then we will want to push it onto
	//	the stack.
	//
	if (!_wcsnicmp (crcwsz.m_pwsz, m_pwsz, m_cch))
	{
		LPCWSTR pwsz = crcwsz.m_pwsz;

		//	There are two interesting cases here.
		//
		//	- The child vroot has a physical path that has
		//	  diverged from the parent's.
		//
		//	- The child vroot has a physical path that aligns
		//	  perfectly with the parent.
		//
		//	ie. "/fs" has a VrPath of "f:\fs" and "/fs/bvt" has
		//	a VrPath of "f:\fs\bvt"
		//
		//	In this latter case, needs to be handled by the
		//	piece of code that is doing the traversing.  In
		//	most cases, this done by seeing if we traverse
		//	down into a vroot, etc.
		//
		Assert (L'\0' == m_pwsz[m_cch]);
		if ((L'/' == pwsz[m_cch]) || (L'/' == pwsz[m_cch - 1]))
		{
			//	Push it on the stack
			//
			m_vrl.push_back (CSortableStrings(m_sb.AppendWithNull(pwsz)));
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\chartype.cpp ===
/*
 * CharType.cxx 1.0 6/15/98
 * 
 * Character type constants and functions
 *
 *		Copied from nt\private\inet\xml\core\util\chartype.cxx 
 *		This is the logic used by XML parser. we use it for XML emitting
 *		so that we can make sure we emit XML friendly chars.
 *
 *  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */

#include "_xml.h"

int g_anCharType[TABLE_SIZE] = { 
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\_vroot.cpp ===
/*
 *	_ V R O O T . C P P
 *
 *	vroot lookup precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_vroot.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\chartype.h ===
/*
 * CharType.h 1.0 6/15/98
 * 
 * Character type constants and functions
 *
 *		Copied from nt\private\inet\xml\core\util\chartype.hxx 
 *		This is the logic used by XML parser. we use it for XML emitting
 *		so that we can make sure we emit XML friendly chars.
 *
 *  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */
 
#ifndef _CORE_UTIL_CHARTYPE_H_
#define _CORE_UTIL_CHARTYPE_H_


//==============================================================================

static const short TABLE_SIZE = 128;

enum
{
    FWHITESPACE    = 1,
    FDIGIT         = 2,
    FLETTER        = 4,
    FMISCNAME      = 8,
    FSTARTNAME     = 16,
    FCHARDATA      = 32
};

extern int g_anCharType[TABLE_SIZE];

inline bool isLetter(WCHAR ch)
{
    return (ch >= 0x41) && IsCharAlphaW(ch);
        // isBaseChar(ch) || isIdeographic(ch);
}

inline bool isAlphaNumeric(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39) || ((ch >= 0x41) && IsCharAlphaW(ch));
        // isBaseChar(ch) || isIdeographic(ch);
}

inline bool isDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39);
}

inline bool isHexDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
}

inline bool isCombiningChar(WCHAR ch)
{
    return false;
}

inline bool isExtender(WCHAR ch)
{
    return (ch == 0xb7);
}

inline int isNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE ? (g_anCharType[ch] & (FLETTER | FDIGIT | FMISCNAME | FSTARTNAME)) :
              ( isAlphaNumeric(ch) || 
                ch == '-' ||  
                ch == '_' ||
                ch == '.' ||
                ch == ':' ||
                isCombiningChar(ch) ||
                isExtender(ch)));
}

inline int isStartNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE) ? (g_anCharType[ch] & (FLETTER | FSTARTNAME))
        : (isLetter(ch) || (ch == '_' || ch == ':'));
        
}

inline int isCharData(WCHAR ch)
{
    // it is in the valid range if it is greater than or equal to
    // 0x20, or it is white space.
    return (ch < TABLE_SIZE) ?  (g_anCharType[ch] & FCHARDATA)
        : ((ch < 0xD800 && ch >= 0x20) ||   // Section 2.2 of spec.
            (ch >= 0xE000 && ch < 0xfffe));
}

#endif _CORE_UTIL_CHARTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xatom.cpp ===
/*
 *	X A T O M . C P P
 *
 *	XML atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
#include <xatom.h>

//	CXAtomCache ---------------------------------------------------------------
//
CXAtomCache::CXAtomCache () :
   m_cache(CACHESIZE_START)
{
	//	Initialize the MRWLock
	//
	FInitialize();

	//	Initialize the cache
	//
	m_cache.FInit();
}

//	CXAtomCache::GetCachedAtom ------------------------------------------------
//
LPCWSTR
CXAtomCache::GetCachedAtom (CRCWszN& key)
{
	LPCWSTR pwszCommitted;
	LPCWSTR* ppwsz;

	//	First look to see if it is already there.
	//
	{
		CSynchronizedReadBlock (*this);
		ppwsz = m_cache.Lookup (key);
	}

	//	If it wasn't there, do our best to add it
	//
	if (NULL == ppwsz)
	{
		CSynchronizedWriteBlock (*this);

		//	There is a small window where it could
		//	have shown up, so do a second quick peek
		//
		ppwsz = m_cache.Lookup (key);
		if (NULL == ppwsz)
		{
			//	Commit the string to perm. storage
			//
			pwszCommitted = m_csb.Append (key.m_cch * sizeof(WCHAR), key.m_pwsz);

			//	Add the atom to the cache, but before it
			//	gets added, swap out the key's string pointer
			//	to the committed version.
			//
			key.m_pwsz = pwszCommitted;
			m_cache.FAdd (key, pwszCommitted);

			//	Setup for the return
			//
			ppwsz = &pwszCommitted;
		}
	}

	Assert (ppwsz);
	return *ppwsz;
}

//	CXAtomCache::CacheAtom ----------------------------------------------------
//
LPCWSTR
CXAtomCache::CacheAtom (LPCWSTR pwsz, UINT cch)
{
	Assert (pwsz);

	//	Retrieve the string from the cache
	//
	CRCWszN key(pwsz, cch);
	return Instance().GetCachedAtom (key);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\var.cpp ===
/*
 *	V A R . C P P
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	ScVariantTypeFromString()
//
//	Returns the variant type associated with a dav datatype string
//
SCODE
ScVariantTypeFromString (LPCWSTR pwszType, USHORT& vt)
{
	SCODE sc = S_OK;

	//	NULL, "string" and "uri"
	//
	if (!pwszType ||
		!_wcsicmp (pwszType, gc_wszDavType_String) ||
		!_wcsicmp (pwszType, gc_wszUri))
	{
		vt = VT_LPWSTR;
	}
	//	integer
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Int))
	{
		vt = VT_I4;
	}
	//	boolean.tf
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Boolean))
	{
		vt = VT_BOOL;
	}
	//	float (Floating/Reals)
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Float))
	{
		vt = VT_R8;
	}
	//	date.iso8601
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Date_ISO8601))
	{
		vt = VT_FILETIME;
	}
	else
	{
		DebugTrace ("ScVariantTypeFromString(): unknown type");
		vt = VT_LPWSTR;
		sc = S_OK;
	}

	return sc;
}

//	ScVariantValueFromString() ------------------------------------------------
//
//	Sets the value of a PROPVARIANT
//
SCODE
ScVariantValueFromString (PROPVARIANT& var, LPCWSTR pwszValue)
{
	SCODE sc = S_OK;

	LPWSTR pwsz;
	SYSTEMTIME st;

	switch (var.vt)
	{
		case VT_LPWSTR:

			if (pwszValue)
			{
				pwsz = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(wcslen(pwszValue))));
				if (NULL == pwsz)
				{
					DebugTrace ("ScVariantValueFromString() - CoTaskMemAlloc() failed to allocate %d bytes\n", CbSizeWsz(wcslen(pwszValue)));

					sc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
					goto ret;
				}

				wcscpy (pwsz, pwszValue);
				var.pwszVal = pwsz;
			}
			else
				var.pwszVal = NULL;

			break;

		case VT_I4:

			Assert (pwszValue);
			var.lVal = _wtoi (pwszValue);
			break;

		case VT_BOOL:

#pragma warning(disable:4310)	//	wtypes.h is broken

			Assert (pwszValue);
			if (!_wcsnicmp (pwszValue, gc_wsz1, 1))
				var.boolVal = VARIANT_TRUE;
			else if (!_wcsnicmp (pwszValue, gc_wsz0, 1))
				var.boolVal = VARIANT_FALSE;
			else
			{
				sc = E_INVALIDARG;
				goto ret;
			}
			break;

#pragma warning(default:4310)	//	wtypes.h is broken

		case VT_R8:

			Assert (pwszValue);
			var.dblVal = wcstod (pwszValue, NULL);
			break;

		case VT_FILETIME:

			Assert (pwszValue);
			if (!FGetSystimeFromDateIso8601 (pwszValue, &st))
			{
				sc = E_INVALIDARG;
				goto ret;
			}
			SystemTimeToFileTime (&st, &var.filetime);
			break;

		default:

			Assert (pwszValue);
			TrapSz ("ScVariantValueFromString() unknown type");

			sc = E_INVALIDARG;
			goto ret;
	}

ret:

	return sc;
}

//	ScEmitFromVariant() ------------------------------------------------
//
SCODE
ScEmitFromVariant (CXMLEmitter& emitter,
	CEmitterNode& enParent,
	LPCWSTR pwszTag,
	PROPVARIANT& var)
{
	CEmitterNode en;
	CStackBuffer<CHAR,110> szBuf;
	CStackBuffer<WCHAR,128> wszBuf;
	LPCWSTR	pwszType = NULL;
	LPWSTR pwszValue = NULL;
	SCODE sc = S_OK;
	SYSTEMTIME 	st;
	UINT cch;
	UINT i;
	VARIANT* pvarTrue = reinterpret_cast<VARIANT*>(&var);

	switch (var.vt)
	{
		case VT_NULL:
		case VT_EMPTY:

			break;

		case VT_BSTR:

			pwszValue = static_cast<LPWSTR>(var.bstrVal);
			break;

		case VT_LPWSTR:

			pwszValue = var.pwszVal;
			break;

		case VT_LPSTR:

			if (!var.pszVal)
				break;

			cch = static_cast<UINT>(strlen (var.pszVal));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar (CP_ACP,
									   MB_ERR_INVALID_CHARS,
									   var.pszVal,
									   cch + 1,
									   pwszValue,
									   wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}
			break;

		case VT_I1:

			pwszType = gc_wszDavType_Int;
			_itow (pvarTrue->cVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI1:

			pwszType = gc_wszDavType_Int;
			_ultow (var.bVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I2:

			pwszType = gc_wszDavType_Int;
			_itow (var.iVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI2:

			pwszType = gc_wszDavType_Int;
			_ultow (var.uiVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I4:

			pwszType = gc_wszDavType_Int;
			_ltow (var.lVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI4:

			pwszType = gc_wszDavType_Int;
			_ultow (var.ulVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I8:

			pwszType = gc_wszDavType_Int;

			//$ REVIEW: negative values of _int64 seem to have problems in
			//	the __i64tow() API.  Handle those cases ourselves by using the wrapper
			//  function Int64ToPwsz.
			//
			Int64ToPwsz (&var.hVal.QuadPart, wszBuf.get());
			//
			//$ REVIEW: end

			pwszValue = wszBuf.get();
			break;

		case VT_UI8:

			pwszType = gc_wszDavType_Int;
			_ui64tow (var.uhVal.QuadPart, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_INT:

			pwszType = gc_wszDavType_Int;
			_itow (pvarTrue->intVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UINT:

			pwszType = gc_wszDavType_Int;
			_ultow (pvarTrue->uintVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_BOOL:

			pwszType = gc_wszDavType_Boolean;
			_itow (!(VARIANT_FALSE == var.boolVal), wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_R4:
			//	_gcvt could add 8 extra chars then the number of digits asked
			//	for example -3.1415e+019, '-','.' "e+019", plus the terminating
			//	NULL doesn't count in digits asked. so we have to reserve
			//	enough space in the provided buffer. using 11 to make sure
			//	we are absolutely safe.
			//
			_gcvt (var.fltVal, szBuf.celems() - 11, szBuf.get());

			cch = static_cast<UINT>(strlen(szBuf.get()));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  szBuf.get(),
									  cch + 1,
									  wszBuf.get(),
									  wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}

			pwszType = gc_wszDavType_R4;
			break;

		case VT_R8:
			//	_gcvt could add 8 extra chars then the number of digits asked
			//	for example -3.1415e+019, '-','.' "e+019", plus the terminating
			//	NULL doesn't count in digits asked. so we have to reserve
			//	enough space in the provided buffer. using 11 to make sure
			//	we are absolutely safe.
			//
			_gcvt (var.dblVal, szBuf.celems() - 11, szBuf.get());

			cch = static_cast<UINT>(strlen(szBuf.get()));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  szBuf.get(),
									  cch + 1,
									  wszBuf.get(),
									  wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}

			pwszType = gc_wszDavType_Float;
			break;

		case VT_FILETIME:

			if (!FileTimeToSystemTime (&var.filetime, &st))
			{
				//	In case the filetime is invalid, default to zero
				//
				FILETIME ftDefault = {0};
				FileTimeToSystemTime (&ftDefault, &st);
			}
			if (!FGetDateIso8601FromSystime(&st, wszBuf.get(), wszBuf.celems()))
				return E_INVALIDARG;

			pwszType = gc_wszDavType_Date_ISO8601;
			pwszValue = wszBuf.get();
			break;

		case VT_VECTOR | VT_LPWSTR:
		{
			//	Create the emitter node;
			//
			sc = en.ScConstructNode (emitter,
									 enParent.Pxn(),
									 pwszTag,
									 NULL,
									 gc_wszDavType_Mvstring);
			if (FAILED (sc))
				goto ret;

			//	Add the values
			//
			for (i = 0; i < var.calpwstr.cElems; i++)
			{
				CEmitterNode enSub;
				sc = en.ScAddNode (gc_wszXml_V,
								   enSub,
								   var.calpwstr.pElems[i]);
				if (FAILED (sc))
					goto ret;
			}

			//	In this case we have built up the node ourselves.  We do not
			//	want to fall into recreating the node.
			//
			return S_OK;
		}

		case VT_CY:
		case VT_DATE:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
		case VT_UNKNOWN:
		case VT_DECIMAL:
		case VT_RECORD:
		case VT_BLOB:
		case VT_STREAM:
		case VT_STORAGE:
		case VT_STREAMED_OBJECT:
		case VT_STORED_OBJECT:
		case VT_BLOB_OBJECT:
		case VT_CF:
		case VT_CLSID:
		default:

			TrapSz ("ScEmitterNodeFromVariant() unknown type");
			return E_UNEXPECTED;
			break;
	}

	//	Create the emitter node
	//
	sc = en.ScConstructNode (emitter,
							 enParent.Pxn(),
							 pwszTag,
							 pwszValue,
							 pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xfind.cpp ===
/*
 *	X F I N D . C P P
 *
 *	XML push model parsing for PROPFIND requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	class CNFFind -------------------------------------------------------------
//
SCODE
CNFFind::ScCompleteAttribute (void)
{
	if (m_state == ST_ENUMLIMIT)
		m_state = ST_INENUMREPORT;
	return S_OK;
}

SCODE
CNFFind::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	switch (m_state)
	{
		case ST_PROPFIND:

			m_state = ST_NODOC;
			break;

		case ST_PROPS:
		case ST_ALLPROP:
		case ST_ALLNAMES:
		case ST_ENUMREPORT:

			m_state = ST_PROPFIND;
			break;

		case ST_INPROP:

			m_state = ST_PROPS;
			break;

		case ST_INENUMREPORT:

			m_state = ST_ENUMREPORT;
			break;

		case ST_ALLPROPFULL:

			m_state = ST_ALLPROP;
			break;

		case ST_ALLNAMESFULL:

			m_state = ST_ALLNAMES;
			break;

		case ST_ALLPROP_EXCLUDE:

			m_state = ST_ALLPROPFULL;
			break;

		case ST_ALLPROP_EXCLUDE_INPROP:

			m_state = ST_ALLPROP_EXCLUDE;
			break;

		case ST_ALLPROP_INCLUDE:

			m_state = ST_ALLPROPFULL;
			break;

		case ST_ALLPROP_INCLUDE_INPROP:

			m_state = ST_ALLPROP_INCLUDE;
			break;

	}
	return S_OK;
}

SCODE
CNFFind::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	LPCWSTR pwszTag;
	CStackBuffer<WCHAR> wsz;
	SCODE sc = S_FALSE;
	UINT cch;

	//	In the case of a PROPFIND, all the nodes that we are
	//	interested are XML_ELEMENT nodes.  Anything else can
	//	(and should) be safely ignored.
	//
	//	Returning S_FALSE signifies that we are not handling
	//	the node (and therefore its children).
	//
	if (dwType == XML_ELEMENT)
	{
		cch = ulNamespaceLen + ulLen;
		pwszTag = wsz.resize(CbSizeWsz(cch));
		if (NULL == pwszTag)
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
		wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
		*(wsz.get() + cch) = 0;

		switch (m_state)
		{
			case ST_NODOC:

				//	If this is the topmost node in a propfind request,
				//	transition to the next state.  Since there is no
				//	parent node to provide scoping, FIsTag() cannot be
				//	used here!
				//
				if (!wcscmp (pwszTag, gc_wszPropfind))
				{
					m_state = ST_PROPFIND;
					sc = S_OK;
				}
				break;

			case ST_PROPFIND:

				//	Look for our well know node types
				//
				if (FIsTag (pwszTag, gc_wszAllprop))
				{
					//	Tell the context we are interested in all
					//	properties of the given resources
					//
					sc = m_cfc.ScGetAllProps (NULL);
					if (FAILED (sc))
						goto ret;

					m_state = ST_ALLPROP;
				}
				else if (FIsTag (pwszTag, gc_wszPropname))
				{
					//	Tell the context we are interested in all
					//	property names available in the given resources
					//
					sc = m_cfc.ScGetAllNames (NULL);
					if (FAILED (sc))
						goto ret;

					m_state = ST_ALLNAMES;
				}
				else if (FIsTag (pwszTag, gc_wszProp))
				{
					m_state = ST_PROPS;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszEnumReport))
				{
					sc = m_cfc.ScEnumReport ();
					if (FAILED(sc))
						goto ret;

					m_state = ST_ENUMREPORT;
				}
				break;

			case ST_PROPS:

				//	Add the specific property to the set of properties
				//	we are interested in.
				//
				sc = m_cfc.ScAddProp (NULL, pwszTag, CFindContext::FIND_PROPLIST_INCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_INPROP;
				break;

			case ST_ENUMREPORT:

				//	Add the report to the report list
				//
				sc = m_cfc.ScSetReportName (cch, pwszTag);
				if (FAILED(sc))
					goto ret;

				if (S_OK == sc)
					m_state = ST_INENUMREPORT;
				break;

			case ST_ALLPROP:
			case ST_ALLNAMES:

				//	Look for full fidelity node
				//
				if (FIsTag (pwszTag, gc_wszFullFidelity))
				{
					//	Tell the context we are interested in all
					//	properties with full fidelity of the given
					//	resources
					//
					sc = m_cfc.ScGetFullFidelityProps ();
					if (FAILED (sc))
						goto ret;

					if (ST_ALLPROP == m_state)
					{
						m_state = ST_ALLPROPFULL;
					}
					else
					{
						m_state = ST_ALLNAMESFULL;
					}
				}

			case ST_ALLPROPFULL:

				//	for the all-props full-fidelity case, there could be
				//	two lists of props: one exclude list and one include
				//	list. Exclude list specifies the props the client is
				//	not interested in and hence need to be removed from
				//	the response. Similarly include list specifies the
				//	extra properties the client is interested in.
				//
				if (FIsTag (pwszTag, gc_wszFullFidelityExclude))
				{
					m_state = ST_ALLPROP_EXCLUDE;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszFullFidelityInclude))
				{
					m_state = ST_ALLPROP_INCLUDE;
					sc = S_OK;
				}
				break;


			case ST_ALLPROP_EXCLUDE:

				sc = m_cfc.ScAddProp (NULL,
									  pwszTag,
									  CFindContext::FIND_PROPLIST_EXCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_ALLPROP_EXCLUDE_INPROP;
				break;

			case ST_ALLPROP_INCLUDE:

				sc = m_cfc.ScAddProp (NULL,
									  pwszTag,
									  CFindContext::FIND_PROPLIST_INCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_ALLPROP_INCLUDE_INPROP;
				break;

		}
	}
	else if (dwType == XML_ATTRIBUTE)
	{
		if ((m_state == ST_INENUMREPORT) && (XML_NS != dwSubType))
		{
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			//	If this is a limit attribute, make the
			//	appropriate transition
			//
			if (!_wcsnicmp (pwszTag, gc_wszLimit, cch))
			{
				m_state = ST_ENUMLIMIT;
				sc = S_OK;
			}
		}
	}
	else if (dwType == XML_PCDATA)
	{
		if (m_state == ST_ENUMLIMIT)
			sc = m_cfc.ScSetReportLimit (ulLen, pwcText);
	}

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xmlparser_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Tue Sep 22 19:11:47 1998
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_XMLPSR = {0xd242361c,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLNodeSource = {0xd242361d,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLParser = {0xd242361e,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLNodeFactory = {0xd242361f,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const CLSID CLSID_XMLParser = {0xd2423620,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xout.cpp ===
/*
 *	X O U T . C P P
 *
 *	XML push model printing
 *
 *	This code was stolen from the XML guys and adapted for our use
 *	in owner comment processing.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	CXMLOut -------------------------------------------------------------------
//
VOID
CXMLOut::CloseElementDecl(
	/* [in] */ BOOL fEmptyNode)
{
	//	If we get a call to EndAttributesOut, and the
	//	node is empty, we want to close things up here.
	//
	if (fEmptyNode)
	{
		m_sb.Append (L"/>");
	}
	//
	//	Otherwise, we can end the attributes as if a new node is
	//	to follow.
	//
	else
		m_sb.Append (L">");

	//	Remember that they have been ended!
	//
	m_fElementNeedsClosing = FALSE;

	//	Note, we should start to emit the namespaces after the first element
	//	node is closed. The namespaces for the first node is emitter from
	//	the namespace cache
	//
	m_fAddNamespaceDecl = TRUE;
}

VOID
CXMLOut::EndAttributesOut (
	/* [in] */ DWORD dwType)
{
	//	Make sure we setup to close the element
	//
	if (XML_ELEMENT == dwType)
	{
		Assert (FALSE == m_fElementNeedsClosing);
		m_fElementNeedsClosing = TRUE;
	}
}

VOID
CXMLOut::EndChildrenOut (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	If there is an element awaiting a close...
	//
	if (m_fElementNeedsClosing)
	{
		//	... close it
		//
		CloseElementDecl (fEmptyNode);
	}

	switch (dwType)
	{
		case XML_ELEMENT:

			if (!fEmptyNode)
			{
				m_sb.Append (L"</");
				m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
				m_sb.Append (L">");
			}
			break;

		case XML_ATTRIBUTE:

			m_sb.Append (L"\"");
			break;

		case XML_XMLDECL:
		case XML_PI:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"?>");
			break;

		case XML_DOCTYPE:
		case XML_ENTITYDECL:
		case XML_PENTITYDECL:
		case XML_ELEMENTDECL:
		case XML_ATTLISTDECL:
		case XML_NOTATION:

			m_sb.Append (L">");
			break;

		case XML_GROUP:

			m_sb.Append (L")");
			break;

		case XML_INCLUDESECT:

			m_sb.Append (L"]]>");
			break;
	}
}

void
CXMLOut::CreateNodeAttrOut (
	/* [in] */ const WCHAR __RPC_FAR *pwszAttr,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	m_sb.Append (pwszAttr);
	m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
	m_sb.Append (L"\"");
}

VOID
CXMLOut::CreateNodeOut(
	/* [in] */ DWORD dwType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	If there is an element awaiting a close...
	//
	if (m_fElementNeedsClosing)
	{
		//	... close it
		//
		CloseElementDecl (FALSE);
	}

	switch (dwType)
	{
		case XML_ELEMENT:

			m_sb.Append (L"<");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ATTRIBUTE:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"=\"");
			break;

		case XML_XMLDECL:
		case XML_PI:

			m_sb.Append (L"<?");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_DOCTYPE:

			m_sb.Append (L"<!DOCTYPE ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ENTITYDECL:

			m_sb.Append (L"<!ENTITY ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_PENTITYDECL:

			m_sb.Append (L"<!ENTITY % ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ELEMENTDECL:

			m_sb.Append (L"<!ELEMENT ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ATTLISTDECL:

			m_sb.Append (L"<!ATTLIST ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_NOTATION:

			m_sb.Append (L"<!NOTATION ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_GROUP:

			m_sb.Append (L" (");
			break;

		case XML_INCLUDESECT:

			m_sb.Append (L"<![");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"[");
			break;

		case XML_IGNORESECT:

			m_sb.Append (L"<![IGNORE[");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"]]>");
			break;

		case XML_CDATA:

			m_sb.Append (L"<![CDATA[");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"]]>");
			break;

		case XML_COMMENT:

			m_sb.Append (L"<!--");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"-->");
			break;

		case XML_ENTITYREF:

			m_sb.Append (L"&");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L";");
			break;

		case XML_PEREF:

			m_sb.Append (L"%");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L";");
			break;

		case XML_SYSTEM:

			CreateNodeAttrOut (L" SYSTEM \"", pwcText, ulLen);
			break;

		case XML_PUBLIC:

			CreateNodeAttrOut (L" PUBLIC \"", pwcText, ulLen);
			break;

		case XML_NAME:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_STRING:

			CreateNodeAttrOut (L" \"", pwcText, ulLen);
			break;

		case XML_VERSION:

			CreateNodeAttrOut (L" version=\"", pwcText, ulLen);
			break;

		case XML_ENCODING:

			CreateNodeAttrOut (L" encoding=\"", pwcText, ulLen);
			break;

		case XML_NDATA:

			m_sb.Append (L" NDATA");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_PCDATA:

			//	IMPORTANT: we will get multiple calls to this for each
			//	entity element, some of which need to be escaped.  Handle
			//	that here.
			//
			//	The elements that need escaping are:
			//
			//		'&'	goes to "&amp;"
			//		'>' goes to "&gt;"
			//		'<' goes to	"&lt;"
			//		''' goes to	"&qpos;"
			//		'"' goes to "&quot;"
			//
			//	Note that in the case of attributes, only two need escaping --
			//	the latter two quote marks.  The first three are for node values.
			//	However, we are going to make some simple assumptions that should
			//	be reasonable.  If we only get a single character that matches on
			//	of the escape sequences, then escape it.
			//
			if (1 == ulLen)
			{
				switch (*pwcText)
				{
					case L'&':

						pwcText = gc_wszAmp;
						ulLen = CchConstString (gc_wszAmp);
						Assert (5 == ulLen);
						break;

					case L'>':

						pwcText = gc_wszGreaterThan;
						ulLen = CchConstString (gc_wszGreaterThan);
						Assert (4 == ulLen);
						break;

					case L'<':

						pwcText = gc_wszLessThan;
						ulLen = CchConstString (gc_wszLessThan);
						Assert (4 == ulLen);
						break;

					case L'\'':

						pwcText = gc_wszApos;
						ulLen = CchConstString (gc_wszApos);
						Assert (6 == ulLen);
						break;

					case L'"':

						pwcText = gc_wszQuote;
						ulLen = CchConstString (gc_wszQuote);
						Assert (6 == ulLen);
						break;

					default:

						//	There is no mapping required.
						//
						break;
				}
			}
			Assert (fTerminal);
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_EMPTY:
		case XML_ANY:
		case XML_MIXED:
		case XML_ATTDEF:
		case XML_AT_CDATA:
		case XML_AT_ID:
		case XML_AT_IDREF:
		case XML_AT_IDREFS:
		case XML_AT_ENTITY:
		case XML_AT_ENTITIES:
		case XML_AT_NMTOKEN:
		case XML_AT_NMTOKENS:
		case XML_AT_NOTATION:
		case XML_AT_REQUIRED:
		case XML_AT_IMPLIED:
		case XML_AT_FIXED:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_DTDSUBSET:

			//	Do nothing -- since we've already printed the DTD subset.
			//	and EndDTDSubset will print the ']' character.
			//
			break;

		default:

			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;
	}
}

//	Owner processing ----------------------------------------------------------
//
SCODE
CXMLOut::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	Close the current owner comment item
	//
	EndChildrenOut (fEmptyNode, dwType, pwcText, ulLen);

	//	Decrement the depth of the owner tree
	//
	--m_lDepth;
	XmlTrace ("Xml: Lock: Owner: decrementing depth to: %ld\n", m_lDepth);
	return S_OK;
}

SCODE
CXMLOut::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	switch (dwType)
	{
		case XML_ATTRIBUTE:

			//	If this is a namespace decl, then there is different
			//	name reconstruction that needs to happen...
			//
			if (XML_NS == dwSubType)
			{
				//	... but before we do that ...
				//
				//	There are some namespaces that should not be added
				//	to the owners comments at this time (the get added
				//	by the namespace cache emitting mechanism.  If the
				//	namespaces are to be blocked, handle this now.
				//
				//	Note that by returning S_FALSE, we will not get
				//	called for the PCDATA nodes that also apply to this
				//	namespace.
				//
				if (!m_fAddNamespaceDecl)
					return S_FALSE;

				Assert (!wcsncmp(pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns)));
				break;
			}

			//	Otherwise, fall through to the regular processing
			//

		case XML_ELEMENT:
		{
			//	OK, we are going to be real sneaky here.  The
			//	original, aliased tag is available here without
			//	having to back-lookup.  The pwcText pointer has
			//	simply been scooted forward in the text to skip
			//	over the the alias and ':'.  So, we can use the
			//	ulNsPrefixLen to scoot back and not have to do
			//	any sort of back lookup.
			//
			if (0 != ulNsPrefixLen)
			{
				//	The prefix len does not take into account the
				//	colon separator, so we have to here!
				//
				pwcText -= ulNsPrefixLen + 1;
				ulLen += ulNsPrefixLen + 1;
			}

			break;
		}
	}

	//	Acknowledge the change in owner processing
	//	depth...
	//
	if (!fTerminal)
	{
		++m_lDepth;
		XmlTrace ("CXmlOut: incrementing depth to: %ld\n", m_lDepth);
	}

	//	Build up the owner comment where appropriate
	//
	CreateNodeOut (dwType, fTerminal, pwcText, ulLen);
	return S_OK;
}

BOOL
CEmitNmspc::operator()(const CRCWszN&, const auto_ref_ptr<CNmspc>& pns)
{
	Assert (pns.get());

	//	Allocate enough space for the namespace attribute --
	//	which includes the prefix, an optional colon and an
	//	alias.
	//
	CStackBuffer<WCHAR> pwsz;
	UINT cch = pns->CchAlias() + CchConstString(gc_wszXmlns) + 1;
	if (NULL == pwsz.resize(CbSizeWsz(cch)))
		return FALSE;

	//	Copy over the prefix
	//
	wcsncpy (pwsz.get(), gc_wszXmlns, CchConstString(gc_wszXmlns));
	if (pns->CchAlias())
	{
		//	Copy over the colon and alias
		//
		pwsz[CchConstString(gc_wszXmlns)] = L':';
		wcsncpy(pwsz.get() + CchConstString(gc_wszXmlns) + 1,
				pns->PszAlias(),
				pns->CchAlias());

		//	Terminate it
		//
		pwsz[cch] = 0;
	}
	else
	{
		//	Terminate it
		//
		pwsz[CchConstString(gc_wszXmlns)] = 0;
		cch = CchConstString(gc_wszXmlns);
	}

	//	Output the namespace element.
	//
	m_xo.CreateNodeOut (XML_ATTRIBUTE, FALSE, pwsz.get(), cch);

	//	There may be some escaping that needs to happen for a namespace.
	//
	LPCWSTR pwszHref = pns->PszHref();
	LPCWSTR pwszStart = pns->PszHref();
	UINT cchHref = pns->CchHref();
	for (; pwszHref < pns->PszHref() + cchHref; pwszHref++)
	{
		if ((L'\'' == *pwszHref) ||
			(L'"' == *pwszHref) ||
		    (L'&' == *pwszHref))
		{
			//	Emit the stuff leading up to the escaped character
			//
			m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszStart, static_cast<UINT>(pwszHref - pwszStart));

			//	Escape the single character and the underlying code
			//	will do the proper escaping!
			//
			m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszHref, 1);

			//	Mark our starting point at the next character
			//
			pwszStart = pwszHref + 1;
		}
	}

	//	Finish off the namespace
	//
	m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszStart, static_cast<UINT>(pwszHref - pwszStart));
	m_xo.EndChildrenOut (FALSE, XML_ATTRIBUTE, pwsz.get(), cch);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xemit.cpp ===
/*
 *	X E M I T . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
#include <szsrc.h>

//	class CXNode - Emitting ---------------------------------------------------
//
//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
//	more info.
//
//		Unicode value    1st byte    2nd byte    3rd byte
//		000000000xxxxxxx 0xxxxxxx
//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
//
inline
VOID WideCharToUTF8Chars (WCHAR wch, BYTE * pb, UINT * pib)
{
	Assert (pb);
	Assert (pib);

	UINT	ib = *pib;

	//	single-byte: 0xxxxxxx
	//
	if (wch < 0x80)
	{
		pb[ib] = static_cast<BYTE>(wch);
	}
	//
	//	two-byte: 110xxxxx 10xxxxxx
	//
	else if (wch < 0x800)
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 6) | 0xC0);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}
	//
	//	three-byte: 1110xxxx 10xxxxxx 10xxxxxx
	//
	else
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 12) | 0xE0);
		pb[ib++] = static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}

	*pib = ib;
}

//	CXMLEmitter helper functions ----------------------------------------------
//
SCODE
ScGetPropNode (
	/* [in] */ CEmitterNode& enItem,
	/* [in] */ ULONG hsc,
	/* [out] */ CEmitterNode& enPropStat,
	/* [out] */ CEmitterNode& enProp)
{
	SCODE	sc = S_OK;

	//	<DAV:propstat> node
	//
	sc = enItem.ScAddNode (gc_wszPropstat, enPropStat);
	if (FAILED(sc))
		goto ret;

	//	<DAV:status> node
	//
	sc = ScAddStatus (&enPropStat, hsc);
	if (FAILED(sc))
		goto ret;

	//	<DAV:prop> node
	//
	sc = enPropStat.ScAddNode (gc_wszProp, enProp);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

//	CXNode helper functions ---------------------------------------------------
//
SCODE
ScSetEscapedValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch, BOOL fHandleStoragePathEscaping)
{
	SCODE	sc = S_OK;
	CStackBuffer<WCHAR>	lpwsz;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	Make sure there is always room to terminate and allocate
	//  an extra byte.
	//  NOTE:  cb is not an actual count of bytes
	//  because of this.  it does not include the NULL termination.
	//
	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	UINT ib;
	UINT iwch;
	CStackBuffer<BYTE> pb;
	if (NULL == pb.resize (cb+1))
		return E_OUTOFMEMORY;

	if (fHandleStoragePathEscaping)
	{
		// $REVIEW: this might cause a stack overflow for exceptionally
		// large values of cch!  but this branch should only be executed
		// on the case for urls, so perhaps it's not possible...
		//
		if (NULL == lpwsz.resize((cch + 1) * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		CopyMemory(lpwsz.get(), pcwsz, (cch * sizeof(WCHAR)));
		lpwsz[cch] = L'\0';

		cch = static_cast<UINT>(wcslen(lpwsz.get()));
		pcwsz = lpwsz.get();
	}

	for (iwch = 0; iwch < cch; )
	{
		auto_heap_ptr<CHAR>  pszEscaped;

		//  While there are more characters to convert
		//  and we have enough buffer space left for one UTF8 character
		//  (max of 3 bytes).  the NULL termination is not included in
		//  cb, so it is already accounted for.
		//

		for (ib = 0;
			 (ib < cb - 2) && (iwch < cch);
			 ib++, iwch++)
		{
			WideCharToUTF8Chars (pcwsz[iwch], pb.get(), &ib);
		}

		//	Terminate
		//
		pb[ib] = 0;

		//	Escape the bytes
		//
		HttpUriEscape (reinterpret_cast<LPSTR>(pb.get()), pszEscaped);
		sc = pxn->ScSetUTF8Value (pszEscaped, static_cast<UINT>(strlen(pszEscaped)));
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
ScEmitRawStoragePathValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch)
{
    return pxn->ScSetValue (pcwsz, cch);
}

//	CEmitterNode helper functions ---------------------------------------------
//
VOID __fastcall
FormatStatus (ULONG hsc, LPSTR sz, UINT cb)
{
	UINT cch = CchConstString(gc_szHTTP_1_1);

	//	Construct a status line from the HSC
	//
	memcpy (sz, gc_szHTTP_1_1, cch);

	//	Add in a space
	//
	*(sz + cch++) = ' ';

	//	Add in the HSC
	//
	_itoa (hsc, sz + cch, 10);
	Assert (cch + 3 == strlen (sz));
	cch += 3;

	//	Add in a space
	//
	*(sz + cch++) = ' ';

	//	Add the description text
	//	Note, status line is not localized
	//
	//$REVIEW: Now that status line is not localized, do we still need to go through
	//$REVIEW: CResourceStringCache ?
	//
	LpszLoadString (hsc, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), sz + cch, cb - cch);
}

SCODE __fastcall
ScAddStatus (CEmitterNode* pen, ULONG hsc)
{
	CHAR sz[MAX_PATH];
	CEmitterNode enStatus;

	FormatStatus (hsc, sz, sizeof(sz));
	return pen->ScAddMultiByteNode (gc_wszStatus, enStatus, sz);
}

SCODE __fastcall
ScAddError (CEmitterNode* pen, LPCWSTR pwszErrMsg)
{
	CEmitterNode en;
	return pen->ScAddNode (gc_wszErrorMessage, en, gc_wszErrorMessage);
}

//	class CStatusCache ------------------------------------------------------
//
BOOL
CStatusCache::EmitStatusNodeOp::operator()(
	const CHsc& key, const auto_ref_ptr<CPropNameArray>& pna )
{
	SCODE sc = S_OK;
	UINT iProp;
	CEmitterNode enPropStat;
	CEmitterNode enProp;

	sc = ScGetPropNode (m_enParent,
						key.m_hsc,
						enPropStat,
						enProp);
	//	Add prop names
	//
	for (iProp = 0; iProp < pna->CProps(); iProp++)
	{
		CEmitterNode en;

		//	Add one prop
		//
		sc = enProp.ScAddNode (pna->PwszProp(iProp), en);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc == S_OK;
}

SCODE
CStatusCache::ScAddErrorStatus (ULONG hsc, LPCWSTR pwszProp)
{
	SCODE	sc = E_OUTOFMEMORY;
	auto_ref_ptr<CPropNameArray>	pna;
	auto_ref_ptr<CPropNameArray> *	ppna = NULL;

	//	Lookup in the cache for the array for the specific hsc
	//
	ppna = m_cache.Lookup (hsc);

	//	Add a new propname array if not exist
	//
	if (!ppna)
	{
		//	Create new propname array object
		//
		pna.take_ownership (new CPropNameArray());
		if (!pna.get())
			goto ret;

		//	Add it to the cache
		//
		if (!m_cache.FAdd (hsc, pna))
			goto ret;
	}
	else
		pna = *ppna;

	//	Persist the prop name string
	//
	pwszProp = m_csbPropNames.AppendWithNull (pwszProp);
	if (!pwszProp)
		goto ret;

	//	Add it to prop name array
	//
	sc = pna->ScAddPropName (pwszProp);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CStatusCache::ScEmitErrorStatus (CEmitterNode& enParent)
{
	EmitStatusNodeOp op (enParent);

	//$REVIEW: Currently, ForEach does not return an error code
	//$REVIEW: even when it stops in the middle. we may want to
	//$REVIEW: have it return at least a boolean to allow caller
	//$REVIEW: to tell whether to continue
	//
	m_cache.ForEach(op);

	return S_OK;
}


//	Property name escaping ----------------------------------------------------
//
DEC_CONST char gc_szEscape[] = "_xnnnn";

__inline WCHAR
WchFromEscape (const LPCWSTR wsz)
{
	WCHAR wch = 0;

	if ((L'x' == *(wsz + 1)) || (L'X' == *(wsz + 1)))
	{
		//	Convert the hex value into a wchar
		//
		LPWSTR wszEnd;
		wch = static_cast<WCHAR>(wcstoul(wsz + 2, &wszEnd, 16 /* hexidecimal */));

		//	If the length of the sequence is not correct,
		//	or the terminating character was not an underscore,
		//	then we there was no escape sequence.
		//
		if (((wszEnd - wsz) != CchConstString(gc_szEscape)) || (L'_' != *wszEnd))
			wch = 0;
	}
	return wch;
}

__inline BOOL
FIsXmlAllowedChar (WCHAR wch, BOOL fFirstChar)
{
	if (fFirstChar)
		return isStartNameChar (wch);
	else
		return isNameChar (wch);
}

SCODE
ScEscapePropertyName (LPCWSTR wszProp, UINT cchProp, LPWSTR wszEscaped, UINT* pcch, BOOL fRestrictFirstCharacter)
{
	Assert (wszProp);
	Assert (wszEscaped);
	Assert (pcch);

	LPCWSTR wszStart = wszProp;
	SCODE sc = S_OK;
	UINT cch = 0;
	UINT cchLeft = cchProp;

	//  The first character of an xml prop tag has different rules
	//  regarding what is allowable (only characters and underscores
	//  are allowed).
	//
	BOOL fFirstCharOfTag = TRUE;

	//  However, if the caller doesn't want us to impose the additional
	//  restrictions on the first character, treat the first character
	//  as no different from any other.
	//
	if (!fRestrictFirstCharacter) fFirstCharOfTag = FALSE;

	while (wszProp < (wszStart + cchProp))
	{
		//	If this is a supported character in a XML tag name,
		//	copy it over now...
		//
		if (FIsXmlAllowedChar(*wszProp, fFirstCharOfTag))
		{
			//	If there is room, copy it over.
			//
			if (cch < *pcch)
				*wszEscaped = *wszProp;
		}
		//
		//	... or if the chararacter is an underscore that does not
		//	look like it preceeds an escape sequence, copy it over
		//	now...
		//
		else if ((L'_' == *wszProp) &&
				((cchLeft <= CchConstString(gc_szEscape)) ||
					(0 == WchFromEscape(wszProp))))
		{
			//	If there is room, copy it over.
			//
			if (cch < *pcch)
				*wszEscaped = *wszProp;
		}
		//
		//	... and everything else gets escaped.
		//
		else
		{
			//	Adjust the byte count as if there were room for all
			//	but one of the characters in the escape sequence.
			//
			cch += CchConstString(gc_szEscape);

			//	If there is room, insert the escape
			//	sequence.
			//
			if (cch < *pcch)
			{
				wsprintfW (wszEscaped, L"_x%04x_", *wszProp);
				wszEscaped += CchConstString(gc_szEscape);
			}
		}

		//	Account for the last character copied over
		//
		wszEscaped += 1;
		wszProp += 1;
		cch += 1;
		cchLeft--;
		fFirstCharOfTag = FALSE;
	}

	//	If there was not room to escape the whole thing, then
	//	pass back S_FALSE.
	//
	if (cch > *pcch)
		sc = S_FALSE;

	//	Tell the caller how long the result is, and return
	//
	*pcch = cch;
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xlock.cpp ===
/*
 *	X L O C K . C P P
 *
 *	XML push model parsing for LOCK requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

#include <xlock.h>
#include <statetok.h>

//	Here are our LOCK XML elements
//
const WCHAR gc_wszLockActive[]				= L"DAV:activelock";
const WCHAR gc_wszLockDepth[]				= L"DAV:depth";
const WCHAR gc_wszLockDiscovery[]			= L"DAV:lockdiscovery";
const WCHAR gc_wszLockEntry[]				= L"DAV:lockentry";
const WCHAR gc_wszLockInfo[]				= L"DAV:lockinfo";
const WCHAR gc_wszLockOwner[]				= L"DAV:owner";
const WCHAR gc_wszLockScope[]				= L"DAV:lockscope";
const WCHAR gc_wszLockScopeExclusive[]		= L"DAV:exclusive";
const WCHAR gc_wszLockScopeShared[]			= L"DAV:shared";
const WCHAR gc_wszLockSupportedlock[]		= L"DAV:supportedlock";
const WCHAR gc_wszLockTimeout[]				= L"DAV:timeout";
const WCHAR gc_wszLockToken[]				= L"DAV:locktoken";
const WCHAR gc_wszLockType[]				= L"DAV:locktype";
const WCHAR gc_wszLockTypeWrite[]			= L"DAV:write";
const WCHAR	gc_wszLockTypeCheckout[]		= L"DAV:checkout";
const WCHAR gc_wszLockTypeTransaction[]		= L"DAV:transaction";
const WCHAR gc_wszLockTypeTransactionGOP[]	= L"DAV:groupoperation";
const WCHAR	gc_wszLockScopeLocal[]			= L"DAV:local";

//	And one item from the rollback draft.
//
const WCHAR gc_wszLockRollback[]		= L"http://www.iana.org/experimental/msrollback/rollback";

//	UNLOCK xml elememts
//
const WCHAR	gc_wszUnlockInfo[]			= L"DAV:unlockinfo";
const WCHAR gc_wszCancelCheckout[]		= L"DAV:cancelcheckout";
const WCHAR	gc_wszComment[]				= L"DAV:comment";
const WCHAR	gc_wszTransactionInfo[]		= L"DAV:transactioninfo";
const WCHAR	gc_wszTransactionStatus[]	= L"DAV:transactionstatus";
const WCHAR	gc_wszCommit[]				= L"DAV:commit";
const WCHAR	gc_wszAbort[]				= L"DAV:abort";

//	class CNFLock -------------------------------------------------------------
//
SCODE
CNFLock::ScCompleteAttribute (void)
{
	//	When we have gotten here, we have started processing
	//	owner node attributes and all cached namespaces have
	//	been added.
	//
	if (m_state == ST_OWNER)
		return m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );

	return S_OK;
}

SCODE
CNFLock::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;

	//	Handle owner processing first....
	//
	if (ST_OWNER == m_state)
	{
		sc = m_xo.ScCompleteChildren (fEmptyNode,
									  dwType,
									  pwcText,
									  ulLen);
		if (FAILED (sc))
			goto ret;
	}

	//	Handle the rest...
	//
	switch (dwType)
	{
		case XML_ELEMENT:

			switch (m_state)
			{
				case ST_LOCKINFO:

					m_state = ST_NODOC;
					break;

				case ST_OWNER:

					if (0 == m_xo.LDepth())
					{
						//	Complete the owner comment buffer
						//
						m_state = ST_LOCKINFO;
						m_sbOwner.Append (sizeof(WCHAR), L"\0");
						XmlTrace ("Xml: Lock: owner XML body:\n%ws\n",
								  m_sbOwner.PContents());
					}
					break;

				case ST_TYPE:

					m_state = ST_LOCKINFO;
					break;

				case ST_INTYPE:

					m_state = ST_TYPE;
					break;

				case ST_INTYPE_TRANS:

					m_state = ST_INTYPE;
					break;

				case ST_SCOPE:

					m_state = ST_LOCKINFO;
					break;

				case ST_INSCOPE:

					m_state = ST_SCOPE;
					break;

				case ST_ROLLBACK:

					m_state = ST_LOCKINFO;
					break;
			}
	}

ret:
	return sc;
}

SCODE
CNFLock::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag = NULL;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				break;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propfind request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszLockInfo))
					{
						m_state = ST_LOCKINFO;
						sc = S_OK;
					}
					break;

				case ST_LOCKINFO:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszLockOwner))
					{
						CEmitNmspc cen(m_xo);

						//	Make the state transition and start recording
						//
						m_sbOwner.Reset();
						m_state = ST_OWNER;
						sc = m_xo.ScHandleNode (dwType,
												dwSubType,
												fTerminal,
												pwcText,
												ulLen,
												ulNamespaceLen,
												pwcNamespace,
											    ulNsPrefixLen);

						//	Spit out the namespaces.
						//
						//	Note that this will spit out any namespaces
						//	decl'd in the DAV:owner node itself.  So we
						//	do not really want to emit these out to the
						//	owners comments until ScCompleteAttribute()
						//	is called.
						//
						Assert (!m_xo.FAddNamespaceDecl());
						m_cache.ForEach(cen);
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockRollback))
					{
						m_dwRollback = DAV_LOCKTYPE_ROLLBACK;
						m_state = ST_ROLLBACK;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockType))
					{
						m_state = ST_TYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScope))
					{
						m_state = ST_SCOPE;
						sc = S_OK;
					}
					break;

				case ST_TYPE:

					if (FIsTag (pwszTag, gc_wszLockTypeWrite))
					{
						XmlTrace ("Xml: Lock: request is for a WRITE lock\n");
						m_dwLockType |= GENERIC_WRITE;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockTypeCheckout))
					{
						XmlTrace ("Xml: Lock: request is for a CHECKOUT lock\n");
						m_dwLockType |= DAV_LOCKTYPE_CHECKOUT;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockTypeTransaction))
					{
						XmlTrace ("Xml: Lock: request is for a TRANSACTION lock\n");
						m_state = ST_INTYPE_TRANS;
						sc = S_OK;
					}
#ifdef	DBG
					if (!_wcsicmp (pwszTag, L"read"))
					{
						XmlTrace ("Xml: Lock: request is for a READ lock\n");
						m_dwLockType |= GENERIC_READ;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
#endif	// DBG
					break;

				case ST_SCOPE:

					if (FIsTag (pwszTag, gc_wszLockScopeExclusive))
					{
						XmlTrace ("Xml: Lock: request is for an EXCLUSE lock\n");
						m_dwScope = DAV_EXCLUSIVE_LOCK;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScopeShared))
					{
						XmlTrace ("Xml: Lock: request is for a SHARED lock\n");
						m_dwScope = DAV_SHARED_LOCK;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScopeLocal))
					{
						XmlTrace ("Xml: Lock: request is for a LOCAL scope lock\n");
						m_dwScope = DAV_LOCKSCOPE_LOCAL;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					break;
				case ST_OWNER:

					sc = m_xo.ScHandleNode (dwType,
											dwSubType,
											fTerminal,
											pwcText,
											ulLen,
											ulNamespaceLen,
											pwcNamespace,
										    ulNsPrefixLen);
					break;

				case ST_INTYPE_TRANS:

					if (FIsTag (pwszTag, gc_wszLockTypeTransactionGOP))
					{
						XmlTrace ("Xml: Lock: request is for a TRANSACTION GOP lock\n");
						m_dwLockType |= DAV_LOCKTYPE_TRANSACTION_GOP;
						m_state = ST_INTYPE_TRANS;
						sc = S_OK;
					}
			}
			break;

		default:

			//	If we are processing the owner, continue
			//	to do so...
			//
			if (ST_OWNER == m_state)
			{
				sc = m_xo.ScHandleNode (dwType,
										dwSubType,
										fTerminal,
										pwcText,
										ulLen,
										ulNamespaceLen,
										pwcNamespace,
									    ulNsPrefixLen);
			}
			break;
	}

	return sc;
}

SCODE
CNFLock::ScCompleteCreateNode (
	/* [in] */ DWORD dwType)
{
	if (ST_OWNER == m_state)
		m_xo.CompleteCreateNode (dwType);

	return S_OK;
}

//	class CNFUnlock -------------------------------------------------------------
//
SCODE
CNFUnlock::ScCompleteAttribute (void)
{
	return S_OK;
}

SCODE
CNFUnlock::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	Handle the rest...
	//
	switch (m_state)
	{
		case ST_UNLOCKINFO:

			m_state = ST_NODOC;
			break;

		case ST_COMMENT:
		case ST_CANCELCHECKOUT:

			m_state = ST_UNLOCKINFO;
			break;
	}

	return S_OK;
}

SCODE
CNFUnlock::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag = NULL;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				break;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propfind request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszUnlockInfo))
					{
						m_state = ST_UNLOCKINFO;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszTransactionInfo))
					{
						m_state = ST_TRANSACTIONINFO;
						sc = S_OK;
					}
					break;

				case ST_UNLOCKINFO:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszComment))
					{
						m_state = ST_COMMENT;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszCancelCheckout))
					{
						m_fCancelCheckout = TRUE;
						m_state = ST_CANCELCHECKOUT;
						sc = S_OK;
					}
					break;
				case ST_TRANSACTIONINFO:
					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszTransactionStatus))
					{
						m_state = ST_TRANSACTIONSTATUS;
						sc = S_OK;
					}
					break;
				case ST_TRANSACTIONSTATUS:
					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszCommit))
					{
						m_fCommitTransaction = TRUE;
						m_state = ST_TRANSACTIONSTATUS_COMMIT;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszAbort))
					{
						m_fAbortTransaction = TRUE;
						m_state = ST_TRANSACTIONSTATUS_ABORT;
						sc = S_OK;
					}
					break;
			}
			break;

		case XML_PCDATA:

			//	get unlock comment
			//
			if (m_state == ST_COMMENT)
			{
				//	Keep the comment
				//	It's a syntax error to have more than one comment
				//
				if (!m_wszComment.get())
				{
					m_wszComment = reinterpret_cast<LPWSTR>(ExAlloc((ulLen + 1) * sizeof(WCHAR)));
					Assert (m_wszComment.get());

					wcsncpy (m_wszComment.get(), pwcText, ulLen);
					m_wszComment[ulLen] = L'\0';

					sc = S_OK;
				}
				//	else it's an error
				else
					sc = E_DAV_XML_PARSE_ERROR;
			}
			break;
	}

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xpatch.cpp ===
/*
 *	X P A T C H . C P P
 *
 *	XML push model parsing for PROPPATCH requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	class CNFPatch -------------------------------------------------------------
//
SCODE
CNFPatch::ScCompleteAttribute (void)
{
	SCODE sc = S_OK;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	If we are value echoing, this is the point at which we much
	//	complete outputting the attribute (i.e. add the quotation mark
	//	after the value)
	//
	if (m_vestate == VE_INPROGRESS)
	{
		sc = m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );
		if (FAILED(sc))
			goto ret;

		//	Complete the current lextype
		//
		if (m_state == ST_LEXTYPE)
			m_state = ST_INPROP;
	}

	//	Normal processing -- values not being echoed
	//
	else if (m_state == ST_LEXTYPE)
	{
		//	Complete the current lextype
		//
		//	Note that m_ppctx is non-NULL if and only if
		//	ST_SET and the property to set is not a reserved
		//	property.
		//	(That means m_ppctx is NULL on ST_REMOVE, or if the impl
		//	didn't add a pctx, say because it's a reserved prop
		//	and they know the set of this prop will fail anyway....)
		//
		if ((m_sType == ST_SET) && m_ppctx.get())
		{
			m_sbValue.Append (sizeof(WCHAR), L"");
			sc = m_ppctx->ScSetType (m_sbValue.PContents());
			if (FAILED (sc))
				goto ret;
			m_sbValue.Reset();
		}

		m_state = ST_INPROP;
	}

	//	Flags processing
	//
	else if (m_state == ST_FLAGS)
	{
		//	Complete the current set of flags
		//
		//	Note that m_ppctx is non-NULL if and only if
		//	ST_SET and the property to set is not a reserved
		//	property.
		//
		//	That means m_ppctx is NULL on ST_REMOVE, or if the impl
		//	didn't add a pctx, say because it's a reserved prop
		//	and they know the set of this prop will fail anyway....
		//
		if ((m_sType == ST_SET) && m_ppctx.get())
		{
			m_sbValue.Append (sizeof(WCHAR), L"");
			sc = m_ppctx->ScSetFlags (wcstol (m_sbValue.PContents(), NULL, 0));
			if (FAILED (sc))
				goto ret;
			m_sbValue.Reset();
		}

		m_state = ST_INPROP;
	}

	else if (m_state == ST_SEARCHREQUEST)
	{
		sc = m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScCompleteCreateNode (
	/* [in] */ DWORD dwType)
{
	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	if (ST_SEARCHREQUEST == m_state || VE_INPROGRESS == m_vestate)
		m_xo.CompleteCreateNode (dwType);

	return S_OK;
}

SCODE
CNFPatch::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;
	static const WCHAR wch = 0;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	switch (m_state)
	{
		case ST_UPDATE:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_NODOC;
			break;

		case ST_SET:
		case ST_DELETE:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_UPDATE;
			break;

		case ST_PROPS:

			Assert (dwType == XML_ELEMENT);
			m_state = m_sType;
			break;

		case ST_SEARCHREQUEST:

			//	Do searchreqeust processing
			//
			Assert (dwType == XML_ELEMENT);
			sc = m_xo.ScCompleteChildren (fEmptyNode,
										  dwType,
										  pwcText,
										  ulLen);
			if (FAILED (sc))
				goto ret;

			//	26/NOV/99: MAXB
			//	REVIEW: if there are attributes will count really go to zero?
			//
			if (0 != m_xo.LDepth())
				break;

			// else fall through

		case ST_INPROP:

			//	Complete the current property
			//
			//	Note that m_ppctx is non-NULL if and only if
			//	ST_SET and the property to set is not a reserved
			//	property.
			//
			if (m_vestate != VE_NOECHO)
			{
				Assert (dwType == XML_ELEMENT);
				sc = m_xo.ScCompleteChildren (fEmptyNode,
										  dwType,
										  pwcText,
										  ulLen);
				if (FAILED (sc))
					goto ret;

				if (0 != m_xo.LDepth())
					break;
				m_vestate = VE_NOECHO;
			}

			Assert (dwType == XML_ELEMENT);
			if ((m_sType == ST_SET) && m_ppctx.get())
			{
				m_sbValue.Append (sizeof(wch), &wch);
				sc = m_ppctx->ScSetValue (!fEmptyNode
										  ? m_sbValue.PContents()
										  : NULL,
										  m_cmvValues);
				if (FAILED (sc))
					goto ret;

				sc = m_ppctx->ScComplete (fEmptyNode);
				if (FAILED (sc))
					goto ret;

				m_cmvValues = 0;
				m_sbValue.Reset();
				m_ppctx.clear();
			}
			m_state = ST_PROPS;
			break;

		//	When dealing with multivalued properties, we need this extra
		//	state such that each value gets added to the context via a single
		//	call to ScSetValue() with multiple values layed end-to-end.
		//
		case ST_INMVPROP:

			Assert (dwType == XML_ELEMENT);
			if ((m_sType == ST_SET) && m_ppctx.get())
			{
				//	Terminate the current value.
				//
				m_sbValue.Append (sizeof(wch), &wch);
			}
			m_state = ST_INPROP;
			break;

		//  We are finishing a <DAV:resourcetype> tag, reset state to ST_PROPS
		//
		case ST_RESOURCETYPE:
			m_state = ST_PROPS;
			break;

		//  We are inside a <DAV:resourcetype> tag, reset state to ST_RESOURCETYPE
		//
		case ST_STRUCTUREDDOCUMENT:
			m_state = ST_RESOURCETYPE;
			break;
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	Forward to searchreqeust node handling
	//
	if (ST_SEARCHREQUEST == m_state)
	{
		sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);
		goto ret;
	}

	//	If we are performing value echoing, do it now
	//	NOTE: that unlike ST_SEARCHREQUEST we *also*
	//	do other processing.
	//
	if (m_vestate == VE_INPROGRESS)
	{
		sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);
		if (FAILED(sc))
			goto ret;
	}

	//	Normal handling performed whether we are echoing
	//	values or not
	//
	switch (dwType)
	{
		case XML_ELEMENT:

			//	Handle any state changes based on element
			//	names
			//
			sc = ScHandleElementNode (dwType,
									  dwSubType,
									  fTerminal,
									  pwcText,
									  ulLen,
									  ulNamespaceLen,
									  pwcNamespace,
									  ulNsPrefixLen);
			if (FAILED (sc))
				goto ret;

			break;

		case XML_ATTRIBUTE:

			if ((m_state == ST_INPROP) && (XML_NS != dwSubType))
			{
				cch = ulNamespaceLen + ulLen;
				pwszTag = wsz.resize(CbSizeWsz(cch));
				if (NULL == pwszTag)
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
				wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
				*(wsz.get() + cch) = 0;

				//	If this is a lextype attribute, make the
				//	appropriate transition
				//
				if (!_wcsnicmp (pwszTag, gc_wszLexType, cch) ||
					!wcsncmp (pwszTag, gc_wszDataTypes, cch) ||
					!wcsncmp (pwszTag, gc_wszLexTypeOfficial, cch))
				{
					m_state = ST_LEXTYPE;
					sc = S_OK;
				}
				else if (!wcsncmp (pwszTag, gc_wszFlags, cch))
				{
					m_state = ST_FLAGS;
					sc = S_OK;
				}
			}
			break;

		case XML_PCDATA:
		case XML_WHITESPACE:

			if (m_vestate != VE_INPROGRESS)
			{
				switch (m_state)
				{
					case ST_INPROP:

						//	If we are in the transition from outside, value to
						//	inside value -- and visa versa -- we do not want to
						//	add anything to the current buffer.
						//	Note that m_ppcxt may be NULL if we've encountered a
						//	reserved property in the request.
						//
						if ((XML_WHITESPACE == dwType) &&
							(!m_ppctx.get() || m_ppctx->FMultiValued()))
							break;

						// !!! FALL THROUGH !!! */

					case ST_INMVPROP:

						//	Note that m_ppctx is non-NULL if and only if
						//	ST_SET and the property to set is not a reserved
						//	property.  If these are not set, then ignore the
						//	value.
						//
						if ((m_sType != ST_SET) || !m_ppctx.get())
							break;

						/* !!! FALL THROUGH !!! */

					case ST_LEXTYPE:
					case ST_FLAGS:

						Assert (fTerminal);

						//	Build up the value for later use...
						//
						m_sbValue.Append (ulLen * sizeof(WCHAR), pwcText);
						sc = S_OK;
				}
			}
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScHandleElementNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	Construct the full name of the node
	//
	cch = ulNamespaceLen + ulLen;
	pwszTag = wsz.resize(CbSizeWsz(cch));
	if (NULL == pwszTag)
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
	wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
	*(wsz.get() + cch) = 0;

	switch (m_state)
	{
		case ST_NODOC:

			//	If this is the topmost node in a propfind request,
			//	transition to the next state.  Since there is no parent
			//	node to provide scoping, FIsTag() cannot be used here!
			//
			if (!wcscmp (pwszTag, gc_wszPropertyUpdate))
			{
				m_state = ST_UPDATE;
				sc = S_OK;
			}
			break;

		case ST_UPDATE:

			//	Look for our well know node types
			//
			if (FIsTag (pwszTag, gc_wszSet))
			{
				m_state = m_sType = ST_SET;
				sc = S_OK;
			}
			else if (FIsTag (pwszTag, gc_wszRemove))
			{
				m_state = m_sType = ST_DELETE;
				sc = S_OK;
			}
			break;

		case ST_SET:
		case ST_DELETE:

			//	Look for our well know node types
			//
			if (FIsTag (pwszTag, gc_wszProp))
			{
				m_state = ST_PROPS;
				sc = S_OK;
			}
			break;

		case ST_PROPS:

			//	Process the property as requested...
			//
			if (dwType == XML_ELEMENT)
			{
				m_state = ST_INPROP;
				if (m_sType == ST_SET)
				{
					//	Get a property context from the patch context
					//	that we can fill out and complete...
					//
					Assert (0 == m_cmvValues);
					Assert (NULL == m_ppctx.get());

					//  If it's resourcetype request, change the state
					//  and don't set props
					//
					if (FIsTag (pwszTag, gc_wszResoucetype))
					{
						m_state = ST_RESOURCETYPE;
						sc = S_OK;
					}
					else
					{
						sc = m_cpc.ScSetProp (NULL, pwszTag, m_ppctx);
						if (FAILED (sc))
							goto ret;

						//	Special handling for search requests, recording
						//	begins immediately
						//
						if (FIsTag (pwszTag, gc_wszSearchRequest))
						{
							CEmitNmspc cen(m_xo);

							//	Make the state transition and start recording
							//
							m_state = ST_SEARCHREQUEST;
							sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);

							//	Spit out the namespaces.
							//
							//	Note that this will spit out any namespaces
							//	decl'd in the DAV:owner node itself.  So we
							//	do not really want to emit these out to the
							//	owners comments until ScCompleteAttribute()
							//	is called.
							//
							Assert (!m_xo.FAddNamespaceDecl());
							m_cache.ForEach(cen);
							sc = S_OK;
						}
						//	Special handling for case when we are PROPPATCH-ing
						//	XML valued properties.  In this case we don't begin
						//	recording yet because we don't want the property
						//	node just the XML value inside
						//
						else if (FValueIsXML (pwszTag))
							m_vestate = VE_NEEDNS;
					}
				}
				else
				{
					//	Queue the property for deletion with
					//	the patch context
					//
					Assert (m_sType == ST_DELETE);
					sc = m_cpc.ScDeleteProp (NULL, pwszTag);
					if (FAILED (sc))
						goto ret;
				}
			}
			break;

		case ST_INPROP:

			//	Normal case -- value echoing is off.  The work here is to
			//	deal with multivalued properties.  In this case we need an extra
			//	state such that each value gets added to the context via a single
			//	call to ScSetValue() with multiple values layed end-to-end.
			//
			//		NOTE: support for handling multivalued properties has not been
			//		added for echoing mode.  If you add an XML valued multivalued
			//		property you need to do	some work in the echo mode cases below
			//
			if (m_vestate == VE_NOECHO)
			{
				//	m_ppctx is NULL when we have attempted to set a reserved
				//  (read only) property.  when this happens, we need to continue
				//  parsing the request, but we don't actually set the properties.
				//  thus, we need to set the correct state as if this was a valid
				//  request.
				//
				if (NULL == m_ppctx.get())
				{
					m_state = ST_INMVPROP;
					sc = S_OK;
				}
				else if (m_ppctx->FMultiValued() && FIsTag (pwszTag, gc_wszXml_V))
				{
					m_state = ST_INMVPROP;
					m_cmvValues += 1;
					sc = S_OK;
				}
			}

			//	We are echoing values or about to start echoing values
			//
			else
			{
				//	If this is the first element seen that is part of an XML-valued
				//	property that we are PROPPATCH-ing, then we need to spit out
				//	the cached namespaces they are available to the EXOLEDB side
				//
				if (m_vestate == VE_NEEDNS)
				{
					CEmitNmspc cen(m_xo);

					//	Make the state transition and start recording
					//
					m_vestate = VE_INPROGRESS;
					sc = m_xo.ScHandleNode (dwType,
											dwSubType,
											fTerminal,
											pwcText,
											ulLen,
											ulNamespaceLen,
											pwcNamespace,
											ulNsPrefixLen);

					//	Spit out the namespaces.
					//
					//	Note that this will spit out any namespaces
					//	decl'd in the DAV:owner node itself.  So we
					//	do not really want to emit these out to the
					//	owners comments until ScCompleteAttribute()
					//	is called.
					//
					Assert (!m_xo.FAddNamespaceDecl());
					m_cache.ForEach(cen);

				}

				//	Indicate that additional namespace declarations
				//	should be echoed as we see them
				//
				m_xo.CompleteAttribute();

				sc = S_OK;
			}
			break;
		//  We see a <DAV:resourcetype> tag.  It should be in a MKCOL body.
		//
		case ST_RESOURCETYPE:
			//  If resourcetype is not structured doc, just ignore
			//
			if (FIsTag (pwszTag, gc_wszStructureddocument))
			{
				m_cpc.SetCreateStructureddocument();
				m_state = ST_STRUCTUREDDOCUMENT;
				sc = S_OK;
			}
			break;
	}

ret:
	return sc;
}

// Tags that have XML values that need to be shipped across epoxy
//
const WCHAR * gc_rgwszXMLValueTags[] =
{
	L"http://schemas.microsoft.com/exchange/security/admindescriptor",
	L"http://schemas.microsoft.com/exchange/security/descriptor",
	L"http://schemas.microsoft.com/exchange/security/creator",
	L"http://schemas.microsoft.com/exchange/security/lastmodifier",
	L"http://schemas.microsoft.com/exchange/security/sender",
	L"http://schemas.microsoft.com/exchange/security/sentrepresenting",
	L"http://schemas.microsoft.com/exchange/security/originalsender",
	L"http://schemas.microsoft.com/exchange/security/originalsentrepresenting",
	L"http://schemas.microsoft.com/exchange/security/readreceiptfrom",
	L"http://schemas.microsoft.com/exchange/security/reportfrom",
	L"http://schemas.microsoft.com/exchange/security/originator",
	L"http://schemas.microsoft.com/exchange/security/reportdestination",
	L"http://schemas.microsoft.com/exchange/security/originalauthor",
	L"http://schemas.microsoft.com/exchange/security/receivedby",
	L"http://schemas.microsoft.com/exchange/security/receivedrepresenting",
};


//This function tests to see if a property has an XML value that must be
//shipped from DAVEX to EXOLEDB
//
BOOL
CNFPatch::FValueIsXML( const WCHAR *pwcTag )
{
	BOOL	f = FALSE;

	ULONG	iwsz;

	for (iwsz = 0; iwsz < sizeof(gc_rgwszXMLValueTags)/sizeof(WCHAR *); iwsz ++)
	{
		if (wcscmp (pwcTag, gc_rgwszXMLValueTags[iwsz]) == 0)
		{
			f = TRUE;
			break;
		}
	}
	return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xsearch.cpp ===
/*
 *	X S E A R C H . C P P
 *
 *	XML push model parsing for MS-SEARCH requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
#include <align.h>

//	class CNFSearch -------------------------------------------------------------
//
SCODE
CNFSearch::ScCompleteAttribute (void)
{
	SCODE sc = S_OK;

	switch (m_state)
	{
		case ST_RANGE_TYPE:

			//	Find the range type.
			//
			m_state = ST_RANGE;
			if (0 == wcsncmp (m_sb.PContents(), L"row", m_sb.CchSize()))
				m_uRT = RANGE_ROW;
			else if (0 == wcsncmp (m_sb.PContents(), L"url", m_sb.CchSize()))
				m_uRT = RANGE_URL;
			else if (0 == wcsncmp (m_sb.PContents(), L"find", m_sb.CchSize()))
				m_uRT = RANGE_FIND;
			else
				m_uRT = RANGE_UNKNOWN;

			m_sb.Reset();
			break;

		case ST_RANGE_ROWS:

			//	Find the number of rows to retrieve
			//
			m_state = ST_RANGE;
			m_sb.Append (sizeof(WCHAR), L"");
			m_lcRows = wcstol (m_sb.PContents(), NULL, 10 /* base 10 only */);
			m_sb.Reset();
			break;

	}
	return sc;
}

SCODE
CNFSearch::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;

	switch (m_state)
	{
		case ST_SEARCH:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_NODOC;
			break;

		//	Exiting the base repl node
		//
		case ST_REPL:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_SEARCH;
			break;

		case ST_QUERY:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_SEARCH;

			//	Set the search text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetSQL (this, m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_QUERYENTITY:

			m_state = ST_QUERY;
			break;

		case ST_REPLCOLLBLOB:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPL;

			//	Set the collblob text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetCollBlob (m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_REPLRESTAGLIST:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPL;
			break;

		case ST_REPLRESTAGADD:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPLRESTAGLIST;

			//	Set the restag text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetResTagAdds (m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_RANGE:

			Assert (XML_ELEMENT == dwType);
			m_state = ST_SEARCH;

			//	Add the range to the list
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScAddRange (m_uRT, m_sb.PContents(), m_lcRows);
			if (FAILED (sc))
				goto ret;

			//	Clear all range elements
			//
			m_uRT = RANGE_UNKNOWN;
			m_lcRows = 0;
			break;

		case ST_GROUP_EXPANSION:

			Assert (XML_ELEMENT == dwType);
			m_state = ST_SEARCH;

			//	Add the expansion level to the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetExpansion (wcstol(m_sb.PContents(), NULL, 10));
			if (FAILED (sc))
				goto ret;

			break;
	}

ret:
	return sc;
}

SCODE
CNFSearch::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propSearch request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszSearchRequest))
					{
						m_state = ST_SEARCH;
						sc = S_OK;
					}
					break;

				case ST_SEARCH:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszSql))
					{
						m_state = ST_QUERY;
						m_sb.Reset();
						sc = S_OK;
					}
					//	Check for our top-level repl node.
					//	All repl items should appear inside this node.
					//	Tell our caller this is a REPL request, and
					//	switch our state to ST_REPL.
					//
					else if (FIsTag (pwszTag, gc_wszReplNode))
					{
						m_state = ST_REPL;
						sc = m_csc.ScSetReplRequest (TRUE);
						if (FAILED (sc))
							goto ret;
					}
					else if (FIsTag (pwszTag, gc_wszRange))
					{
						m_state = ST_RANGE;
						m_sb.Reset();
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszExpansion))
					{
						m_state = ST_GROUP_EXPANSION;
						m_sb.Reset();
						sc = S_OK;
					}
					break;

				case ST_REPL:

					//	Handle the nodes under the top-level repl node.
					//
					if (FIsTag (pwszTag, gc_wszReplCollBlob))
					{
						m_sb.Reset();
						m_state = ST_REPLCOLLBLOB;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszReplResTagList))
					{
						m_sb.Reset();
						m_state = ST_REPLRESTAGLIST;
						sc = S_OK;
					}
					break;

				case ST_REPLRESTAGLIST:

					//	Handle the restag nodes under the restaglist node.
					//
					if (FIsTag (pwszTag, gc_wszReplResTagItem))
					{
						m_sb.Reset();
						m_state = ST_REPLRESTAGADD;
						sc = S_OK;
					}
					break;
			}
			break;

		case XML_ATTRIBUTE:

			if (ST_RANGE == m_state)
			{
				//	Construct the full name of the node
				//
				cch = ulNamespaceLen + ulLen;
				pwszTag = wsz.resize(CbSizeWsz(cch));
				if (NULL == pwszTag)
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
				wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
				*(wsz.get() + cch) = 0;

				//	There are two attributes node for the DAV:range
				//	node.  DAV:type, and DAV:rows.
				//
				if (FIsTag (pwszTag, gc_wszRangeType))
				{
					m_state = ST_RANGE_TYPE;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszRangeRows))
				{
					m_state = ST_RANGE_ROWS;
					sc = S_OK;
				}
				break;
			}
			break;

		case XML_PCDATA:

			//	If this is SQL query data, or repl collblob data,
			//	repl resourcetag data, or any of the range items,
			//	then remember it in our buffer.
			//
			if ((m_state == ST_QUERY)
				|| (m_state == ST_REPLCOLLBLOB)
				|| (m_state == ST_REPLRESTAGADD)
				|| (m_state == ST_RANGE_TYPE)
				|| (m_state == ST_RANGE_ROWS)
				|| (m_state == ST_RANGE)
				|| (m_state == ST_GROUP_EXPANSION))
			{
				//	Append the current bits to the buffer
				//
				m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
				sc = S_OK;
			}
			break;
	}

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\_xml.h ===
/*
 *	_ X M L . H
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4100)	//	unref formal parameter
#pragma warning(disable:4710)	//	unexpanded c++ methods


//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>

#include <oledberr.h>

#include <ex\xml.h>
#include <ex\xprs.h>
#include <ex\calcom.h>

#include <xemit.h>
#include <xmeta.h>
#include <xsearch.h>

#include "chartype.h"

//	Helper Macros -------------------------------------------------------------
//
#define CElems(_rg)			(sizeof(_rg)/sizeof(_rg[0]))
#define CbSizeWsz(_cch)		(((_cch) + 1) * sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xml\_xml.cpp ===
/*
 *	_ X M L . C P P
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\atomcache.cpp ===
/*
 *	A T O M C A C H E . C P P
 *
 *	atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

//	CXAtomCache::GetCachedAtom ------------------------------------------------
//
SCODE
CXAtomCache::ScGetCachedAtom (CRCWszN& key, LPCWSTR* pwszAtom)
{
	LPCWSTR wszCommitted;
	LPCWSTR* pwsz;
	SCODE sc = S_OK;

	//	First look to see if it is already there.
	//
	{
		CSynchronizedReadBlock srb(m_lock);
		pwsz = m_cache.Lookup (key);
	}

	//	If it wasn't there, do our best to add it
	//
	if (NULL == pwsz)
	{
		CSynchronizedWriteBlock swb(m_lock);

		//	There is a small window where it could
		//	have shown up, so do a second quick peek
		//
		pwsz = m_cache.Lookup (key);
		if (NULL == pwsz)
		{
			//	Commit the string to perm. storage
			//
			wszCommitted = m_csb.Append(key.m_cch*sizeof(WCHAR), key.m_pwsz);
			if (NULL == wszCommitted)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//	Add the atom to the cache, but before it
			//	gets added, swap out the key's string pointer
			//	to the committed version.
			//
			key.m_pwsz = wszCommitted;
			m_cache.FAdd (key, wszCommitted);

			//	Setup for the return
			//
			pwsz = &wszCommitted;
		}
	}

	Assert (pwsz);
	Assert (pwszAtom);
	*pwszAtom = *pwsz;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\base64.cpp ===
/*
 *	B A S E 6 4 . C P P
 *
 *	Sources Base64 encoding
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

/* From RFC 1521:

5.2.  Base64 Content-Transfer-Encoding

   The Base64 Content-Transfer-Encoding is designed to represent
   arbitrary sequences of octets in a form that need not be humanly
   readable.  The encoding and decoding algorithms are simple, but the
   encoded data are consistently only about 33 percent larger than the
   unencoded data.	This encoding is virtually identical to the one used
   in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
   The base64 encoding is adapted from RFC 1421, with one change: base64
   eliminates the "*" mechanism for embedded clear text.

	  A 65-character subset of US-ASCII is used, enabling 6 bits to be
   represented per printable character. (The extra 65th character, "=",
   is used to signify a special processing function.)

	  NOTE: This subset has the important property that it is
	  represented identically in all versions of ISO 646, including US
	  ASCII, and all characters in the subset are also represented
	  identically in all versions of EBCDIC.  Other popular encodings,
	  such as the encoding used by the uuencode utility and the base85
	  encoding specified as part of Level 2 PostScript, do not share
	  these properties, and thus do not fulfill the portability
	  requirements a binary transport encoding for mail must meet.

   The encoding process represents 24-bit groups of input bits as output
   strings of 4 encoded characters. Proceeding from left to right, a
   24-bit input group is formed by concatenating 3 8-bit input groups.
   These 24 bits are then treated as 4 concatenated 6-bit groups, each
   of which is translated into a single digit in the base64 alphabet.
   When encoding a bit stream via the base64 encoding, the bit stream
   must be presumed to be ordered with the most-significant-bit first.
   That is, the first bit in the stream will be the high-order bit in
   the first byte, and the eighth bit will be the low-order bit in the
   first byte, and so on.

   Each 6-bit group is used as an index into an array of 64 printable
   characters. The character referenced by the index is placed in the
   output string. These characters, identified in Table 1, below, are
   selected so as to be universally representable, and the set excludes
   characters with particular significance to SMTP (e.g., ".", CR, LF)
   and to the encapsulation boundaries defined in this document (e.g.,
   "-").

			   Table 1: The Base64 Alphabet

	  Value Encoding  Value Encoding  Value Encoding  Value Encoding
		   0 A			  17 R			  34 i			  51 z
		   1 B			  18 S			  35 j			  52 0
		   2 C			  19 T			  36 k			  53 1
		   3 D			  20 U			  37 l			  54 2
		   4 E			  21 V			  38 m			  55 3
		   5 F			  22 W			  39 n			  56 4
		   6 G			  23 X			  40 o			  57 5
		   7 H			  24 Y			  41 p			  58 6
		   8 I			  25 Z			  42 q			  59 7
		   9 J			  26 a			  43 r			  60 8
		  10 K			  27 b			  44 s			  61 9
		  11 L			  28 c			  45 t			  62 +
		  12 M			  29 d			  46 u			  63 /
		  13 N			  30 e			  47 v
		  14 O			  31 f			  48 w		   (pad) =
		  15 P			  32 g			  49 x
		  16 Q			  33 h			  50 y

   The output stream (encoded bytes) must be represented in lines of no
   more than 76 characters each.  All line breaks or other characters
   not found in Table 1 must be ignored by decoding software.  In base64
   data, characters other than those in Table 1, line breaks, and other
   white space probably indicate a transmission error, about which a
   warning message or even a message rejection might be appropriate
   under some circumstances.

   Special processing is performed if fewer than 24 bits are available
   at the end of the data being encoded.  A full encoding quantum is
   always completed at the end of a body.  When fewer than 24 input bits
   are available in an input group, zero bits are added (on the right)
   to form an integral number of 6-bit groups.	Padding at the end of
   the data is performed using the '=' character.  Since all base64
   input is an integral number of octets, only the following cases can
   arise: (1) the final quantum of encoding input is an integral
   multiple of 24 bits; here, the final unit of encoded output will be
   an integral multiple of 4 characters with no "=" padding, (2) the
   final quantum of encoding input is exactly 8 bits; here, the final
   unit of encoded output will be two characters followed by two "="
   padding characters, or (3) the final quantum of encoding input is
   exactly 16 bits; here, the final unit of encoded output will be three
   characters followed by one "=" padding character.

   Because it is used only for padding at the end of the data, the
   occurrence of any '=' characters may be taken as evidence that the
   end of the data has been reached (without truncation in transit).  No
   such assurance is possible, however, when the number of octets
   transmitted was a multiple of three.

   Any characters outside of the base64 alphabet are to be ignored in
   base64-encoded data.	 The same applies to any illegal sequence of
   characters in the base64 encoding, such as "====="

   Care must be taken to use the proper octets for line breaks if base64
   encoding is applied directly to text material that has not been
   converted to canonical form.	 In particular, text line breaks must be
   converted into CRLF sequences prior to base64 encoding. The important
   thing to note is that this may be done directly by the encoder rather
   than in a prior canonicalization step in some implementations.

	  NOTE: There is no need to worry about quoting apparent
	  encapsulation boundaries within base64-encoded parts of multipart
	  entities because no hyphen characters are used in the base64
	  encoding.

*/

VOID inline
EncodeAtom (LPBYTE pbIn, WCHAR* pwszOut, UINT cbIn)
{
	static const WCHAR wszBase64[] = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
									 L"abcdefghijklmnopqrstuvwxyz"
									 L"0123456789+/";
	Assert (pbIn);
	Assert (pwszOut);
	Assert (cbIn);

	//	Set cbIn to 3 if it's greater than three: convenient for 'switch'
	//
	if (cbIn > 3)
		cbIn = 3;

	pwszOut[0] = wszBase64[pbIn[0] >> 2];
	switch(cbIn)
	{
		case 3:

			//	End of stream has not been reached yet
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[((pbIn[1] & 0x0F) << 2) + (pbIn[2] >> 6)];
			pwszOut[3] = wszBase64[pbIn[2] & 0x3F];
			return;

		case 2:

			//	At the end of stream: pad with 1 byte
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[ (pbIn[1] & 0x0F) << 2];
			pwszOut[3] = L'=';
			return;

		case 1:

			//	At the end of stream: pad with 2 bytes
			//
			pwszOut[1] = wszBase64[ (pbIn[0] & 0x03) << 4];
			pwszOut[2] = L'=';
			pwszOut[3] = L'=';
			return;

		default:

			//	Should never happen
			//
			Assert (FALSE);
	}
}

//	------------------------------------------------------------------------
//	EncodeBase64
//
//	Encode cbIn bytes of data from pbIn into the provided buffer
//	at pwszOut, up to cchOut chars.
//$REVIEW: Shouldn't this function return some kind of error if
//$REVIEW: cchOut didn't have enough space for the entire output string?!!!
//
void
EncodeBase64 (LPBYTE pbIn, UINT cbIn, WCHAR* pwszOut, UINT cchOut)
{
	//	They must have passed us at least one char of space -- for the terminal NULL.
	Assert (cchOut);

	//	Loop through, encoding atoms as we go...
	//
	while (cbIn)
	{
		//	NOTE: Yes, test for STRICTLY more than 4 WCHARs of space.
		//	We will use 4 WCHARs on this pass of the loop, and we always
		//	need one for the terminal NULL!
		Assert (cchOut > 4);

		//	Encode the next three bytes of data into four chars of output string.
		//	(NOTE: This does handle the case where we have <3 bytes of data
		//	left to encode -- thus we pass in cbIn!)
		//
		EncodeAtom (pbIn, pwszOut, cbIn);

		//	Update our pointers and counters.
		pbIn += min(cbIn, 3);
		pwszOut += 4;
		cchOut -= 4;
		cbIn -= min(cbIn, 3);
	}

	//	Ensure Termination
	//	(But first, check that we still have one WCHAR of space left
	//	for the terminal NULL!)
	//
	Assert (cchOut >= 1);
	*pwszOut = 0;
}

SCODE
ScDecodeBase64 (WCHAR* pwszIn, UINT cchIn, LPBYTE pbOut, UINT* pcbOut)
{
	//	Base64 Reverse alphabet.  Indexed by base 64 alphabet character
	//
	static const BYTE bEq = 254;
	static const BYTE rgbDict[128] = {

		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 0-F
		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 10-1F
		255,255,255,255,255,255,255,255,255,255,255, 62,255,255,255, 63,	// 20-2F
		 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,255,255,255,bEq,255,255,	// 30-3f
		255,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,	// 40-4f
		 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,255,255,255,255,255,	// 50-5f
		255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,	// 60-6f
		 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,255,255,255,255,255		// 70-7f
	};

	SCODE sc = S_OK;

	UINT cchConsumed = 0;
	UINT cbProduced = 0;
	UINT cbFudge = 0;

	Assert (pbOut);
	Assert (pcbOut);

	//	Check that they didn't lie about the size of their buffer!
	//
	Assert (!IsBadWritePtr(pbOut, *pcbOut));

	//	Check that the size of the output buffer is adequate for
	//	decoded data.
	//
	Assert (*pcbOut >= CbNeededDecodeBase64(cchIn));
	Assert (pwszIn);

	//	Output is generated in 3-byte increments for 4 bytes of input
	//
	Assert ((cchIn*3)/4 <= *pcbOut);

	//	Go until there is nothing left to decode...
	//
	while (cchConsumed < cchIn)
	{
		Assert (cbProduced <= *pcbOut);

		BYTE rgb[4];
		UINT ib = 0;
		
		//	However, if there is not enough space to
		//	decode the next atom into, then this has
		//	got to be an error...
		//
		if (*pcbOut - cbProduced < 3)
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Not enough space to decode next base64 atom.");
			break;
		}

		//	The characters that do not fall into base 64 alphabet must be
		//	ignored, so let us assemble the 4 byte chunk of data that we
		//	will actually go with for the conversion
		//
		while ((cchConsumed < cchIn) &&
			   (ib < 4))
		{
			//	If the symbol is in the alphabet ...
			//
			if ((pwszIn[cchConsumed] < sizeof(rgbDict)) &&
				(rgbDict[pwszIn[cchConsumed]] != 0xFF))
			{
				//	...	save the character off into the
				//	array
				//
				rgb[ib++] = rgbDict[pwszIn[cchConsumed]];
			}

			//	... go for the next character in the line
			//
			cchConsumed++;
		}

		//	If there is no more data at all, then go
		//	away with no error, as up to that point
		//	we converted everything just fine, and
		//	the characters in the end were ignorable
		//
		if (0 == ib)
		{
			Assert(cchConsumed == cchIn);
			break;
		}
		else if ((4 != ib) || (0 != cbFudge))
		{
			//	There was some data to convert, but not enough to fill in
			//	the 4 byte buffer then data is incomplete and cannot be converted;
			//	If the end bEq markers were present some time before, data
			//	is also invalid, there should not be any data after the end
			//
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, data not complete, or extra data after padding: %ws\n", pwszIn);
			break;
		}

		//	Check that the characters 1 and 2 are not bEq
		//
		if ((rgb[0] == bEq) ||
			(rgb[1] == bEq))
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected: %ws\n", pwszIn);
			break;
		}

		//	Check if the third character is bEq
		//
		if (rgb[2] == bEq)
		{
			rgb[2] = 0;
			cbFudge += 1;

			//	... the fourth should be also bEq if the third was that way
			//
			if (rgb[3] != bEq)
			{
				sc = E_DAV_BASE64_ENCODING_ERROR;
				DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected:  %ws\n", pwszIn);
				break;
			}
		}

		//	Check if the fourth character is bEq
		//
		if (rgb[3] == bEq)
		{
			rgb[3] = 0;
			cbFudge += 1;
		}

		//	Make sure that these are well formed 6bit characters.
		//
		Assert((rgb[0] & 0x3f) == rgb[0]);
		Assert((rgb[1] & 0x3f) == rgb[1]);
		Assert((rgb[2] & 0x3f) == rgb[2]);
		Assert((rgb[3] & 0x3f) == rgb[3]);

		//	Ok, we now have 4 6bit characters making up the 3 bytes of output.
		//
		//	Assemble them together to make a 3 byte word.
		//
		DWORD dwValue = (rgb[0] << 18) +
						(rgb[1] << 12) +
						(rgb[2] << 6) +
						(rgb[3]);

		//	This addition had better not have wrapped.
		//
		Assert ((dwValue & 0xff000000) == 0);

		//	Copy over the 3 bytes into the output stream.
		//
		pbOut[0] = (BYTE)((dwValue & 0x00ff0000) >> 16);
		Assert(pbOut[0] == (rgb[0] << 2) + (rgb[1] >> 4));
		pbOut[1] = (BYTE)((dwValue & 0x0000ff00) >>	 8);
		Assert(pbOut[1] == ((rgb[1] & 0xf) << 4) + (rgb[2] >> 2));
		pbOut[2] = (BYTE)((dwValue & 0x000000ff) >>	 0);
		Assert(pbOut[2] == ((rgb[2] & 0x3) << 6) + rgb[3]);
		cbProduced += 3;
		pbOut += 3;

		//	If cbFudge is non 0, it means we had "=" signs at the end
		//	of the buffer.	In this case, we overcounted the actual
		//	number of characters in the buffer.
		//
		//	Although cbFuge is counted in 6 bit chunks, but it assumes
		//	values just 0, 1 or 2. And that allows us to say that the
		//	number of bytes actually produced were by cbFuge less.
		//	Eg. if cbFuge = 1, then uuuuuu is padded, which could
		//		happen only when zzzzzzzz chunk was empty
		//		if cbFuge = 2, then zzzzzz uuuuuu is padded, which could
		//		happen only when yyyyyyyy and zzzzzzzz were empty
		//
		//	xxxxxx yyyyyy zzzzzz uuuuuu <- 6 bit chunks
		//	xxxxxx xxyyyy yyyyzz zzzzzz	<- 8 bit chunks
		//
		if (cbFudge)
		{
			Assert ((cbFudge < 3) && (cbFudge < cbProduced));
			cbProduced -= cbFudge;
			pbOut -= cbFudge;
		}		
	}

	//	Tell the caller the actuall size...
	//
	*pcbOut = cbProduced;
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xemit2.cpp ===
/*
 *	X E M I T 2 . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

DEC_CONST CHAR gc_szXmlVersion[] = "<?xml version=\"1.0\"?>";
DEC_CONST UINT gc_cchXmlVersion = CElems(gc_szXmlVersion) - 1 ;


//	class CXMLEmitter ---------------------------------------------------------
//
SCODE
CXMLEmitter::ScAddNmspc (
	/* [in] */ const auto_ref_ptr<CNmspc>& pns,
	/* [in] */ CXNode* pxnRoot)
{
	Assert (pxnRoot);

	auto_ref_ptr<CXNode> pxn;
	CStackBuffer<WCHAR> pwsz;
	SCODE sc = S_OK;
	UINT cch;

	//	Allocate enough space for the prefix, colon and alias
	//
	cch = CchConstString(gc_wszXmlns) + 1 + pns->CchAlias();
	if (NULL == pwsz.resize(CbSizeWsz(cch)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	wcsncpy (pwsz.get(), gc_wszXmlns, CchConstString(gc_wszXmlns));
	if (pns->CchAlias())
	{
		pwsz[CchConstString(gc_wszXmlns)] = L':';
		wcsncpy(pwsz.get() + CchConstString(gc_wszXmlns) + 1,
				pns->PszAlias(),
				pns->CchAlias());
		pwsz[cch] = 0;
	}
	else
		pwsz[CchConstString(gc_wszXmlns)] = 0;

	//	Create the namespace attribute
	//
	sc = pxnRoot->ScGetChildNode (CXNode::XN_NAMESPACE, pxn.load());
	if (FAILED(sc))
		goto ret;

	Assert (pxn.get());
	sc = ScAddAttribute (pxn.get(),
						 pwsz.get(),
						 cch,
						 pns->PszHref(),
						 pns->CchHref());
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXMLEmitter::ScAddAttribute (
	/* [in] */ CXNode * pxn,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ UINT cchTag,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ UINT cchValue)
{
	SCODE	sc = S_OK;

	//	Format:
	//
	//	" " [<alias> ":"] <tag> "=\"" <value> "\""
	//
	sc = m_pxb->ScAddTextBytes (1, " ");
	if (FAILED(sc))
		goto ret;

	sc = pxn->ScSetTag (this, cchTag, pwszTag);
	if (FAILED (sc))
		goto ret;

	sc = m_pxb->ScAddTextBytes (2, "=\"");
	if (FAILED(sc))
		goto ret;

	sc = pxn->ScSetValue (pwszValue, cchValue);
	if (FAILED (sc))
		goto ret;

	sc = m_pxb->ScAddTextBytes (1, "\"");
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

BOOL
CXMLEmitter::NmspcEmittingOp::operator() (const CRCWszN&, const auto_ref_ptr<CNmspc>& nmspc )
{
	return SUCCEEDED (m_emitter->ScAddNmspc (nmspc, m_pxnParent.get()));
}

SCODE
CXMLEmitter::ScNewNode (
	/* [in] */ XNT xnt,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CXNode * pxnParent,
	/* [in] */ auto_ref_ptr<CXNode>& pxnOut)
{
	auto_ref_ptr<CXNode> pxn;
	SCODE sc = S_OK;

	//	Create the node
	//
	sc = pxnParent->ScGetChildNode (xnt, pxn.load());
	if (FAILED(sc))
		goto ret;

	//	Set the tag name
	//
	switch (xnt)
	{
		case CXNode::XN_ELEMENT:
		case CXNode::XN_ATTRIBUTE:

			sc = pxn->ScSetTag (this, static_cast<UINT>(wcslen(pwszTag)), pwszTag);
			if (FAILED (sc))
				goto ret;

		case CXNode::XN_NAMESPACE:

			break;
	}

	//	Pass back a reference
	//
	Assert (S_OK == sc);
	pxnOut = pxn.get();

ret:
	return sc;
}

SCODE
CXMLEmitter::ScSetRoot (LPCWSTR pwszTag)
{
	SCODE	sc = S_OK;

	if (!m_pxnRoot.get())
	{
		//	Create the <?xml version="1.0"?> node and insert it
		//	into the document.
		//
		sc = m_pxb->ScAddTextBytes (gc_cchXmlVersion, gc_szXmlVersion);
		if (FAILED(sc))
			goto ret;

		sc = ScNewRootNode (pwszTag);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXMLEmitter::ScNewRootNode (LPCWSTR pwszTag)
{
	SCODE sc = S_OK;

	if (m_pxnRoot.get() == NULL)
	{
		//	Initialize the emitter's namespace cache
		//
		sc = ScInit();
		if (FAILED (sc))
			goto ret;

		//	Take this chance to initialize the local cache
		//
		if (!m_cacheLocal.FInit())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		if (m_pNmspcLoader)
		{
			//	Load all the document level namespaces
			//
			sc = m_pNmspcLoader->ScLoadNamespaces(this);
		}
		else
		{
			//	Load the default namespace
			//
			sc = ScPreloadNamespace (gc_wszDav);
		}
		if (FAILED(sc))
			goto ret;

		//	Create the node
		//
		m_pxnRoot.take_ownership (new CXNode (CXNode::XN_ELEMENT, m_pxb.get()));
		if (!m_pxnRoot.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Set the tag name
		//
		sc = m_pxnRoot->ScSetTag (this, static_cast<UINT>(wcslen(pwszTag)), pwszTag);
		if (FAILED (sc))
			goto ret;

		//	Namespace must have been populated before root node is created
		//
		Assert (S_OK == sc);

		//	It's time to add all the namespaces
		//
		{
			NmspcEmittingOp op (this, m_pxnRoot.get());
			m_cache.ForEach(op);
		}
	}

ret:
	return sc;
}

SCODE
CXMLEmitter::ScFindNmspc (LPCWSTR pwsz, UINT cch, auto_ref_ptr<CNmspc>& pns)
{
	Assert (pwsz);

	SCODE sc = S_OK;

	//	Emitter has two namespace cache, one is the docoument level cache
	//	for namespaces that span the whole XML body, and the other one is
	//	for namesapces that scopes on the current record only.
	//
	//	Look into the record level cache first
	//
	if (m_cacheLocal.CItems())
	{
		CRCWszN key(pwsz, cch);
		auto_ref_ptr<CNmspc>* parp;
		parp = m_cacheLocal.Lookup (key);
		if (NULL != parp)
		{
			pns = *parp;
			return S_OK;
		}
	}

	//	Try and find the namespace in the document's cache
	//
	sc = ScNmspcFromHref (pwsz, cch, pns);

	return sc;
}

SCODE
CXMLEmitter::ScPreloadNamespace (LPCWSTR pwszTag)
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	Assert (pwszTag);

	//	This must be done before root node is created
	//
	Assert (!m_pxnRoot.get());

	//	And should no local namespace yet
	//
	Assert (m_cacheLocal.CItems() == 0);

	//	Find the namespace separator
	//
	cch = CchNmspcFromTag (static_cast<UINT>(wcslen(pwszTag)), pwszTag, &pwsz);
	if (cch != 0)
	{
		//	Add to namespace cache
		//
		auto_ref_ptr<CNmspc> pns;
		sc = ScNmspcFromHref (pwszTag, cch, pns);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

//
//	CXMLEmitter::ScPreloadNamespace
//		Preload namespaces
SCODE
CXMLEmitter::ScPreloadLocalNamespace (CXNode * pxn, LPCWSTR pwszTag)
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	Assert (pwszTag);

	//	This must be done after root node is created
	//
	Assert (m_pxnRoot.get());

	//	Find the namespace separator
	//
	cch = CchNmspcFromTag (static_cast<UINT>(wcslen(pwszTag)), pwszTag, &pwsz);
	if (cch != 0)
	{
		auto_ref_ptr<CNmspc> pns;

		//	Add to namespace cache
		//
		sc = ScFindNmspc (pwszTag, cch, pns);
		if (FAILED (sc))
			goto ret;

		if (S_FALSE == sc)
		{
			//	It wasn't there, so if the root of the document has
			//	already been committed, then remove the name from the
			//	document cache and add it to the chunk cache.
			//
			CRCWszN key = IndexKey(pns);

			//	First, remove from the parent
			//
			Assert (NULL == m_cacheLocal.Lookup (key));
			m_cache.Remove (key);

			//	Looks like this is a new namespace to this
			//	chunk and needs to be cached.
			//
			if (!m_cacheLocal.FAdd (key, pns))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//	Emit this namespace
			//
			sc = ScAddNmspc (pns, pxn);
			if (FAILED(sc))
				goto ret;

			//	Regardless of whether or not this namespace was
			//	new to this chunk, we do not want it added to the
			//	document.  So we cannot return S_FALSE.
			//
			sc = S_OK;
		}
	}

ret:
	return sc;
}

//	CEmitterNode --------------------------------------------------------------
//
SCODE
CEmitterNode::ScConstructNode (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ CXNode* pxnParent,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = S_OK;

	//	Create the new node...
	//
	Assert (pxnParent);
	Assert (m_emitter.get() == NULL);
	sc = emitter.ScNewNode (CXNode::XN_ELEMENT, pwszTag, pxnParent, m_pxn);
	if (FAILED (sc))
		goto ret;

	XmlTrace ("XML: constructing node:\n-- tag: %ws\n", pwszTag);

	//	Set the value type if it existed
	//
	if (pwszType)
	{
		//	Create the namespace attribute
		//
		auto_ref_ptr<CXNode> pxnType;
		sc = m_pxn->ScGetChildNode (CXNode::XN_ATTRIBUTE, pxnType.load());
		if (FAILED(sc))
			goto ret;

		Assert (pxnType.get());
		XmlTrace ("-- type: %ws\n", pwszType);
		sc = emitter.ScAddAttribute (pxnType.get(),
									 gc_wszLexType,
									 gc_cchLexType,
									 pwszType,
									 static_cast<UINT>(wcslen(pwszType)));
		if (FAILED (sc))
			goto ret;

	}

	//	Set the value
	//		Value must be emitted after type
	//
	if (pwszValue)
	{
		XmlTrace ("-- value: %ws\n", pwszValue);
		sc = m_pxn->ScSetValue (pwszValue);
		if (FAILED (sc))
			goto ret;
	}

	//	Stuff the emitter into the node
	//
	m_emitter = &emitter;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = S_OK;

	//	Construct the node
	//
	Assert (m_emitter.get());
	sc = en.ScConstructNode (*m_emitter,
							 m_pxn.get(),
							 pwszTag,
							 pwszValue,
							 pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddMultiByteNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCSTR pszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = ScAddNode (pwszTag, en, NULL, pwszType);
	if (FAILED (sc))
		goto ret;

	Assert (pszValue);
	sc = en.Pxn()->ScSetValue (pszValue, static_cast<UINT>(strlen(pszValue)));
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddUTF8Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCSTR pszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = ScAddNode (pwszTag, en, NULL, pwszType);
	if (FAILED (sc))
		goto ret;

	Assert (pszValue);
	sc = en.Pxn()->ScSetUTF8Value (pszValue, static_cast<UINT>(strlen(pszValue)));
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddDateNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ FILETIME* pft,
	/* [in] */ CEmitterNode& en)
{
	SYSTEMTIME st;
	WCHAR rgwch[20];

	Assert (pft);
	if (!FileTimeToSystemTime (pft, &st))
	{
		//	In case the filetime is invalid, default to zero
		//
		FILETIME ftDefault = {0};
		FileTimeToSystemTime (&ftDefault, &st);
	}
	if (FGetDateIso8601FromSystime (&st, rgwch, sizeof(rgwch)))
	{
		return ScAddNode (pwszTag,
						  en,
						  rgwch,
						  gc_wszDavType_Date_ISO8601);
	}

	return W_DAV_XML_NODE_NOT_CONSTRUCTED;
}

SCODE
CEmitterNode::ScAddInt64Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ LARGE_INTEGER * pli,
	/* [in] */ CEmitterNode& en)
{
	WCHAR rgwch[20];

	Assert (pli);
	_ui64tow (pli->QuadPart, rgwch, 10);
	return ScAddNode (pwszTag, en, rgwch,gc_wszDavType_Int);
}

SCODE
CEmitterNode::ScAddBoolNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ BOOL f,
	/* [in] */ CEmitterNode& en)
{
	return ScAddNode (pwszTag,
					  en,
					  (f ? gc_wsz1 : gc_wsz0),
					  gc_wszDavType_Boolean);
}

SCODE
CEmitterNode::ScAddBase64Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ ULONG cb,
	/* [in] */ LPVOID pv,
	/* [in] */ CEmitterNode& en,
	/* [in] */ BOOL fSupressType,
	/* [in] */ BOOL fUseBinHexIfNoValue)
{
	auto_heap_ptr<WCHAR> pwszBuf;
	Assert (pwszTag);
	Assert (pv);

	//	If they didn't request type supression, then label this node
	//	with the correct type -- bin.base64
	//
	LPCWSTR pwszType;

	if (fSupressType)
	{
		pwszType = NULL;
	}
	else
	{
		//	If fUseBinHexIfNoValue is TRUE AND cb = 0, then use "bin.hex"
		//	as the type rather than bin.base64.  This is to handle WebFolders (shipped Office9)
		//	which doesn't seem to handle 0 length bin.base64 properties correctly
		//	(fails).
		//
		if (fUseBinHexIfNoValue && (0 == cb))
			pwszType = gc_wszDavType_Bin_Hex;
		else
			pwszType = gc_wszDavType_Bin_Base64;
	}

	if (cb)
	{
		//	Allocate a buffer big enough for the entire encoded string.
		//	Base64 uses 4 chars out for each 3 bytes in, AND if there is ANY
		//	"remainder", it needs another 4 chars to encode the remainder.
		//	("+2" BEFORE "/3" ensures that we count any remainder as a whole
		//	set of 3 bytes that need 4 chars to hold the encoding.)
		//	We also need one char for terminal NULL of our string --
		//	CbSizeWsz takes care of that for the alloc, and we explicitly pass
		//	cchBuf+1 for the call to EncodeBase64.
		//
		ULONG cchBuf = CchNeededEncodeBase64 (cb);
		pwszBuf = static_cast<LPWSTR>(ExAlloc(CbSizeWsz(cchBuf)));
		EncodeBase64 (reinterpret_cast<BYTE*>(pv), cb, pwszBuf, cchBuf + 1);
	}
	return ScAddNode (pwszTag, en, pwszBuf, pwszType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\cnvt.cpp ===
/*
 *	C N V T . C P P
 *
 *	Data conversion routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
#include <string.h>
#include <stdio.h>

//	Month names ---------------------------------------------------------------
//
DEC_CONST LPCWSTR c_rgwszMonthNames[] =
{
	L"Jan",
	L"Feb",
	L"Mar",
	L"Apr",
	L"May",
	L"Jun",
	L"Jul",
	L"Aug",
	L"Sep",
	L"Oct",
	L"Nov",
	L"Dec",
};
DEC_CONST ULONG c_cMonthNames = CElems(c_rgwszMonthNames);
DEC_CONST ULONG c_cchMonthName = 3;

DEC_CONST LPCWSTR c_rgwszDayNames[] =
{
	L"Sun",
	L"Mon",
	L"Tue",
	L"Wed",
	L"Thu",
	L"Fri",
	L"Sat",
};
DEC_CONST UINT c_cDayNames = CElems(c_rgwszDayNames);
DEC_CONST UINT c_cchDayName = 3;

//	Date formats --------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszIso8601_min[]			= L"yyyy-mm-ddThh:mm:ssZ";
DEC_CONST UINT	gc_cchIso8601_min			= CchConstString(gc_wszIso8601_min);
DEC_CONST WCHAR gc_wszIso8601_scanfmt[]		= L"%04hu-%02hu-%02huT%02hu:%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_tz_scanfmt[]	= L"%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_fmt[]			= L"%04d-%02d-%02dT%02d:%02d:%02d.%03dZ";
DEC_CONST WCHAR gc_wszRfc1123_min[]			= L"www, dd mmm yyyy hh:mm:ss GMT";
DEC_CONST UINT	gc_cchRfc1123_min			= CchConstString (gc_wszRfc1123_min);
DEC_CONST WCHAR gc_wszRfc1123_fmt[] 		= L"%ls, %02d %ls %04d %02d:%02d:%02d GMT";

enum {
	tf_year,
	tf_month,
	tf_day,
	tf_hour,
	tf_minute,
	tf_second,
	cTimeFields,

	tz_hour = 0,
	tz_minute,
	cTzDeltaFields,

	RADIX_BASE = 10,
};

//	Conversion functions ------------------------------------------------------
//
/*
 *	CchFindChar
 *
 *	Look for the given char, obeying the cbMax limit.
 *	If the char is not found, return INVALID_INDEX.
 */
UINT __fastcall
CchFindChar(WCHAR wch, LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   wch != *pwszData)
	{
		cchParsed++;
		pwszData++;
	}

	if (cchParsed == cchMax)
		cchParsed = INVALID_INDEX;
	return cchParsed;
}

/*
 *	CchSkipWhitespace
 *
 *	Skips whitespace, obeying the cbMax limit.
 *	Returns the number of bytes parsed.
 */
UINT __fastcall
CchSkipWhitespace(LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   (L' ' == *pwszData ||
			L'\t' == *pwszData ||
			L'\n' == *pwszData ||
			L'\r' == *pwszData))
	{
		cchParsed++;
		pwszData++;
	}
	return cchParsed;
}

LONG __fastcall
LNumberFromParam(LPCWSTR pwszData, UINT cchMax)
{
	LONG lReturn = 0;
	UINT cchCurrent = 0;
	BOOL fNegative = FALSE;

	// Get any sign char.
	//
	if (L'-' == *pwszData)
	{
		// Set the negative flag to true.
		//
		fNegative = TRUE;

		// Skip this valid character.
		//
		cchCurrent++;

		// Skip any whitespace.
		//
		cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
	}
	else if (L'+' == *pwszData)
	{
		// Skip any whitespace.
		//
		cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
	}

	// From here, any non-number chars are invalid & mean we
	// should stop parsing.

	// Get the magnitude of the number.
	//
	while (cchCurrent < cchMax)
	{
		if (L'0' <= static_cast<USHORT>(pwszData[cchCurrent]) &&
		    L'9' >= static_cast<USHORT>(pwszData[cchCurrent]))
		{
			lReturn *= 10;
			lReturn += (pwszData[cchCurrent] - L'0');
		}
		else
		{
			// Not a number char.  Time to quit parsing.
			//
			break;
		}

		// Move to the next char.
		//
		cchCurrent++;
	}

	// Apply the negative sign, if any.
	//
	if (fNegative)
		lReturn = (0 - lReturn);

	return lReturn;
}

HRESULT __fastcall
HrHTTPDateToFileTime(LPCWSTR pwszDate,
					 FILETIME * pft)
{
	HRESULT		hr;
	SYSTEMTIME	systime;
	UINT		cchDate;

	//	Make sure we were passed something as a date string.
	//
	Assert(pwszDate);
	Assert(pft);

	//	Zero out the structure.
	//
	memset(&systime, 0, sizeof(SYSTEMTIME));

	//	Get the length of the date string.
	//
	cchDate = static_cast<UINT>(wcslen(pwszDate));

	//	Get the date and time pieces.  If either fails, return its
	//	error code.  Otherwise, convert to a file time at the end,
	//	return E_FAIL if the conversion fails, S_OK otherwise.
	//
	hr = GetFileDateFromParam(pwszDate,
							  cchDate,
							  &systime);
	if (FAILED(hr))
		return hr;

	hr = GetFileTimeFromParam(pwszDate,
							  cchDate,
							  &systime);

	if (FAILED(hr))
		return hr;

	if (!SystemTimeToFileTime(&systime, pft))
		return E_FAIL;

	return S_OK;
}


HRESULT __fastcall
GetFileDateFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;

	// If the first char's of the date are ddd, then the day of the
	// week is a part of the date, and we really do not care.
	//
	if (L'9' < static_cast<USHORT>(*pwszCurrent))
	{
		// Find the day
		//
		UINT uiDay;
		for (uiDay = 0; uiDay < c_cDayNames; uiDay++)
		{
			// Compare the month names.
			//
			if (*pwszCurrent == *(c_rgwszDayNames[uiDay]) &&
				!_wcsnicmp(pwszCurrent, c_rgwszDayNames[uiDay], c_cchDayName))
			{
				// Found the right month.  This index tells us the month number.
				//
				psystime->wDayOfWeek = static_cast<WORD>(uiDay);  // Sunday is 0
				break;
			}
		}
		if (uiDay == c_cDayNames)
			return E_FAIL;

		// Look for our space delimiter.
		//
		cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
		if (INVALID_INDEX == cchTemp)
		{
			// Invalid format to this data. Fail here.
			//
			return E_FAIL;
		}
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;

		// Again, skip whitespace.
		//
		cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;
	}

	// The date format is dd month yyyy.  Anything else is invalid.

	// Get the day-of-the-month number.
	//
	psystime->wDay = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Find the month number.
	//
	for (UINT uiMonth = 0; uiMonth < c_cMonthNames; uiMonth++)
	{
		// Compare the month names.
		//
		if (*pwszCurrent == *(c_rgwszMonthNames[uiMonth]) &&
			!_wcsnicmp(pwszCurrent, c_rgwszMonthNames[uiMonth], c_cchMonthName))
		{
			// Found the right month.  This index tells us the month number.
			//
			psystime->wMonth = static_cast<WORD>(uiMonth + 1);  // January is 1.
			break;
		}
	}

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Now get the year.
	//
	psystime->wYear = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	return S_OK;
}

HRESULT __fastcall
GetFileTimeFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;

	// Skip any date information.  This could get called for date-time params!

	// Look for the first colon delimiter. Yes, we assume no colons in date info!
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No time info available. Fail here.
		//
		return E_FAIL;
	}
	cchTemp--;		// Back up to get the hours digits.
	cchTemp--;
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Skip whitespace (in case the parm is h:mm:ss).
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Time format is hh:mm:ss UT, GMT, +- hh:mm, anything else is invalid.
	// (Actually, we allow [h]h:mm[:ss], and whitespace around the colons.)

	// Get the hours.
	//
	psystime->wHour = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No minutes specified.  This is not allowed.  Fail here.
		//
		return E_FAIL;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Get the minutes.
	//
	psystime->wMinute = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// NOTE: The seconds are optional.  Don't fail here!

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No seconds specified.  This is allowed.  Return success.
		//
		return S_OK;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;

	// Get the seconds, if any.
	//
	psystime->wSecond = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// LATER: Get the timezone spec from the line and shift this data into our timezone...

	return S_OK;
}

BOOL __fastcall
FGetSystimeFromDateIso8601(LPCWSTR pwszDate, SYSTEMTIME * psystime)
{
	UINT i;

	// 	Iso8601 is a fixed digit format: "yyyy-mm-ddThh:mm:ssZ"
	//	we require the date strings has at least the required
	//	chars (we allow for the ommission of the fractional
	//	seconds, and the time delta), otherwise it is an error.
	//
	if (gc_cchIso8601_min > static_cast<UINT>(wcslen(pwszDate)))
	{
		DebugTrace ("Dav: date length < than minimal\n");
		return FALSE;
	}

	//	Scan the first bit of date information up to the
	//	optional bits
	//
	psystime->wMilliseconds = 0;
	if (cTimeFields != swscanf (pwszDate,
								gc_wszIso8601_scanfmt,
								&psystime->wYear,
								&psystime->wMonth,
								&psystime->wDay,
								&psystime->wHour,
								&psystime->wMinute,
								&psystime->wSecond))
	{
		DebugTrace ("Dav: minimal scan failed\n");
		return FALSE;
	}

	//	Take a look at what is next and process accordingly.
	//
	//	('Z'), ('.'), ('+') and ('-').
	//
	//	The ('Z') element signifies ZULU time and completes
	//	the time string.  The ('.') element signifies that a
	//	fractional second value follows.  And either a ('+')
	//	or ('-') element indicates that a timezone delta will
	//	follow.
	//
	i = gc_cchIso8601_min - 1;
	if (pwszDate[i] == L'Z')
		goto ret;
	else if (pwszDate[i] == L'.')
		goto frac_sec;
	else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'+'))
		goto tz_delta;

	DebugTrace ("Dav: minimal date not terminated properly\n");
	return FALSE;

frac_sec:

	Assert (pwszDate[i] == L'.');
	{
		UINT iFrac;

		for (iFrac = ++i; pwszDate[i]; i++)
		{
			//	Any non-digit terminates the fractional seconds time
			//
			if ((pwszDate[i] > L'9') || (pwszDate[i] < L'0'))
			{
				//	At this point, we are expecting ('Z') or a timezone
				//	delta ('+') or ('-')
				//
				if (pwszDate[i] == L'Z')
					goto ret;
				else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'))
					goto tz_delta;

				break;
			}

			//	It turns out, our granularity is only milliseconds, so
			//	we cannot keep any better precision than that.  However,
			//	we can round the last digit, so at best we will process
			//	the next four digits
			//
			if (i - iFrac < 3)
			{
				//	As many digits remain, comprise the fractional
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds * RADIX_BASE + (pwszDate[i]-L'0'));
			}
			else if (i - iFrac < 4)
			{
				//	Our granularity is only milliseconds, so we cannot keep
				//	any better precision than that.  However, we can round this
				//	digit.
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds + (((pwszDate[i]-L'0')>4)?1:0));
			}
		}

		//	We ran out of string before the time was terminated
		//
		return FALSE;
	}

tz_delta:

	Assert ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'));
	{
		WORD wHr;
		WORD wMin;
		__int64 tm;
		__int64 tzDelta;
		static const __int64 sc_i64Min = 600000000;
		static const __int64 sc_i64Hr = 36000000000;
		FILETIME ft;

		//	Find the time delta in terms of FILETIME units
		//
		if (cTzDeltaFields != swscanf (pwszDate + i + 1,
									   gc_wszIso8601_tz_scanfmt,
									   &wHr,
									   &wMin))
		{
			DebugTrace ("Dav: tz delta scan failed\n");
			return FALSE;
		}
		tzDelta = (sc_i64Hr * wHr) + (sc_i64Min * wMin);

		//	Convert the time into a FILETIME, and stuff it into
		//	a 64bit integer
		//
		if (!SystemTimeToFileTime (psystime, &ft))
		{
			DebugTrace ("Dav: invalid time specified\n");
			return FALSE;
		}
		tm = FileTimeCastToI64(ft);

		//	Apply the delta
		//
		if (pwszDate[i] == L'+')
			tm = tm + tzDelta;
		else
		{
			Assert (pwszDate[i] == L'-');
			tm = tm - tzDelta;
		}

		//	Return the value converted back into a SYSTEMTIME
		//
		ft = I64CastToFileTime(tm);
		if (!FileTimeToSystemTime (&ft, psystime))
		{
			DebugTrace ("Dav: delta invalidated time\n");
			return FALSE;
		}
	}

ret:

	return TRUE;
}

BOOL __fastcall
FGetDateIso8601FromSystime(SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchIso8601_min >= cchSize)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszIso8601_fmt,
						 psystime->wYear,
						 psystime->wMonth,
						 psystime->wDay,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond,
						 psystime->wMilliseconds));
}

BOOL __fastcall
FGetDateRfc1123FromSystime (SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchRfc1123_min >= cchSize)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszRfc1123_fmt,
						 c_rgwszDayNames[psystime->wDayOfWeek],
						 psystime->wDay,
						 c_rgwszMonthNames[psystime->wMonth - 1],
						 psystime->wYear,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond));
}

//	BCharToHalfByte -----------------------------------------------------------
//
//	Switches a wide char to a half-byte hex value.  The incoming char
//	MUST be in the "ASCII-encoded hex digit" range: 0-9, A-F, a-f.
//
DEC_CONST BYTE gc_mpbchCharToHalfByte[] = {

	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,	0x8,0x9,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Caps here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Lowercase here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

inline BYTE BCharToHalfByte(WCHAR ch)
{
	//	gc_mpbchCharToHalfByte - map a ASCII-encoded char representing a single hex
	//	digit to a half-byte value.  Used to convert hex represented strings into a
	//	binary representation.
	//
	//	Reference values:
	//
	//		'0' = 49, 0x31;
	//		'A' = 65, 0x41;
	//		'a' = 97, 0x61;
	//
    AssertSz (!(ch & 0xFF00), "BCharToHalfByte: char upper bits non-zero");
    AssertSz (iswxdigit(ch), "Char out of hex digit range.");

    return gc_mpbchCharToHalfByte[ch];
}

//	------------------------------------------------------------------------
//	c_mpwchbStringize - map a half-byte (low nibble) value to
//		the correspoding ASCII-encoded wide char.
//	Used to convert binary data into Unicode URL strings.
//
DEC_CONST WCHAR c_mpwchhbStringize[] =
{
	L'0', L'1', L'2', L'3',
	L'4', L'5', L'6', L'7',
	L'8', L'9', L'a', L'b',
	L'c', L'd', L'e', L'f',
};

//	------------------------------------------------------------------------
//	WchHalfByteToWideChar
//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline WCHAR WchHalfByteToWideChar(BYTE b)
{
	AssertSz(!(b & 0xF0), "Garbage in upper nibble.");
	return c_mpwchhbStringize[b];
};

//	==========================================================================
//
//	UTILITY FUNCTIONS
//		Used in building some props -- like getetag, resourcetag and flat url.
//		This code has been moved from calcprops.cpp to exprops.cpp and now to
//		cnvt.cpp. The Flat URL code lives in this file because it is needed
//		by _storext, exdav and davex. _props is the other component which is
//		shared by all of them. But _cnvt seemed like a better place to put
//		it. The other utility functions are needed by the flat url generation
//		code and by davex in processing parameterized URLs.
//
//	==========================================================================

//	------------------------------------------------------------------------
//	Un-stringiz-ing support functions
//	(Stringize = dump a binary blob to a string.
//	Unstringize = make it a binary blob again.)
//
inline
void
AssertCharInHexRange (char ch)
{
	Assert ((ch >= '0' && ch <= '9') ||
			(ch >= 'A' && ch <= 'F') ||
			(ch >= 'a' && ch <= 'f'));
}

inline
BYTE
NibbleFromChar (char ch)
{
	//	Assumes data is already in range....
	//
	return static_cast<BYTE>((ch <= '9')
							 ? ch - '0'
							 : ((ch >= 'a')
								? ch - 'W'		// 'W' = 'a' - 0xa
								: ch - '7'));	// '7' = 'A' - 0xa
}

inline
BYTE
ByteFromTwoChars (char chLow, char chHigh)
{
	BYTE nibbleLow;
	BYTE nibbleHigh;

	nibbleLow = NibbleFromChar(chLow);
	nibbleHigh = NibbleFromChar(chHigh);

	return static_cast<BYTE>(nibbleLow | (nibbleHigh << 4));
}

//$REVIEW: The following two functions really does not belong to any common libraries
//$REVIEW: that are shared by davex, exdav and exoledb. (other options are _prop, _sql)
//$REVIEW: On the other hand, we definitely don't want add a new lib for this. so just
//$REVIEW: add it here. Feel free to move them to a better location if you find one
//
//	------------------------------------------------------------------------
//
//	ScDupPsid()
//
//	Copies a SID properly (using CopySid()) into a heap-allocated buffer
//	that is returned to the caller.  The caller must free the buffer when
//	it is done using it.
//
SCODE
ScDupPsid (PSID psidSrc,
		   DWORD dwcbSID,
		   PSID * ppsidDst)
{
	PSID psidDst;

	Assert (psidSrc);
	Assert (IsValidSid(psidSrc));
	Assert (GetLengthSid(psidSrc) == dwcbSID);

	psidDst = static_cast<PSID>(ExAlloc(dwcbSID));
	if (!psidDst)
	{
		DebugTrace ("ScDupPsid() - OOM allocating memory for dup'd SID\n");
		return E_OUTOFMEMORY;
	}

	//	"Right way" -- since MSDN says not to touch the SID directly.
	if (!CopySid (dwcbSID, psidDst, psidSrc))
	{
		DWORD dwLastError = GetLastError();

		DebugTrace ("ScDupPsid() - CopySid() failed %d\n", dwLastError);
		ExFree (psidDst);
		return HRESULT_FROM_WIN32(dwLastError);
	}

	*ppsidDst = psidDst;

	return S_OK;
}

//	------------------------------------------------------------------------
//
//	ScGetTokenInfo()
//
//	Extracts a user's security ID (SID) from a security token.  Returns the SID
//	in a heap-allocated buffer which the caller must free.
//
SCODE
ScGetTokenInfo (HANDLE hTokenUser,
				DWORD * pdwcbSIDUser,
				PSID * ppsidUser)
{
	CStackBuffer<TOKEN_USER> pTokenUser;
	DWORD dwcbTokenUser = pTokenUser.size(); //$OPT What is a good initial guess?

	Assert (pdwcbSIDUser);
	Assert (ppsidUser);

	//	Fetch the token info into local memory.  GetTokenInformation()
	//	returns the size of the buffer needed if the one passed in is
	//	not large enough so this loop should execute no more than twice.
	//
#ifdef DBG
	for ( UINT iPass = 0;
		  (Assert (iPass < 2), TRUE);
		  ++iPass )
#else
	for ( ;; )
#endif
	{
		if (NULL == pTokenUser.resize(dwcbTokenUser))
			return E_OUTOFMEMORY;

		if (GetTokenInformation (hTokenUser,
								 TokenUser,
								 pTokenUser.get(),
								 dwcbTokenUser,
								 &dwcbTokenUser))
		{
			break;
		}
		else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	//	Dup and return the SID from the token info.
	//
	*pdwcbSIDUser = GetLengthSid(pTokenUser->User.Sid);
	return ScDupPsid (pTokenUser->User.Sid,
					  *pdwcbSIDUser,
					  ppsidUser);
}


//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	It returns similarly to the system call WideCharToMultiByte:
//
//	If the function succeeds, and cbDest is nonzero, the return value is
//	the number of bytes written to the buffer pointed to by psz.
//
//	If the function succeeds, and cbDest is zero, the return value is
//	the required size, in bytes, for a buffer that can receive the translated
//	string.
//
//	If the function fails, the return value is zero. To get extended error
//	information, call GetLastError. GetLastError may return one of the
//	following error codes:
//
//	ERROR_INSUFFICIENT_BUFFER
//	ERROR_INVALID_FLAGS
//	ERROR_INVALID_PARAMETER
//
//	See the WideCharToMultiByte MSDN pages to find out more about
//	this function and its use.
//
UINT WideCharToUTF8(/* [in]  */ LPCWSTR	pwszSrc,
				    /* [in]  */ UINT	cchSrc,
				    /* [out] */ LPSTR	pszDest,
				    /* [in]  */ UINT	cbDest)
{
	//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
	//	more info.
	//
	//		Unicode value    1st byte    2nd byte    3rd byte
	//		000000000xxxxxxx 0xxxxxxx
	//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
	//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
	//

	//	If cbDest == 0 is passed in then we should only calculate the length
	//	needed, not use the "pszDest" parameter.
	//
	BOOL	fCalculateOnly = FALSE;

	//	(comment from nt\private\windows\winnls\mbcs.c, corrected for accuracy):
	//  Invalid Parameter Check:
	//     - length of WC string is 0
	//     - multibyte buffer size is negative
	//     - WC string is NULL
	//     - length of MB string is NOT zero AND
	//         (MB string is NULL OR src and dest pointers equal)
	//
	if ( (cchSrc == 0) ||
		 (pwszSrc == NULL) ||
		 ((cbDest != 0) &&
		  ((pszDest == NULL) ||
		   (reinterpret_cast<VOID *>(pszDest) ==
			reinterpret_cast<VOID *>(const_cast<LPWSTR>(pwszSrc))))) )
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return 0;
	}

#ifdef DBG
	//	Check our parameters.  We must be given a non-NULL pwszSrc.
	//
	Assert(pwszSrc);

	//	Make sure we have a valid string.
	//
	Assert(!IsBadStringPtrW(pwszSrc, (INVALID_INDEX == cchSrc) ? INFINITE : cchSrc));

	//	If the user says that the length of the multi-byte string is non-Zero,
	//	we must be given a non-NULL pszDest.  We'll also check it with IsBadWritePtr().
	//
	if (cbDest)
	{
		Assert(pszDest);
		Assert(!IsBadWritePtr(pszDest, cbDest));
	}
#endif

	//	If -1 is passed in as the length of the string, then we calculate the
	//	length of the string on the fly, and include the NULL terminator.
	//
	if (INVALID_INDEX == cchSrc)
		cchSrc = static_cast<UINT>(wcslen(pwszSrc) + 1);

	//	If 0 is passed in as cbDest, then we calculate the length of the
	//	buffer that would be needed to convert the string.  We ignore the
	//	pszDest parameter in this case.
	//
	if (0 == cbDest)
		fCalculateOnly = TRUE;

	UINT ich = 0;
	UINT iwch = 0;
	for (; iwch < cchSrc; iwch++)
	{
		WCHAR wch = pwszSrc[iwch];
		//
		//	Single-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		000000000xxxxxxx 0xxxxxxx
		//
		if (wch < 0x80)
		{
			if (!fCalculateOnly)
			{
				if (ich >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich] = static_cast<BYTE>(wch);
			}
			ich++;
		}
		//
		//	Double-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
		//
		else if (wch < 0x800)
		{
			if (!fCalculateOnly)
			{
				if ((ich + 1) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 6) | 0xC0);
				pszDest[ich + 1]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 2;
		}
		//
		//	Triple-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
		//
		else
		{
			if (!fCalculateOnly)
			{
				if ((ich + 2) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 12) | 0xE0);
				pszDest[ich + 1]	= static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
				pszDest[ich + 2]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 3;
		}
	}

	return ich;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\_xmllib.cpp ===
/*
 *	_ X M L L I B . C P P
 *
 *	Precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\_xmllib.h ===
/*
 *	_ X M L L I B . H
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__XMLLIB_H_
#define __XMLLIB_H_

//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <oledberr.h>
#include <limits.h>

#pragma warning(disable:4100)	//	unref formal parameter
#pragma warning(disable:4200)	//	non-standard extension
#pragma warning(disable:4201)	//	non-standard extension
#pragma warning(disable:4710)	//	unexpanded c++ methods

#include <ex\refcnt.h>
#include <ex\nmspc.h>
#include <ex\xml.h>
#include <ex\xmldata.h>
#include <ex\xprs.h>
#include <ex\cnvt.h>

#include <ex\atomcache.h>
#include <ex\xemit.h>

DEC_CONST WCHAR gc_wszNamespaceGuid[] = L"{xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb}";

#endif	// __XMLLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xprs.cpp ===
/*
 *	X P R S . C P P
 *
 *	XML push model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

#define IID_INodeFactory	__uuidof(INodeFactory)
#define IID_IXMLParser		__uuidof(IXMLParser)

//	Debugging: Node types -----------------------------------------------------
//
DEC_CONST WCHAR gc_wszUnknown[] = L"UNKNOWN";

#define WszNodeType(_t)		{_t,L#_t}
typedef struct _NodeTypeMap {

	DWORD		dwType;
	LPCWSTR		wszType;

} NTM;

#ifdef	DBG
const NTM gc_mpnt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XML_ELEMENT),
	WszNodeType(XML_ATTRIBUTE),
	WszNodeType(XML_PI),
	WszNodeType(XML_XMLDECL),
	WszNodeType(XML_DOCTYPE),
	WszNodeType(XML_DTDATTRIBUTE),
	WszNodeType(XML_ENTITYDECL),
	WszNodeType(XML_ELEMENTDECL),
	WszNodeType(XML_ATTLISTDECL),
	WszNodeType(XML_NOTATION),
	WszNodeType(XML_GROUP),
	WszNodeType(XML_INCLUDESECT),
	WszNodeType(XML_PCDATA),
	WszNodeType(XML_CDATA),
	WszNodeType(XML_IGNORESECT),
	WszNodeType(XML_COMMENT),
	WszNodeType(XML_ENTITYREF),
	WszNodeType(XML_WHITESPACE),
	WszNodeType(XML_NAME),
	WszNodeType(XML_NMTOKEN),
	WszNodeType(XML_STRING),
	WszNodeType(XML_PEREF),
	WszNodeType(XML_MODEL),
	WszNodeType(XML_ATTDEF),
	WszNodeType(XML_ATTTYPE),
	WszNodeType(XML_ATTPRESENCE),
	WszNodeType(XML_DTDSUBSET),
	WszNodeType(XML_LASTNODETYPE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszNodeType (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpnt); i++)
		if (gc_mpnt[i].dwType == dwType)
			return gc_mpnt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Debugging: Sub-node Types -------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpsnt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(0),
	WszNodeType(XML_VERSION),
	WszNodeType(XML_ENCODING),
	WszNodeType(XML_STANDALONE),
	WszNodeType(XML_NS),
	WszNodeType(XML_XMLSPACE),
	WszNodeType(XML_XMLLANG),
	WszNodeType(XML_SYSTEM),
	WszNodeType(XML_PUBLIC),
	WszNodeType(XML_NDATA),
	WszNodeType(XML_AT_CDATA),
	WszNodeType(XML_AT_ID),
	WszNodeType(XML_AT_IDREF),
	WszNodeType(XML_AT_IDREFS),
	WszNodeType(XML_AT_ENTITY),
	WszNodeType(XML_AT_ENTITIES),
	WszNodeType(XML_AT_NMTOKEN),
	WszNodeType(XML_AT_NMTOKENS),
	WszNodeType(XML_AT_NOTATION),
	WszNodeType(XML_AT_REQUIRED),
	WszNodeType(XML_AT_IMPLIED),
	WszNodeType(XML_AT_FIXED),
	WszNodeType(XML_PENTITYDECL),
	WszNodeType(XML_EMPTY),
	WszNodeType(XML_ANY),
	WszNodeType(XML_MIXED),
	WszNodeType(XML_SEQUENCE),
	WszNodeType(XML_CHOICE),
	WszNodeType(XML_STAR),
	WszNodeType(XML_PLUS),
	WszNodeType(XML_QUESTIONMARK),
	WszNodeType(XML_LASTSUBNODETYPE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszSubnodeType (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpsnt); i++)
		if (gc_mpsnt[i].dwType == dwType)
			return gc_mpsnt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Debugging: Events ---------------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpevt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XMLNF_STARTDOCUMENT),
	WszNodeType(XMLNF_STARTDTD),
	WszNodeType(XMLNF_ENDDTD),
	WszNodeType(XMLNF_STARTDTDSUBSET),
	WszNodeType(XMLNF_ENDDTDSUBSET),
	WszNodeType(XMLNF_ENDPROLOG),
	WszNodeType(XMLNF_STARTENTITY),
	WszNodeType(XMLNF_ENDENTITY),
	WszNodeType(XMLNF_ENDDOCUMENT),
	WszNodeType(XMLNF_DATAAVAILABLE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszEvent (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpevt); i++)
		if (gc_mpevt[i].dwType == dwType)
			return gc_mpevt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Error codes ---------------------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpec[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XML_E_ENDOFINPUT),
	WszNodeType(XML_E_UNCLOSEDPI),
	WszNodeType(XML_E_MISSINGEQUALS),
	WszNodeType(XML_E_UNCLOSEDSTARTTAG),
	WszNodeType(XML_E_UNCLOSEDENDTAG),
	WszNodeType(XML_E_UNCLOSEDSTRING),
	WszNodeType(XML_E_MISSINGQUOTE),
	WszNodeType(XML_E_COMMENTSYNTAX),
	WszNodeType(XML_E_UNCLOSEDCOMMENT),
	WszNodeType(XML_E_BADSTARTNAMECHAR),
	WszNodeType(XML_E_BADNAMECHAR),
	WszNodeType(XML_E_UNCLOSEDDECL),
	WszNodeType(XML_E_BADCHARINSTRING),
	WszNodeType(XML_E_XMLDECLSYNTAX),
	WszNodeType(XML_E_BADCHARDATA),
	WszNodeType(XML_E_UNCLOSEDMARKUPDECL),
	WszNodeType(XML_E_UNCLOSEDCDATA),
	WszNodeType(XML_E_MISSINGWHITESPACE),
	WszNodeType(XML_E_BADDECLNAME),
	WszNodeType(XML_E_BADEXTERNALID),
	WszNodeType(XML_E_EXPECTINGTAGEND),
	WszNodeType(XML_E_BADCHARINDTD),
	WszNodeType(XML_E_BADELEMENTINDTD),
	WszNodeType(XML_E_BADCHARINDECL),
	WszNodeType(XML_E_MISSINGSEMICOLON),
	WszNodeType(XML_E_BADCHARINENTREF),
	WszNodeType(XML_E_UNBALANCEDPAREN),
	WszNodeType(XML_E_EXPECTINGOPENBRACKET),
	WszNodeType(XML_E_BADENDCONDSECT),
	WszNodeType(XML_E_RESERVEDNAMESPACE),
	WszNodeType(XML_E_INTERNALERROR),
	WszNodeType(XML_E_EXPECTING_VERSION),
	WszNodeType(XML_E_EXPECTING_ENCODING),
	WszNodeType(XML_E_EXPECTING_NAME),
	WszNodeType(XML_E_UNEXPECTED_WHITESPACE),
	WszNodeType(XML_E_UNEXPECTED_ATTRIBUTE),
	WszNodeType(XML_E_SUSPENDED),
	WszNodeType(XML_E_STOPPED),
	WszNodeType(XML_E_UNEXPECTEDENDTAG),
	WszNodeType(XML_E_ENDTAGMISMATCH),
	WszNodeType(XML_E_UNCLOSEDTAG),
	WszNodeType(XML_E_DUPLICATEATTRIBUTE),
	WszNodeType(XML_E_MULTIPLEROOTS),
	WszNodeType(XML_E_INVALIDATROOTLEVEL),
	WszNodeType(XML_E_BADXMLDECL),
	WszNodeType(XML_E_INVALIDENCODING),
	WszNodeType(XML_E_INVALIDSWITCH),
	WszNodeType(XML_E_MISSINGROOT),
	WszNodeType(XML_E_INCOMPLETE_ENCODING),
	WszNodeType(XML_E_EXPECTING_NDATA),
	WszNodeType(XML_E_INVALID_MODEL),
	WszNodeType(XML_E_BADCHARINMIXEDMODEL),
	WszNodeType(XML_E_MISSING_STAR),
	WszNodeType(XML_E_BADCHARINMODEL),
	WszNodeType(XML_E_MISSING_PAREN),
	WszNodeType(XML_E_INVALID_TYPE),
	WszNodeType(XML_E_INVALIDXMLSPACE),
	WszNodeType(XML_E_MULTI_ATTR_VALUE),
	WszNodeType(XML_E_INVALID_PRESENCE),
	WszNodeType(XML_E_BADCHARINENUMERATION),
	WszNodeType(XML_E_UNEXPECTEDEOF),
	WszNodeType(XML_E_BADPEREFINSUBSET),
	WszNodeType(XML_E_BADXMLCASE),
	WszNodeType(XML_E_CONDSECTINSUBSET),
	WszNodeType(XML_E_CDATAINVALID),
	WszNodeType(XML_E_INVALID_STANDALONE),
	WszNodeType(XML_E_PE_NESTING),
	WszNodeType(XML_E_UNEXPECTED_STANDALONE),
	WszNodeType(XML_E_DOCTYPE_IN_DTD),
	WszNodeType(XML_E_INVALID_CDATACLOSINGTAG),
	WszNodeType(XML_E_PIDECLSYNTAX),
	WszNodeType(XML_E_EXPECTINGCLOSEQUOTE),
	WszNodeType(XML_E_DTDELEMENT_OUTSIDE_DTD),
	WszNodeType(XML_E_DUPLICATEDOCTYPE),
	WszNodeType(XML_E_MISSING_ENTITY),
	WszNodeType(XML_E_ENTITYREF_INNAME),
	WszNodeType(XML_E_DOCTYPE_OUTSIDE_PROLOG),
	WszNodeType(XML_E_INVALID_VERSION),
	WszNodeType(XML_E_MULTIPLE_COLONS),
	WszNodeType(XML_E_INVALID_DECIMAL),
	WszNodeType(XML_E_INVALID_HEXIDECIMAL),
	WszNodeType(XML_E_INVALID_UNICODE),
	WszNodeType(XML_E_RESOURCE),
	WszNodeType(XML_E_LASTERROR)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszErrorCode (SCODE sc)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpec); i++)
		if (gc_mpec[i].dwType == static_cast<DWORD>(sc))
			return gc_mpec[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

void __fastcall
XmlTraceNodeInfo (const XML_NODE_INFO * pNodeInfo)
{
#ifdef	DBG

	CStackBuffer<WCHAR,MAX_PATH> pwsz(CbSizeWsz(pNodeInfo->ulLen));
	if (NULL != pwsz.get())
    {
        wcsncpy(pwsz.get(), pNodeInfo->pwcText, pNodeInfo->ulLen);
        pwsz[pNodeInfo->ulLen] = 0;
    }
    else
	{
		XmlTrace ("XML: WARNING: not enough memory to trace\n");
		return;
	}

    //	_XML_NODE_INFO
    //
    //	typedef struct  _XML_NODE_INFO	{
    //
    //		DWORD dwType;
    //		DWORD dwSubType;
    //		BOOL fTerminal;
    //		WCHAR __RPC_FAR *pwcText;
    //		ULONG ulLen;
    //		ULONG ulNsPrefixLen;
    //		PVOID pNode;
    //		PVOID pReserved;
    //
    //	} XML_NODE_INFO;
	//
    XmlTrace ("- pNodeInfo:\n"
              "--  dwSize: %ld bytes\n"
              "--  dwType: %ws (0x%08X)\n"
              "--  dwSubType: %ws (0x%08X)\n"
              "--  fTerminal: %ld\n"
              "--  pwcText: '%ws'\n"
              "--  ulLen: %ld (0x%08X)\n"
              "--  ulNsPrefixLen: %ld (0x%08X)\n"
              "--  pNode: 0x%08X\n"
              "--  pReserved: 0x%08X\n",
              pNodeInfo->dwSize,
              PwszNodeType(pNodeInfo->dwType), pNodeInfo->dwType,
              PwszSubnodeType(pNodeInfo->dwSubType), pNodeInfo->dwSubType,
              static_cast<DWORD>(pNodeInfo->fTerminal),
              pwsz.get(),
              pNodeInfo->ulLen, pNodeInfo->ulLen,
              pNodeInfo->ulNsPrefixLen, pNodeInfo->ulNsPrefixLen,
              pNodeInfo->pNode,
              pNodeInfo->pReserved);

#endif	// DBG
}

void __fastcall
XmlTraceCountedNodeInfo (const USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
#ifdef	DBG

	for (USHORT iNi = 0; iNi < cNumRecs; iNi++)
		XmlTraceNodeInfo (*apNodeInfo++);

#endif	// DBG
}

//	EXO class statics ---------------------------------------------------------
//
BEGIN_INTERFACE_TABLE(CNodeFactory)
	INTERFACE_MAP(CNodeFactory, IXMLNodeFactory)
END_INTERFACE_TABLE(CNodeFactory);
EXO_GLOBAL_DATA_DECL(CNodeFactory, EXO);

//	class CNodeFactory --------------------------------------------------------
//
HRESULT STDMETHODCALLTYPE CNodeFactory::NotifyEvent(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ XML_NODEFACTORY_EVENT iEvt)
{
	XmlTrace ("Xml: INodeFactory::NotifyEvent() called\n");
	XmlTrace ("- iEvt: %ws (0x%08X)\n", PwszEvent(iEvt), iEvt);

	switch (iEvt)
	{
		case XMLNF_STARTDOCUMENT:

			//	Take note that we have started processing a document
			//
			m_state = ST_PROLOGUE;
			break;

		case XMLNF_ENDPROLOG:

			//	Take note that we have completed prologue processing
			//	and are now processing the document body.
			//
			Assert (m_state == ST_PROLOGUE);
			m_state = ST_INDOC;
			break;

		case XMLNF_ENDDOCUMENT:

			//	The state should be an error or document state
			//
			m_state = ST_NODOC;
			break;

		case XMLNF_DATAAVAILABLE:

			//	More data got pushed to the XMLParser.  There is no
			//	specific action for us, but we shouldn't fail this
			//	either.
			//
			break;

		case XMLNF_STARTDTD:
		case XMLNF_ENDDTD:
		case XMLNF_STARTDTDSUBSET:
		case XMLNF_ENDDTDSUBSET:
		case XMLNF_STARTENTITY:
		case XMLNF_ENDENTITY:
		default:

			//	Unhandled notications
			//
			return E_DAV_XML_PARSE_ERROR;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::BeginChildren(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::BeginChildren() called\n");
	XmlTraceNodeInfo (pNodeInfo);

	//	There should be no required action in our parsing
	//	mechanism here.
	//
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::EndChildren(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ BOOL fEmpty,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::EndChildren() called\n");
	XmlTrace ("- fEmtpy: %ld\n", static_cast<DWORD>(fEmpty));
	XmlTraceNodeInfo (pNodeInfo);

	SCODE sc = S_OK;

	if (ST_INDOC == m_state)
	{
		//	If the node was being handled by a subclass, then
		//	pass the ::EndChildren along to the subclass.
		//
		if (m_cUnhandled == 0)
		{
			sc = ScCompleteChildren (fEmpty,
									 pNodeInfo->dwType,
									 pNodeInfo->pwcText,
									 pNodeInfo->ulLen);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			//	Otherwise pop the unhandled count
			//
			PopUnhandled();
		}

	}

ret:

	//	If there was a scope context, leave the scope.
	//
	if (pNodeInfo->pNode)
	{
		//	A ref added when we handed the object to the
		//	XMLParser.  Reclaim that ref and release the
		//	object.
		//
		auto_ref_ptr<CXmlnsScope> pscope;
		pscope.take_ownership(reinterpret_cast<CXmlnsScope*>(pNodeInfo->pNode));
		pscope->LeaveScope(this);
		pNodeInfo->pNode = NULL;
	}

	return sc;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::Error(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ HRESULT hrErrorCode,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::Error() called\n");
	XmlTrace ("- hrErrorCode: %ws (0x%08X)\n"
			  "- cNumRecs: %hd\n",
			  PwszErrorCode(hrErrorCode), hrErrorCode,
			  cNumRecs);

	//	Argh...
	//
	//	MSXML currently has a bug where if the error occurs whilst
	//	processing the root -- ie. a non-xml document, then ::Error()
	//	is called with a cNumRecs of 1 and a null apNodeInfo.  Oops.
	//
	if (NULL == apNodeInfo)
		return S_OK;

	//	Argh...
	//
	//	There was an error in the XML somewhere.  I don't know if
	//	this is info that would ever help the client.
	//
	XmlTraceCountedNodeInfo (cNumRecs, apNodeInfo);
	m_hrParserError = hrErrorCode;
	m_state = ST_XMLERROR;

	for (; cNumRecs--; apNodeInfo++)
	{
		//	If there was a scope context, leave the scope.
		//
		if ((*apNodeInfo)->pNode)
		{
			//	A ref added when we handed the object to the
			//	XMLParser.  Reclaim that ref and release the
			//	object.
			//
			auto_ref_ptr<CXmlnsScope> pscope;
			pscope.take_ownership(reinterpret_cast<CXmlnsScope*>((*apNodeInfo)->pNode));
			pscope->LeaveScope(this);
			(*apNodeInfo)->pNode = NULL;
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::CreateNode(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ PVOID pNodeParent,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO __RPC_FAR **apNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::CreateNode() called\n");
	XmlTrace ("- pNodeParent: 0x%08X\n"
			  "- cNumRecs: %hd\n",
			  pNodeParent,
			  cNumRecs);
	XmlTraceCountedNodeInfo (cNumRecs, apNodeInfo);

	auto_ref_ptr<CNmspc> pnsLocal;
	auto_ref_ptr<CXmlnsScope> pxmlnss;
	LPCWSTR pwcNamespaceAttributeDefault = NULL;
	LPCWSTR pwcNamespace = NULL;
	SCODE sc = S_OK;
	ULONG ulNsPrefiLenAttributeDefault = 0;
	USHORT iNi;

	//	We really do not care much about anything in the
	//	prologue.
	//
	if (ST_INDOC != m_state)
		goto ret;

	//	The processing for ::CreateNode() really is a two pass
	//	mechanism for all the nodes being created.  First, the
	//	list of nodes are scanned for namespaces and they are
	//	added to the cache.  This is required because namespace
	//	definitions for this node's scope can apear anywhere in
	//	the list of attributes.
	//
	//	Once all the namespaces have been processed, the subclass
	//	is called for each node -- with the expanded names for
	//	both XML_ELEMENTS and XML_ATTRIBUTES
	//
	for (iNi = 0; iNi < cNumRecs; iNi++)
	{
		if (XML_NS == apNodeInfo[iNi]->dwSubType)
		{
			//	This should always be the case.  The enumeration
			//	that defines the subtypes picks up where the node
			//	types left off.
			//
			Assert (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType);
			//
			//	However, handle this case -- just in case...
			//
			if (XML_ATTRIBUTE != apNodeInfo[iNi]->dwType)
				continue;

			//	Since we are about to create some namespaces that
			//	are scoped by this node, create a scoping object
			//	and set it into the node info.
			//
			//	When we hand this back to those wacky XML guys, we
			//	need to keep our reference so the object lives beyond
			//	the current instance.  It gets cleaned up in response
			//	to ::Error() or ::EndChildren() calls.
			//
			if (NULL == pxmlnss.get())
			{
				pxmlnss.take_ownership(new CXmlnsScope);
				if (NULL == pxmlnss.get())
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
			}

			//	Ok, we have a namespace, and need to construct and
			//	cache it.
			//
			//	If this is a default namespace -- ie. one that does
			//	not have an alias associated with its use -- then
			//	the length of the namespace prefix should be zero.
			//
			auto_ref_ptr<CNmspc> pns;
			pns.take_ownership(new CNmspc());
			if (NULL == pns.get())
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			if (0 == apNodeInfo[iNi]->ulNsPrefixLen)
			{
				//	Set the empty alias
				//
				Assert (CchConstString(gc_wszXmlns) == apNodeInfo[iNi]->ulLen);
				Assert (!wcsncmp (apNodeInfo[iNi]->pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns)));
				sc = pns->ScSetAlias (apNodeInfo[iNi]->pwcText, 0);
				if (FAILED (sc))
					goto ret;
			}
			else
			{
				UINT cch = apNodeInfo[iNi]->ulLen - apNodeInfo[iNi]->ulNsPrefixLen - 1;
				LPCWSTR pwsz = apNodeInfo[iNi]->pwcText + apNodeInfo[iNi]->ulLen - cch;

				//	The alias for this namespace is the text following
				//	the single colon in the namespace decl.
				//
				Assert (CchConstString(gc_wszXmlns) < apNodeInfo[iNi]->ulLen);
				Assert (!wcsncmp (apNodeInfo[iNi]->pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns)));
				Assert (L':' == *(apNodeInfo[iNi]->pwcText + CchConstString(gc_wszXmlns)));
				sc = pns->ScSetAlias (pwsz, cch);
				if (FAILED (sc))
					goto ret;
			}

			//	Now assemble the href.  The href is defined by the next N
			//	consecutive nodes of type XML_PCDATA.
			//
			while (++iNi < cNumRecs)
			{
				if (XML_PCDATA != apNodeInfo[iNi]->dwType)
					break;

				if (-1 == m_sbValue.Append(apNodeInfo[iNi]->ulLen * sizeof(WCHAR),
										   apNodeInfo[iNi]->pwcText))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
			}

			//	At this point, we have hit the end of this current namespace
			//	declaration and can set the href into the namespace.
			//
			sc = pns->ScSetHref (m_sbValue.PContents(), m_sbValue.CchSize());
			if (FAILED (sc))
				goto ret;

			m_sbValue.Reset();

			//	The namespace has been completed, so we should cache it
			//	at this point; and clear the namespace in construction.
			//
			Assert (pns.get());
			Assert (pns->PszHref() && pns->PszAlias());
			CachePersisted (pns);

			//	Make sure the scoping for this namespace is handled.
			//
			Assert (pxmlnss.get());
			pxmlnss->ScopeNamespace (pns.get());

			//	Ok, if we simply move on to the next node, then we will skip the
			//	node that brought us out of the namespace processing.
			//
			iNi--;
		}
	}

	//	Now that we have all the namespaces taken care of, call the subclass
	//	for each of the nodes.
	//
	for (iNi = 0; iNi < cNumRecs; iNi++)
	{
		LPCWSTR pwcText = apNodeInfo[iNi]->pwcText;
		ULONG ulLen = apNodeInfo[iNi]->ulLen;
		ULONG ulNsPrefixLen = apNodeInfo[iNi]->ulNsPrefixLen;

		switch (apNodeInfo[iNi]->dwType)
		{
			case XML_ATTRIBUTE:
			case XML_ELEMENT:

				//	For both XML_ELEMENTs and XML_ATTRIBUTEs, we want to
				//	do the namespace translation and hand the subclass the
				//	fully qualified name!  The only exception to this would
				//	be for the special node and element subtypes.
				//
				if (0 == apNodeInfo[iNi]->dwSubType)
				{
					//	For attributes, if there was no translation, then we
					//	want to use this node's namespace for defaulting the
					//	attribute namespaces.
					//
					if ((XML_ATTRIBUTE == apNodeInfo[iNi]->dwType) &&
						(0 == apNodeInfo[iNi]->ulNsPrefixLen))
					{
						pwcNamespace = pwcNamespaceAttributeDefault;
						ulNsPrefixLen = ulNsPrefiLenAttributeDefault;
					}
					else
					{
						//	Otherwise try and translate...
						//
						sc = TranslateToken (&pwcText,
											 &ulLen,
											 &pwcNamespace,
											 &ulNsPrefixLen);
					}

					//	For elements, if there was no translation and there
					//	is a current default namespace declaired for this xml
					//	this document, this is invalid xml.
					//
					Assert (!FAILED (sc));
					if (S_FALSE == sc)
					{
						XmlTrace ("Xml: element has no valid namespace\n");
						sc = E_DAV_XML_PARSE_ERROR;
						goto ret;
					}

					//	Check for an empty property name.  An empty property name
					//  is invalid.  ulLen is the size of the property name with
					//  the prefix stripped.  ***
					//
					if (0 == ulLen)
					{
						XmlTrace("Xml:  property has noname\n");
						sc = E_DAV_XML_PARSE_ERROR;
						goto ret;
					}
				}

				//	Handle empty tags here -- ie. all namespace!
				//
				if (0 == apNodeInfo[iNi]->ulLen)
				{
					XmlTrace ("Xml: element has no valid tag\n");
					sc = E_DAV_XML_PARSE_ERROR;
				}

				//	If this is the first node in the list, then set the defaults
				//
				if (0 == iNi)
				{
					pwcNamespaceAttributeDefault = pwcNamespace;
					ulNsPrefiLenAttributeDefault = ulNsPrefixLen;
				}

				/* !!! FALL THROUGH !!! */

			case XML_PI:
			case XML_XMLDECL:
			case XML_DOCTYPE:
			case XML_DTDATTRIBUTE:
			case XML_ENTITYDECL:
			case XML_ELEMENTDECL:
			case XML_ATTLISTDECL:
			case XML_NOTATION:
			case XML_GROUP:
			case XML_INCLUDESECT:
			case XML_PCDATA:
			case XML_CDATA:
			case XML_IGNORESECT:
			case XML_COMMENT:
			case XML_ENTITYREF:
			case XML_WHITESPACE:
			case XML_NAME:
			case XML_NMTOKEN:
			case XML_STRING:
			case XML_PEREF:
			case XML_MODEL:
			case XML_ATTDEF:
			case XML_ATTTYPE:
			case XML_ATTPRESENCE:
			case XML_DTDSUBSET:
			default:
			{
				//	If we are currently in a state where the subclass has chosen
				//	not to handle a node (and subsequently its children), then we
				//	do not want to even bother the subclass.
				//
				//$	REVIEW:
				//
				//	We do not cut this off earlier such that we can process and
				//	know the namespaces of the unhandled nodes.  Otherwise we cannot
				//	do any XML validation of the unhandled nodes.
				//
				if (0 == m_cUnhandled)
				{
					//	Call the subclass
					//	Note that we don't need to call subclass if the it's a XML_NS node,
					//	because we've handled all the namespaces.
					//
					Assert (pwcNamespace ||
							(0 == apNodeInfo[iNi]->ulNsPrefixLen) ||
						    (apNodeInfo[iNi]->dwSubType == XML_NS));

					//	If we see a sub type of XML_NS, this must be a XML_ATTRIBUTE
					//
					Assert ((apNodeInfo[iNi]->dwSubType != XML_NS) ||
							(apNodeInfo[iNi]->dwType == XML_ATTRIBUTE));

					sc = ScHandleNode (apNodeInfo[iNi]->dwType,
									   apNodeInfo[iNi]->dwSubType,
									   apNodeInfo[iNi]->fTerminal,
									   pwcText,
									   ulLen,
									   ulNsPrefixLen,
									   pwcNamespace,
									   apNodeInfo[iNi]->ulNsPrefixLen);
					if (FAILED (sc))
						goto ret;
				}

				//	Watch for UNHANDLED nodes.  Any node that ends up not being handled
				//	pushes us into a state where all we do is continue processing the
				//	XML stream until our unhandled count (which is really a depth) goesbd
				//	back to zero.  A subclass tells us something was unhandled by passing
				//	back S_FALSE;
				//
				if (S_FALSE == sc)
				{
					//	Any type that results in an EndChildren() call
					//	needs to add to the unhandled depth.
					//
					//$	WORKAROUND: There is a bug in the XML parser where it is
					//	giving us a non-terminal PCDATA!  Work around that here!
					//
					if (!apNodeInfo[iNi]->fTerminal && (XML_PCDATA != apNodeInfo[iNi]->dwType))
					{
						//	We should only get non-terminal node info structures
						//	as the first in the list or as attributes!
						//
						Assert ((0 == iNi) || (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType));
						PushUnhandled ();
					}
				}

				//  For most attributes we expect the attribute to be followed by
				//  XML_PCDATA element, but we want to allow the empty namespace
				//  definition xmlns:a="".  This has no data element, so we need
				//  to adjust the state for this case.
				//
				if ((ST_INDOC == m_state) && (XML_NS == apNodeInfo[iNi]->dwSubType))
				{
					//  If we have sub type XML_NS, we know that it has to be of type
					//  XML_ATTTRIBUTE.
					//
					Assert (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType);

					//  If there are no more records or if the next element is not of
					//  type XML_PCDATA, we know we hit an empty namespace declaration.
					//
					if ((iNi == cNumRecs - 1) ||
						(XML_PCDATA != apNodeInfo[iNi + 1]->dwType))
					{
						m_state = ST_INATTRDATA;
					}
				}

				//	If we just processed an attribute, then we had better transition
				//	into the right state for processing its value.
				//
				switch (m_state)
				{
					case ST_INDOC:

						if (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType)
						{
							//$	REVIEW: if this is the last node, that means that the
							//	attribute value is empty.  Don't transition...
							//
							if (iNi < (cNumRecs - 1))
							{
								//	Remember that we have started processing an attribute.
								//	We need to do this so that we can call the subclass to
								//	tell them that the attribute is completed.
								//
								m_state = ST_INATTR;
							}
							//
							//$	REVIEW: end.
						}
						break;

					case ST_INATTR:

						//	We better not get anything other than PCDATA when dealing
						//	with attributes, otherwise it is an error.
						//
						if (XML_PCDATA == apNodeInfo[iNi]->dwType)
						{
							//	We also need to close the attribute off if this is
							//	the last node in the list, so we should fall through
							//	below to handle the termination case.
							//
							m_state = ST_INATTRDATA;
						}
						else
						{
							//	We better not get anything other than PCDATA
							//	when dealing with attributes, otherwise it
							//	is an error.
							//
							XmlTrace ("Xml: got something other than PC_DATA\n");
							sc = E_DAV_XML_PARSE_ERROR;
							goto ret;
						}

						/* !!! FALL THROUGH !!! */

					case ST_INATTRDATA:

						//	The next node is anything but PC_DATA or this is the
						//	last node in the list, then we need to close the current
						//	attribute.
						//
						if ((iNi == cNumRecs - 1) ||
							(XML_PCDATA != apNodeInfo[iNi + 1]->dwType))
						{
							m_state = ST_INDOC;

							//	Now that all the bits that define the node are handled
							//	by the subclass, we can pass on the end of the attributes.
							//
							//	If the subclass is handling the current context, pass
							//	the call along
							//
							if (0 == m_cUnhandled)
							{
								sc = ScCompleteAttribute ();
								if (FAILED (sc))
									goto ret;
							}
							else
							{
								//	Don't call the subclass but certainly pop the
								//	unhandled state
								//
								PopUnhandled();
							}
						}
						break;
				}
				break;
			}
		}
	}

	//	Complete the CreateNode() call
	//
	Assert (0 != cNumRecs);
	sc = ScCompleteCreateNode (apNodeInfo[0]->dwType);
	if (FAILED (sc))
		goto ret;

	//	Assert that in a completely successful call, we are still
	//	in the ST_INDOC state.
	//
	Assert (ST_INDOC == m_state);

	//	Make sure that any scoping that needed to happen, happens
	//
	Assert ((NULL == pxmlnss.get()) || (0 != cNumRecs));
	apNodeInfo[0]->pNode = pxmlnss.relinquish();

ret:
	return sc;
}

//	ScNewXMLParser() ----------------------------------------------------------
//
SCODE
ScNewXMLParser (CNodeFactory * pnf, IStream * pstm, IXMLParser ** ppxprsRet)
{
	auto_ref_ptr<IXMLParser> pxprsNew;
	SCODE sc = S_OK;

	//$	IMPORTANT: we are trusting that IIS has initialized co
	//	for us.  We have been told by the powers that be that
	//	we shall not init co.
	//
	//	Grab an instance of the XML parser
	//
	sc = CoCreateInstance (CLSID_XMLParser,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IXMLParser,
						   reinterpret_cast<LPVOID*>(pxprsNew.load()));
	//
	//$	IMPORTANT: end

	if (FAILED (sc))
		goto ret;

	//	Set the input to the parser
	//
	sc = pxprsNew->SetInput (pstm);
	if (FAILED (sc))
		goto ret;

	//	Initialize the node factory
	//
	sc = pnf->ScInit();
	if (FAILED (sc))
		goto ret;

	//	Push our node factory
	//
	sc = pxprsNew->SetFactory (pnf);
	if (FAILED (sc))
		goto ret;

	//	Set some flags that are fairly useful
	//
	sc = pxprsNew->SetFlags (XMLFLAG_SHORTENDTAGS | XMLFLAG_NOWHITESPACE);
	if (FAILED (sc))
		goto ret;

	//	Pass back the instantiated parser
	//
	*ppxprsRet = pxprsNew.relinquish();

ret:
	return sc;
}

//	ScParseXML() --------------------------------------------------------------
//
SCODE
ScParseXML (IXMLParser* pxprs, CNodeFactory * pnf)
{
	//	Note Run() can return E_PENDING when I/O is pending
	//	on the stream which we are parsing.
	//
	SCODE sc = pxprs->Run (-1);

	if (FAILED (sc) && pnf->FParserError(sc))
		sc = E_DAV_XML_PARSE_ERROR;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xnode.cpp ===
/*
 *	X N O D E . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
#include <string.h>
#include <stdio.h>

//	class CXNode - Emitting ---------------------------------------------------
//
//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
//	more info.
//
//		Unicode value    1st byte    2nd byte    3rd byte
//		000000000xxxxxxx 0xxxxxxx
//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
//
inline
VOID WideCharToUTF8Chars (WCHAR wch, BYTE * pb, UINT * pib)
{
	Assert (pb);
	Assert (pib);

	UINT	ib = *pib;

	//	single-byte: 0xxxxxxx
	//
	if (wch < 0x80)
	{
		pb[ib] = static_cast<BYTE>(wch);
	}
	//
	//	two-byte: 110xxxxx 10xxxxxx
	//
	else if (wch < 0x800)
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 6) | 0xC0);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}
	//
	//	three-byte: 1110xxxx 10xxxxxx 10xxxxxx
	//
	else
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 12) | 0xE0);
		pb[ib++] = static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}

	*pib = ib;
}

SCODE
CXNode::ScAddUnicodeResponseBytes (
	/* [in] */ UINT cch,
	/* [in] */ LPCWSTR pcwsz)
{
	SCODE sc = S_OK;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	BYTE* pb = static_cast<BYTE*>(_alloca(cb));
	UINT ib;
	UINT iwch;

	for (iwch = 0; iwch < cch; )
	{
		for (ib = 0;
			 (ib < cb-2) && (iwch < cch);
			 ib++, iwch++)
		{
			WideCharToUTF8Chars (pcwsz[iwch], pb, &ib);
		}

		//	Add the bytes
		//
		Assert (ib <= cb);
		sc = m_pxb->ScAddTextBytes (ib, reinterpret_cast<LPSTR>(pb));
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXNode::ScAddEscapedValueBytes (UINT cch, LPCSTR psz)
{
	SCODE sc = S_OK;
	const CHAR* pch;
	const CHAR* pchLast;

	for (pchLast = pch = psz; pch < psz + cch; pch++)
	{
		//	Character Range
		//	[2] Char ::=  #x9
		//				| #xA
		//				| #xD
		//				| [#x20-#xD7FF]
		//				| [#xE000-#xFFFD]
		//				| [#x10000-#x10FFFF]
		//
		//	/* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */
		//
		//	Valid characters also escaped in values:
		//
		//		&	-- escaped as &amp;
		//		<	-- excaped as &lt;
		//		>	-- excaped as &gt;
		//
		if ('&' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szAmp), gc_szAmp);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('<' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szLessThan), gc_szLessThan);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('>' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szGreaterThan), gc_szGreaterThan);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if (	(0x9 > static_cast<BYTE>(*pch))
				 || (0xB == *pch)
				 || (0xC == *pch)
				 || ((0x20 > *pch) && (0xD < *pch)))
		{
			char rgch[10];

			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence...
			//
			sprintf (rgch, "&#x%02X;", *pch);
			Assert (strlen(rgch) == CchConstString("&#x00;"));
			sc = m_pxb->ScAddTextBytes (CchConstString("&#x00;"), rgch);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
		else if (pch - pchLast + 1 >= CB_XMLBODYPART_SIZE)
		{
			//	Break up if the bodyparts gets too big
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast + 1), pchLast);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
	}

	//	Add any remaining bytes
	//
	sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScAddEscapedAttributeBytes (UINT cch, LPCSTR psz)
{
	SCODE sc = S_OK;
	const CHAR* pch;
	const CHAR* pchLast;

	for (pchLast = pch = psz; pch < psz + cch; pch++)
	{
		//	Characters escaped in values:
		//
		//		&	-- escaped as &amp;
		//		"	-- excaped as &quot;
		//
		if ('&' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szAmp), gc_szAmp);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('"' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szQuote), gc_szQuote);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ((0x9 > static_cast<BYTE>(*pch))
				 || (0xB == *pch)
				 || (0xC == *pch)
				 || ((0x20 > *pch) && (0xD < *pch)))
		{
			char rgch[10];

			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence...
			//
			sprintf (rgch, "&#x%02X;", *pch);
			Assert (strlen(rgch) == CchConstString("&#x00;"));
			sc = m_pxb->ScAddTextBytes (CchConstString("&#x00;"), rgch);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
	}

	//	Add any remaining bytes
	//
	sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

//	class CXNode - Construction -----------------------------------------------
//
SCODE
CXNode::ScWriteTagName ()
{
	SCODE sc = S_OK;

	//	If there is a namespace associated with this node,
	//	when writing out the tag name, add the alias and a
	//	separator to the data stream.
	//
	if (m_pns.get() && m_pns->CchAlias())
	{
		//	Add the alias
		//
		sc = ScAddUnicodeResponseBytes (m_pns->CchAlias(), m_pns->PszAlias());
		if (FAILED(sc))
			goto ret;

		//	Add in the separator
		//
		sc = m_pxb->ScAddTextBytes(1, &gc_chColon);
		if (FAILED(sc))
			goto ret;
	}

	//	Write the tag
	//
	Assert (m_pwszTagEscaped.get());
	sc = ScAddUnicodeResponseBytes (m_cchTagEscaped, m_pwszTagEscaped.get());
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScSetTag (CXMLEmitter* pmsr, UINT cchTag, LPCWSTR pwszTag)
{
	LPCWSTR pwszName = pwszTag;
	SCODE sc = S_OK;
	BOOL fAddNmspc = FALSE;
	UINT cch = 0;
	UINT cchName = 0;
	UINT cchTagEscaped = 64;
	auto_heap_ptr<WCHAR> pwszTagEscaped;

	//	Namespace nodes do not have a namespace associated with them,
	//	so don't even bother looking...
	//
	switch (m_xnt)
	{
		case XN_ELEMENT:
		case XN_ATTRIBUTE:

			//	See if a namespace applies to this tag
			//
			cch = CchNmspcFromTag (cchTag, pwszTag, &pwszName);
			if (0 == cch)
			{
				m_fHasEmptyNamespace = TRUE;
			}
			else
			{
				//	Find the namespace to use
				//
				sc = pmsr->ScFindNmspc (pwszTag, cch, m_pns);
				if (FAILED (sc))
					goto ret;

				//	If a new namespace is added in the local namespace
				//	cache, make sure we emit it in the node
				//
				//$NOTE: this is how we handle pilot namespace, this is
				//$NOTE: is NOT the normal way of handling namespaces. All
				//$NOTE: common namespaces should be preloaded.
				//$NOTE:
				//
				fAddNmspc = (sc == S_FALSE);

				//	We should have preloaded all namespaces. The pilot
				//	namespace is handled here to avoid emitting invalid
				//	xml. But we should look into the reason why the pilot
				//	namespace comes up. so assert here.
				//
				//	Note that this assert should be removed if we decide
				//	we want to leave uncommon namesapces not preloaded and
				//	expect them to be treated as pilot namespaces.
				//
				AssertSz(!fAddNmspc, "Pilot namespace found, safe to ingore,"
									 "but please raid against HTTP-DAV");
			}

			break;

		case XN_NAMESPACE:
			break;
	}

	//	Record the new tag and\or its length
	//
	//	NOTE: the item that goes into the tag cache is the name
	//	of the property with the namespace stripped off.  This is
	//	important to know when doing searches in the tag cache.
	//
	cchName = static_cast<UINT>(pwszTag + cchTag - pwszName);
	if (0 == cchName )
	{
		//	We really need to have a tag that has a value.  Empty
		//	tags produce invalid XML.
		//
		sc = E_DAV_INVALID_PROPERTY_NAME;
		goto ret;
	}
	sc = CXAtomCache::ScCacheAtom (&pwszName, cchName);
	if (FAILED (sc))
		goto ret;

	//	ScSetTag shouldn't have been called for this node.
	//
	Assert (!m_pwszTagEscaped.get());

	//	Allocate buffer for the property tag.
	//
	pwszTagEscaped = static_cast<WCHAR*>(ExAlloc(CbSizeWsz(cchTagEscaped)));
	if (!pwszTagEscaped.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Escape the tag name as required.
	//
	//  If we have an empty namespace, we need to impose additional
	//  restrictions on the first character of the property name because
	//  it will be the first character of the xml node, and the first
	//  character of an xml node can only be a letter or an underscore
	//  (numbers, etc. are not allowed).
	//
	//  Note:  This will disallow an xml node <123> because it is invalid
	//  xml, but it will ALLOW the xml node <a:123> even though this is
	//  also invalid.  This is by design because most xml parsers will handle
	//  this appropriately, and it makes more sense to clients.
	//
	sc = ScEscapePropertyName (pwszName, cchName, pwszTagEscaped.get(), &cchTagEscaped, m_fHasEmptyNamespace);
	if (S_FALSE == sc)
	{
		pwszTagEscaped.clear();
		pwszTagEscaped = static_cast<WCHAR*>(ExAlloc(CbSizeWsz(cchTagEscaped)));
		if (!pwszTagEscaped.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		sc = ScEscapePropertyName (pwszName, cchName, pwszTagEscaped.get(), &cchTagEscaped, m_fHasEmptyNamespace);
		Assert (S_OK == sc);
	}

	m_pwszTagEscaped = pwszTagEscaped.relinquish();
	m_cchTagEscaped = cchTagEscaped;

	//	Start a new node if XN_ELEMENT
	//
	if (m_xnt == XN_ELEMENT)
	{
		sc = m_pxb->ScAddTextBytes (1, "<");
		if (FAILED(sc))
			goto ret;
	}

	sc = ScWriteTagName();
	if (FAILED(sc))
		goto ret;

	if (fAddNmspc)
	{
		//	Add the namespace attribute in the node if necessary
		//
		sc = pmsr->ScAddNmspc (m_pns, this);
		if (FAILED(sc))
			goto ret;

		//	Save the emitter which can be used later to remove the temporary nmspc
		//
		m_pmsr = pmsr;
	}

ret:
	return sc;
}

SCODE
CXNode::ScDone ()
{
	SCODE sc = S_OK;

	//	This method should never be called twice
	//
	Assert (!m_fDone);
	switch (m_xnt)
	{
		case XN_ELEMENT:

			if (!m_pwszTagEscaped.get())
			{
				//$	RAID: 85824: When an invalid property name is unpacked,
				//	ScSetTag will fail with E_DAV_INVALID_PROPERTY_NAME.
				//
				//	Usuallly, the client will fail when it sees any error
				//	from CXNode methods, but in this case it may choose to
				//	continue and ignore this node completely.
				//
				//	For us, it's safe to not to emit anything when no tag name
				//	is available.
				//
				break;
				//
				//$RAID: 85824
			}

			if (m_fNodeOpen)
			{
				//	Node is open, so emit a complete closing node
				//	</tag>
				//
				sc = m_pxb->ScAddTextBytes (2, "</");
				if (FAILED(sc))
					goto ret;

				//	Add tag
				//
				sc = ScWriteTagName();
				if (FAILED(sc))
					goto ret;

				//	closing
				//
				sc = m_pxb->ScAddTextBytes (1, ">");
				if (FAILED(sc))
					goto ret;
			}
			else
			{
				//	Close directly
				//
				sc = m_pxb->ScAddTextBytes (2, "/>");
				if (FAILED(sc))
					goto ret;
			}

			break;

		case XN_NAMESPACE:

			//	Namespace nodes, should not have a namespace associated with
			//	them.
			//
			Assert (NULL == m_pns.get());
			//
			//	  Otherwise treat it at an attribute -- and fall through

		case XN_ATTRIBUTE:

			Assert (m_pwszTagEscaped.get());
			break;
	}

	//	Remove the pilot namespace from global cache
	//
	if (m_pmsr)
		m_pmsr->RemovePersisted(m_pns);

	m_fDone = TRUE;

ret:
	return sc;
}

SCODE
CXNode::ScSetFormatedXML (LPCSTR pszValue, UINT cch)
{
	SCODE	sc = S_OK;

	Assert (m_xnt == XN_ELEMENT);

	if (!m_fNodeOpen)
	{
		// We must have written the tag name
		//
		Assert (m_pwszTagEscaped.get());

		// Now that we are adding value to the element node
		// We should write the node open
		//
		sc = m_pxb->ScAddTextBytes (1, ">");
		if (FAILED(sc))
			goto ret;

		m_fNodeOpen = TRUE;
	}

	//	Add the value directly
	//
	sc = m_pxb->ScAddTextBytes (cch, pszValue);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScSetFormatedXML (LPCWSTR pwszValue, UINT cch)
{
	SCODE	sc = S_OK;

	Assert (m_xnt == XN_ELEMENT);

	if (!m_fNodeOpen)
	{
		// We must have written the tag name
		//
		Assert (m_pwszTagEscaped.get());

		// Now that we are adding value to the element node
		// We should write the node open
		//
		sc = m_pxb->ScAddTextBytes (1, ">");
		if (FAILED(sc))
			goto ret;

		m_fNodeOpen = TRUE;
	}

	//	Add the value directly
	//
	sc = ScAddUnicodeResponseBytes (cch, pwszValue);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}


SCODE
CXNode::ScSetUTF8Value (LPCSTR pszValue, UINT cch)
{
	SCODE sc = S_OK;

	switch (m_xnt)
	{
		case XN_ELEMENT:

			if (!m_fNodeOpen)
			{
				// We must have written the tag name
				//
				Assert (m_pwszTagEscaped.get());

				// Now that we are adding value to the element node
				// We should write the node open
				//
				sc = m_pxb->ScAddTextBytes (1, ">");
				if (FAILED(sc))
					goto ret;

				m_fNodeOpen = TRUE;
			}

			// Write the value
			//
			sc =  ScAddEscapedValueBytes (cch, pszValue);
			if (FAILED(sc))
				goto ret;

			break;

		case XN_NAMESPACE:
		case XN_ATTRIBUTE:

			//	Write the value directly
			//
			sc =  ScAddEscapedAttributeBytes (cch, pszValue);
			if (FAILED(sc))
				goto ret;
			break;
	}

ret:
	return sc;
}

SCODE
CXNode::ScSetValue (LPCSTR pszValue, UINT cch)
{
	//	Ok, against all better judgement, we need to take this
	//	multi-byte string and convert it to unicode before doing
	//	any UTF8 processing on it.
	//
	//	Translations from multibyte to unicode, can never grow in
	//	character counts, so we are relatively safe allocating this
	//	on the stack.
	//
	LPWSTR pwsz = static_cast<LPWSTR>(_alloca(CbSizeWsz(cch)));
	UINT cchUnicode = MultiByteToWideChar (GetACP(),
										   0,
										   pszValue,
										   cch,
										   pwsz,
										   cch + 1);

	//	Terminate the string
	//
	Assert ((0 == cchUnicode) || (0 != *(pwsz + cchUnicode - 1)));
	*(pwsz + cchUnicode) = 0;

	//	Set the value
	//
	return ScSetValue (pwsz, cchUnicode);
}

SCODE
CXNode::ScSetValue (LPCWSTR pcwsz, UINT cch)
{
	SCODE sc = S_OK;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//	Note that when the value
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	BYTE* pb = static_cast<BYTE*>(_alloca(cb));
	UINT ib;
	UINT iwch;

	for (iwch = 0; iwch < cch; )
	{
		for (ib = 0; (ib < cb-2) && (iwch < cch); ib++, iwch++)
			WideCharToUTF8Chars (pcwsz[iwch], pb, &ib);

		//	Add the bytes
		//
		Assert (ib <= cb);
		sc = ScSetUTF8Value (reinterpret_cast<LPSTR>(pb), ib);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXNode::ScGetChildNode (XNT xntType, CXNode **ppxnChild)
{
	SCODE sc = S_OK;
	auto_ref_ptr<CXNode> pxn;

	Assert (ppxnChild);
	if (XN_ELEMENT == xntType)
	{
		//	Now that new element child node is added, then this node is done open.
		//	i.e close by ">", instead of "/>"
		//
		if (!m_fNodeOpen)
		{
			sc = m_pxb->ScAddTextBytes (1, ">");
			if (FAILED(sc))
				goto ret;

			//	Then this node is an open node
			//
			m_fNodeOpen = TRUE;
		}
	}
	else
	{
		Assert ((XN_ATTRIBUTE == xntType) || (XN_NAMESPACE == xntType));
	}

	//	Create the child node
	//
	pxn.take_ownership (new CXNode(xntType, m_pxb));
	if (!pxn.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Pass back
	//
	*ppxnChild = pxn.relinquish();

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Version 5.0 (using 32-bit types)
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short	_2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_64PVOID       0x0603      // 64 bit pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned
#define T_64PCHAR       0X0610      // 64 bit pointer to 8 bit signed
#define T_64PUCHAR      0X0620      // 64 bit pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char
#define T_64PRCHAR      0x0670      // 64 bit pointer to a real char



//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char
#define T_64PWCHAR      0x0671      // 64 bit pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int
#define T_64PINT1       0x0668      // 64 bit pointer to 8 bit signed int
#define T_64PUINT1      0x0669      // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned
#define T_64PSHORT      0x0611      // 64 bit pointer to 16 bit signed
#define T_64PUSHORT     0x0621      // 64 bit pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int
#define T_64PINT2       0x0672      // 64 bit pointer to 16 bit signed int
#define T_64PUINT2      0x0673      // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned
#define T_64PLONG       0x0612      // 64 bit pointer to 32 bit signed
#define T_64PULONG      0x0622      // 64 bit pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int
#define T_64PINT4       0x0674      // 64 bit pointer to 32 bit signed int
#define T_64PUINT4      0x0675      // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned
#define T_64PQUAD       0x0613      // 64 bit pointer to 64 bit signed
#define T_64PUQUAD      0x0623      // 64 bit pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int
#define T_64PINT8       0x0676      // 64 bit pointer to 64 bit signed int
#define T_64PUINT8      0x0677      // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned
#define T_64POCT        0x0614      // 64 bit pointer to 128 bit signed
#define T_64PUOCT       0x0624      // 64 bit pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int
#define T_64PINT16      0x0678      // 64 bit pointer to 128 bit signed int
#define T_64PUINT16     0x0679      // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real
#define T_64PREAL32     0x0640      // 64 bit pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real
#define T_64PREAL48     0x0644      // 64 bit pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real
#define T_64PREAL64     0x0641      // 64 bit pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real
#define T_64PREAL80     0x0642      // 64 bit pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real
#define T_64PREAL128    0x0643      // 64 bit pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex
#define T_64PCPLX32     0x0650      // 64 bit pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex
#define T_64PCPLX64     0x0651      // 64 bit pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex
#define T_64PCPLX80     0x0652      // 64 bit pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex
#define T_64PCPLX128    0x0653      // 64 bit pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean

#define T_64PBOOL08     0x0630      // 64 bit pointer to 8 bit boolean
#define T_64PBOOL16     0x0631      // 64 bit pointer to 18 bit boolean
#define T_64PBOOL32     0x0632      // 64 bit pointer to 32 bit boolean
#define T_64PBOOL64     0x0633      // 64 bit pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER_16t     0x0001
#define LF_POINTER_16t      0x0002
#define LF_ARRAY_16t        0x0003
#define LF_CLASS_16t        0x0004
#define LF_STRUCTURE_16t    0x0005
#define LF_UNION_16t        0x0006
#define LF_ENUM_16t         0x0007
#define LF_PROCEDURE_16t    0x0008
#define LF_MFUNCTION_16t    0x0009
#define LF_VTSHAPE          0x000a
#define LF_COBOL0_16t       0x000b
#define LF_COBOL1           0x000c
#define LF_BARRAY_16t       0x000d
#define LF_LABEL            0x000e
#define LF_NULL             0x000f
#define LF_NOTTRAN          0x0010
#define LF_DIMARRAY_16t     0x0011
#define LF_VFTPATH_16t      0x0012
#define LF_PRECOMP_16t      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP       0x0014      // not referenced from symbol
#define LF_OEM_16t          0x0015      // oem definable type string
#define LF_TYPESERVER       0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP_16t         0x0200
#define LF_ARGLIST_16t      0x0201
#define LF_DEFARG_16t       0x0202
#define LF_LIST             0x0203
#define LF_FIELDLIST_16t    0x0204
#define LF_DERIVED_16t      0x0205
#define LF_BITFIELD_16t     0x0206
#define LF_METHODLIST_16t   0x0207
#define LF_DIMCONU_16t      0x0208
#define LF_DIMCONLU_16t     0x0209
#define LF_DIMVARU_16t      0x020a
#define LF_DIMVARLU_16t     0x020b
#define LF_REFSYM           0x020c
                            
#define LF_BCLASS_16t       0x0400
#define LF_VBCLASS_16t      0x0401
#define LF_IVBCLASS_16t     0x0402
#define LF_ENUMERATE        0x0403
#define LF_FRIENDFCN_16t    0x0404
#define LF_INDEX_16t        0x0405
#define LF_MEMBER_16t       0x0406
#define LF_STMEMBER_16t     0x0407
#define LF_METHOD_16t       0x0408
#define LF_NESTTYPE_16t     0x0409
#define LF_VFUNCTAB_16t     0x040a
#define LF_FRIENDCLS_16t    0x040b
#define LF_ONEMETHOD_16t    0x040c
#define LF_VFUNCOFF_16t     0x040d

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
#define LF_TI16_MAX         0x1000

#define LF_MODIFIER         0x1001
#define LF_POINTER          0x1002
#define LF_ARRAY            0x1003
#define LF_CLASS            0x1004
#define LF_STRUCTURE        0x1005
#define LF_UNION            0x1006
#define LF_ENUM             0x1007
#define LF_PROCEDURE        0x1008
#define LF_MFUNCTION        0x1009
#define LF_COBOL0           0x100a
#define LF_BARRAY           0x100b
#define LF_DIMARRAY         0x100c
#define LF_VFTPATH          0x100d
#define LF_PRECOMP          0x100e      // not referenced from symbol
#define LF_OEM              0x100f      // oem definable type string
                            
    // leaf indices starting records but referenced only from type records
                            
#define LF_SKIP             0x1200
#define LF_ARGLIST          0x1201
#define LF_DEFARG           0x1202
#define LF_FIELDLIST        0x1203
#define LF_DERIVED          0x1204
#define LF_BITFIELD         0x1205
#define LF_METHODLIST       0x1206
#define LF_DIMCONU          0x1207
#define LF_DIMCONLU         0x1208
#define LF_DIMVARU          0x1209
#define LF_DIMVARLU         0x120a
                            
#define LF_BCLASS           0x1400
#define LF_VBCLASS          0x1401
#define LF_IVBCLASS         0x1402
#define LF_FRIENDFCN        0x1403
#define LF_INDEX            0x1404
#define LF_MEMBER           0x1405
#define LF_STMEMBER         0x1406
#define LF_METHOD           0x1407
#define LF_NESTTYPE         0x1408
#define LF_VFUNCTAB         0x1409
#define LF_FRIENDCLS        0x140a
#define LF_ONEMETHOD        0x140b
#define LF_VFUNCOFF         0x140c
#define LF_NESTTYPEEX       0x140d
#define LF_MEMBERMODIFY     0x140e




#define LF_NUMERIC          0x8000
#define LF_CHAR             0x8000
#define LF_SHORT            0x8001
#define LF_USHORT           0x8002
#define LF_LONG             0x8003
#define LF_ULONG            0x8004
#define LF_REAL32           0x8005
#define LF_REAL64           0x8006
#define LF_REAL80           0x8007
#define LF_REAL128          0x8008
#define LF_QUADWORD         0x8009
#define LF_UQUADWORD        0x800a
#define LF_REAL48           0x800b
#define LF_COMPLEX32        0x800c
#define LF_COMPLEX64        0x800d
#define LF_COMPLEX80        0x800e
#define LF_COMPLEX128       0x800f
#define LF_VARSTRING        0x8010
                            
#define LF_OCTWORD          0x8017
#define LF_UOCTWORD         0x8018
                            
#define LF_PAD0             0xf0
#define LF_PAD1             0xf1
#define LF_PAD2             0xf2
#define LF_PAD3             0xf3
#define LF_PAD4             0xf4
#define LF_PAD5             0xf5
#define LF_PAD6             0xf6
#define LF_PAD7             0xf7
#define LF_PAD8             0xf8
#define LF_PAD9             0xf9
#define LF_PAD10            0xfa
#define LF_PAD11            0xfb
#define LF_PAD12            0xfc
#define LF_PAD13            0xfd
#define LF_PAD14            0xfe
#define LF_PAD15            0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**		Notes on alignment
 *		Alignment of the fields in most of the type records is done on the 
 *		basis of the TYPTYPE record base.  That is why in most of the lf*
 *		records that the CV_typ_t (32-bit types) is located on what appears to
 *		be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *		records that are in a list (lfFieldList, lfMethodList), which are
 *		aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

	Record type			Change (f == field arrangement, p = padding added)
	----------------------------------------------------------------------
	lfModifer			f
	lfPointer			fp
	lfClass				f
	lfStructure			f
	lfUnion				f
	lfEnum				f
	lfVFTPath			p
    lfPreComp           p
	lfOEM				p
	lfArgList			p
	lfDerived			p
	mlMethod			p	(method list member)
	lfBitField			f
	lfDimCon			f
	lfDimVar			p
	lfIndex				p	(field list member)
	lfBClass			f	(field list member)
	lfVBClass			f	(field list member)
	lfFriendCls			p	(field list member)
	lfFriendFcn			p	(field list member)
	lfMember			f	(field list member)
	lfSTMember			f	(field list member)
	lfVFuncTab			p	(field list member)
	lfVFuncOff			p	(field list member)
	lfNestType			p	(field list member)

	DATASYM32			f
	PROCSYM32			f
	VPATHSYM32			f
	REGREL32			f
	THREADSYM32			f
	PROCSYMMIPS			f

	
*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union  {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t			utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t	attr;           // method attribute
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t		index;          // index to type record for procedure
    unsigned long	vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
	                                // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
	                                // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
	_2BYTEPAD       pad0;			// internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
	_2BYTEPAD       pad0;		// internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
	S_REGISTER_16t	=  0x0002, // Register variable
	S_CONSTANT_16t	=  0x0003, // constant symbol
	S_UDT_16t		=  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
	S_COBOLUDT_16t	=  0x000b, // special UDT for cobol that does not symbol pack
	S_MANYREG_16t	=  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry
                       
    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address
                       
    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation
                       
    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start
                       
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
	S_REGISTER		=  0x1001, // Register variable
	S_CONSTANT		=  0x1002, // constant symbol
	S_UDT			=  0x1003, // User defined type
	S_COBOLUDT		=  0x1004, // special UDT for cobol that does not symbol pack
	S_MANYREG		=  0x1005, // multiple register variable
	S_BPREL32		=  0x1006, // BP-relative
	S_LDATA32		=  0x1007, // Module-local symbol
	S_GDATA32		=  0x1008, // Global data symbol
	S_PUB32 		=  0x1009, // a public symbol (CV internal reserved)
	S_LPROC32		=  0x100a, // Local procedure start
	S_GPROC32		=  0x100b, // Global procedure start
	S_VFTABLE32 	=  0x100c, // address of virtual function table
	S_REGREL32		=  0x100d, // register relative address
	S_LTHREAD32 	=  0x100e, // local thread storage
	S_GTHREAD32 	=  0x100f, // global thread storage

	S_LPROCMIPS 	=  0x1010, // Local procedure start
	S_GPROCMIPS 	=  0x1011, // Global procedure start
                       
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_REGISTER_16t
	CV_typ16_t		typind; 	// Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_MANYREG_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_CONSTANT_16t
	CV_typ16_t		typind; 	// Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_UDT_16t | S_COBOLUDT_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table			= 0x00,	// not executable
    CEXM_MDL_jumptable		= 0x01, // Compiler generated jump table
    CEXM_MDL_datapad		= 0x02, // Data padding for alignment
    CEXM_MDL_native			= 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol			= 0x21, // cobol
    CEXM_MDL_codepad		= 0x22, // Code padding for alignment
    CEXM_MDL_code			= 0x23, // code
	CEXM_MDL_sql			= 0x30,	// sql
    CEXM_MDL_pcode			= 0x40, // pcode
    CEXM_MDL_pcode32Mac		= 0x41,	// macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
	CV_typ16_t		root;		// type index of the root of path
	CV_typ16_t		path;		// type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgatq.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

       dbgatq.cxx

   Abstract:

       This module contains the NTSD Debugger extensions for the
       Asynchronous Thread Queue DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     12-May-1997

   Environment:
       Debugger Mode - inside NT command line debuggers

   Project:

       Internet Server Debugging DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#include "inetdbgp.h"


/************************************************************
 *    Definitions of Variables & Macros
 ************************************************************/

//
//  Text names of ATQ_SOCK_STATE values
//

char * AtqSockState[] = {
    "ATQ_SOCK_CLOSED",
    "ATQ_SOCK_UNCONNECTED",
    "ATQ_SOCK_LISTENING",
    "ATQ_SOCK_CONNECTED"
};

char * AtqEndpointState[] = {
    "AtqStateInit",
    "AtqStateActive",
    "AtqStateClosed",
    "AtqStateMax",
};

#define LookupSockState( SockState )                                          \
            ((SockState) <= ATQ_SOCK_CONNECTED ? AtqSockState[ (SockState) ] :\
                                                 "<Invalid>")


/************************************************************
 *    Functions
 ************************************************************/

VOID
DumpAtqGlobals(
    VOID
    );

VOID
DumpAtqContextList(
    CHAR Level,
    CHAR Verbosity,
    ATQ_ENDPOINT * pEndpointIn
    );

void
DumpEndpointList(
    LIST_ENTRY * pAtqClientHead,
    CHAR         Level,
    DWORD *      pcContext,
    BYTE *       pvStart,
    BYTE *       pvEnd,
    ATQ_ENDPOINT * pEndpointIn
    );

VOID
PrintAtqContext(
    ATQ_CONTEXT * AtqContext
    );


void
PrintEndpoint(
    ATQ_ENDPOINT * pEp
    );

VOID
DumpEndpoint(
    CHAR Level
    );


DECLARE_API( atq )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    BOOL          fRet;
    ATQ_CONTEXT   AtqContext;
    ATQ_CONTEXT * pAtqContext;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "atq" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        switch ( *lpArgumentString )  {


        case 'g':
            {
                DumpAtqGlobals();
                break;
            }

        case 'c':
            {
                DumpAtqContextList( lpArgumentString[1],
                                    lpArgumentString[2],
                                    NULL );
                break;
            }

        case 'e':
            {

                ATQ_ENDPOINT       * pEndpoint;

                // Arguments:  -e<Level><Verbosity> <EndpointAddr>

                pEndpoint = ((ATQ_ENDPOINT * )
                             GetExpression( lpArgumentString + 4));
                if ( !pEndpoint ) {

                    dprintf( "inetdbg: Unable to evaluate "
                             "EndpointAddr \"%s\"\n",
                             lpArgumentString );

                    break;
                }

                DumpAtqContextList( lpArgumentString[1],
                                    lpArgumentString[2],
                                    pEndpoint );
                break;
            }

        case 'l':
            {
                DumpEndpoint( lpArgumentString[1] );
                break;
            }

        case 'p':
            {
                //
                //  Treat the argument as the address of an AtqEndpoint
                //

                ATQ_ENDPOINT       * pEndpoint;

                // Arguments:  -p <EndpointAddr>

                pEndpoint = ((ATQ_ENDPOINT *)
                             GetExpression( lpArgumentString + 2 )
                             );

                if ( !pEndpoint )
                    {
                        dprintf( "inetdbg: Unable to evaluate \"%s\"\n",
                                 lpArgumentString );

                        break;
                    }
                else
                    {
                        ATQ_ENDPOINT         Endpoint;
                        move( Endpoint, pEndpoint );
                        PrintEndpoint( &Endpoint );
                    }
                break;
            }

        default:
        case 'h':
            {
                PrintUsage( "atq" );
                break;
            }

        } // switch

        return;
    }

    //
    //  Treat the argument as the address of an AtqContext
    //

    pAtqContext = (PATQ_CONT)GetExpression( lpArgumentString );

    if ( !pAtqContext )
    {
        dprintf( "inetdbg: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( AtqContext, pAtqContext );
    PrintAtqContext( &AtqContext );
} // DECLARE_API( atq )




/************************************************************
 * ATQ related functions
 ************************************************************/

VOID
DumpAtqGlobals(
    VOID
    )
{
    //
    //  Dump Atq Globals
    //

    dprintf("Atq Globals:\n");

    DumpDword( "isatq!g_cConcurrency       " );
    DumpDword( "isatq!g_cThreads           " );
    DumpDword( "isatq!g_cAvailableThreads  " );
    DumpDword( "isatq!g_cMaxThreads        " );

    dprintf("\n");
    DumpDword( "isatq!g_fUseAcceptEx       " );
    DumpDword( "isatq!g_fUseTransmitFile   " );
    DumpDword( "isatq!g_cbXmitBufferSize   " );
    DumpDword( "isatq!g_cbMinKbSec         " );
    DumpDword( "isatq!g_cCPU               " );
    DumpDword( "isatq!g_fShutdown          " );
    dprintf("\n");

    DumpDword( "isatq!g_msThreadTimeout    " );
    DumpDword( "isatq!g_dwTimeoutCookie    " );
    DumpDword( "isatq!g_cListenBacklog     " );
    DumpDword( "isatq!AtqCurrentTick       " );
    DumpDword( "isatq!AtqGlobalContextCount" );
    dprintf("\tsizeof(ATQ_CONTEXT) = %d\n", sizeof(ATQ_CONTEXT));

    return;
} // DumpAtqGlobals()



VOID
DumpAtqContextList(
    CHAR Level,
    CHAR Verbosity,
    ATQ_ENDPOINT * pEndpointIn
    )
{
    LIST_ENTRY           AtqClientHead;
    LIST_ENTRY *         pAtqClientHead;
    ATQ_CONTEXT *        pAtqContext;
    ATQ_CONTEXT          AtqContext;
    CHAR                 Symbol[256];
    DWORD                cContext = 0;
    DWORD                cc1;
    ATQ_CONTEXT_LISTHEAD * pAtqActiveContextList;
    ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];
    DWORD                i;

    pAtqActiveContextList =
        (ATQ_CONTEXT_LISTHEAD *) GetExpression( "&isatq!AtqActiveContextList" );

    if ( !pAtqActiveContextList )
    {
        dprintf("Unable to get AtqActiveContextList symbol\n" );
        return;
    }

    if ( !ReadMemory( (LPVOID) pAtqActiveContextList,
                      AtqActiveContextList,
                      sizeof(AtqActiveContextList),
                      NULL ))
    {
        dprintf("Unable to read AtqActiveContextList memory\n" );
        return;
    }

    for ( i = 0; i < ATQ_NUM_CONTEXT_LIST; i++ )
    {
        dprintf("================================================\n");
        dprintf("== Context List %d                            ==\n", i );
        dprintf("================================================\n");

        dprintf(" Active List ==>\n" );

        cc1 = 0;
        DumpEndpointList( &(AtqActiveContextList[i].ActiveListHead),
                  Verbosity,
                  &cc1,
                  (BYTE *) pAtqActiveContextList,
                  (BYTE *) &pAtqActiveContextList[ATQ_NUM_CONTEXT_LIST],
                  pEndpointIn
                  );

        if ( 0 != cc1) {
            dprintf( "\n\t%d Atq contexts traversed\n", cc1 );
            cContext += cc1;
        }

        if ( Level >= '1' )
        {
            dprintf("================================================\n");
            dprintf("Pending AcceptEx List\n");

            cc1 = 0;
            DumpEndpointList( &(AtqActiveContextList[i].PendingAcceptExListHead),
                      Verbosity,
                      &cc1,
                      (BYTE *) pAtqActiveContextList,
                      (BYTE *) &pAtqActiveContextList[ATQ_NUM_CONTEXT_LIST],
                      pEndpointIn
                      );
            if ( 0 != cc1) {
                dprintf( "\n\t%d Atq contexts traversed\n", cc1 );
                cContext += cc1;
            }
        }

        if ( CheckControlC() )
        {
            dprintf( "\n^C\n" );
            return;
        }


    }

    dprintf( "%d Atq contexts traversed\n",
             cContext );

    return;
} // DumpAtqContextList()



void
DumpEndpointList(
    LIST_ENTRY * pAtqClientHead,
    CHAR         Verbosity,
    DWORD *      pcContext,
    BYTE *       pvStart,
    BYTE *       pvEnd,
    ATQ_ENDPOINT * pEndpointIn
    )
{
    LIST_ENTRY *         pEntry;
    ATQ_CONTEXT *        pAtqContext;
    ATQ_CONTEXT          AtqContext;

    //
    //  the list head is embedded in a structure so the exit condition of the
    //  loop is when the remote memory address ends up in the array memory
    //

    for ( pEntry  = pAtqClientHead->Flink;
          !((BYTE *)pEntry >= pvStart && (BYTE *)pEntry <= pvEnd);
        )
    {
        if ( CheckControlC() )
        {
            return;
        }

        pAtqContext = CONTAINING_RECORD( pEntry,
                                         ATQ_CONTEXT,
                                         m_leTimeout );

        move( AtqContext, pAtqContext );

        // selectively print only the contexts that have a matching Endpoint
        if ( (pEndpointIn != NULL) &&
             (AtqContext.pEndpoint != pEndpointIn)
             ) {

            move( pEntry, &pEntry->Flink );
            continue;
        }


        (*pcContext)++;

        if ( AtqContext.Signature != ATQ_CONTEXT_SIGNATURE )
        {
            dprintf( "AtqContext(%08lp) signature %08lx doesn't"
                     " match expected %08lx\n",
                     pAtqContext,
                     AtqContext.Signature,
                     ATQ_CONTEXT_SIGNATURE
                     );

            return;
        }

        if ( Verbosity >= '1' )
        {
            //
            //  Print all
            //

            dprintf( "\nAtqContext at %08lp\n",
                     pAtqContext );

            PrintAtqContext( &AtqContext );

        }
        else if ( Verbosity >= '0' )
        {
            //
            //  Print all with one line summary info
            //

            dprintf( "hAsyncIO = %4lp, Flink = %08lp, Blink = %08lp,"
                     " State = %8lx, Flags =%8lx\n",
                     AtqContext.hAsyncIO,
                     AtqContext.m_leTimeout.Blink,
                     AtqContext.m_leTimeout.Flink,
                     AtqContext.m_acState,
                     AtqContext.m_acFlags
                     );
        }

        move( pEntry, &pEntry->Flink );
    }
} // DumpEndpointList()



VOID
PrintAtqContext(
    ATQ_CONTEXT * pContext
    )
{
    UCHAR szSymFnCallback[MAX_SYMBOL_LEN];
    ULONG_PTR offset;

             
    GetSymbol((ULONG_PTR) pContext->pfnCompletion,
              szSymFnCallback, &offset);

    if (!*szSymFnCallback)
        sprintf((char*) szSymFnCallback, "%p()",
                pContext->pfnCompletion);

    dprintf( "\n" );
    dprintf( "\thAsyncIO            = %08lp   Signature        = %08lx\n"
             "\tOverlapped.Internal = %08lp   Overlapped.Offset= %08lx\n"
             "\tLE-Timeout.Flink    = %08lp   LE-Timeout.Blink = %p\n"
             "\tClientContext       = %08lp   ContextList      = %p\n"
             "\tpfnIOCompletion     = %s\n"
             "\tlSyncTimeout        = %8d     m_nIO            = %8d\n"
             "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
             "\tBytesSent           = %d (0x%08lx)\n"
             "\tpvBuff              = %08lp   pEndPoint        = %08lp\n"
             "\tState               = %8lx    Flags            = %08lx\n",
             pContext->hAsyncIO,           pContext->Signature,
             pContext->Overlapped.Internal,pContext->Overlapped.Offset,
             pContext->m_leTimeout.Flink,  pContext->m_leTimeout.Blink,
             pContext->ClientContext,      pContext->ContextList,
             szSymFnCallback,
             pContext->lSyncTimeout,       pContext->m_nIO,
             pContext->TimeOut,            pContext->NextTimeout,
             pContext->BytesSent,          pContext->BytesSent,
             pContext->pvBuff,             pContext->pEndpoint,
             pContext->m_acState,          pContext->m_acFlags
             );

    // identify and print the various properties
    dprintf( "\t");
    // First print the state bits
    if ( pContext->m_acState & ACS_SOCK_CLOSED) {
        dprintf( " ACS_SOCK_CLOSED");
    }
    if ( pContext->m_acState & ACS_SOCK_UNCONNECTED) {
        dprintf( " ACS_SOCK_UNCONNECTED");
    }
    if ( pContext->m_acState & ACS_SOCK_LISTENING) {
        dprintf( " ACS_SOCK_LISTENING");
    }
    if ( pContext->m_acState & ACS_SOCK_CONNECTED) {
        dprintf( " ACS_SOCK_CONNECTED");
    }
    if ( pContext->m_acState & ACS_SOCK_TOBE_FREED) {
        dprintf( " ACS_SOCK_TOBE_FREED");
    }

    // now print the flags associated with this context
    if ( pContext->m_acFlags & ACF_ACCEPTEX_ROOT_CONTEXT) {
        dprintf( " ACCEPTEX_CONTEXT");
    }
    if ( pContext->m_acFlags & ACF_CONN_INDICATED) {
        dprintf( " CONNECTION_INDICATED");
    }
    if ( pContext->m_acFlags & ACF_IN_TIMEOUT) {
        dprintf( " IN_TIMEOUT");
    }
    if ( pContext->m_acFlags & ACF_BLOCKED) {
        dprintf( " BLOCKED_BY_BWT");
    }
    if ( pContext->m_acFlags & ACF_REUSE_CONTEXT) {
        dprintf( " REUSE_CONTEXT");
    }
    if ( pContext->m_acFlags & ACF_RECV_ISSUED) {
        dprintf( " RECV_ISSUED");
    }
    if ( pContext->m_acFlags & ACF_ABORTIVE_CLOSE) {
        dprintf( " ABORTIVE_CLOSE");
    }
    dprintf( "\n");

    if ( pContext->IsFlag( ACF_ACCEPTEX_ROOT_CONTEXT) && pContext->pvBuff )
    {
        //
        //  This size should correspond to the MIN_SOCKADDR_SIZE field in
        //  atqnew.c.  We assume it's two thirty two byte values currently.
        //

        DWORD AddrInfo[16];
        ATQ_ENDPOINT       * pEndpoint = pContext->pEndpoint;
        ATQ_ENDPOINT         Endpoint;

        move( Endpoint, pEndpoint );

        if ( ReadMemory( (LPVOID) ((BYTE *) pContext->pvBuff +
                                   Endpoint.InitialRecvSize +
                                   2 * MIN_SOCKADDR_SIZE -
                                   sizeof( AddrInfo )),
                         AddrInfo,
                         sizeof(AddrInfo),
                         NULL ))
        {

            dprintf( "\tLocal/Remote Addr   = %08x %08x %08x %08x\n"
                     "\t                      %08x %08x %08x %08x\n"
                     "\t                      %08x %08x %08x %08x\n"
                     "\t                      %08x %08x %08x %08x\n",
                     AddrInfo[0],
                     AddrInfo[1],
                     AddrInfo[2],
                     AddrInfo[3],
                     AddrInfo[4],
                     AddrInfo[5],
                     AddrInfo[6],
                     AddrInfo[7],
                     AddrInfo[8],
                     AddrInfo[9],
                     AddrInfo[10],
                     AddrInfo[11],
                     AddrInfo[12],
                     AddrInfo[13],
                     AddrInfo[14],
                     AddrInfo[15] );
        }
    }
} // PrintAtqContext()


VOID
DumpEndpoint(
    CHAR Verbosity
    )
{
    LIST_ENTRY           AtqEndpointList;
    LIST_ENTRY *         pAtqEndpointList;
    LIST_ENTRY *         pEntry;
    ATQ_CONTEXT *        pAtqContext;
    ATQ_CONTEXT          AtqContext;
    CHAR                 Symbol[256];
    DWORD                cEndp = 0;
    DWORD                i;
    ATQ_ENDPOINT       * pEndpoint;
    ATQ_ENDPOINT         Endpoint;

    pAtqEndpointList = (LIST_ENTRY *) GetExpression( "&isatq!AtqEndpointList" );

    if ( !pAtqEndpointList )
    {
        dprintf("Unable to get AtqEndpointList symbol\n" );
        return;
    }

    move( AtqEndpointList, pAtqEndpointList );

    for ( pEntry  =  AtqEndpointList.Flink;
          pEntry != pAtqEndpointList;
          cEndp++
        )
    {
        if ( CheckControlC() )
        {
            return;
        }

        pEndpoint = CONTAINING_RECORD( pEntry,
                                       ATQ_ENDPOINT,
                                       ListEntry );

        move( Endpoint, pEndpoint );

        if ( Endpoint.Signature != ATQ_ENDPOINT_SIGNATURE )
        {
            dprintf( "Endpoint(%08p) signature %08lx doesn't match expected %08lx\n",
                     pEndpoint,
                     Endpoint.Signature,
                     ATQ_ENDPOINT_SIGNATURE
                     );

            break;
        }

        if ( Verbosity >= '1' )
        {
            //
            //  Print all
            //

            dprintf( "\nEndpoint at %08lp\n",
                     pEndpoint );

            PrintEndpoint( &Endpoint );

        }
        else if ( Verbosity >= '0' )
        {
            //
            //  Print all with one line summary info
            //

            dprintf( "sListenSocket = %4lp, cRef = %d, cSocketsAvail = %d\n",
                      Endpoint.ListenSocket,
                      Endpoint.m_refCount,
                      Endpoint.nSocketsAvail );
        }

        move( pEntry, &pEntry->Flink );
    }

    dprintf( "%d Atq Endpoints traversed\n",
             cEndp );

    return;
} // DumpEndpoint()


void
PrintEndpoint(
    ATQ_ENDPOINT * pEp
    )
{

    dprintf( "\tcRef             = %8d     State             = %s\n"
             "\tIP Address       = %s      Port              = %04x\n"
             "\tsListenSocket    = %8p     InitRecvSize      = %04x\n"
             "\tnSocketsAvail    = %8d     nAvailAtTimeout   = %d\n"
             "\tnAcceptExOutstdg =%8d\n"
             "\tUseAcceptEx      = %8s     AcceptExTimeout   = %8d\n"
             "\tEnableBw Throttle= %s\n"
             "\tListEntry.Flink  = %08lp     ListEntry.Blink   = %08lp\n"
             "\tClient Context   = %08lp     pfnCompletion     = %08lp()\n"
             "\tpfnConnComp      = %08lp()   pfnConnExComp     = %08lp()\n"
             "\tShutDownCallback = %08lp()   ShutDown Context  = %08lp\n"
             ,
             pEp->m_refCount,
             AtqEndpointState[pEp->State],
             pEp->IpAddress,
             pEp->Port,
             pEp->ListenSocket,
             pEp->InitialRecvSize,
             pEp->nSocketsAvail,
             pEp->nAvailDuringTimeOut,
             pEp->nAcceptExOutstanding,
             BoolValue( pEp->UseAcceptEx),
             pEp->AcceptExTimeout,
             BoolValue( pEp->EnableBw),
             pEp->ListEntry.Flink,
             pEp->ListEntry.Blink,
             pEp->Context,
             pEp->IoCompletion,
             pEp->ConnectCompletion,
             pEp->ConnectExCompletion,
             pEp->ShutdownCallback,
             pEp->ShutdownCallbackContext
             );

    return;
} // PrintEndpoint()


/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgcc.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgcc.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    IIS - W3SVC Client Connection

Author:

    Murali R. Krishnan (MuraliK)  22-Aug-1997

Revision History:

--*/

#include "inetdbgp.h"

# undef DBG_ASSERT



/************************************************************
 *   Debugger Utility Functions
 ************************************************************/

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;



/************************************************************
 * CLIENT_CONN related functions
 ************************************************************/
char * g_rgchCCState[] = {
    "CcsStartup",
    "CcsGettingClientReq",
    "CcsGatheringGatewayData",
    "CcsProcessingClientReq",
    "CcsDisconnecting",
    "CcsShutdown",
    "CcsMaxItems"
};

#define LookupCCState( ItemState ) \
            ((((ItemState) >= CCS_STARTUP) && ((ItemState) <= CCS_SHUTDOWN)) ?\
             g_rgchCCState[ (ItemState)] : "<Invalid>")



VOID PrintClientConn( CLIENT_CONN * pccOriginal,
                      CLIENT_CONN * pcc, CHAR Verbosity);

VOID
PrintClientConnThunk( PVOID pccDebuggee,
                      PVOID pccDebugger,
                      CHAR  verbosity,
                      DWORD iCount);


DECLARE_API( cc )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    DEFINE_CPP_VAR( CLIENT_CONN, cc);
    CLIENT_CONN * pcc;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "cc" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "cc" );
            return;
        }


        if ( *lpArgumentString == 'l' ) {

            DumpClientConnList( lpArgumentString[1], PrintClientConnThunk );
            return;
        }

    } // while

    //
    //  Treat the argument as the address of an AtqContext
    //

    pcc = (CLIENT_CONN * ) GetExpression( lpArgumentString );

    if ( !pcc )
    {
        dprintf( "inetdbg.cc: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( cc, pcc );
    PrintClientConn( pcc, GET_CPP_VAR_PTR( CLIENT_CONN, cc), '2' );

    return;
} // DECLARE_API( cc )


VOID
PrintClientConn( CLIENT_CONN * pccOriginal,
                 CLIENT_CONN * pcc,
                 CHAR Verbosity )
/*++
  Description:
    This function takes the client connection object and prints out
    the details for the same in the debugger. The granularity of the
    deatils are controlled by the verbosity flag

  Arguments:
    pccOriginal - pointer to the location where the original CLIENT_CONN
                  object is located.
                  Note: pccOriginal points to object inside debuggee process
    pcc         - pointer to the Client Connection object that is a copy
                  of the contents located at [pccOriginal]
                  Note: pcc points to object inside the debugger process
    Verbostiy   - level of details requested.

  Returns:
    None
--*/
{
    if ( Verbosity >= '0') {

        //
        // print Brief information about the client connection
        //

        dprintf( "ClIENT_CONN:%08p Refs = %8d   State      = %15s\n"
                 "\t HTTP_REQUEST     = %08p  AtqContext  = %08p\n"
                 ,
                 pccOriginal, pcc->_cRef,
                 LookupCCState( pcc->_ccState),
                 pcc->_phttpReq,
                 pcc->_AtqContext
                 );
    }

    if ( Verbosity >= '1' ) {

        //
        //  Print all details for the Client Connection object
        //


        dprintf( "\tSignature         = %08x   fSecurePort=%d  fValid=%d; \n"
                 "\tSocket            = %08p   Port: Local=%hd  Remote=%hd\n"
                 "\tListEntry.Flink   = %08p   ListEntry.Blink   = %08p\n"
                 "\tInitialBuffer     = %08p   InitialBytesRecvd = %d\n"
                 "\tBuffLE.Flink      = %08p   BuffLE.Blink      = %08p\n"
                 "\tAddress Local     = %10s Address Remote    = %10s\n"
                 "\tW3Instance        = %08p   Reflog            = %08p\n"
                 ,
                 pcc->_Signature,  pcc->_fSecurePort, pcc->_fIsValid,
                 pcc->_sClient,    pcc->_sPort,      pcc->_sRemotePort,
                 pcc->ListEntry.Flink,               pcc->ListEntry.Blink,
                 pcc->_pvInitial,                    pcc->_cbInitial,
                 pcc->_BuffListEntry.Flink,          pcc->_BuffListEntry.Blink,
                 pcc->_achLocalAddr,                 pcc->_achRemoteAddr,
                 pcc->m_pInstance,
#if CC_REF_TRACKING   // Enabled in free builds for build 585 and later
                 pcc->_pDbgCCRefTraceLog
#else
                 (PVOID)(-1)
#endif
                 );
    }


    if ( Verbosity >= '2' ) {

        //
        //  Print the initial request received for the client connection
        //

        dstring( "  Initial Request", pcc->_pvInitial, pcc->_cbInitial);
    }

    return;
} // PrintClientConn()




VOID
PrintClientConnThunk( PVOID pccDebuggee,
                      PVOID pccDebugger,
                      CHAR  verbosity,
                      DWORD iThunk)
/*++
  Description:
    This is the callback function for printing the CLIENT_CONN object.

  Arguments:
    pccDebuggee  - pointer to client conn object in the debuggee process
    pccDebugger  - pointer to client conn object in the debugger process
    verbosity    - character indicating the verbosity level desired

  Returns:
    None
--*/
{
    if ( ((CLIENT_CONN * )pccDebugger)->_Signature != CLIENT_CONN_SIGNATURE) {

        dprintf( "ClientConn(%08lp) signature %08lx doesn't"
                 " match expected %08lx\n",
                 pccDebuggee,
                 ((CLIENT_CONN * )pccDebugger)->_Signature,
                 CLIENT_CONN_SIGNATURE
                 );
        return;
    }

    PrintClientConn( (CLIENT_CONN *) pccDebuggee,
                     (CLIENT_CONN *) pccDebugger,
                     verbosity);
} // PrintClientConnThunk()



VOID
DumpClientConnList(
    CHAR Verbosity,
    PFN_LIST_ENUMERATOR pfnCC
    )
{
    LIST_ENTRY *         pccListHead;

    pccListHead = (LIST_ENTRY *) GetExpression( "&w3svc!listConnections");

    if ( NULL == pccListHead) {

        dprintf( " Unable to get Client Connections list \n");
        return;
    }

    EnumLinkedList( pccListHead, pfnCC, Verbosity,
                    sizeof( CLIENT_CONN),
                    FIELD_OFFSET( CLIENT_CONN, ListEntry)
                    );

    return;
} // DumpClientConnList()



/************************************************************
 * HTTP_REQUEST related functions
 ************************************************************/
char * g_rgchHREQState[] = {
    "HtrReadingClientRequest",
    "HtrReadingGatewayData",
    "HtrParse",
    "HtrDoVerb",
    "HtrGatewayAsyncIO",
    "HtrSendFile",
    "HtrProxySendingRequest",
    "HtrCgi",
    "HtrRange",
    "HtrRestartRequest",
    "HtrWritingFile",
    "HtrCertRenegotiate",
    "HtrMaxItems"
};

#define LookupHREQState( ItemState ) \
            ((((ItemState) >= HTR_READING_CLIENT_REQUEST) && \
              ((ItemState) <= HTR_DONE)) ?\
             g_rgchHREQState[ (ItemState)] : "<Invalid>")

const char * g_rgchHreqPutState[] = {
    "PSTATE_START",
    "PSTATE_READING",
    "PSTATE_DISCARD_READING",
    "PSTATE_DISCARD_CHUNK"
};

# define LookupHreqPutState( ItemState) \
            ((((ItemState) >= PSTATE_START) && \
              ((ItemState) <= PSTATE_DISCARD_CHUNK)) ?\
             g_rgchHreqPutState[ (ItemState)] : "<Invalid>")


VOID
PrintHttpRequest( HTTP_REQUEST * phreqOriginal,
                  HTTP_REQUEST * phreq,
                  CHAR Verbosity);

VOID
PrintHttpRequestThunk( PVOID pccDebuggee,
                       PVOID pccDebugger,
                       CHAR  verbosity,
                       DWORD iCount);


DECLARE_API( hreq )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    DEFINE_CPP_VAR( HTTP_REQUEST, hreq);
    HTTP_REQUEST * phreq;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "hreq" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "hreq" );
            return;
        }


        if ( *lpArgumentString == 'l' ) {

            DumpClientConnList( lpArgumentString[1],
                                PrintHttpRequestThunk);
            return;
        }

    } // if

    //
    //  Treat the argument as the address of an AtqContext
    //

    phreq = (HTTP_REQUEST * ) GetExpression( lpArgumentString );

    if ( !phreq )
    {
        dprintf( "inetdbg.hreq: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( hreq, phreq );
    PrintHttpRequest( phreq, GET_CPP_VAR_PTR( HTTP_REQUEST, hreq), '2');

    return;
} // DECLARE_API( hreq )



VOID
PrintHttpRequestThunk(
    PVOID pccDebuggee,
    PVOID pccDebugger,
    CHAR  verbosity,
    DWORD iCount)
/*++
  Description:
    This is the callback function for printing the HTTP_REQUEST object.

  Arguments:
    pccDebuggee  - pointer to client conn object in the debuggee process
    pccDebugger  - pointer to client conn object in the debugger process
    verbosity    - character indicating the verbosity level desired

  Returns:
    None
--*/
{
    DEFINE_CPP_VAR( HTTP_REQUEST, hreq);
    HTTP_REQUEST * phreq;

    CLIENT_CONN * pcc = (CLIENT_CONN *) pccDebugger;

    if ( pcc->_Signature != CLIENT_CONN_SIGNATURE) {

        dprintf( "ClientConn(%08lp) signature %08lx doesn't"
                 " match expected %08lx\n",
                 pccDebuggee,
                 pcc->_Signature,
                 CLIENT_CONN_SIGNATURE
                 );
        return;
    }


    //
    // Obtain the pointer for HTTP_REQUEST object from CLIENT_CONN object
    //  and make local copy of the HTTP_REQUEST object inside debugger process
    //
    phreq = (HTTP_REQUEST *) pcc->_phttpReq;
    move( hreq, phreq);

    // Print out the http request object
    PrintHttpRequest( phreq,
                      GET_CPP_VAR_PTR( HTTP_REQUEST, hreq),
                      verbosity);
} // PrintHttpRequestThunk()


VOID
PrintHttpRequest( HTTP_REQUEST * phreqOriginal,
                  HTTP_REQUEST * phreq,
                  CHAR Verbosity )
/*++
  Description:
    This function takes the HTTP_REQUEST object and prints out
    the details for the same in the debugger. The granularity of the
    deatils are controlled by the verbosity flag

  Arguments:
    phreqOriginal - pointer to the location where the original HTTP_REQUEST
                  object is located.
                  Note: phreqOriginal points to object inside debuggee process
    phreq         - pointer to the HTTP_REQUEST object that is a copy
                  of the contents located at [phreqOriginal]
                  Note: phreq points to object inside the debugger process
    Verbostiy   - level of details requested.

  Returns:
    None
--*/
{
    if ( Verbosity >= '0') {

        //
        // print Brief information about the client connection
        //

        dprintf( "HTTP_REQUEST:%08p       State           = %15s\n"
                 "\t CLIENT_CONN       = %08p  WamReq          = %08p\n"
                 ,
                 phreqOriginal,
                 LookupHREQState( phreq->_htrState),
                 phreq->_pClientConn,
                 phreq->_pWamRequest
                 );
    }

    if ( Verbosity >= '1' ) {

        //
        //  Print all details for the Client Connection object
        //

        dprintf( "\t _fKeepConn        = %8s  _fLoggedOn      = %8s\n"
                 "\t _fChunked         = %8s  Client Ver      =      %d.%d\n"
                 "\t _tcpauth          = %08p  _Filter         = %p \n"
                 "\t _cbClientRequest  = %8d  _cbOldData      = %8d\n"
                 "\t _cbEntityBody     = %8d  _cbTotalEntBody = %8d\n"
                 "\t _cbChunkHeader    = %8d  _cbChunkBytesRead=%8d\n"
                 "\t _cbExtraData      = %8d  _pchExtraData   = %08p\n"
                 "\t _pMetaData        = %08p  _pURIInfo       = %08p\n"
                 "\t _pGetFile         = %08p  _Exec           = %08p\n"
                 "\t _pW3Stats         = %08p\n"
                 "\t _dwLogHttpResponse= %8d  _dwLogWinError  = %8d\n"
                 ,
                 BoolValue(phreq->_fKeepConn),
                 BoolValue(phreq->_fLoggedOn),
                 BoolValue(phreq->_fChunked),
                 (int) phreq->_VersionMajor, (int) phreq->_VersionMinor,
                 (BYTE *) phreqOriginal + ((BYTE *) &phreq->_tcpauth - (BYTE *) phreq),
                 (BYTE *) phreqOriginal + ((BYTE *) &phreq->_Filter - (BYTE *) phreq),
                 phreq->_cbClientRequest,
                 phreq->_cbOldData,
                 phreq->_cbEntityBody,
                 phreq->_cbTotalEntityBody,
                 phreq->_cbChunkHeader,
                 phreq->_cbChunkBytesRead,
                 phreq->_cbExtraData,
                 phreq->_pchExtraData,
                 phreq->_pMetaData,
                 phreq->_pURIInfo,
                 phreq->_pGetFile,
                 (BYTE *) phreqOriginal + ((BYTE *) &phreq->_Exec - (BYTE *) phreq),
                 phreq->_pW3Stats,
                 phreq->_dwLogHttpResponse,
                 phreq->_dwLogWinError
                 );
    }


    if ( Verbosity >= '2' ) {

        //
        //  Print state specific data
        //

        dprintf( "\t _putstate         = %8s  _pFileNameLock   = %8p\n"
                 , LookupHreqPutState( phreq->_putstate)
                 , phreq->_pFileNameLock
                 );
    }

    return;
} // PrintHttpRequest()





VOID
PrintW3Statistics( W3_SERVER_STATISTICS * pw3statsDebuggee );

/*++

    NAME:       wstats

    SYNOPSIS:   Displays the w3svc statistics.
    By default print the global w3svc statistics.
    If given an argument treat that argument as a pointer to the
       W3_SERVER_STATISITCS structure and print it out

--*/
DECLARE_API( wstats )
{
    W3_SERVER_STATISTICS * pw3stats;
    W3_IIS_SERVICE * pw3s;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;


    //
    //  Capture the statistics.
    //
    if ( !*lpArgumentString ) {

        dprintf( "OffsetOfGlobalStats from W3_IIS_SERVICE = %d (0x%x)\n",
                 FIELD_OFFSET( W3_IIS_SERVICE, m_GlobalStats),
                 FIELD_OFFSET( W3_IIS_SERVICE, m_GlobalStats)
                 );

        dprintf( "OffsetOfStats from W3_SERVER_INSTANCE = %d (0x%x)\n",
                 FIELD_OFFSET( W3_SERVER_INSTANCE, m_pW3Stats),
                 FIELD_OFFSET( W3_SERVER_INSTANCE, m_pW3Stats)
                 );

        //
        // In IIS 4.0, the global statistics structure is part of
        //  the W3_IIS_SERVICE structure - obtain the address indirectly.
        //

        W3_IIS_SERVICE ** ppw3s;

        ppw3s = (W3_IIS_SERVICE **) GetExpression( "w3svc!g_pInetSvc");
        if ( !ppw3s) {
            dprintf( "Unable to get w3svc!g_pInetSvc to fetch global stats\n");
            return;
        }

        //
        // From the pointer to pointer to W3_IIS_SERVICE,
        // obtain the pointer to the W3_IIS_SERVICE
        //
        moveBlock( pw3s, ppw3s, sizeof(W3_IIS_SERVICE * ));

        pw3stats = &pw3s->m_GlobalStats;
    } else {

        //
        // extract the address from the argument given
        //

        pw3stats = (W3_SERVER_STATISTICS * ) GetExpression( lpArgumentString );
    }

    PrintW3Statistics( pw3stats);
    return;
}   // stats


# define P2DWORDS( a, b) \
    Print2Dwords( #a, \
                  pw3statsDebugger->m_W3Stats. ## a, \
                  #b, \
                  pw3statsDebugger->m_W3Stats. ## b \
                )

VOID
PrintW3Statistics( W3_SERVER_STATISTICS * pw3statsDebuggee )
/*++
  Description:
    This function takes the W3_SERVER_STATISTICS object and prints out
    the details for the same in the debugger.

  Arguments:
    pw3statsDebuggee - pointer to the location where the original structure
                    is found inside the debuggee process.
    pw3statsDebugger - pointer to the copy of the data in the debugger process.

  Returns:
    None
--*/
{
    DEFINE_CPP_VAR( W3_SERVER_STATISTICS, w3stats);
    W3_SERVER_STATISTICS * pw3statsDebugger =
        (W3_SERVER_STATISTICS *) &w3stats;

    CHAR             szLargeInt[64];

    //
    // copy the statistics data into the local buffer inside the debugger
    //  process so we can play with it
    //

    move( w3stats, pw3statsDebuggee);

    dprintf( " %30s = 0x%08p\n",
             "W3_SERVER_STATISTICS",
             pw3statsDebuggee);

    PrintLargeInteger( "TotalBytesSent",
                       &pw3statsDebugger->m_W3Stats.TotalBytesSent);
    PrintLargeInteger( "TotalBytesReceived",
                       &pw3statsDebugger->m_W3Stats.TotalBytesReceived);

    P2DWORDS( TotalFilesSent, TotalFilesReceived);
    dprintf("\n");

    P2DWORDS( CurrentAnonymousUsers, CurrentNonAnonymousUsers);
    P2DWORDS( TotalAnonymousUsers, TotalNonAnonymousUsers);
    P2DWORDS( MaxAnonymousUsers, MaxNonAnonymousUsers);
    P2DWORDS( CurrentConnections, MaxConnections);
    P2DWORDS( ConnectionAttempts, LogonAttempts);
    dprintf( "\n");

    P2DWORDS( TotalGets, TotalPosts);
    P2DWORDS( TotalHeads, TotalPuts);
    P2DWORDS( TotalDeletes, TotalTraces);
    P2DWORDS( TotalOthers, TotalNotFoundErrors);
    P2DWORDS( TotalCGIRequests, TotalBGIRequests);
    dprintf( "\n");

    P2DWORDS( CurrentCGIRequests, MaxCGIRequests);
    P2DWORDS( CurrentBGIRequests, MaxBGIRequests);


    return;
} // PrintW3Statistics()




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbglocks.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbglocks.cxx

Abstract:

    Locks support

Author:

    George V. Reilly (GeorgeRe)  01-Mar-1999

Revision History:

--*/

#include "inetdbgp.h"

#ifdef LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME ("inetdbg")
# ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
LONG CSmallSpinLock::sm_cTotalLocks   = 0;
# endif

#ifdef TEST_LOCKS
LONG CSpinLock1::sm_cTotalLocks        = 0;
LONG CSpinLock2::sm_cTotalLocks       = 0;
#endif // TEST_LOCKS

LONG CSpinLock::sm_cTotalLocks       = 0;
LONG CReaderWriterLock::sm_cTotalLocks  = 0;
LONG CReaderWriterLock2::sm_cTotalLocks = 0;
LONG CReaderWriterLock3::sm_cTotalLocks = 0;
#else // !LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME 
#endif // !LOCK_INSTRUMENTATION

const char*
LockName(
    LOCK_LOCKTYPE lt)
{
    const char* pszName = NULL;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        pszName = "CSmallSpinLock";
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        pszName = "CSpinLock1";
        break;
    case LOCK_SPINLOCK2:
        pszName = "CSpinLock2";
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        pszName = "CSpinLock";
        break;
    case LOCK_FAKELOCK:
        pszName = "CFakeLock";
        break;
    case LOCK_CRITSEC:
        pszName = "CCritSec";
        break;
    case LOCK_RTLRESOURCE:
        pszName = "CRtlResource";
        break;
    case LOCK_SHARELOCK:
        pszName = "CShareLock";
        break;
    case LOCK_READERWRITERLOCK:
        pszName = "CReaderWriterLock";
        break;
    case LOCK_READERWRITERLOCK2:
        pszName = "CReaderWriterLock2";
        break;
    case LOCK_READERWRITERLOCK3:
        pszName = "CReaderWriterLock3";
        break;
    default:
        pszName = "UnknownLockType";
        break;
    }

    return pszName;
};

int
LockSize(
    LOCK_LOCKTYPE lt)
{
    int cb = 0;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        cb = sizeof(CSmallSpinLock);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        cb = sizeof(CSpinLock1);
        break;
    case LOCK_SPINLOCK2:
        cb = sizeof(CSpinLock2);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        cb = sizeof(CSpinLock);
        break;
    case LOCK_FAKELOCK:
        cb = sizeof(CFakeLock);
        break;
    case LOCK_CRITSEC:
        cb = sizeof(CCritSec);
        break;
    case LOCK_RTLRESOURCE:
        cb = sizeof(CRtlResource);
        break;
    case LOCK_SHARELOCK:
        cb = sizeof(CShareLock);
        break;
    case LOCK_READERWRITERLOCK:
        cb = sizeof(CReaderWriterLock);
        break;
    case LOCK_READERWRITERLOCK2:
        cb = sizeof(CReaderWriterLock2);
        break;
    case LOCK_READERWRITERLOCK3:
        cb = sizeof(CReaderWriterLock3);
        break;
    default:
        cb = 0;
        break;
    }

    return cb;
};



BOOL
Print_SmallSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl LOCK_DEFAULT_NAME;
#else // !LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl;
#endif // !LOCK_SMALL_SPIN_INSTRUMENTATION

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSmallSpinLock (%p): Thread = %x\n",
            pvLock, sl.m_lTid);

    return TRUE;
}



#ifdef TEST_LOCKS

BOOL
Print_SpinLock1(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock1 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock1 (%p): ssl = %x, Thread = %hd, Owners = %d, RW = %d\n",
            pvLock, sl.m_ssl.m_lLock, sl.m_nThreadId,
            (int) sl.m_cOwners, (int) sl.m_nRWState);

    return TRUE;
}



BOOL
Print_SpinLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock2 (%p): Thread = %hd, Count = %hd\n",
            pvLock, sl.m_data.m_nThreadId, sl.m_data.m_cOwners);

    return TRUE;
}

#endif // TEST_LOCKS


BOOL
Print_SpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock (%p): Thread = %d, Count = %d\n",
            pvLock,
            (sl.m_lTid & CSpinLock::THREAD_MASK) >> CSpinLock::THREAD_SHIFT,
            (sl.m_lTid & CSpinLock::OWNER_MASK) >> CSpinLock::OWNER_SHIFT);

    return TRUE;
}



BOOL
Print_FakeLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_CritSec(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_RtlResource(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ShareLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ReaderWriterLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock (%p): State = %x, Waiters = %d\n",
            pvLock, sl.m_nState, sl.m_cWaiting);

    return TRUE;
}



BOOL
Print_ReaderWriterLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock2 (%p): State = %x, Waiters = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock2::SL_STATE_MASK)
                >> CReaderWriterLock2::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock2::SL_WAITING_MASK)
                >> CReaderWriterLock2::SL_WAITING_SHIFT
            );

    return TRUE;
}



BOOL
Print_ReaderWriterLock3(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock3 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock3 (%p): State = %x, Waiters = %d, "
            "Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                >> CReaderWriterLock3::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock3::SL_WAITING_MASK)
                >> CReaderWriterLock3::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_THREAD_MASK)
                >> CReaderWriterLock3::SL_THREAD_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_OWNER_MASK)
                >> CReaderWriterLock3::SL_OWNER_SHIFT
            );

    return TRUE;
}



BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose)
{
    BOOL f = FALSE;
    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        f = Print_SmallSpinLock(pvLock, nVerbose);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        f = Print_SpinLock1(pvLock, nVerbose);
        break;
    case LOCK_SPINLOCK2:
        f = Print_SpinLock2(pvLock, nVerbose);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        f = Print_SpinLock(pvLock, nVerbose);
        break;
    case LOCK_FAKELOCK:
        f = Print_FakeLock(pvLock, nVerbose);
        break;
    case LOCK_CRITSEC:
        f = Print_CritSec(pvLock, nVerbose);
        break;
    case LOCK_RTLRESOURCE:
        f = Print_RtlResource(pvLock, nVerbose);
        break;
    case LOCK_SHARELOCK:
        f = Print_ShareLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK:
        f = Print_ReaderWriterLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK2:
        f = Print_ReaderWriterLock2(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK3:
        f = Print_ReaderWriterLock3(pvLock, nVerbose);
        break;
    default:
        f = FALSE;
        break;
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbglkrh.cxx ===
/*++


Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbglkrh.cxx

Abstract:

    LKRhash support

Author:

    George V. Reilly (GeorgeRe)  22-Feb-1999

Revision History:

--*/

#include "inetdbgp.h"

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets = 0;
LONG CLKRLinearHashTable::sm_cTables           = 0;
#endif // LOCK_INSTRUMENTATION

// #define SAMPLE_LKRHASH_TESTCLASS
// #include <lkrhash.h>


// There are several different DLLs in the IISRTL family. This is to
// allow us to set the name of the DLL on the fly.
// TODO: add a command to set this name dynamically.
CHAR g_szIisRtlName[MAX_PATH] = IISRTL_NAME;

// sprintf-formatted string, e.g., "&%s!CLKRHashTable__sm_llGlobalList"
// Has to return LPSTR, not LPCSTR, because GetExpression is not const-correct
LPSTR
IisRtlVar(
    LPCSTR pszFormat)
{
    // we can get away with a static CHAR[] because debugger extensions
    // are single-threaded
    static CHAR szSymbol[MAX_SYMBOL_LEN];

    sprintf(szSymbol, pszFormat, g_szIisRtlName);
    return szSymbol;
}


class CTest
{
public:
    enum {BUFFSIZE=20};

    int   m_n;                  // This will also be a key
    char  m_sz[BUFFSIZE];       // This will be the primary key
    bool  m_fWhatever;
    mutable LONG  m_cRefs;      // Reference count for lifetime management.
                                // Must be mutable to use 'const CTest*' in
                                // hashtables

    CTest(int n, const char* psz, bool f)
        : m_n(n), m_fWhatever(f), m_cRefs(0)
    {
        strncpy(m_sz, psz, BUFFSIZE-1);
        m_sz[BUFFSIZE-1] = '\0';
    }

    ~CTest()
    {
        IRTLASSERT(m_cRefs == 0);
    }
};

BOOL
TestEnum(
    IN const void* pvParam,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    CTest* pTest = (CTest*) pvParam;
    CTest  tst(0, "", 0);
    ReadMemory(pTest, &tst, sizeof(tst), NULL);
    dprintf("%8p: %d %s %d %d \n",
            pTest, tst.m_n, tst.m_sz, tst.m_fWhatever, tst.m_cRefs);
    return TRUE;
}



// Dummy implementations so that we can link

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls            // for signature compatiblity
                                    // with CLKRHashTable
    )
#ifdef LKR_NEWCODE
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL)
#endif // LKR_NEWCODE
{}

#ifdef LKR_NEWCODE
CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent       // Owning table.
    )
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL)
{}
#endif // LKR_NEWCODE

CLKRLinearHashTable::~CLKRLinearHashTable()
{}

CLKRHashTable::CLKRHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls            // #subordinate hash tables
    )
{}

CLKRHashTable::~CLKRHashTable()
{}



/************************************************************
 * Dump LKRhash tables
 ************************************************************/
const char*
LKRC2String(
    LK_RETCODE lkrc)
{
    const char* psz = NULL;

    switch (lkrc)
    {
    case LK_UNUSABLE:
        psz = "LK_UNUSABLE";
        break;
    case LK_ALLOC_FAIL:
        psz = "LK_ALLOC_FAIL";
        break;
    case LK_BAD_ITERATOR:
        psz = "LK_BAD_ITERATOR";
        break;
    case LK_BAD_RECORD:
        psz = "LK_BAD_RECORD";
        break;
    case LK_BAD_PARAMETERS:
        psz = "LK_BAD_PARAMETERS";
        break;
    case LK_NOT_INITIALIZED:
        psz = "LK_NOT_INITIALIZED";
        break;
    case LK_SUCCESS:
        psz = "LK_SUCCESS";
        break;
    case LK_KEY_EXISTS:
        psz = "LK_KEY_EXISTS";
        break;
    case LK_NO_SUCH_KEY:
        psz = "LK_NO_SUCH_KEY";
        break;
    case LK_NO_MORE_ELEMENTS:
        psz = "LK_NO_MORE_ELEMENTS";
        break;
    default:
        psz = "Unknown LK_RETCODE";
        break;
    }

    return psz;
}


BOOL
DefaultLKRhashEnum(
    IN const void* pvParam,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    dprintf("%8p (%08x)\n", pvParam, dwSignature);
    return TRUE;
}


typedef CLKRLinearHashTable::CBucket        CBucket;
typedef CLKRLinearHashTable::CNodeClump     CNodeClump;
typedef CLKRLinearHashTable::CSegment       CSegment;
typedef CLKRLinearHashTable::CSmallSegment  CSmallSegment;
typedef CLKRLinearHashTable::CMediumSegment CMediumSegment;
typedef CLKRLinearHashTable::CLargeSegment  CLargeSegment;
typedef CLKRLinearHashTable::CDirEntry      CDirEntry;

enum {
    NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
    HASH_INVALID_SIGNATURE = CLKRLinearHashTable::HASH_INVALID_SIGNATURE,
};



BOOL
EnumerateBucketChain(
    IN PFN_ENUM_LKRHASH     pfnEnum,
    IN LOCK_LOCKTYPE        ltBucketLockType,
    IN CBucket*             pbkt,
    IN INT                  nVerbose)
{
    PSTR cmdName = "lkrhash";
    CBucket     bkt;
    CNodeClump  nc;
    CNodeClump* pncCurr;
    CNodeClump* pncPrev = NULL;
    DWORD       cNodes = 0;

    ReadMemory(pbkt, &bkt, sizeof(bkt), NULL);

    PrintLock(ltBucketLockType, &pbkt->m_Lock, nVerbose);

    for (pncCurr = (CNodeClump*) ((PBYTE) pbkt + LockSize(ltBucketLockType));
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = nc.m_pncNext)
    {
        DWORD i, c;

        ReadMemory(pncCurr, &nc, sizeof(nc), NULL);

        for (i = c = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (nc.m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                c++;
        }

        if (c == NODES_PER_CLUMP)
        {
            dprintf("  0-%d: -- empty\n", NODES_PER_CLUMP);
        }
        else
        {
            for (i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (nc.m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                {
                    dprintf("  %d: --\n", i);
                }
                else
                {
                    (*pfnEnum)(nc.m_pvNode[i], nc.m_dwKeySigs[i], nVerbose);
                }
            }
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            return FALSE;
        }

        const DWORD MAX_NODES = 20;
        if (++cNodes > MAX_NODES)
        {
            dprintf("inetdbg.%s: Bucket chain contains more than %d nodes! "
                    "Corrupted?\n", cmdName, MAX_NODES);
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
EnumerateLKRLinearHashTable(
    IN PFN_ENUM_LKRHASH     pfnEnum,
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    PSTR cmdName = "lkrhash";
    CLKRLinearHashTable lht(NULL, NULL, NULL, NULL, NULL);
    INT i;
    BOOL fRet = FALSE;
    LOCK_LOCKTYPE ltTableLockType  = LOCK_SPINLOCK;
    LOCK_LOCKTYPE ltBucketLockType = LOCK_SPINLOCK;
    CDirEntry* paDirSegs = NULL;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(plht, &lht, sizeof(lht), NULL) )
    {
        dprintf("inetdbg.%s: cannot read memory @ %p\n",
                cmdName, (PVOID)plht);

        goto cleanup;
    }

    dprintf(
        "\ninetdbg.%s: @ %p:\n"
        "    CLKRLinearHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    State = %d (%s)\n",
        cmdName,
        plht,
        lht.m_dwSignature,
        DECODE_SIGNATURE(lht.m_dwSignature),
        lht.m_dwSignature == CLKRLinearHashTable::SIGNATURE
            ? "OK" : (lht.m_dwSignature == CLKRLinearHashTable::SIGNATURE_FREE
                      ? "FREED" : "INVALID"),
        lht.m_szName,
        lht.m_lkrcState, LKRC2String(lht.m_lkrcState));

    if (nVerbose == 0)
        goto done;

#ifdef LKR_NEWCODE
    ltTableLockType  = (LOCK_LOCKTYPE) lht.m_nTableLockType;
    ltBucketLockType = (LOCK_LOCKTYPE) lht.m_nBucketLockType;
    dprintf(
        "    TableLock = %s, BucketLock = %s, Parent CLKRHashTable = %p\n",
        LockName(ltTableLockType),
        LockName(ltBucketLockType),
        lht.m_phtParent);
#endif // LKR_NEWCODE

    dprintf(
        "    Size = %d, SegBits = %d, SegSize = %d, SegMask = %x\n",
        lht.m_lkts, lht.m_dwSegBits, lht.m_dwSegSize, lht.m_dwSegMask);
    dprintf(
        "    MaxLoad = %3.1f, paDirSegs = %p, cDirSegs = %d\n",
        lht.m_MaxLoad, lht.m_paDirSegs, lht.m_cDirSegs);
    dprintf(
        "    cRecords = %d, cActiveBuckets = %d, BucketSpins = %hd\n",
        lht.m_cRecords, lht.m_cActiveBuckets, lht.m_wBucketLockSpins);
    dprintf(
        "    nLevel = %d, dwBktAddrMask = %x, iExpansionIdx = %d\n",
        lht.m_nLevel, lht.m_dwBktAddrMask, lht.m_iExpansionIdx);

    PrintLock(ltTableLockType, &plht->m_Lock, nVerbose);

    if (nVerbose == 1)
        goto done;
    
    paDirSegs = (CDirEntry*) calloc(lht.m_cDirSegs, sizeof(CDirEntry));

    if (paDirSegs == NULL) {
        dprintf("Out of memory\n");
        goto cleanup;
    }

    ReadMemory(lht.m_paDirSegs, paDirSegs,
               sizeof(CDirEntry) * lht.m_cDirSegs, NULL);

    for (i = 0;  i < (INT) (lht.m_cDirSegs * lht.m_dwSegSize);  i++)
    {
        const DWORD iSeg = i >> lht.m_dwSegBits;
        CLargeSegment* pseg =
            static_cast<CLargeSegment*>(paDirSegs[iSeg].m_pseg);

        if ((i & lht.m_dwSegMask) == 0)
            dprintf("Segment %d: %p\n", iSeg, pseg);

        if (pseg == NULL)
            continue;

        if (nVerbose >= 2)
        {
            CBucket* const pbkt = pseg->m_bktSlots + (i & lht.m_dwSegMask);
            
            dprintf("Bucket %4d: ", i);
            if (!EnumerateBucketChain(pfnEnum, ltBucketLockType,
                                      pbkt, nVerbose))
                goto cleanup;
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;

  cleanup:
    if (paDirSegs)
        free(paDirSegs);
    return fRet;
}


BOOL
EnumerateLKRhashTable(
    IN PFN_ENUM_LKRHASH  pfnEnum,
    IN CLKRHashTable*    pht,
    IN INT               nVerbose)
{
    CLKRHashTable ht(NULL, NULL, NULL, NULL, NULL);
    PSTR cmdName = "lkrhash";
    CLKRLinearHashTable** palhtDir = NULL;
    UINT i;
    BOOL fRet = FALSE;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(pht, &ht, sizeof(ht), NULL) )
    {
        dprintf("inetdbg.%s: cannot read memory @ %p\n",
                cmdName, (PVOID)pht);

        goto cleanup;
    }

    dprintf(
        "inetdbg.%s: @ %p:\n"
        "    CLKRHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    %d subtables, State = %d (%s)\n",
        cmdName,
        pht,
        ht.m_dwSignature,
        DECODE_SIGNATURE(ht.m_dwSignature),
        ht.m_dwSignature == CLKRHashTable::SIGNATURE
            ? "OK"
            : ht.m_dwSignature == CLKRHashTable::SIGNATURE_FREE
              ? "FREED"
              : "INVALID",
        ht.m_szName,
        ht.m_cSubTables,
        ht.m_lkrcState, LKRC2String(ht.m_lkrcState)
        );

    if (nVerbose == 0)
        goto done;

    palhtDir = (CLKRLinearHashTable**) calloc(ht.m_cSubTables,
                                              sizeof(CLKRLinearHashTable*));
    if (!palhtDir)
        goto cleanup;
    
    if (!ReadMemory(ht.m_palhtDir, palhtDir,
                    ht.m_cSubTables * sizeof(CLKRLinearHashTable*), NULL))
        goto cleanup;

    for (i = 0;  i < ht.m_cSubTables;  ++i)
    {
        dprintf("%d : ", i);
        if (!EnumerateLKRLinearHashTable(pfnEnum, palhtDir[i], nVerbose))
            break;

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;
    
  cleanup:
    free(palhtDir);

    return fRet;
}

VOID
PrintLKRLinearHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLKRLinearHashTable*) psdDebugger)->m_dwSignature;

    if (dwSig != CLKRLinearHashTable::SIGNATURE)
    {
        dprintf( "CLKRLinearHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx\n",
                 psdDebuggee, dwSig, DECODE_SIGNATURE(dwSig),
                 CLKRLinearHashTable::SIGNATURE
                 );
        return;
    }

    EnumerateLKRLinearHashTable(DefaultLKRhashEnum,
                                (CLKRLinearHashTable*) psdDebuggee,
                                chVerbosity);
}

VOID
PrintLKRHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLKRHashTable*) psdDebugger)->m_dwSignature;
    if (dwSig != CLKRHashTable::SIGNATURE)
    {
        dprintf( "CLKRHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx\n",
                 psdDebuggee,
                 dwSig, DECODE_SIGNATURE(dwSig),
                 CLKRHashTable::SIGNATURE
                 );
        return;
    }

    EnumerateLKRhashTable(DefaultLKRhashEnum, (CLKRHashTable*) psdDebuggee,
                          chVerbosity);
}

VOID
DumpLKRsList(
    IN INT nVerbose)
{
    CLockedDoubleList* plstHashTables = (CLockedDoubleList*) GetExpression(
                        IisRtlVar("&%s!CLKRHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                IisRtlVar("%s!CLKRHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLKRHashTable),
                    FIELD_OFFSET( CLKRHashTable, m_leGlobalList)
                    );


    plstHashTables = (CLockedDoubleList*) GetExpression(
                      IisRtlVar( "&%s!CLKRLinearHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                IisRtlVar("!CLKRLinearHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRLinearHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRLinearHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLKRLinearHashTable),
                    FIELD_OFFSET( CLKRLinearHashTable, m_leGlobalList)
                    );
    return;
} // DumpLKRsList()





DECLARE_API( lkrhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKRhash table.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = "lkrhash";

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

        if ( *lpArgumentString == 'v' )
        {
            lpArgumentString++;
            nVerbose = 99;
        }

        if ( *lpArgumentString == 'g' )
        {
            lpArgumentString++;
            DumpLKRsList(nVerbose);
            return;
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    lkrAddress = (ULONG_PTR) GetExpression( lpArgumentString );

    if (lkrAddress == 0) {

        dprintf(
            "inetdbg.%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    DWORD dwSig;

    if (!ReadMemory(lkrAddress, &dwSig, sizeof(dwSig), NULL) )
    {
        dprintf("inetdbg.%s: cannot read memory @ %p\n",
                cmdName, (PVOID)lkrAddress);

        goto cleanup;
    }

    if (dwSig == CLKRHashTable::SIGNATURE ||
        dwSig == CLKRHashTable::SIGNATURE_FREE)
    { 
        EnumerateLKRhashTable(DefaultLKRhashEnum,
                              (CLKRHashTable*) lkrAddress,
                              nVerbose);
    }
    else if (dwSig == CLKRLinearHashTable::SIGNATURE ||
             dwSig == CLKRLinearHashTable::SIGNATURE_FREE)
    { 
        EnumerateLKRLinearHashTable(DefaultLKRhashEnum,
                                    (CLKRLinearHashTable*) lkrAddress,
                                    nVerbose);
    }
    else
    {
        dprintf("inetdbg.%s: %p does not contain a valid LKRhash table\n",
                cmdName, (PVOID)lkrAddress);
    }
    
cleanup:
    return;
} // DECLARE_API( lkrhash )


DECLARE_API( testhash )
{
    INIT_API();

    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = "testhash";

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    lkrAddress = (ULONG_PTR)GetExpression( lpArgumentString );

    if( lkrAddress == 0 ) {

        dprintf(
            "inetdbg.%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    EnumerateLKRhashTable(TestEnum,
                          (CLKRHashTable*) lkrAddress,
                          nVerbose);
    
} // DECLARE_API( testhash )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgasp.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgasp.cxx

Abstract:

Author:

    David Gottner (dgottner) 3-Aug-1998

Revision History:

--*/

#include "inetdbgp.h"

// Need to Undef malloc() & free() because ASP includes malloc.h, which will result
// in syntax error if these are defined.
//
#undef malloc
#undef calloc
#undef realloc
#undef free

#include "denali.h"
#include "hitobj.h"
#include "scrptmgr.h"
#include "cachemgr.h"
#include "wamxinfo.hxx"

// re-instate malloc & free macros.  -- NOTE: inetdbgp.h needs to be included before 
// asp includes, so this funky design is necessary.
//
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#define calloc( n, s ) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (n)*(s) )
#define realloc( p, n ) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (p), (n) )
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )


#define Bool2Str(f)  ((f)? "true" : "false")


static void CreateStringFromVariant(char *, const VARIANT *, void *);
static void *GetObjectList(CComponentCollection *pDebuggeeCompColl);
static void DumpAspGlobals();
static void ListTemplateCache();
static void DumpAspHitobj(void *pvArg, int nVerbosity);
static void DumpAspAppln(void *pvArg, int nVerbosity);
static void DumpAspSession(void *pvArg, int nVerbosity);
static void DumpAspObject(void *pvArg, int nVerbosity);
static void DumpAspTemplate(void *pvArg, int nVerbosity);
static void DumpAspFilemap(void *pvArg, int nVerbosity);
static void DumpAspEngine(void *pvArg, int nVerbosity);
static void ListAspObjects(void *pvArg, int /* unused */);



DECLARE_API( asp )
/*++

Routine Description:

    This function is called as an NTSD extension to Diagnose ASP bugs

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.
--*/
	{
    INIT_API();
    int nVerbosity = 0;
	void (*pfnDebugPrint)(void *pvArg, int nVerbosity) = NULL;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' || *lpArgumentString == '\t' )
        ++lpArgumentString;

    if( *lpArgumentString == '\0' )
		{
        PrintUsage( "asp" );
        return;
		}

    if ( *lpArgumentString == '-' )
		{
        switch ( *++lpArgumentString )
			{
        case 'v':
        	switch ( *++lpArgumentString )
        		{
        	case '0':
        	case '1':
        	case '2':
        		nVerbosity = *lpArgumentString++ - '0';
        		break;

        	case ' ':
        	case '\t':
        		nVerbosity = 1;
        		break;

        	default:
        		// allow option combining; e.g.  "!inetdbg.asp -vh <addr>" to dump verbose hitobj.
        		// to do this, insert hyphen at current location and run through the switch again.
        		//
        		nVerbosity = 1;
        		*--lpArgumentString = '-';
        		}

			// Now, we are pointing just after "-v" arg.  Skip blanks to move to next argument
			while( *lpArgumentString == ' ' || *lpArgumentString == '\t' )
				++lpArgumentString;

			// enter new select/case statement, this one not accepting "-v" option.
			if ( *lpArgumentString == '-' )
				{
				switch ( *++lpArgumentString )
					{
				case 'h': case 'H': pfnDebugPrint = DumpAspHitobj;      break;
				case 'a': case 'A': pfnDebugPrint = DumpAspAppln;       break;
				case 'e': case 'E': pfnDebugPrint = DumpAspEngine;      break;
				case 's': case 'S': pfnDebugPrint = DumpAspSession;     break;
				case 'o': case 'O': pfnDebugPrint = DumpAspObject;      break;
				case 't': case 'T':
					switch (*(lpArgumentString + 1))
						{
					case 'f': case 'F': pfnDebugPrint = DumpAspFilemap; ++lpArgumentString; break;
					default:
						pfnDebugPrint = DumpAspTemplate;
						break;
						}
					break;

				default:
					PrintUsage( "asp" );
					return;
					}
				}
			else
				{
				PrintUsage( "asp" );
				return;
				}
			break;

        case 'g': case 'G': DumpAspGlobals(); break;
		case 'h': case 'H': pfnDebugPrint = DumpAspHitobj;      break;
		case 'a': case 'A': pfnDebugPrint = DumpAspAppln;       break;
		case 'e': case 'E': pfnDebugPrint = DumpAspEngine;      break;
		case 's': case 'S': pfnDebugPrint = DumpAspSession;     break;
		case 'o': case 'O': pfnDebugPrint = DumpAspObject;      break;
		case 'l': case 'L': pfnDebugPrint = ListAspObjects;     break;
		case 't': case 'T':
			switch (*(lpArgumentString + 1))
				{
			case 'f': case 'F': pfnDebugPrint = DumpAspFilemap; ++lpArgumentString; break;
			case 'l': case 'L': ListTemplateCache(); ++lpArgumentString; break;
			default:
				pfnDebugPrint = DumpAspTemplate;
				break;
				}
			break;

		default:
			PrintUsage( "asp" );
			return;
			}
		}
    else
		{
        PrintUsage( "asp" );
        return;
		}

	if (pfnDebugPrint)   // set to NULL if output func already called  ('-g' etc.)
		{
		void *pvArg = reinterpret_cast<void *>(GetExpression(lpArgumentString + 1));
		if (!pvArg)
			{
			dprintf("inetdbg: Unable to evaluate \"%s\"\n", lpArgumentString + 1);
			return;
			}
		(*pfnDebugPrint)(pvArg, nVerbosity);
		}
	}



/*++
 * DumpAspGlobals
 --*/
void DumpAspGlobals()
	{
    dprintf("Asp Globals:\n");

    DumpDword( "asp!g_nSessions              " );
    DumpDword( "asp!g_nApplications          " );
    DumpDword( "asp!g_nApplicationsRestarting" );
    DumpDword( "asp!g_nBrowserRequests       " );
    DumpDword( "asp!g_nSessionCleanupRequests" );
    DumpDword( "asp!g_nApplnCleanupRequests  " );
    DumpDword( "asp!g_fShutDownInProgress    " );
	DumpDword( "asp!g_dwDebugThreadId        " );
	DumpDword( "asp!g_pPDM                   " );
	DumpDword( "asp!g_pDebugApp              " );
	DumpDword( "asp!g_pDebugAppRoot          " );
	DumpDword( "asp!CTemplate__gm_pTraceLog  " );
	DumpDword( "asp!CSession__gm_pTraceLog   " );

	void *pvApplnMgr = reinterpret_cast<void *>(GetExpression("asp!g_ApplnMgr"));
	if (pvApplnMgr)
		{
		// Copy Appln Manager Stuff

		DEFINE_CPP_VAR(CApplnMgr, TheObject);
		move(TheObject, pvApplnMgr);
		CApplnMgr *pApplnMgr = GET_CPP_VAR_PTR(CApplnMgr, TheObject);

		// print Queues

		dprintf("\n"
				"\t\t--- Application Manager\n"
				"\n"
				"\tApplication Lock       = %p\n"
				"\tDelete Appln Event     = 0x%X\n"
				"\tEngine Cleanup List    = %p (Contents: <%p, %p>)\n"
				"\tFirst Application      = %p\n",
					&static_cast<CApplnMgr *>(pvApplnMgr)->m_csLock,
					pApplnMgr->m_hDeleteApplnEvent,
					&static_cast<CApplnMgr *>(pvApplnMgr)->m_listEngineCleanup,
					pApplnMgr->m_listEngineCleanup.m_pLinkNext,
					pApplnMgr->m_listEngineCleanup.m_pLinkPrev,
					static_cast<CAppln *>(pApplnMgr->m_pHead));   // cast required due to multiple vtables
		}

	void *pvScriptMgr = reinterpret_cast<void *>(GetExpression("asp!g_ScriptManager"));
	if (pvScriptMgr)
		{
		// Copy Script Manager Stuff

		DEFINE_CPP_VAR(CScriptManager, TheObject);
		move(TheObject, pvScriptMgr);
		CScriptManager *pScriptMgr = GET_CPP_VAR_PTR(CScriptManager, TheObject);

		// print Queues

		dprintf("\n"
				"\t\t--- Script Manager\n"
				"\n"
				"\tRunning Script List    = %p (Contents: <%p, %p>)\n"
		        "\tFree Script Queue      = %p (Contents: <%p, %p>)\n"
				"\tRunning Script CritSec = %p\n"
				"\tFree Script CritSec    = %p\n",
					&static_cast<CScriptManager *>(pvScriptMgr)->m_htRSL.m_lruHead,
					pScriptMgr->m_htRSL.m_lruHead.m_pLinkNext,
					pScriptMgr->m_htRSL.m_lruHead.m_pLinkPrev,
					&static_cast<CScriptManager *>(pvScriptMgr)->m_htFSQ.m_lruHead,
					pScriptMgr->m_htFSQ.m_lruHead.m_pLinkNext,
					pScriptMgr->m_htFSQ.m_lruHead.m_pLinkPrev,
					&static_cast<CScriptManager *>(pvScriptMgr)->m_csRSL,
					&static_cast<CScriptManager *>(pvScriptMgr)->m_csFSQ);
		}

	void *pvTemplateCache = reinterpret_cast<void *>(GetExpression("asp!g_TemplateCache"));
	if (pvTemplateCache)
		{
		// Copy Template Cache Stuff

		DEFINE_CPP_VAR(CTemplateCacheManager, TheObject);
		move(TheObject, pvTemplateCache);
		CTemplateCacheManager *pTemplateCache = GET_CPP_VAR_PTR(CTemplateCacheManager, TheObject);

		// print Stuff

		dprintf("\n"
				"\t\t--- Template Cache\n"
				"\n"
				"\tTemplate LKRhash Table  = %p\n"
				"\tTemplate Mem LRU Order Q= %p (Contents: <%p, %p>)\n"
				"\tTemplate Per LRU Order Q= %p (Contents: <%p, %p>)\n"
				"\tTemplate Update CritSec = %p\n",
					static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_pHashTemplates,
					&static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_pHashTemplates->m_listMemoryTemplates,
					pTemplateCache->m_pHashTemplates->m_listMemoryTemplates.m_pLinkNext,
					pTemplateCache->m_pHashTemplates->m_listMemoryTemplates.m_pLinkPrev,
					&static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_pHashTemplates->m_listPersistTemplates,
					pTemplateCache->m_pHashTemplates->m_listPersistTemplates.m_pLinkNext,
					pTemplateCache->m_pHashTemplates->m_listPersistTemplates.m_pLinkPrev,
					&static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_csUpdate);
		}
	}


/*++
 * DumpAspHitobj
 --*/
void DumpAspHitobj(void *pvObj, int nVerbosity)
	{
	// used to create english readable strings
	//    The hitobj fields are 4 bits, so each possible value is enumerated.

	static
	char *szNone = "<bad value>";

	static
	char *rgszRequestTypes[16] = { "Uninitialized", "Browser Request", "Session Cleanup", szNone, "Application Cleanup",
								   szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	static
	char *rgszEventStates[16] = { "None", "Application_OnStart", "Session_OnStart", szNone, "Application_OnEnd",
								  szNone, szNone, szNone, "Session_OnEnd",
								  szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	static
	char *rgszActivityScope[16] = { "Unknown", "Application", "Session", szNone, "Page",
								    szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone };


	// copy Hitobj from debuggee to debugger

	DEFINE_CPP_VAR(CHitObj, TheObject);
	move(TheObject, pvObj);
	CHitObj *pHitObj = GET_CPP_VAR_PTR(CHitObj, TheObject);

	// get name of file & ecb.

	DEFINE_CPP_VAR(WAM_EXEC_INFO, WamXInfo);
	move(WamXInfo, pHitObj->m_pWXI);
	WAM_EXEC_INFO *pWXI = GET_CPP_VAR_PTR(WAM_EXEC_INFO, WamXInfo);

	char szPathInfo[256];
	move(szPathInfo, pWXI->ecb.lpszPathInfo);

	char szPathTranslated[256];
	move(szPathTranslated, pWXI->ecb.lpszPathTranslated);

	char szMethod[256];
	move(szMethod, pWXI->ecb.lpszMethod);

	// terminate strings

	szPathInfo[255] = 0;
	szPathTranslated[255] = 0;
	szMethod[255] = 0;

	// yeehaw! dumpit.

	dprintf("METHOD          = %s\n"
	        "PATH_INFO       = %s\n"
	        "PATH_TRANSLATED = %s\n"
	        "WAM_EXEC_INFO   = %p\n"
	        "ECB             = %p\n"
	        "Request Type    = %s\n"
	        "Event State     = %s\n"
	        "Activity Scope  = %s\n"
			"\n"
	        "\t-- object pointers --\n"
	        "\n"
	        "Session Object     = %p\n"
	        "Application Object = %p\n"
	        "Response Object    = %p\n"
	        "Request Object     = %p\n"
	        "Server Object      = %p\n"
			"Page Object List   = %p\n"
			"Page Component Mgr = %p\n",
				szMethod,
				szPathInfo,
				szPathTranslated,
				pHitObj->m_pWXI,
				&pWXI->ecb,
				rgszRequestTypes[pHitObj->m_ehtType],
				rgszEventStates[pHitObj->m_eEventState],
				rgszActivityScope[pHitObj->m_ecsActivityScope],
				pHitObj->m_pSession,
				pHitObj->m_pAppln,
				pHitObj->m_pResponse,
				pHitObj->m_pRequest,
				pHitObj->m_pServer,
				GetObjectList(pHitObj->m_pPageCompCol),
				pHitObj->m_pPageObjMgr);

	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"Inited                           = %s\n"
				"RunGlobalAsa                     = %s\n"
				"StartSession                     = %s\n"
				"NewCookie                        = %s\n"
				"StartApplication                 = %s\n"
				"ClientCodeDebug                  = %s\n"
				"ApplnOnStartFailed               = %s\n"
				"CompilationFailed                = %s\n"
				"Executing                        = %s\n"
				"HideRequestAndResponseIntrinsics = %s\n"
				"HideSessionIntrinsic             = %s\n"
				"DoneWithSession                  = %s\n"
				"Rejected                         = %s\n"
				"449Done                          = %s\n"
				"InTransferOnError                = %s\n",
					Bool2Str(pHitObj->m_fInited),
					Bool2Str(pHitObj->m_fRunGlobalAsa),
					Bool2Str(pHitObj->m_fStartSession),
					Bool2Str(pHitObj->m_fNewCookie),
					Bool2Str(pHitObj->m_fStartApplication),
					Bool2Str(pHitObj->m_fClientCodeDebug),
					Bool2Str(pHitObj->m_fApplnOnStartFailed),
					Bool2Str(pHitObj->m_fCompilationFailed),
					Bool2Str(pHitObj->m_fExecuting),
					Bool2Str(pHitObj->m_fHideRequestAndResponseIntrinsics),
					Bool2Str(pHitObj->m_fHideSessionIntrinsic),
					Bool2Str(pHitObj->m_fDoneWithSession),
					Bool2Str(pHitObj->m_fRejected),
					Bool2Str(pHitObj->m_f449Done),
					Bool2Str(pHitObj->m_fInTransferOnError));

	if (nVerbosity >= 2)
		dprintf("\n"
		        "\t--- kitchen sink---\n"
		        "\n"
		        "pUnkScriptingNamespace   = %p\n"
		        "dwObjectContextCookie    = 0x%X\n"
		        "Impersonation Handle     = 0x%p\n"
		        "Viper Activity           = %p\n"
		        "Session Cookie           = %s\n"
		        "Session ID tuple         = (0x%X, 0x%X, 0x%X)\n"
		        "Scripting Context Object = %p\n"
		        "Scripting Timeout        = %d\n"
		        "Code Page                = %u\n"
		        "LCID                     = %u\n"
		        "pEngineInfo              = %p\n"
		        "pDispTypeLibWrapper      = %p\n"
		        "Timestamp                = %u\n",
					pHitObj->m_punkScriptingNamespace,
					pHitObj->m_dwObjectContextCookie,
					pHitObj->m_hImpersonate,
					pHitObj->m_pActivity,
					pHitObj->m_szSessionCookie,
					pHitObj->m_SessionId.m_dwId, pHitObj->m_SessionId.m_dwR1, pHitObj->m_SessionId.m_dwR2,
					pHitObj->m_pScriptingContext,
					pHitObj->m_nScriptTimeout,
					pHitObj->m_uCodePage,
					pHitObj->m_lcid,
					pHitObj->m_pEngineInfo,
					pHitObj->m_pdispTypeLibWrapper,
					pHitObj->m_dwtTimestamp);
	}

/*++
 * DumpAspAppln
 --*/
void DumpAspAppln(void *pvObj, int nVerbosity)
	{
	// copy Appln from debuggee to debugger

	DEFINE_CPP_VAR(CAppln, TheObject);
	move(TheObject, pvObj);
	CAppln *pAppln = GET_CPP_VAR_PTR(CAppln, TheObject);

	char szMBaseKey[256];
	move(szMBaseKey, pAppln->m_pszMetabaseKey);

	char szApplnPathTranslated[256];
	move(szApplnPathTranslated, pAppln->m_pszApplnPath);

	char szApplnPath[256];
	move(szApplnPath, pAppln->m_pszApplnVRoot);

	char szGlobalAsa[256];
	move(szGlobalAsa, pAppln->m_pszGlobalAsa);

	// terminate strings

	szMBaseKey[255] = 0;
	szApplnPathTranslated[255] = 0;
	szApplnPath[255] = 0;
	szGlobalAsa[255] = 0;

	// yeehaw! dumpit.

	dprintf("Reference Count      = %d\n"
	        "# of Requests        = %d\n"
	        "# of Sessions        = %d\n"
	        "Metabase Key         = %s\n"
	        "Application Root     = %s\n"
	        "Physical Root Path   = %s\n"
			"global.asa Path      = %s\n"
			"global.asa Template  = %p\n"
			"Next Application     = %p\n"
			"Previous Application = %p\n"
			"\n"
	        "\t-- object pointers --\n"
	        "\n"
			"Application Object List  = %p\n"
			"Property Collection      = %p\n"
			"TaggedObjects Collection = %p\n"
			"pSessionMgr              = %p\n",
				pAppln->m_cRefs,
				pAppln->m_cRequests,
				pAppln->m_cSessions,
				szMBaseKey,
				szApplnPath,
				szApplnPathTranslated,
				szGlobalAsa,
				pAppln->m_pGlobalTemplate,
				pAppln->m_pNext,
				pAppln->m_pPrev,
				GetObjectList(pAppln->m_pApplCompCol),
				pAppln->m_pProperties,
				pAppln->m_pTaggedObjects,
				pAppln->m_pSessionMgr);

	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"Inited                 = %s\n"
				"FirstRequestRan        = %s\n"
				"GlobalChanged          = %s\n"
				"DeleteInProgress       = %s\n"
				"Tombstone              = %s\n"
				"DebuggingEnabled       = %s\n"
				"NotificationAdded      = %s\n"
				"UseImpersonationHandle = %s\n",
					Bool2Str(pAppln->m_fInited),
					Bool2Str(pAppln->m_fFirstRequestRan),
					Bool2Str(pAppln->m_fGlobalChanged),
					Bool2Str(pAppln->m_fDeleteInProgress),
					Bool2Str(pAppln->m_fTombstone),
					Bool2Str(pAppln->m_fDebuggable),
					Bool2Str(pAppln->m_fNotificationAdded),
					Bool2Str(pAppln->m_fUseImpersonationHandle));

	if (nVerbosity >= 2)
		dprintf("\n"
		        "\t--- kitchen sink---\n"
		        "\n"
		        "Viper Activity            = %p\n"
				"Application Config        = %p\n"
		        "Internal Lock (CS)        = %p\n"
		        "Application Lock (CS)     = %p\n"
		        "Locking thread ID         = 0x%X\n"
		        "Lock Ref Count            = %u\n"
		        "User Impersonation Handle = 0x%p\n"
		        "pDispTypeLibWrapper       = %p\n"
		        "IDebugApplicationNode     = %p\n",
					pAppln->m_pActivity,
					pAppln->m_pAppConfig,
					&pAppln->m_csInternalLock,
					&pAppln->m_csApplnLock,
					pAppln->m_dwLockThreadID,
					pAppln->m_cLockRefCount,
					pAppln->m_hUserImpersonation,
					pAppln->m_pdispGlobTypeLibWrapper,
					pAppln->m_pAppRoot);
	}

/*++
 * DumpAspSession
 --*/
void DumpAspSession(void *pvObj, int nVerbosity)
	{
	// copy Session from debuggee to debugger

	DEFINE_CPP_VAR(CSession, TheObject);
	move(TheObject, pvObj);
	CSession *pSession = GET_CPP_VAR_PTR(CSession, TheObject);

	dprintf("Reference Count  = %d\n"
			"# of Requests    = %d\n"
			"Application      = %p\n"
			"Current HitObj   = %p\n"
			"Session ID tuple = (0x%X, 0x%X, 0x%X)\n"
			"External ID      = %d\n"
			"\n"
	        "\t-- object pointers --\n"
	        "\n"
			"Session Object List      = %p\n"
			"Property Collection      = %p\n"
			"TaggedObjects Collection = %p\n"
			"Request Object           = %p\n"
			"Response Object          = %p\n"
			"Server Object            = %p\n",
				pSession->m_cRefs,
				pSession->m_cRequests,
				pSession->m_pAppln,
				pSession->m_pHitObj,
				pSession->m_Id.m_dwId, pSession->m_Id.m_dwR1, pSession->m_Id.m_dwR2,
				pSession->m_dwExternId,
				GetObjectList(&static_cast<CSession *>(pvObj)->m_SessCompCol),
				pSession->m_pProperties,
				pSession->m_pTaggedObjects,
				&static_cast<CSession *>(pvObj)->m_Request,		// OK since we don't dereference ptrs
				&static_cast<CSession *>(pvObj)->m_Response,
				&static_cast<CSession *>(pvObj)->m_Server);
			  
	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"Inited         = %s\n"
				"LightWeight    = %s\n"
				"OnStartFailed  = %s\n"
				"OnStartInvoked = %s\n"
				"OnEndPresent   = %s\n"
				"TimedOut       = %s\n"
				"StateAcquired  = %s\n"
				"CustomTimeout  = %s\n"
				"Abandoned      = %s\n"
				"Tombstone      = %s\n"
				"InTOBucket     = %s\n"
				"SessCompCol    = %s\n",
					Bool2Str(pSession->m_fInited),
					Bool2Str(pSession->m_fLightWeight),
					Bool2Str(pSession->m_fOnStartFailed),
					Bool2Str(pSession->m_fOnStartInvoked),
					Bool2Str(pSession->m_fOnEndPresent),
					Bool2Str(pSession->m_fTimedOut),
					Bool2Str(pSession->m_fStateAcquired),
					Bool2Str(pSession->m_fCustomTimeout),
					Bool2Str(pSession->m_fAbandoned),
					Bool2Str(pSession->m_fTombstone),
					Bool2Str(pSession->m_fInTOBucket),
					Bool2Str(pSession->m_fSessCompCol));

	if (nVerbosity >= 2)
		dprintf("\n"
		        "\t--- kitchen sink---\n"
		        "\n"
		        "Viper Activity = %p\n"
				"Timeout Time   = %d\n"
				"Current Time   = %d\n"
				"Code Page      = %d\n"
				"LCID           = %d\n",
					&pSession->m_Activity,
					pSession->m_dwmTimeoutTime,
					pSession->m_nTimeout,
					pSession->m_lCodePage,
					pSession->m_lcid);
	}

/*++
 * DumpAspTemplate
 --*/
void DumpAspTemplate(void *pvObj, int nVerbosity)
	{
	static
	char *szNone = "<bad value>";

	static
	char *rgszTransType[16] = { "Undefined", "NotSupported", "Supported", szNone, "Required",
								szNone, szNone, szNone, "RequiresNew", szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	// copy Template from debuggee to debugger

	DEFINE_CPP_VAR(CTemplate, TheObject);
	move(TheObject, pvObj);
	CTemplate *pTemplate = GET_CPP_VAR_PTR(CTemplate, TheObject);

	// get strings

	char szPathTranslated[256];
	move(szPathTranslated, pTemplate->m_LKHashKey.szPathTranslated);

	char szApplnURL[256];
	move(szApplnURL, pTemplate->m_szApplnURL);

	// terminate strings

	szPathTranslated[255] = 0;
	szApplnURL[255] = 0;

	// yeehaw! dumpit.

	dprintf("Template File Name   = %s\n"
			"Server Instance ID   = %d\n"
			"Application URL      = %s\n"
			"Reference Count      = %d\n"
			"# of Filemaps        = %d\n"
			"Filemap Ptr Array    = %p\n"
			"# of Script Engines  = %d\n"
			"Debug Script Engines = %p\n"
			"Compiled Template    = %p\n"
			"Template Size        = %d\n"
			"Transacted           = %s\n"
			"Next Template        = %p\n"
			"Previous Template    = %p\n",
				szPathTranslated,
				pTemplate->m_LKHashKey.dwInstanceID,
				szApplnURL,
				pTemplate->m_cRefs,
				pTemplate->m_cFilemaps,
				pTemplate->m_rgpFilemaps,
				pTemplate->m_cScriptEngines,
				pTemplate->m_rgpDebugScripts,
				pTemplate->m_pbStart,
				pTemplate->m_cbTemplate,
				rgszTransType[pTemplate->m_ttTransacted & 0x0F],
				pTemplate->m_pLinkNext,
				pTemplate->m_pLinkPrev);

	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"DebuggerDetachCSInited = %s\n"
				"GlobalAsa   = %s\n"
				"IsValid     = %s\n"
				"DontCache   = %s\n"
				"ReadyForUse = %s\n"
				"DontAttach  = %s\n"
				"Session     = %s\n"
				"Scriptless  = %s\n"
				"Debuggable  = %s\n"
				"Zombie      = %s\n"
				"CodePageSet = %s\n"
				"LCIDSet     = %s\n",
					Bool2Str(pTemplate->m_fDebuggerDetachCSInited),
					Bool2Str(pTemplate->m_fGlobalAsa),
					Bool2Str(pTemplate->m_fIsValid),
					Bool2Str(pTemplate->m_fDontCache),
					Bool2Str(pTemplate->m_fReadyForUse),
					Bool2Str(pTemplate->m_fDontAttach),
					Bool2Str(pTemplate->m_fSession),
					Bool2Str(pTemplate->m_fScriptless),
					Bool2Str(pTemplate->m_fDebuggable),
					Bool2Str(pTemplate->m_fZombie),
					Bool2Str(pTemplate->m_fCodePageSet),
					Bool2Str(pTemplate->m_fLCIDSet));

	if (nVerbosity >= 2)
		dprintf("\n"
		        "\t--- kitchen sink---\n"
		        "\n"
		        "hEventReadyForUse   = 0x%p\n"
				"Connection Pt Obj   = %p\n"
				"csDebuggerDetach    = %p\n"
				"List of Doc Nodes   = %p (Contents: <%p, %p>)\n"
				"pbErrorLocation     = %p\n"
				"szLastErrorInfo[0]  = %s\n"
				"szLastErrorInfo[1]  = %s\n"
				"szLastErrorInfo[2]  = %s\n"
				"szLastErrorInfo[3]  = %s\n"
				"szLastErrorInfo[4]  = %s\n"
				"szLastErrorInfo[5]  = %s\n"
				"dwLastErrorMask     = 0x%X\n"
				"hrOnNoCache         = 0x%08X\n"
				"Code Page           = %d\n"
				"LCID                = %d\n"
				"pdispTypeLibWrapper = %p\n",
					pTemplate->m_hEventReadyForUse,
					&static_cast<CTemplate *>(pvObj)->m_CPTextEvents,		// OK since we don't dereference ptrs
					&static_cast<CTemplate *>(pvObj)->m_csDebuggerDetach,
					&static_cast<CTemplate *>(pvObj)->m_listDocNodes,
					pTemplate->m_listDocNodes.m_pLinkNext,
					pTemplate->m_listDocNodes.m_pLinkPrev,
					pTemplate->m_pbErrorLocation,
					pTemplate->m_pszLastErrorInfo[0],
					pTemplate->m_pszLastErrorInfo[1],
					pTemplate->m_pszLastErrorInfo[2],
					pTemplate->m_pszLastErrorInfo[3],
					pTemplate->m_pszLastErrorInfo[4],
					pTemplate->m_pszLastErrorInfo[5],
					pTemplate->m_dwLastErrorMask,
					pTemplate->m_hrOnNoCache,
					pTemplate->m_wCodePage,
					pTemplate->m_lLCID,
					pTemplate->m_pdispTypeLibWrapper);
	}

/*++
 * DumpAspFilemap
 --*/
void DumpAspFilemap(void *pvObj, int nVerbosity)
	{
	// copy Filemap from debuggee to debugger

	DEFINE_CPP_VAR(CTemplate::CFileMap, TheObject);
	move(TheObject, pvObj);
	CTemplate::CFileMap *pFileMap = GET_CPP_VAR_PTR(CTemplate::CFileMap, TheObject);

	// get strings

	char szPathInfo[256];
	move(szPathInfo, pFileMap->m_szPathInfo);

	char szPathTranslated[256];
	move(szPathTranslated, pFileMap->m_szPathTranslated);

	// terminate strings

	szPathTranslated[255] = 0;
	szPathInfo[255] = 0;

	// yeehaw! dumpit.

	dprintf("PathInfo        = %s\n"
			"PathTranslated  = %s\n"
			"Child Filemap   = %p\n"
			"%s Filemap = %p\n"
			"File Handle     = 0x%p\n"
			"Map Handle      = 0x%p\n"
			"File Text       = %p\n"
			"Include File    = %p\n"
			"File Size       = %d\n",
				szPathInfo,
				szPathTranslated,
				pFileMap->m_pfilemapChild,
				pFileMap->m_fHasSibling? "Sibling" : "Parent ", pFileMap->m_pfilemapParent,
				pFileMap->m_hFile,
				pFileMap->m_hMap,
				pFileMap->m_pbStartOfFile,
				pFileMap->m_pIncFile,
				pFileMap->m_cChars);

	if (nVerbosity >= 1)
		dprintf("\n"
				"\t--- kitchen sink ---\n"
				"\n"
				"Security Descriptor Size = %d\n"
				"Security Descriptor      = %p\n"
				"Last Write Time          = 0x%08X%08X\n"
				"DirMon entry             = %p\n",
					pFileMap->m_dwSecDescSize,
					pFileMap->m_pSecurityDescriptor,
					pFileMap->m_ftLastWriteTime.dwHighDateTime, pFileMap->m_ftLastWriteTime.dwLowDateTime,
					pFileMap->m_pDME);
	}

/*++
 * DumpAspEngine
 --*/
void DumpAspEngine(void *pvObj, int nVerbosity)
	{
	// copy Engine from debuggee to debugger

	DEFINE_CPP_VAR(CActiveScriptEngine, TheObject);
	move(TheObject, pvObj);
	CActiveScriptEngine *pEng = GET_CPP_VAR_PTR(CActiveScriptEngine, TheObject);

	// get strings

	char szTemplateName[256];
	move(szTemplateName, pEng->m_szTemplateName);
	szTemplateName[127] = 0;

	char szProglangId[256];
	wsprintf(szProglangId,
			 "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
			 pEng->m_proglang_id.Data1,
			 pEng->m_proglang_id.Data2,
			 pEng->m_proglang_id.Data3,
			 pEng->m_proglang_id.Data4[0],
			 pEng->m_proglang_id.Data4[1],
			 pEng->m_proglang_id.Data4[2],
			 pEng->m_proglang_id.Data4[3],
			 pEng->m_proglang_id.Data4[4],
			 pEng->m_proglang_id.Data4[5],
			 pEng->m_proglang_id.Data4[6],
			 pEng->m_proglang_id.Data4[7]);

	// terminate strings
	szTemplateName[255] = 0;

	// yeehaw! dumpit.

	dprintf("Template Name   = %s\n"
			"Instance ID     = %d\n"
			"Reference Count = %d\n"
			"Language ID     = %s\n"
			"Template        = %p\n"
			"HitObject       = %p\n",
				szTemplateName,
				pEng->m_dwInstanceID,
				pEng->m_cRef,
				szProglangId,
				pEng->m_pTemplate,
				pEng->m_pHitObj);

	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"Inited         = %s\n"
				"Zombie         = %s\n"
				"ScriptLoaded   = %s\n"
				"ObjectsLoaded  = %s\n"
				"BeingDebugged  = %s\n"
				"ScriptAborted  = %s\n"
				"ScriptTimedOut = %s\n"
				"ScriptHadError = %s\n"
				"Corrupted      = %s\n"
				"NameAllocated  = %s\n",
					Bool2Str(pEng->m_fInited),
					Bool2Str(pEng->m_fZombie),
					Bool2Str(pEng->m_fScriptLoaded),
					Bool2Str(pEng->m_fObjectsLoaded),
					Bool2Str(pEng->m_fBeingDebugged),
					Bool2Str(pEng->m_fScriptAborted),
					Bool2Str(pEng->m_fScriptTimedOut),
					Bool2Str(pEng->m_fScriptHadError),
					Bool2Str(pEng->m_fCorrupted),
					Bool2Str(pEng->m_fTemplateNameAllocated));

	if (nVerbosity >= 2)
		dprintf("\n"
				"\t--- interfaces ---\n"
				"\n"
				"IDispatch          = %p\n"
				"IActiveScript      = %p\n"
				"IActiveScriptParse = %p\n"
				"IHostInfoUpdate    = %p\n"
				"\n"
				"\t--- kitchen sink ---\n"
				"\n"
				"LCID           = %d\n"
				"Time Started   = %u\n"
				"Source Context = %d\n",
					pEng->m_pDisp,
					pEng->m_pAS,
					pEng->m_pASP,
					pEng->m_pHIUpdate,
					pEng->m_lcid,
					pEng->m_timeStarted,
					pEng->m_dwSourceContext);
	}

/*++
 * DumpAspObject
 --*/
void DumpAspObject(void *pvObj, int nVerbosity)
	{
	static
	char *szNone = "<bad value>";

	static
	char *rgszCompScope[16] = { "Unknown", "Application", "Session", szNone, "Page",
								szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	static
	char *rgszCompType[16] = { "Unknown", "Tagged", "Property", szNone, "Unnamed",
								szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	static
	char *rgszThreadModel[16] = { "Unknown", "Single", "Apartment", szNone, "Free",
								  szNone, szNone, szNone, "Both", szNone, szNone, szNone, szNone, szNone, szNone, szNone };

	// copy CompColl from debuggee to debugger

	DEFINE_CPP_VAR(CComponentObject, TheObject);
	move(TheObject, pvObj);
	CComponentObject *pObj = GET_CPP_VAR_PTR(CComponentObject, TheObject);

	// get strings

	wchar_t wszName[128];
	move(wszName, pObj->m_pKey);
	wszName[127] = 0;

	char szVariantOrGUID[256];
	if (pObj->m_fVariant)
		CreateStringFromVariant(szVariantOrGUID, &pObj->m_Variant, &static_cast<CComponentObject *>(pvObj)->m_Variant);
	else
		wsprintf(szVariantOrGUID,
				 "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
				 pObj->m_ClsId.Data1,
				 pObj->m_ClsId.Data2,
				 pObj->m_ClsId.Data3,
				 pObj->m_ClsId.Data4[0],
				 pObj->m_ClsId.Data4[1],
				 pObj->m_ClsId.Data4[2],
				 pObj->m_ClsId.Data4[3],
				 pObj->m_ClsId.Data4[4],
				 pObj->m_ClsId.Data4[5],
				 pObj->m_ClsId.Data4[6],
				 pObj->m_ClsId.Data4[7]);
				 
	// yeehaw! dumpit.

	dprintf("Name            = %S\n"
			"Scope           = %s\n"
			"Object Type     = %s\n"
			"Threading Model = %s\n"
			"\n"
			"\t--- value ---\n"
			"\n"
			"VARIANT Value = %s\n"
			"Class ID      = %s\n"
			"IDispatch *   = %p\n"
			"IUnknown *    = %p\n"
			"GIP Cookie    = 0x%X\n"
			"\n"
			"\t--- pointers ---\n"
			"\n"
			"Next Object = %p\n"
			"Prev Object = %p\n",
				wszName,
				rgszCompScope[pObj->m_csScope],
				rgszCompType[pObj->m_ctType],
				rgszThreadModel[pObj->m_cmModel],
				pObj->m_fVariant? szVariantOrGUID : "N/A",
				pObj->m_fVariant? "N/A" : szVariantOrGUID,
				pObj->m_pDisp,
				pObj->m_pUnknown,
				pObj->m_dwGIPCookie,
				pObj->m_pCompNext,
				pObj->m_pCompPrev);

	if (nVerbosity >= 1)
		dprintf("\n"
		        "\t--- flags ---\n"
		        "\n"
				"Agile               = %s\n"
				"OnPageInfoCached    = %s\n"
				"OnPageStarted       = %s\n"
				"FailedToInstantiate = %s\n"
				"InstantiatedTagged  = %s\n"
				"InPtrCache          = %s\n"
				"Variant             = %s\n"
				"NameAllocated       = %s\n",
					Bool2Str(pObj->m_fAgile),
					Bool2Str(pObj->m_fOnPageInfoCached),
					Bool2Str(pObj->m_fOnPageStarted),
					Bool2Str(pObj->m_fFailedToInstantiate),
					Bool2Str(pObj->m_fInstantiatedTagged),
					Bool2Str(pObj->m_fInPtrCache),
					Bool2Str(pObj->m_fVariant),
					Bool2Str(pObj->m_fNameAllocated));


	}

/*++
 * ListTemplateCache
 *
 * Provide condensed object list
 --*/
static
void ListTemplateCache()
	{
	void *pvTemplateCache = reinterpret_cast<void *>(GetExpression("asp!g_TemplateCache"));
	if (pvTemplateCache)
		{
		// Copy Template Cache Stuff

		DEFINE_CPP_VAR(CTemplateCacheManager, TheObject);
		move(TheObject, pvTemplateCache);
		CTemplateCacheManager *pTemplateCache = GET_CPP_VAR_PTR(CTemplateCacheManager, TheObject);

		dprintf("%-8s %-4s %s\n", "addr", "id", "file");
		dprintf("------------------------------------------------\n");

		void *pvList = &static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_pHashTemplates->m_listMemoryTemplates;
		void *pvTemplate = pTemplateCache->m_pHashTemplates->m_listMemoryTemplates.m_pLinkNext;

        for (int i=0; 
             i < 2; 
             i++,
                pvList = &static_cast<CTemplateCacheManager *>(pvTemplateCache)->m_pHashTemplates->m_listPersistTemplates,
                pvTemplate = pTemplateCache->m_pHashTemplates->m_listPersistTemplates.m_pLinkNext) {
		    while (pvTemplate != pvList)
			    {
			    DEFINE_CPP_VAR(CTemplate, TheObject);
			    move(TheObject, pvTemplate);
			    CTemplate *pTemplate = GET_CPP_VAR_PTR(CTemplate, TheObject);

			    // get name

			    char szPathTranslated[256];
			    move(szPathTranslated, pTemplate->m_LKHashKey.szPathTranslated);

			    dprintf("%p %-4d %s\n", pvTemplate, pTemplate->m_LKHashKey.dwInstanceID, szPathTranslated);
			    if (CheckControlC())
				    {
				    dprintf("\n^C\n");
				    return;
				    }

			    pvTemplate = pTemplate->m_pLinkNext;
			    }
		    }
        }
	}

/*++
 * ListAspObjects
 *
 * Provide condensed object list
 --*/
static
void ListAspObjects(void *pvObj, int /* unused */)
	{
	while (pvObj != NULL)
		{
		DEFINE_CPP_VAR(CComponentObject, TheObject);
		move(TheObject, pvObj);
		CComponentObject *pObj = GET_CPP_VAR_PTR(CComponentObject, TheObject);

		// get strings

		wchar_t wszName[20];
		move(wszName, pObj->m_pKey);
		wszName[19] = 0;

		char szVariantOrGUID[256];
		if (pObj->m_fVariant)
			CreateStringFromVariant(szVariantOrGUID, &pObj->m_Variant, &static_cast<CComponentObject *>(pvObj)->m_Variant);
		else
			wsprintf(szVariantOrGUID,
					 "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
					 pObj->m_ClsId.Data1,
					 pObj->m_ClsId.Data2,
					 pObj->m_ClsId.Data3,
					 pObj->m_ClsId.Data4[0],
					 pObj->m_ClsId.Data4[1],
					 pObj->m_ClsId.Data4[2],
					 pObj->m_ClsId.Data4[3],
					 pObj->m_ClsId.Data4[4],
					 pObj->m_ClsId.Data4[5],
					 pObj->m_ClsId.Data4[6],
					 pObj->m_ClsId.Data4[7]);
				 
		if (CheckControlC())
			{
			dprintf("\n^C\n");
			return;
			}

		dprintf("%-10p %-20S %s\n", pvObj, wszName, szVariantOrGUID);
		pvObj = pObj->m_pCompNext;
		}
	}

/*++
 * CreateStringFromVariant
 *
 * Print value of a VARIANT structure
 --*/
void CreateStringFromVariant(char *szOut, const VARIANT *pvarCopy, void *pvDebuggeeVariant)
	{
	const BSTR_BUF_SIZE = 120;
	wchar_t wszBstr[BSTR_BUF_SIZE];

	switch (V_VT(pvarCopy))
		{
	case VT_I4:       wsprintf(szOut, "(I4) %d", V_I4(pvarCopy));                       break;
	case VT_I2:       wsprintf(szOut, "(I2) %d", V_I2(pvarCopy));                       break;
	case VT_UI1:      wsprintf(szOut, "(UI1) %d", V_UI1(pvarCopy));                     break;
	case VT_R4:       wsprintf(szOut, "(R4) %g", V_R4(pvarCopy));                       break;
	case VT_R8:       wsprintf(szOut, "(R4) %g", V_R8(pvarCopy));                       break;
	case VT_BOOL:     wsprintf(szOut, "(BOOL) %s", V_BOOL(pvarCopy)? "true" : "false"); break;
	case VT_ERROR:    wsprintf(szOut, "(ERROR) %08x", V_ERROR(pvarCopy));               break;
	case VT_UNKNOWN:  wsprintf(szOut, "(UNKNOWN) %p", V_UNKNOWN(pvarCopy));             break;
	case VT_DISPATCH: wsprintf(szOut, "(DISPATCH) %p", V_UNKNOWN(pvarCopy));            break;
	case VT_BSTR:
		move(wszBstr, V_BSTR(pvarCopy));
		wszBstr[BSTR_BUF_SIZE - 1] = 0;
		wsprintf(szOut, "(BSTR) \"%S\"", wszBstr);
		break;
	default:
		wsprintf(szOut, "VarType: %#04x, Unsupported Type.  Please \"dd\" Variant at %p", V_VT(pvarCopy), pvDebuggeeVariant);
		break;
		}
	}

/*++
 * GetObjectList
 --*/
void *GetObjectList(CComponentCollection *pDebuggeeCompColl)
	{
	// copy CompColl from debuggee to debugger

	if (pDebuggeeCompColl == NULL)
		return NULL;

	void *pvObjectList;
	MoveWithRet(pvObjectList, &pDebuggeeCompColl->m_pCompFirst, NULL);
	return pvObjectList;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbginet.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    dbginet.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server

Author:

    Murali R. Krishnan (MuraliK)  16-Sept-1996

Revision History:

--*/

#include "inetdbgp.h"



/************************************************************
 * Scheduler Related functions
 ************************************************************/

// Keep this array in synch with the SCHED_ITEM_STATE enumeration

char * g_rgchSchedState[] = {
    "SiError",
    "SiIdle",
    "SiActive",
    "SiActivePeriodic",
    "SiCallbackPeriodic",
    "SiToBeDeleted",
    "SiMaxItems"
};

#define LookupSchedState( ItemState ) \
            ((((ItemState) >= SI_ERROR) && ((ItemState) <= SI_MAX_ITEMS)) ? \
             g_rgchSchedState[ (ItemState)] : "<Invalid>")


// Initialize class static members
CSchedData*       CSchedData::sm_psd = NULL;
CLockedDoubleList CSchedData::sm_lstSchedulers;
LONG              CSchedData::sm_nID = 0;
LONG              CThreadData::sm_nID = 1000;
LONG      SCHED_ITEM::sm_lSerialNumber = SCHED_ITEM::SERIAL_NUM_INITIAL_VALUE;


VOID
PrintSchedItem( SCHED_ITEM * pschDebuggee,
                SCHED_ITEM * pschDebugger,
                CHAR Verbosity);

VOID
PrintThreadDataThunk( PVOID ptdDebuggee,
                      PVOID ptdDebugger,
                      CHAR  chVerbosity,
                      DWORD iThunk);

VOID
PrintThreadData( CThreadData* ptdDebuggee,
                 CThreadData* ptdDebugger,
                 CHAR chVerbosity);

VOID
PrintSchedData( CSchedData* psdDebuggee,
                CSchedData* psdDebugger,
                CHAR chVerbosity);

VOID
PrintSchedDataThunk( PVOID psdDebuggee,
                      PVOID psdDebugger,
                      CHAR  chVerbosity,
                      DWORD iThunk);

VOID
DumpSchedItemList(
    CHAR Verbosity
    );

VOID
DumpSchedulersList(
    CHAR Verbosity
    );



DECLARE_API( sched )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    SCHED_ITEM    sch( NULL, NULL, NULL);
    SCHED_ITEM *  psch;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "sched" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "sched" );
            return;
        }
        else if ( *lpArgumentString == 'l' )
        {
            DumpSchedItemList( lpArgumentString[1] );
            return;
        }
        else if ( *lpArgumentString == 's' )
        {
            DumpSchedulersList( lpArgumentString[1] );
            return;
        }
        else if ( *lpArgumentString == 'S' )
        {
            CSchedData* psd = (CSchedData*) GetExpression(++lpArgumentString);

            if ( !psd )
            {
                dprintf( "inetdbg.sched: Unable to evaluate \"%s\"\n",
                         lpArgumentString );

                return;
            }

            DEFINE_CPP_VAR(CSchedData, sd);
            move(sd, psd);

            PrintSchedData(psd, GET_CPP_VAR_PTR(CSchedData, sd), '2');
            return;
        }
        else if ( *lpArgumentString == 'T' )
        {
            CThreadData* ptd =(CThreadData*) GetExpression(++lpArgumentString);

            if ( !ptd )
            {
                dprintf( "inetdbg.sched: Unable to evaluate \"%s\"\n",
                         lpArgumentString );

                return;
            }

            DEFINE_CPP_VAR(CThreadData, td);
            move(td, ptd);

            PrintThreadData(ptd, GET_CPP_VAR_PTR(CThreadData, td), '2');
            return;
        }
    } // while

    //
    //  Treat the argument as the address of a SCHED_ITEM
    //

    psch = (SCHED_ITEM * ) GetExpression( lpArgumentString );

    if ( !psch )
    {
        dprintf( "inetdbg.sched: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( sch, psch );
    PrintSchedItem( psch, &sch, '2' );

    return;
} // DECLARE_API( sched )


VOID
PrintSchedItem( SCHED_ITEM  * pschDebuggee,
                SCHED_ITEM * pschDebugger,
                CHAR chVerbosity)
{
    if ( chVerbosity >= '0' )
    {
        //  Print all with one line summary info
        dprintf( "%p: Serial=%-6d  Flink=%p, Blink=%p, State=%s\n",
                 pschDebuggee,
                 pschDebugger->_dwSerialNumber,
                 pschDebugger->_ListEntry.Flink,
                 pschDebugger->_ListEntry.Blink,
                 LookupSchedState( pschDebugger->_siState) );
    }

    if ( chVerbosity >= '1')
    {
        UCHAR szSymFnCallback[MAX_SYMBOL_LEN];
        ULONG_PTR offset;

        GetSymbol((ULONG_PTR) pschDebugger->_pfnCallback,
                  szSymFnCallback, &offset);

        if (!*szSymFnCallback)
            sprintf((char*) szSymFnCallback, "%p()",
                    pschDebugger->_pfnCallback);

        dprintf( "\tSignature    = '%c%c%c%c'    Context     = %08p\n"
                 "\tmsecInterval = %8d  msecExpires = %I64d\n"
                 "\tpfnCallBack  = %s\n",
                 DECODE_SIGNATURE(pschDebugger->_Signature),
                 pschDebugger->_pContext,
                 pschDebugger->_msecInterval,
                 pschDebugger->_msecExpires,
                 szSymFnCallback
                 );
    }

    return;
} // PrintSchedItem()



VOID
PrintSchedItemThunk( PVOID pschDebuggee,
                     PVOID pschDebugger,
                     CHAR  chVerbosity,
                     DWORD iThunk)
{
    if ( ((SCHED_ITEM * )pschDebugger)->_Signature != SIGNATURE_SCHED_ITEM) {

        dprintf( "SCHED_ITEM(%p) signature %08lx doesn't"
                 " match expected %08lx\n",
                 pschDebuggee,
                 ((SCHED_ITEM * )pschDebugger)->_Signature,
                 SIGNATURE_SCHED_ITEM
                 );
        return;
    }

    PrintSchedItem( (SCHED_ITEM*) pschDebuggee,
                    (SCHED_ITEM*) pschDebugger,
                    chVerbosity);

} // PrintSchedItemThunk()


VOID
PrintThreadData( CThreadData* ptdDebuggee,
                 CThreadData* ptdDebugger,
                 CHAR chVerbosity)
{
    if ( chVerbosity >= '0' )
    {
        //  Print all with one line summary info
        dprintf( "CThreadData %p: ID=%-6d, Flink=%p, Blink=%p\n",
                 ptdDebuggee,
                 ptdDebugger->m_nID,
                 ptdDebugger->m_leThreads.Flink,
                 ptdDebugger->m_leThreads.Blink
                 );
    }

    if ( chVerbosity >= '1')
    {
        dprintf( "\tm_dwSignature   = '%c%c%c%c'   m_psdOwner      = %08lp\n"
                 "\tm_hevtShutdown  = %08lp  m_hThreadSelf   = %08lx.\n"
                 ,
                 DECODE_SIGNATURE(ptdDebugger->m_dwSignature),
                 ptdDebugger->m_psdOwner,
                 ptdDebugger->m_hevtShutdown,
                 ptdDebugger->m_hThreadSelf
                 );
    }

    return;
} // PrintThreadData()



VOID
PrintThreadDataThunk( PVOID ptdDebuggee,
                      PVOID ptdDebugger,
                      CHAR  chVerbosity,
                      DWORD iThunk)
{
    if (((CThreadData*) ptdDebugger)->m_dwSignature != SIGNATURE_THREADDATA)
    {
        dprintf( "CThreadData(%08p) signature %08lx doesn't"
                 " match expected: %08lx\n",
                 ptdDebuggee,
                 ((CThreadData * )ptdDebugger)->m_dwSignature,
                 SIGNATURE_THREADDATA
                 );
        return;
    }

    PrintThreadData( (CThreadData *) ptdDebuggee,
                     (CThreadData *) ptdDebugger,
                     chVerbosity);

} // PrintThreadDataThunk()


VOID
PrintSchedData( CSchedData* psdDebuggee,
                CSchedData* psdDebugger,
                CHAR chVerbosity)
{
    if ( chVerbosity >= '0' )
    {
        //  Print all with one line summary info
        dprintf( "CSchedData %p: ID=%d, Flink=%p, Blink=%p\n",
                 psdDebuggee,
                 psdDebugger->m_nID,
                 psdDebugger->m_leGlobalList.Flink,
                 psdDebugger->m_leGlobalList.Blink
                 );
    }

    if ( chVerbosity >= '1')
    {
        dprintf( "\tm_dwSignature   = '%c%c%c%c'    m_lstItems      = %08lp\n"
                 "\tm_lstThreads    = %08lp  m_cRefs         = %d\n"
                 "\tm_hevtNotify    = %08lp  m_fShutdown     = %s\n"
                 "\tm_pachSchedItems= %08lp\n"
                 ,
                 DECODE_SIGNATURE(psdDebugger->m_dwSignature),
                 &psdDebuggee->m_lstItems,
                 &psdDebuggee->m_lstThreads,
                 psdDebugger->m_cRefs,
                 psdDebugger->m_hevtNotify,
                 BoolValue(psdDebugger->m_fShutdown),
                 psdDebugger->m_pachSchedItems
                 );
    }

    if ( chVerbosity >= '2')
    {
        dprintf("Threads\n");

        EnumLinkedList((LIST_ENTRY*)&psdDebuggee->m_lstThreads.m_list.m_leHead,
                       PrintThreadDataThunk,
                       chVerbosity,
                       sizeof(CThreadData),
                       FIELD_OFFSET( CThreadData, m_leThreads)
                       );
    }

    return;
} // PrintSchedData()



VOID
PrintSchedDataThunk( PVOID psdDebuggee,
                     PVOID psdDebugger,
                     CHAR  chVerbosity,
                     DWORD iThunk)
{
    if (((CSchedData*) psdDebugger)->m_dwSignature != SIGNATURE_SCHEDDATA)
    {
        dprintf( "CSchedData(%08p) signature %08lx doesn't"
                 " match expected: %08lx\n",
                 psdDebuggee,
                 ((CSchedData*) psdDebugger)->m_dwSignature,
                 SIGNATURE_SCHEDDATA
                 );
        return;
    }

    PrintSchedData( (CSchedData*) psdDebuggee,
                    (CSchedData*) psdDebugger,
                    chVerbosity);

} // PrintSchedDataThunk()




VOID
DumpSchedItemList(
    CHAR Verbosity
    )
{
    CSchedData** ppsd = (CSchedData**) GetExpression(
                        IisRtlVar("&%s!CSchedData__sm_psd"));
    if (NULL == ppsd)
    {
        dprintf("Unable to get %s\n", IisRtlVar("&%s!CSchedData__sm_psd"));
        return;
    }

    CSchedData* psd;
    move(psd, ppsd);

    DEFINE_CPP_VAR( CSchedData, sd);
    move(sd, psd);

    PrintSchedData(psd, GET_CPP_VAR_PTR(CSchedData, sd), Verbosity);
    dprintf("\n");

    EnumLinkedList( (LIST_ENTRY*) &psd->m_lstItems.m_list.m_leHead,
                    PrintSchedItemThunk,
                    Verbosity,
                    sizeof( SCHED_ITEM),
                    FIELD_OFFSET( SCHED_ITEM, _ListEntry)
                    );
    return;
} // DumpSchedItemList()



VOID
DumpSchedulersList(
    CHAR Verbosity
    )
{
    CLockedDoubleList* plstSchedulers = (CLockedDoubleList*) GetExpression(
                        IisRtlVar("&%s!CSchedData__sm_lstSchedulers"));

    if (NULL == plstSchedulers)
    {
        dprintf("Unable to get %s\n",
                IisRtlVar("&%s!CSchedData__sm_lstSchedulers"));
        return;
    }

    EnumLinkedList( (LIST_ENTRY*) &plstSchedulers->m_list.m_leHead,
                    PrintSchedDataThunk,
                    Verbosity,
                    sizeof(CSchedData),
                    FIELD_OFFSET( CSchedData, m_leGlobalList)
                    );
    return;
} // DumpSchedulersList()




/************************************************************
 * Allocation cache Related functions
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig)
{}

ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{}


VOID
PrintAcacheHandler( IN ALLOC_CACHE_HANDLER * pachDebuggee,
                    IN ALLOC_CACHE_HANDLER * pachDebugger,
                    IN CHAR chVerbostity);

VOID
DumpAcacheGlobals( VOID );


VOID
DumpAcacheList(
    CHAR Verbosity
    );


DECLARE_API( acache )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    ALLOC_CACHE_HANDLER * pach;

    //
    // Since ALLOC_CACHE_HANDLER is a C++ object with a non-void
    //  constructor, we will have to copy the contents to a temporary
    //  buffer and cast the value appropriately.
    //
    CHAR                 achItem[sizeof(ALLOC_CACHE_HANDLER)];
    ALLOC_CACHE_HANDLER * pachCopy = (ALLOC_CACHE_HANDLER *) achItem;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "acache" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "acache" );
            return;
        }

        if ( *lpArgumentString == 'g' )
        {
            DumpAcacheGlobals();
            return;
        }

        if ( *lpArgumentString == 'l' ) {

            DumpAcacheList( lpArgumentString[1] );
            return;
        }

    } // while

    //
    //  Treat the argument as the address of an AtqContext
    //

    dprintf( "inetdbg.acache: Trying to access %s\n",
             lpArgumentString );

    pach = (ALLOC_CACHE_HANDLER * ) GetExpression( lpArgumentString );

    if ( !pach )
    {
        dprintf( "inetdbg.acache: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    moveBlock( achItem, pach, sizeof(ALLOC_CACHE_HANDLER));
    PrintAcacheHandler( pach, pachCopy, '2' );

    return;
} // DECLARE_API( acache )


VOID
PrintAcacheHandler( ALLOC_CACHE_HANDLER * pachDebuggee,
                    ALLOC_CACHE_HANDLER * pachDebugger,
                    CHAR  chVerbosity)
{
    if ( chVerbosity >= '0') {
        dprintf(
                "ACACHE[%8p] "
                , pachDebuggee
                );
        dstring( "Name", (PVOID) pachDebugger->m_pszName, 40);
    }

    if ( chVerbosity >= '1') {
        dprintf("\t(Size=%d bytes, Concurrency=%d, Threshold=%u)"
                " FillPattern=%08lX\n"
                "\tTotal=%d."
                " Calls:(Alloc=%d, Free=%d)"
                " FreeEntries=%d. Heap=%p.\n"
                ,
                pachDebugger->m_acConfig.cbSize,
                pachDebugger->m_acConfig.nConcurrency,
                pachDebugger->m_acConfig.nThreshold,
                pachDebugger->m_nFillPattern,
                pachDebugger->m_nTotal,
                pachDebugger->m_nAllocCalls, pachDebugger->m_nFreeCalls,
                pachDebugger->m_nFreeEntries, pachDebugger->m_hHeap
                );
    }

    return;
} // PrintAcacheHandler()

VOID
PrintAcacheHandlerThunk( PVOID pachDebuggee,
                         PVOID pachDebugger,
                         CHAR  chVerbosity,
                         DWORD iCount)
{
    dprintf( "[%d] ", iCount);
    PrintAcacheHandler( (ALLOC_CACHE_HANDLER *) pachDebuggee,
                        (ALLOC_CACHE_HANDLER *) pachDebugger,
                        chVerbosity);
    return;
} // PrintAcacheHandlerThunk()

VOID
DumpAcacheGlobals( VOID )
{
    LIST_ENTRY * pachList;
    LIST_ENTRY   achList;

    dprintf("Allocation Cache Globals:\n");

    pachList = (LIST_ENTRY *)
        GetExpression( IisRtlVar("&%s!ALLOC_CACHE_HANDLER__sm_lItemsHead"));

    if ( NULL == pachList) {

        dprintf( " Unable to get Allocation cache list object, %s\n",
                 IisRtlVar("&%s!ALLOC_CACHE_HANDLER__sm_lItemsHead"));
        return;
    }

    move( achList, pachList);

    dprintf( " AllocCacheList  Flink = %08p  Blink = %08p\n",
             achList.Flink, achList.Blink
             );

    dprintf("\tsizeof(ALLOC_CACHE_HANDLER) = %d\n",
            sizeof(ALLOC_CACHE_HANDLER));
    return;
} // DumpAcacheGlobals()




VOID
DumpAcacheList(
    CHAR Verbosity
    )
{
    LIST_ENTRY *         pachListHead;

    pachListHead = (LIST_ENTRY *)
        GetExpression( IisRtlVar("&%s!ALLOC_CACHE_HANDLER__sm_lItemsHead"));

    if ( NULL == pachListHead) {

        dprintf( " Unable to get Alloc Cache List object, %s\n",
                 IisRtlVar("&%s!ALLOC_CACHE_HANDLER__sm_lItemsHead"));
        return;
    }

    EnumLinkedList( pachListHead, PrintAcacheHandlerThunk, Verbosity,
                    sizeof( ALLOC_CACHE_HANDLER),
                    FIELD_OFFSET( ALLOC_CACHE_HANDLER, m_lItemsEntry)
                    );
    return;
} // DumpAcacheList()




/************************************************************
 * Dump Symbols from stack
 ************************************************************/


DECLARE_API( ds )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    symbols on the stack.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR startingAddress;
    ULONG_PTR stack;
    DWORD i;
    UCHAR symbol[MAX_SYMBOL_LEN];
    ULONG_PTR offset;
    PCHAR format;
    BOOL validSymbolsOnly = FALSE;
    MODULE_INFO moduleInfo;


    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '-' ) {
        lpArgumentString++;
        switch( *lpArgumentString ) {
        case 'v' :
        case 'V' :
            validSymbolsOnly = TRUE;
            lpArgumentString++;
            break;

        default :
            PrintUsage( "ds" );
            return;
        }
    }

    while( *lpArgumentString == ' ' ) {
        lpArgumentString++;
    }

    //
    // By default, start at the current stack location. Otherwise,
    // start at the given address.
    //

    if( !*lpArgumentString ) {
#if defined(_X86_)
        lpArgumentString = "esp";
#elif defined(_AMD64_)
        lpArgumentString = "rsp";
#elif defined(_IA64_)
        lpArgumentString = "sp";
#else
#error "unsupported CPU"
#endif
    }

    startingAddress = GetExpression( lpArgumentString );

    if( startingAddress == 0 ) {

        dprintf(
            "!inetdbg.ds: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Ensure startingAddress is DWORD aligned.
    //

    startingAddress &= ~(sizeof(ULONG_PTR)-1);

    //
    // Read the stack.
    //

    for( i = 0 ; i < NUM_STACK_SYMBOLS_TO_DUMP ; startingAddress += sizeof(ULONG_PTR) ) {

        if( CheckControlC() ) {
            break;
        }

        if( ReadMemory(
                startingAddress,
                &stack,
                sizeof(stack),
                NULL
                ) ) {

            GetSymbol(
                stack,
                symbol,
                &offset
                );

            if( symbol[0] == '\0' ) {
                if( FindModuleByAddress(
                        stack,
                        &moduleInfo
                        ) ) {
                    strcpy( (CHAR *)symbol, moduleInfo.FullName );
                    offset = DIFF(stack - moduleInfo.DllBase);
                }
            }

            if( symbol[0] == '\0' ) {
                if( validSymbolsOnly ) {
                    continue;
                }
                format = "%p : %p\n";
            } else
            if( offset == 0 ) {
                format = "%p : %p : %s\n";
            } else {
                format = "%p : %p : %s+0x%lx\n";
            }

            dprintf(
                format,
                startingAddress,
                stack,
                symbol,
                (DWORD)offset
                );

            i++;

        } else {

            dprintf(
                "!inetdbg.ds: cannot read memory @ %p\n",
                startingAddress
                );

            return;

        }

    }

    dprintf(
        "!inetdbg.ds %s%lx to dump next block\n",
        validSymbolsOnly ? "-v " : "",
        startingAddress
        );

} // DECLARE_API( ds )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgthunk.cxx ===
/*++


   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       dbgthunk.cxx

   Abstract:
       This module defines all thunks for inlined functions, so that the
       debugger extension DLL can be peacefully linked.

   Author:

       Murali R. Krishnan    ( MuraliK )     24-Aug-1997

   Environment:
       Debugging Mode - NTSD Debugger Extension DLL

   Project:

       IIS Debugger Extensions DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "inetdbgp.h"

# undef DBG_ASSERT

# define minSize(a, b)  (((a) < (b)) ? (a) : (b))


#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Utility Functions
************************************************************/

VOID
dstring( CHAR * pszName, PVOID pvString, DWORD cbLen)
/*++
  Description:
    This function reads the data from the debuggee process at
    address [pvString] for specified length [cbLen] and echoes
    the string back on the debugger window.

  Arguments:
    pszName - pointer to string containing the name of the string read
    pvString - pointer to VOID specifying the location of the string
               in the debugee process
    cbLen   - count of bytes to be read at [pvString]

  Returns:
     None
--*/
{
    CHAR rgchString[10240];
    DWORD cLength = minSize( cbLen, sizeof(rgchString) -1);

    //
    // Read the data block from the debuggee process into local buffer
    //
    moveBlock( rgchString, pvString, cLength);

    rgchString[cLength] = '\0'; // terminate the string buffer
    dprintf( "%s = %s\n", pszName, rgchString);

    return;
} // dstring()



VOID
PrintLargeInteger( CHAR * pszName, LARGE_INTEGER * pli)
{
    CHAR  szLargeInt[100];

    RtlLargeIntegerToChar( pli,  // large integer location
                           10,   // base for conversion
                           sizeof(szLargeInt),
                           szLargeInt );
    dprintf( " %30s = %s\n", pszName, szLargeInt);
    return;

} // PrintLargeInteger()

VOID
Print2Dwords( CHAR * pszN1, DWORD d1,
              CHAR * pszN2, DWORD d2
              )
{
    dprintf("    %25s =%8d  %25s =%8d\n",
             pszN1, d1,
             pszN2, d2
             );
    return;
} // Print2Dwords()



BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    )
/*++
  Description:
    This function iterates over the NT's standard LIST_ENTRY structure
    (doubly linked circular list with header) and makes callbacks for
    objects found on the list.

  Arguments:
    pListHead  - pointer to List head in the debugee process
    pfnListEnumerator - pointer to callback function for the object on the list
    chVerbosity - character indicating the verbosity level desired
    cbSizeOfStructure - count of bytes of object's size
    cbListEntryOffset - count of bytes of offset of the List entry structure
                           inside the containing object

  Returns:
     TRUE on successful enumeration
     FALSE on failure
--*/
{
# define MAX_STRUCTURE_SIZE        (10240)
    CHAR           rgch[MAX_STRUCTURE_SIZE];
    PVOID          pvDebuggee = NULL;
    PVOID          pvDebugger = (PVOID ) rgch;

    LIST_ENTRY     leListHead;
    LIST_ENTRY *   pListEntry;

    DWORD          cItems = 0;

    if ( NULL == pListHead) {
        dprintf( "Invalid List given \n");
        return (FALSE);
    }

    if ( MAX_STRUCTURE_SIZE < cbSizeOfStructure) {
        dprintf( "Given size for structure %d exceeds default max %d bytes\n",
                 cbSizeOfStructure, MAX_STRUCTURE_SIZE);
        return (FALSE);
    }

    // make a local copy of the list head for navigation purposes
    MoveWithRet( leListHead, pListHead, FALSE);

    for ( pListEntry  = leListHead.Flink;
          pListEntry != pListHead;
          )
    {
        if ( CheckControlC() )
        {
            return (FALSE);
        }

        pvDebuggee = (PVOID ) ((PCHAR ) pListEntry - cbListEntryOffset);

        // make a local copy of the debuggee structure
        MoveBlockWithRet( rgch, pvDebuggee, cbSizeOfStructure, FALSE);

        cItems++;

        if( pfnListEnumerator ) {
            (*pfnListEnumerator)( pvDebuggee, pvDebugger, chVerbosity, cItems);
            dprintf( "\n");
        }

        MoveWithRet( pListEntry, &pListEntry->Flink, FALSE );
    } // for all linked list entries

    dprintf( "%d entries traversed\n", cItems );

    return (TRUE);
} // EnumLinkedList()



/*++
  Description:
    COM objects registered as LocalServer result in running in a separate
    process. The base process communicates with these COM objects using RPC.
    It is often required to find the process id of destination process.


    The function cracks the process id of the target process given the first
    parameter to the function
       ole32!CRpcChannelBuffer__SendReceive()

  Argument:
  arg1 - pointer to string containing the parameter that is the hex-value
          of the RPC structure's location (which is the first param of
          function ole32!CRpcChannelBuffer__SendReceive())

 Standard NTSD parameters:
    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

  Returns:
    None

--*/
DECLARE_API( rpcoop )
{
    DWORD *   pRpcParam1;
    DWORD    dwContent;

    INIT_API();
#if _WIN64
    dprintf("inetdbg.rpcoop: Not functional for 64bit as of yet");
#else
    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "rpcoop" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "rpcoop" );
            return;
        }

    } // while

    //
    //  Treat the argument as the param1 of the RPC function
    //

    pRpcParam1 = (DWORD * ) GetExpression( lpArgumentString );

    if ( !pRpcParam1 )
    {
        dprintf( "inetdbg.rpcoop: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    //
    // get the contents of the memory at seventh DWORD to pRpcParam1
    // ie. get [pRpcParam1 + 0x6]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    move( dwContent, pRpcParam1 + 0x6 );

    //
    // dwContent now contains the address of another structure
    //   that carries the remote process Id
    // get the contents of the memory at seventh DWORD to dwContent
    // ie. get [dwContent + 9]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    DWORD  dwProcessId;

    move( dwProcessId, ((LPDWORD ) dwContent) + 9);

    //
    // dump the process id to debugger screen
    //
    dprintf("\tRPC process ID = %d (0x%x)\n", dwProcessId, dwProcessId);
#endif
    return;
} // DECLARE_API( rpcoop )

DECLARE_API( llc )

/*++

Routine Description:

    This function is called as an NTSD extension to count the LIST_ENTRYs
    on a linked list.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PLIST_ENTRY remoteListHead;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "llc" );
        return;
    }

    //
    // Get the list head.
    //

    remoteListHead = (PLIST_ENTRY)GetExpression( lpArgumentString );

    if( remoteListHead == NULL ) {
        dprintf( "!llc: cannot evaluate %s\n", lpArgumentString );
        return;
    }

    //
    // Let the enumerator do the dirty work.
    //

    EnumLinkedList(
        remoteListHead,
        NULL,
        0,
        sizeof(LIST_ENTRY),
        0
        );

}   // DECLARE_API( llc )


/************************************************************
 *  FAKE Functions
 *
 *  Fake the definitions of certain functions that belong only
 *   in the local compilation of w3svc & infocomm dlls
 *
 ************************************************************/

extern "C" {

    //
    // NTSD Extensions & CRTDLL likes to have the main() function
    // Let us throw this in as well, while we are in the business
    // of faking several other functions :)
    //

void _cdecl main( void )
{
    ;
}

}

__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
{ return (0); }


BOOL BUFFER::GetNewStorage( UINT cbRequested ) { return (TRUE);}
BOOL BUFFER::ReallocStorage( UINT cbRequested ) { return (TRUE);}

VOID STR::AuxInit( const BYTE * pInit ) {}
BOOL STR::AuxAppend( const BYTE * pInit,
                     UINT cbStr, BOOL fAddSlop )
{ return (TRUE);}

VOID MULTISZ::AuxInit( const BYTE * pInit ) {}
BOOL MULTISZ::AuxAppend( const BYTE * pInit,
                     UINT cbStr, BOOL fAddSlop )
{ return (TRUE);}


DWORD HASH_TABLE::CalculateHash( IN LPCSTR pszKey, IN DWORD cchKey) const
{ return ( 0); }
VOID HASH_TABLE::Cleanup( VOID) {}
HT_ELEMENT * HASH_TABLE::Lookup( IN LPCSTR pszKey, IN DWORD cchKey)
{ return ( NULL); }

DWORD
IIS_SERVER_INSTANCE::UpdateBindingsHelper(
                                          IN BOOL IsSecure
                                          )
{ return (NO_ERROR); }

DWORD
IIS_SERVER_INSTANCE::UnbindHelper(
                                  IN PLIST_ENTRY BindingListHead
                                  )
{ return ( NO_ERROR); }

BOOL IIS_SERVICE::LoadStr( OUT STR & str, IN  DWORD dwResId, IN BOOL fForceEnglish ) const
{ return ( TRUE); }

DWORD
IIS_SERVICE::UpdateServiceStatus(IN DWORD State,
                                IN DWORD Win32ExitCode,
                                IN DWORD CheckPoint,
                                IN DWORD WaitHint )
{ return ( NO_ERROR); }

BOOL   IIS_SERVICE::RemoveServerInstance(
                                         IN IIS_SERVER_INSTANCE * pInstance
                                         )
{ return ( FALSE); }


INET_PARSER::INET_PARSER( char * pszStart) {}
INET_PARSER::~INET_PARSER(VOID) {}

CHAR * INET_PARSER::AuxEatWhite(VOID) { return ( NULL); }
CHAR * INET_PARSER::AuxEatNonWhite(CHAR ch) { return ( NULL); }
CHAR * INET_PARSER::AuxSkipTo(CHAR ch) { return ( NULL); }

VOID INET_PARSER::TerminateToken( CHAR ch) {}
VOID INET_PARSER::RestoreToken( VOID ) {}
VOID INET_PARSER::TerminateLine( VOID ) {}
VOID INET_PARSER::RestoreLine( VOID ) {}
CHAR * INET_PARSER::NextToken( CHAR ) { return (NULL); }

AC_RESULT ADDRESS_CHECK::CheckName( LPSTR pName ) { return ( AC_NO_LIST); }
VOID TS_DIRECTORY_INFO::CleanupThis(VOID) {};
VOID * TCP_AUTHENT::QueryPrimaryToken(VOID) { return (NULL); }


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgwmif.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

       dbgwmif.cxx

   Abstract:

       This module contains the NTSD Debugger extensions for the
       W3SVC DLL(WAMINFO and WAM_DICTATOR data structure)

   Author:

       Lei Jin    ( leijin )     16-09-1997

   Environment:
       Debugger Mode - inside NT command line debuggers

   Project:

       Internet Server Debugging DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#include "inetdbgp.h"
#include "wamexec.hxx"
// include stddef.h for macro offsetof.
#include "stddef.h"


/************************************************************
 *    Definitions of Variables & Macros
 ************************************************************/


/************************************************************
 *    Functions
 ************************************************************/
CHAR * szWamInfoState[] =
	{
	"WIS_START",
	"WIS_RUNNING",
	"WIS_REPAIR",
	"WIS_PAUSE",
	"WIS_CPUPAUSE",
	"WIS_ERROR",
	"WIS_SHUTDOWN",
	"WIS_END",
	"WIS_MAX_STATE"
	};

VOID
DumpWamDictator(
BOOL fDumpDyingList = FALSE
    );

VOID
DumpWamInfo(
CWamInfo *pWamInfoOriginal,
CWamInfo *pWamInfo
    );

VOID
DumpWamInfoOutProc(
CWamInfoOutProc *pOriginal,
CWamInfoOutProc *pWamInfoOutProc
    );

VOID
DumpOOPList(
LIST_ENTRY * pListHead
    );

VOID
DumpDyingList(
LIST_ENTRY * pListHead
    );

DECLARE_API( waminfo )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "waminfo" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        switch ( *lpArgumentString )  {

        case 'g':
            {
                lpArgumentString++;

                if (*lpArgumentString == '1')
                    {
                    DumpWamDictator(TRUE);
                    }
                else
                    {
                    DumpWamDictator(FALSE);
                    }
                break;
            }
        case 'd':
            {
                CWamInfo       * pWamInfo = NULL;
                DEFINE_CPP_VAR(CWamInfo, WamInfo);
                // Arguments:  -d <WamInfoAddr>

                pWamInfo = ((CWamInfo * )GetExpression( lpArgumentString + 2));
                if ( !pWamInfo )
                    {

                    dprintf( "inetdbg: Unable to evaluate "
                             "WaminfoAddr \"%s\"\n",
                             lpArgumentString );

                    break;
                    }

                move(WamInfo, pWamInfo);
                DumpWamInfo(pWamInfo, GET_CPP_VAR_PTR( CWamInfo, WamInfo));
                break;
            }
        case 'l':
            {
            LIST_ENTRY * pListEntry;
            // Arguments:  -l <OOPListHeadAddr>

            pListEntry = ((LIST_ENTRY * )GetExpression( lpArgumentString + 2));
            if ( !pListEntry )
                {

                dprintf( "inetdbg: Unable to evaluate "
                         "OOPListHead \"%s\"\n",
                         lpArgumentString );
                }
            else
                {
                DumpOOPList(pListEntry);
                }
            break;
            }

        default:
        case 'h':
            {
                PrintUsage( "waminfo" );
                break;
            }

        } // switch

        return;
    }
} // DECLARE_API( atq )

VOID
DumpWamDictator
(
BOOL fDumpDyingList
)
{
    DEFINE_CPP_VAR(WAM_DICTATOR, WamDictator);
    WAM_DICTATOR ** ppWamDictator = NULL;
    WAM_DICTATOR *  pWamDictatorDebuggee = NULL;
    WAM_DICTATOR *  pWamDictator = NULL;

    ppWamDictator = (WAM_DICTATOR **) GetExpression( "w3svc!g_pWamDictator");

    if (!ppWamDictator)
        {
        dprintf("Unable to get w3svc!g_pWamDictator to dump the Wam Dictator info\n");
        return;
        }

    //
    // From the pointer to pointer to WAM_DICTATOR,
    // obtain the pointer to the WAM_DICTATOR
    //
    moveBlock( pWamDictatorDebuggee, ppWamDictator, sizeof(WAM_DICTATOR * ));

    if (!pWamDictatorDebuggee)
        {
        dprintf("Unable to get w3svc!g_pWamDictator to dump the Wam Dictator info.\n");
        return;
        }

    moveBlock(WamDictator, pWamDictatorDebuggee, sizeof(WAM_DICTATOR));

    pWamDictator = GET_CPP_VAR_PTR(WAM_DICTATOR, WamDictator);
    dprintf("g_pWamDictator    ===>  %08p\n"
            "\tm_pMetabase     = %08p    m_fCleanupInProgress    = %8s\n"
            "\tm_hW3SVC        = %08p    m_dwScheduledId         = %08x\n"
            "\tm_cRef          = %08x    m_fShutdownInProgress   = %8s\n"
            "\tm_DyingListHead.Flink = %08p\n"
            "\tm_DyingListHead.Blink = %08p\n"
            "\n\n"
            ,
            pWamDictatorDebuggee,
            pWamDictator->m_pMetabase,  BoolValue(pWamDictator->m_fCleanupInProgress),
            pWamDictator->m_hW3Svc,     pWamDictator->m_dwScheduledId,
            pWamDictator->m_cRef,       BoolValue(pWamDictator->m_fShutdownInProgress),
            pWamDictator->m_DyingListHead.Flink,
            pWamDictator->m_DyingListHead.Blink
            );

    if (fDumpDyingList)
        {
        DumpDyingList((LIST_ENTRY *)((CHAR *)pWamDictatorDebuggee + offsetof(WAM_DICTATOR, m_DyingListHead)));
        }
    return;
}


VOID
DumpWamInfo
(
CWamInfo *pWamInfoOriginal,
CWamInfo *pWamInfo
)
{
    dprintf("CWamInfo    ===>  %08p\n"
            "\tm_pIWam           = %08p    m_pProcessEntry      = %08p\n"
            "\tm_cRef               = %08x\n"
            "\tm_cTotalRequests  = %08x    m_fEnableTryExcept   = %8s\n"
            "\tm_fInProcess      = %8s    m_fShutdown          = %8s\n"
            "\tp_m_strApplicationPath = %08p\n"
            "\tp_m_WamClsid = %08p\n"
			"\tm_dwState = %12s\n"
			"\tm_dwIWamGipCookie = %08x\n"
            "\n\n",
            pWamInfoOriginal,
            pWamInfo->m_pIWam, pWamInfo->m_pProcessEntry,
            pWamInfo->m_cRef,
            pWamInfo->m_cTotalRequests, 
			BoolValue(pWamInfo->m_fEnableTryExcept),
            BoolValue(pWamInfo->m_fInProcess),
            BoolValue(pWamInfo->m_fShuttingDown),
            pWamInfo->m_strApplicationPath.m_pb,
            (DWORD *)pWamInfoOriginal + offsetof(CWamInfo, m_clsidWam),
			szWamInfoState[pWamInfo->m_dwState],
			pWamInfo->m_dwIWamGipCookie
            );

    if (pWamInfo->m_fInProcess == FALSE)
        {
        CWamInfoOutProc * pWamInfoOutProc = NULL;
        DEFINE_CPP_VAR(CWamInfoOutProc, WamInfoOutProc);

        move(WamInfoOutProc, pWamInfoOriginal);
        DumpWamInfoOutProc((CWamInfoOutProc*)pWamInfoOriginal, GET_CPP_VAR_PTR( CWamInfoOutProc, WamInfoOutProc));
        }
    return;
}

VOID
DumpWamInfoOutProc
(
CWamInfoOutProc *pOriginal,
CWamInfoOutProc *pWamInfoOutProc
)
{
    dprintf("\tm_pCurrentListHead = %08p  m_fInRepair             = %8s\n"
            "\tm_hPermitOOPEvent  = %08p  m_rgOOPWamReqListHead   = %08p\n"
            "\tm_dwThreshold      = %08x  m_dwWamVersion          = %08x\n"
            "\tm_cList            = %08x  m_pwServerInstance      = %08p\n"
            "\tm_idScheduled      = %08x  m_fJobEnabled           = %08s\n"
            "\n\n",
            pWamInfoOutProc->m_pCurrentListHead,
              BoolValue(pWamInfoOutProc->m_fInRepair),
            pWamInfoOutProc->m_hPermitOOPEvent,
              pWamInfoOutProc->m_rgRecoverListHead.Flink,
            pWamInfoOutProc->m_dwThreshold, pWamInfoOutProc->m_dwWamVersion,
            pWamInfoOutProc->m_cRecoverList,
			pWamInfoOutProc->m_pwsiInstance,
			pWamInfoOutProc->m_idScheduled, 
			BoolValue(pWamInfoOutProc->m_fJobEnabled)
            );

    return;
}

VOID
DumpOOPList
(
LIST_ENTRY * pListHead
)
{
    LIST_ENTRY  oopListHead;
    LIST_ENTRY* poopListHead = NULL;
    LIST_ENTRY* pEntry = NULL;
    WAM_REQUEST* pWamRequest = NULL;
    INT iCount;

    DEFINE_CPP_VAR(WAM_REQUEST, WamRequest);

    // move the list header into memory
    move(oopListHead, pListHead);

    poopListHead = GET_CPP_VAR_PTR(LIST_ENTRY, oopListHead);
    for (iCount = 0, pEntry = poopListHead->Flink; pEntry != pListHead; iCount++)
        {
        if (CheckControlC())
            {
            return;
            }

        pWamRequest = CONTAINING_RECORD( pEntry, WAM_REQUEST, m_leOOP);

        if (pWamRequest == NULL)
            {
            dprintf("pWamRequest is NULL, link list breaks\n");
            return;
            }

        dprintf("[%d] WamRequest %08p \n", iCount, pWamRequest);

        move(pEntry, &pEntry->Flink);
        }

    dprintf("End of OOP WamRequest link list\n\n");
    return;
}

VOID
DumpDyingList
(
LIST_ENTRY* pListHead
)
{
    LIST_ENTRY  DyingListHead;
    LIST_ENTRY* pDyingListHead = NULL;
    LIST_ENTRY* pEntry = NULL;
    CWamInfo* pWamInfo = NULL;
    INT iCount;

    dprintf("Dying List head %08p\n", pListHead);

    // move the list header into memory
    move(DyingListHead, pListHead);

    pDyingListHead = GET_CPP_VAR_PTR(LIST_ENTRY, DyingListHead);
    for (iCount = 0, pEntry = pDyingListHead->Flink; pEntry != pListHead; iCount++)
        {
        if (CheckControlC())
            {
            return;
            }

        pWamInfo = CONTAINING_RECORD( pEntry, CWamInfo, ListEntry);

        if (pWamInfo == NULL)
            {
            dprintf("pWamInfo is NULL, link list breaks\n");
            return;
            }

        dprintf("[%d] WamInfo %08p \n", iCount, pWamInfo);

        move(pEntry, &pEntry->Flink);
        }

    dprintf("End of WamInfo Dying link list\n\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgtrace.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    dbgtrace.cxx

Abstract:

    NTSD extension commands for the WMI Tracing mechanism.

Author:

    Jason Andre (jasandre) Jan-1999

Revision History:

--*/

#include "inetdbgp.h"

#ifndef _NO_TRACING_

#define VALID_SIG(Sig) \
    if (SGuidList::TRACESIG != Sig) { \
        char *pSig = (char *) &Sig; \
        dprintf("Corrupt list, wrong signature found (%c%c%c%c)\n", \
                pSig[0], pSig[1], pSig[2], pSig[3]); \
        break; \
    }

#define MAX_ARG_SIZE        80
#define MAX_NUM_ARGS        10

// List of arguments, arbitrarily selected maximum of 10 arguments
struct {
    char szArg[MAX_ARG_SIZE];
    int iArg;
} ArgList[MAX_NUM_ARGS];

int SplitParameters(char *lpArgumentString)
/*++
    This function takes a string of arguments separated by spaces or tabs and
    splits them apart, arbitrarily set to a max of 10 arguments.

    Arguments:
       lpArgumentString     pointer to the argument string.

    Returns:
        int                 number of arguments added to list.

--*/
{
    BOOL fFinished = FALSE;
    int iArgCount = 0;
    // Ensure that the argument list is empty
    RtlZeroMemory(ArgList, sizeof(ArgList));
    // Iterate throught the argument string until we run out of characters
    while (*lpArgumentString && !fFinished && (iArgCount < MAX_NUM_ARGS)) {
        // Skip any leading whitespace, returning if we run out of characters
        while (*lpArgumentString && isspace(*lpArgumentString)) {
            ++lpArgumentString;
        }
        if (!*lpArgumentString)
            break;
        // Look for the end of the current argument
        char *lpStart = lpArgumentString;
        while (*lpArgumentString && !isspace(*lpArgumentString)) {
            ++lpArgumentString;
        }
        // Determine if this is the last parameter in the string
        if (!*lpArgumentString) 
            fFinished = TRUE;
        else
            *lpArgumentString = '\0';
        // Copy the argument to the list
        strncpy(ArgList[iArgCount].szArg, lpStart, MAX_ARG_SIZE);
        // On the off chance this is a number try and convert it, assume it is 
        // in hex
        ArgList[iArgCount].iArg = strtoul(ArgList[iArgCount].szArg, NULL, 16);
        // Next
        ++lpArgumentString;
        ++iArgCount;
    };
    return iArgCount;
}

void DisableTracing(LIST_ENTRY *pListHead)
/*++
    This function iterates through the list of known modules and masks out all 
    the flags other than ODS and Initialize.

    Arguments:
       pListHead        pointer to the start of the list of modules.

    Returns:

--*/
{
    LIST_ENTRY *pListEntry;
    LIST_ENTRY leListHead;
    SGuidList *pGE;
    SGuidList sglGE;
    int fErrorFlag;

    move(leListHead, pListHead);

    for (pListEntry = leListHead.Flink;
         pListEntry != pListHead;)
    {
        pGE = CONTAINING_RECORD(pListEntry,
                                SGuidList,
                                m_leEntry);
        move(sglGE, pGE);
        VALID_SIG(sglGE.dwSig);

        if (sglGE.m_dpData.m_piErrorFlags) {

            move(fErrorFlag, sglGE.m_dpData.m_piErrorFlags);
            // If the error handle is set then we are debugging
            if (fErrorFlag & DEBUG_FLAGS_ANY) {
                // Disable tracing for this module, but not ODS
                fErrorFlag &= DEBUG_FLAG_ODS;
                if (!fErrorFlag)
                    sglGE.m_dpData.m_iControlFlag = 0;
                // Write the new value back to memory
                WriteMemory(sglGE.m_dpData.m_piErrorFlags, &fErrorFlag, sizeof(fErrorFlag), NULL);
                if (!fErrorFlag)
                    WriteMemory(pGE, &sglGE, sizeof(SGuidList), NULL);
            }
        }

        move(pListEntry, &pListEntry->Flink);
    }
}

void SetODS(LIST_ENTRY *pListHead, BOOL fProcessAll, BOOL bEnableODS)
/*++
    This function iterates through the list of known modules and sets the
    ODS flag for each module.

    Arguments:
       pListHead        pointer to the start of the list of modules.

    Returns:

--*/
{
    LIST_ENTRY *pListEntry;
    LIST_ENTRY leListHead;
    SGuidList *pGE;
    SGuidList sglGE;
    int fErrorFlag;

    move(leListHead, pListHead);

    for (pListEntry = leListHead.Flink;
         pListEntry != pListHead;)
    {
        pGE = CONTAINING_RECORD(pListEntry,
                                SGuidList,
                                m_leEntry);
        move(sglGE, pGE);
        VALID_SIG(sglGE.dwSig);

        if (sglGE.m_dpData.m_piErrorFlags) {

            if (fProcessAll || !_strcmpi(ArgList[1].szArg, sglGE.m_dpData.m_rgchLabel)) {
                // Load the error flag into useable memory and change it
                move(fErrorFlag, sglGE.m_dpData.m_piErrorFlags);
                if (bEnableODS) {
                    fErrorFlag |= DEBUG_FLAG_ODS;
                    dprintf("%15s: Enabled ODS\n", sglGE.m_dpData.m_rgchLabel);
                }
                else {
                    fErrorFlag &= ~DEBUG_FLAG_ODS;
                    dprintf("%15s: Disabled ODS\n", sglGE.m_dpData.m_rgchLabel);
                }
                // Write the new value back to memory
                WriteMemory(sglGE.m_dpData.m_piErrorFlags, &fErrorFlag, sizeof(fErrorFlag), NULL);
            }
        }

        move(pListEntry, &pListEntry->Flink);
    }
}

void ShowStatus(LIST_ENTRY *pListHead, BOOL fProcessAll)
/*++
    This function iterates through the list of known modules and displays
    status information for each/a module.

    Arguments:
       pListHead        pointer to the start of the list of modules.
       fProcessAll      boolean specifying whether to show status for all 
                        modules. If this is FALSE then the module we are 
                        after is in ArgList[1]

    Returns:

--*/
{
    LIST_ENTRY *pListEntry;
    LIST_ENTRY leListHead;
    SGuidList *pGE;
    SGuidList sglGE;
    int fErrorFlag = 0;

    move(leListHead, pListHead);

    for (pListEntry = leListHead.Flink;
         pListEntry != pListHead;)
    {
        pGE = CONTAINING_RECORD(pListEntry,
                                SGuidList,
                                m_leEntry);
        move(sglGE, pGE);
        VALID_SIG(sglGE.dwSig);

        if (fProcessAll || !_strcmpi(ArgList[1].szArg, sglGE.m_dpData.m_rgchLabel)) {

            if (sglGE.m_dpData.m_piErrorFlags)
                move(fErrorFlag, sglGE.m_dpData.m_piErrorFlags);

            dprintf("%15s: ", sglGE.m_dpData.m_rgchLabel);
            if (sglGE.m_iInitializeFlags & DEBUG_FLAG_INITIALIZE)
                dprintf("State =    Not Started, ");
            else if (sglGE.m_iInitializeFlags & DEBUG_FLAG_DEFERRED_START)
                dprintf("State = Deferred Start, ");
            else if (!sglGE.m_dpData.m_piErrorFlags)
                dprintf("State =     Not Loaded, ");
            else 
                dprintf("State = %14s, ", 
                        (fErrorFlag & DEBUG_FLAGS_ANY) ? "Tracing" : "Not Tracing");
            dprintf("Level = %d, ",
                    fErrorFlag & DEBUG_FLAG_INFO ? DEBUG_LEVEL_INFO : 
                    fErrorFlag & DEBUG_FLAG_WARN ? DEBUG_LEVEL_WARN : 
                    fErrorFlag & DEBUG_FLAG_ERROR ? DEBUG_LEVEL_ERROR : 0);
            dprintf("Flags = %08X, ", sglGE.m_dpData.m_iControlFlag);
            if (sglGE.m_dpData.m_piErrorFlags)
                dprintf("ODS = %s\n", fErrorFlag & DEBUG_FLAG_ODS ? "TRUE" : "FALSE");
            else
                dprintf("ODS = FALSE\n");
        }

        move(pListEntry, &pListEntry->Flink);
    }
}

void SetActive(LIST_ENTRY *pListHead, BOOL fProcessAll, int iLevel, int iFlags)
/*++
    This function iterates through the list of known modules and sets the
    level and control flags for each/a module.

    Arguments:
       pListHead        pointer to the start of the list of modules.
       fProcessAll      boolean specifying whether to toggle the state for all 
                        modules. If this is FALSE then the module we are 
                        after is in ArgList[1]
       iLevel           the new error level setting for the module
       iFlags           the new control flags for the module

    Returns:

--*/
{
    LIST_ENTRY *pListEntry;
    LIST_ENTRY leListHead;
    SGuidList *pGE;
    SGuidList sglGE;
    int fErrorFlag = 0;

    move(leListHead, pListHead);

    for (pListEntry = leListHead.Flink;
         pListEntry != pListHead;)
    {
        pGE = CONTAINING_RECORD(pListEntry,
                                SGuidList,
                                m_leEntry);
        move(sglGE, pGE);
        VALID_SIG(sglGE.dwSig);

        if (sglGE.m_dpData.m_piErrorFlags) {
            if (fProcessAll || !_strcmpi(ArgList[1].szArg, sglGE.m_dpData.m_rgchLabel)) {
                move(fErrorFlag, sglGE.m_dpData.m_piErrorFlags);
                dprintf("%15s: %sabling tracing... ", 
                        sglGE.m_dpData.m_rgchLabel, 
                        (iLevel == 0) ? "Dis" : "En");
                // Clear everything except the ODS flag
                fErrorFlag &= DEBUG_FLAG_ODS;
                // Enable tracing for this module
                switch (iLevel) {
                case 0: break;
                case DEBUG_LEVEL_ERROR: fErrorFlag |= DEBUG_FLAG_ERROR; break;
                case DEBUG_LEVEL_WARN: fErrorFlag |= DEBUG_FLAG_WARN; break;
                default:
                case DEBUG_LEVEL_INFO: fErrorFlag |= DEBUG_FLAG_INFO; break;
                }
                sglGE.m_dpData.m_iControlFlag = iFlags;
                // Write the new values back to memory
                WriteMemory(sglGE.m_dpData.m_piErrorFlags, &fErrorFlag, sizeof(fErrorFlag), NULL);
                WriteMemory(pGE, &sglGE, sizeof(SGuidList), NULL);
                dprintf("Done!\n");
            }
        }

        move(pListEntry, &pListEntry->Flink);
    }
}

void SetFlags(LIST_ENTRY *pListHead, BOOL fProcessAll, int iControlFlags)
/*++
    This function iterates through the list of known modules and sets the
    control flags for each/a module.

    Arguments:
       pListHead        pointer to the start of the list of modules.
       fProcessAll      boolean specifying whether to set the flags for all 
                        modules. If this is FALSE then the module we are 
                        after is in ArgList[1]
       iControlFlags    the new control flags for the module

    Returns:

--*/
{
    LIST_ENTRY *pListEntry;
    LIST_ENTRY leListHead;
    SGuidList *pGE;
    SGuidList sglGE;
    int fErrorFlag = 0;

    move(leListHead, pListHead);

    for (pListEntry = leListHead.Flink;
         pListEntry != pListHead;)
    {
        pGE = CONTAINING_RECORD(pListEntry,
                                SGuidList,
                                m_leEntry);
        move(sglGE, pGE);
        VALID_SIG(sglGE.dwSig);

        if (fProcessAll || !_strcmpi(ArgList[1].szArg, sglGE.m_dpData.m_rgchLabel)) {
            // Set the new value for the control flag
            sglGE.m_dpData.m_iControlFlag = iControlFlags;
            // Write the new value back to memory
            WriteMemory(pGE, &sglGE, sizeof(SGuidList), NULL);
            dprintf("%15s: Flag = %08X\n", 
                    sglGE.m_dpData.m_rgchLabel, iControlFlags);
        }

        move(pListEntry, &pListEntry->Flink);
    }
}
#endif


DECLARE_API( trace )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

#ifndef _NO_TRACING_

    // Load all the arguments into the ArgumentLst
    int ArgCount = SplitParameters(lpArgumentString);
    // Make sure we have a - something as the first parameters
    if( ArgList[0].szArg[0] != '-' ) {
        PrintUsage( "trace" );
        return;
    }
    // We need to have access to the GuidList before we can do anything so
    // attempt to load it first
    LIST_ENTRY *pGuidList = (LIST_ENTRY *) GetExpression("IisRTL!g_pGuidList");
    if (!pGuidList) {
        dprintf("inetdbg.trace: Unable to access the IISRTL Guid list\n");
        return;
    }
    // Determine which request we have and process it
    switch (tolower(ArgList[0].szArg[1])) 
    {
        // !trace -o <LoggerName> <LoggerFileName> Toggle tracing active state
        case 'o': 
            {
                struct {
                    EVENT_TRACE_PROPERTIES Header;
                    char LogFileName[MAX_PATH];
                } Properties;

                PEVENT_TRACE_PROPERTIES LoggerInfo = &Properties.Header;

                TRACEHANDLE LoggerHandle = 0;
                // Make sure we have the correct number of parameters
                if (ArgCount < 3) {
                    PrintUsage( "trace" );
                    break;
                }
                // We want to create a trace session, so set up all the control buffers
                RtlZeroMemory(&Properties, sizeof(Properties));
                LoggerInfo->Wnode.BufferSize = sizeof(Properties);
                LoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
//                LoggerInfo.LogFileName = ArgList[2].szArg;
//                LoggerInfo.LoggerName = ArgList[1].szArg;
                // See if there is already a session with that name
                ULONG Status = QueryTrace(0, ArgList[1].szArg, LoggerInfo);
                if (ERROR_SUCCESS == Status) {
                    // There was a session of that name already existing, so stop it
                    LoggerHandle = LoggerInfo->Wnode.HistoricalContext;
                    Status = StopTrace((TRACEHANDLE) 0, ArgList[1].szArg, LoggerInfo);
                    // And if successful iterate through all the modules and disable 
                    // tracing, but not ODS
                    if (ERROR_SUCCESS == Status) {
                        DisableTracing(pGuidList);
                    }
                }
                else if (ERROR_WMI_INSTANCE_NOT_FOUND == Status) {
                    if (ArgList[2].szArg != NULL) {
                        strcpy(&Properties.LogFileName[0], ArgList[2].szArg);
                    }
                    LoggerInfo->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                    // There was no sesion of that name, so start one
                    Status = StartTrace(&LoggerHandle, ArgList[1].szArg, LoggerInfo);
                }
                if (ERROR_SUCCESS != Status)
                    dprintf("Failure processing Logger request, Status returned was %d\n", Status);
                else
                    dprintf("Toggled Active state of Trace %s\n", ArgList[1].szArg);
            }
            break;

        // !trace -d <Module_Name|all> 0|1 Set OutputDebugString generation state
        case 'd': 
            {
                // Determine if we are processing one or all modules
                BOOL fProcessAll = !_strcmpi(ArgList[1].szArg, "all");
                // Make sure we have the correct number of parameters
                if (ArgCount < 2) {
                    PrintUsage( "trace" );
                    break;
                }
                // Look for the relevant modules and process them
                SetODS(pGuidList, fProcessAll, (ArgList[2].szArg[0] == '1') ? TRUE : FALSE);
            }
            break;

        // !trace -s [Module_Name] List module status
        case 's': 
            {
                // Determine if we are processing one or all modules
                BOOL fProcessAll = (1 == ArgCount) ? TRUE : !_strcmpi(ArgList[1].szArg, "all");
                // Look for the relevant modules and process them
                ShowStatus(pGuidList, fProcessAll);
            }
            break;

        // !trace -a <Module_Name|all> <LoggerName> [Level] [Flags] Set active state of specified module
        case 'a':
            {
                EVENT_TRACE_PROPERTIES LoggerInfo;
                TRACEHANDLE LoggerHandle = 0;
//                char LogFileName[_MAX_PATH];
                int iLevel = 0;
                int iFlags = 0;
                // Make sure we have the correct number of parameters
                if (ArgCount < 3) {
                    PrintUsage( "trace" );
                    break;
                }
                if (ArgCount > 3)
                    iLevel = ArgList[3].iArg;
                if (ArgCount > 4)
                    iFlags = ArgList[4].iArg;
                // Determine if we are processing one or all modules
                BOOL fProcessAll = !_strcmpi(ArgList[1].szArg, "all");
                // Set up the logger info buffer so that we can get the logger handle 
                // for the specified logger
                RtlZeroMemory(&LoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
                LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
//                RtlZeroMemory(&LogFileName[0], _MAX_PATH);
//                LoggerInfo.LogFileName = &LogFileName[0];
//                LoggerInfo.LoggerName = ArgList[2].szArg;
// Jason: no need to pass in if you do not need the names return
                // Try to get the logger handle
                ULONG Status = QueryTrace(0, ArgList[2].szArg, &LoggerInfo);
                if (Status == ERROR_SUCCESS)
                    LoggerHandle = LoggerInfo.Wnode.HistoricalContext;
                else if (ERROR_WMI_INSTANCE_NOT_FOUND == Status) {
                    dprintf("Failed to find the Logger %s\n"
                            "Please start this logger before activating modules which use it\n", 
                            ArgList[2].szArg);
                    break;
                }
                else {
                    dprintf("Failed to find the Logger %s\n"
                            "Status returned was %d\n", 
                            ArgList[2].szArg, Status);
                    break;
                }
                // Look for the relevant modules and process them
                SetActive(pGuidList, fProcessAll, iLevel, iFlags);
            }
            break;

        // !trace -f <Module_Name|all> <Flag> Set control flag for a specific module
        case  'f': 
            {
                // Make sure we have the correct number of parameters
                if (ArgCount != 3) {
                    PrintUsage( "trace" );
                    break;
                }
                // Determine if we are processing one or all modules
                BOOL fProcessAll = !_strcmpi(ArgList[1].szArg, "all");
                // And then get the control flag to use
                int iControlFlags = ArgList[2].iArg;
                // Now go through all the modules and make the appropriate changes
                SetFlags(pGuidList, fProcessAll, iControlFlags);
            }
            break;

        default:
            PrintUsage( "trace" );
            break;
    };

#else

    dprintf("This feature not supported in this build.\n"
            "Please rebuild without the build flag _NO_TRACING_\n");

#endif

}   // DECLARE_API( trace )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\enumheap.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    enumheap.cxx

Abstract:

    This module implements a heap enumerator.

Author:

    Keith Moore (keithmo) 31-Oct-1997

Revision History:

--*/

#include "inetdbgp.h"


BOOLEAN
EnumProcessHeaps(
    IN PFN_ENUMHEAPS EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heaps in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each heap.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PVOID * heapList;
    ULONG numHeaps;
    ULONG i;
    PEB peb;
    HEAP heap;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    heapList = NULL;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    if( !ReadMemory(
            (ULONG_PTR)basicInfo.PebBaseAddress,
            &peb,
            sizeof(peb),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Allocate an array for the heap pointers, then read them from
    // the debugee.
    //

    numHeaps = peb.NumberOfHeaps;

    heapList = (PVOID *)malloc( numHeaps * sizeof(PVOID) );

    if( heapList == NULL ) {
        goto cleanup;
    }

    if( !ReadMemory(
            (ULONG_PTR)peb.ProcessHeaps,
            heapList,
            numHeaps * sizeof(PVOID),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Now that we have the heap list, we can scan it and invoke the
    // enum proc.
    //

    for( i = 0 ; i < numHeaps ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( !ReadMemory(
                (ULONG_PTR)heapList[i],
                &heap,
                sizeof(heap),
                NULL
                ) ) {
            goto cleanup;
        }

        if( heap.Signature != HEAP_SIGNATURE ) {
            dprintf(
                "Heap @ %08lp has invalid signature %08lx\n",
                heapList[i],
                heap.Signature
                );
            goto cleanup;
        }

        if( !EnumProc(
                Param,
                &heap,
                (PHEAP)heapList[i],
                i
                ) ) {
            break;
        }

    }

    //
    // Success!
    //

    result = TRUE;

cleanup:

    if( heapList != NULL ) {
        free( heapList );
    }

    return result;

}   // EnumProcessHeaps


BOOLEAN
EnumHeapSegments(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPSEGMENTS EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap segments within a heap.

Arguments:

    LocalHeap - Pointer to a local copy of the HEAP to enumerate.

    RemoteHeap - The actual address of the heap in the debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    ULONG i;
    HEAP_SEGMENT heapSegment;

    //
    // Scan the segments.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_SEGMENTS ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( LocalHeap->Segments[i] != NULL ) {

            //
            // Read the segment, invoke the enumeration proc.
            //

            if( !ReadMemory(
                    (ULONG_PTR)LocalHeap->Segments[i],
                    &heapSegment,
                    sizeof(heapSegment),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( heapSegment.Signature != HEAP_SEGMENT_SIGNATURE ) {
                dprintf(
                    "HeapSegment @ %08lp has invalid signature %08lx\n",
                    LocalHeap->Segments[i],
                    heapSegment.Signature
                    );
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &heapSegment,
                    LocalHeap->Segments[i],
                    i
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegments


BOOLEAN
EnumHeapSegmentEntries(
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN PFN_ENUMHEAPSEGMENTENTRIES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap entries in a heap segment.

Arguments:

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT to
        enumerate.

    RemoteHeapSegment - The actual address of hte heap segment in the
        debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PHEAP_ENTRY lastHeapEntry;
    PHEAP_ENTRY remoteHeapEntry;
    HEAP_ENTRY localHeapEntry;
    PHEAP_UNCOMMMTTED_RANGE remoteUCR;
    HEAP_UNCOMMMTTED_RANGE localUCR;

    //
    // Snag the beginning & ending limits of this segment.
    //

    remoteHeapEntry = LocalHeapSegment->FirstEntry;
    lastHeapEntry = LocalHeapSegment->LastValidEntry;

    //
    // If this segment has one or more uncommitted ranges, then
    // read the first one.
    //

    remoteUCR = LocalHeapSegment->UnCommittedRanges;

    if( remoteUCR != NULL ) {
        if( !ReadMemory(
                (ULONG_PTR)remoteUCR,
                &localUCR,
                sizeof(localUCR),
                NULL
                ) ) {
            goto cleanup;
        }
    }

    //
    // Scan the entries.
    //

    while(  remoteHeapEntry < lastHeapEntry )